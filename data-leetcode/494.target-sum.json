[
    {
        "title": "Binary Tree Inorder Traversal",
        "question_content": "Given the root of a binary tree, return the inorder traversal of its nodes' values.\n&nbsp;\nExample 1:\n\nInput: root = [1,null,2,3]\nOutput: [1,3,2]\n\nExample 2:\n\nInput: root = []\nOutput: []\n\nExample 3:\n\nInput: root = [1]\nOutput: [1]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [0, 100].\n\t-100 <= Node.val <= 100\n\n&nbsp;\nFollow up: Recursive solution is trivial, could you do it iteratively?",
        "solutions": [
            {
                "id": 283746,
                "title": "all-dfs-traversals-preorder-inorder-postorder-in-python-in-1-line",
                "content": "![image](https://assets.leetcode.com/users/andvary/image_1556551007.png)\\n\\n```\\ndef preorder(root):\\n  return [root.val] + preorder(root.left) + preorder(root.right) if root else []\\n```\\n\\n```\\ndef inorder(root):\\n  return  inorder(root.left) + [root.val] + inorder(root.right) if root else []\\n```\\n\\n```\\ndef postorder(root):\\n  return  postorder(root.left) + postorder(root.right) + [root.val] if root else []\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef preorder(root):\\n  return [root.val] + preorder(root.left) + preorder(root.right) if root else []\\n```\n```\\ndef inorder(root):\\n  return  inorder(root.left) + [root.val] + inorder(root.right) if root else []\\n```\n```\\ndef postorder(root):\\n  return  postorder(root.left) + postorder(root.right) + [root.val] if root else []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 31213,
                "title": "iterative-solution-in-java-simple-and-readable",
                "content": "    \\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode cur = root;\\n\\n        while(cur!=null || !stack.empty()){\\n            while(cur!=null){\\n                stack.add(cur);\\n                cur = cur.left;\\n            }\\n            cur = stack.pop();\\n            list.add(cur.val);\\n            cur = cur.right;\\n        }\\n\\n        return list;\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Iterator"
                ],
                "code": "    \\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode cur = root;\\n\\n        while(cur!=null || !stack.empty()){\\n            while(cur!=null){\\n                stack.add(cur);\\n                cur = cur.left;\\n            }\\n            cur = stack.pop();\\n            list.add(cur.val);\\n            cur = cur.right;\\n        }\\n\\n        return list;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31381,
                "title": "python-recursive-and-iterative-solutions",
                "content": "        \\n    # recursively\\n    def inorderTraversal1(self, root):\\n        res = []\\n        self.helper(root, res)\\n        return res\\n        \\n    def helper(self, root, res):\\n        if root:\\n            self.helper(root.left, res)\\n            res.append(root.val)\\n            self.helper(root.right, res)\\n     \\n    # iteratively       \\n    def inorderTraversal(self, root):\\n        res, stack = [], []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                return res\\n            node = stack.pop()\\n            res.append(node.val)\\n            root = node.right",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    # recursively\\n    def inorderTraversal1(self, root):\\n        res = []\\n        self.helper(root, res)\\n        return res\\n        \\n    def helper(self, root, res):\\n        if root:\\n            self.helper(root.left, res)\\n            res.append(root.val)\\n            self.helper(root.right, res)\\n     \\n    # iteratively       \\n    def inorderTraversal(self, root):\\n        res, stack = [], []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                return res\\n            node = stack.pop()\\n            res.append(node.val)\\n            root = node.right",
                "codeTag": "Python3"
            },
            {
                "id": 3169549,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n    vector<int> ans;\\n    if (root == NULL) return ans;\\n    vector<int> left = inorderTraversal(root->left);\\n    ans.insert(ans.end(), left.begin(), left.end());\\n    ans.push_back(root->val);\\n    vector<int> right = inorderTraversal(root->right);\\n    ans.insert(ans.end(), right.begin(), right.end());\\n    return ans;\\n}\\n\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        st = []\\n        res = []\\n\\n        while root or st:\\n            while root:\\n                st.append(root)\\n                root = root.left\\n            \\n            root = st.pop()\\n            res.append(root.val)\\n\\n            root = root.right\\n        \\n        return res   \\n```\\n\\n```Java []\\nclass Solution {\\n    private List<Integer> res = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        traverse(root);\\n        return res;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        traverse(root.left);\\n        res.add(root.val);\\n        traverse(root.right);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n    vector<int> ans;\\n    if (root == NULL) return ans;\\n    vector<int> left = inorderTraversal(root->left);\\n    ans.insert(ans.end(), left.begin(), left.end());\\n    ans.push_back(root->val);\\n    vector<int> right = inorderTraversal(root->right);\\n    ans.insert(ans.end(), right.begin(), right.end());\\n    return ans;\\n}\\n\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        st = []\\n        res = []\\n\\n        while root or st:\\n            while root:\\n                st.append(root)\\n                root = root.left\\n            \\n            root = st.pop()\\n            res.append(root.val)\\n\\n            root = root.right\\n        \\n        return res   \\n```\n```Java []\\nclass Solution {\\n    private List<Integer> res = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        traverse(root);\\n        return res;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        traverse(root.left);\\n        res.add(root.val);\\n        traverse(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31231,
                "title": "c-iterative-recursive-and-morris",
                "content": "There are three solutions to this problem.\\n\\n 1. Iterative solution using stack: `O(n)` time and `O(n)` space;\\n 2. Recursive solution: `O(n)` time and `O(n)` space (function call stack);\\n 3. Morris traversal: `O(n)` time and `O(1)` space.\\n\\n**Iterative solution using stack**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        stack<TreeNode*> todo;\\n        while (root || !todo.empty()) {\\n            while (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            }\\n            root = todo.top();\\n            todo.pop();\\n            nodes.push_back(root -> val);\\n            root = root -> right;\\n        }\\n        return nodes;\\n    }\\n};\\n```\\n\\n**Recursive solution**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        inorder(root -> left, nodes);\\n        nodes.push_back(root -> val);\\n        inorder(root -> right, nodes);\\n    }\\n};\\n```\\n\\n**Morris traversal**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        while (root) {\\n            if (root -> left) {\\n                TreeNode* pre = root -> left;\\n                while (pre -> right && pre -> right != root) {\\n                    pre = pre -> right;\\n                }\\n                if (!pre -> right) {\\n                    pre -> right = root;\\n                    root = root -> left;\\n                } else {\\n                    pre -> right = NULL;\\n                    nodes.push_back(root -> val);\\n                    root = root -> right;\\n                }\\n            } else {\\n                nodes.push_back(root -> val);\\n                root = root -> right;\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```\\t\\t",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        stack<TreeNode*> todo;\\n        while (root || !todo.empty()) {\\n            while (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            }\\n            root = todo.top();\\n            todo.pop();\\n            nodes.push_back(root -> val);\\n            root = root -> right;\\n        }\\n        return nodes;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        inorder(root -> left, nodes);\\n        nodes.push_back(root -> val);\\n        inorder(root -> right, nodes);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        while (root) {\\n            if (root -> left) {\\n                TreeNode* pre = root -> left;\\n                while (pre -> right && pre -> right != root) {\\n                    pre = pre -> right;\\n                }\\n                if (!pre -> right) {\\n                    pre -> right = root;\\n                    root = root -> left;\\n                } else {\\n                    pre -> right = NULL;\\n                    nodes.push_back(root -> val);\\n                    root = root -> right;\\n                }\\n            } else {\\n                nodes.push_back(root -> val);\\n                root = root -> right;\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 713539,
                "title": "python-3-all-iterative-traversals-inorder-preorder-postorder-similar-solutions",
                "content": "[Python3] Pre, In, Post Iteratively Summarization\\nIn preorder, the order should be\\n\\nroot -> left -> right\\n\\nBut when we use stack, the order should be reversed:\\n\\nright -> left -> root\\n\\nPre\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:  \\n                    res.append(node.val)\\n                else:  # preorder: root -> left -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n                    stack.append((node, True))\\n        return res\\n```\\n\\n\\nIn inorder, the order should be\\nleft -> root -> right\\n\\nBut when we use stack, the order should be reversed:\\n\\nright -> root -> left\\n\\nIn\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # inorder: left -> root -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node, True))\\n                    stack.append((node.left, False))\\n        return res\\n```\\t\\n\\n\\nIn postorder, the order should be\\nleft -> right -> root\\n\\nBut when we use stack, the order should be reversed:\\n\\nroot -> right -> left\\n\\nPost\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # postorder: left -> right -> root\\n                    stack.append((node, True))\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:  \\n                    res.append(node.val)\\n                else:  # preorder: root -> left -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n                    stack.append((node, True))\\n        return res\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # inorder: left -> root -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node, True))\\n                    stack.append((node.left, False))\\n        return res\\n```\n```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # postorder: left -> right -> root\\n                    stack.append((node, True))\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328601,
                "title": "all-dfs-traversals-preorder-postorder-inorder-in-java-in-5-lines",
                "content": "![image](https://assets.leetcode.com/users/andvary/image_1556551007.png)\\n\\nPreorder: Node -> Left -> Right\\n\\n```\\npublic void preorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  nums.add(root.val);\\n  preorder(root.left, nums);\\n  preorder(root.right, nums);\\n}\\n```\\n\\nInorder : Left -> Node -> Right\\n\\n```\\npublic void inorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  inorder(root.left, nums);\\n  nums.add(root.val);\\n  inorder(root.right, nums);\\n}\\n```\\n\\nPostorder : Left -> Right -> Node\\n\\n```\\npublic void postorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  postorder(root.left, nums);\\n  postorder(root.right, nums);\\n  nums.add(root.val);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic void preorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  nums.add(root.val);\\n  preorder(root.left, nums);\\n  preorder(root.right, nums);\\n}\\n```\n```\\npublic void inorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  inorder(root.left, nums);\\n  nums.add(root.val);\\n  inorder(root.right, nums);\\n}\\n```\n```\\npublic void postorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  postorder(root.left, nums);\\n  postorder(root.right, nums);\\n  nums.add(root.val);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31232,
                "title": "three-methods-to-solve-c",
                "content": "Method 1: Using one stack and the binary tree node will be changed. Easy ,not Practical\\n\\n    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            vector<int> vector;\\n            if(!root)\\n            return vector;\\n            stack<TreeNode *> stack;\\n            stack.push(root);\\n            while(!stack.empty())\\n            {\\n                TreeNode *pNode = stack.top();\\n                if(pNode->left)\\n                {\\n                    stack.push(pNode->left);\\n                    pNode->left = NULL;\\n                }\\n                else\\n                {\\n                    vector.push_back(pNode->val);\\n                    stack.pop();\\n                    if(pNode->right)\\n                    stack.push(pNode->right);\\n                }\\n            }\\n            return vector;\\n        }\\n    };\\n\\nMethod 2: Using one stack and one unordered_map, this will not changed the node. Better\\n\\n    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            vector<int> vector;\\n            if(!root)\\n            return vector;\\n            unordered_map<TreeNode *, bool> map;//left child has been visited:true.\\n            stack<TreeNode *> stack;\\n            stack.push(root);\\n            while(!stack.empty())\\n            {\\n                TreeNode *pNode = stack.top();\\n                if(pNode->left && !map[pNode])\\n                {\\n                    stack.push(pNode->left);\\n                    map[pNode] = true;\\n                }\\n                else\\n                {\\n                    vector.push_back(pNode->val);\\n                    stack.pop();\\n                    if(pNode->right)\\n                    stack.push(pNode->right);\\n                }\\n            }\\n            return vector;\\n        }\\n    };\\n\\nMethod 3: Using one stack  and will not changed the node. Best(at least in this three solutions)\\n\\n    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            vector<int> vector;\\n            stack<TreeNode *> stack;\\n            TreeNode *pCurrent = root;\\n            \\n            while(!stack.empty() || pCurrent)\\n            {\\n                if(pCurrent)\\n                {\\n                    stack.push(pCurrent);\\n                    pCurrent = pCurrent->left;\\n                }\\n                else\\n                {\\n                    TreeNode *pNode = stack.top();\\n                    vector.push_back(pNode->val);\\n                    stack.pop();\\n                    pCurrent = pNode->right;\\n                }\\n            }\\n            return vector;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            vector<int> vector;\\n            if(!root)\\n            return vector;\\n            stack<TreeNode *> stack;\\n            stack.push(root);\\n            while(!stack.empty())\\n            {\\n                TreeNode *pNode = stack.top();\\n                if(pNode->left)\\n                {\\n                    stack.push(pNode->left);\\n                    pNode->left = NULL;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 31228,
                "title": "simple-python-iterative-solution-by-using-a-visited-flag-o-n-56ms",
                "content": "    # Definition for a binary tree node.\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param {TreeNode} root\\n        # @return {integer[]}\\n        def inorderTraversal(self, root):\\n            result, stack = [], [(root, False)]\\n    \\n            while stack:\\n                cur, visited = stack.pop()\\n                if cur:\\n                    if visited:\\n                        result.append(cur.val)\\n                    else:\\n                        stack.append((cur.right, False))\\n                        stack.append((cur, True))\\n                        stack.append((cur.left, False))\\n    \\n            return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 31394,
                "title": "javascript-solution-with-iteration",
                "content": "```js\\nfunction inorderTraversal(root) {\\n  const stack = [];\\n  const res = [];\\n\\n  while (root || stack.length) {\\n    if (root) {\\n      stack.push(root);\\n      root = root.left;\\n    } else {\\n      root = stack.pop();\\n      res.push(root.val);\\n      root = root.right;\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nfunction inorderTraversal(root) {\\n  const stack = [];\\n  const res = [];\\n\\n  while (root || stack.length) {\\n    if (root) {\\n      stack.push(root);\\n      root = root.left;\\n    } else {\\n      root = stack.pop();\\n      res.push(root.val);\\n      root = root.right;\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1377500,
                "title": "3-solutions-1-recursive-2-iterative-o-1-space-complexity-morris-traversal-explained-code",
                "content": "We can solve this problem in three ways lets 1st talk about he recursive method :\\n\\n**1st approach recursive**\\n\\n```\\nvoid helper(TreeNode* root,vector<int>& ans)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        helper(root->left,ans);\\n        ans.push_back(root->val);\\n        helper(root->right,ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root,ans);\\n        return ans;\\n            \\n    }\\n```\\n\\n\\nthis approach is pretty self explanitory and i don\\'t think it needs any explanation. \\n\\n\\n**2nd approach**\\n\\n\\nJust use a stack\\n\\n```\\n vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> s;\\n        while(root||!s.empty()){\\n            if(root!=NULL){\\n                s.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                root=s.top();\\n                s.pop();\\n                v.push_back(root->val);\\n                root=root->right;\\n            }\\n          }\\n         return v;\\n    }\\n```\\n\\nand keep the nodes in the stack and just perform the left and the right operation and then just pop the stack.\\n\\n\\n**3rd approach and the most optimised approach with T.C. O(n) and S.C O(1)**\\n\\nI have just used the morris-traversal technique.\\nIn this approach we don\\'t need to make any stack or vector we can just manipulate the leaf node and get the desired result.\\n\\nAfter a successful Morris approach your tree will look something like this\\n\\n**Before morris algorithm**\\n![image](https://assets.leetcode.com/users/images/92e256e9-9f11-42a8-bec7-5cfd020a5b7a_1627858941.954608.jpeg)\\n\\n**After morris algorithm**\\n![image](https://assets.leetcode.com/users/images/c91d5981-e57e-4cac-8a38-b8278b447f82_1627858986.5674217.jpeg)\\n\\n\\nso now we can just iterate our root which is at **4** and go till we get a null.\\n\\n\\n```\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode* temp;\\n        while(root)\\n        {\\n            if(root->left)\\n            {\\n                temp=root->left;\\n                while(temp->right)\\n                {\\n                    temp=temp->right;\\n                }\\n                temp->right=root;\\n                temp=root->left;\\n                root->left=NULL;\\n                root=temp;\\n            }\\n            else\\n            {\\n                ans.push_back(root->val);\\n                root=root->right;\\n                \\n            }\\n        }\\n        return ans;\\n```\\n\\nThis is the code to implement this approach. Please comment down if you have any confusions.\\n\\n**Please consider upvoting if you liked my effort of explaining this problem this will give me motivation to upload more such solutions.**\\n\\n**#happy_coding**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvoid helper(TreeNode* root,vector<int>& ans)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        helper(root->left,ans);\\n        ans.push_back(root->val);\\n        helper(root->right,ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root,ans);\\n        return ans;\\n            \\n    }\\n```\n```\\n vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> s;\\n        while(root||!s.empty()){\\n            if(root!=NULL){\\n                s.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                root=s.top();\\n                s.pop();\\n                v.push_back(root->val);\\n                root=root->right;\\n            }\\n          }\\n         return v;\\n    }\\n```\n```\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode* temp;\\n        while(root)\\n        {\\n            if(root->left)\\n            {\\n                temp=root->left;\\n                while(temp->right)\\n                {\\n                    temp=temp->right;\\n                }\\n                temp->right=root;\\n                temp=root->left;\\n                root->left=NULL;\\n                root=temp;\\n            }\\n            else\\n            {\\n                ans.push_back(root->val);\\n                root=root->right;\\n                \\n            }\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 148939,
                "title": "cpp-morris-traversal",
                "content": "# Morris Traversal ( Using Threaded Tree for Inorder Traversal)\\n> O(n) Time | O(1) Space\\n\\n## Definition Threaded Tree\\n\"A binary tree is threaded by making all right child pointers that would normally be null point to the inorder successor of the node (if it exists), and all left child pointers that would normally be null point to the inorder predecessor of the node.\\n\\n![Img](https://upload.wikimedia.org/wikipedia/commons/7/7a/Threaded_tree.svg)\\n\\n\\n## Links\\nMorris Traversal : https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\nThreaded Binary Tree: https://en.wikipedia.org/wiki/Threaded_binary_tree\\n\\n## Note\\nWe are not caring about the predecessor link (C -> B in diagram) here to print inorder. Hence not entirely a threaded tree is made\\n\\n## Pseudo Code\\n```\\n1. Initialize current as root \\n2. While current is not NULL\\n   If current hs a left child\\n      ifa) Make current as right child of the rightmost \\n         node in current\\'s left subtree\\n      ifb) Go to this left child, i.e., current = current->left\\n   Else\\n      ea) Print current\\u2019s data\\n      eb) Go to the right, i.e., current = current->right\\n```\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode* curNode = root;\\n        vector<int> nodes;\\n        \\n        while (curNode != NULL) \\n        {\\n            if (curNode -> left) \\n            {\\n\\t\\t\\t\\t\\t\\t   //Find the inorder predecessor of current\\n               //ifa) Make current as right child of the rightmost node in current\\'s left subtree\\n                TreeNode* predecessor = curNode -> left;\\n                while (predecessor -> right && predecessor -> right != curNode) //second condition used when reverting\\n                    predecessor = predecessor -> right;\\n                \\n                if ((predecessor -> right)==NULL) \\n                {\\n                    predecessor -> right = curNode;\\n                    curNode = curNode -> left; //ifb) Go to this left child\\n                }\\n                else \\n                {\\n                    //Revert back the changes\\n                    predecessor -> right = NULL;\\n                    nodes.push_back(curNode -> val);\\n                    curNode = curNode -> right;\\n                }\\n            }\\n            else \\n            {\\n                nodes.push_back(curNode -> val);  //ea)\\n                curNode = curNode -> right;  //eb)\\n            }\\n        }\\n        \\n        return nodes;\\n    }\\n};\\n```\\n\\n## References \\nhttps://leetcode.com/problems/binary-tree-inorder-traversal/discuss/31231/Clear-C++-solutions-iterative-recursive-and-Morris-traversal-(3-different-solutions!)\\nhttps://leetcode.com/problems/binary-tree-inorder-traversal/discuss/31232/Three-Methods-to-Solve-(C++)\\n\\n\\n # Other Solutions\\n ## Recursive\\n \\n ```\\n class Solution {\\npublic:\\n    vector<int> v;\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        find(root);\\n        return v;\\n    }\\n    \\n    void find(TreeNode* root){\\n        if(!root) return;\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n    }\\n};\\n```\\n\\n## Stack Based Solution\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode *root) {\\n        vector<int> vector;\\n        if(!root)\\n        return vector;\\n        unordered_map<TreeNode *, bool> map;//left child has been visited:true.\\n        stack<TreeNode *> stack;\\n        stack.push(root);\\n        while(!stack.empty())\\n        {\\n            TreeNode *pNode = stack.top();\\n            if(pNode->left && !map[pNode])\\n            {\\n                stack.push(pNode->left);\\n                map[pNode] = true;\\n            }\\n            else\\n            {\\n                vector.push_back(pNode->val);\\n                stack.pop();\\n                if(pNode->right)\\n                stack.push(pNode->right);\\n            }\\n        }\\n        return vector;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n1. Initialize current as root \\n2. While current is not NULL\\n   If current hs a left child\\n      ifa) Make current as right child of the rightmost \\n         node in current\\'s left subtree\\n      ifb) Go to this left child, i.e., current = current->left\\n   Else\\n      ea) Print current\\u2019s data\\n      eb) Go to the right, i.e., current = current->right\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode* curNode = root;\\n        vector<int> nodes;\\n        \\n        while (curNode != NULL) \\n        {\\n            if (curNode -> left) \\n            {\\n\\t\\t\\t\\t\\t\\t   //Find the inorder predecessor of current\\n               //ifa) Make current as right child of the rightmost node in current\\'s left subtree\\n                TreeNode* predecessor = curNode -> left;\\n                while (predecessor -> right && predecessor -> right != curNode) //second condition used when reverting\\n                    predecessor = predecessor -> right;\\n                \\n                if ((predecessor -> right)==NULL) \\n                {\\n                    predecessor -> right = curNode;\\n                    curNode = curNode -> left; //ifb) Go to this left child\\n                }\\n                else \\n                {\\n                    //Revert back the changes\\n                    predecessor -> right = NULL;\\n                    nodes.push_back(curNode -> val);\\n                    curNode = curNode -> right;\\n                }\\n            }\\n            else \\n            {\\n                nodes.push_back(curNode -> val);  //ea)\\n                curNode = curNode -> right;  //eb)\\n            }\\n        }\\n        \\n        return nodes;\\n    }\\n};\\n```\n```\\n class Solution {\\npublic:\\n    vector<int> v;\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        find(root);\\n        return v;\\n    }\\n    \\n    void find(TreeNode* root){\\n        if(!root) return;\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode *root) {\\n        vector<int> vector;\\n        if(!root)\\n        return vector;\\n        unordered_map<TreeNode *, bool> map;//left child has been visited:true.\\n        stack<TreeNode *> stack;\\n        stack.push(root);\\n        while(!stack.empty())\\n        {\\n            TreeNode *pNode = stack.top();\\n            if(pNode->left && !map[pNode])\\n            {\\n                stack.push(pNode->left);\\n                map[pNode] = true;\\n            }\\n            else\\n            {\\n                vector.push_back(pNode->val);\\n                stack.pop();\\n                if(pNode->right)\\n                stack.push(pNode->right);\\n            }\\n        }\\n        return vector;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31404,
                "title": "concise-java-solution-based-on-stack",
                "content": "**Explanation**\\n\\nThe basic idea is referred from [here][1]: using stack to simulate the recursion procedure: for each node, travel to its left child until it's left leaf, then pop to left leaf's higher level node A, and switch to A's right branch. Keep the above steps until cur is null and stack is empty. As the following:\\n\\n**Runtime = O(n)**: As each node is visited once\\n\\n**Space = O(n)**\\n\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n    \\tList<Integer> res = new LinkedList<Integer>();\\n    \\tif (root == null) return res;\\n    \\t\\n    \\tStack<TreeNode> stack = new Stack<TreeNode>();\\n    \\tTreeNode cur = root;\\n    \\twhile (cur != null || !stack.isEmpty()) { \\n    \\t\\twhile (cur != null) {// Travel to each node's left child, till reach the left leaf\\n    \\t\\t\\tstack.push(cur);\\n    \\t\\t\\tcur = cur.left;\\t\\t\\t\\t\\n    \\t\\t}\\t\\t \\n    \\t\\tcur = stack.pop(); // Backtrack to higher level node A\\n    \\t\\tres.add(cur.val);  // Add the node to the result list\\n    \\t\\tcur = cur.right;   // Switch to A'right branch\\n    \\t}\\n    \\treturn res;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/19765/iterative-solution-in-java-simple-and-readable",
                "solutionTags": [],
                "code": "**Explanation**\\n\\nThe basic idea is referred from [here][1]: using stack to simulate the recursion procedure: for each node, travel to its left child until it's left leaf, then pop to left leaf's higher level node A, and switch to A's right branch. Keep the above steps until cur is null and stack is empty. As the following:\\n\\n**Runtime = O(n)**: As each node is visited once\\n\\n**Space = O(n)**\\n\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n    \\tList<Integer> res = new LinkedList<Integer>();\\n    \\tif (root == null) return res;\\n    \\t\\n    \\tStack<TreeNode> stack = new Stack<TreeNode>();\\n    \\tTreeNode cur = root;\\n    \\twhile (cur != null || !stack.isEmpty()) { \\n    \\t\\twhile (cur != null) {// Travel to each node's left child, till reach the left leaf\\n    \\t\\t\\tstack.push(cur);\\n    \\t\\t\\tcur = cur.left;\\t\\t\\t\\t\\n    \\t\\t}\\t\\t \\n    \\t\\tcur = stack.pop(); // Backtrack to higher level node A\\n    \\t\\tres.add(cur.val);  // Add the node to the result list\\n    \\t\\tcur = cur.right;   // Switch to A'right branch\\n    \\t}\\n    \\treturn res;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/19765/iterative-solution-in-java-simple-and-readable",
                "codeTag": "Unknown"
            },
            {
                "id": 1374069,
                "title": "iterative-solution-stack-in-python-easy-and-fast-99-89",
                "content": "The rule of Inorder Traversal is simple : For each sub tree, you need **visit left child** of current root, then **save root value**, then **visit right child** of current root, for example:\\n![image](https://assets.leetcode.com/users/images/18b11daa-0a08-4215-9713-c59e5e507abb_1627725926.9611049.png)\\n\\nand you MUST always follow this order\\n\\nWhen you visit each children node (here is node 2 or node 4), \\n* if it\\'s a parent of others children, then apply our rule again\\n* if it\\'s empty- which mean it\\'s a leaf- then add it to the Result_list\\n\\nSo, when the tree is bigger, we can notice the pattern of the job and using Stack for our job:\\n* We always visit until the end of left tree, each time visit, you append children to stack. Why ? Imagine we are saving a checkpoint for later to visit the right part of each root\\n```\\n while root:\\n      stack.append(root)\\n      root = root.left\\n```\\n* Each time finish the loop,  comeback and visit parent value, which is the last value of the stack. So just pop it and add value to the Result_list \\n```\\nroot = stack.pop()\\nresult.append(root.val)\\n```\\nNow the last thing in our rule is visit the right \\n```\\nroot = root.right\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c602e413-e193-4710-9127-10c91c86f7e4_1627726325.61519.png)\\nSo here is the code:\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = []\\n        result = []\\n        \\n        while root or stack:\\n          while root:\\n            stack.append(root)\\n            root = root.left\\n          root = stack.pop()\\n          result.append(root.val)\\n          root = root.right\\n        return result\\n```\\nUpvote if you find it useful =))",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n while root:\\n      stack.append(root)\\n      root = root.left\\n```\n```\\nroot = stack.pop()\\nresult.append(root.val)\\n```\n```\\nroot = root.right\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = []\\n        result = []\\n        \\n        while root or stack:\\n          while root:\\n            stack.append(root)\\n            root = root.left\\n          root = stack.pop()\\n          result.append(root.val)\\n          root = root.right\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31467,
                "title": "morris-traversal-no-recursion-no-stack",
                "content": "\\tpublic class TreeNode {\\n\\t    int val;\\n\\t    TreeNode left;\\n\\t    TreeNode right;\\n\\t    TreeNode(int x) { val = x; }\\n\\t}\\n\\t\\n\\tpublic class Solution {\\n\\t    public List<Integer> inorderTraversal(TreeNode root) {\\n\\t        if(root == null) return new ArrayList<Integer>();\\n\\t        List<Integer> res = new ArrayList<Integer>();\\n\\t        TreeNode pre = null;\\n\\t        while(root != null){\\n\\t        \\tif(root.left == null){\\n\\t        \\t\\tres.add(root.val);\\n\\t        \\t\\troot = root.right;\\n\\t        \\t}else{\\n\\t        \\t\\tpre = root.left;\\n\\t        \\t\\twhile(pre.right != null && pre.right != root){\\n\\t        \\t\\t\\tpre = pre.right;\\n\\t        \\t\\t}\\n\\t        \\t\\tif(pre.right == null){\\n\\t        \\t\\t\\tpre.right = root;\\n\\t        \\t\\t\\troot = root.left;\\n\\t        \\t\\t}else{\\n\\t        \\t\\t\\tpre.right = null;\\n\\t        \\t\\t\\tres.add(root.val);\\n\\t        \\t\\t\\troot = root.right;\\n\\t        \\t\\t}\\n\\t        \\t}\\n\\t        }\\n\\t        return res;\\n\\t    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t    public List<Integer> inorderTraversal(TreeNode root) {\\n\\t        if(root == null) return new ArrayList<Integer>();\\n\\t        List<Integer> res = new ArrayList<Integer>();\\n\\t        TreeNode pre = null;\\n\\t        while(root != null){\\n\\t        \\tif(root.left == null){\\n\\t        \\t\\tres.add(root.val);\\n\\t        \\t\\troot = root.right;\\n\\t        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 31372,
                "title": "java-solution-both-recursion-and-iteration",
                "content": "\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        // method 1: recursion\\n\\n        helper(root, res);\\n        return res;\\n\\n        //helper function for method 1\\n        private void helper(TreeNode root, List<Integer> res) {\\n            if (root != null) {\\n                if (root.left != null) {\\n                    helper(root.left, res);\\n                }\\n                res.add(root.val);\\n                if (root.right != null) {\\n                    helper(root.right, res);\\n               }\\n           }\\n       }\\n\\n\\n----------\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        // method 2: iteration\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode cur = root;\\n        while (cur != null || !stack.isEmpty()) {\\n            while (cur != null) {\\n                stack.push(cur);\\n                cur = cur.left;\\n            }\\n            cur = stack.pop();\\n            res.add(cur.val);\\n            cur = cur.right;\\n        }\\n        return res;        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        // method 1: recursion\\n\\n        helper(root, res);\\n        return res;\\n\\n        //helper function for method 1\\n        private void helper(TreeNode root, List<Integer> res) {\\n            if (root != null) {\\n                if (root.left != null) {\\n                    helper(root.left, res);\\n                }\\n                res.add(root.val);\\n                if (root.right != null) {\\n                    helper(root.right, res);\\n               }\\n           }\\n       }\\n\\n\\n----------\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        // method 2: iteration\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode cur = root;\\n        while (cur != null || !stack.isEmpty()) {\\n            while (cur != null) {\\n                stack.push(cur);\\n                cur = cur.left;\\n            }\\n            cur = stack.pop();\\n            res.add(cur.val);\\n            cur = cur.right;\\n        }\\n        return res;        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 603442,
                "title": "intuitive-javascript-solution-with-stack",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n  const output = [];\\n  \\n  if (root === null) {\\n    return output;\\n  }\\n  \\n  /**\\n   * The goal is to maintain a stack of nodes to visit as we traverse \\n   * down the tree. As we traverse down, We go left and push all the \\n   * left nodes first in the stack. Once we reach to the bottom, we \\n   * store the node value and traverse right.\\n   *           1\\n   *         /   \\\\\\n   *        2     3    preorder traversal: 4 -> 2 -> 5 -> 1 -> 6 -> 3\\n   *       / \\\\   /     (left -> root -> right)\\n   *      4   5 6\\n   */\\n  const stack = [];\\n  let curr = root;\\n  \\n  while (curr !== null || stack.length !== 0) {\\n    if (curr !== null) {\\n      stack.push(curr);\\n      curr = curr.left;\\n    } else {\\n      curr = stack.pop();\\n      output.push(curr.val);\\n      curr = curr.right;  \\n    }  \\n  }\\n  \\n  return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n  const output = [];\\n  \\n  if (root === null) {\\n    return output;\\n  }\\n  \\n  /**\\n   * The goal is to maintain a stack of nodes to visit as we traverse \\n   * down the tree. As we traverse down, We go left and push all the \\n   * left nodes first in the stack. Once we reach to the bottom, we \\n   * store the node value and traverse right.\\n   *           1\\n   *         /   \\\\\\n   *        2     3    preorder traversal: 4 -> 2 -> 5 -> 1 -> 6 -> 3\\n   *       / \\\\   /     (left -> root -> right)\\n   *      4   5 6\\n   */\\n  const stack = [];\\n  let curr = root;\\n  \\n  while (curr !== null || stack.length !== 0) {\\n    if (curr !== null) {\\n      stack.push(curr);\\n      curr = curr.left;\\n    } else {\\n      curr = stack.pop();\\n      output.push(curr.val);\\n      curr = curr.right;  \\n    }  \\n  }\\n  \\n  return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 691488,
                "title": "javascript-clean-solution",
                "content": "```javascript\\nvar inorderTraversal = function(root) {\\n    const result = [];\\n    \\n    function traverse(node) {\\n        if(!node) return;\\n        \\n        traverse(node.left);\\n        result.push(node.val);\\n        traverse(node.right);\\n    }\\n    traverse(root);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar inorderTraversal = function(root) {\\n    const result = [];\\n    \\n    function traverse(node) {\\n        if(!node) return;\\n        \\n        traverse(node.left);\\n        result.push(node.val);\\n        traverse(node.right);\\n    }\\n    traverse(root);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 332283,
                "title": "python-recursive-and-iterative-solutions",
                "content": "Please see and vote for my solutions for these similar problems.\\n[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/discuss/332283/Python-recursive-and-iterative-solutions)\\n[144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/discuss/332277/Python-recursive-and-iterative-solutions)\\n[145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/discuss/332286/Python-recursive-and-iterative-solutions)\\n\\nRecursive solution:\\n```\\n    def inorderTraversal(self, root):\\n        def dfs(node):\\n            if not node:\\n                return\\n            dfs(node.left)\\n            in_order.append(node.val)\\n            dfs(node.right)\\n        \\n        in_order = []\\n        dfs(root)\\n        return in_order\\n```\\n\\nIterative solution 1: use a stack and a hashset visited\\n```\\n    def inorderTraversal(self, root):\\n        if not root:\\n            return []\\n        in_order = []\\n        stack = [root]\\n        visited = {root}\\n        while stack:\\n            top = stack[-1]\\n            no_left = True\\n            if top.left and top.left not in visited:\\n                stack.append(top.left)\\n                visited.add(top.left)\\n                no_left = False\\n            if no_left:\\n                stack.pop()\\n                in_order.append(top.val)\\n                if top.right and top.right not in visited:\\n                    stack.append(top.right)\\n                    visited.add(top.right)\\n        return in_order\\n```\\n\\nIterative solution 2: use a stack and a pointer\\n```\\n    def inorderTraversal(self, root):\\n        in_order = []\\n        stack, p = [], root\\n        while stack or p:\\n            if p:\\n                stack.append(p)\\n                p = p.left\\n            else:\\n                p = stack.pop()\\n                in_order.append(p.val)\\n                p = p.right\\n        return in_order\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def inorderTraversal(self, root):\\n        def dfs(node):\\n            if not node:\\n                return\\n            dfs(node.left)\\n            in_order.append(node.val)\\n            dfs(node.right)\\n        \\n        in_order = []\\n        dfs(root)\\n        return in_order\\n```\n```\\n    def inorderTraversal(self, root):\\n        if not root:\\n            return []\\n        in_order = []\\n        stack = [root]\\n        visited = {root}\\n        while stack:\\n            top = stack[-1]\\n            no_left = True\\n            if top.left and top.left not in visited:\\n                stack.append(top.left)\\n                visited.add(top.left)\\n                no_left = False\\n            if no_left:\\n                stack.pop()\\n                in_order.append(top.val)\\n                if top.right and top.right not in visited:\\n                    stack.append(top.right)\\n                    visited.add(top.right)\\n        return in_order\\n```\n```\\n    def inorderTraversal(self, root):\\n        in_order = []\\n        stack, p = [], root\\n        while stack or p:\\n            if p:\\n                stack.append(p)\\n                p = p.left\\n            else:\\n                p = stack.pop()\\n                in_order.append(p.val)\\n                p = p.right\\n        return in_order\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1319978,
                "title": "c-clean-concise-code-recursive-faster-than-100-0ms-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void in(TreeNode* root, vector<int> &v){\\n        if(root==NULL){\\n            return;\\n        }\\n        else{\\n            in(root->left,v);\\n            v.push_back(root->val);\\n            in(root->right,v);\\n        }\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        in(root,v);\\n        return v;\\n    }\\n};\\n```\\n**Please help to UPVOTE if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\nHAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void in(TreeNode* root, vector<int> &v){\\n        if(root==NULL){\\n            return;\\n        }\\n        else{\\n            in(root->left,v);\\n            v.push_back(root->val);\\n            in(root->right,v);\\n        }\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        in(root,v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702291,
                "title": "python-iterative-recursive-and-morris-traversal-o-1-space-and-o-n-time-complexity",
                "content": "**Iterative :**\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        output, stack =[],[]\\n        while(stack or root):\\n            if root:\\n                # Go to the left most and push the parent into the stack\\n                # We need this parent node once we are done with left child and need to go to the right child\\n                stack.append(root)\\n                root = root.left\\n            elif stack and root == None:\\n                #We are done with left , so pop out the parent\\n                root = stack.pop()\\n                output.append(root.val)\\n                # Go to the right child\\n                root = root.right\\n        return output\\n```\\nSpace : O(n) , Time : O(n)\\n\\n**Recursive**: \\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        output =[]\\n        def inorderTraversalHelper(root):\\n            if not root:\\n                return None\\n            inorderTraversalHelper(root.left)\\n            output.append(root.val)\\n            inorderTraversalHelper(root.right)\\n        inorderTraversalHelper(root)\\n        return output\\n```\\n\\n**Morris Traversal** : This can be done in constant space using Morris Traversal. Main aim of using a stack is to be able to go to right child of node once you have traverse the left child of a node. Instead of using a stack for that we can create a link between the inorder predecessor of the node and the node. Inorder predecessor of a node is the rightmost child of a left subtree and when you do a inorder traversal the node will come immediately after its inorder predecessor. \\n![image](https://assets.leetcode.com/users/images/9586323c-3a72-4e7a-a23c-27aa97795520_1592941100.20095.png)\\n\\nIf not using stack , create a link between 5 and 1. Now we don\\'t need a stack , we can go to 1 directly via 5. \\n![image](https://assets.leetcode.com/users/images/1793fa7e-e90f-4c74-8a60-7cc04bef6788_1592941130.8812513.png)\\n\\n![image](https://assets.leetcode.com/users/images/daad333c-010d-4a23-a998-1eb1c1102a08_1593026461.844386.png)\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        # Morris Traversal\\n        curr = root\\n        output =[]\\n        while(curr):\\n            #if no left child, we can directly go the right child\\n            if not curr.left:\\n                output.append(curr.val)\\n                curr = curr.right\\n            else:\\n            # find the inorder predecessor of the current node\\n                predecessor = curr.left\\n                # predecessor.right = curr will occur when we have already explored the left subtree of current \\n                # and reached the curr via its predecessor link and now again checking this else condition.\\n                # We have to break out of this loop.\\n                while predecessor.right !=None and predecessor.right != curr:\\n                    predecessor = predecessor.right # go as right as possible\\n\\n                # Now check which out of 2 above condition it reached\\n                if predecessor.right == None:\\n                    # No link created till now, so create one and go to the left child of current.\\n                    predecessor.right = curr\\n                    curr = curr.left\\n                else:\\n                    # left subtree is already visited , so delete the link and then go to right subtree\\n                    predecessor.right = None\\n                    output.append(curr.val)\\n                    curr = curr.right\\n        return output \\n```\\n\\nCode Walk through with the example :\\n1. Curr is 1 and before moving to its left , you have to create a link between 1 and its predecessor.\\n2. Predecessor is 5. Before creating the link , check if the predecessor already contains the link or not. Create a link between 5 and 1 and go to the left of 1 . **It is like putting the curr value to the stack and going to its left.**\\n3. Repeat the same process for curr node 2.  Before moving to its left , create a link between 2 and its predecessor \"4\"\\n![image](https://assets.leetcode.com/users/images/8867ccd2-686b-4ba4-a88e-9de48e65089b_1593704192.85518.png)\\n4. Now there is no curr.left. Add it to the output. Usually in inorder traversal with stack => you pop out from the stack , get the parent , add it to the output and go to left.Here to get the parent , you go to the right and followed the parent using the link created before.\\n![image](https://assets.leetcode.com/users/images/1e30590a-4c94-4d1b-b0ca-5d79d9428e81_1593704211.958061.png)\\n5. Now you are at 2 and **you don\\'t know if you are coming to this 2 for the first time or you have already explored its left**. One way to find it out is to check its predecessor and if link already exist , it means you have already explored the left of 2 and have utlised the link created before to come to 2. Now you can safely delete this link as you will not need it again . Now go to the curr.right. ( Left is done , parent is done)\\n![image](https://assets.leetcode.com/users/images/7ad9a3e5-5a8c-4761-9d23-488b2989d88b_1593704218.4761784.png)\\n6. Now you are at 5. There is no left so append it to the output and go to its right. 5.right = 1(the link we created before). Now repeat the same process of deleting the link as we did before and go to curr right which is 3. ( left is explored , parent is explored)\\n![image](https://assets.leetcode.com/users/images/9c63e1ae-7d79-4f21-af05-4c385bd55443_1593704224.371424.png)\\n7. You are at 3 and there is no left , so add it to the output.\\n![image](https://assets.leetcode.com/users/images/e89a7026-4060-4d7c-a922-70c3f30dafc2_1593704228.9838285.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        output, stack =[],[]\\n        while(stack or root):\\n            if root:\\n                # Go to the left most and push the parent into the stack\\n                # We need this parent node once we are done with left child and need to go to the right child\\n                stack.append(root)\\n                root = root.left\\n            elif stack and root == None:\\n                #We are done with left , so pop out the parent\\n                root = stack.pop()\\n                output.append(root.val)\\n                # Go to the right child\\n                root = root.right\\n        return output\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        output =[]\\n        def inorderTraversalHelper(root):\\n            if not root:\\n                return None\\n            inorderTraversalHelper(root.left)\\n            output.append(root.val)\\n            inorderTraversalHelper(root.right)\\n        inorderTraversalHelper(root)\\n        return output\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        # Morris Traversal\\n        curr = root\\n        output =[]\\n        while(curr):\\n            #if no left child, we can directly go the right child\\n            if not curr.left:\\n                output.append(curr.val)\\n                curr = curr.right\\n            else:\\n            # find the inorder predecessor of the current node\\n                predecessor = curr.left\\n                # predecessor.right = curr will occur when we have already explored the left subtree of current \\n                # and reached the curr via its predecessor link and now again checking this else condition.\\n                # We have to break out of this loop.\\n                while predecessor.right !=None and predecessor.right != curr:\\n                    predecessor = predecessor.right # go as right as possible\\n\\n                # Now check which out of 2 above condition it reached\\n                if predecessor.right == None:\\n                    # No link created till now, so create one and go to the left child of current.\\n                    predecessor.right = curr\\n                    curr = curr.left\\n                else:\\n                    # left subtree is already visited , so delete the link and then go to right subtree\\n                    predecessor.right = None\\n                    output.append(curr.val)\\n                    curr = curr.right\\n        return output \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724058,
                "title": "recursive-and-iterative-approach",
                "content": "# 1. Recursive Approach\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        def inorder(root,ans):\\n            if not root:\\n                return None\\n            inorder(root.left,ans)\\n            ans.append(root.val)\\n            inorder(root.right,ans)\\n        inorder(root,ans)\\n        return ans\\n```\\n# 2. Iterative Approach\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        stack=[]\\n        cur=root\\n        while stack or cur:\\n            if cur:\\n                stack.append(cur)\\n                cur=cur.left\\n            else:\\n                cur=stack.pop()\\n                ans.append(cur.val)\\n                cur=cur.right\\n        return ans\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        def inorder(root,ans):\\n            if not root:\\n                return None\\n            inorder(root.left,ans)\\n            ans.append(root.val)\\n            inorder(root.right,ans)\\n        inorder(root,ans)\\n        return ans\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        stack=[]\\n        cur=root\\n        while stack or cur:\\n            if cur:\\n                stack.append(cur)\\n                cur=cur.left\\n            else:\\n                cur=stack.pop()\\n                ans.append(cur.val)\\n                cur=cur.right\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31463,
                "title": "non-recursive-python-solution",
                "content": "Simple, understandable solution. In the loop: If we get a node with flag false, we add children in correct order and set them to false. because they have to be processed (for their children). And we set flag of current node to true. \\n\\nIf we get node with flag set to true we simply print its value (add to acc).\\nCan be modified to do post and pre order too.\\n\\n    class Solution:\\n        def inorderTraversal(self, root):\\n            stack = [ (False, root) ]\\n            acc = []\\n            \\n            while stack:\\n                flag, val = stack.pop()\\n                if val:\\n                    if not flag:\\n                        stack.append( (False, val.right) )\\n                        stack.append( (True, val) )\\n                        stack.append( (False, val.left) )\\n                    else:\\n                        acc.append( val.val )\\n            return acc",
                "solutionTags": [
                    "Python"
                ],
                "code": "Simple, understandable solution. In the loop: If we get a node with flag false, we add children in correct order and set them to false. because they have to be processed (for their children). And we set flag of current node to true. \\n\\nIf we get node with flag set to true we simply print its value (add to acc).\\nCan be modified to do post and pre order too.\\n\\n    class Solution:\\n        def inorderTraversal(self, root):\\n            stack = [ (False, root) ]\\n            acc = []\\n            \\n            while stack:\\n                flag, val = stack.pop()\\n                if val:\\n                    if not flag:\\n                        stack.append( (False, val.right) )\\n                        stack.append( (True, val) )\\n                        stack.append( (False, val.left) )\\n                    else:\\n                        acc.append( val.val )\\n            return acc",
                "codeTag": "Java"
            },
            {
                "id": 1860290,
                "title": "tree-traversal-algorithms-preorder-inorder-and-postorder-traverse-algorithms-all-in-one",
                "content": "[Leetcode](https://leetcode.com/) [94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/).\\n\\n\\n***By Frank Luo***\\n\\nThe **Tree Traversal Algorithms** are used to traversal the tree including **Binary Tree** and **N-ary Tree**. \\n\\n1. Binary Tree Traversal\\n\\n[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)\\n[144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)\\n[145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/)\\n\\n2. N-ary Tree Traversal\\n\\n[589. N-ary Tree Preorder Traversal](https://leetcode.com/problems/n-ary-tree-preorder-traversal/)\\n[590. N-ary Tree Postorder Traversal](https://leetcode.com/problems/n-ary-tree-postorder-traversal/)\\n\\n\\n# Binary Tree\\n\\n## PreOrder\\n\\nAlgorithm Preorder(tree)\\n1. Visit the root;\\n2. Traverse the left subtree, i.e., call Preorder(left-subtree);\\n3. Traverse the right subtree, i.e., call Preorder(right-subtree). \\n\\n### Recursive\\n\\n```java\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        preOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void preOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        list.add(root.val);\\n        preOrder(root.left, list);\\n        preOrder(root.right, list);\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n### Iteration\\n\\n```java\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                ans.add(root.val);\\n                root = root.left;\\n            }\\n            \\n            root = stack.pop();\\n            root = root.right;\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n<!-- more -->\\n\\n## InOrder\\n\\nAlgorithm Inorder(tree)\\n\\n1. Traverse the left subtree, i.e., call Inorder(left-subtree);\\n2. Visit the root;\\n3. Traverse the right subtree, i.e., call Inorder(right-subtree).\\n\\n### Recursive\\n\\n```java\\n    public List<Integer> inorderTraversal_rec(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        inOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void inOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        if (root.left != null) {\\n            inOrder(root.left, list);\\n        }\\n        list.add(root.val);\\n        if (root.right != null) {\\n            inOrder(root.right, list);\\n        }\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n### Iteration\\n\\n```java\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            \\n            root = stack.pop();\\n            ans.add(root.val);\\n            root = root.right;\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n## PostOrder\\n\\nAlgorithm Postorder(tree)\\n1. Traverse the left subtree, i.e., call Postorder(left-subtree);\\n2. Traverse the right subtree, i.e., call Postorder(right-subtree);\\n3. Visit the root.\\n\\n\\n### Recursive\\n\\n```java\\n    public List<Integer> postorderTraversal_rec(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        postOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void postOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        postOrder(root.left, list);\\n        postOrder(root.right, list);\\n        list.add(root.val);\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n### Iteration\\n\\n```java\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        TreeNode prev = null;\\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                root = root.left;\\n            }\\n\\n            root = stack.pop();\\n            if (root.right == null || root.right == prev) {\\n                ans.add(root.val);\\n                prev = root;\\n                root = null;\\n            } else {\\n                stack.push(root);\\n                root = root.right;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n# N-ary Tree Traversal\\n\\n## PreOrder\\n\\n### Recursive\\n\\n```java\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        preOrderTraversal(root, ans);\\n        return ans;\\n    }\\n    \\n    public void preOrderTraversal(Node root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        list.add(root.val);\\n        List<Node> children = root.children;\\n        for (Node child : children) {\\n            preOrderTraversal(child, list);\\n        }\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n### Iteration\\n\\n```java\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        Stack<Node> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.empty()) {\\n            Node node = stack.pop();\\n            ans.add(node.val);\\n            List<Node> children = node.children;\\n            int size = children.size();\\n            for (int i = size - 1; i >= 0; i--) {\\n                stack.push(children.get(i));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n## PostOrder\\n\\n### Recursive\\n\\n```java\\n    public List<Integer> postorder_rec(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        postOrderTraversal(root, ans);\\n        return ans;\\n    }\\n    \\n    public void postOrderTraversal(Node root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        List<Node> children = root.children;\\n        for (Node child : children) {\\n            postOrderTraversal(child, list);\\n        }\\n        list.add(root.val);\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n### Iteration\\n\\n```java\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        Stack<Node> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.empty()) {\\n            Node node = stack.pop();\\n            ans.add(node.val);\\n            List<Node> children = node.children;\\n            int size = children.size();\\n            for (int i = 0; i < size; i++) {\\n                stack.push(children.get(i));\\n            }\\n        }\\n        \\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n-------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```java\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        preOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void preOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        list.add(root.val);\\n        preOrder(root.left, list);\\n        preOrder(root.right, list);\\n    }\\n```\n```java\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                ans.add(root.val);\\n                root = root.left;\\n            }\\n            \\n            root = stack.pop();\\n            root = root.right;\\n        }\\n        \\n        return ans;\\n    }\\n```\n```java\\n    public List<Integer> inorderTraversal_rec(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        inOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void inOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        if (root.left != null) {\\n            inOrder(root.left, list);\\n        }\\n        list.add(root.val);\\n        if (root.right != null) {\\n            inOrder(root.right, list);\\n        }\\n    }\\n```\n```java\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            \\n            root = stack.pop();\\n            ans.add(root.val);\\n            root = root.right;\\n        }\\n        \\n        return ans;\\n    }\\n```\n```java\\n    public List<Integer> postorderTraversal_rec(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        postOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void postOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        postOrder(root.left, list);\\n        postOrder(root.right, list);\\n        list.add(root.val);\\n    }\\n```\n```java\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        TreeNode prev = null;\\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                root = root.left;\\n            }\\n\\n            root = stack.pop();\\n            if (root.right == null || root.right == prev) {\\n                ans.add(root.val);\\n                prev = root;\\n                root = null;\\n            } else {\\n                stack.push(root);\\n                root = root.right;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\n```java\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        preOrderTraversal(root, ans);\\n        return ans;\\n    }\\n    \\n    public void preOrderTraversal(Node root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        list.add(root.val);\\n        List<Node> children = root.children;\\n        for (Node child : children) {\\n            preOrderTraversal(child, list);\\n        }\\n    }\\n```\n```java\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        Stack<Node> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.empty()) {\\n            Node node = stack.pop();\\n            ans.add(node.val);\\n            List<Node> children = node.children;\\n            int size = children.size();\\n            for (int i = size - 1; i >= 0; i--) {\\n                stack.push(children.get(i));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\n```java\\n    public List<Integer> postorder_rec(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        postOrderTraversal(root, ans);\\n        return ans;\\n    }\\n    \\n    public void postOrderTraversal(Node root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        List<Node> children = root.children;\\n        for (Node child : children) {\\n            postOrderTraversal(child, list);\\n        }\\n        list.add(root.val);\\n    }\\n```\n```java\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        Stack<Node> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.empty()) {\\n            Node node = stack.pop();\\n            ans.add(node.val);\\n            List<Node> children = node.children;\\n            int size = children.size();\\n            for (int i = 0; i < size; i++) {\\n                stack.push(children.get(i));\\n            }\\n        }\\n        \\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31407,
                "title": "my-3-solutions-in-c",
                "content": "\\n    // recursive, it's trivial...\\n    vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(!root) return v;\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return v;\\n    }\\n    \\n    \\n    // iterate, use stack\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root;\\n        stack<TreeNode*> s;\\n        while(true){\\n            while(temp){\\n                s.push(temp);\\n                temp = temp->left;\\n            }\\n            if(s.empty()) break;\\n            temp = s.top();\\n            s.pop();\\n            v.push_back(temp->val);\\n            temp = temp->right;\\n        }\\n        return v;\\n    }\\n    \\n    \\n    // iterate, morris traversal, without stack\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root, *prev;\\n        while(temp){\\n            if(!temp->left){\\n                v.push_back(temp->val);\\n                temp = temp->right;\\n            }else{\\n                prev = temp->left;\\n                while(prev->right&&(prev->right != temp))\\n                    prev = prev->right;\\n                if(!prev->right){\\n                    prev->right = temp;\\n                    temp = temp->left;\\n                }else{\\n                    v.push_back(temp->val);\\n                    prev->right = NULL;\\n                    temp = temp->right;\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n    // recursive, it's trivial...\\n    vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(!root) return v;\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return v;\\n    }\\n    \\n    \\n    // iterate, use stack\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root;\\n        stack<TreeNode*> s;\\n        while(true){\\n            while(temp){\\n                s.push(temp);\\n                temp = temp->left;\\n            }\\n            if(s.empty()) break;\\n            temp = s.top();\\n            s.pop();\\n            v.push_back(temp->val);\\n            temp = temp->right;\\n        }\\n        return v;\\n    }\\n    \\n    \\n    // iterate, morris traversal, without stack\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root, *prev;\\n        while(temp){\\n            if(!temp->left){\\n                v.push_back(temp->val);\\n                temp = temp->right;\\n            }else{\\n                prev = temp->left;\\n                while(prev->right&&(prev->right != temp))\\n                    prev = prev->right;\\n                if(!prev->right){\\n                    prev->right = temp;\\n                    temp = temp->left;\\n                }else{\\n                    v.push_back(temp->val);\\n                    prev->right = NULL;\\n                    temp = temp->right;\\n                }\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 434091,
                "title": "js-recursive-clean-code",
                "content": "```\\nconst inorderTraversal = root => {\\n    if (!root) {\\n        return []\\n    }\\n    \\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst inorderTraversal = root => {\\n    if (!root) {\\n        return []\\n    }\\n    \\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3348653,
                "title": "java-fastest-dfs-solution-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(H) h is height of the tree\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/4501697a-bbba-4d67-89cb-f285873536ec_1679937247.5252385.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        \\n        // Check if the root is null\\n        if(root == null){\\n            // If the root is null, return an empty ArrayList\\n            return new ArrayList<Integer>();\\n        }\\n\\n        // Create a new ArrayList to store the values obtained in an in-order traversal\\n        ArrayList<Integer> ans = new ArrayList<>();\\n\\n        // Recursively perform an in-order traversal on the left subtree and add the obtained values to the ArrayList\\n        ans.addAll(inorderTraversal(root.left));\\n\\n        // Add the value of the root to the ArrayList\\n        ans.add(root.val);\\n\\n        // Recursively perform an in-order traversal on the right subtree and add the obtained values to the ArrayList\\n        ans.addAll(inorderTraversal(root.right));\\n\\n        // Return the ArrayList containing all the values obtained in the in-order traversal\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        \\n        // Check if the root is null\\n        if(root == null){\\n            // If the root is null, return an empty ArrayList\\n            return new ArrayList<Integer>();\\n        }\\n\\n        // Create a new ArrayList to store the values obtained in an in-order traversal\\n        ArrayList<Integer> ans = new ArrayList<>();\\n\\n        // Recursively perform an in-order traversal on the left subtree and add the obtained values to the ArrayList\\n        ans.addAll(inorderTraversal(root.left));\\n\\n        // Add the value of the root to the ArrayList\\n        ans.add(root.val);\\n\\n        // Recursively perform an in-order traversal on the right subtree and add the obtained values to the ArrayList\\n        ans.addAll(inorderTraversal(root.right));\\n\\n        // Return the ArrayList containing all the values obtained in the in-order traversal\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019265,
                "title": "stack-c-inorder-beginner-friendly",
                "content": "**Runtime: 0 ms, faster than 100.00% of C++ online submissions \\nMemory Usage: 9.4 MB, less than 11.18% of C++ online submissions**\\n```\\nclass Solution {\\npublic:\\n    vector<int> vec;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==nullptr) return {};\\n        inorderTraversal(root->left);\\n        vec.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return vec;\\n    }\\n};\\n```\\n**Runtime: 0 ms, faster than 100.00% of C++ online submissions \\nMemory Usage: 8.6 MB, less than 11.18% of C++ online submissions**\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root){ \\n        if(root==NULL)\\n           return {};\\n        vector<int> vec;\\n        stack<TreeNode*> s;\\n        while(true){\\n            if(root!=NULL){\\n               s.push(root);\\n               root=root->left; \\n            }\\n            else{\\n                if(s.empty())\\n                    break;\\n                root=s.top();\\n                s.pop();\\n                vec.push_back(root->val);\\n                root=root->right;\\n            }\\n        }\\n        return vec;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vec;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==nullptr) return {};\\n        inorderTraversal(root->left);\\n        vec.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return vec;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root){ \\n        if(root==NULL)\\n           return {};\\n        vector<int> vec;\\n        stack<TreeNode*> s;\\n        while(true){\\n            if(root!=NULL){\\n               s.push(root);\\n               root=root->left; \\n            }\\n            else{\\n                if(s.empty())\\n                    break;\\n                root=s.top();\\n                s.pop();\\n                vec.push_back(root->val);\\n                root=root->right;\\n            }\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158278,
                "title": "python-stack-dfs",
                "content": "### 94. Binary Tree Inorder Traversal\\n```\\n> \\u7C7B\\u578B\\uFF1A\\n> Time Complexity O(n)\\n> Space Complexity O(1)\\n```\\n\\n#### DFS Recursive\\n```python\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        self.res = []\\n        self.dfs(root)\\n        return self.res\\n        \\n    def dfs(self, root):\\n        if not root:\\n            return\\n        self.dfs(root.left)\\n        self.res.append(root.val)\\n        self.dfs(root.right)\\n```\\n\\n#### Stack\\n\\n\\u5148\\u628A\\u8FED\\u4EE3\\u5230\\u6700\\u5DE6\\u8FB9\\u7684\\u53F6\\u5B50\\u8282\\u70B9\\uFF0C\\u628A\\u6240\\u6709\\u9014\\u4E2D\\u7684`root`\\u653E\\u8FDBstack\\uFF0C\\u5F53\\u5DE6\\u8FB9\\u8D70\\u4E0D\\u901A\\u4E86\\uFF0C\\u5F00\\u59CB\\u5F80`res`\\u91CC\\u9762\\u5B58\\u6570\\uFF0C\\u5E76\\u5F80\\u53F3\\u8FB9\\u8D70\\u3002\\n\\n```python\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        res, stack = [], []\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                res.append(node.val)\\n                root = node.right\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n> \\u7C7B\\u578B\\uFF1A\\n> Time Complexity O(n)\\n> Space Complexity O(1)\\n```\n```python\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        self.res = []\\n        self.dfs(root)\\n        return self.res\\n        \\n    def dfs(self, root):\\n        if not root:\\n            return\\n        self.dfs(root.left)\\n        self.res.append(root.val)\\n        self.dfs(root.right)\\n```\n```python\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        res, stack = [], []\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                res.append(node.val)\\n                root = node.right\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1073216,
                "title": "python-3-solutions-recursive-iterative",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        #\\n        ## recursive\\n        if not root: return []\\n        else: return self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right)\\n```\\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        #\\n        ## iteration\\n        stack,res = [],[]\\n        node = root\\n        # why we need to judge the node or the stack at the same time?\\n        # Because we will stop the first while loop when it reach the far-right leaf.\\n        # However, the stack will be empty when the node reaches the root.\\n        # And the node will be None when we reach the left leaf.\\n        # To make sure the node reaches the far-right leaf, we need to check the node and stack\\n        # in the first while loop.\\n        while node or stack:\\n            while node: # put all left nodes in the stack\\n                stack.append(node)\\n                node = node.left\\n            node = stack.pop()\\n            res.append(node.val)\\n            # change the direction to the right direction after the left.children\\n            # and parent are taken care of, which the inorder means.\\n            node = node.right\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        #\\n        ## recursive\\n        if not root: return []\\n        else: return self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right)\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        #\\n        ## iteration\\n        stack,res = [],[]\\n        node = root\\n        # why we need to judge the node or the stack at the same time?\\n        # Because we will stop the first while loop when it reach the far-right leaf.\\n        # However, the stack will be empty when the node reaches the root.\\n        # And the node will be None when we reach the left leaf.\\n        # To make sure the node reaches the far-right leaf, we need to check the node and stack\\n        # in the first while loop.\\n        while node or stack:\\n            while node: # put all left nodes in the stack\\n                stack.append(node)\\n                node = node.left\\n            node = stack.pop()\\n            res.append(node.val)\\n            # change the direction to the right direction after the left.children\\n            # and parent are taken care of, which the inorder means.\\n            node = node.right\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338663,
                "title": "python-inorder-iterative-stack-t-f-explanation",
                "content": "InOrder Traversal:\\n\\t- Traverse the left side\\n\\t- hit the root\\n\\t- traverse the right side \\n\\nW/ recursive go -> left,root,right\\nW/iterative stack go -> right,root,left\\n\\t - stack follows LIFO(last-in-first-out)\\n\\t - so you\\'ll iterate through the right side first, but you\\'ll pop OUT the left side first\\n\\t - aka its backwards traversal to get the proper answer \\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res = []\\n        # root starts out False because you haven\\'t visited it yet\\n        stack = [(root, False)]\\n        \\n        while stack:\\n            # pop the last element\\n            node, visited = stack.pop() \\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  \\n                    # inorder: left -> root -> right\\n                    # switch because stacks work backwards\\n                    stack.append((node.right, False)) # has not been visited before\\n                    stack.append((node, True)) # has been visited before\\n                    stack.append((node.left, False)) # has not been visited before \\n        return res\\n```\\n\\nNow to the fun part... True or False?\\n- False = you have appended to stack once\\n- True = you have popped the False, second appending is True\\n\\n```\\n# True vs. False\\n\\n         1\\n        / \\\\\\n       2   3\\n      / \\\\\\n     4   5\\n\\nroot  = 1\\nstack = [(root,False)]\\nFalse = not yet visited \\n\\n\\n# While stack:\\n    node, visited = stack.pop([(1,False)])\\n    \\n    if node: node = (1)\\n        if visited: FALSE\\n        \\n        else:   stack.append(node = 3, False) # hasn\\'t been visited yet \\n                stack.append(node = 1, True) # has been visited once before\\n                stack.append(node = 2, False) # hasn\\'t been visited yet\\nstack = [(3,False),(1, True),(2,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(2,False)\\n    \\n    if node: node = 2\\n        if visited: FALSE\\n        \\n        else:   stack.append(node = 5, False) # hasn\\'t been visited yet   \\n                stack.append(node = 2, True) # has been visited once before\\n                stack.append(node = 4, False) # hasn\\'t been visited yet         \\nstack = [(3,False),(1, True),(5,False),(2,True),(4,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(4,False)\\n    \\n    if node: node = 4\\n        if visited: False\\n\\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 4, True) # has been visited once before\\n                stack.append(NA) # leaf         \\nstack = [(3,False),(1, True),(5,False),(2,True),(4,True)]\\n\\n# while stack:\\n    node, visited = stack.pop(4,True)\\n    \\n    if node: node = 4\\n        if visited: True\\n            res.append(node.4)\\nres = [4]\\nstack = [(3,False),(1, True),(5,False),(2,True)]\\n\\n# while stack:\\n    node, visited = stack.pop(2,True)\\n    \\n    if node: node = 2\\n        if visited: True \\n            res.append(node.2)\\nres = [4,2]\\nstack = [(3,False),(1, True),(5,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(5,False)\\n    \\n    if node: node = 5\\n        if visited: False\\n            \\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 5, True) # has been visited once before\\n                stack.append(NA) # leaf              \\nres = [4,2]\\nstack = [(3,False),(1, True),(5,True)]        \\n\\n# while stack:\\n    node, visited = stack.pop(5,True)\\n    \\n    if node: node = 5\\n        if visited: True \\n            res.append(node.5)\\nres = [4,2,5]\\nstack = [(3,False),(1, True)]  \\n\\n# while stack:\\n    node, visited = stack.pop(1,True)\\n    \\n    if node: node = 1\\n        if visited: True \\n            res.append(node.1)\\nres = [4,2,5,1]\\nstack = [(3,False)]  \\n\\n# while stack:\\n    node, visited = stack.pop(3,False)\\n    \\n    if node: node = 3\\n        if visited: False\\n\\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 3, True) # has been visited once before\\n                stack.append(NA) # leaf   \\nres = [4,2,5,1]\\nstack = [(3,True)] \\n\\n# while stack:\\n    node, visited = stack.pop(3,True)\\n    if node: node = 3\\n        if visited: True \\n            res.append(node.3)\\nres = [4,2,5,1,3]\\nstack = []  \\n```\\n\\nHope that helps :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res = []\\n        # root starts out False because you haven\\'t visited it yet\\n        stack = [(root, False)]\\n        \\n        while stack:\\n            # pop the last element\\n            node, visited = stack.pop() \\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  \\n                    # inorder: left -> root -> right\\n                    # switch because stacks work backwards\\n                    stack.append((node.right, False)) # has not been visited before\\n                    stack.append((node, True)) # has been visited before\\n                    stack.append((node.left, False)) # has not been visited before \\n        return res\\n```\n```\\n# True vs. False\\n\\n         1\\n        / \\\\\\n       2   3\\n      / \\\\\\n     4   5\\n\\nroot  = 1\\nstack = [(root,False)]\\nFalse = not yet visited \\n\\n\\n# While stack:\\n    node, visited = stack.pop([(1,False)])\\n    \\n    if node: node = (1)\\n        if visited: FALSE\\n        \\n        else:   stack.append(node = 3, False) # hasn\\'t been visited yet \\n                stack.append(node = 1, True) # has been visited once before\\n                stack.append(node = 2, False) # hasn\\'t been visited yet\\nstack = [(3,False),(1, True),(2,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(2,False)\\n    \\n    if node: node = 2\\n        if visited: FALSE\\n        \\n        else:   stack.append(node = 5, False) # hasn\\'t been visited yet   \\n                stack.append(node = 2, True) # has been visited once before\\n                stack.append(node = 4, False) # hasn\\'t been visited yet         \\nstack = [(3,False),(1, True),(5,False),(2,True),(4,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(4,False)\\n    \\n    if node: node = 4\\n        if visited: False\\n\\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 4, True) # has been visited once before\\n                stack.append(NA) # leaf         \\nstack = [(3,False),(1, True),(5,False),(2,True),(4,True)]\\n\\n# while stack:\\n    node, visited = stack.pop(4,True)\\n    \\n    if node: node = 4\\n        if visited: True\\n            res.append(node.4)\\nres = [4]\\nstack = [(3,False),(1, True),(5,False),(2,True)]\\n\\n# while stack:\\n    node, visited = stack.pop(2,True)\\n    \\n    if node: node = 2\\n        if visited: True \\n            res.append(node.2)\\nres = [4,2]\\nstack = [(3,False),(1, True),(5,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(5,False)\\n    \\n    if node: node = 5\\n        if visited: False\\n            \\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 5, True) # has been visited once before\\n                stack.append(NA) # leaf              \\nres = [4,2]\\nstack = [(3,False),(1, True),(5,True)]        \\n\\n# while stack:\\n    node, visited = stack.pop(5,True)\\n    \\n    if node: node = 5\\n        if visited: True \\n            res.append(node.5)\\nres = [4,2,5]\\nstack = [(3,False),(1, True)]  \\n\\n# while stack:\\n    node, visited = stack.pop(1,True)\\n    \\n    if node: node = 1\\n        if visited: True \\n            res.append(node.1)\\nres = [4,2,5,1]\\nstack = [(3,False)]  \\n\\n# while stack:\\n    node, visited = stack.pop(3,False)\\n    \\n    if node: node = 3\\n        if visited: False\\n\\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 3, True) # has been visited once before\\n                stack.append(NA) # leaf   \\nres = [4,2,5,1]\\nstack = [(3,True)] \\n\\n# while stack:\\n    node, visited = stack.pop(3,True)\\n    if node: node = 3\\n        if visited: True \\n            res.append(node.3)\\nres = [4,2,5,1,3]\\nstack = []  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287690,
                "title": "c-solution-100-faster-iterative-and-recursive-version",
                "content": "Both iterative and recursive solutions are equally fast(0ms, 100% faster).\\n\\n```\\n//iterative solution using stack\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    int*ans=malloc(100*sizeof(int));\\n    *returnSize=0;\\n    struct TreeNode**stack=malloc(100*sizeof(struct TreeNode*));\\n    int top=0;\\n    while(top||root){\\n        if(root){\\n            stack[top++]=root;\\n            root=root->left;\\n        }\\n        else{\\n            root=stack[--top];\\n            ans[(*returnSize)++]=root->val;\\n            root=root->right;\\n        }\\n    }\\n    free(stack);\\n    ans=realloc(ans,(*returnSize)*sizeof(int));\\n    return ans;\\n}\\n```\\n\\n```\\n//recursive solution\\nvoid traverse(struct TreeNode* root, int* arr, int* returnSize){\\n    if(root->left)\\n        traverse(root->left,arr,returnSize);\\n    arr[(*returnSize)++]=root->val;\\n    if(root->right)\\n        traverse(root->right,arr,returnSize);\\n}\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    int*arr=malloc(100*sizeof(int));\\n    *returnSize=0;\\n    if(root)\\n        traverse(root,arr,returnSize);\\n    arr=realloc(arr,(*returnSize)*sizeof(int));\\n    return arr;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//iterative solution using stack\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    int*ans=malloc(100*sizeof(int));\\n    *returnSize=0;\\n    struct TreeNode**stack=malloc(100*sizeof(struct TreeNode*));\\n    int top=0;\\n    while(top||root){\\n        if(root){\\n            stack[top++]=root;\\n            root=root->left;\\n        }\\n        else{\\n            root=stack[--top];\\n            ans[(*returnSize)++]=root->val;\\n            root=root->right;\\n        }\\n    }\\n    free(stack);\\n    ans=realloc(ans,(*returnSize)*sizeof(int));\\n    return ans;\\n}\\n```\n```\\n//recursive solution\\nvoid traverse(struct TreeNode* root, int* arr, int* returnSize){\\n    if(root->left)\\n        traverse(root->left,arr,returnSize);\\n    arr[(*returnSize)++]=root->val;\\n    if(root->right)\\n        traverse(root->right,arr,returnSize);\\n}\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    int*arr=malloc(100*sizeof(int));\\n    *returnSize=0;\\n    if(root)\\n        traverse(root,arr,returnSize);\\n    arr=realloc(arr,(*returnSize)*sizeof(int));\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2547065,
                "title": "leetcode-the-hard-way-dfs-in-order-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\nYou may also check out my recent DFS solutions on other tree problems.\\n\\n- [987. Vertical Order Traversal of a Binary Tree](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/discuss/2527028/leetcode-the-hard-way-easy-dfs-explained-line-by-line)\\n- [1448. Count Good Nodes in Binary Tree](https://leetcode.com/problems/count-good-nodes-in-binary-tree/discuss/2511705/leetcode-the-hard-way-dfs-explained-line-by-line)\\n- [814. Binary Tree Pruning](https://leetcode.com/problems/binary-tree-pruning/discuss/2537510/leetcode-the-hard-way-easy-dfs-explained-line-by-line)\\n- [606. Construct String from Binary Tree](https://leetcode.com/problems/construct-string-from-binary-tree/discuss/2542523/leetcode-the-hard-way-dfs-5-cases-explained-line-by-line)\\n\\nThe steps for in-order is \\n- traverse left subtree \\n- do something with root value\\n-  traverse right sub tree. \\n\\nFor example 1, starting the root node 1.\\n \\n- At node 1 now, traverse left node first, however, there is no left node, hence return.\\n- At node 1 now, add root value which is 1. answer = [1]\\n- At node 1 now, traverse right node.\\n- At node 2 now, traverse left node first.\\n- At node 3 now,  traverse left node first, however, there is no left node, hence return.\\n- At node 3 now, add root value which is 3. answer = [1, 3]\\n- At node 3 now,  traverse right node, however, there is no right node, hence return.\\n- At node 2 now, add root value which is 2. answer = [1, 3, 2]\\n- At node 2 now, traverse right node, however, there is no right node, hence return.\\n\\n**C++**\\n\\n```cpp\\n// Time Complexity: O(N)\\n// Space Complexity: O(N)\\n\\n// This is a standard in-order traversal problem, I\\'d suggest to learn pre-order and post-order as well.\\n// Here\\'s a short tutorial if you\\'re interested.\\n// https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n// then you may try the following problems \\n// 144. Binary Tree Preorder Traversal: https://leetcode.com/problems/binary-tree-preorder-traversal/\\n// 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void inorder(TreeNode* node) {\\n        if (node == NULL) return;\\n        // traverse the left node\\n        inorder(node->left);\\n        // do something with node value here\\n        ans.push_back(node->val);\\n        // traverse the right node\\n        inorder(node->right);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        inorder(root);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n# This is a standard in-order traversal problem, I\\'d suggest to learn pre-order and post-order as well.\\n# Here\\'s a short tutorial if you\\'re interested.\\n# https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n# then you may try the following problems \\n# 144. Binary Tree Preorder Traversal: https://leetcode.com/problems/binary-tree-preorder-traversal/\\n# 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\t# left -> root -> right\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```cpp\\n// Time Complexity: O(N)\\n// Space Complexity: O(N)\\n\\n// This is a standard in-order traversal problem, I\\'d suggest to learn pre-order and post-order as well.\\n// Here\\'s a short tutorial if you\\'re interested.\\n// https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n// then you may try the following problems \\n// 144. Binary Tree Preorder Traversal: https://leetcode.com/problems/binary-tree-preorder-traversal/\\n// 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void inorder(TreeNode* node) {\\n        if (node == NULL) return;\\n        // traverse the left node\\n        inorder(node->left);\\n        // do something with node value here\\n        ans.push_back(node->val);\\n        // traverse the right node\\n        inorder(node->right);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        inorder(root);\\n        return ans;\\n    }\\n};\\n```\n```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n# This is a standard in-order traversal problem, I\\'d suggest to learn pre-order and post-order as well.\\n# Here\\'s a short tutorial if you\\'re interested.\\n# https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n# then you may try the following problems \\n# 144. Binary Tree Preorder Traversal: https://leetcode.com/problems/binary-tree-preorder-traversal/\\n# 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\t# left -> root -> right\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508286,
                "title": "c-simple-recursive-solution",
                "content": "**C++ :**\\n\\n```\\nvoid inorderTraversalHelper(TreeNode* root, vector<int> &res) {\\n\\tif(root)\\n\\t{\\n\\t\\tif(root -> left)\\n\\t\\t\\tinorderTraversalHelper(root -> left, res);\\n\\n\\t\\tres.push_back(root -> val);\\n\\n\\t\\tif(root -> right)\\n\\t\\t\\tinorderTraversalHelper(root -> right, res);\\n\\t}\\n\\n\\treturn;\\n}\\n\\n\\nvector<int> inorderTraversal(TreeNode* root) \\n{   \\n\\tvector<int> res;\\n\\tinorderTraversalHelper(root, res) ;\\n\\treturn res;\\n}\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvoid inorderTraversalHelper(TreeNode* root, vector<int> &res) {\\n\\tif(root)\\n\\t{\\n\\t\\tif(root -> left)\\n\\t\\t\\tinorderTraversalHelper(root -> left, res);\\n\\n\\t\\tres.push_back(root -> val);\\n\\n\\t\\tif(root -> right)\\n\\t\\t\\tinorderTraversalHelper(root -> right, res);\\n\\t}\\n\\n\\treturn;\\n}\\n\\n\\nvector<int> inorderTraversal(TreeNode* root) \\n{   \\n\\tvector<int> res;\\n\\tinorderTraversalHelper(root, res) ;\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31313,
                "title": "three-ways-of-iterative-inorder-traversing-easy-explanation",
                "content": "Three types of Iterative Inorder Traversals. \\n\\n1) **Using 1 Stack.** O(n) Time & O(n) Space\\n\\t* Push all `left` nodes into the `stack` till it hits `NULL`.\\n\\t* Then `Pop` the top element from the stack, print it and make the `root` point to its `right`.\\n\\t* Keep iterating till `both` the below conditions are met -\\n\\t\\t* Stack is empty `and`\\n        * Root is NULL.\\n\\t\\n```\\n \\npublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\tif(root==null)\\n\\t\\t\\treturn out;\\n\\t\\tStack<TreeNode> s = new Stack();      \\n\\t\\twhile(root!=null || !s.empty()){\\n\\t\\t\\tif(root!=null){\\t\\t\\t\\t\\n\\t\\t\\t\\ts.push(root);\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\troot = s.pop();\\n\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\troot = root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\t\\n```\\n\\n2) **Using 2 Stacks.** O(n) Time & O(n) Space\\nWe use two stacks. Stack `s` is used to find and traverse the child nodes, and `path` stack keeps track of the path from the `root` to the current node. (This is usefull in certain problems like [Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/) and [Path Sum](https://leetcode.com/problems/path-sum/) ). \\nThe logic is similar to [Preorder using 2 Stacks](https://discuss.leetcode.com/topic/64675/three-ways-of-iterative-preorder-traversing-easy-explanation) . The difference is on every iteration we first pop `s`. Then push it back in when we push the children. Make sure the order of pushing is right child -> root -> left child. Also, we print the element only on our way back.\\n    * Initially we push the `root` into `s`.\\n\\t* Keep iterating with below logic till `s` is `empty`.\\n\\t\\t* `root` = `s.pop()`\\n\\t\\t* If the top elements of both the stacks are not the same :\\t\\t\\n\\t\\t\\t* Push `root` into `path`.\\n\\t\\t\\t* Push `right child` into `s` if it exists.\\n\\t\\t\\t* Push `root` back into `s`.\\n\\t\\t\\t* Now, push `left child` into `s` if it exists.\\n\\t\\t* When top elements of both stacks are equal. (Which means we hit a deadend, and need to turn back)\\n\\t\\t\\t* Pop from `path`.\\n\\t\\t\\t* Print the root.\\n\\t\\n```\\n\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n        if(root == null)\\n            return out; \\n        Stack<TreeNode> s = new Stack(), path = new Stack();\\n        s.push(root);\\n        while(!s.empty()){\\n            root = s.pop();\\n            if(!path.empty() && path.peek()==root){                \\n                path.pop();\\n\\t\\t    out.add(root.val);\\n            }\\n            else{                \\n                path.push(root);\\n                if(root.right != null)\\n                    s.push(root.right);\\n\\t\\t    s.push(root);\\n                if(root.left != null)\\n                    s.push(root.left);\\n            }\\n        }\\n\\t    return out;\\n    }\\n\\t\\n```\\n\\n3) **Using No Stacks (Morris Traversal).** O(n) Time & O(1) Space\\nInstead of using stacks to remember our way back up the tree, we are going to modify the tree to create upwards links. The idea is based on [Threaded Binary Tree](https://en.wikipedia.org/wiki/Threaded_binary_tree). \\n\\t* Iterate till `root` is null.\\n\\t\\t* If `root` has a left child.\\n\\t\\t\\t* Find the `inorder predecessor`. (Inorder predecessor of root is the right most child of its left child)\\n\\t\\t\\t\\t* Make it point to root.\\n\\t\\t\\t\\t* `root` = `root.left`.\\n\\t\\t\\t* If its already pointing to root (which means we have traversed it already and are on our way up.)\\n\\t\\t\\t\\t* Make the `inorder predecessor` point to `null` (Reverting our structural changes)\\n\\t\\t\\t\\t* `root` = `root.right`.\\n\\t\\t* If left child is `null`\\n\\t\\t\\t* `root` = `root.right`. (We are climbing up our link.)\\n\\t\\t\\t\\n```\\n\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\t\\tif(root == null)\\n\\t\\t\\t\\treturn out;\\n\\t\\t\\tTreeNode pre = null;\\n\\t\\t\\twhile(root!=null){\\n\\t\\t\\t\\tif(root.left !=null){\\n\\t\\t\\t\\t\\tpre = root.left;\\n\\t\\t\\t\\t\\twhile(pre.right!=null && pre.right!=root)\\n\\t\\t\\t\\t\\t\\tpre=pre.right;\\n\\t\\t\\t\\t\\tif(pre.right==null){\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tpre.right=root;\\n\\t\\t\\t\\t\\t\\troot=root.left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t    out.add(root.val);\\n\\t\\t\\t\\t\\t\\tpre.right=null;\\n\\t\\t\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t\\t\\t}                   \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn out;\\n\\t\\t}\\n\\t\\t\\n```\\n\\nAlso checkout [PostOrder](https://discuss.leetcode.com/topic/64689/three-ways-of-iterative-postorder-traversing-easy-explanation)  & [PreOrder](https://discuss.leetcode.com/topic/64675/three-ways-of-iterative-preorder-traversing-easy-explanation)  :))",
                "solutionTags": [],
                "code": "```\\n \\npublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\tif(root==null)\\n\\t\\t\\treturn out;\\n\\t\\tStack<TreeNode> s = new Stack();      \\n\\t\\twhile(root!=null || !s.empty()){\\n\\t\\t\\tif(root!=null){\\t\\t\\t\\t\\n\\t\\t\\t\\ts.push(root);\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\troot = s.pop();\\n\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\troot = root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\t\\n```\n```\\n\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n        if(root == null)\\n            return out; \\n        Stack<TreeNode> s = new Stack(), path = new Stack();\\n        s.push(root);\\n        while(!s.empty()){\\n            root = s.pop();\\n            if(!path.empty() && path.peek()==root){                \\n                path.pop();\\n\\t\\t    out.add(root.val);\\n            }\\n            else{                \\n                path.push(root);\\n                if(root.right != null)\\n                    s.push(root.right);\\n\\t\\t    s.push(root);\\n                if(root.left != null)\\n                    s.push(root.left);\\n            }\\n        }\\n\\t    return out;\\n    }\\n\\t\\n```\n```\\n\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\t\\tif(root == null)\\n\\t\\t\\t\\treturn out;\\n\\t\\t\\tTreeNode pre = null;\\n\\t\\t\\twhile(root!=null){\\n\\t\\t\\t\\tif(root.left !=null){\\n\\t\\t\\t\\t\\tpre = root.left;\\n\\t\\t\\t\\t\\twhile(pre.right!=null && pre.right!=root)\\n\\t\\t\\t\\t\\t\\tpre=pre.right;\\n\\t\\t\\t\\t\\tif(pre.right==null){\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tpre.right=root;\\n\\t\\t\\t\\t\\t\\troot=root.left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t    out.add(root.val);\\n\\t\\t\\t\\t\\t\\tpre.right=null;\\n\\t\\t\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t\\t\\t}                   \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn out;\\n\\t\\t}\\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 890237,
                "title": "go-solution",
                "content": "```go\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc inorderTraversal(root *TreeNode) []int {\\n    \\n    ans := []int{}\\n    \\n    var inorder func(*TreeNode) \\n    \\n    inorder = func(root *TreeNode) {\\n        if root == nil {return}\\n        \\n        inorder(root.Left)\\n        ans = append(ans, root.Val)\\n        inorder(root.Right)\\n        \\n    }\\n    inorder(root)\\n    \\n    return ans;   \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc inorderTraversal(root *TreeNode) []int {\\n    \\n    ans := []int{}\\n    \\n    var inorder func(*TreeNode) \\n    \\n    inorder = func(root *TreeNode) {\\n        if root == nil {return}\\n        \\n        inorder(root.Left)\\n        ans = append(ans, root.Val)\\n        inorder(root.Right)\\n        \\n    }\\n    inorder(root)\\n    \\n    return ans;   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31409,
                "title": "share-my-solution-in-c",
                "content": "///// iterative solution\\n\\n    int* inorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    *returnSize = 0;\\n    \\n    struct TreeNode **stack = (struct TreeNode **)malloc(sizeof(struct TreeNode *));\\n    struct TreeNode *pop;\\n    int length = 0, state = 1;\\n    //stack[length++] = root;\\n    \\n    while (length>0 || root != NULL) {\\n        if (root) {\\n            stack = (struct TreeNode **)realloc(stack, sizeof(struct TreeNode *)*length+1);\\n            stack[length++] = root;\\n            root = root->left;\\n        }\\n        else {\\n            root = stack[--length];\\n            result = (int *)realloc(result, sizeof(int)*(*returnSize+1));\\n            result[*returnSize] = root->val;\\n            *returnSize += 1;\\n            root = root->right;\\n        }\\n    }\\n    \\n    return result;\\n}\\n\\n//// recursive solution\\n\\n    int* inorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    if (!root)\\n        return result;\\n    \\n    int *leftarr=NULL, *rightarr=NULL, leftsize=0, rightsize=0;\\n    if (root->left)\\n        leftarr = inorderTraversal(root->left, &leftsize);\\n    if (root->right)\\n        rightarr = inorderTraversal(root->right, &rightsize);\\n    \\n    *returnSize = 1 + leftsize + rightsize;\\n    result = (int *)malloc(sizeof(int)*(*returnSize));\\n    \\n    int i, j;\\n    for (i=0; i<leftsize; i++)\\n        result[i] = leftarr[i];\\n    result[i++] = root->val;\\n    for (j=0; j<rightsize; j++)\\n        result[i+j] = rightarr[j];\\n    free(leftarr); free(rightarr);\\n    \\n    return result;\\n}",
                "solutionTags": [],
                "code": "///// iterative solution\\n\\n    int* inorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    *returnSize = 0;\\n    \\n    struct TreeNode **stack = (struct TreeNode **)malloc(sizeof(struct TreeNode *));\\n    struct TreeNode *pop;\\n    int length = 0, state = 1;\\n    //stack[length++] = root;\\n    \\n    while (length>0 || root != NULL) {\\n        if (root) {\\n            stack = (struct TreeNode **)realloc(stack, sizeof(struct TreeNode *)*length+1);\\n            stack[length++] = root;\\n            root = root->left;\\n        }\\n        else {\\n            root = stack[--length];\\n            result = (int *)realloc(result, sizeof(int)*(*returnSize+1));\\n            result[*returnSize] = root->val;\\n            *returnSize += 1;\\n            root = root->right;\\n        }\\n    }\\n    \\n    return result;\\n}\\n\\n//// recursive solution\\n\\n    int* inorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    if (!root)\\n        return result;\\n    \\n    int *leftarr=NULL, *rightarr=NULL, leftsize=0, rightsize=0;\\n    if (root->left)\\n        leftarr = inorderTraversal(root->left, &leftsize);\\n    if (root->right)\\n        rightarr = inorderTraversal(root->right, &rightsize);\\n    \\n    *returnSize = 1 + leftsize + rightsize;\\n    result = (int *)malloc(sizeof(int)*(*returnSize));\\n    \\n    int i, j;\\n    for (i=0; i<leftsize; i++)\\n        result[i] = leftarr[i];\\n    result[i++] = root->val;\\n    for (j=0; j<rightsize; j++)\\n        result[i+j] = rightarr[j];\\n    free(leftarr); free(rightarr);\\n    \\n    return result;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 160386,
                "title": "python-solution",
                "content": "Recursive:\\n```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if root == None:\\n            return []\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```\\nIterative:\\n```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if root == None:\\n            return []\\n        trav = root\\n        res = []\\n        stack = []\\n        while stack or trav:\\n            while trav:\\n                stack.append(trav)\\n                trav = trav.left\\n            u = stack.pop()\\n            res.append(u.val)\\n            trav = u.right\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if root == None:\\n            return []\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```\n```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if root == None:\\n            return []\\n        trav = root\\n        res = []\\n        stack = []\\n        while stack or trav:\\n            while trav:\\n                stack.append(trav)\\n                trav = trav.left\\n            u = stack.pop()\\n            res.append(u.val)\\n            trav = u.right\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107203,
                "title": "java-recursive-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS in order traversal\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    private List<Integer> res = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        traverse(root);\\n        return res;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        traverse(root.left);\\n        res.add(root.val);\\n        traverse(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    private List<Integer> res = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        traverse(root);\\n        return res;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        traverse(root.left);\\n        res.add(root.val);\\n        traverse(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547003,
                "title": "easy-python-3-line-solution",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418125,
                "title": "simple-python-solution-recursive",
                "content": "```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        else:\\n            return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        else:\\n            return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307460,
                "title": "c-simple-solution",
                "content": "```\\nvoid travel(struct TreeNode* root,int *ret,int *size)\\n{\\n    if(root==NULL)return;\\n    travel(root->left,ret,size);\\n    ret[(*size)++]=root->val;\\n    travel(root->right,ret,size);\\n}\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    *returnSize=0;\\n    int *ret=malloc(sizeof(int)*100);\\n    travel(root,ret,returnSize);\\n    return ret;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvoid travel(struct TreeNode* root,int *ret,int *size)\\n{\\n    if(root==NULL)return;\\n    travel(root->left,ret,size);\\n    ret[(*size)++]=root->val;\\n    travel(root->right,ret,size);\\n}\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    *returnSize=0;\\n    int *ret=malloc(sizeof(int)*100);\\n    travel(root,ret,returnSize);\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31375,
                "title": "java-two-solutions-recursive-1-ms-and-non-recursive-2-ms",
                "content": "Recursive:`\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list =new ArrayList();\\n        addNode(list,root);\\n        return list;\\n    }\\n    public void addNode(List<Integer> list,TreeNode root){\\n        if(root==null) return;\\n        addNode(list,root.left);\\n        list.add(root.val);\\n        addNode(list,root.right); \\n    }\\n\\nNon-recursive :`\\n\\n        List<Integer> list =new ArrayList();\\n        Stack<TreeNode> stack=new Stack();\\n        if(root==null) return list;\\n        while(root!=null){\\n            stack.push(root);\\n            root=root.left;\\n            while(root==null){\\n                if(stack.empty()) return list;\\n                root=stack.pop();\\n                list.add(root.val);\\n                root=root.right;\\n            }\\n        }\\n        return list;\\n `",
                "solutionTags": [],
                "code": "Recursive:`\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list =new ArrayList();\\n        addNode(list,root);\\n        return list;\\n    }\\n    public void addNode(List<Integer> list,TreeNode root){\\n        if(root==null) return;\\n        addNode(list,root.left);\\n        list.add(root.val);\\n        addNode(list,root.right); \\n    }\\n\\nNon-recursive :`\\n\\n        List<Integer> list =new ArrayList();\\n        Stack<TreeNode> stack=new Stack();\\n        if(root==null) return list;\\n        while(root!=null){\\n            stack.push(root);\\n            root=root.left;\\n            while(root==null){\\n                if(stack.empty()) return list;\\n                root=stack.pop();\\n                list.add(root.val);\\n                root=root.right;\\n            }\\n        }\\n        return list;\\n `",
                "codeTag": "Unknown"
            },
            {
                "id": 31464,
                "title": "4ms-iterative-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            stack<TreeNode*> s;\\n            pushAllLeft(s, root);\\n            vector<int> result;\\n            while(!s.empty()) {\\n                TreeNode* p = s.top();\\n                s.pop();\\n                result.push_back(p->val);\\n                pushAllLeft(s,p->right);\\n            }\\n            return result;\\n        }\\n        \\n        void pushAllLeft(stack<TreeNode*>& s, TreeNode* root) {\\n            while(root) {\\n                s.push(root);\\n                root = root->left;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            stack<TreeNode*> s;\\n            pushAllLeft(s, root);\\n            vector<int> result;\\n            while(!s.empty()) {\\n                TreeNode* p = s.top();\\n                s.pop();\\n                result.push_back(p->val);\\n                pushAllLeft(s,p->right);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3673822,
                "title": "simplest-3-line-sol-with-explaination",
                "content": "# Intuition\\nThis code performs a inorder traversal on a binary tree and returns a list of integers containing the values of the nodes visited in the traversal.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create an instance variable `ans` of type `List<Integer>` to store the values of the nodes in the inorder traversal.\\n2. Define the `inorderTraversal` function that takes a `TreeNode` called `root` as input and returns a list of integers.\\n3. Check if the `root` is null. If it is, return the `ans` list.\\n4. Recursively call the `inorderTraversal` function on the left child of the current `root` node.\\n5. Add the value of the current `root` node to the `ans` list using the `add` method.\\n6. Recursively call the `inorderTraversal` function on the right child of the current `root` node.\\n7. Finally, return the `ans` list containing the values of the nodes visited in the inorder traversal.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    List<Integer> ans = new ArrayList<>();\\n\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n   if (root == null) return ans;\\n   inorderTraversal(root.left);\\n   ans.add(root.val);\\n   inorderTraversal(root.right);\\n   return ans;\\n}\\n}\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/34562f78-5f5b-4e2e-a154-2df98ad56ee8_1687528905.3259234.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    List<Integer> ans = new ArrayList<>();\\n\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n   if (root == null) return ans;\\n   inorderTraversal(root.left);\\n   ans.add(root.val);\\n   inorderTraversal(root.right);\\n   return ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926144,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the tree.\\n    //   - space: O(n), where n is the number of nodes in the tree.\\n    \\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var ans = [Int]()\\n        var stack = [TreeNode?]()\\n        var curr = root\\n\\n        while curr != nil || !stack.isEmpty {\\n            while curr != nil {\\n                stack.append(curr)\\n                curr = curr?.left\\n            }\\n            curr = stack.removeLast()\\n            if let val = curr?.val {\\n                ans.append(val)\\n            }\\n            curr = curr?.right\\n        }\\n\\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the tree.\\n    //   - space: O(n), where n is the number of nodes in the tree.\\n    \\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var ans = [Int]()\\n        var stack = [TreeNode?]()\\n        var curr = root\\n\\n        while curr != nil || !stack.isEmpty {\\n            while curr != nil {\\n                stack.append(curr)\\n                curr = curr?.left\\n            }\\n            curr = stack.removeLast()\\n            if let val = curr?.val {\\n                ans.append(val)\\n            }\\n            curr = curr?.right\\n        }\\n\\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533303,
                "title": "iterative-inorder-traversal-with-full-explanation",
                "content": "**Inorder tree traversal** is a type of *depth first search* (DFS) where we explore tree nodes in a particular order: left, root, right. \\n\\nTypically DFS is done recursively but I could also implement it with a *stack* (an abstract data type). To solve this problem, I\\'m going to implement a stack with a Python `list`.\\n\\nA more thorough explanation can be found on my [GitHub](https://github.com/sanoke/leetcode/blob/master/tree%20traversal/0094-binary-tree-inorder-traversal.ipynb), where I also do an inorder traversal of an example tree to demonstrate some intuition behind the process.\\n\\n```python\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode):\\n        # initialize the stack\\n        stack = []\\n        # initialize the traveral list\\n        traversal = []\\n        \\n        # while we\\'re at a valid node or there are\\n        # still nodes to traverse... \\n        while stack or root:\\n            \\n            if root:\\n                # if we\\'re at a valid node,\\n                # remember where we\\'ve been and keep moving left\\n                stack.append(root)\\n                root = root.left\\n            \\n            else:\\n                # otherwise we\\'ve hit a dead end so\\n                # -- pop the most recent value\\n                # -- report out\\n                # -- move right\\n                root = stack.pop()\\n                traversal.append(root.val)\\n                root = root.right\\n        \\n        return traversal\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode):\\n        # initialize the stack\\n        stack = []\\n        # initialize the traveral list\\n        traversal = []\\n        \\n        # while we\\'re at a valid node or there are\\n        # still nodes to traverse... \\n        while stack or root:\\n            \\n            if root:\\n                # if we\\'re at a valid node,\\n                # remember where we\\'ve been and keep moving left\\n                stack.append(root)\\n                root = root.left\\n            \\n            else:\\n                # otherwise we\\'ve hit a dead end so\\n                # -- pop the most recent value\\n                # -- report out\\n                # -- move right\\n                root = stack.pop()\\n                traversal.append(root.val)\\n                root = root.right\\n        \\n        return traversal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527791,
                "title": "javascript-10-lines-iterative-and-recursive",
                "content": "### Iterative In-order Traverse\\n- Time Complexity: O(N)\\n- Space Complexity: O(H)\\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    let curr = root,  res = [], stack = [];\\n    while (curr || stack.length) {\\n        while (curr) {\\n            stack.push(curr);\\n            curr = curr.left;\\n        }\\n        curr = stack.pop();\\n        res.push(curr.val);\\n        curr = curr.right;\\n    }\\n    return res;\\n};\\n```\\n### Recursive In-order Traverse\\n\\n- Time Complexity: O(N)\\n- Space Complexity: O(H)\\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    const res = [];\\n    traverse(root);\\n    return res;\\n    \\n    function traverse(node) {\\n        if (!node) return;\\n        traverse(node.left);\\n        res.push(node.val);\\n        traverse(node.right);\\n    }\\n};\\n```\\n\\n- Time Complexity:\\n    - `an spread syntax takes linear time and it takes T(n/2) in this implementation`\\n    - average: O(N log N)\\n    - worst: O(N^2) `unbalanced tree`\\n- Space Complexity: O(H)\\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    if (!root) return [];\\n    const res = [];\\n    res.push(...inorderTraversal(root.left));\\n    res.push(root.val);\\n    res.push(...inorderTraversal(root.right));\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    let curr = root,  res = [], stack = [];\\n    while (curr || stack.length) {\\n        while (curr) {\\n            stack.push(curr);\\n            curr = curr.left;\\n        }\\n        curr = stack.pop();\\n        res.push(curr.val);\\n        curr = curr.right;\\n    }\\n    return res;\\n};\\n```\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    const res = [];\\n    traverse(root);\\n    return res;\\n    \\n    function traverse(node) {\\n        if (!node) return;\\n        traverse(node.left);\\n        res.push(node.val);\\n        traverse(node.right);\\n    }\\n};\\n```\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    if (!root) return [];\\n    const res = [];\\n    res.push(...inorderTraversal(root.left));\\n    res.push(root.val);\\n    res.push(...inorderTraversal(root.right));\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31364,
                "title": "java-recursive-and-iterative-solutions",
                "content": "        \\n    // recursively\\n    public List<Integer> inorderTraversal1(TreeNode root) {\\n        List<Integer> ret = new ArrayList<>();\\n        dfs(root, ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(TreeNode node, List<Integer> ret) {\\n        if (node != null) {\\n            dfs(node.left, ret);\\n            ret.add(node.val);\\n            dfs(node.right, ret);\\n        }\\n    }\\n    \\n    // iteratively\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n       Stack<TreeNode> stack = new Stack<>();\\n       List<Integer> ret = new ArrayList<>();\\n       while (true) {\\n           while (root != null) {\\n               stack.push(root);\\n               root = root.left;\\n           }\\n           if (stack.isEmpty()) {\\n               break;  // no node left\\n           }\\n           TreeNode node = stack.pop();\\n           ret.add(node.val);\\n           root = node.right;\\n       }\\n       return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // recursively\\n    public List<Integer> inorderTraversal1(TreeNode root) {\\n        List<Integer> ret = new ArrayList<>();\\n        dfs(root, ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(TreeNode node, List<Integer> ret) {\\n        if (node != null) {\\n            dfs(node.left, ret);\\n            ret.add(node.val);\\n            dfs(node.right, ret);\\n        }\\n    }\\n    \\n    // iteratively\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n       Stack<TreeNode> stack = new Stack<>();\\n       List<Integer> ret = new ArrayList<>();\\n       while (true) {\\n           while (root != null) {\\n               stack.push(root);\\n               root = root.left;\\n           }\\n           if (stack.isEmpty()) {\\n               break;  // no node left\\n           }\\n           TreeNode node = stack.pop();\\n           ret.add(node.val);\\n           root = node.right;\\n       }\\n       return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2967362,
                "title": "javascript-recursive-and-iterative-explained",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    let result = [];\\n\\n    /*\\n    RECURSIVE SOLUTION\\n\\n    function inorder(root) {\\n        // if node null, return back to the prenode (works like that with recursive functions)\\n        if (!root) {\\n            return;\\n        }\\n\\n        inorder(root.left);    // recursive call for left nodes\\n        result.push(root.val); // push to result   \\n        inorder(root.right);   // when its done with left, start right\\n\\n    }\\n    // call recursive function\\n    inorder(root);\\n    return result;\\n    */\\n\\n\\n    // ITERATIVE SOLUTION \\n\\n    // The call stack, which we can return to the parent node and decide if there is something to do left\\n    let stack = [];\\n    // The pointer on the current node\\n    let currentNode = root;\\n\\n    while (currentNode || stack.length) {\\n        // this loop is going down the left nodes and exits if there is no left node anymore. Also adds all nodes to Stack\\n        if(currentNode) {\\n            stack.push(currentNode);\\n            currentNode = currentNode.left;\\n        } else {\\n// finishing the above loop, it means we are at the deepest left node we could get and all ar added, so now we need to point the currentNode to the parentNode. We do this by popping the last item in our callstack, which was the parentNode. pop returns the last item, currentNode is now the last Item (Parent)\\n        currentNode = stack.pop()\\n// We add currentNode to the result, because inorder traversal is \"\"left-root-right\"-order\", so we always add the most left node which is left (and has no left children)\\n        result.push(currentNode.val);\\n// then we point the pointer to the right node (even if its null)\\n        currentNode = currentNode.right;\\n        \\n// After we were at the deepest left, a new outer while loop is started, where is checked if currentNode exists, if yes, add to stack, move left. if not, set currentNode/pointer to parent, push it to result and set to right child node.\\n        }\\n            \\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    let result = [];\\n\\n    /*\\n    RECURSIVE SOLUTION\\n\\n    function inorder(root) {\\n        // if node null, return back to the prenode (works like that with recursive functions)\\n        if (!root) {\\n            return;\\n        }\\n\\n        inorder(root.left);    // recursive call for left nodes\\n        result.push(root.val); // push to result   \\n        inorder(root.right);   // when its done with left, start right\\n\\n    }\\n    // call recursive function\\n    inorder(root);\\n    return result;\\n    */\\n\\n\\n    // ITERATIVE SOLUTION \\n\\n    // The call stack, which we can return to the parent node and decide if there is something to do left\\n    let stack = [];\\n    // The pointer on the current node\\n    let currentNode = root;\\n\\n    while (currentNode || stack.length) {\\n        // this loop is going down the left nodes and exits if there is no left node anymore. Also adds all nodes to Stack\\n        if(currentNode) {\\n            stack.push(currentNode);\\n            currentNode = currentNode.left;\\n        } else {\\n// finishing the above loop, it means we are at the deepest left node we could get and all ar added, so now we need to point the currentNode to the parentNode. We do this by popping the last item in our callstack, which was the parentNode. pop returns the last item, currentNode is now the last Item (Parent)\\n        currentNode = stack.pop()\\n// We add currentNode to the result, because inorder traversal is \"\"left-root-right\"-order\", so we always add the most left node which is left (and has no left children)\\n        result.push(currentNode.val);\\n// then we point the pointer to the right node (even if its null)\\n        currentNode = currentNode.right;\\n        \\n// After we were at the deepest left, a new outer while loop is started, where is checked if currentNode exists, if yes, add to stack, move left. if not, set currentNode/pointer to parent, push it to result and set to right child node.\\n        }\\n            \\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2555429,
                "title": "binary-tree-inorder-traversal",
                "content": "1. ITERATIVE APPROACH\\nIn iterative approach, the stack data structure is used. We need to store the current or parent node so that after processing the left subtree we can process the node so we push the node in the stack data structure. After processing the node, we pop that respective node.\\n\\n```\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        stack<TreeNode*>st;\\n        while(1){\\n            if(root!=NULL){\\n                st.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                if(st.empty()==true) break;\\n                root=st.top();\\n                st.pop();\\n                ans.push_back(root->val);\\n                root=root->right;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\t\\n2. RECURSIVE APPROACH\\nThe first call recursively left child node until getting NULL value then get node value and then call recursively right child node until getting NULL. So now print the value of all nodes inorder traversing.\\n\\n```\\n\\tclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        inorder(root -> left, nodes);\\n        nodes.push_back(root -> val);\\n        inorder(root -> right, nodes);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        stack<TreeNode*>st;\\n        while(1){\\n            if(root!=NULL){\\n                st.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                if(st.empty()==true) break;\\n                root=st.top();\\n                st.pop();\\n                ans.push_back(root->val);\\n                root=root->right;\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\n\\tclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        inorder(root -> left, nodes);\\n        nodes.push_back(root -> val);\\n        inorder(root -> right, nodes);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547292,
                "title": "c-recursive-morris-traversal-approach",
                "content": "**Please upvote if you like the post :)**\\n\\n**Intuition:**\\nSeeing tree problems, first thing that hit\\'s your brain is? what is it? Yessss its **Recursion.**\\n\\n**Approach: (DFS Traversal)**\\n* **Inorder** Traversal follows - **Left Root Right**\\n* If `root==NULL` we can simply return `{}`;\\n* we declare a vector **vec** and simply push all the `root->val` after every **left** traversal and after that **right** traversal happens.\\n \\n**Visualization: (DFS)**\\n![image](https://assets.leetcode.com/users/images/910dc845-947f-4f49-806c-dec5f90fd9f4_1662608198.1349866.gif)\\n\\n\\n\\n\\n\\n**C++:(DFS Traversal)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> vec; \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==NULL)\\n            return {};\\n        inorderTraversal(root->left);\\n        vec.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return vec;\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(N)**, where N is the number of nodes in the Binary Tree.\\n**Space Complexity:** **O(N)**, where N is the number of node in the Binary Tree (Recursion stack space)\\n****\\n**Approach 2: (Optimized - Morris Traversal)**\\n* So the idea is that at a `node` whether we have to move `left` or `right` is determined whether the node has a **left** subtree. \\n* If it doesn\\u2019t we move to the **right**. \\n* If there is a `left` subtree then we see its `rightmost` child. If the `rightmost` child is pointing to `NULL`, we move the **current** node to its **left**. \\n* If the **rightmost** child is already pointing towards the **current** node, we remove that link and move to the **right** of the **current** node. \\n* We will **stop** the execution when the **current** points to `null` and we have traversed the whole tree.\\n \\n**Visualization: (Optimized - Morris Traversal)**\\n![image](https://assets.leetcode.com/users/images/27affd71-dfea-4a3f-9755-d5648c86ccf5_1662608543.0316582.png)\\n\\n\\n\\n**C++:(Optimized - Morris Traversal)** \\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> inOrder;\\n        TreeNode* cur = root;\\n        while(cur!=NULL){\\n            if(cur->left==NULL){\\n                inOrder.push_back(cur->val);\\n                cur=cur->right;\\n            }\\n            else{\\n                TreeNode* prev = cur->left;\\n                while(prev->right!=NULL && prev->right!=cur){\\n                    prev=prev->right;\\n                }\\n                if(prev->right==NULL){\\n                    prev->right=cur;\\n                    cur=cur->left;\\n                }\\n                else if(prev->right==cur){\\n                    prev->right=NULL;\\n                    inOrder.push_back(cur->val);\\n                    cur=cur->right;\\n                }\\n            }\\n        }\\n        return inOrder;\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(N)**, where N is the number of nodes in the Binary Tree.\\n**Space Complexity:** **O(1)**, constant space\\n****",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vec; \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==NULL)\\n            return {};\\n        inorderTraversal(root->left);\\n        vec.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return vec;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> inOrder;\\n        TreeNode* cur = root;\\n        while(cur!=NULL){\\n            if(cur->left==NULL){\\n                inOrder.push_back(cur->val);\\n                cur=cur->right;\\n            }\\n            else{\\n                TreeNode* prev = cur->left;\\n                while(prev->right!=NULL && prev->right!=cur){\\n                    prev=prev->right;\\n                }\\n                if(prev->right==NULL){\\n                    prev->right=cur;\\n                    cur=cur->left;\\n                }\\n                else if(prev->right==cur){\\n                    prev->right=NULL;\\n                    inOrder.push_back(cur->val);\\n                    cur=cur->right;\\n                }\\n            }\\n        }\\n        return inOrder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385969,
                "title": "easiest-traversal-without-stack-queue-100-inorder",
                "content": "##  **Using This Solution We Can Make Inorder Traversal In Binary Tree Without Using Stack And Queue.**\\n\\n##### Global Declaration Of Ans Vector.\\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root == NULL){\\n            return v;\\n        }\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return v;\\n    }\\n};\\n```\\n\\n\\n##### Pass By Reference Ans Vector.\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode *root, vector<int> &ans){\\n        if(root == NULL) return ;\\n        helper(root->left,ans);\\n        ans.push_back(root->val);\\n        helper(root->right,ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans; helper(root,ans);\\n        return ans;\\n    }\\n};\\n```\\n**Like & UpVote If You Get My Intuition Also Comment If You Have Any Query..**\\n\\n",
                "solutionTags": [
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root == NULL){\\n            return v;\\n        }\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode *root, vector<int> &ans){\\n        if(root == NULL) return ;\\n        helper(root->left,ans);\\n        ans.push_back(root->val);\\n        helper(root->right,ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans; helper(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294202,
                "title": "golang-recursive-100-faster-0-ms",
                "content": "```\\nfunc inorderTraversal(root *TreeNode) []int {\\n    var nums = []int{}\\n    if root == nil {\\n        return nums\\n    }\\n    \\n    nums = append(nums, inorderTraversal(root.Left)...)\\n    nums = append(nums, root.Val)\\n    nums = append(nums, inorderTraversal(root.Right)...)\\n    return nums\\n}\\nPlease upvote if you like\\n```",
                "solutionTags": [
                    "Go",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nfunc inorderTraversal(root *TreeNode) []int {\\n    var nums = []int{}\\n    if root == nil {\\n        return nums\\n    }\\n    \\n    nums = append(nums, inorderTraversal(root.Left)...)\\n    nums = append(nums, root.Val)\\n    nums = append(nums, inorderTraversal(root.Right)...)\\n    return nums\\n}\\nPlease upvote if you like\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1251231,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==NULL)\\n            return {};\\n        inorderTraversal(root->left);\\n        ans.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==NULL)\\n            return {};\\n        inorderTraversal(root->left);\\n        ans.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 668448,
                "title": "morris-traversal",
                "content": "I wanted to share an example of in-place Morris traversal. Didn\\'t see many Python examples out there. This example is based off Tushar\\'s morris traversal video: https://youtu.be/wGXB9OWhPTg and various sources I found: \\n\\nhttps://www.***.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\nhttps://leetcode.com/problems/binary-tree-inorder-traversal/discuss/148939/CPP-Morris-Traversal\\n\\n```python\\n\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res = []\\n\\n        while root:\\n            if not root.left: # if we don\\'t have a left, this is our best in-order value at the moment. add it to the list and move right.\\n                res.append(root.val)\\n                root = root.right\\n            else:\\n                pred = self.findPredecessor(root) # find the predecessor for the given node. This is the farthest right of the first left we see.\\n\\n\\t\\t\\t\\t# if we have a right we have move on to explore this sub tree. The pred.right != root check is to ensure that we\\'re not ex\\n                if pred.right != root:\\n                    pred.right = root\\n                    root = root.left\\n                else: \\n\\t\\t\\t\\t# otherwise, we have found a pointer back to the current root and we need to rewrite the tree structure. This is basically a form of \"have we seen this before?\".\\n                    root.left = None\\n\\n        return res\\n\\n    def findPredecessor(self, root: TreeNode) -> TreeNode:\\n        curr = root.left\\n\\n        while curr.right and curr.right != root:\\n            curr = curr.right\\n\\n        return curr\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\n\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res = []\\n\\n        while root:\\n            if not root.left: # if we don\\'t have a left, this is our best in-order value at the moment. add it to the list and move right.\\n                res.append(root.val)\\n                root = root.right\\n            else:\\n                pred = self.findPredecessor(root) # find the predecessor for the given node. This is the farthest right of the first left we see.\\n\\n\\t\\t\\t\\t# if we have a right we have move on to explore this sub tree. The pred.right != root check is to ensure that we\\'re not ex\\n                if pred.right != root:\\n                    pred.right = root\\n                    root = root.left\\n                else: \\n\\t\\t\\t\\t# otherwise, we have found a pointer back to the current root and we need to rewrite the tree structure. This is basically a form of \"have we seen this before?\".\\n                    root.left = None\\n\\n        return res\\n\\n    def findPredecessor(self, root: TreeNode) -> TreeNode:\\n        curr = root.left\\n\\n        while curr.right and curr.right != root:\\n            curr = curr.right\\n\\n        return curr\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 31261,
                "title": "c-solution",
                "content": "```\\n    public IList<int> InorderTraversal(TreeNode root) {\\n        List<int> result = new List<int>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode currentNode = root;\\n\\n        while (currentNode != null || stack.Count != 0)\\n        {\\n            while (currentNode != null)\\n            {\\n                stack.Push(currentNode);\\n                currentNode = currentNode.left;\\n            }\\n            \\n            if (stack.Count != 0)\\n            {\\n                currentNode = stack.Pop();\\n                result.Add(currentNode.val);\\n                currentNode = currentNode.right;\\n            }\\n        }\\n            \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public IList<int> InorderTraversal(TreeNode root) {\\n        List<int> result = new List<int>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode currentNode = root;\\n\\n        while (currentNode != null || stack.Count != 0)\\n        {\\n            while (currentNode != null)\\n            {\\n                stack.Push(currentNode);\\n                currentNode = currentNode.left;\\n            }\\n            \\n            if (stack.Count != 0)\\n            {\\n                currentNode = stack.Pop();\\n                result.Add(currentNode.val);\\n                currentNode = currentNode.right;\\n            }\\n        }\\n            \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31422,
                "title": "java-simple-and-clean",
                "content": "No1:\\n\\n     List<Integer> ans = new ArrayList<>();\\n    \\n    public List<Integer> inorderTraversal(TreeNode root) {\\n       if (root == null) return ans;\\n       inorderTraversal(root.left);\\n       ans.add(root.val);\\n       return inorderTraversal(root.right);\\n    }\\n\\n\\nNo2:\\n\\n       public List<Integer> inorderTraversal(TreeNode root) {\\n    \\tStack<TreeNode> stack = new Stack<>();\\n    \\tTreeNode cur = root;\\n    \\twhile (!stack.isEmpty() || cur != null) {\\n    \\t\\twhile (cur != null) {\\n        \\t\\tstack.push(cur);\\n        \\t\\tcur = cur.left;\\n        \\t}\\n    \\t\\tcur = stack.pop();\\n    \\t\\tans.add(cur.val);\\n    \\t\\tcur = cur.right;\\n     \\t}\\n    \\treturn ans;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "No1:\\n\\n     List<Integer> ans = new ArrayList<>();\\n    \\n    public List<Integer> inorderTraversal(TreeNode root) {\\n       if (root == null) return ans;\\n       inorderTraversal(root.left);\\n       ans.add(root.val);\\n       return inorderTraversal(root.right);\\n    }\\n\\n\\nNo2:\\n\\n       public List<Integer> inorderTraversal(TreeNode root) {\\n    \\tStack<TreeNode> stack = new Stack<>();\\n    \\tTreeNode cur = root;\\n    \\twhile (!stack.isEmpty() || cur != null) {\\n    \\t\\twhile (cur != null) {\\n        \\t\\tstack.push(cur);\\n        \\t\\tcur = cur.left;\\n        \\t}\\n    \\t\\tcur = stack.pop();\\n    \\t\\tans.add(cur.val);\\n    \\t\\tcur = cur.right;\\n     \\t}\\n    \\treturn ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31411,
                "title": "iterative-0ms-c-solution-with-o-1-space",
                "content": "    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n    \\tTreeNode *buf;\\n    \\twhile (root) {\\n    \\t\\tif (root->left) {\\n    \\t\\t\\tbuf = root->left;\\n    \\t\\t\\twhile (buf->right){\\n    \\t\\t\\t\\tbuf = buf->right;\\n    \\t\\t\\t}\\n    \\t\\t\\tbuf->right = root;\\n    \\t\\t\\tbuf = root->left;\\n    \\t\\t\\troot->left = NULL;\\n    \\t\\t\\troot = buf;\\n    \\t\\t}\\n    \\t\\telse {\\n    \\t\\t\\tans.push_back(root->val);\\n    \\t\\t\\troot = root->right;\\n    \\t\\t}\\n    \\t}\\n    \\treturn ans;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n    \\tTreeNode *buf;\\n    \\twhile (root) {\\n    \\t\\tif (root->left) {\\n    \\t\\t\\tbuf = root->left;\\n    \\t\\t\\twhile (buf->right){\\n    \\t\\t\\t\\tbuf = buf->right;\\n    \\t\\t\\t}\\n    \\t\\t\\tbuf->right = root;\\n    \\t\\t\\tbuf = root->left;\\n    \\t\\t\\troot->left = NULL;\\n    \\t\\t\\troot = buf;\\n    \\t\\t}\\n    \\t\\telse {\\n    \\t\\t\\tans.push_back(root->val);\\n    \\t\\t\\troot = root->right;\\n    \\t\\t}\\n    \\t}\\n    \\treturn ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3198212,
                "title": "c-recursive-iterative-all",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple three steps in Inorder Traversal :\\n- Left Traversal\\n- Push The ROOT \\n- Right Traversal\\n<--------**LPR**------->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Recusrive : Do left recursion then push  then Do right recursion\\n- Iterative : Use a stack (just like recursion stack is internally used ,same is here) .So just start from root and go left upto left !=null and keep pushing them in stack and then  store the topof stack  in answer vector and pop that  and then  for that top go for its right . (L->P->R strategy)\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Recusrive INorder**\\n```\\nvector<int>ans;\\n    void Inorder(TreeNode * root){\\n        if(!root)return;\\n        Inorder(root->left);\\n        ans.push_back(root->val);\\n        Inorder(root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        Inorder(root);\\n        return ans;\\n    }\\n```\\n**Iterative Inorder**\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        if(!root)return {};\\n         stack<TreeNode*>st;\\n         TreeNode* temp=root;\\n         while(!st.empty() or temp){\\n             while(temp){\\n                 st.push(temp);\\n                 temp=temp->left;\\n             }\\n             temp=st.top();\\n             ans.push_back(st.top()->val);\\n             st.pop();\\n             temp=temp->right;\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nvector<int>ans;\\n    void Inorder(TreeNode * root){\\n        if(!root)return;\\n        Inorder(root->left);\\n        ans.push_back(root->val);\\n        Inorder(root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        Inorder(root);\\n        return ans;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        if(!root)return {};\\n         stack<TreeNode*>st;\\n         TreeNode* temp=root;\\n         while(!st.empty() or temp){\\n             while(temp){\\n                 st.push(temp);\\n                 temp=temp->left;\\n             }\\n             temp=st.top();\\n             ans.push_back(st.top()->val);\\n             st.pop();\\n             temp=temp->right;\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547358,
                "title": "java-easy-solution-100-faster-code-minimum-lines-codes",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n    List<Integer> res = new ArrayList<Integer>();\\n    in(root,res);\\n    return res;\\n}\\n\\npublic void in(TreeNode root,List<Integer> res){\\n    if(root==null)\\n        return;\\n    in(root.left,res);\\n    res.add(root.val);\\n    in(root.right,res);\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n    List<Integer> res = new ArrayList<Integer>();\\n    in(root,res);\\n    return res;\\n}\\n\\npublic void in(TreeNode root,List<Integer> res){\\n    if(root==null)\\n        return;\\n    in(root.left,res);\\n    res.add(root.val);\\n    in(root.right,res);\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414598,
                "title": "rust-solution",
                "content": "```Rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn inorder_traversal(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\\n        let mut res = vec![];\\n        \\n        fn traversal(node: Option<Rc<RefCell<TreeNode>>>, res: &mut Vec<i32>) {\\n            if let Some(n) = node {\\n                traversal(n.borrow().left.clone(), res);\\n                res.push(n.borrow().val);\\n                traversal(n.borrow().right.clone(), res);\\n            }\\n        }\\n        \\n        traversal(root, &mut res);\\n        \\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```Rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn inorder_traversal(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\\n        let mut res = vec![];\\n        \\n        fn traversal(node: Option<Rc<RefCell<TreeNode>>>, res: &mut Vec<i32>) {\\n            if let Some(n) = node {\\n                traversal(n.borrow().left.clone(), res);\\n                res.push(n.borrow().val);\\n                traversal(n.borrow().right.clone(), res);\\n            }\\n        }\\n        \\n        traversal(root, &mut res);\\n        \\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1329494,
                "title": "0-ms-swift-binary-tree-inorder-traversal-test-cases",
                "content": "```swift\\nclass Solution {\\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var result = [Int](), array = [TreeNode](), head = root\\n        while head != nil || !(array.isEmpty) {\\n            switch head {\\n            case .some(let node):\\n                array.append(node)\\n                head = node.left\\n            default:\\n                let prev = array.removeLast()\\n                result.append(prev.val)\\n                head = prev.right\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.046 (0.048) seconds\\n\\nclass Tests: XCTestCase {\\n    let s = Solution()\\n    func test0() {\\n        let res = s.inorderTraversal(.init([1,nil,2,3]))\\n        XCTAssertEqual(res, [1,3,2])\\n    }\\n    func test1() {\\n        let res = s.inorderTraversal(.init([]))\\n        XCTAssertEqual(res, [])\\n    }\\n    func test2() {\\n        let res = s.inorderTraversal(.init([1]))\\n        XCTAssertEqual(res, [1])\\n    }\\n    func test3() {\\n        let res = s.inorderTraversal(.init([1,2]))\\n        XCTAssertEqual(res, [2,1])\\n    }\\n    func test4() {\\n        let res = s.inorderTraversal(.init([1,nil,2]))\\n        XCTAssertEqual(res, [1,2])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        val = head; left = nil; right = nil\\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var result = [Int](), array = [TreeNode](), head = root\\n        while head != nil || !(array.isEmpty) {\\n            switch head {\\n            case .some(let node):\\n                array.append(node)\\n                head = node.left\\n            default:\\n                let prev = array.removeLast()\\n                result.append(prev.val)\\n                head = prev.right\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.046 (0.048) seconds\\n\\nclass Tests: XCTestCase {\\n    let s = Solution()\\n    func test0() {\\n        let res = s.inorderTraversal(.init([1,nil,2,3]))\\n        XCTAssertEqual(res, [1,3,2])\\n    }\\n    func test1() {\\n        let res = s.inorderTraversal(.init([]))\\n        XCTAssertEqual(res, [])\\n    }\\n    func test2() {\\n        let res = s.inorderTraversal(.init([1]))\\n        XCTAssertEqual(res, [1])\\n    }\\n    func test3() {\\n        let res = s.inorderTraversal(.init([1,2]))\\n        XCTAssertEqual(res, [2,1])\\n    }\\n    func test4() {\\n        let res = s.inorderTraversal(.init([1,nil,2]))\\n        XCTAssertEqual(res, [1,2])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        val = head; left = nil; right = nil\\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197245,
                "title": "python3-31ms-easy-explanation",
                "content": "# Approach\\n- first traverse till last node in left branch of every next node.\\n- now return when None node found\\n- append current element to inorder list\\n- at this point this means we traversed all left possible nodes.\\n- now go to right branch and do the same.\\n- return inord.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        inord = []\\n        def inorder(curr=root):\\n            nonlocal inord\\n            if curr:\\n                inorder(curr.left)\\n                inord.append(curr.val)\\n                inorder(curr.right)\\n            return\\n        inorder()\\n        return inord\\n```\\n# Please like and comment below.\\n# ( \\u0361\\u1D54\\u202F\\u035C\\u0296 \\u0361\\u1D54)\\u270C",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        inord = []\\n        def inorder(curr=root):\\n            nonlocal inord\\n            if curr:\\n                inorder(curr.left)\\n                inord.append(curr.val)\\n                inorder(curr.right)\\n            return\\n        inorder()\\n        return inord\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830795,
                "title": "c-easy-solution-100-fast",
                "content": "```\\nint i=0;\\nint arr[101]={0};\\nvoid inorder(struct TreeNode* s)\\n{\\n    if(s!=NULL)\\n    {\\n        inorder(s->left);\\n        arr[i++]=s->val;\\n        inorder(s->right);\\n    }\\n}\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    inorder(root);\\n    int* ans=malloc(i*sizeof(int));\\n    for(int j=0;j<i;j++) ans[j]=arr[j];\\n    *(returnSize)=i;\\n    i=0;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint i=0;\\nint arr[101]={0};\\nvoid inorder(struct TreeNode* s)\\n{\\n    if(s!=NULL)\\n    {\\n        inorder(s->left);\\n        arr[i++]=s->val;\\n        inorder(s->right);\\n    }\\n}\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    inorder(root);\\n    int* ans=malloc(i*sizeof(int));\\n    for(int j=0;j<i;j++) ans[j]=arr[j];\\n    *(returnSize)=i;\\n    i=0;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803478,
                "title": "python-simple-python-solution-using-recursion-faster-than-90-84",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 33 ms, faster than 90.84% of Python3 online submissions for Binary Tree Inorder Traversal.\\n# Memory Usage: 13.8 MB, less than 60.15% of Python3 online submissions for Binary Tree Inorder Traversal.\\n\\n\\tclass Solution:\\n\\t\\tdef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\n\\t\\t\\tself.result = []\\n\\n\\t\\t\\tdef InOrderTraversal(node):\\n\\n\\t\\t\\t\\tif node == None:\\n\\t\\t\\t\\t\\treturn None\\n\\n\\t\\t\\t\\tInOrderTraversal(node.left)\\n\\t\\t\\t\\tself.result.append(node.val)\\n\\t\\t\\t\\tInOrderTraversal(node.right)\\n\\n\\t\\t\\tInOrderTraversal(root)\\n\\n\\t\\t\\treturn self.result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 33 ms, faster than 90.84% of Python3 online submissions for Binary Tree Inorder Traversal.\\n# Memory Usage: 13.8 MB, less than 60.15% of Python3 online submissions for Binary Tree Inorder Traversal.\\n\\n\\tclass Solution:\\n\\t\\tdef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\n\\t\\t\\tself.result = []\\n\\n\\t\\t\\tdef InOrderTraversal(node):\\n\\n\\t\\t\\t\\tif node == None:\\n\\t\\t\\t\\t\\treturn None\\n\\n\\t\\t\\t\\tInOrderTraversal(node.left)\\n\\t\\t\\t\\tself.result.append(node.val)\\n\\t\\t\\t\\tInOrderTraversal(node.right)\\n\\n\\t\\t\\tInOrderTraversal(root)\\n\\n\\t\\t\\treturn self.result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 1743165,
                "title": "javascript-typescript-simple-2-line-recursive-solution-time-97-faster-memory-5-less",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     val: number\\n *     left: TreeNode | null\\n *     right: TreeNode | null\\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.left = (left===undefined ? null : left)\\n *         this.right = (right===undefined ? null : right)\\n *     }\\n * }\\n */\\n\\nfunction inorderTraversal(root: TreeNode | null): number[] {\\n    if (root === null) return [];\\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     val: number\\n *     left: TreeNode | null\\n *     right: TreeNode | null\\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.left = (left===undefined ? null : left)\\n *         this.right = (right===undefined ? null : right)\\n *     }\\n * }\\n */\\n\\nfunction inorderTraversal(root: TreeNode | null): number[] {\\n    if (root === null) return [];\\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486984,
                "title": "single-iterative-solution-for-preorder-inorder-and-postorder-traversals-in-one-go",
                "content": "```\\nclass Solution:\\n\\tdef inorderTraversal(self, root):\\n\\n\\t\\tpreo,ino,posto,stack=[],[],[],[[root,1]]\\n\\t\\tif not root:\\n\\t\\t\\treturn\\n\\t\\twhile stack:\\n\\t\\t\\tn=stack.pop()\\n\\n\\t\\t\\t#Preorder Traversal\\n\\t\\t\\tif n[1]==1:\\n\\t\\t\\t\\tpreo.append(n[0].val)\\n\\t\\t\\t\\tn[1]+=1\\n\\t\\t\\t\\tstack.append(n)\\n\\t\\t\\t\\tif n[0].left:\\n\\t\\t\\t\\t\\tstack.append([n[0].left,1])\\n\\n\\t\\t\\t#Inorder Traversal\\n\\t\\t\\telif n[1]==2:\\n\\t\\t\\t\\tino.append(n[0].val)\\n\\t\\t\\t\\tn[1]+=1\\n\\t\\t\\t\\tstack.append(n)\\n\\t\\t\\t\\tif n[0].right:\\n\\t\\t\\t\\t\\tstack.append([n[0].right,1])\\n\\n\\t\\t\\t#Postorder Traversal\\n\\t\\t\\telse:\\n\\t\\t\\t\\tposto.append(n[0].val)\\n\\t\\treturn ino",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\tdef inorderTraversal(self, root):\\n\\n\\t\\tpreo,ino,posto,stack=[],[],[],[[root,1]]\\n\\t\\tif not root:\\n\\t\\t\\treturn\\n\\t\\twhile stack:\\n\\t\\t\\tn=stack.pop()\\n\\n\\t\\t\\t#Preorder Traversal\\n\\t\\t\\tif n[1]==1:\\n\\t\\t\\t\\tpreo.append(n[0].val)\\n\\t\\t\\t\\tn[1]+=1\\n\\t\\t\\t\\tstack.append(n)\\n\\t\\t\\t\\tif n[0].left:\\n\\t\\t\\t\\t\\tstack.append([n[0].left,1])\\n\\n\\t\\t\\t#Inorder Traversal\\n\\t\\t\\telif n[1]==2:\\n\\t\\t\\t\\tino.append(n[0].val)\\n\\t\\t\\t\\tn[1]+=1\\n\\t\\t\\t\\tstack.append(n)\\n\\t\\t\\t\\tif n[0].right:\\n\\t\\t\\t\\t\\tstack.append([n[0].right,1])\\n\\n\\t\\t\\t#Postorder Traversal\\n\\t\\t\\telse:\\n\\t\\t\\t\\tposto.append(n[0].val)\\n\\t\\treturn ino",
                "codeTag": "Java"
            },
            {
                "id": 286620,
                "title": "java-morris-traversal-with-detailed-explanation",
                "content": "```\\nclass Solution {\\n\\t/**\\n\\t * Morris inorder traversal\\n\\t * \\n\\t * @param root\\n\\t * @return\\n\\t * @see <a href=\\n\\t *      \"https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\">Inorder\\n\\t *      Tree Traversal without recursion and without stack</a>\\n\\t * @see <a href=\"https://en.wikipedia.org/wiki/Threaded_binary_tree\">Threaded\\n\\t *      binary tree</a>\\n\\t */\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> r = new ArrayList<>();\\n\\t\\tif (root == null)\\n\\t\\t\\treturn r;\\n\\n\\t\\t// Start from root\\n\\t\\tTreeNode cur = root;\\n\\n\\t\\t// Define a cursor that will be used to find predecessor, link and unlink nodes\\n\\t\\tTreeNode traverseCursor = null;\\n\\t\\twhile (cur != null) {\\n\\t\\t\\t/*\\n\\t\\t\\t * Check current node\\'s left child, if the left child node exist, then traverse\\n\\t\\t\\t * through left child\\'s right branch to the bottom, the rightmost leaf node will\\n\\t\\t\\t * be the predecessor of current node, once we find it, we \\'link\\' the\\n\\t\\t\\t * predecessor to current node, i.e., we make current node the right child of\\n\\t\\t\\t * the predecessor\\n\\t\\t\\t */\\n\\t\\t\\tif (cur.left != null) {\\n\\t\\t\\t\\ttraverseCursor = cur.left;\\n\\t\\t\\t\\twhile (traverseCursor.right != null && traverseCursor.right != cur) {\\n\\t\\t\\t\\t\\ttraverseCursor = traverseCursor.right;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (traverseCursor.right == null) {\\n\\t\\t\\t\\t\\t// We found the leaf node, now create the link\\n\\t\\t\\t\\t\\ttraverseCursor.right = cur;\\n\\t\\t\\t\\t\\t// Now move the cursor of current node to its left child\\n\\t\\t\\t\\t\\tcur = cur.left;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (traverseCursor.right == cur) {\\n\\t\\t\\t\\t\\t// This case is indicating we have already visited current node\\'s predecessor by\\n\\t\\t\\t\\t\\t// linking, we need to unlink the nodes to restore the original tree\\n\\t\\t\\t\\t\\ttraverseCursor.right = null;\\n\\t\\t\\t\\t\\t// This case is also indicating we are visiting the successor of the predecessor\\n\\t\\t\\t\\t\\t// i.e., the root\\n\\t\\t\\t\\t\\tr.add(cur.val);\\n\\t\\t\\t\\t\\t// Now visit the right branch\\n\\t\\t\\t\\t\\tcur = cur.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// We reached the node we want to visit\\n\\t\\t\\t\\tr.add(cur.val);\\n\\t\\t\\t\\t// Now we move the cursor to its \\'right\\' child, which was linked to its\\n\\t\\t\\t\\t// successor\\n\\t\\t\\t\\t// by traverseCursor\\n\\t\\t\\t\\tcur = cur.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn r;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t/**\\n\\t * Morris inorder traversal\\n\\t * \\n\\t * @param root\\n\\t * @return\\n\\t * @see <a href=\\n\\t *      \"https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\">Inorder\\n\\t *      Tree Traversal without recursion and without stack</a>\\n\\t * @see <a href=\"https://en.wikipedia.org/wiki/Threaded_binary_tree\">Threaded\\n\\t *      binary tree</a>\\n\\t */\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> r = new ArrayList<>();\\n\\t\\tif (root == null)\\n\\t\\t\\treturn r;\\n\\n\\t\\t// Start from root\\n\\t\\tTreeNode cur = root;\\n\\n\\t\\t// Define a cursor that will be used to find predecessor, link and unlink nodes\\n\\t\\tTreeNode traverseCursor = null;\\n\\t\\twhile (cur != null) {\\n\\t\\t\\t/*\\n\\t\\t\\t * Check current node\\'s left child, if the left child node exist, then traverse\\n\\t\\t\\t * through left child\\'s right branch to the bottom, the rightmost leaf node will\\n\\t\\t\\t * be the predecessor of current node, once we find it, we \\'link\\' the\\n\\t\\t\\t * predecessor to current node, i.e., we make current node the right child of\\n\\t\\t\\t * the predecessor\\n\\t\\t\\t */\\n\\t\\t\\tif (cur.left != null) {\\n\\t\\t\\t\\ttraverseCursor = cur.left;\\n\\t\\t\\t\\twhile (traverseCursor.right != null && traverseCursor.right != cur) {\\n\\t\\t\\t\\t\\ttraverseCursor = traverseCursor.right;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (traverseCursor.right == null) {\\n\\t\\t\\t\\t\\t// We found the leaf node, now create the link\\n\\t\\t\\t\\t\\ttraverseCursor.right = cur;\\n\\t\\t\\t\\t\\t// Now move the cursor of current node to its left child\\n\\t\\t\\t\\t\\tcur = cur.left;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (traverseCursor.right == cur) {\\n\\t\\t\\t\\t\\t// This case is indicating we have already visited current node\\'s predecessor by\\n\\t\\t\\t\\t\\t// linking, we need to unlink the nodes to restore the original tree\\n\\t\\t\\t\\t\\ttraverseCursor.right = null;\\n\\t\\t\\t\\t\\t// This case is also indicating we are visiting the successor of the predecessor\\n\\t\\t\\t\\t\\t// i.e., the root\\n\\t\\t\\t\\t\\tr.add(cur.val);\\n\\t\\t\\t\\t\\t// Now visit the right branch\\n\\t\\t\\t\\t\\tcur = cur.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// We reached the node we want to visit\\n\\t\\t\\t\\tr.add(cur.val);\\n\\t\\t\\t\\t// Now we move the cursor to its \\'right\\' child, which was linked to its\\n\\t\\t\\t\\t// successor\\n\\t\\t\\t\\t// by traverseCursor\\n\\t\\t\\t\\tcur = cur.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn r;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548362,
                "title": "python-recursive-and-iterative-solutions",
                "content": "# Recursive Solution\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        A = []\\n        def inorder(node):\\n            if not node: return\\n            inorder(node.left)\\n            A.append(node.val)\\n            inorder(node.right)\\n        inorder(root)\\n        return A\\n```\\n\\n# Iterative solution\\nSame idea, exhaust left sub trees, then pop the current, add to the answer and repeat the logic for right subtree (in order)\\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        A = []\\n        stack = []\\n        cur_node = root\\n        \\n        while stack or cur_node:\\n            \\n            # Exhausted left nodes. Pop current and go right\\n            if not cur_node:\\n                node = stack.pop()\\n                A.append(node.val)\\n                cur_node = node.right\\n            \\n            # Otherwise go left\\n            else:\\n                stack.append(cur_node)\\n                cur_node = cur_node.left\\n        \\n        return A\\n```\\n\\n# Generator function\\nNote that you can turn the iterative solution into a generator function by yielding the result.\\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        stack = []\\n        cur_node = root\\n        \\n        while stack or cur_node:\\n            # Exhausted left nodes. Pop current and go right\\n            if not cur_node:\\n                node = stack.pop()\\n                yield node.val\\n                cur_node = node.right\\n            \\n            # Otherwise go left\\n            else:\\n                stack.append(cur_node)\\n                cur_node = cur_node.left\\n```\\n\\n# Appendix\\nOne could solve the problem in constant space O(1) using morris traversal.\\nRefer to this link for more info: https://stackoverflow.com/questions/5502916/explain-morris-inorder-tree-traversal-without-using-stacks-or-recursion",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        A = []\\n        def inorder(node):\\n            if not node: return\\n            inorder(node.left)\\n            A.append(node.val)\\n            inorder(node.right)\\n        inorder(root)\\n        return A\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        A = []\\n        stack = []\\n        cur_node = root\\n        \\n        while stack or cur_node:\\n            \\n            # Exhausted left nodes. Pop current and go right\\n            if not cur_node:\\n                node = stack.pop()\\n                A.append(node.val)\\n                cur_node = node.right\\n            \\n            # Otherwise go left\\n            else:\\n                stack.append(cur_node)\\n                cur_node = cur_node.left\\n        \\n        return A\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        stack = []\\n        cur_node = root\\n        \\n        while stack or cur_node:\\n            # Exhausted left nodes. Pop current and go right\\n            if not cur_node:\\n                node = stack.pop()\\n                yield node.val\\n                cur_node = node.right\\n            \\n            # Otherwise go left\\n            else:\\n                stack.append(cur_node)\\n                cur_node = cur_node.left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547698,
                "title": "2-ways-of-0ms-java-solution",
                "content": "**Recursion**\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        solve(res,root);\\n        return res;\\n    }\\n    \\n    private void solve(List<Integer> res, TreeNode root){\\n        if(root == null) return;\\n        \\n\\t\\t// Traverse left node\\n        solve(res, root.left);\\n\\t\\t\\n\\t\\t// Traverse parent node\\n        res.add(root.val);\\n\\t\\t\\n\\t\\t// Traverse right node\\n        solve(res, root.right);\\n    }\\n}\\n```\\n\\n**Using Stack**\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        \\n        TreeNode curr = root;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(curr != null || stack.size() != 0){\\n            \\n            // Move to the left-most node of the tree and push them in stack for future traversal\\n            while(curr != null){\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            // Left node\\n            curr = stack.pop();\\n            \\n            // Parent node\\n            res.add(curr.val);\\n            \\n            // Right node\\n            curr = curr.right;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n<br/>\\n\\n**Kotlin Version**\\n\\n```\\nclass Solution {\\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n        val res = mutableListOf<Int>()\\n        inorder(root,res)\\n        return res\\n    }\\n    \\n    private fun inorder(node:TreeNode?, res : MutableList<Int>){\\n        node?.let{\\n            inorder(node.left,res)\\n            res.add(node.`val`)\\n            inorder(node.right,res)\\n        }\\n    }\\n}\\n```\\n\\n**Using Stack**\\n```\\nclass Solution {\\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n        val res = mutableListOf<Int>()\\n        \\n        var curr = root\\n        val stack = Stack<TreeNode>()\\n        \\n        while(curr != null || stack.size != 0){\\n            while(curr!=null){\\n                stack.push(curr)\\n                curr = curr.left\\n            }\\n            curr = stack.pop()\\n            res.add(curr.`val`)\\n            curr = curr.right\\n        }   \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        solve(res,root);\\n        return res;\\n    }\\n    \\n    private void solve(List<Integer> res, TreeNode root){\\n        if(root == null) return;\\n        \\n\\t\\t// Traverse left node\\n        solve(res, root.left);\\n\\t\\t\\n\\t\\t// Traverse parent node\\n        res.add(root.val);\\n\\t\\t\\n\\t\\t// Traverse right node\\n        solve(res, root.right);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        \\n        TreeNode curr = root;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(curr != null || stack.size() != 0){\\n            \\n            // Move to the left-most node of the tree and push them in stack for future traversal\\n            while(curr != null){\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            // Left node\\n            curr = stack.pop();\\n            \\n            // Parent node\\n            res.add(curr.val);\\n            \\n            // Right node\\n            curr = curr.right;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n        val res = mutableListOf<Int>()\\n        inorder(root,res)\\n        return res\\n    }\\n    \\n    private fun inorder(node:TreeNode?, res : MutableList<Int>){\\n        node?.let{\\n            inorder(node.left,res)\\n            res.add(node.`val`)\\n            inorder(node.right,res)\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n        val res = mutableListOf<Int>()\\n        \\n        var curr = root\\n        val stack = Stack<TreeNode>()\\n        \\n        while(curr != null || stack.size != 0){\\n            while(curr!=null){\\n                stack.push(curr)\\n                curr = curr.left\\n            }\\n            curr = stack.pop()\\n            res.add(curr.`val`)\\n            curr = curr.right\\n        }   \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986517,
                "title": "swift-0-ms-2-lines-recursive",
                "content": "```\\nclass Solution {\\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        guard let root = root else { return [] }\\n        return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        guard let root = root else { return [] }\\n        return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969561,
                "title": "c-3-method-recursive-iterative-using-stack-morris-traversal-threaded-binary-tree",
                "content": "Recall: Inorder= Left, Root Node, Right\\n\\n**1st Approach:** Using recursion\\nWe use a helper function to traverse recursively \\n\\n```\\nclass Solution {\\npublic:\\n        void inorder(TreeNode* root, vector<int>& res){\\n        if (root){\\n            inorder (root->left, res);\\n            res.push_back(root->val);\\n            inorder (root->right, res);\\n        }\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> p;\\n        inorder (root, p);\\n        return p;\\n    }\\n};\\n```\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n**2nd Approach:** Iteratively using Stack\\nUnlike recursively which used the internal stack, we would explicitly use a stack to keep a track of nodes\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector < int > inOrder;\\n        stack < TreeNode* > s;\\n        TreeNode* curr = root;\\n        while (true) {\\n            if (curr != NULL) {\\n                s.push(curr);\\n                curr = curr -> left;\\n            } else\\n            {\\n                if (s.empty()) break;\\n                curr = s.top();\\n                inOrder.push_back(curr -> val);\\n                s.pop();\\n                curr = curr -> right;\\n            }\\n        }\\n        return inOrder;\\n    }\\n};\\n```\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n**3rd Approach:** Using morris traversal i.e, applying the concept of threaded binary tree.\\n\\nExplanation: Here we are wisely creating a thread between the current node and its inorder predecessor so that we can visit back the current node, as there are no parent pointer in the binary tree strucure nor recursion stack which did this task in previous approaches.\\n\\n![image](https://assets.leetcode.com/users/images/0f962cd3-ceb9-43ef-91ec-b79acbe9394d_1650542250.3279028.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode *cur = root;\\n        vector<int> inorder;\\n        while (cur != NULL)\\n        {\\n            if (cur->left == NULL)//no left node then directly push in inorder and go right\\n            {\\n                inorder.push_back(cur->val);\\n                cur = cur->right;\\n            }\\n            else//there is a left node\\n            {\\n                //find inorder predecessor\\n                TreeNode* predecessor = cur->left;//predecessor will be the rightmost of left until it reaches null or back to the current node (as we might have already created thread from it.\\n                while (predecessor->right != cur && predecessor->right != NULL)\\n                    predecessor = predecessor->right;\\n                if (predecessor->right == NULL)//thread creation as visiting first time\\n                {\\n                    predecessor->right = cur;\\n                    cur = cur-> left;\\n                }\\n                else//thread deletion to avoid cycle and pushing node in inorder\\n                {\\n                    predecessor->right = NULL;\\n                    inorder.push_back(cur->val);\\n                    cur = cur->right;\\n                }\\n            }\\n        }\\n        return inorder;\\n    }\\n};\\n```\\nTime Complexity: O(N)\\nSpace Complexity: **O(1)**\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        void inorder(TreeNode* root, vector<int>& res){\\n        if (root){\\n            inorder (root->left, res);\\n            res.push_back(root->val);\\n            inorder (root->right, res);\\n        }\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> p;\\n        inorder (root, p);\\n        return p;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector < int > inOrder;\\n        stack < TreeNode* > s;\\n        TreeNode* curr = root;\\n        while (true) {\\n            if (curr != NULL) {\\n                s.push(curr);\\n                curr = curr -> left;\\n            } else\\n            {\\n                if (s.empty()) break;\\n                curr = s.top();\\n                inOrder.push_back(curr -> val);\\n                s.pop();\\n                curr = curr -> right;\\n            }\\n        }\\n        return inOrder;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode *cur = root;\\n        vector<int> inorder;\\n        while (cur != NULL)\\n        {\\n            if (cur->left == NULL)//no left node then directly push in inorder and go right\\n            {\\n                inorder.push_back(cur->val);\\n                cur = cur->right;\\n            }\\n            else//there is a left node\\n            {\\n                //find inorder predecessor\\n                TreeNode* predecessor = cur->left;//predecessor will be the rightmost of left until it reaches null or back to the current node (as we might have already created thread from it.\\n                while (predecessor->right != cur && predecessor->right != NULL)\\n                    predecessor = predecessor->right;\\n                if (predecessor->right == NULL)//thread creation as visiting first time\\n                {\\n                    predecessor->right = cur;\\n                    cur = cur-> left;\\n                }\\n                else//thread deletion to avoid cycle and pushing node in inorder\\n                {\\n                    predecessor->right = NULL;\\n                    inorder.push_back(cur->val);\\n                    cur = cur->right;\\n                }\\n            }\\n        }\\n        return inorder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548841,
                "title": "c-solution",
                "content": "****Runtime: 0 ms, faster than 100.00% of C online submissions for Binary Tree Inorder Traversal.\\nMemory Usage: 5.9 MB, less than 68.48% of C online submissions for Binary Tree Inorder Traversal.\\n```\\nvoid travel(struct TreeNode* root,int*ret,int*size){\\n    if(root==NULL)\\n        return 0 ;\\n    travel(root->left,ret,size);\\n    ret[(*size)++]=root->val;\\n    travel(root->right,ret,size);\\n}\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    *returnSize=0;\\n    int *ret=malloc(sizeof(int)*100);\\n    travel(root,ret,returnSize);\\n        return ret;\\n\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvoid travel(struct TreeNode* root,int*ret,int*size){\\n    if(root==NULL)\\n        return 0 ;\\n    travel(root->left,ret,size);\\n    ret[(*size)++]=root->val;\\n    travel(root->right,ret,size);\\n}\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    *returnSize=0;\\n    int *ret=malloc(sizeof(int)*100);\\n    travel(root,ret,returnSize);\\n        return ret;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1359114,
                "title": "recursive-python-3-lines-of-code",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not(root):\\n            return []\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not(root):\\n            return []\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259828,
                "title": "2-line-javascript-solution-faster-than-81",
                "content": "```\\nvar inorderTraversal = function(root) {\\n    if (!root) return []\\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar inorderTraversal = function(root) {\\n    if (!root) return []\\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 960715,
                "title": "python-iterative",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        traversal = []\\n\\n        node = root\\n        stack = []\\n        while node or stack:\\n            if node:\\n                stack.append(node)\\n                node = node.left\\n            else:\\n                node = stack.pop()\\n                traversal.append(node.val)\\n                node = node.right\\n                \\n        return traversal\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        traversal = []\\n\\n        node = root\\n        stack = []\\n        while node or stack:\\n            if node:\\n                stack.append(node)\\n                node = node.left\\n            else:\\n                node = stack.pop()\\n                traversal.append(node.val)\\n                node = node.right\\n                \\n        return traversal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31380,
                "title": "recommend-by-rainbow-morris-traversal-and-time-complexity-analysis-why-o-n",
                "content": "**Update : 2016/02/26**\\n\\nabout why the time complexity of the Morris traversal is O(n) maybe confusing !\\n\\nHere is the details you need to understand the time complexity is O(N) as each edge is traversed for 3 times at most.\\n\\n       Each edge is traversed at most 3 times and there are n-1 edges in a tree,\\n       hence the O(n).\\n\\nI think the part that is confusing you is the predecessor finding loop because it goes down the tree following the rightmost node.\\n\\n            /* Find the inorder predecessor of current */\\n          pre = current->left;\\n          while (pre->right != NULL && pre->right != current)\\n          pre = pre->right;\\n\\n\\nThis full path is only processed twice: \\nwhen the current pointer reaches the node\\nwhen we have processed its left subtree\\n\\nAlso, the key is that this path is not processed again while we're on the left subtree.\\n\\nYou can see a simple example here .\\n\\n[https://www.quora.com/Why-does-the-Morris-in-order-traversal-algorithm-have-O-n-time-complexity][1]\\n\\nMorris traversal is a cheap way to do the traversal of the tree with no Space cost and non-recursive way.\\n\\nBut at first, it may seem hard for you to understand.\\n\\nThe key idea is to traversal as in-order, when meet the node with left child, then we will\\n\\ntraverse to find the pre-node of the current node and link it to the current node. \\n\\nSo after push back the in-order first node,  it will back track by the previous setting \"right link\"!\\n\\nSo when we meet the \"right link\"  for the next time, we will reset it and push back the value.\\n\\nSo we link the tree value and get the final vector result.\\n\\n         1. Initialize current as root \\n         2. While current is not NULL\\n                   If current does not have left child\\n                         a) Print current\\u2019s data\\n                         b) Go to the right, i.e., current = current->right\\n                   Else\\n                         a) Make current as right child of the rightmost node in current's left subtree\\n                         b) Go to this left child, i.e., current = current->left\\n\\nAC C++  implementation .\\n\\n\\n    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode* root) {\\n            TreeNode* cur, *pre;\\n            vector<int> result;\\n            if(!root)  return  result;\\n            \\n            cur=root;\\n            while(cur){\\n                /** move left **/\\n                if(cur->left){\\n                    /** find the previous node of the cur **/\\n                   pre=cur->left;\\n                   while(pre->right && pre->right!=cur)  pre=pre->right;\\n                   /** if not set, keep traversal **/\\n                   if(!pre->right){\\n                       pre->right=cur;\\n                       cur=cur->left;\\n                   }\\n                   /** if set, push back the value, and keep traversal **/\\n                   else{\\n                       pre->right=NULL;\\n                       result.push_back(cur->val);\\n                       cur=cur->right;\\n                   }\\n                }\\n                /** push_back the root value move right (previous set right link will point \\n                    to the in-order-next node)**/\\n                else{\\n                    result.push_back(cur->val);\\n                    cur=cur->right;\\n                }\\n            }\\n        }\\n    };\\n\\n\\n  [1]: https://www.quora.com/Why-does-the-Morris-in-order-traversal-algorithm-have-O-n-time-complexity",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode* root) {\\n            TreeNode* cur, *pre;\\n            vector<int> result;\\n            if(!root)  return  result;\\n            \\n            cur=root;\\n            while(cur){\\n                /** move left **/\\n                if(cur->left){\\n                    /** find the previous node of the cur **/\\n                   pre=cur->left;\\n                   while(pre->right && pre->right!=cur)  pre=pre->right;\\n                   /** if not set, keep traversal **/\\n                   if(!pre->right){\\n                       pre->right=cur;\\n                       cur=cur->left;\\n                   }",
                "codeTag": "Java"
            },
            {
                "id": 3931235,
                "title": "easy-c-solution-dfs-bfs-and-morris-traversal-beats-100",
                "content": "# Code\\n```\\n// Recursive approach\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &ans){\\n        //base case\\n        if(root == NULL)\\n            return;\\n\\n        inorder(root->left, ans);\\n        ans.push_back(root->val);\\n        inorder(root->right, ans);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inorder(root, ans);\\n        return ans;\\n    }\\n};\\n\\n// Iterative approach\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        stack<TreeNode*> s;\\n        TreeNode *curr = root;\\n\\n        while(true){\\n            if(curr != NULL){\\n                s.push(curr);\\n                curr = curr->left;\\n            }\\n            else if(s.empty())\\n                break;\\n            else{\\n                ans.push_back(s.top()->val);\\n                curr = s.top()->right;\\n                s.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Morris traversal - Space O(1)\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root == NULL)\\n            return {};\\n        \\n        vector<int> ans;\\n        TreeNode *curr = root, *pre;\\n        while(curr != NULL){\\n            if(curr->left == NULL){\\n                ans.push_back(curr->val);\\n                curr = curr->right;\\n            }\\n            else{\\n                pre = curr->left;\\n                while(pre->right != NULL && pre->right != curr)\\n                    pre = pre->right;\\n                \\n                if(pre->right == NULL){\\n                    pre->right = curr;\\n                    curr = curr->left;\\n                }\\n                else{   // pre->right == curr\\n                    pre->right = NULL;\\n                    ans.push_back(curr->val);\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n// Recursive approach\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &ans){\\n        //base case\\n        if(root == NULL)\\n            return;\\n\\n        inorder(root->left, ans);\\n        ans.push_back(root->val);\\n        inorder(root->right, ans);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inorder(root, ans);\\n        return ans;\\n    }\\n};\\n\\n// Iterative approach\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        stack<TreeNode*> s;\\n        TreeNode *curr = root;\\n\\n        while(true){\\n            if(curr != NULL){\\n                s.push(curr);\\n                curr = curr->left;\\n            }\\n            else if(s.empty())\\n                break;\\n            else{\\n                ans.push_back(s.top()->val);\\n                curr = s.top()->right;\\n                s.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Morris traversal - Space O(1)\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root == NULL)\\n            return {};\\n        \\n        vector<int> ans;\\n        TreeNode *curr = root, *pre;\\n        while(curr != NULL){\\n            if(curr->left == NULL){\\n                ans.push_back(curr->val);\\n                curr = curr->right;\\n            }\\n            else{\\n                pre = curr->left;\\n                while(pre->right != NULL && pre->right != curr)\\n                    pre = pre->right;\\n                \\n                if(pre->right == NULL){\\n                    pre->right = curr;\\n                    curr = curr->left;\\n                }\\n                else{   // pre->right == curr\\n                    pre->right = NULL;\\n                    ans.push_back(curr->val);\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431301,
                "title": "in-order-traversing-in-python-python3",
                "content": "# Approach\\nAs Inorder traversing a Binary tree, first we have to travse the left tree nodes than root node and than at the last right tree nodes.\\nUsing recursive model for this solution.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053456,
                "title": "c-short-simple-recursion",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    \\n    void inorder(TreeNode* root){\\n        if(root==nullptr){return;}\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        inorder(root);\\n        return v;    \\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    \\n    void inorder(TreeNode* root){\\n        if(root==nullptr){return;}\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        inorder(root);\\n        return v;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827145,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur_node = head;\\n        while (cur_node && cur_node->next) {\\n            ListNode* next_node = cur_node->next;\\n            if (cur_node->val == next_node->val)\\n                cur_node->next = next_node->next;\\n            else\\n                cur_node = next_node;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur_node = head;\\n        while (cur_node && cur_node->next) {\\n            ListNode* next_node = cur_node->next;\\n            if (cur_node->val == next_node->val)\\n                cur_node->next = next_node->next;\\n            else\\n                cur_node = next_node;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2035548,
                "title": "java-script-solution-using-recursion",
                "content": "```\\nvar inorderTraversal = function(root) {\\n    if(root === null) return [];\\n    return [...inorderTraversal(root.left),root.val,...inorderTraversal(root.right)];\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar inorderTraversal = function(root) {\\n    if(root === null) return [];\\n    return [...inorderTraversal(root.left),root.val,...inorderTraversal(root.right)];\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1778180,
                "title": "python-recursive-one-liner",
                "content": "```\\nclass Solution:\\n  def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n    return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n  def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n    return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437870,
                "title": "js-heavily-commented-recursive-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    // In-Order Traversal ->\\n    //  1. Recursively traverse through the left subtree\\n    //  2. Visit current node\\n    //  3. Recursively traverse through the right subtree\\n    \\n    // Initialize array of values\\n    let result = [];\\n    \\n    // Recursive function to traverse through subtrees\\n    inorder(root, result);\\n    \\n    return result;\\n};\\n\\nconst inorder = (node, result) => {\\n    if (!node) return null;\\n    inorder(node.left, result); // Traverse through left subtree\\n    result.push(node.val); // Visit node\\n    inorder(node.right, result); // Traverse through right subtree\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    // In-Order Traversal ->\\n    //  1. Recursively traverse through the left subtree\\n    //  2. Visit current node\\n    //  3. Recursively traverse through the right subtree\\n    \\n    // Initialize array of values\\n    let result = [];\\n    \\n    // Recursive function to traverse through subtrees\\n    inorder(root, result);\\n    \\n    return result;\\n};\\n\\nconst inorder = (node, result) => {\\n    if (!node) return null;\\n    inorder(node.left, result); // Traverse through left subtree\\n    result.push(node.val); // Visit node\\n    inorder(node.right, result); // Traverse through right subtree\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 706892,
                "title": "python-morris-traversal",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        curr = root\\n        res = []\\n        while curr:\\n            if curr.left:\\n                pre = curr.left\\n                while pre.right and pre.right!=curr:\\n                    pre = pre.right\\n                if pre.right == curr:\\n                    pre.right = None\\n                    res.append(curr.val)\\n                    curr = curr.right\\n                else:\\n                    pre.right = curr\\n                    curr = curr.left\\n            else:\\n                res.append(curr.val)\\n                curr = curr.right\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        curr = root\\n        res = []\\n        while curr:\\n            if curr.left:\\n                pre = curr.left\\n                while pre.right and pre.right!=curr:\\n                    pre = pre.right\\n                if pre.right == curr:\\n                    pre.right = None\\n                    res.append(curr.val)\\n                    curr = curr.right\\n                else:\\n                    pre.right = curr\\n                    curr = curr.left\\n            else:\\n                res.append(curr.val)\\n                curr = curr.right\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546002,
                "title": "easy-to-understand-iterative-and-recursive-faster-simple-python-solution",
                "content": "```\\ndef iterative(self, root):\\n        out = []\\n        stack = []\\n        top = root\\n        while top or len(stack):\\n            while top:\\n                stack.append(top)\\n                top = top.left\\n            top = stack.pop()\\n            out.append(top.val)\\n            top = top.right\\n        return out\\n    \\n    def recursive(self, root):\\n        def rec(root):\\n            if root:\\n                rec(root.left)\\n                out.append(root.val)\\n                rec(root.right)\\n        \\n        out = []\\n        rec(root)\\n        return out\\n```\\n\\n**I hope that you\\'ve found them useful.**\\n\\t*In that case, please do upvote. It motivates me to write more such post\\uD83D\\uDE03*",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef iterative(self, root):\\n        out = []\\n        stack = []\\n        top = root\\n        while top or len(stack):\\n            while top:\\n                stack.append(top)\\n                top = top.left\\n            top = stack.pop()\\n            out.append(top.val)\\n            top = top.right\\n        return out\\n    \\n    def recursive(self, root):\\n        def rec(root):\\n            if root:\\n                rec(root.left)\\n                out.append(root.val)\\n                rec(root.right)\\n        \\n        out = []\\n        rec(root)\\n        return out\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 31386,
                "title": "c-0ms-stack-based-solution",
                "content": "    class Solution {\\n    public:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        vector<TreeNode*> stack;\\n        TreeNode *cur=root;\\n        while (cur!=NULL || !stack.empty()){\\n            if (cur){\\n                stack.push_back(cur);\\n                cur = cur->left;\\n            }\\n            else {\\n                cur = stack.back();\\n                stack.pop_back();\\n                res.push_back(cur->val);\\n                cur = cur->right;\\n            }\\n        }\\n        return res;\\n    } \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        vector<TreeNode*> stack;\\n        TreeNode *cur=root;\\n        while (cur!=NULL || !stack.empty()){\\n            if (cur){\\n                stack.push_back(cur);\\n                cur = cur->left;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 31402,
                "title": "java-1ms-both-iterative-and-recursive",
                "content": "The recursive solution is trivial, yet the iterative solution with an explicit stack helps us better understand what is going on with the stack in the recursive solution.\\n\\n    public class Solution {\\n        public List<Integer> inorderTraversal(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            inorderTraversalRecursive(root, result);\\n            //inorderTraversalIterative(root, result);\\n            return result;\\n        }\\n        \\n        private void inorderTraversalIterative(TreeNode root, List<Integer> result) {\\n            LinkedList<TreeNode> stack = new LinkedList<TreeNode>();\\n            TreeNode curr = root;\\n            while (curr != null || !stack.isEmpty()) {\\n                if (curr != null) {\\n                    stack.offerLast(curr);\\n                    curr = curr.left;\\n                } else {\\n                    result.add(stack.getLast().val);\\n                    curr = stack.getLast().right;\\n                    stack.pollLast();\\n                }\\n            }\\n        }\\n        \\n        private void inorderTraversalRecursive(TreeNode root, List<Integer> result) {\\n            if (root == null) {\\n                return;\\n            }\\n            inorderTraversalRecursive(root.left, result);\\n            result.add(root.val);\\n            inorderTraversalRecursive(root.right, result);        \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> inorderTraversal(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            inorderTraversalRecursive(root, result);\\n            //inorderTraversalIterative(root, result);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 31478,
                "title": "my-accepted-solution-in-python",
                "content": "    class Solution:\\n        def inorderTraversal(self, root):\\n            stack = []\\n            output = []\\n            while True:\\n                while root:\\n                    stack.append(root)\\n                    root = root.left\\n                if stack == []:\\n                    break\\n                node = stack.pop()\\n                output.append(node.val)\\n                root = node.right\\n            return output",
                "solutionTags": [],
                "code": "    class Solution:\\n        def inorderTraversal(self, root):\\n            stack = []\\n            output = []\\n            while True:\\n                while root:\\n                    stack.append(root)\\n                    root = root.left\\n                if stack == []:\\n                    break\\n                node = stack.pop()\\n                output.append(node.val)\\n                root = node.right\\n            return output",
                "codeTag": "Java"
            },
            {
                "id": 3202461,
                "title": "c-recursive-easy-solution-beats-100",
                "content": "# Intuition\\nRecursive Solution\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &vct){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        inorder(root->left,vct);\\n        vct.push_back(root->val);\\n        inorder(root->right,vct);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> vct;\\n        inorder(root,vct);\\n        return vct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &vct){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        inorder(root->left,vct);\\n        vct.push_back(root->val);\\n        inorder(root->right,vct);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> vct;\\n        inorder(root,vct);\\n        return vct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187656,
                "title": "91-35-binary-tree-inorder-traversal-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe idea is to traverse the binary tree in an inorder fashion using a stack. We start with the root node and keep going to the left child until we reach a leaf node. Then, we backtrack and process the node by popping it from the stack, appending its value to the result, and moving to its right child. We repeat this process until the stack is empty and we have processed all the nodes in the tree.\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n91.35%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        # Initialize an empty stack to store the nodes\\n        stack = []\\n        # Initialize an empty list to store the result\\n        result = []\\n        # Start with the root node\\n        curr = root\\n        # Loop until the stack is empty or curr is None\\n        while stack or curr:\\n            # If curr is not None, push it onto the stack and move to its left child\\n            if curr:\\n                stack.append(curr)\\n                curr = curr.left\\n            # If curr is None, pop a node from the stack, append its value to the result, and move to its right child\\n            else:\\n                curr = stack.pop()\\n                result.append(curr.val)\\n                curr = curr.right\\n        # Return the result\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        # Initialize an empty stack to store the nodes\\n        stack = []\\n        # Initialize an empty list to store the result\\n        result = []\\n        # Start with the root node\\n        curr = root\\n        # Loop until the stack is empty or curr is None\\n        while stack or curr:\\n            # If curr is not None, push it onto the stack and move to its left child\\n            if curr:\\n                stack.append(curr)\\n                curr = curr.left\\n            # If curr is None, pop a node from the stack, append its value to the result, and move to its right child\\n            else:\\n                curr = stack.pop()\\n                result.append(curr.val)\\n                curr = curr.right\\n        # Return the result\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185647,
                "title": "c-easy-solution-using-recursion-explained",
                "content": "# Intuition\\nIn-Order Traversal is a Depth First Search Algorithm of traversal in Binary Trees. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# DFS Traversal Algorithms \\n- [In-Order Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/post-solution/3185647/) \\n- [Post-Order Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3185653/c-easy-solution-using-recursion-explained/)\\n- [Pre-Order Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3185665/c-easy-solution-using-recursion-explained/)\\n\\n# Approach\\nIn-Order Traversal -> L N R\\n1. Traverse the left subtree\\n2. Print/Store the node \\n3. Traverse the right subtree\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n// InOrder Traversal -> L N R \\n// Traverse the left subtree till NULL (Base Case), print/store the node, traverse the right subtree(till NULL - Base Case)\\n    void inOrder (TreeNode *node, vector<int> &result)\\n    {\\n        if (node == NULL)\\n        {\\n            return ;\\n        }\\n\\n        inOrder (node -> left, result) ; \\n        result.push_back(node -> val) ; \\n        inOrder (node -> right, result) ;\\n\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> result ; \\n\\n        inOrder (root, result) ; \\n        return result ; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/a558e75a-a201-4602-887b-3d5314b6875f_1676391339.7404554.png)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n// InOrder Traversal -> L N R \\n// Traverse the left subtree till NULL (Base Case), print/store the node, traverse the right subtree(till NULL - Base Case)\\n    void inOrder (TreeNode *node, vector<int> &result)\\n    {\\n        if (node == NULL)\\n        {\\n            return ;\\n        }\\n\\n        inOrder (node -> left, result) ; \\n        result.push_back(node -> val) ; \\n        inOrder (node -> right, result) ;\\n\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> result ; \\n\\n        inOrder (root, result) ; \\n        return result ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163094,
                "title": "simple-java-100-easy-comments-readable-beginners-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode curr = root;\\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = stack.pop();\\n            res.add(curr.val);\\n            curr = curr.right;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode curr = root;\\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = stack.pop();\\n            res.add(curr.val);\\n            curr = curr.right;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976367,
                "title": "best-c-code-out-there-memory-100-optimized",
                "content": "class Solution {\\n     private : vector<int>res;\\n    void inorder(TreeNode *root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n            return;\\n        \\n        inorder(root->left,res);\\n        res.push_back(root->val);\\n        inorder(root->right,res);\\n        return;\\n    }\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        inorder(root,res);\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n     private : vector<int>res;\\n    void inorder(TreeNode *root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n            return;\\n        \\n        inorder(root->left,res);\\n        res.push_back(root->val);\\n        inorder(root->right,res);\\n        return;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1724132,
                "title": "python-3-25ms-perfect-pythonic-recursive-one-liner-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return  self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return  self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588635,
                "title": "javascript-one-liner",
                "content": "```javascript\\nvar inorderTraversal = function(root) {\\n    return !root ? [] : [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```javascript\\nvar inorderTraversal = function(root) {\\n    return !root ? [] : [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1348586,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300339,
                "title": "c-recursive-solution-in-o-n-time",
                "content": "#Trees - **Binary Tree Inorder Traversal**\\n\\n\\uD83D\\uDC49 Recursive solution: `O(n)` time and `O(n)` space (function call stack);\\n\\nHere, We just traverse in such a way that after making left call we push the value at that point in the the vector and then make the right call. \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void traverse(TreeNode* root, vector<int> &ans)\\n    {\\n        if(!root)\\n            return;\\n        \\n        if(root->left) \\n            traverse(root->left, ans);\\n        \\n        ans.push_back(root->val);  \\n        \\n        if(root->right)\\n            traverse(root->right, ans);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) \\n    {\\n        vector<int> ans;\\n        \\n            traverse(root, ans);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\u2728 Alternate Approach : Try solving Iteratively using stack: `O(n)` time and `O(n)` space",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void traverse(TreeNode* root, vector<int> &ans)\\n    {\\n        if(!root)\\n            return;\\n        \\n        if(root->left) \\n            traverse(root->left, ans);\\n        \\n        ans.push_back(root->val);  \\n        \\n        if(root->right)\\n            traverse(root->right, ans);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) \\n    {\\n        vector<int> ans;\\n        \\n            traverse(root, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048556,
                "title": "java-3-solutions-with-explanation-recursive-iterative-using-stack-iterative-without-stack",
                "content": "The idea is simple for in-order traversal -\\n1. traverse the left sub-tree\\n2. visit the node\\n3. traverse the right sub-tree\\n\\nThis process is done recursively for each node in the tree.\\n\\n#### Recursive\\n\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> inOrderList = new ArrayList<>();\\n        inOrder(root, inOrderList);\\n        return inOrderList;\\n    }\\n    \\n    private void inOrder(TreeNode node, List<Integer> list){\\n        if(node != null){\\n            inOrder(node.left, list);\\n            list.add(node.val);\\n            inOrder(node.right, list);\\n        }\\n    }\\n}\\n```\\n\\nThe same idea of recursion can be implemented using stack as well.\\n\\n#### Iterative using Stack\\n\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> listInOrder = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode curr = root;\\n        \\n        while(curr != null || !stack.isEmpty()){\\n            if(curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            } else{\\n                curr = stack.pop();\\n                listInOrder.add(curr.val);\\n                curr = curr.right;                    \\n            }\\n        }\\n        return listInOrder;\\n    }\\n}\\n```\\n\\n#### Iterative (Without Stack) - Morris Traversal in Threaded BST\\n\\nThis idea is slightly different than the other two but is relatively simple. Instead of using a stack (or recursion) for revisiting the current node again to traverse the right subtree, we update the right pointer of the in-order predecessor to point to the current node even before we start doing the in-order traversal on a node. Later we get rid of this pointer when all nodes of the left sub-tree is completely visited to leave the tree back in its original state.\\n\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        TreeNode curr = root;\\n        \\n        while(curr != null){\\n            if(curr.left == null){\\n                list.add(curr.val);\\n                curr = curr.right;\\n            } else {\\n                TreeNode predecessor = curr.left;\\n                while(predecessor.right != null && predecessor.right != curr)\\n                    predecessor = predecessor.right;\\n                if(predecessor.right == null){\\n                    predecessor.right = curr;\\n                    curr = curr.left;\\n                } else {\\n                    predecessor.right = null;\\n                    list.add(curr.val);\\n                    curr = curr.right;\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> inOrderList = new ArrayList<>();\\n        inOrder(root, inOrderList);\\n        return inOrderList;\\n    }\\n    \\n    private void inOrder(TreeNode node, List<Integer> list){\\n        if(node != null){\\n            inOrder(node.left, list);\\n            list.add(node.val);\\n            inOrder(node.right, list);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> listInOrder = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode curr = root;\\n        \\n        while(curr != null || !stack.isEmpty()){\\n            if(curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            } else{\\n                curr = stack.pop();\\n                listInOrder.add(curr.val);\\n                curr = curr.right;                    \\n            }\\n        }\\n        return listInOrder;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        TreeNode curr = root;\\n        \\n        while(curr != null){\\n            if(curr.left == null){\\n                list.add(curr.val);\\n                curr = curr.right;\\n            } else {\\n                TreeNode predecessor = curr.left;\\n                while(predecessor.right != null && predecessor.right != curr)\\n                    predecessor = predecessor.right;\\n                if(predecessor.right == null){\\n                    predecessor.right = curr;\\n                    curr = curr.left;\\n                } else {\\n                    predecessor.right = null;\\n                    list.add(curr.val);\\n                    curr = curr.right;\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847780,
                "title": "c-recursive",
                "content": "```\\nint cnt(struct TreeNode* root)\\n{\\n    if(root)\\n        return 1 + cnt(root->left) + cnt(root->right);\\n    return 0;\\n}\\n\\nvoid inorder(struct TreeNode* root, int** res)\\n{\\n    if(root)\\n    {\\n        inorder(root->left, res);\\n        *((*res)++) = root->val;\\n        inorder(root->right, res);\\n    }\\n}\\n\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize)\\n{\\n    \\n    *returnSize = cnt(root);\\n    int* res = (int*)malloc(((*returnSize)) * sizeof(int));\\n    memset(res, 0, (*returnSize) * sizeof(int));   \\n    int *cpy = res;\\n    inorder(root, &cpy);\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint cnt(struct TreeNode* root)\\n{\\n    if(root)\\n        return 1 + cnt(root->left) + cnt(root->right);\\n    return 0;\\n}\\n\\nvoid inorder(struct TreeNode* root, int** res)\\n{\\n    if(root)\\n    {\\n        inorder(root->left, res);\\n        *((*res)++) = root->val;\\n        inorder(root->right, res);\\n    }\\n}\\n\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize)\\n{\\n    \\n    *returnSize = cnt(root);\\n    int* res = (int*)malloc(((*returnSize)) * sizeof(int));\\n    memset(res, 0, (*returnSize) * sizeof(int));   \\n    int *cpy = res;\\n    inorder(root, &cpy);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 632114,
                "title": "c-easy-iterative-and-recurive-solution-with-explanation",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // Recursive Method\\n    \\n    vector <int> ans;\\n    void inorder(TreeNode *root)\\n    {\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root->left);\\n        ans.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        inorder(root);\\n        return ans;\\n    }\\n    \\n    \\n    // Iterative method\\n    \\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        TreeNode *ptr = root;\\n        vector <int> ans;\\n        stack <TreeNode*> address;\\n        \\n        if(root == NULL)\\n            return ans;\\n        \\n        // until address stack is empty and ptr points to NULL i.e. Traversal is over\\n        while( !address.empty() || ptr != NULL )\\n        {\\n            // if ptr points to a child\\n            if(ptr != NULL)\\n            {\\n                // pushing the address to the stack\\n                address.push(ptr);\\n                // moving left\\n                ptr = ptr->left;                    // LEFT\\n            }\\n            else\\n            {\\n                // popping the address and making ptr point to it, kinda backtrack a step\\n                ptr = address.top();\\n                address.pop();\\n                // printing or pushing the value of node to array\\n                ans.push_back(ptr->val);            // PRINT\\n                // movinf left\\n                ptr= ptr->right;                    // RIGHT\\n            }\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // Recursive Method\\n    \\n    vector <int> ans;\\n    void inorder(TreeNode *root)\\n    {\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root->left);\\n        ans.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        inorder(root);\\n        return ans;\\n    }\\n    \\n    \\n    // Iterative method\\n    \\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        TreeNode *ptr = root;\\n        vector <int> ans;\\n        stack <TreeNode*> address;\\n        \\n        if(root == NULL)\\n            return ans;\\n        \\n        // until address stack is empty and ptr points to NULL i.e. Traversal is over\\n        while( !address.empty() || ptr != NULL )\\n        {\\n            // if ptr points to a child\\n            if(ptr != NULL)\\n            {\\n                // pushing the address to the stack\\n                address.push(ptr);\\n                // moving left\\n                ptr = ptr->left;                    // LEFT\\n            }\\n            else\\n            {\\n                // popping the address and making ptr point to it, kinda backtrack a step\\n                ptr = address.top();\\n                address.pop();\\n                // printing or pushing the value of node to array\\n                ans.push_back(ptr->val);            // PRINT\\n                // movinf left\\n                ptr= ptr->right;                    // RIGHT\\n            }\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467789,
                "title": "one-code-pattern-for-3-leetcode-questions-c",
                "content": "**The In-Order code pattern below can be used to solve three different Leetcode problems. The othe**r **questions also require In-Order Traversal**\\n\\n**IN-ORDER TRAVERSAL - USING STACKS**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        vector<int> ans;\\n        if(root==NULL) return ans;\\n        stack<TreeNode*> s;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top();\\n            s.pop();\\n            ans.push_back(root->val);\\n            root=root->right;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n*TIME = O(N) \\nSPACE = O(N)*\\n\\n**VALIDATE A BINARY TREE**\\n\\n```class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root)\\n    {\\n        if(root==NULL) return true;\\n        stack<TreeNode*> s;\\n        TreeNode *prev=NULL;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top();  s.pop();\\n            if(prev!=NULL && root->val <= prev->val) \\n                return false;\\n            prev=root;\\n            root=root->right;\\n        }\\n        return true;\\n    }\\n};\\n```\\n*TIME = O(N)\\nWhen bad element is in the rightmost leaf*\\n*SPACE = O(N)*\\n\\n**FIND THE K-th SMALLEST ELEMENT IN A BT**\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) \\n    {\\n        stack<TreeNode*> s;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top(); s.pop();\\n            if(--k ==0) \\n                break;\\n            root=root->right;\\n        }        \\n        return root->val;\\n    }\\n};\\n```\\n\\n*TIME = O(H+k)*\\n*where H is a tree height. This complexity is defined by the stack, which contains at least H + k elements, since* *before starting to pop out one has to go down to a leaf. This results in O(logN+k) for the balanced tree and O(N+k) for completely unbalanced tree with all the nodes in the left subtree.*\\n\\n*SPACE = O(H+k)\\nworst case (space) = O(N+k)\\nAverage case (space)= O(logn +k)*\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        vector<int> ans;\\n        if(root==NULL) return ans;\\n        stack<TreeNode*> s;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top();\\n            s.pop();\\n            ans.push_back(root->val);\\n            root=root->right;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root)\\n    {\\n        if(root==NULL) return true;\\n        stack<TreeNode*> s;\\n        TreeNode *prev=NULL;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top();  s.pop();\\n            if(prev!=NULL && root->val <= prev->val) \\n                return false;\\n            prev=root;\\n            root=root->right;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) \\n    {\\n        stack<TreeNode*> s;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top(); s.pop();\\n            if(--k ==0) \\n                break;\\n            root=root->right;\\n        }        \\n        return root->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234471,
                "title": "python3-100-using-iteration-readable",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: \\'TreeNode\\') -> \\'List[int]\\':\\n        if not root:\\n            return []\\n        stack = list()\\n        output = list()\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                output.append(node.val)\\n                root = node.right\\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: \\'TreeNode\\') -> \\'List[int]\\':\\n        if not root:\\n            return []\\n        stack = list()\\n        output = list()\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                output.append(node.val)\\n                root = node.right\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31332,
                "title": "why-every-solution-is-using-2-while-loops-the-standard-iterative-solution-shoule-only-has-one-while-loop",
                "content": "```\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<Integer> ();\\n        if (root == null) return res;\\n        \\n        Stack<TreeNode> s = new Stack<TreeNode>();\\n        TreeNode n = root;\\n        \\n        while (n != null || !s.isEmpty()) {\\n            if  (n != null) {\\n                s.push(n);\\n                n = n.left;\\n            }\\n            else {\\n                TreeNode l = s.pop();\\n                res.add(l.val);\\n                n = l.right;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<Integer> ();\\n        if (root == null) return res;\\n        \\n        Stack<TreeNode> s = new Stack<TreeNode>();\\n        TreeNode n = root;\\n        \\n        while (n != null || !s.isEmpty()) {\\n            if  (n != null) {\\n                s.push(n);\\n                n = n.left;\\n            }\\n            else {\\n                TreeNode l = s.pop();\\n                res.add(l.val);\\n                n = l.right;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31344,
                "title": "javascript-solution",
                "content": "`````\\nvar inorderTraversal = function(root) {\\n    var stack = [],\\n        res = [];\\n    \\n    while(true){\\n        if(root !== null){\\n            stack.push(root);\\n            root = root.left;\\n        }else{\\n            if(stack.length === 0) break;\\n            root = stack.pop();\\n            res.push(root.val);\\n            root = root.right;\\n        }\\n    }\\n    \\n    return res;\\n};",
                "solutionTags": [],
                "code": "`````\\nvar inorderTraversal = function(root) {\\n    var stack = [],\\n        res = [];\\n    \\n    while(true){\\n        if(root !== null){\\n            stack.push(root);\\n            root = root.left;\\n        }else{\\n            if(stack.length === 0) break;\\n            root = stack.pop();\\n            res.push(root.val);\\n            root = root.right;\\n        }\\n    }\\n    \\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3626483,
                "title": "1-line-solution-python",
                "content": "# Approach\\n1. The function begins with a base case check: `[] if not root`. If the `root` node is `None` (i.e., there is no tree), an empty list `[]` is returned.\\n\\n2. If the `root` node is not `None`, the function recursively calls itself to perform an inorder traversal on the left subtree: `self.inorderTraversal(root.left)`. This step visits all the nodes in the left subtree in the inorder sequence.\\n\\n3. After the recursive call for the left subtree, the value of the `root` node is appended to the result list using `[root.val]`.\\n\\n4. Finally, the function recursively calls itself to perform an inorder traversal on the right subtree: `self.inorderTraversal(root.right)`. This step visits all the nodes in the right subtree in the inorder sequence.\\n\\n5. The function returns the concatenation of the left subtree traversal, the `root` value, and the right subtree traversal: `self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)`.\\n\\nThis approach utilizes the recursive nature of the inorder traversal. It recursively traverses the left subtree, visits the current node, and then recursively traverses the right subtree. The base case handles the empty tree, and the concatenation of the traversal results builds the final inorder traversal list.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        return [] if not root else self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)                       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        return [] if not root else self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)                       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436598,
                "title": "simple-c-solution",
                "content": "# Inorder -> Left Node Right\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n```\\n# Iterative\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        stack<TreeNode *> st;\\n        while(true){\\n            if(root!=NULL){\\n                st.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                if(st.empty()){\\n                    break;\\n                }\\n                root=st.top();\\n                res.push_back(root->val);\\n                st.pop();\\n                root=root->right;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n# Recursive\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<int> &res, TreeNode *root){\\n        if(root==NULL){\\n            return ;\\n        }\\n        helper(res,root->left);\\n        res.push_back(root->val);\\n        helper(res,root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        helper(res,root);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        stack<TreeNode *> st;\\n        while(true){\\n            if(root!=NULL){\\n                st.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                if(st.empty()){\\n                    break;\\n                }\\n                root=st.top();\\n                res.push_back(root->val);\\n                st.pop();\\n                root=root->right;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<int> &res, TreeNode *root){\\n        if(root==NULL){\\n            return ;\\n        }\\n        helper(res,root->left);\\n        res.push_back(root->val);\\n        helper(res,root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        helper(res,root);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300936,
                "title": "easiest-solution-out-there-in-5-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPlsssss Up vote -> \\uD83D\\uDE2D\\n# Code\\n```\\n\\nclass Solution {\\n    List<Integer> list = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        if (root!=null) {\\n            inorderTraversal(root.left);\\n            list.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    List<Integer> list = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        if (root!=null) {\\n            inorderTraversal(root.left);\\n            list.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268031,
                "title": "beats-100-use-of-recursion-in-java",
                "content": "\\n\\n# Approach\\nThis is a Java program that solves the problem of traversing a binary tree in an inorder manner. The input to the program is a binary tree, represented using the TreeNode class. The TreeNode class has three fields: val, left, and right. The val field stores the value of the node, while the left and right fields store references to the left and right subtrees, respectively. The program returns a list of integers representing the inorder traversal of the binary tree.\\n\\nThe solution implements the inorder traversal recursively using the helper function func. The function takes two arguments: the current node being traversed (root) and the list to which the values are to be added (ans). The traversal is done as follows:\\n\\n1. If the current node is null, return.\\n2. Recursively traverse the left subtree.\\n3. Add the value of the current node to the list.\\n4. Recursively traverse the right subtree.\\n\\n\\n\\nThe main function, inorderTraversal, initializes an empty list ans and calls the helper function func with the root node and the list. Finally, the function returns the list containing the inorder traversal of the binary tree.\\n\\nOverall, the program is an implementation of the classic inorder traversal algorithm for binary trees\\n# Complexity\\n- Time complexity: \\nO(N), where N is the number of nodes in the binary tree. This is because the function visits each node exactly once.\\n\\n\\n- Space complexity:\\nO(N), where N is the number of nodes in the binary tree. This is because the maximum depth of the recursion is equal to the height of the binary tree, and in the worst case, the binary tree can be a degenerate tree, which means that it has N nodes and a height of N. In this case, the recursion would use O(N) space.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        func(root,ans);\\n        return ans;\\n    }\\n    public void func(TreeNode root,List<Integer> ans){\\n        if(root==null){\\n            return;\\n        }\\n        func(root.left,ans);\\n        ans.add(root.val);\\n        func(root.right,ans);\\n    }\\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/2c79ad82-a411-4e0d-9b03-481e726b3c16_1678181469.338393.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        func(root,ans);\\n        return ans;\\n    }\\n    public void func(TreeNode root,List<Integer> ans){\\n        if(root==null){\\n            return;\\n        }\\n        func(root.left,ans);\\n        ans.add(root.val);\\n        func(root.right,ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168608,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nRecurive Solution\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL) \\n            return;\\n        inorder(root->left, nodes);\\n        nodes.push_back(root->val);\\n        inorder(root->right, nodes);    \\n    }    \\n};\\n```\\n\\n# Approach 2\\nIterative Solution\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> inorder;\\n        if (root == NULL)\\n            return inorder;\\n        stack <TreeNode* > st;\\n        TreeNode* curr = root;\\n        while (true) {\\n            if (curr != NULL) {\\n                st.push(curr);\\n                curr = curr->left;\\n            } else {\\n                if (st.empty() == true)\\n                    break;\\n                curr = st.top();\\n                st.pop();\\n                inorder.push_back(curr->val);\\n                curr = curr->right;    \\n            }\\n        }    \\n        return inorder;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL) \\n            return;\\n        inorder(root->left, nodes);\\n        nodes.push_back(root->val);\\n        inorder(root->right, nodes);    \\n    }    \\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> inorder;\\n        if (root == NULL)\\n            return inorder;\\n        stack <TreeNode* > st;\\n        TreeNode* curr = root;\\n        while (true) {\\n            if (curr != NULL) {\\n                st.push(curr);\\n                curr = curr->left;\\n            } else {\\n                if (st.empty() == true)\\n                    break;\\n                curr = st.top();\\n                st.pop();\\n                inorder.push_back(curr->val);\\n                curr = curr->right;    \\n            }\\n        }    \\n        return inorder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070108,
                "title": "morris-inorder-traversal",
                "content": "My Python approach for Morris Inorder Traversal.\\nBased on [this](https://www.youtube.com/watch?v=80Zug6D1_r4) video.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans = []\\n        cur = root\\n        while cur != None:\\n            #printing the leftmost node\\n            if not cur.left:\\n                ans.append(cur.val)\\n                cur = cur.right\\n            else:\\n                temp = cur\\n                temp = temp.left\\n                #going to the rightmost node in the left subtree (lets call it temp)\\n                while temp.right and temp.right != cur:\\n                    temp = temp.right\\n                \\n                #2 conditions arise:\\n                \\n                #i. the right child of temp doesn\\'t exist (The thread to the cur node has not been made)\\n                #in this case, point the right child of temp to cur and move cur to its left child\\n                if not temp.right:\\n                    temp.right = cur\\n                    cur = cur.left\\n\\n                #ii. the thread has already been created so we break the thread\\n                #(pointing the temp\\'s right child back to None)and print cur.\\n                #Finally, move cur to its right child      \\n                else:\\n                    ans.append(cur.val)\\n                    temp.right = None\\n                    cur = cur.right\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans = []\\n        cur = root\\n        while cur != None:\\n            #printing the leftmost node\\n            if not cur.left:\\n                ans.append(cur.val)\\n                cur = cur.right\\n            else:\\n                temp = cur\\n                temp = temp.left\\n                #going to the rightmost node in the left subtree (lets call it temp)\\n                while temp.right and temp.right != cur:\\n                    temp = temp.right\\n                \\n                #2 conditions arise:\\n                \\n                #i. the right child of temp doesn\\'t exist (The thread to the cur node has not been made)\\n                #in this case, point the right child of temp to cur and move cur to its left child\\n                if not temp.right:\\n                    temp.right = cur\\n                    cur = cur.left\\n\\n                #ii. the thread has already been created so we break the thread\\n                #(pointing the temp\\'s right child back to None)and print cur.\\n                #Finally, move cur to its right child      \\n                else:\\n                    ans.append(cur.val)\\n                    temp.right = None\\n                    cur = cur.right\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2550488,
                "title": "96-05-senior-developer-javascript-js-2022",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    let res = [];\\n    \\n    const fn = (node) => {\\n        if (!node) return;\\n        fn(node.left);  \\n        res.push(node.val)\\n        fn(node.right);\\n    }\\n    \\n    fn(root);\\n    \\n    return res;\\n    \\n};\\n\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    let res = [];\\n    \\n    const fn = (node) => {\\n        if (!node) return;\\n        fn(node.left);  \\n        res.push(node.val)\\n        fn(node.right);\\n    }\\n    \\n    fn(root);\\n    \\n    return res;\\n    \\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2549705,
                "title": "simplest-approach-c-9ms-iterative-inorder-traversal",
                "content": "Just move to the left most node and then go on pushing the node values. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void dfs(TreeNode* node){\\n        if(!node)\\n            return;\\n        dfs(node->left);\\n        ans.push_back(node->val);\\n        dfs(node->right);        \\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void dfs(TreeNode* node){\\n        if(!node)\\n            return;\\n        dfs(node->left);\\n        ans.push_back(node->val);\\n        dfs(node->right);        \\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546965,
                "title": "daily-leetcoding-challenge-september-day-8",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-inorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterating method using Stack\n\n  \n**Approach 3:** Morris Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-inorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2286560,
                "title": "3-approach-in-c-recursive-iterative-morris-traversal",
                "content": "**Recursive Approach:**\\n````\\n void inordert(TreeNode* root, vector<int>& ans)\\n    {\\n        if(root == NULL) return;\\n        inordert(root->left, ans);\\n        ans.push_back(root->val);\\n        inordert(root->right, ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inordert(root, ans);\\n        return ans;\\n    }\\n````\\n\\n-------------------------------------------------------------------------------------------------------\\n**Iterative Approach:**\\n````\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode* node = root;\\n        stack<TreeNode*> st;\\n        while(true)\\n        {\\n            if(node != NULL)\\n            {\\n                st.push(node);\\n                node = node->left;\\n            }\\n            else\\n            {\\n                if(st.empty() == true) break;\\n                else\\n                {\\n                    node = st.top();\\n                    st.pop();\\n                    ans.push_back(node->val);\\n                    node = node->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n````\\n\\n-------------------------------------------------------------------------------------------------------\\n**Morris Traversal:**\\n````\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode *node = root;\\n        while(node != NULL)\\n        {\\n            if(node->left == NULL) \\n            {\\n                ans.push_back(node->val);\\n                node = node->right;\\n            }\\n            else\\n            {\\n                TreeNode *prev = node->left;\\n                while(prev->right && prev->right != node)\\n                {\\n                    prev = prev->right;\\n                }\\n                if(prev->right == NULL)\\n                {\\n                    prev->right = node;\\n                    node = node->left;\\n                }\\n                else\\n                {\\n                    prev->right = NULL;\\n                    ans.push_back(node->val);\\n                    node = node->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n````\\n\\n**One Request: Please do upvote if you found these approaches helpful, as it motivates me to post such useful content to help our leetcode community. Thanks in Advance!**",
                "solutionTags": [],
                "code": "````\\n void inordert(TreeNode* root, vector<int>& ans)\\n    {\\n        if(root == NULL) return;\\n        inordert(root->left, ans);\\n        ans.push_back(root->val);\\n        inordert(root->right, ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inordert(root, ans);\\n        return ans;\\n    }\\n```\n````\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode* node = root;\\n        stack<TreeNode*> st;\\n        while(true)\\n        {\\n            if(node != NULL)\\n            {\\n                st.push(node);\\n                node = node->left;\\n            }\\n            else\\n            {\\n                if(st.empty() == true) break;\\n                else\\n                {\\n                    node = st.top();\\n                    st.pop();\\n                    ans.push_back(node->val);\\n                    node = node->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n````\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode *node = root;\\n        while(node != NULL)\\n        {\\n            if(node->left == NULL) \\n            {\\n                ans.push_back(node->val);\\n                node = node->right;\\n            }\\n            else\\n            {\\n                TreeNode *prev = node->left;\\n                while(prev->right && prev->right != node)\\n                {\\n                    prev = prev->right;\\n                }\\n                if(prev->right == NULL)\\n                {\\n                    prev->right = node;\\n                    node = node->left;\\n                }\\n                else\\n                {\\n                    prev->right = NULL;\\n                    ans.push_back(node->val);\\n                    node = node->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2248076,
                "title": "java-easy-standard-solution-0ms",
                "content": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n      \\n       ArrayList<Integer> ans = new ArrayList<Integer>();\\n      if(root == null) return ans; // base condition\\n      \\n      Stack<TreeNode> st = new Stack<>();\\n      \\n      TreeNode cur = root;\\n        while(cur != null || !st.isEmpty()) {\\n          while(cur != null) {\\n            st.add(cur);\\n            cur = cur.left;\\n          }\\n          cur = st.pop();\\n          ans.add(cur.val);\\n          cur = cur.right;\\n        }\\n      return ans;\\n    }\\n}\\n```\\n# KINDLY UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n      \\n       ArrayList<Integer> ans = new ArrayList<Integer>();\\n      if(root == null) return ans; // base condition\\n      \\n      Stack<TreeNode> st = new Stack<>();\\n      \\n      TreeNode cur = root;\\n        while(cur != null || !st.isEmpty()) {\\n          while(cur != null) {\\n            st.add(cur);\\n            cur = cur.left;\\n          }\\n          cur = st.pop();\\n          ans.add(cur.val);\\n          cur = cur.right;\\n        }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161133,
                "title": "python-simple-and-easy-solution-using-recursion",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        #Approach - Using Recursion\\n        in_list=[]\\n        if not root:\\n            return\\n        if root.left:\\n            in_list+=self.inorderTraversal(root.left)\\n        in_list.append(root.val)\\n        if root.right:\\n            in_list+=self.inorderTraversal(root.right)\\n        return in_list\\n        \\n```\\n**Please Upvote if it was Helpful. :)**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        #Approach - Using Recursion\\n        in_list=[]\\n        if not root:\\n            return\\n        if root.left:\\n            in_list+=self.inorderTraversal(root.left)\\n        in_list.append(root.val)\\n        if root.right:\\n            in_list+=self.inorderTraversal(root.right)\\n        return in_list\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663643,
                "title": "c-iterative-and-recursive",
                "content": "Both recursive and iterative solutions use stack.\\nFor iterative solution it uses a user defined stack.\\n\\nIterative Solution\\n\\n1) Intitialize a stack.\\n2) While loop with OR conditions if stack is empty or node is null\\n3) First we traverse through all the left child. Push all the left child nodes in the stack to refer again.\\n4) If node is null, Pop the last element, print the value and visit its right child.\\n\\n```\\n\\t\\tstack <TreeNode*> S;\\n        vector <int> res;\\n        TreeNode* temp = root;\\n        \\n        while((!S.empty())||(temp != NULL)){\\n            if(temp != NULL){\\n                S.push(temp);\\n                temp = temp->left;                \\n            }\\n            else{\\n                temp = S.top();\\n                S.pop();\\n                res.push_back(temp->val);\\n                temp = temp->right;\\n            }\\n        }\\n        return res;        \\n```\\n\\n\\nIterative Solution\\n1) Visit and store All left child\\n2) Print the value\\n3) Visit all Right child\\n```\\n\\tvoid inorder(TreeNode* root,vector <int> &res){\\n        if(root){\\n        inorder(root->left,res);\\n        res.push_back(root->val);\\n        inorder(root->right,res);\\n        }\\n        //return res\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> res;\\n        inorder(root,res);\\n        return res;\\n    }\\n```\\n\\nHope it helps!\\nPlease up vote.\\nFor more detailed explanation please refer https://www.techiedelight.com/inorder-tree-traversal-iterative-recursive/",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\n\\t\\tstack <TreeNode*> S;\\n        vector <int> res;\\n        TreeNode* temp = root;\\n        \\n        while((!S.empty())||(temp != NULL)){\\n            if(temp != NULL){\\n                S.push(temp);\\n                temp = temp->left;                \\n            }\\n            else{\\n                temp = S.top();\\n                S.pop();\\n                res.push_back(temp->val);\\n                temp = temp->right;\\n            }\\n        }\\n        return res;        \\n```\n```\\n\\tvoid inorder(TreeNode* root,vector <int> &res){\\n        if(root){\\n        inorder(root->left,res);\\n        res.push_back(root->val);\\n        inorder(root->right,res);\\n        }\\n        //return res\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> res;\\n        inorder(root,res);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1570071,
                "title": "recursion-time-complexity-space-complexity-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> nodeVec;\\n        doTraversal(nodeVec,root);\\n        return nodeVec;\\n    }\\n\\t\\n    void doTraversal(vector<int> &nodeVec, TreeNode* temp)\\n    {\\n        if(temp==nullptr)\\n            return;\\n        doTraversal(nodeVec,temp->left);\\n        nodeVec.push_back(temp->val);\\n        doTraversal(nodeVec,temp->right);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> nodeVec;\\n        doTraversal(nodeVec,root);\\n        return nodeVec;\\n    }\\n\\t\\n    void doTraversal(vector<int> &nodeVec, TreeNode* temp)\\n    {\\n        if(temp==nullptr)\\n            return;\\n        doTraversal(nodeVec,temp->left);\\n        nodeVec.push_back(temp->val);\\n        doTraversal(nodeVec,temp->right);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540039,
                "title": "c-inorder-preorder-postorder-all-3-solution-0ms-faster-than-100",
                "content": "You can observe there is just a minimal diffrence in all 3 ,i.e, it\\'s just the way of filling vector while calling fill function.  \\n***Inorder Traversal :*** \\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        ans.push_back(root->val);  // Inorder\\n        fill(root->right);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\\n\\n***Preorder Traversal :***\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        ans.push_back(root->val);  // Preoder\\n        fill(root->left);\\n        fill(root->right);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\\n\\n***Postorder Traversal :***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        fill(root->right);\\n        ans.push_back(root->val);  /// Postorder\\n    }\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\\nHope you liked it , kindly upvote !!\\n\\nHappy Coding \\uD83E\\uDD17",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        ans.push_back(root->val);  // Inorder\\n        fill(root->right);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        ans.push_back(root->val);  // Preoder\\n        fill(root->left);\\n        fill(root->right);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        fill(root->right);\\n        ans.push_back(root->val);  /// Postorder\\n    }\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907247,
                "title": "simple-javascript-solution-recursive",
                "content": "Simple Javascript solution using spread operator:\\n\\n```javascript \\nvar inorderTraversal = function(root) {\\n    if (!root) {\\n      return [];\\n    }\\n    let left = inorderTraversal(root.left);\\n    let mid = root.val;\\n    let right = inorderTraversal(root.right);\\n    return [...left, mid, ...right];\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```javascript \\nvar inorderTraversal = function(root) {\\n    if (!root) {\\n      return [];\\n    }\\n    let left = inorderTraversal(root.left);\\n    let mid = root.val;\\n    let right = inorderTraversal(root.right);\\n    return [...left, mid, ...right];\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 600732,
                "title": "javascript-iterative-solution-stack-93-56",
                "content": "Very simpe iterative solution which uses stack.\\n\\nRuntime: 48 ms, faster than 93.31% of JavaScript online submissions for Binary Tree Inorder Traversal.\\nMemory Usage: 33.8 MB, less than 56.25% of JavaScript online submissions for Binary Tree Inorder Traversal.\\n\\n```\\nfunction inorderTraversal(root) {\\n  const stack = [], ret = [];\\n  root && stack.push(root);\\n  while (stack.length) {\\n    const item = stack.pop();\\n    if (item.left) {\\n      stack.push(item);\\n      stack.push(item.left);\\n      item.left = null;\\n    }\\n    else {\\n      ret.push(item.val);\\n      item.right && stack.push(item.right);\\n    }\\n  }\\n  return ret;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nfunction inorderTraversal(root) {\\n  const stack = [], ret = [];\\n  root && stack.push(root);\\n  while (stack.length) {\\n    const item = stack.pop();\\n    if (item.left) {\\n      stack.push(item);\\n      stack.push(item.left);\\n      item.left = null;\\n    }\\n    else {\\n      ret.push(item.val);\\n      item.right && stack.push(item.right);\\n    }\\n  }\\n  return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 516768,
                "title": "c-iterative-lnr-using-stack",
                "content": "```\\npublic class Solution {\\n    public IList<int> InorderTraversal(TreeNode root) {\\n        List<int> result = new List<int>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        while (stack.Count != 0 || root != null) {\\n            if (root != null) {\\n                stack.Push(root);\\n                root = root.left;\\n            } else {\\n                root = stack.Pop();\\n                result.Add(root.val);\\n                root = root.right;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> InorderTraversal(TreeNode root) {\\n        List<int> result = new List<int>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        while (stack.Count != 0 || root != null) {\\n            if (root != null) {\\n                stack.Push(root);\\n                root = root.left;\\n            } else {\\n                root = stack.Pop();\\n                result.Add(root.val);\\n                root = root.right;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 458464,
                "title": "python-simple-iterative-and-recursive-solutions-98-faster-100-less-memory",
                "content": "```\\n\\n#recursive\\nclass Solution:\\n    def __init__(self):\\n        self.return_list = []\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        \\n        if root:\\n            self.inorderTraversal(root.left)\\n            \\n            self.return_list.append(root.val)\\n            \\n            self.inorderTraversal(root.right)\\n            \\n        return self.return_list\\n```\\n```\\n#ITERATIVE\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:        \\n        return_list = []\\n        stack = []\\n        node = root\\n        \\n        while True:\\n            \\n            if node is not None:\\n                stack.append(node)\\n                node = node.left\\n                \\n            elif(stack):\\n                node = stack.pop()\\n                return_list.append(node.val)\\n                node = node.right\\n            else:\\n                break\\n        return return_list",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\n#recursive\\nclass Solution:\\n    def __init__(self):\\n        self.return_list = []\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        \\n        if root:\\n            self.inorderTraversal(root.left)\\n            \\n            self.return_list.append(root.val)\\n            \\n            self.inorderTraversal(root.right)\\n            \\n        return self.return_list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455535,
                "title": "javascript-1-line-solution",
                "content": "```js\\nconst inorderTraversal = root => root ? [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)] : [];",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst inorderTraversal = root => root ? [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)] : [];",
                "codeTag": "Unknown"
            },
            {
                "id": 180116,
                "title": "javascript",
                "content": "```\\nvar inorderTraversal = function(root) {\\n    let result = [];\\n    dfs(root);\\n    \\n    function dfs(root) {\\n        if(root != null) {\\n            dfs(root.left);\\n            result.push(root.val);\\n            dfs(root.right);\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar inorderTraversal = function(root) {\\n    let result = [];\\n    dfs(root);\\n    \\n    function dfs(root) {\\n        if(root != null) {\\n            dfs(root.left);\\n            result.push(root.val);\\n            dfs(root.right);\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 166659,
                "title": "javascript-100-iterative-and-recursive",
                "content": "Recursive:\\n\\n```js\\nconst inorderTraversal = root => {\\n  if (!root) return [];\\n  \\n  return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n};\\n```\\n\\nIterative (using a stack):\\n```js\\nconst inorderTraversal = root => {\\n  const traversed = [];\\n  \\n  if (!root) {\\n    return traversed;\\n  }\\n  \\n  const nodes = [root];\\n  let currentNode = root.left;\\n  \\n  while (currentNode || nodes.length) {\\n    while (currentNode) {\\n      nodes.push(currentNode);\\n      currentNode = currentNode.left;\\n    }\\n    \\n    currentNode = nodes.pop();\\n    traversed.push(currentNode.val);\\n    currentNode = currentNode.right;\\n  }\\n  \\n  return traversed;\\n}\\n```\\n\\nBoth have 52ms runtime.",
                "solutionTags": [],
                "code": "```js\\nconst inorderTraversal = root => {\\n  if (!root) return [];\\n  \\n  return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n};\\n```\n```js\\nconst inorderTraversal = root => {\\n  const traversed = [];\\n  \\n  if (!root) {\\n    return traversed;\\n  }\\n  \\n  const nodes = [root];\\n  let currentNode = root.left;\\n  \\n  while (currentNode || nodes.length) {\\n    while (currentNode) {\\n      nodes.push(currentNode);\\n      currentNode = currentNode.left;\\n    }\\n    \\n    currentNode = nodes.pop();\\n    traversed.push(currentNode.val);\\n    currentNode = currentNode.right;\\n  }\\n  \\n  return traversed;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 152061,
                "title": "recursive-and-iterative-approaches-using-ruby",
                "content": "### Recursive approach\\n```ruby\\ndef inorder_traversal_recursive(root)\\n  response = []\\n  traverse(root, response)\\n  return response\\nend\\n\\ndef traverse(node, response)\\n  return if node.nil?\\n  \\n  traverse(node.left, response) if node.left\\n  response << node.val\\n  traverse(node.right, response) if node.right\\nend\\n```\\n\\n### Iterative approach\\n```ruby\\ndef inorder_traversal(root)\\n  curr = root\\n  stack, res = [], []\\n  \\n  while !(curr.nil? and stack.empty?)\\n    while curr\\n      stack.push(curr)\\n      curr = curr.left\\n    end\\n    curr = stack.pop\\n    res << curr.val\\n    curr = curr.right\\n  end\\n  \\n  return res\\nend\\n````\\n",
                "solutionTags": [],
                "code": "```ruby\\ndef inorder_traversal_recursive(root)\\n  response = []\\n  traverse(root, response)\\n  return response\\nend\\n\\ndef traverse(node, response)\\n  return if node.nil?\\n  \\n  traverse(node.left, response) if node.left\\n  response << node.val\\n  traverse(node.right, response) if node.right\\nend\\n```\n```ruby\\ndef inorder_traversal(root)\\n  curr = root\\n  stack, res = [], []\\n  \\n  while !(curr.nil? and stack.empty?)\\n    while curr\\n      stack.push(curr)\\n      curr = curr.left\\n    end\\n    curr = stack.pop\\n    res << curr.val\\n    curr = curr.right\\n  end\\n  \\n  return res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 31378,
                "title": "share-my-c-solution-very-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode* root) {\\n            vector<int> ret;\\n            stack<TreeNode *> s;\\n            TreeNode *temp = root;\\n            \\n            while (!s.empty() || temp != NULL)\\n            {\\n                while (temp != NULL)\\n                {\\n                    s.push(temp);\\n                    temp = temp->left;\\n                }\\n                \\n                temp = s.top();\\n                ret.push_back(temp->val);\\n                s.pop();\\n                temp = temp->right;\\n            }\\n            \\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode* root) {\\n            vector<int> ret;\\n            stack<TreeNode *> s;\\n            TreeNode *temp = root;\\n            \\n            while (!s.empty() || temp != NULL)\\n            {\\n                while (temp != NULL)\\n                {\\n                    s.push(temp);\\n                    temp = temp->left;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3509959,
                "title": "python-easy-recursive-iterative-both-solutions",
                "content": "**Iterative Solution:**\\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return\\n        t=root\\n        a=[]\\n        ans=[]\\n        while True:\\n            if t:\\n                a.append(t)\\n                t=t.left\\n            else:\\n                if len(a)==0:\\n                    break\\n                t=a.pop()\\n                ans.append(t.val)\\n                t=t.right \\n        return ans\\n```\\n**Recursive Solution:**\\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.ans=[]\\n        self.Traversal(root)\\n        return self.ans\\n    def Traversal(self,root):\\n        if root is None:\\n            return\\n        self.Traversal(root.left)\\n        self.ans.append(root.val)\\n        self.Traversal(root.right)\\n```\\n**An  upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return\\n        t=root\\n        a=[]\\n        ans=[]\\n        while True:\\n            if t:\\n                a.append(t)\\n                t=t.left\\n            else:\\n                if len(a)==0:\\n                    break\\n                t=a.pop()\\n                ans.append(t.val)\\n                t=t.right \\n        return ans\\n```\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.ans=[]\\n        self.Traversal(root)\\n        return self.ans\\n    def Traversal(self,root):\\n        if root is None:\\n            return\\n        self.Traversal(root.left)\\n        self.ans.append(root.val)\\n        self.Traversal(root.right)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3408869,
                "title": "very-easy-o-n-intutive-recursive-code-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nVery Easy and understandable c++ code\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void solve(TreeNode* root,vector<int>&v){\\n        if(!root)\\n        return;\\n\\n        solve(root->left,v);\\n        v.push_back(root->val);\\n        solve(root->right,v);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        \\n        solve(root,v);\\n        return v;\\n        \\n    }\\n};         \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void solve(TreeNode* root,vector<int>&v){\\n        if(!root)\\n        return;\\n\\n        solve(root->left,v);\\n        v.push_back(root->val);\\n        solve(root->right,v);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        \\n        solve(root,v);\\n        return v;\\n        \\n    }\\n};         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399456,
                "title": "simple-go-solution",
                "content": "\\n```\\n\\nfunc inorderTraversal(root *TreeNode) []int {\\n\\tres := make([]int, 0, 101)\\n\\tif root != nil {\\n\\t\\tres = help(root, res)\\n\\t}\\n\\t\\n\\treturn res\\n}\\n\\nfunc help(root *TreeNode, res []int) []int {\\n\\tif root.Left != nil {\\n\\t\\tres = help(root.Left, res)\\n\\t}\\n\\tres = append(res, root.Val)\\n\\tif root.Right != nil {\\n\\t\\tres = help(root.Right, res)\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nfunc inorderTraversal(root *TreeNode) []int {\\n\\tres := make([]int, 0, 101)\\n\\tif root != nil {\\n\\t\\tres = help(root, res)\\n\\t}\\n\\t\\n\\treturn res\\n}\\n\\nfunc help(root *TreeNode, res []int) []int {\\n\\tif root.Left != nil {\\n\\t\\tres = help(root.Left, res)\\n\\t}\\n\\tres = append(res, root.Val)\\n\\tif root.Right != nil {\\n\\t\\tres = help(root.Right, res)\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3203062,
                "title": "java-easy-iterative-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root==null)  return list;\\n        TreeNode curr = root;\\n        Stack<TreeNode> st = new Stack<>();\\n        while(!st.isEmpty() || curr!=null){\\n            while(curr!=null){\\n                st.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = st.pop();\\n            list.add(curr.val);\\n            curr = curr.right;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root==null)  return list;\\n        TreeNode curr = root;\\n        Stack<TreeNode> st = new Stack<>();\\n        while(!st.isEmpty() || curr!=null){\\n            while(curr!=null){\\n                st.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = st.pop();\\n            list.add(curr.val);\\n            curr = curr.right;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195780,
                "title": "python-4-solutions-dfs-bfs-morris-1-morris-2",
                "content": "# Approach 1: DFS.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is the number of nodes in the tree`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            yield from chain(inorder(root.left), (root,), inorder(root.right)) if root else tuple()\\n        \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\\n\\n---\\n\\n# Approach 2: BFS.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is the number of nodes in the tree`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            stack = [root] if root else []\\n            \\n            while stack:\\n                node = stack.pop()\\n                if not node.left and not node.right: yield node; continue\\n                \\n                if node.right: stack.append(node.right)\\n                stack.append(TreeNode(node.val))\\n                if node.left: stack.append(node.left)\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\\n\\n---\\n\\n# Approach 3: Morris traversal. (Destroys the tree.)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is the number of nodes in the tree`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys the tree)\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            node = root\\n            while node:\\n                if node.left:\\n                    last = node.left\\n                    while last.right: last = last.right\\n                    \\n                    last.right = node\\n                    node = node.left\\n                    last.right.left = None\\n                else:\\n                    yield node\\n                    node = node.right\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\\n\\n---\\n\\n# Approach 4: Morris traversal. (Destroys and recovers the tree.)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is the number of nodes in the tree`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys and recovers the tree)\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            node = root\\n            while node:\\n                if node.left:\\n                    last = node.left\\n                    while last.right and last.right != node:\\n                        last = last.right\\n                    \\n                    if last.right:\\n                        last.right = None\\n                        yield node\\n                        node = node.right\\n                    else:\\n                        last.right = node\\n                        node = node.left\\n                else:\\n                    yield node\\n                    node = node.right\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            yield from chain(inorder(root.left), (root,), inorder(root.right)) if root else tuple()\\n        \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            stack = [root] if root else []\\n            \\n            while stack:\\n                node = stack.pop()\\n                if not node.left and not node.right: yield node; continue\\n                \\n                if node.right: stack.append(node.right)\\n                stack.append(TreeNode(node.val))\\n                if node.left: stack.append(node.left)\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys the tree)\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            node = root\\n            while node:\\n                if node.left:\\n                    last = node.left\\n                    while last.right: last = last.right\\n                    \\n                    last.right = node\\n                    node = node.left\\n                    last.right.left = None\\n                else:\\n                    yield node\\n                    node = node.right\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys and recovers the tree)\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            node = root\\n            while node:\\n                if node.left:\\n                    last = node.left\\n                    while last.right and last.right != node:\\n                        last = last.right\\n                    \\n                    if last.right:\\n                        last.right = None\\n                        yield node\\n                        node = node.right\\n                    else:\\n                        last.right = node\\n                        node = node.left\\n                else:\\n                    yield node\\n                    node = node.right\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087159,
                "title": "java-recursive-way-easy-solution-with-comments",
                "content": "# Approach\\nUsing recursive way, travsere the tree and keep adding the value to the list. Another way is by using the stack\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution \\n{\\n    //creating an instance\\n    List<Integer> list = new ArrayList<Integer>();\\n\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        //if empty tree\\n        if(root == null)\\n            return list;\\n\\n        TreeNode ptr = root;\\n\\n        traversal(ptr);\\n\\n        return list;\\n    }\\n\\n    //inorder traversal\\n    public void traversal (TreeNode root)\\n    {\\n        //return on reaching end\\n        if(root == null)\\n            return;\\n\\n        // recur on the left node\\n        traversal(root.left);\\n\\n        //get the data of the node\\n        list.add(root.val);\\n\\n        //now recur on the right node\\n        traversal(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution \\n{\\n    //creating an instance\\n    List<Integer> list = new ArrayList<Integer>();\\n\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        //if empty tree\\n        if(root == null)\\n            return list;\\n\\n        TreeNode ptr = root;\\n\\n        traversal(ptr);\\n\\n        return list;\\n    }\\n\\n    //inorder traversal\\n    public void traversal (TreeNode root)\\n    {\\n        //return on reaching end\\n        if(root == null)\\n            return;\\n\\n        // recur on the left node\\n        traversal(root.left);\\n\\n        //get the data of the node\\n        list.add(root.val);\\n\\n        //now recur on the right node\\n        traversal(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026386,
                "title": "beats-100-3-methods-morris-iterative-recursion-c-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Using simple recursion.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) (recursive call stack)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void inorderHelper(TreeNode* root, vector<int>& ans){\\n        if(root==NULL)return;\\n        inorderHelper(root->left,ans); \\n        ans.push_back(root->val);\\n        inorderHelper(root->right,ans);      \\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inorderHelper(root,ans);\\n        return ans;\\n    }\\n};\\n```\\n---\\n# Method #2 : Morris Traversal\\n\\n# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf current does not have left child\\n\\n    a. Add current\\u2019s value\\n\\n    b. Go to the right, i.e., current = current.right\\n\\nElse\\n\\n    a. In current\\'s left subtree, make current the right child of the rightmost node\\n\\n    b. Go to this left child, i.e., current = current.left\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode* curNode = root;\\n        vector<int> nodes;\\n        \\n        while (curNode != NULL) \\n        {\\n            if (curNode -> left) \\n            {\\n\\t\\t\\t\\t//Find the inorder predecessor of current\\n               //ifa) Make current as right child of the rightmost node in current\\'s left subtree\\n                TreeNode* predecessor = curNode -> left;\\n                while (predecessor -> right && predecessor -> right != curNode) //second condition used when reverting\\n                    predecessor = predecessor -> right;\\n                \\n                if ((predecessor -> right)==NULL) \\n                {\\n                    predecessor -> right = curNode;\\n                    curNode = curNode -> left; //ifb) Go to this left child\\n                }\\n                else \\n                {\\n                    //Revert back the changes\\n                    predecessor -> right = NULL;\\n                    nodes.push_back(curNode -> val);\\n                    curNode = curNode -> right;\\n                }\\n            }\\n            else \\n            {\\n                nodes.push_back(curNode -> val);  //ea)\\n                curNode = curNode -> right;  //eb)\\n            }\\n        }\\n        \\n        return nodes;\\n    }\\n};\\n```\\n---\\n# Method #3 : Iterative(Important)\\n\\n# Intution \\n- we\\'ll use a stack for that , to store addresses of elements and there state.\\n- state 0 = inorder(root->left);\\n- state 1 = cout<<data;\\n- state 2 = inorder(root->right);\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) (stack)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<pair<TreeNode*,int>> st;\\n        vector<int> v;\\n        if(root == NULL) return {};\\n        st.push({root,0});\\n        while(!st.empty()){\\n            TreeNode* cur = st.top().first;\\n            int state = st.top().second;\\n            st.pop();\\n            \\n            if(cur == NULL){\\n                continue;\\n            }\\n            if(state == 0){\\n                st.push({cur,1});\\n                st.push({cur->left,0});\\n            }else if(state == 1){\\n                v.push_back(cur->val);\\n                st.push({cur,2});\\n            }else{\\n                st.push({cur->right,0});\\n            }\\n        }\\n        return v;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void inorderHelper(TreeNode* root, vector<int>& ans){\\n        if(root==NULL)return;\\n        inorderHelper(root->left,ans); \\n        ans.push_back(root->val);\\n        inorderHelper(root->right,ans);      \\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inorderHelper(root,ans);\\n        return ans;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode* curNode = root;\\n        vector<int> nodes;\\n        \\n        while (curNode != NULL) \\n        {\\n            if (curNode -> left) \\n            {\\n\\t\\t\\t\\t//Find the inorder predecessor of current\\n               //ifa) Make current as right child of the rightmost node in current\\'s left subtree\\n                TreeNode* predecessor = curNode -> left;\\n                while (predecessor -> right && predecessor -> right != curNode) //second condition used when reverting\\n                    predecessor = predecessor -> right;\\n                \\n                if ((predecessor -> right)==NULL) \\n                {\\n                    predecessor -> right = curNode;\\n                    curNode = curNode -> left; //ifb) Go to this left child\\n                }\\n                else \\n                {\\n                    //Revert back the changes\\n                    predecessor -> right = NULL;\\n                    nodes.push_back(curNode -> val);\\n                    curNode = curNode -> right;\\n                }\\n            }\\n            else \\n            {\\n                nodes.push_back(curNode -> val);  //ea)\\n                curNode = curNode -> right;  //eb)\\n            }\\n        }\\n        \\n        return nodes;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<pair<TreeNode*,int>> st;\\n        vector<int> v;\\n        if(root == NULL) return {};\\n        st.push({root,0});\\n        while(!st.empty()){\\n            TreeNode* cur = st.top().first;\\n            int state = st.top().second;\\n            st.pop();\\n            \\n            if(cur == NULL){\\n                continue;\\n            }\\n            if(state == 0){\\n                st.push({cur,1});\\n                st.push({cur->left,0});\\n            }else if(state == 1){\\n                v.push_back(cur->val);\\n                st.push({cur,2});\\n            }else{\\n                st.push({cur->right,0});\\n            }\\n        }\\n        return v;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024178,
                "title": "94-fast-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ll=[]\\n        def tr(root):\\n            if root==None:\\n                return \\n            \\n            tr(root.left)\\n            ll.append(root.val)\\n            tr(root.right)\\n            return ll\\n        return tr(root)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ll=[]\\n        def tr(root):\\n            if root==None:\\n                return \\n            \\n            tr(root.left)\\n            ll.append(root.val)\\n            tr(root.right)\\n            return ll\\n        return tr(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006595,
                "title": "beats-100-golang",
                "content": "\\n\\n# Code\\n```\\nfunc inorderTraversal(root *TreeNode) []int {\\n\\tif root == nil {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tvar values []int\\n\\tvalues = append(values, inorderTraversal(root.Left)...)\\n\\tvalues = append(values, root.Val)\\n\\tvalues = append(values, inorderTraversal(root.Right)...)\\n\\n\\treturn values\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc inorderTraversal(root *TreeNode) []int {\\n\\tif root == nil {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tvar values []int\\n\\tvalues = append(values, inorderTraversal(root.Left)...)\\n\\tvalues = append(values, root.Val)\\n\\tvalues = append(values, inorderTraversal(root.Right)...)\\n\\n\\treturn values\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2927089,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void f(TreeNode* root, vector<int> &ans)\\n    {\\n        if(root==NULL)\\n            return;\\n        f(root->left, ans);\\n        ans.push_back(root->val);\\n        f(root->right, ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        f(root, ans);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void f(TreeNode* root, vector<int> &ans)\\n    {\\n        if(root==NULL)\\n            return;\\n        f(root->left, ans);\\n        ans.push_back(root->val);\\n        f(root->right, ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        f(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765181,
                "title": "c-traversal",
                "content": "```\\npublic:\\n    bool is_same(TreeNode *root1, TreeNode *root2){\\n        if(!root1 && !root2) return true;\\n        if((!root1 && root2) || (root1 && !root2)) return false;\\n        \\n        if(root1->val == root2->val) return is_same(root1->left , root2->right) && is_same(root1->right , root2->left);\\n        else return false;\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        return is_same(root->left, root->right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npublic:\\n    bool is_same(TreeNode *root1, TreeNode *root2){\\n        if(!root1 && !root2) return true;\\n        if((!root1 && root2) || (root1 && !root2)) return false;\\n        \\n        if(root1->val == root2->val) return is_same(root1->left , root2->right) && is_same(root1->right , root2->left);\\n        else return false;\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        return is_same(root->left, root->right);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2628733,
                "title": "typescript-javascript-solution-that-doesn-t-push-arrays-around",
                "content": "If you simply use an array outer to the function, subsequent test cases will fail, because Leetcode will run your function repeatedly but won\\'t clear the array. So the array needs to be cleared on the first invocation of the function, but the function is called recursively, so you don\\'t know when the first invocation is.\\nOne solution would be to return the arrays of numbers and concatenate them, but that needlessly moved data in the stack.\\nA faster solution is to use a closure, and initialize the array in it.\\n```\\nfunction inorderTraversal(root: TreeNode | null): number[] {\\n    const result = [];\\n    function traverse(root: TreeNode | null): number[] {\\n        if (root) {\\n            traverse(root.left);\\n            result.push(root.val);\\n            traverse(root.right);\\n        }\\n        return result;\\n    }\\n    return traverse(root);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction inorderTraversal(root: TreeNode | null): number[] {\\n    const result = [];\\n    function traverse(root: TreeNode | null): number[] {\\n        if (root) {\\n            traverse(root.left);\\n            result.push(root.val);\\n            traverse(root.right);\\n        }\\n        return result;\\n    }\\n    return traverse(root);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2564385,
                "title": "python-all-in-one-morris-with-notes-iterative-recursive-solutions",
                "content": "**Morris Traversal**\\nEven Recursive takes Auxiliary stack space so Time O(n) and sapce O(n) , But Morris takes O(n) and O(1)\\nMorris Uses treaded BT (Contains predecessor and successor information in NULL pointers)\\n**Algorithm Cases:**\\n\\t1. If left null, print curr and move right\\n\\t2. before going left, make right most node on left subtree connected to current node, then go left\\n\\t3. if thread is already pointed to current node, then remove the thread\\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\tres = []\\n\\t\\t\\tcurr = root\\n\\n\\t\\t\\twhile curr:\\n\\t\\t\\t\\t# If left null, print curr and move right\\n\\t\\t\\t\\tif not curr.left:\\n\\t\\t\\t\\t\\tres.append(curr.val)\\n\\t\\t\\t\\t\\tcurr = curr.right\\n\\t\\t\\t\\t# before going left, make right most node on left subtree connected to current node, then go left\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tprev = curr.left\\n\\t\\t\\t\\t\\twhile prev.right and prev.right!=curr:\\n\\t\\t\\t\\t\\t\\tprev = prev.right\\n\\t\\t\\t\\t\\t# make thread\\n\\t\\t\\t\\t\\tif not prev.right:\\n\\t\\t\\t\\t\\t\\tprev.right = curr\\n\\t\\t\\t\\t\\t\\tcurr = curr.left\\n\\t\\t\\t\\t\\t# if thread is already pointed to current node, means You have visited the node, cut the thread, print the root and  move to the right\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tprev.right = None\\n\\t\\t\\t\\t\\t\\tres.append(curr.val)\\n\\t\\t\\t\\t\\t\\tcurr = curr.right\\n\\t\\t\\treturn res\\n```\\n\\n**Iterative**\\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\tstack, res = [], []      \\n        while True:\\n            while root:\\n                stack.append(root)\\n                root=root.left\\n            if not stack: return res\\n            node = stack.pop()\\n            res.append(node.val)\\n            root=node.right\\n```\\n**Recursive**\\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\treturn self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right) if root else []\\n```\\n\\n**PLEASE UPVOTE IF YOU LIKED!**\\n",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\tres = []\\n\\t\\t\\tcurr = root\\n\\n\\t\\t\\twhile curr:\\n\\t\\t\\t\\t# If left null, print curr and move right\\n\\t\\t\\t\\tif not curr.left:\\n\\t\\t\\t\\t\\tres.append(curr.val)\\n\\t\\t\\t\\t\\tcurr = curr.right\\n\\t\\t\\t\\t# before going left, make right most node on left subtree connected to current node, then go left\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tprev = curr.left\\n\\t\\t\\t\\t\\twhile prev.right and prev.right!=curr:\\n\\t\\t\\t\\t\\t\\tprev = prev.right\\n\\t\\t\\t\\t\\t# make thread\\n\\t\\t\\t\\t\\tif not prev.right:\\n\\t\\t\\t\\t\\t\\tprev.right = curr\\n\\t\\t\\t\\t\\t\\tcurr = curr.left\\n\\t\\t\\t\\t\\t# if thread is already pointed to current node, means You have visited the node, cut the thread, print the root and  move to the right\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tprev.right = None\\n\\t\\t\\t\\t\\t\\tres.append(curr.val)\\n\\t\\t\\t\\t\\t\\tcurr = curr.right\\n\\t\\t\\treturn res\\n```\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\tstack, res = [], []      \\n        while True:\\n            while root:\\n                stack.append(root)\\n                root=root.left\\n            if not stack: return res\\n            node = stack.pop()\\n            res.append(node.val)\\n            root=node.right\\n```\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\treturn self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2547396,
                "title": "c-0ms-short-simple-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!***\\n\\t\\n**TC** = O(N)\\n\\t\\n\\tvoid solve(TreeNode *root, vector<int>&v){\\n        if(!root) return;\\n        \\n        solve(root->left,v);         //root->left\\n        v.push_back(root->val);      //store root->val\\n        solve(root->right,v);        //root->right\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        solve(root,v);\\n        return v;\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!***\\n\\t\\n**TC** = O(N)\\n\\t\\n\\tvoid solve(TreeNode *root, vector<int>&v){\\n        if(!root) return;\\n        \\n        solve(root->left,v);         //root->left\\n        v.push_back(root->val);      //store root->val\\n        solve(root->right,v);        //root->right\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        solve(root,v);\\n        return v;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2229713,
                "title": "c-solution-faster-than-100-solutions-currently",
                "content": "**The below code is faster than 100% of the solutions currently on LeetCode. Happy Leetcoding !!\\nDo Upvote \\u270C\\uD83C\\uDFFB**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorder (TreeNode* root,vector<int>&v)\\n    {\\n       if(root!=NULL)\\n       {\\n            inorder(root->left,v);\\n            v.push_back(root->val);\\n            inorder(root->right,v);\\n       }\\n        return v;\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        \\n        inorder(root,v);\\n        \\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Tree",
                    "Recursion",
                    "Binary Tree",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> inorder (TreeNode* root,vector<int>&v)\\n    {\\n       if(root!=NULL)\\n       {\\n            inorder(root->left,v);\\n            v.push_back(root->val);\\n            inorder(root->right,v);\\n       }\\n        return v;\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        \\n        inorder(root,v);\\n        \\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147819,
                "title": "two-lines-solution-in-kotlin",
                "content": "Simple solution using recursion in Kotlin\\n\\n```\\nclass Solution {\\n    \\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n       root ?: return listOf<Int>()\\n       return  inorderTraversal(root.left) + listOf(root.`val`) + inorderTraversal(root.right)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    \\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n       root ?: return listOf<Int>()\\n       return  inorderTraversal(root.left) + listOf(root.`val`) + inorderTraversal(root.right)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050074,
                "title": "python-100-easy-solution",
                "content": "\\n\\tresult = []\\n        return self.dfs(root, result)\\n    \\n    def dfs(self, node, res):\\n        if node is not None:\\n            self.dfs(node.left, res)\\n            res.append(node.val)\\n            self.dfs(node.right, res)\\n        return res",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "\\n\\tresult = []\\n        return self.dfs(root, result)\\n    \\n    def dfs(self, node, res):\\n        if node is not None:\\n            self.dfs(node.left, res)\\n            res.append(node.val)\\n            self.dfs(node.right, res)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1978409,
                "title": "c-iterative-solution-stack-with-comments",
                "content": "```\\nclass Solution {\\n\\t// Inorder - Left Subtree -> Root -> Right Subtree\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        vector<int> ans;\\n        \\n\\t\\t// 1. Make root as the starting node, that is currNode\\n        TreeNode* currNode = root;\\n        while (currNode or !st.empty()) {\\n\\t\\t// 2. Now add all the left subtree nodes to the stack\\n            while (currNode) {\\n                st.push(currNode);\\n                currNode = currNode->left;\\n            }   \\n        // 3. Pick out the top node, put it in answer array\\n            currNode = st.top();\\n            st.pop();\\n            \\n            ans.push_back(currNode->val);\\n\\t\\t// 4. Update currNode as below, this will take care of the right subtree\\n            currNode = currNode->right;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n\\t// Inorder - Left Subtree -> Root -> Right Subtree\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        vector<int> ans;\\n        \\n\\t\\t// 1. Make root as the starting node, that is currNode\\n        TreeNode* currNode = root;\\n        while (currNode or !st.empty()) {\\n\\t\\t// 2. Now add all the left subtree nodes to the stack\\n            while (currNode) {\\n                st.push(currNode);\\n                currNode = currNode->left;\\n            }   \\n        // 3. Pick out the top node, put it in answer array\\n            currNode = st.top();\\n            st.pop();\\n            \\n            ans.push_back(currNode->val);\\n\\t\\t// 4. Update currNode as below, this will take care of the right subtree\\n            currNode = currNode->right;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958957,
                "title": "scala-solution",
                "content": "```\\nobject Solution {\\n    def inorderTraversal(root: TreeNode): List[Int] = {\\n        if(root == null) List()\\n        else inorderTraversal(root.left) ++ List(root.value) ++ inorderTraversal(root.right)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def inorderTraversal(root: TreeNode): List[Int] = {\\n        if(root == null) List()\\n        else inorderTraversal(root.left) ++ List(root.value) ++ inorderTraversal(root.right)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1777345,
                "title": "python-solution-iterative-recursive-easy-to-understand",
                "content": "```python\\n# Recursive and Iterative Solutions to inOrder, preOrder, and postOrder traversal\\n# ------------------------------------------- recursive\\n# recursive\\ndef BSTTraversal(root):\\n    res = []\\n    def inOrder(root):\\n        if root:\\n            inOrder(root.left)\\n            res.append(root.val)\\n            inOrder(root.right)\\n    \\n    def preOrder(root):\\n        if root:\\n            res.append(root.val)\\n            inOrder(root.left)\\n            inOrder(root.right)\\n    \\n    def postOrder(root):\\n        if root:\\n            inOrder(root.left)\\n            inOrder(root.right)\\n            res.append(root.val)\\n    \\n    inOrder(root)\\n    return res\\n\\n# one-liner recursive\\ndef traverse(root):\\n    return self.postorderTraversal(root.left)+self.postorderTraversal(root.right)+[root.val] if root else [] #post order\\n    # return self.postorderTraversal(root.left)+[root.val]+self.postorderTraversal(root.right) if root else [] #in order\\n    # return [root.val]+self.postorderTraversal(root.left)+self.postorderTraversal(root.right) if root else [] #pre order\\n\\n# ------------------------------------------- Iterative\\ndef inorderTraversal(self, root):\\n    stack, result = [], []   \\n    curr = root\\n    while curr or stack:\\n        while curr:\\n            stack.append(curr)\\n            curr = curr.left\\n        node = stack.pop()\\n        result.append(node.val)\\n        curr = node.right\\n        \\n    return result\\n\\ndef preorderTraversal(self, root):\\n    stack, result = [root], []   \\n    while stack:\\n        curr = stack.pop()\\n        if curr:\\n            result.append(curr.val)\\n            stack.append(curr.right)\\n            stack.append(curr.left)\\n        \\n    return result\\n\\ndef postorderTraversal(root):\\n    stack, result = [root], []   \\n    while stack:\\n        curr = stack.pop()\\n        if curr:\\n            result.append(curr.val)\\n            stack.append(curr.left)\\n            stack.append(curr.right)\\n    return result[::-1]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```python\\n# Recursive and Iterative Solutions to inOrder, preOrder, and postOrder traversal\\n# ------------------------------------------- recursive\\n# recursive\\ndef BSTTraversal(root):\\n    res = []\\n    def inOrder(root):\\n        if root:\\n            inOrder(root.left)\\n            res.append(root.val)\\n            inOrder(root.right)\\n    \\n    def preOrder(root):\\n        if root:\\n            res.append(root.val)\\n            inOrder(root.left)\\n            inOrder(root.right)\\n    \\n    def postOrder(root):\\n        if root:\\n            inOrder(root.left)\\n            inOrder(root.right)\\n            res.append(root.val)\\n    \\n    inOrder(root)\\n    return res\\n\\n# one-liner recursive\\ndef traverse(root):\\n    return self.postorderTraversal(root.left)+self.postorderTraversal(root.right)+[root.val] if root else [] #post order\\n    # return self.postorderTraversal(root.left)+[root.val]+self.postorderTraversal(root.right) if root else [] #in order\\n    # return [root.val]+self.postorderTraversal(root.left)+self.postorderTraversal(root.right) if root else [] #pre order\\n\\n# ------------------------------------------- Iterative\\ndef inorderTraversal(self, root):\\n    stack, result = [], []   \\n    curr = root\\n    while curr or stack:\\n        while curr:\\n            stack.append(curr)\\n            curr = curr.left\\n        node = stack.pop()\\n        result.append(node.val)\\n        curr = node.right\\n        \\n    return result\\n\\ndef preorderTraversal(self, root):\\n    stack, result = [root], []   \\n    while stack:\\n        curr = stack.pop()\\n        if curr:\\n            result.append(curr.val)\\n            stack.append(curr.right)\\n            stack.append(curr.left)\\n        \\n    return result\\n\\ndef postorderTraversal(root):\\n    stack, result = [root], []   \\n    while stack:\\n        curr = stack.pop()\\n        if curr:\\n            result.append(curr.val)\\n            stack.append(curr.left)\\n            stack.append(curr.right)\\n    return result[::-1]",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1567642,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1567706,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1576752,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1571206,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1862741,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1750273,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1820685,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1566744,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1569462,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1565404,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1567642,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1567706,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1576752,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1571206,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1862741,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1750273,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1820685,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1566744,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1569462,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1565404,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1570174,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1905416,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1816158,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1574193,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1572684,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1869599,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1869367,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1570515,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 2026019,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1949066,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1809614,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 1751467,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 1574233,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 1572593,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 1574123,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 1573707,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 2068958,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 2049898,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 2033340,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 2013454,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 2007717,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1997329,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1977346,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1940711,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1919780,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1886680,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1879007,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1873868,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1863953,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1833518,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1799574,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1783048,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1767924,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1767523,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1762359,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1758368,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1757633,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1739648,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1735530,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1733493,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1728201,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1725903,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1719384,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1708956,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1706983,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1691789,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1691788,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1691142,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1672383,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1669371,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            }
        ]
    },
    {
        "title": "Transpose File",
        "question_content": "<p>Given a text file <code>file.txt</code>, transpose its content.</p>\n\n<p>You may assume that each row has the same number of columns, and each field is separated by the <code>&#39; &#39;</code> character.</p>\n\n<p><strong class=\"example\">Example:</strong></p>\n\n<p>If <code>file.txt</code> has the following content:</p>\n\n<pre>\nname age\nalice 21\nryan 30\n</pre>\n\n<p>Output the following:</p>\n\n<pre>\nname alice ryan\nage 21 30\n</pre>\n",
        "solutions": [
            {
                "id": 55502,
                "title": "ac-solution-using-awk-and-statement-just-like-c",
                "content": "Just feel free to use `for` and `if`.  \\nYou can append string easily, for example, `s = s a` to append `a` with `s`. \\n\\n\\n    awk '\\n    {\\n        for (i = 1; i <= NF; i++) {\\n            if(NR == 1) {\\n                s[i] = $i;\\n            } else {\\n                s[i] = s[i] \" \" $i;\\n            }\\n        }\\n    }\\n    END {\\n        for (i = 1; s[i] != \"\"; i++) {\\n            print s[i];\\n        }\\n    }' file.txt",
                "solutionTags": [],
                "code": "Just feel free to use `for` and `if`.  \\nYou can append string easily, for example, `s = s a` to append `a` with `s`. \\n\\n\\n    awk '\\n    {\\n        for (i = 1; i <= NF; i++) {\\n            if(NR == 1) {\\n                s[i] = $i;\\n            } else {\\n                s[i] = s[i] \" \" $i;\\n            }\\n        }\\n    }\\n    END {\\n        for (i = 1; s[i] != \"\"; i++) {\\n            print s[i];\\n        }\\n    }' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 111382,
                "title": "solution-using-awk-with-explanations",
                "content": "I would definitely recommend this tutorial: http://www.grymoire.com/Unix/Awk.html if you'd like to know more about GAWK/NAWK. Similar to `sed`, `awk` is used to perform complex editing tasks to streams of text. The main difference is that `awk` is more suitable for larger editing tasks (those that may need some programming language features).\\n\\nYou may have already seen `awk` solutions similar to the one presented below:\\n\\n```bash\\nawk '\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (FNR == 1) {\\n            t[i] = $i;\\n        } else {\\n            t[i] = t[i] \" \" $i\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; t[i] != \"\"; i++) {\\n        print t[i]\\n    }\\n}\\n' file.txt\\n```\\n\\nHere're some quick notes to help you understand:\\n\\n1. The code block with an \"END\" prefix is only executed after the last line is read; similarly, a code block with a \"BEGIN\" prefix will be executed before any line reads.\\n\\n2. AWK is line-based: the main code block (the code block without prefix) processes one line of input at a time.\\n\\n3. `NR`: a variable indicating the number of records (i.e. current line number) that's accumulated across multiple files read. `FNR` is similar to `NR`, but is reset for each file read. Since we only need to deal with one file in this question, either is fine to use.\\n\\n4. `NF`: a variable indicating the number of fields (i.e. number of \"columns\") on an input line.\\n\\n5. `$i`: the i-th field of the input line.\\n\\n6. `t[]`: an array for saving the transposed table. More on awk arrays here: http://www.grymoire.com/Unix/Awk.html#uh-22",
                "solutionTags": [],
                "code": "```bash\\nawk '\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (FNR == 1) {\\n            t[i] = $i;\\n        } else {\\n            t[i] = t[i] \" \" $i\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; t[i] != \"\"; i++) {\\n        print t[i]\\n    }\\n}\\n' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 657470,
                "title": "simple-0ms-no-awk-no-scripting-in-bash",
                "content": "```bash\\nhead -1 file.txt | wc -w | xargs seq 1 | xargs -I{} -n 1 sh -c \"cut -d \\' \\' -f{} file.txt | paste -sd \\' \\' -\"\\n```",
                "solutionTags": [],
                "code": "```bash\\nhead -1 file.txt | wc -w | xargs seq 1 | xargs -I{} -n 1 sh -c \"cut -d \\' \\' -f{} file.txt | paste -sd \\' \\' -\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 607685,
                "title": "the-real-intended-solution-using-pure-bash",
                "content": "```\\n#!/bin/bash\\npython3 -c \\'print(\"\\\\n\".join(map(\" \".join, zip(*(l.split() for l in open(\"file.txt\"))))))\\'",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\npython3 -c \\'print(\"\\\\n\".join(map(\" \".join, zip(*(l.split() for l in open(\"file.txt\"))))))\\'",
                "codeTag": "Python3"
            },
            {
                "id": 55501,
                "title": "simple-bash-solution-that-oj-hates",
                "content": "My solution in BASH. It works fine on my computer and I think it's conceptually straightforward. OJ complains exceeding memory.\\n\\n    ncol=`head -n1 file.txt | wc -w`\\n    \\n    for i in `seq 1 $ncol`\\n    do\\n        echo `cut -d' ' -f$i file.txt`\\n    done",
                "solutionTags": [],
                "code": "My solution in BASH. It works fine on my computer and I think it's conceptually straightforward. OJ complains exceeding memory.\\n\\n    ncol=`head -n1 file.txt | wc -w`\\n    \\n    for i in `seq 1 $ncol`\\n    do\\n        echo `cut -d' ' -f$i file.txt`\\n    done",
                "codeTag": "Unknown"
            },
            {
                "id": 373961,
                "title": "beat-99-4ms-single-line-awk-with-explain-pure-shell-ver-no-cat-awk-sed-etc",
                "content": "```\\nawk \\'{for(i=0;++i<=NF;)a[i]=a[i]?a[i] FS $i:$i}END{for(i=0;i++<NF;)print a[i]}\\' file.txt\\n```\\n\\nExplain:\\n```\\nfor(i=0;++i<=NF;)a[i]=a[i]?a[i] FS $i:$i\\n```\\n\\nLet\\'s talk it in C\\'s perspective.\\n* In `awk` ,`$i` is the i-th column of the line segmented by `Field Separator`(`FS`), \\n\\t\\twhich is internally defined as `FS=\" \"`.\\n\\t\\t`NF` = Number of Fields, how many pieces of the line we got after segmentation\\n* the expression in first `for` statement: \\n\\t\\t1) `?` is ternary operator as it does in C.\\n\\t\\t2) `a[i] FS $i` concatenates string `a[i]` and `FS` and `$i`\\n\\t\\t3) strings in array `a` *DO NOT* need to be declared, they\\'re `NULL` by default.\\n\\t\\t4) `NULL` logically equals to `FALSE`\\n\\t\\t5) obviously ternary operator has higher priority than variable assignment/concatenation\\n* So the whole expresion just transposed the content of input.\\n\\n`END` tells what to do after previous expression. As you see, `{for(i=0;i++<NF;)print a[i]}` just print them out.\\n\\nPure shell version:\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nfile=\"file.txt\"\\ndeclare -a tranctx\\nwhile read line; do\\n        IFS=\" \"\\n        j=0\\n        p=($line)\\n        while [ ! -z \"${p[$j]}\" ]; do\\n                tranctx[$j]=${tranctx[$j]}${p[$j]}$\\'\\\\n\\'\\n                ((++j))\\n        done\\n        IFS=$\\'\\\\n\\'\\ndone <$file\\n\\ni=0\\nwhile [ ! -z \"${tranctx[${i}]}\" ]; do\\n        echo ${tranctx[${i}]}\\n        ((++i))\\ndone\\n```\\nIt basically does same thing, but much more slower (**150ms**).",
                "solutionTags": [],
                "code": "```\\nawk \\'{for(i=0;++i<=NF;)a[i]=a[i]?a[i] FS $i:$i}END{for(i=0;i++<NF;)print a[i]}\\' file.txt\\n```\n```\\nfor(i=0;++i<=NF;)a[i]=a[i]?a[i] FS $i:$i\\n```\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nfile=\"file.txt\"\\ndeclare -a tranctx\\nwhile read line; do\\n        IFS=\" \"\\n        j=0\\n        p=($line)\\n        while [ ! -z \"${p[$j]}\" ]; do\\n                tranctx[$j]=${tranctx[$j]}${p[$j]}$\\'\\\\n\\'\\n                ((++j))\\n        done\\n        IFS=$\\'\\\\n\\'\\ndone <$file\\n\\ni=0\\nwhile [ ! -z \"${tranctx[${i}]}\" ]; do\\n        echo ${tranctx[${i}]}\\n        ((++i))\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55510,
                "title": "bash-sort-no-array-matrix",
                "content": "I print the words with coordinates `i` and `j`, then sort by `j` and `i`, then print in that order.\\n\\nInput:\\n```\\nname age\\nalice 21\\nryan 30\\n```\\nThe words with coordinates:\\n```\\n1 1 name\\n1 2 age\\n2 1 alice\\n2 2 21\\n3 1 ryan\\n3 2 30\\n```\\nSorted by `j` and `i`:\\n```\\n1 1 name\\n2 1 alice\\n3 1 ryan\\n1 2 age\\n2 2 21\\n3 2 30\\n```\\nFinal output:\\n```\\nname alice ryan\\nage 21 30\\n```\\nThe code:\\n```\\nm=`wc -l file.txt | cut -d' ' -f1`\\ni=0\\nwhile read line\\ndo\\n    let i++\\n    j=0\\n    for a in $line\\n    do\\n        let j++\\n        echo $i $j $a\\n    done\\ndone < file.txt | sort -n -k2 -k1 | while read i j a\\ndo\\n    if [ \"$i\" == \"$m\" ]\\n    then\\n        echo $a\\n    else\\n        echo -n \"$a \"\\n    fi\\ndone\\n```\\nIt's very slow, though, takes about 750 ms.",
                "solutionTags": [],
                "code": "```\\nname age\\nalice 21\\nryan 30\\n```\n```\\n1 1 name\\n1 2 age\\n2 1 alice\\n2 2 21\\n3 1 ryan\\n3 2 30\\n```\n```\\n1 1 name\\n2 1 alice\\n3 1 ryan\\n1 2 age\\n2 2 21\\n3 2 30\\n```\n```\\nname alice ryan\\nage 21 30\\n```\n```\\nm=`wc -l file.txt | cut -d' ' -f1`\\ni=0\\nwhile read line\\ndo\\n    let i++\\n    j=0\\n    for a in $line\\n    do\\n        let j++\\n        echo $i $j $a\\n    done\\ndone < file.txt | sort -n -k2 -k1 | while read i j a\\ndo\\n    if [ \"$i\" == \"$m\" ]\\n    then\\n        echo $a\\n    else\\n        echo -n \"$a \"\\n    fi\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55514,
                "title": "my-28ms-awk-solution",
                "content": "    # Read from the file file.txt and print its transposed content to stdout.\\n    \\n    # using awk for this purpose\\n    awk '\\n        {\\n            for(i=1; i<=NF; i++)\\n            {   \\n                if(line[i] == \"\")\\n                {\\n                    line[i] = $i\\n                }\\n                else\\n                {\\n                    line[i] = line[i]\" \"$i\\n                }\\n            }\\n        }\\n        END{\\n             for(i=1; i<=NF; i++)\\n             {\\n                 print line[i]\\n             }\\n           }\\n        ' file.txt",
                "solutionTags": [],
                "code": "    # Read from the file file.txt and print its transposed content to stdout.\\n    \\n    # using awk for this purpose\\n    awk '\\n        {\\n            for(i=1; i<=NF; i++)\\n            {   \\n                if(line[i] == \"\")\\n                {\\n                    line[i] = $i\\n                }\\n                else\\n                {\\n                    line[i] = line[i]\" \"$i\\n                }\\n            }\\n        }\\n        END{\\n             for(i=1; i<=NF; i++)\\n             {\\n                 print line[i]\\n             }\\n           }\\n        ' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 3218902,
                "title": "194-solution-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe problem is asking to transpose the content of a text file. The transpose operation is performed by converting rows to columns. For example, if we have a matrix, the transpose of the matrix is the operation of changing the rows of the matrix to columns.\\n\\nIn this case, we need to transpose the content of a text file, which means to swap the rows with columns, and print the resulting output.\\n\\nTo solve this problem, we can use the awk command in Unix. The awk command is a powerful tool for text processing, and it can be used to perform various operations on text files.\\n\\nLet\\'s break down the solution step by step:\\n\\n1. awk is a command for text processing, and it is used to extract and manipulate data from text files. We are using awk to perform the transpose operation on the content of a text file.\\n\\n2. We start with a for loop that reads the input file and stores the data in an array a. The NF variable in awk is the number of fields in the current record (or row), and the NR variable is the number of records (or rows) in the input file. The for loop reads each field in the row and stores it in the array a. The array a has two dimensions, where the first dimension is the column number, and the second dimension is the row number.\\n\\n3. After storing the data in the array a, we use another for loop to print the transposed data. We use the printf function to print the data in a formatted way. The printf function prints the data without adding a newline at the end, which is important for printing the transposed data.\\n\\n4. In the second for loop, we print the data in the transposed form. The loop iterates over each column first and then over each row. The printf function prints the data from the array a in a transposed form.\\n\\n5. The output of the one-liner is the transposed data of the input file.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nawk \\'{for (i=1; i<=NF; i++) {a[i,NR]=$i}} END {for (i=1; i<=NF; i++) {for (j=1; j<=NR; j++) {printf a[i,j]; if (j<NR) printf \" \"} printf \"\\\\n\"}}\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\nawk \\'{for (i=1; i<=NF; i++) {a[i,NR]=$i}} END {for (i=1; i<=NF; i++) {for (j=1; j<=NR; j++) {printf a[i,j]; if (j<NR) printf \" \"} printf \"\\\\n\"}}\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55522,
                "title": "ac-solution-8-lines-only-in-pure-bash",
                "content": "    while read -a line; do\\n        for ((i=0; i < \"${#line[@]}\"; i++)); do\\n            a[$i]=\"${a[$i]} ${line[$i]}\"\\n        done\\n    done < file.txt\\n    for ((i=0; i < ${#a[@]}; i++)); do\\n        echo ${a[i]}\\n    done",
                "solutionTags": [],
                "code": "    while read -a line; do\\n        for ((i=0; i < \"${#line[@]}\"; i++)); do\\n            a[$i]=\"${a[$i]} ${line[$i]}\"\\n        done\\n    done < file.txt\\n    for ((i=0; i < ${#a[@]}; i++)); do\\n        echo ${a[i]}\\n    done",
                "codeTag": "Unknown"
            },
            {
                "id": 55520,
                "title": "simple-solution-with-awk",
                "content": "Simple solution with awk using associative array\\n\\nawk '{ for(i=1; i<=NF; ++i) {if (word[i] == \"\") {word[i] = $i} else{word[i] = word[i]\" \"$i}}} END{for(i=1; i<=NF; ++i) {print word[i]}}' file.txt",
                "solutionTags": [],
                "code": "Simple solution with awk using associative array\\n\\nawk '{ for(i=1; i<=NF; ++i) {if (word[i] == \"\") {word[i] = $i} else{word[i] = word[i]\" \"$i}}} END{for(i=1; i<=NF; ++i) {print word[i]}}' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 55511,
                "title": "memory-limit-exceeded",
                "content": "    # Read from the file file.txt and print its transposed content to stdout.\\n    A=$(head -1 file.txt | tr ' ' '\\\\n' | wc -l)\\n    COUNTER=1\\n    while [  $COUNTER -le $A ]; do\\n    \\tawk -v temp=$COUNTER '{ printf(\"%s \", $temp) }' file.txt\\n    \\techo \"\"\\n    \\tlet COUNTER=COUNTER+1 \\n    done",
                "solutionTags": [],
                "code": "    # Read from the file file.txt and print its transposed content to stdout.\\n    A=$(head -1 file.txt | tr ' ' '\\\\n' | wc -l)\\n    COUNTER=1\\n    while [  $COUNTER -le $A ]; do\\n    \\tawk -v temp=$COUNTER '{ printf(\"%s \", $temp) }' file.txt\\n    \\techo \"\"\\n    \\tlet COUNTER=COUNTER+1 \\n    done",
                "codeTag": "Unknown"
            },
            {
                "id": 55524,
                "title": "building-matrix-with-awk",
                "content": "\\nI had to use \\n\\n - NF!=0 to remove any blank lines and  save rows and \\n - cols=NF to be used in END{} block.\\n\\n    awk 'NF!=0 {for(c=1;c<=NF;c++) mtx[NR,c]=$c; rows++; cols=NF;} END{for(c=1;c<=cols;c++) { line=mtx[1,c]; for(r=2;r<=rows;r++) { line=line\" \"mtx[r,c]}; print line; }}' file.txt",
                "solutionTags": [],
                "code": "\\nI had to use \\n\\n - NF!=0 to remove any blank lines and  save rows and \\n - cols=NF to be used in END{} block.\\n\\n    awk 'NF!=0 {for(c=1;c<=NF;c++) mtx[NR,c]=$c; rows++; cols=NF;} END{for(c=1;c<=cols;c++) { line=mtx[1,c]; for(r=2;r<=rows;r++) { line=line\" \"mtx[r,c]}; print line; }}' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 2722028,
                "title": "easy-solution",
                "content": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (FNR == 1) {\\n            t[i] = $i;\\n        } else {\\n            t[i] = t[i] \" \" $i\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; t[i] != \"\"; i++) {\\n        print t[i]\\n    }\\n}\\n\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (FNR == 1) {\\n            t[i] = $i;\\n        } else {\\n            t[i] = t[i] \" \" $i\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; t[i] != \"\"; i++) {\\n        print t[i]\\n    }\\n}\\n\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1399773,
                "title": "one-simple-solution",
                "content": "```\\nfor ((i = 1; ; i++)); do\\n    line=$(awk -vn=$i \\'{print $n}\\' file.txt)\\n    [[ $line ]] || break\\n    echo $line\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\nfor ((i = 1; ; i++)); do\\n    line=$(awk -vn=$i \\'{print $n}\\' file.txt)\\n    [[ $line ]] || break\\n    echo $line\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 261053,
                "title": "16ms-use-2-dimensions-array-of-awk-so-easy-to-understand",
                "content": "awk \\'{for(j=1;j<=NF;j++){data[NR,j]=$j;}} END {for(ii=1;ii<=NF;ii++){for(jj=1;jj<=NR;jj++){printf \"%s%c\", data[jj,ii],jj==NR?\"\\\\n\":\" \";}}}\\' file.txt",
                "solutionTags": [],
                "code": "awk \\'{for(j=1;j<=NF;j++){data[NR,j]=$j;}} END {for(ii=1;ii<=NF;ii++){for(jj=1;jj<=NR;jj++){printf \"%s%c\", data[jj,ii],jj==NR?\"\\\\n\":\" \";}}}\\' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 1482122,
                "title": "one-liner-4ms",
                "content": "Using xargs, one liner (kinda),\\n**awk**ward shell substitution to avoid creating a variable.\\n\\n```\\nseq \"$(awk \\'{print NF}\\' file.txt | head -n 1)\" |\\n\\txargs -r -I {} sh -c \"awk \\'{print \\\\${}}\\' file.txt | xargs -r\"\\n```",
                "solutionTags": [],
                "code": "```\\nseq \"$(awk \\'{print NF}\\' file.txt | head -n 1)\" |\\n\\txargs -r -I {} sh -c \"awk \\'{print \\\\${}}\\' file.txt | xargs -r\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1185158,
                "title": "solution-using-awk-beats-100-of-submissions-0ms-solution",
                "content": "I would definitely recommend this tutorial: http://www.grymoire.com/Unix/Awk.html if you\\'d like to know more about GAWK/NAWK. Similar to sed, awk is used to perform complex editing tasks to streams of text. The main difference is that awk is more suitable for larger editing tasks (those that may need some programming language features).\\n\\nSolution :\\n```\\nwordcount=$(head -1 file.txt | wc -w)\\ncol_n=1\\nwhile [[ $col_n -le $wordcount ]]; do\\n\\tawk \"{ print \\\\$$col_n }\" file.txt | paste -sd \" \"\\n\\tcol_n=$((col_n + 1))\\ndone\\n```\\n\\nHere\\'re some quick notes to help you understand:\\n\\nThe code block with an \"END\" prefix is only executed after the last line is read; similarly, a code block with a \"BEGIN\" prefix will be executed before any line reads.\\n\\nAWK is line-based: the main code block (the code block without prefix) processes one line of input at a time.",
                "solutionTags": [],
                "code": "```\\nwordcount=$(head -1 file.txt | wc -w)\\ncol_n=1\\nwhile [[ $col_n -le $wordcount ]]; do\\n\\tawk \"{ print \\\\$$col_n }\" file.txt | paste -sd \" \"\\n\\tcol_n=$((col_n + 1))\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1014550,
                "title": "here-is-my-simple-solution",
                "content": "```\\nnum_row=$(head -1 file.txt | wc -w)\\ni=1;\\nwhile [[ $i -le $num_row ]] ; do\\n#Print the ith column of each row and join together\\nawk \"{print \\\\$$i}\" file.txt | paste -s -d \\' \\';\\n((i=$i+1))\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\nnum_row=$(head -1 file.txt | wc -w)\\ni=1;\\nwhile [[ $i -le $num_row ]] ; do\\n#Print the ith column of each row and join together\\nawk \"{print \\\\$$i}\" file.txt | paste -s -d \\' \\';\\n((i=$i+1))\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 816087,
                "title": "simple-4-line-answer",
                "content": "```\\nncols=`head -n1 file.txt | wc -w`\\nfor i in `seq 1 $ncols`; do\\n    cat file.txt | awk \"{ print \\\\$$i }\" | xargs\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\nncols=`head -n1 file.txt | wc -w`\\nfor i in `seq 1 $ncols`; do\\n    cat file.txt | awk \"{ print \\\\$$i }\" | xargs\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55512,
                "title": "solution-using-associative-array-transpose-file",
                "content": "    # Read from the file file.txt and print its transposed content to stdout.\\n    #!/bin/bash\\n    \\n    declare -A matrix\\n    col=1\\n    row=1\\n    \\n    while read line; do\\n        col=1\\n        for word in $line; do\\n                matrix[$row,$col]=$word\\n                ((col++))\\n        done\\n        ((row++))\\n    done < file.txt\\n    \\n    for ((i=1;i<col;i++)) do\\n        echo -n ${matrix[1,$i]} \\n        for((j=2;j<row;j++)) do\\n                echo -n ' '${matrix[$j,$i]}\\n        done\\n        echo\\n    done",
                "solutionTags": [],
                "code": "    # Read from the file file.txt and print its transposed content to stdout.\\n    #!/bin/bash\\n    \\n    declare -A matrix\\n    col=1\\n    row=1\\n    \\n    while read line; do\\n        col=1\\n        for word in $line; do\\n                matrix[$row,$col]=$word\\n                ((col++))\\n        done\\n        ((row++))\\n    done < file.txt\\n    \\n    for ((i=1;i<col;i++)) do\\n        echo -n ${matrix[1,$i]} \\n        for((j=2;j<row;j++)) do\\n                echo -n ' '${matrix[$j,$i]}\\n        done\\n        echo\\n    done",
                "codeTag": "Unknown"
            },
            {
                "id": 2729918,
                "title": "cut-tr",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAll lines have same number of columns. So we may iterate  by columns.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGet number of columns and itterate over it, by getting coumn via `cut`\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfor i in $(seq $(head -1 file.txt | tr \\' \\' \\'\\\\n\\' | wc -l) ); do\\n  line=$(cut -f $i -d \\' \\' file.txt | tr \\'\\\\n\\' \\' \\')\\n  echo ${line%% }\\ndone \\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nfor i in $(seq $(head -1 file.txt | tr \\' \\' \\'\\\\n\\' | wc -l) ); do\\n  line=$(cut -f $i -d \\' \\' file.txt | tr \\'\\\\n\\' \\' \\')\\n  echo ${line%% }\\ndone \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2184394,
                "title": "for-loop-one-liner-with-cut",
                "content": "Using word count to return number of columns, and printing each column with cut.\\n```\\nfor i in $(seq 1 $(head -n1 file.txt | wc -w)); do echo $(cut -d\\' \\' -f$i file.txt); done\\n```",
                "solutionTags": [],
                "code": "```\\nfor i in $(seq 1 $(head -n1 file.txt | wc -w)); do echo $(cut -d\\' \\' -f$i file.txt); done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 747876,
                "title": "very-simple-count-columns-and-awk-4-lines",
                "content": "```\\nnum_columns=$(head -n 1 file.txt | wc | awk \\'{print $2}\\')\\nfor i in `seq 1 $num_columns`; do\\n  awk -v i=$i \\'{print $i}\\' file.txt | xargs echo\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\nnum_columns=$(head -n 1 file.txt | wc | awk \\'{print $2}\\')\\nfor i in `seq 1 $num_columns`; do\\n  awk -v i=$i \\'{print $i}\\' file.txt | xargs echo\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 559802,
                "title": "bash-two-solutions-awk-bash",
                "content": "The first solution is to use `awk` in which we define an arrary whose `i`th element represents the `i`th column of the input. \\n\\nImplementation (8ms, 81.24%): \\n```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        s[i] = s[i]?s[i] FS $i:$i\\n    }\\n}\\nEND {\\n    for (i in s) {\\n        print s[i]\\n    }\\n}\\' file.txt\\n```\\n\\nThe 2nd solution is to use pure bash in which we define array `arr` whose `i`th element stores the `i`th column of input. \\n\\nImplementation (144ms, 5.16%): \\n```\\ndeclare -a arr\\n\\nwhile IFS= read -r line\\ndo\\n    i=0\\n    for word in $line\\n    do\\n        [[ ${arr[$i]} ]] && arr[$i]=\"${arr[$i]} $word\" || arr[$i]=$word\\n        ((i++))\\n    done\\ndone < file.txt\\n\\nfor ((i=0; i < ${#arr[@]}; i++))\\ndo\\n    echo ${arr[i]}\\ndone\\n```\\n\\nClearly the 1st solution is superior since it is dramtically faster and shorter. Here, bash has an unpleasant fact that in range-based for loop an element with more than one word would be displayed in many lines, e.g.  \\n\\n```\\narr=(apple \"passion fruit\" banana)\\n\\nfor ele in ${arr[@]}\\ndo\\n    echo $ele\\ndone\\n```\\noutputs below in which `passion` and `fruit` are on two lines. \\n```\\napple\\npassion\\nfruit\\nbanana\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        s[i] = s[i]?s[i] FS $i:$i\\n    }\\n}\\nEND {\\n    for (i in s) {\\n        print s[i]\\n    }\\n}\\' file.txt\\n```\n```\\ndeclare -a arr\\n\\nwhile IFS= read -r line\\ndo\\n    i=0\\n    for word in $line\\n    do\\n        [[ ${arr[$i]} ]] && arr[$i]=\"${arr[$i]} $word\" || arr[$i]=$word\\n        ((i++))\\n    done\\ndone < file.txt\\n\\nfor ((i=0; i < ${#arr[@]}; i++))\\ndo\\n    echo ${arr[i]}\\ndone\\n```\n```\\narr=(apple \"passion fruit\" banana)\\n\\nfor ele in ${arr[@]}\\ndo\\n    echo $ele\\ndone\\n```\n```\\napple\\npassion\\nfruit\\nbanana\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 257710,
                "title": "one-line-ac-bash-but-runs-slow",
                "content": "\\n```\\ni=0 && for item in `head -1 file.txt `; do let i++; cut -d \\' \\' -f $i file.txt | xargs; done\\n```",
                "solutionTags": [],
                "code": "```\\ni=0 && for item in `head -1 file.txt `; do let i++; cut -d \\' \\' -f $i file.txt | xargs; done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55515,
                "title": "my-24ms-unreadable-solution",
                "content": "    #! /bin/bash\\n    export LC_ALL=C\\n    col_num=$(awk -F' ' 'NR==1{print NF}' file.txt)\\n    awk -F' ' -v n_col=$col_num 'BEGIN{for(i=1;i<=n_col;++i) line[i]=\"\"}{for(i=1;i<=NF;++i){line[i]=sprintf(\"%s %s\", line[i], $i)}}END{for(i=1;i<=n_col;++i) print line[i]}'  file.txt | sed \"s;^ ;;g\"",
                "solutionTags": [],
                "code": "    #! /bin/bash\\n    export LC_ALL=C\\n    col_num=$(awk -F' ' 'NR==1{print NF}' file.txt)\\n    awk -F' ' -v n_col=$col_num 'BEGIN{for(i=1;i<=n_col;++i) line[i]=\"\"}{for(i=1;i<=NF;++i){line[i]=sprintf(\"%s %s\", line[i], $i)}}END{for(i=1;i<=n_col;++i) print line[i]}'  file.txt | sed \"s;^ ;;g\"",
                "codeTag": "Unknown"
            },
            {
                "id": 3006832,
                "title": "awk-command",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved by reading the input file line by line, and storing the values in each column in an array. Then, the transposed content can be printed by iterating through the array and printing the values stored in each element.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne approach to this problem is to use the awk command to read the input file and store the values in an array. awk is a programming language designed for text processing, which makes it well-suited for this task.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThis will depend on the implementation of awk and the size of the file. In general, the time complexity of awk is linear with respect to the size of the input.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThis will also depend on the implementation of awk and the size of the file. In general, the space complexity of awk is linear with respect to the size of the input.\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (NR == 1) {\\n            s[i] = $i;\\n        } else {\\n            s[i] = s[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; s[i] != \"\"; i++) {\\n        print s[i];\\n    }\\n}\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (NR == 1) {\\n            s[i] = $i;\\n        } else {\\n            s[i] = s[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; s[i] != \"\"; i++) {\\n        print s[i];\\n    }\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1363331,
                "title": "easy-solution-use-awk-and-cut",
                "content": "```\\n#!/bin/bash\\n\\nc=$(cat file.txt | awk -F\\' \\' END\\'{print NF}\\');\\n\\nfor i in $(seq 1 $c);\\ndo\\n        k=$(cut -d\\' \\' -f $i file.txt);\\n        echo $k;\\ndone\\n```\\n",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\n\\nc=$(cat file.txt | awk -F\\' \\' END\\'{print NF}\\');\\n\\nfor i in $(seq 1 $c);\\ndo\\n        k=$(cut -d\\' \\' -f $i file.txt);\\n        echo $k;\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1269297,
                "title": "pure-bash-solution",
                "content": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\ndeclare -A transposed\\nnrows=0\\nncols=0\\nwhile read -r -a row; do\\n    for ((i = 0; i < ${#row[@]}; i++)); do\\n        transposed[$i,$nrows]=${row[i]}\\n    done\\n    ((nrows++))\\n    ncols=${#row[@]}\\ndone < file.txt\\n\\nfor ((r = 0; r < ncols; r++)); do\\n    sep=\\n    for ((c = 0; c < nrows; c++)); do\\n        printf \\'%s%s\\' \"$sep\" \"${transposed[$r,$c]}\"\\n        sep=\" \"\\n    done\\n    printf \\'\\\\n\\'\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\ndeclare -A transposed\\nnrows=0\\nncols=0\\nwhile read -r -a row; do\\n    for ((i = 0; i < ${#row[@]}; i++)); do\\n        transposed[$i,$nrows]=${row[i]}\\n    done\\n    ((nrows++))\\n    ncols=${#row[@]}\\ndone < file.txt\\n\\nfor ((r = 0; r < ncols; r++)); do\\n    sep=\\n    for ((c = 0; c < nrows; c++)); do\\n        printf \\'%s%s\\' \"$sep\" \"${transposed[$r,$c]}\"\\n        sep=\" \"\\n    done\\n    printf \\'\\\\n\\'\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1187882,
                "title": "awk-using-nf-and-nr",
                "content": "```\\nawk \\'{\\n    for (i=1; i<=NF; ++i) {\\n        if (NR==1) s[i] = $i;\\n        else s[i] = s[i] \" \" $i;}\\n} \\nEND {\\n    for (i=1; i<=NF ; ++i)\\n        print s[i];\\n}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{\\n    for (i=1; i<=NF; ++i) {\\n        if (NR==1) s[i] = $i;\\n        else s[i] = s[i] \" \" $i;}\\n} \\nEND {\\n    for (i=1; i<=NF ; ++i)\\n        print s[i];\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 699640,
                "title": "awk-simple-solution",
                "content": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nNUM_FIELDS=`cat file.txt | head -1 | awk \\'{ print NF}\\'`\\n\\nlet count=1\\nwhile [ $count -le $NUM_FIELDS ]; do\\n    result=`cat file.txt | awk -v x=$count \\'{print $x}\\'`\\n    echo $result\\n\\nlet count+=1\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nNUM_FIELDS=`cat file.txt | head -1 | awk \\'{ print NF}\\'`\\n\\nlet count=1\\nwhile [ $count -le $NUM_FIELDS ]; do\\n    result=`cat file.txt | awk -v x=$count \\'{print $x}\\'`\\n    echo $result\\n\\nlet count+=1\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 697637,
                "title": "horrible-perl-solution-nice-ruby-solution",
                "content": "I originally tried to solve this with a ruby oneliner, but ruby\\'s not on the system. Here\\'s my perl solution (I am not a perl coder, this is basically my best attempt to translate my ruby version below):\\n\\n```\\ncat file.txt | perl -ne \\'\\n    BEGIN {\\n        use strict;\\n        use warnings;\\n        my @in_lines = [];\\n    };\\n    push(@in_lines, [split(\" \", $_)]);\\n    END {\\n        $outer_len = @in_lines;\\n        $inner_len = @{$in_lines[0]};\\n        for (my $inner_index = 0; $inner_index < $inner_len; $inner_index++) {\\n            $first = 1;\\n            for (my $outer_index = 0; $outer_index < $outer_len; $outer_index++) {\\n                if ($first) { $first = 0; } else { print(\" \"); }\\n                print($in_lines[$outer_index]->[$inner_index]);\\n            }\\n            print(\"\\\\n\");\\n        }\\n    }\\'\\n```\\n\\nHere\\'s my ruby solution (which I think is nice):\\n```\\ncat file.txt | ruby -ne \\'\\n    BEGIN { lines = []; }\\n    lines << $_.split(\" \");\\n    END { puts lines.transpose.map { |sub| sub.join(\" \")}; }\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | perl -ne \\'\\n    BEGIN {\\n        use strict;\\n        use warnings;\\n        my @in_lines = [];\\n    };\\n    push(@in_lines, [split(\" \", $_)]);\\n    END {\\n        $outer_len = @in_lines;\\n        $inner_len = @{$in_lines[0]};\\n        for (my $inner_index = 0; $inner_index < $inner_len; $inner_index++) {\\n            $first = 1;\\n            for (my $outer_index = 0; $outer_index < $outer_len; $outer_index++) {\\n                if ($first) { $first = 0; } else { print(\" \"); }\\n                print($in_lines[$outer_index]->[$inner_index]);\\n            }\\n            print(\"\\\\n\");\\n        }\\n    }\\'\\n```\n```\\ncat file.txt | ruby -ne \\'\\n    BEGIN { lines = []; }\\n    lines << $_.split(\" \");\\n    END { puts lines.transpose.map { |sub| sub.join(\" \")}; }\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 634826,
                "title": "similar-to-solution-using-awk-jut-the-for-loop-is-simple",
                "content": "```\\nawk \\'{ for (i=1; i<=NF; i++) {\\n            if (NR==1) s[i]=$i; \\n            else s[i] = s[i] \" \" $i;\\n        }\\n     } END { for (i in s) print s[i] }\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{ for (i=1; i<=NF; i++) {\\n            if (NR==1) s[i]=$i; \\n            else s[i] = s[i] \" \" $i;\\n        }\\n     } END { for (i in s) print s[i] }\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 604975,
                "title": "script-using-awk",
                "content": "```\\nnumColumns=`head -1 file.txt | awk \\'{print NF}\\'`\\ni=1\\nwhile [ $i -le $numColumns ]\\ndo\\nawk -v ind=$i \\'{print $ind}\\' file.txt | xargs\\ni=`expr $i + 1`\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\nnumColumns=`head -1 file.txt | awk \\'{print NF}\\'`\\ni=1\\nwhile [ $i -le $numColumns ]\\ndo\\nawk -v ind=$i \\'{print $ind}\\' file.txt | xargs\\ni=`expr $i + 1`\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 561434,
                "title": "simple-fast-readable-awk-solution-4ms-3-5mb",
                "content": "I spent way too long getting the hang of `awk` to make this happen.\\n\\nopted for concatenating each column into its own string, separated by a space.\\n\\n```\\ncat file.txt | awk \\'\\n{\\n    for(i=1; i <= NF; i++){\\n        data[i] = ((i in data) ? data[i] \" \" : \"\") $i\\n    }\\n} END {\\n    for(i in data){\\n        print data[i]\\n    }\\n}\\'\\n```\\n\\nI think this should work even on variable number of columns.",
                "solutionTags": [],
                "code": "```\\ncat file.txt | awk \\'\\n{\\n    for(i=1; i <= NF; i++){\\n        data[i] = ((i in data) ? data[i] \" \" : \"\") $i\\n    }\\n} END {\\n    for(i in data){\\n        print data[i]\\n    }\\n}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520760,
                "title": "awk-solution-use-array",
                "content": "```\\ncat file.txt | awk \\'BEGIN{fs=ofs=\" \";dic[0] = 0;count=0}{for(i=1;i<=NF;i+=1){if(length(dic[i])==0){dic[i]=$i}else{dic[i]=dic[i]\" \"$i}}; count=NF}END{for(i=1;i<=count;i+=1){print dic[i]}}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | awk \\'BEGIN{fs=ofs=\" \";dic[0] = 0;count=0}{for(i=1;i<=NF;i+=1){if(length(dic[i])==0){dic[i]=$i}else{dic[i]=dic[i]\" \"$i}}; count=NF}END{for(i=1;i<=count;i+=1){print dic[i]}}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 417403,
                "title": "nice-and-easy",
                "content": "```\\ncol=\"$(head -1 file.txt | wc -w)\"\\n\\nfor i in $(seq 1 $col);do awk \\'{ print $\\'$i\\' }\\' file.txt | paste -s -d\" \";done\\n```",
                "solutionTags": [],
                "code": "```\\ncol=\"$(head -1 file.txt | wc -w)\"\\n\\nfor i in $(seq 1 $col);do awk \\'{ print $\\'$i\\' }\\' file.txt | paste -s -d\" \";done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 316934,
                "title": "simple-awk-solution",
                "content": "```\\nawk \\' { for (i = 1; i <= NF; ++i)  if (NR == 1) cols[i] = $i;  else  cols[i] =  cols[i] \" \" $i } END { for (i in cols) print cols[i]}\\' file.txt \\n```",
                "solutionTags": [],
                "code": "```\\nawk \\' { for (i = 1; i <= NF; ++i)  if (NR == 1) cols[i] = $i;  else  cols[i] =  cols[i] \" \" $i } END { for (i in cols) print cols[i]}\\' file.txt \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 227458,
                "title": "using-awk",
                "content": "```\\nawk \\'\\n{ \\n    for (i=1; i<=NF; i++)  {\\n        a[NR,i] = $i\\n    }\\n}\\nNF>p { p = NF }\\nEND {    \\n    for(j=1; j<=p; j++) {\\n        str=a[1,j]\\n        for(i=2; i<=NR; i++){\\n            str=str\" \"a[i,j];\\n        }\\n        print str\\n    }\\n}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{ \\n    for (i=1; i<=NF; i++)  {\\n        a[NR,i] = $i\\n    }\\n}\\nNF>p { p = NF }\\nEND {    \\n    for(j=1; j<=p; j++) {\\n        str=a[1,j]\\n        for(i=2; i<=NR; i++){\\n            str=str\" \"a[i,j];\\n        }\\n        print str\\n    }\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 193762,
                "title": "solution-with-perl",
                "content": "Actually Perl is allowed.\\n```\\nperl -e \\'$i=0;while(<>){$j=0;foreach(split){$file[$i][$j]=$_;$j++;}$i++;}foreach $jj (0..$j-1){\\nforeach $ii (0..$i-1){$output.=$file[$ii][$jj];$output.=$ii==$i-1?\"\":\" \";}$output.=\"\\\\n\";}\\nprint $output;\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nperl -e \\'$i=0;while(<>){$j=0;foreach(split){$file[$i][$j]=$_;$j++;}$i++;}foreach $jj (0..$j-1){\\nforeach $ii (0..$i-1){$output.=$file[$ii][$jj];$output.=$ii==$i-1?\"\":\" \";}$output.=\"\\\\n\";}\\nprint $output;\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55504,
                "title": "ac-solution-using-python3",
                "content": "just share my simple solution\\n```\\npython3 <<EOF\\nmatrix = [line[:-1].split(' ') for line in open('file.txt')]\\nfor column in range(len(matrix[0])):\\n    print(*(matrix[row][column] for row in range(len(matrix))))\\nEOF\\n```\\n`<<EOF` is really a helpful syntax",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\npython3 <<EOF\\nmatrix = [line[:-1].split(' ') for line in open('file.txt')]\\nfor column in range(len(matrix[0])):\\n    print(*(matrix[row][column] for row in range(len(matrix))))\\nEOF\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4092401,
                "title": "jidejj",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\n#!/bin/bash\\n\\n# Define the input file\\ninput_file=\"file.txt\"\\n\\n# Check if the file exists\\nif [ ! -f \"$input_file\" ]; then\\n    echo \"File not found: $input_file\"\\n    exit 1\\nfi\\n\\n# Use awk to transpose the file content\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (NR == 1) {\\n            rows[i] = $i;\\n        } else {\\n            rows[i] = rows[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; i <= NF; i++) {\\n        print rows[i];\\n    }\\n}\\n\\' \"$input_file\"\\n                                \\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n#!/bin/bash\\n\\n# Define the input file\\ninput_file=\"file.txt\"\\n\\n# Check if the file exists\\nif [ ! -f \"$input_file\" ]; then\\n    echo \"File not found: $input_file\"\\n    exit 1\\nfi\\n\\n# Use awk to transpose the file content\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (NR == 1) {\\n            rows[i] = $i;\\n        } else {\\n            rows[i] = rows[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; i <= NF; i++) {\\n        print rows[i];\\n    }\\n}\\n\\' \"$input_file\"\\n                                \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4017176,
                "title": "awk-gets-the-job-done",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen approaching this problem, the first thing that comes to mind is finding a way to swap the rows and columns of the file content. To achieve this, we need to think about how to read the file and store its content in a way that allows for easy transposition. We can then output the transposed content to the console or another file.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we will use the `awk` command-line utility, which is a powerful tool for text processing.\\n\\nIn the code, we start by defining an awk script enclosed in single quotes. The script consists of two parts: the main code block and the `END` block.\\n\\nIn the main code block, we iterate over each line of the input file using the default behavior of awk. For each line, we use a for loop to iterate over the fields `$i` separated by whitespace. We then store each field in the array `a` with the column index `i` and the row index `NR`, which represents the current line number.\\n\\nAfter processing all the lines, we move to the `END` block. Here, we iterate over the array `a` by nested for loops. The outer loop iterates over the columns `i`, and the inner loop iterates over the rows `j`. We use the `printf` statement to print the transposed content by accessing the elements of the array with the indices `a[i, j]`. We add the appropriate separators (`RS` for the end of a row and `FS` for the space between elements) to format the output correctly.\\n\\nFinally, we execute the `awk` command by passing the input file `file.txt` as an argument. The transposed content is then printed to the standard output `stdout`.\\n\\nUsing `awk` allows us to efficiently read and process the file, store the content in an array, and print the transposed result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$, where $$n$$ represents the total number of elements in the input file. This is because we need to iterate over each line and each field in the file to store them in the array. The nested loops in the `END` block also contribute to the linear time complexity.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ because we need to store the content of the input file in the array `a`. The size of the array depends on the number of elements in the file, which is directly proportional to the space complexity. The additional space used by variables and temporary storage is negligible compared to the size of the input file.\\n# Runtime & Memory\\n![Screenshot 2023-09-08 at 11.52.36.png](https://assets.leetcode.com/users/images/f72741b1-5778-47f3-b2f9-eebced5848af_1694156608.758566.png)\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        a[i, NR] = $i\\n    }\\n}\\nEND {\\n    for (i = 1; i <= NF; i++) {\\n        for (j = 1; j <= NR; j++) {\\n            printf \"%s%s\", a[i, j], (j == NR ? RS : FS)\\n        }\\n    }\\n}\\n\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        a[i, NR] = $i\\n    }\\n}\\nEND {\\n    for (i = 1; i <= NF; i++) {\\n        for (j = 1; j <= NR; j++) {\\n            printf \"%s%s\", a[i, j], (j == NR ? RS : FS)\\n        }\\n    }\\n}\\n\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938515,
                "title": "perl-solution",
                "content": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\nperl <<\\'EOF\\' - file.txt\\n    my @rows;\\n    while (<>) {\\n        my @words = split /\\\\s+/;\\n        foreach my $i (0 .. $#words) {\\n            push @{$rows[$i]}, $words[$i];\\n        }\\n    }\\n    print join(\\' \\' => @$_), \"\\\\n\" for (@rows)\\nEOF\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\nperl <<\\'EOF\\' - file.txt\\n    my @rows;\\n    while (<>) {\\n        my @words = split /\\\\s+/;\\n        foreach my $i (0 .. $#words) {\\n            push @{$rows[$i]}, $words[$i];\\n        }\\n    }\\n    print join(\\' \\' => @$_), \"\\\\n\" for (@rows)\\nEOF\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3919684,
                "title": "bash-no-awk-just-bash-arrays",
                "content": "The best performimg solution to this problem use `awk`, but I wanted to see if I could to this using bash arrays instead.\\n\\nIt possible, but it\\'s not pretty...\\n\\n# Code\\n```\\ninput=\"file.txt\"\\ndeclare -a lines=()\\n\\nrows=$((0))\\n\\n# Read the input into an array\\n# bash does not seem to support 2D arrays\\n# so it\\'s just 1D\\nwhile IFS=\\' \\' read -a line\\ndo\\n  columns=${#line[@]}\\n  rows=$(($rows + 1))\\n  lines=(${lines[@]} ${line[@]})\\ndone < \"$input\"\\n\\n\\n# Index into the array to transpose it\\n# building output line by line\\nfor ((c = 0; c < $columns; c++ ))\\ndo\\n  line=${lines[$c]}\\n  for ((r = 1; r < $rows; r++)) do\\n    line=\"$line ${lines[$(($c + $r * $columns))]}\"\\n  done\\n  echo $line\\ndone\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ninput=\"file.txt\"\\ndeclare -a lines=()\\n\\nrows=$((0))\\n\\n# Read the input into an array\\n# bash does not seem to support 2D arrays\\n# so it\\'s just 1D\\nwhile IFS=\\' \\' read -a line\\ndo\\n  columns=${#line[@]}\\n  rows=$(($rows + 1))\\n  lines=(${lines[@]} ${line[@]})\\ndone < \"$input\"\\n\\n\\n# Index into the array to transpose it\\n# building output line by line\\nfor ((c = 0; c < $columns; c++ ))\\ndo\\n  line=${lines[$c]}\\n  for ((r = 1; r < $rows; r++)) do\\n    line=\"$line ${lines[$(($c + $r * $columns))]}\"\\n  done\\n  echo $line\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3807270,
                "title": "bash-awk",
                "content": "```\\n#!/bin/bash\\n\\nawk \\'\\n{\\n    # loop over words in curr line\\n    for (i = 1; i <= NF; i++) {\\n        # if first line\\n        if(NR == 1) {\\n            # init array ans[i] with first word of each line\\n            ans[i] = $i;\\n        } else {\\n            # append words to ans[i]\\n            ans[i] = ans[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    # print ans array\\n    for (i = 1; ans[i] != \"\"; i++) {\\n        print ans[i];\\n    }\\n}\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n#!/bin/bash\\n\\nawk \\'\\n{\\n    # loop over words in curr line\\n    for (i = 1; i <= NF; i++) {\\n        # if first line\\n        if(NR == 1) {\\n            # init array ans[i] with first word of each line\\n            ans[i] = $i;\\n        } else {\\n            # append words to ans[i]\\n            ans[i] = ans[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    # print ans array\\n    for (i = 1; ans[i] != \"\"; i++) {\\n        print ans[i];\\n    }\\n}\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3713407,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nseq 1 $(head -1 file.txt | wc -w) | xargs -I \\'{}\\' bash -c \"cut -d \\'\"\\' \\'\"\\' -f {} file.txt| xargs\"\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nseq 1 $(head -1 file.txt | wc -w) | xargs -I \\'{}\\' bash -c \"cut -d \\'\"\\' \\'\"\\' -f {} file.txt| xargs\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3598971,
                "title": "solution-using-loop-bash-hyder-nabi",
                "content": "# Complexity \\nM: No of Lines\\nN: No of Words in each Line\\n- Time complexity: $$O(M*N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M*N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\nfile=\"file.txt\"\\nwhile read line; do\\n\\tIFS=\\' \\' read -ra Arr <<< \"$line\";\\n\\tfor j in ${!Arr[@]}; do\\n\\t\\tmat[j]+=\" ${Arr[j]}\";\\n\\tdone\\t\\ndone < $file;\\n\\nfor i in ${!mat[@]}; do\\n\\techo ${mat[i]};\\ndone;\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\nfile=\"file.txt\"\\nwhile read line; do\\n\\tIFS=\\' \\' read -ra Arr <<< \"$line\";\\n\\tfor j in ${!Arr[@]}; do\\n\\t\\tmat[j]+=\" ${Arr[j]}\";\\n\\tdone\\t\\ndone < $file;\\n\\nfor i in ${!mat[@]}; do\\n\\techo ${mat[i]};\\ndone;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514033,
                "title": "awk-please-don-t-roast-my-bash-i-am-python-noob-arch-linux-sheesh",
                "content": "# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nThis script uses awk to read the input file and transpose its content. It maintains an array transposed where each element represents a column in the transposed output. For each row, it appends the corresponding fields to the respective column in the transposed array. Finally, it prints the transposed content.\\r\\n\\r\\nThis approach is more efficient for larger inputs compared to reading the file into an array in Bash. It leverages the power of awk for handling large datasets efficiently.\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n$$O(NM)$$\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n$$O(N)$$\\r\\n# Code\\r\\n```\\r\\n#!/bin/bash\\r\\n\\r\\n# Use awk to transpose the content\\r\\nawk \\'\\r\\n{\\r\\n    for (i=1; i<=NF; i++) {\\r\\n        if (NR == 1) {\\r\\n            # For the first row, create an array with the fields as columns\\r\\n            transposed[i] = $i\\r\\n        } else {\\r\\n            # For subsequent rows, append the fields to the corresponding column\\r\\n            transposed[i] = transposed[i] \" \" $i\\r\\n        }\\r\\n    }\\r\\n}\\r\\nEND {\\r\\n    # Print the transposed content\\r\\n    for (i=1; i<=NF; i++) {\\r\\n        print transposed[i]\\r\\n    }\\r\\n}\\' file.txt\\r\\n\\r\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\r\\n#!/bin/bash\\r\\n\\r\\n# Use awk to transpose the content\\r\\nawk \\'\\r\\n{\\r\\n    for (i=1; i<=NF; i++) {\\r\\n        if (NR == 1) {\\r\\n            # For the first row, create an array with the fields as columns\\r\\n            transposed[i] = $i\\r\\n        } else {\\r\\n            # For subsequent rows, append the fields to the corresponding column\\r\\n            transposed[i] = transposed[i] \" \" $i\\r\\n        }\\r\\n    }\\r\\n}\\r\\nEND {\\r\\n    # Print the transposed content\\r\\n    for (i=1; i<=NF; i++) {\\r\\n        print transposed[i]\\r\\n    }\\r\\n}\\' file.txt\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420456,
                "title": "bash-command-concise-code-steps-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. This script uses awk, a text processing tool, to read the contents of the file and transpose them. Here\\'s how it works:\\n\\n2. For each field in each row of the input file, it stores the field in an array a with indices i (column) and NR (row number).\\n\\n3. After reading the entire file, it loops over the columns and rows of the array a, printing each element separated by a space. When it reaches the end of a row, it prints a newline character.\\n\\n\\n# Complexity\\n\\n1. Reading the file into a 2D array takes O(NM) time and O(NM) space, where N is the number of rows in the file, M is the number of columns in the file, and we assume that each field is of constant length.\\n\\n2. Transposing the array takes O(NM) time and O(NM) space, since we are constructing a new 2D array with dimensions M x N.\\n\\n3. Printing the transposed array takes O(N*M) time and O(1) space, since we are just printing each element once.\\n- Time complexity: O(NM)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(NM)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'{for (i=1; i<=NF; i++) {a[i,NR]=$i}} END {for (i=1; i<=NF; i++) {for (j=1; j<=NR; j++) {printf(\"%s\",a[i,j]); if (j!=NR) printf(\" \");} printf(\"\\\\n\")}}\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'{for (i=1; i<=NF; i++) {a[i,NR]=$i}} END {for (i=1; i<=NF; i++) {for (j=1; j<=NR; j++) {printf(\"%s\",a[i,j]); if (j!=NR) printf(\" \");} printf(\"\\\\n\")}}\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3389186,
                "title": "transpose-file-bash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\ncolumn=$(cat file.txt | head -n 1 | wc -w)\\n\\ni=1\\nwhile [ $i -le $column ]\\ndo\\n    cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' | rev | cut -c2- | rev\\n    let i=i+1\\ndone\\n\\nexit 0\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\ncolumn=$(cat file.txt | head -n 1 | wc -w)\\n\\ni=1\\nwhile [ $i -le $column ]\\ndo\\n    cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' | rev | cut -c2- | rev\\n    let i=i+1\\ndone\\n\\nexit 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3370714,
                "title": "194-transpose-file",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe task is to transpose the given text file, which means we need to convert the rows of the file to columns and vice versa.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne way to approach this problem is to use a bash script that reads the text file line by line, splits each line using the space delimiter, and stores the values in an array. Then, we can use another loop to iterate over the columns and store them in a separate array. Finally, we can print the transposed content of the file by iterating over the columns and printing each row.\\n\\n# Algorithm\\nRead the text file line by line using a loop\\nFor each line, split the line using the space delimiter and store the values in an array\\nUse another loop to iterate over the columns and store them in a separate array\\nFinally, print the transposed content of the file by iterating over the columns and printing each row\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this approach is O(m*n), where m is the number of rows and n is the number of columns in the text file. This is because we need to read each line of the file and split it into an array of n elements\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this approach is also O(m*n) because we need to store the entire contents of the file in an array of m rows and n columns. However, since we are transposing the content of the file, we only need to store the transpose of the file, which means we can optimize the space complexity by storing only n rows and m columns.\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'{ for(i=1; i<=NF; i++) { a[i,NR]=$i; } } END { for(i=1; i<=NF; i++) { printf(\"%s\", a[i,1]); for(j=2; j<=NR; j++) { printf(\" %s\", a[i,j]); } printf(\"\\\\n\"); } }\\' file.txt\\n\\n```\\nThis command reads the content of file.txt and creates an array a to store the values. The first loop for(i=1; i<=NF; i++) iterates over the columns and rows of the file, and assigns the value of each field to the corresponding position in the array (a[i,NR]=$i). The second loop for(i=1; i<=NF; i++) iterates over the columns of the array, and prints the values of each row in transposed order (printf(\"%s\", a[i,1]); for(j=2; j<=NR; j++) { printf(\" %s\", a[i,j]); } printf(\"\\\\n\");).\\n\\nThe time complexity of this solution is O(mn), where m is the number of rows and n is the number of columns in the file. The space complexity is also O(mn), since the entire file is stored in the a array.",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'{ for(i=1; i<=NF; i++) { a[i,NR]=$i; } } END { for(i=1; i<=NF; i++) { printf(\"%s\", a[i,1]); for(j=2; j<=NR; j++) { printf(\" %s\", a[i,j]); } printf(\"\\\\n\"); } }\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368166,
                "title": "solution-using-awk",
                "content": "# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'{\\n    for(i=1;i<=NF;++i)columns[i][NR]=$i;\\n}\\nEND {\\n    for(c in columns) {\\n        has_elem=0;\\n        for(l in columns[c]) {\\n            if(has_elem==1) printf(\" \");\\n            has_elem=1;\\n            printf(\"%s\", columns[c][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n}\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'{\\n    for(i=1;i<=NF;++i)columns[i][NR]=$i;\\n}\\nEND {\\n    for(c in columns) {\\n        has_elem=0;\\n        for(l in columns[c]) {\\n            if(has_elem==1) printf(\" \");\\n            has_elem=1;\\n            printf(\"%s\", columns[c][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3360683,
                "title": "concise-and-easy-solution-using-temporary-files",
                "content": "# Intuition\\nRead file line by line, transform each line into a column (multiple lines) and save column somewhere for later. At the end combine all columns.\\n\\n# Approach\\nEach line from file is piped to `tr`, which transforms the line to a column by replacing spaces with line breaks. These lines are saved to a temporary file, whose name is remembered in `columnFiles` variable.\\nAfter reading all lines from input file, `paste` combines column-files side-by-side.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n + m)$$, where `n` is the number of lines in input file (for reading input); `m` is the number of columns in input file (for combining columns).\\n\\n- Space complexity:\\n$$O(n)$$ memory space, where `n` is a number of lines in input file. The variable holding names of column-files grows with the number of lines (lines are transformed to columns).\\n$$O(n)$$ disk space, where `n` is the size of input file. Solution effectively makes a copy of input file, but splitted to chunks.\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\n# The idea is to transform each line in to a column (multiple lines)\\n# and save it to a separate file. Then combine all columns using `paste`\\n# command, which reads lines from multiple sources and outputs all\\n# that lines joined.\\n\\ncolumnFiles=\"\"\\n\\nwhile read -r line\\ndo\\n    columnFileName=\"$(mktemp)\"\\n    # I use `tee` to save output to file because testing environment forbids output\\n    # redirections. \\n    # The \\'while read\\' cycle after `tee` suppresses tee\\'s output, because, again,\\n    # no output redirections are allowed and 2>/dev/null is not available.\\n    echo \"$line\" | tr -s \\' \\' \\'\\\\n\\' | tee  \"$columnFileName\" | while read -r suppressed; do true; done\\n    columnFiles=\"$columnFiles $columnFileName\"\\ndone <file.txt\\n\\npaste -d \\' \\' $columnFiles\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\n# The idea is to transform each line in to a column (multiple lines)\\n# and save it to a separate file. Then combine all columns using `paste`\\n# command, which reads lines from multiple sources and outputs all\\n# that lines joined.\\n\\ncolumnFiles=\"\"\\n\\nwhile read -r line\\ndo\\n    columnFileName=\"$(mktemp)\"\\n    # I use `tee` to save output to file because testing environment forbids output\\n    # redirections. \\n    # The \\'while read\\' cycle after `tee` suppresses tee\\'s output, because, again,\\n    # no output redirections are allowed and 2>/dev/null is not available.\\n    echo \"$line\" | tr -s \\' \\' \\'\\\\n\\' | tee  \"$columnFileName\" | while read -r suppressed; do true; done\\n    columnFiles=\"$columnFiles $columnFileName\"\\ndone <file.txt\\n\\npaste -d \\' \\' $columnFiles\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3349525,
                "title": "really-simple-solution-using-bash-script",
                "content": "Just iterate over each column and print the corresponding row.\\n\\n# Code\\n```\\n#!/bin/sh\\ncols=$(awk \\'{print NF}\\' file.txt | sort -nu | tail -n 1)\\nfor (( c=1; c<=$cols; c++ ))\\ndo  \\n    cat file.txt | awk -v x=$c \\'{print $x}\\' | paste -s -d \\' \\'\\ndone\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/sh\\ncols=$(awk \\'{print NF}\\' file.txt | sort -nu | tail -n 1)\\nfor (( c=1; c<=$cols; c++ ))\\ndo  \\n    cat file.txt | awk -v x=$c \\'{print $x}\\' | paste -s -d \\' \\'\\ndone\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3266001,
                "title": "just-builtins-one-file-pass",
                "content": "Loop over lines, gather line items into successive array elements.  Dump the array afterwards.\\n\\nPure in-memory (filter-like) program: memory consumption is proportional to the file size.\\n\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\n# Bash version, uses arrays.  One pass over the input file.\\n\\nexec < file.txt\\n\\nread -r z\\nl=($z)\\n\\nwhile read -r z; do\\n    i=0\\n    for v in $z; do\\n            l[$i]+=\" $v\"\\n            ((i++))\\n    done\\ndone\\n\\nz=${#l[@]}\\nfor ((i=0; i < $z; i++)); do\\n    echo \"${l[$i]}\"\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n# Bash version, uses arrays.  One pass over the input file.\\n\\nexec < file.txt\\n\\nread -r z\\nl=($z)\\n\\nwhile read -r z; do\\n    i=0\\n    for v in $z; do\\n            l[$i]+=\" $v\"\\n            ((i++))\\n    done\\ndone\\n\\nz=${#l[@]}\\nfor ((i=0; i < $z; i++)); do\\n    echo \"${l[$i]}\"\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3143221,
                "title": "transpose-file-using-cut-and-awk-explanation",
                "content": "# Approach\\n1. With the help of awk count amount of columns in file\\n2. Make iterator i equal to amount of columns in file\\n3. In for-loop cut columns in file one by one\\n4. Send column to the output\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\n#!/bin/bash\\n\\ncolumns=$(cat \"file.txt\" | awk -F \\' \\' END\\'{print NF}\\')\\nfor i in $(seq 1 $columns)\\ndo\\noutput=$(cut -f $i -d \\' \\' \"file.txt\")\\necho $output\\ndone\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n#!/bin/bash\\n\\ncolumns=$(cat \"file.txt\" | awk -F \\' \\' END\\'{print NF}\\')\\nfor i in $(seq 1 $columns)\\ndo\\noutput=$(cut -f $i -d \\' \\' \"file.txt\")\\necho $output\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3134897,
                "title": "transpose-file-solution",
                "content": "```\\npython3 <<EOF\\nmatrix = [line[:-1].split(\\' \\') for line in open(\\'file.txt\\')]\\nfor column in range(len(matrix[0])):\\n    print(*(matrix[row][column] for row in range(len(matrix))))\\nEOF\\n```# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npython3 <<EOF\\nmatrix = [line[:-1].split(\\' \\') for line in open(\\'file.txt\\')]\\nfor column in range(len(matrix[0])):\\n    print(*(matrix[row][column] for row in range(len(matrix))))\\nEOF\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\npython3 <<EOF\\nmatrix = [line[:-1].split(\\' \\') for line in open(\\'file.txt\\')]\\nfor column in range(len(matrix[0])):\\n    print(*(matrix[row][column] for row in range(len(matrix))))\\nEOF\\n```\n```\\npython3 <<EOF\\nmatrix = [line[:-1].split(\\' \\') for line in open(\\'file.txt\\')]\\nfor column in range(len(matrix[0])):\\n    print(*(matrix[row][column] for row in range(len(matrix))))\\nEOF\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3125300,
                "title": "clean-bash-code-high-speed-beats-98-9",
                "content": "\\n# Code\\n```\\n#!/bin/bash\\n\\ncolumn=$(cat file.txt | head -n 1 | wc -w)\\n\\ni=1\\nwhile [ $i -le $column ]\\ndo\\n    cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' | rev | cut -c2- | rev\\n    let i=i+1\\ndone\\n\\nexit 0\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/bash\\n\\ncolumn=$(cat file.txt | head -n 1 | wc -w)\\n\\ni=1\\nwhile [ $i -le $column ]\\ndo\\n    cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' | rev | cut -c2- | rev\\n    let i=i+1\\ndone\\n\\nexit 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3046056,
                "title": "very-detailed-solution-easy-to-understande",
                "content": "# Intuition\\nFirst you need to know what\\'s the number of columns?\\n\\n# Approach\\n1) Using `wc` word count to count the number of lines and the number of words.\\n2) Given that the number of columns is the same in every line you can get the number of columns by `columns = words / lines`.\\n3) Iterate over each column to using `cut` with a `space` as delimiter with specifying the field number.\\n4) Using `tr` you can print the output in a single line by replacing the `newline` with the  `space`. \\n\\n# Code\\n```\\n#!/bin/bash\\nlines=$(cat file.txt |wc -l)\\nwords=$(cat file.txt |wc -w)\\ncolumns=$(($words/$lines))\\n\\nfor (( i=1;i<=$columns;i++ ));\\ndo\\n        echo $(cat file.txt | cut -d \" \" -f $i | tr \\'\\\\n\\' \\' \\') \\ndone  \\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/bash\\nlines=$(cat file.txt |wc -l)\\nwords=$(cat file.txt |wc -w)\\ncolumns=$(($words/$lines))\\n\\nfor (( i=1;i<=$columns;i++ ));\\ndo\\n        echo $(cat file.txt | cut -d \" \" -f $i | tr \\'\\\\n\\' \\' \\') \\ndone  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2989965,
                "title": "my-try",
                "content": "I count the number of columns (as specified they\\'ll be always the same on each line), Then use that number for specify the column to get with awk, then it\\'s easy to convert end lines to spaces and print that line. Doing this for every column will invert the matrix.\\n\\n# Code\\n```\\nNUM=\"$(sed \\'1q;d\\' file.txt | wc -w)\"; for ((i = 1; i <= $NUM; i++));do awk \"{ print \\\\${i} }\" < file.txt | tr \\'\\\\n\\' \\' \\' | xargs; done\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nNUM=\"$(sed \\'1q;d\\' file.txt | wc -w)\"; for ((i = 1; i <= $NUM; i++));do awk \"{ print \\\\${i} }\" < file.txt | tr \\'\\\\n\\' \\' \\' | xargs; done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2950901,
                "title": "transpose-a-file-without-using-awk-simple-soln",
                "content": "# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nword_count=$(cat file.txt | head -n 1 | wc -w)\\nfor (( i=1; i<=word_count; i++ ));do\\n  cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' |  sed \\'s/.$//\\'\\n  echo\\ndone\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nword_count=$(cat file.txt | head -n 1 | wc -w)\\nfor (( i=1; i<=word_count; i++ ));do\\n  cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' |  sed \\'s/.$//\\'\\n  echo\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2923860,
                "title": "194-transpose-file-by-boolean-autocrats",
                "content": "# Intuition\\nTo transpose the content of a text file, we can read the lines of the file and store each field in an array, with the array index representing the column number. Then, we can iterate over the array and print each element, which represents a transposed row of the file.\\n\\nIn this solution, I used the awk command to read the lines of the file and transpose the content. The awk command is a powerful text-processing utility that can be used to perform complex operations on text files. It reads the input line by line and allows you to specify actions to be taken based on the contents of the input.\\n\\nTo transpose the content of the file, I used the NF variable, which represents the number of fields in the current line, and the NR variable, which represents the current line number. I iterated over the fields of each line and stored them in an array s, with the array index representing the column number. If the current line was the first line of the file, I stored the field in the corresponding array index. If the current line was not the first line, I appended the field to the value stored in the corresponding array index, separated by a space character.\\n\\nFinally, after all the lines of the file had been processed, I iterated over the array and printed each element, which represented a transposed row of the file.\\n\\nI hope this helps to clarify the intuition behind the Bash solution I provided. Let me know if you have any problem in this questions.\\n\\n# Approach\\nThe approach I used to solve this problem was to use the awk command to read the lines of the file and transpose the content.\\n\\nTo do this, I used the NF variable, which represents the number of fields in the current line, and the NR variable, which represents the current line number. I iterated over the fields of each line and stored them in an array s, with the array index representing the column number. If the current line was the first line of the file, I stored the field in the corresponding array index. If the current line was not the first line, I appended the field to the value stored in the corresponding array index, separated by a space character.\\n\\nFinally, after all the lines of the file had been processed, I iterated over the array and printed each element, which represented a transposed row of the file.\\n\\nI hope this helps to clarify the approach I took to solve this problem. Let me know if you have any problem in this questions.\\n# Complexity\\n- Time complexity:The time complexity of the Bash solution I provided for this problem is O(n), where n is the number of lines in the input file.\\n\\nThe awk command reads the input line by line and processes each line in constant time. Therefore, the time complexity of the solution is determined by the number of lines in the input file.\\n\\nIn this solution, I used a loop to iterate over the fields of each line and store them in an array. I also used another loop to iterate over the array and print each element. Both of these loops execute in O(n) time, since they iterate over all the lines of the input file.\\n\\nTherefore, the overall time complexity of this solution is O(n), since it involves two loops that each execute in O(n) time.\\n\\nI hope this helps! Let me know if you have any problem in this questions.\\n\\n\\n- Space complexity:The space complexity of the Bash solution I provided for this problem is O(n), where n is the number of lines in the input file.\\n\\nThis solution stores each field of the input file in an array, with the array index representing the column number. Therefore, the space complexity is determined by the size of the array, which is equal to the number of lines in the input file.\\n\\nIn addition to the array, this solution also uses a few variables to store intermediate results and control the execution of the loops. However, these variables have a constant size and do not contribute significantly to the space complexity of the solution.\\n\\nTherefore, the overall space complexity of this solution is O(n), since it involves storing all the fields of the input file in an array of size n.\\n\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'\\n{\\n  for (i=1; i<=NF; i++) {\\n    if(NR == 1) {\\n      s[i] = $i;\\n    } else {\\n      s[i] = s[i] \" \" $i;\\n    }\\n  }\\n}\\nEND {\\n  for (i=1; s[i] != \"\"; i++) {\\n    print s[i];\\n  }\\n}\\n\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'\\n{\\n  for (i=1; i<=NF; i++) {\\n    if(NR == 1) {\\n      s[i] = $i;\\n    } else {\\n      s[i] = s[i] \" \" $i;\\n    }\\n  }\\n}\\nEND {\\n  for (i=1; s[i] != \"\"; i++) {\\n    print s[i];\\n  }\\n}\\n\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2887070,
                "title": "bash-script-pipes-and-redirections",
                "content": "# Intuition\\nUsing pipes and redirections \\nUsing cut -f to select column by column\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst, count the number of columns.\\nThen, start a while with a variabile counter i to cut column by column the input file.\\nFor each column, command tr transpose it to a row, but it adds a \\' \\' (space) at the end of the row. \\nTo overcome this issue (believe me, I failed a submission due to it), the last cut command eliminates the last char of the row. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N), N number of columns\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#!/bin/bash\\n\\ncolumn=$(cat file.txt | head -n 1 | wc -w)\\n\\ni=1\\nwhile [ $i -le $column ]\\ndo\\n    cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' | rev | cut -c2- | rev\\n    let i=i+1\\ndone\\n\\nexit 0\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/bash\\n\\ncolumn=$(cat file.txt | head -n 1 | wc -w)\\n\\ni=1\\nwhile [ $i -le $column ]\\ndo\\n    cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' | rev | cut -c2- | rev\\n    let i=i+1\\ndone\\n\\nexit 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2805116,
                "title": "my-not-quick-but-dirty-solution-using-awk",
                "content": "```bash\\nCOLS=$(awk \\'NR == 1 {print NF}\\' file.txt) # Get the number of columns from awk\\nfor ((field=1; field <=$COLS; field++)) # For each column i\\ndo\\n    #For each row j, get element in position (i,j), print it and append space\\n\\tline=$(awk -v field_num=\"$field\" \\'{ORS=\" \"; print $field_num}\\' file.txt)\\n    \\n\\techo \"${line%% }\" #remove trailing space\\ndone\\n```\\nThis code above works but it is not really perfomant (Runtime: 520ms; faster than 30%) since awk has to re-read the whole file for each iteration. I came up with it by skimming through the manual of awk and stumbling upon the ORS variable definition. I just got into Shell Scripting so for a beginner, I think I did pretty alright.",
                "solutionTags": [],
                "code": "```bash\\nCOLS=$(awk \\'NR == 1 {print NF}\\' file.txt) # Get the number of columns from awk\\nfor ((field=1; field <=$COLS; field++)) # For each column i\\ndo\\n    #For each row j, get element in position (i,j), print it and append space\\n\\tline=$(awk -v field_num=\"$field\" \\'{ORS=\" \"; print $field_num}\\' file.txt)\\n    \\n\\techo \"${line%% }\" #remove trailing space\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2624921,
                "title": "my-solution",
                "content": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if(NR == 1) {\\n            s[i] = $i;\\n        } else {\\n            s[i] = s[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; s[i] != \"\"; i++) {\\n        print s[i];\\n    }\\n}\\' file.txt\\n\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if(NR == 1) {\\n            s[i] = $i;\\n        } else {\\n            s[i] = s[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; s[i] != \"\"; i++) {\\n        print s[i];\\n    }\\n}\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2472406,
                "title": "a-few-short-solutions-on-awk-perl",
                "content": "Perl_#1\\n```\\nperl \\'-alne$r=@F;push@f,@F}{for$a(0..$r-1){print\"@f[map{$_*$r+$a}0..$.-1]\"}\\' < file.txt\\n```\\nPerl_#2\\n```\\nperl \\'-alne$a[$k].=\" $v\"while($k,$v)=each@F}{$,=$\\\\;print@a\\' < file.txt\\n```\\nawk\\n```\\nawk \\'{for(i=1;NF>=i;i++)w[i][NR]=$i}END{for(j=1;i>=j;j++){for(k=1;NR>=k;k++)printf\"%s \",w[j][k];print\"\"}}\\' < file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nperl \\'-alne$r=@F;push@f,@F}{for$a(0..$r-1){print\"@f[map{$_*$r+$a}0..$.-1]\"}\\' < file.txt\\n```\n```\\nperl \\'-alne$a[$k].=\" $v\"while($k,$v)=each@F}{$,=$\\\\;print@a\\' < file.txt\\n```\n```\\nawk \\'{for(i=1;NF>=i;i++)w[i][NR]=$i}END{for(j=1;i>=j;j++){for(k=1;NR>=k;k++)printf\"%s \",w[j][k];print\"\"}}\\' < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2256789,
                "title": "for-loop-simple-solution",
                "content": "```\\nfor i in $(seq 1 $(head -n1 file.txt | wc -w)); do echo $(cut -d\\' \\' -f$i file.txt); done\\n```",
                "solutionTags": [],
                "code": "```\\nfor i in $(seq 1 $(head -n1 file.txt | wc -w)); do echo $(cut -d\\' \\' -f$i file.txt); done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2236632,
                "title": "very-obvious-and-simple-solution-with-awk",
                "content": "It seems very obvious just to do simple cycle `column_count` times each times print specific column\\nxargs used to trim whitespaces and newlines (900 ms, 3.9 MB)\\n\\n```bash\\ncolumn_count=$(head -n 1 file.txt | wc -w) # get column count\\nfor i in $(seq $column_count); do \\n    awk \"{printf \\\\\"%s \\\\\",\\\\$$i }\" file.txt | xargs \\ndone\\n```\\n\\nor with cut (273 ms, 3.5 MB)\\n```bash\\ncolumn_count=$(head -n 1 file.txt | wc -w) # get column count\\nfor i in $(seq $column_count); do \\n    echo $(cut -d\\' \\' -f$i file.txt); \\ndone\\n```\\n\\nnot obvious but beautifull one (529 ms,  3.9 MB):\\n```bash\\nfor ((i = 1; ; i++)); do \\n\\tline=$(awk \"{print \\\\$$i}\" file.txt); \\n    [[ $line ]] || break && echo $line\\ndone\\n```",
                "solutionTags": [],
                "code": "```bash\\ncolumn_count=$(head -n 1 file.txt | wc -w) # get column count\\nfor i in $(seq $column_count); do \\n    awk \"{printf \\\\\"%s \\\\\",\\\\$$i }\" file.txt | xargs \\ndone\\n```\n```bash\\ncolumn_count=$(head -n 1 file.txt | wc -w) # get column count\\nfor i in $(seq $column_count); do \\n    echo $(cut -d\\' \\' -f$i file.txt); \\ndone\\n```\n```bash\\nfor ((i = 1; ; i++)); do \\n\\tline=$(awk \"{print \\\\$$i}\" file.txt); \\n    [[ $line ]] || break && echo $line\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2154248,
                "title": "leetcode-problem",
                "content": "Hello.\\nI have a sultion that works on my computer and online bash compiler and the output is fine - as expacted,\\nbut when i submit my solution to Leetcode its says error..  anyone have an idea ??\\n\\n```\\nnames=\\'\\'\\nages=\\'\\'\\n\\nwhile read line || [ -n \"$line\" ]\\ndo\\n\\n\\tnames=\"$names $(echo $line | cut -d \\' \\' -f 1)\"\\n\\tages=\"$ages $(echo $line | cut -d \\' \\' -f 2)\"\\n\\ndone < file.txt\\n\\necho $names\\necho $ages\\n```\\n",
                "solutionTags": [],
                "code": "```\\nnames=\\'\\'\\nages=\\'\\'\\n\\nwhile read line || [ -n \"$line\" ]\\ndo\\n\\n\\tnames=\"$names $(echo $line | cut -d \\' \\' -f 1)\"\\n\\tages=\"$ages $(echo $line | cut -d \\' \\' -f 2)\"\\n\\ndone < file.txt\\n\\necho $names\\necho $ages\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111393,
                "title": "another-while-loop-with-awk",
                "content": "count the numner of columns and loop thru them with an awk\\n| xargs is just to trim the white space that was messing up my tests\\n\\n```\\nnumber_of_columns=$(head -n 1 file.txt | wc -w)\\ncolumn_counter=1\\n\\nwhile [ $column_counter -le $number_of_columns ]\\ndo\\n   awk -v x=$column_counter \\'{print $x}\\' file.txt | tr \"\\\\n\" \" \" | xargs\\n   column_counter=$((column_counter+1))\\ndone\\n```\\n\\ni\\'m embarassed at how long this took me, but better late than never.",
                "solutionTags": [],
                "code": "```\\nnumber_of_columns=$(head -n 1 file.txt | wc -w)\\ncolumn_counter=1\\n\\nwhile [ $column_counter -le $number_of_columns ]\\ndo\\n   awk -v x=$column_counter \\'{print $x}\\' file.txt | tr \"\\\\n\" \" \" | xargs\\n   column_counter=$((column_counter+1))\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2057914,
                "title": "is-using-python-fine",
                "content": "You have to read the whole content to memory, right?\\nI decided to use python for that.\\n\\n```bash\\npython3 -c \\'\\nfrom collections import defaultdict\\ndata = defaultdict(list)\\nwith open(\"file.txt\") as f:\\n   for line in f:\\n       for i, word in enumerate(line.split()):\\n           data[i].append(word)\\nfor line in data.values():\\n    print(\" \".join(line))\\n\\'\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```bash\\npython3 -c \\'\\nfrom collections import defaultdict\\ndata = defaultdict(list)\\nwith open(\"file.txt\") as f:\\n   for line in f:\\n       for i, word in enumerate(line.split()):\\n           data[i].append(word)\\nfor line in data.values():\\n    print(\" \".join(line))\\n\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2052137,
                "title": "yet-another-awk-one-line-solution",
                "content": "awk \\'NR==1{for (i=1;i<=NF;i++){s[i]=$i}}NR>1{for (i=1;i<=NF;i++){s[i]=s[i] \" \" $i}}END{for (i=1;i<=NF;i++){print s[i]}}\\' file.txt",
                "solutionTags": [],
                "code": "awk \\'NR==1{for (i=1;i<=NF;i++){s[i]=$i}}NR>1{for (i=1;i<=NF;i++){s[i]=s[i] \" \" $i}}END{for (i=1;i<=NF;i++){print s[i]}}\\' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 1994989,
                "title": "awk-naive-solution",
                "content": "```\\ncat file.txt | awk \\'\\n(NR==1){ncols = NF}\\n{for(col=1;col<=ncols;col++) a[NR,col] = $col}\\nEND {\\n    for(i=1;i<=NR;i++) {\\n        if(i==1) {for(j=1;j<=ncols;j++) {b[j] = a[i,j]}}\\n        else {for(j=1;j<=ncols;j++) b[j] = b[j] \" \" a[i,j]}\\n    }\\n    for(j=1;j<=ncols;j++) print b[j]\\n}\\n\\'```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | awk \\'\\n(NR==1){ncols = NF}\\n{for(col=1;col<=ncols;col++) a[NR,col] = $col}\\nEND {\\n    for(i=1;i<=NR;i++) {\\n        if(i==1) {for(j=1;j<=ncols;j++) {b[j] = a[i,j]}}\\n        else {for(j=1;j<=ncols;j++) b[j] = b[j] \" \" a[i,j]}\\n    }\\n    for(j=1;j<=ncols;j++) print b[j]\\n}\\n\\'```",
                "codeTag": "Unknown"
            },
            {
                "id": 1713075,
                "title": "runtime-400-ms-memory-usage-3-5-mb-bash-shell",
                "content": "```\\nsplit -l 1 file.txt _A\\nls _A* | xargs -I % sh -c \"tr <% \\' \\' \\'\\\\n\\' >_%\" \\npaste -d \" \" __A* \\nrm _*\\n```",
                "solutionTags": [],
                "code": "```\\nsplit -l 1 file.txt _A\\nls _A* | xargs -I % sh -c \"tr <% \\' \\' \\'\\\\n\\' >_%\" \\npaste -d \" \" __A* \\nrm _*\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1533609,
                "title": "split-tr-paste-rm-simple-but-slow",
                "content": "In a sense it isn\\'t trully a Bash script, but one may appreciate a different approach :)\\n```\\nsplit -l 1 file.txt _A\\nls _A* | xargs -I % sh -c \"tr <% \\' \\' \\'\\\\n\\' >_%\" \\npaste -d \" \" __A* \\nrm _*\\n```",
                "solutionTags": [],
                "code": "```\\nsplit -l 1 file.txt _A\\nls _A* | xargs -I % sh -c \"tr <% \\' \\' \\'\\\\n\\' >_%\" \\npaste -d \" \" __A* \\nrm _*\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1479122,
                "title": "pure-awk-solution-use-2d-array-like-c",
                "content": "```\\nawk \\'{ \\nfor (i = 1; i <= NF; i++) { num[NR][i] = $i } \\n}\\nEND {\\n\\tfor (i = 1; i <= NF; i++) {\\n\\t\\tfor (j = 1; j <= NR; j++) {\\n\\t\\t\\tprintf \"%s\", num[j][i]\\n\\t\\t\\tif (j < NR) { printf \"%s\", \" \"}\\n\\t\\t}\\n\\t\\tif (i < NF) { print \\'\\\\n\\' }\\n\\t}\\n}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{ \\nfor (i = 1; i <= NF; i++) { num[NR][i] = $i } \\n}\\nEND {\\n\\tfor (i = 1; i <= NF; i++) {\\n\\t\\tfor (j = 1; j <= NR; j++) {\\n\\t\\t\\tprintf \"%s\", num[j][i]\\n\\t\\t\\tif (j < NR) { printf \"%s\", \" \"}\\n\\t\\t}\\n\\t\\tif (i < NF) { print \\'\\\\n\\' }\\n\\t}\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1470039,
                "title": "a-simple-solution-awk-sed",
                "content": "```bash\\nCOL=$(awk -F \" \" \\'END{printf NF}\\' file.txt)\\nfor ((i=0; i<$COL; i++));\\ndo\\n        awk \\'{printf $\\'\"$(($i+1))\"\\'\" \"}\\' file.txt | sed \\'s/.$/\\\\n/g\\'\\ndone\\n```",
                "solutionTags": [],
                "code": "```bash\\nCOL=$(awk -F \" \" \\'END{printf NF}\\' file.txt)\\nfor ((i=0; i<$COL; i++));\\ndo\\n        awk \\'{printf $\\'\"$(($i+1))\"\\'\" \"}\\' file.txt | sed \\'s/.$/\\\\n/g\\'\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1428262,
                "title": "one-awk-sed-solution",
                "content": "Treat file.txt as a table. firstly use awk to split tables by columns, for a centain colume, using sed to replace \\\\n with a space (this action compare to altering a column of data to a row of data), then use sed to remove the trailing space. column by column.\\n\\n```\\n#!/bin/bash\\n\\ndeclare -i column\\ndeclare -i i\\n\\ncolumn=$(cat file.txt | awk \\'NR==1 {print NF}\\')\\ni=1\\n\\nwhile [[ $i -le $column ]] \\ndo \\n    cat file.txt | awk \\'{print $\\'$i\\'}\\' | sed \\'s/\\\\n/\" \"/\\' | sed \\'s/ $/\\\\n/\\'\\n    let i+=1\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\n\\ndeclare -i column\\ndeclare -i i\\n\\ncolumn=$(cat file.txt | awk \\'NR==1 {print NF}\\')\\ni=1\\n\\nwhile [[ $i -le $column ]] \\ndo \\n    cat file.txt | awk \\'{print $\\'$i\\'}\\' | sed \\'s/\\\\n/\" \"/\\' | sed \\'s/ $/\\\\n/\\'\\n    let i+=1\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1400251,
                "title": "pure-bash-solution-newline-problems-passed-but-still-weird",
                "content": "Here\\'s a pure bash solution, but I had to mess with the newlines during the output phase to pass this test case\\n```\\na\\n```\\nIf I use echo instead of printf (program below), I get :\\n```\\na\\\\n\\n```\\nwhich makes the test fail ... very picky judge ... Can anyone explain why it makes a difference to not print a newline for the last output line?\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nallLists=()\\n\\nwhile IFS=\\' \\' read -a LINE;\\ndo\\n    for (( i=0; i<=${#LINE[@]}; i++ ))\\n    do\\n        if [[ -z \"${LINE[i]//[$\\'\\\\t\\\\r\\\\n \\']}\" ]]; then\\n            continue\\n        fi\\n        if [ -v allLists[i] ]; then\\n            allLists[$i]=\"${allLists[i]} ${LINE[i]//[$\\'\\\\t\\\\r\\\\n \\']}\"\\n        else\\n            allLists[$i]=\"${LINE[i]//[$\\'\\\\t\\\\r\\\\n \\']}\"\\n        fi\\n    done\\ndone <\"file.txt\"\\n\\nfor (( i=0; i<=${#allLists[@]}; i++ ))\\ndo\\n    # Can\\'t just use echo ${allLists[i]}, but this mess instead:\\n    printf \\'%s\\' \"${allLists[i]//[$\\'\\\\t\\\\r\\\\n\\']}\"\\n    if (( i < ${#allLists[@]} )); then\\n        printf \\'\\\\n\\'\\n    fi\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\na\\n```\n```\\na\\\\n\\n```\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nallLists=()\\n\\nwhile IFS=\\' \\' read -a LINE;\\ndo\\n    for (( i=0; i<=${#LINE[@]}; i++ ))\\n    do\\n        if [[ -z \"${LINE[i]//[$\\'\\\\t\\\\r\\\\n \\']}\" ]]; then\\n            continue\\n        fi\\n        if [ -v allLists[i] ]; then\\n            allLists[$i]=\"${allLists[i]} ${LINE[i]//[$\\'\\\\t\\\\r\\\\n \\']}\"\\n        else\\n            allLists[$i]=\"${LINE[i]//[$\\'\\\\t\\\\r\\\\n \\']}\"\\n        fi\\n    done\\ndone <\"file.txt\"\\n\\nfor (( i=0; i<=${#allLists[@]}; i++ ))\\ndo\\n    # Can\\'t just use echo ${allLists[i]}, but this mess instead:\\n    printf \\'%s\\' \"${allLists[i]//[$\\'\\\\t\\\\r\\\\n\\']}\"\\n    if (( i < ${#allLists[@]} )); then\\n        printf \\'\\\\n\\'\\n    fi\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1378260,
                "title": "solution-with-cut-pure-bash-no-awk",
                "content": "```\\ndelimiter=\\' \\'\\ncount=`head -n1 file.txt|grep -o \"$delimiter\" |wc -l`\\nfor (( line = 1; line <= $((count+1)); line++ ))\\ndo\\n        outLine=`cat file.txt|cut -d\"$delimiter\" -f$line |tr \\'\\\\n\\' \"$delimiter\"`\\n        lineLen=`echo $outLine|wc --chars`\\n        echo $outLine |cut -c 1-$(($lineLen-1))\\ndone\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndelimiter=\\' \\'\\ncount=`head -n1 file.txt|grep -o \"$delimiter\" |wc -l`\\nfor (( line = 1; line <= $((count+1)); line++ ))\\ndo\\n        outLine=`cat file.txt|cut -d\"$delimiter\" -f$line |tr \\'\\\\n\\' \"$delimiter\"`\\n        lineLen=`echo $outLine|wc --chars`\\n        echo $outLine |cut -c 1-$(($lineLen-1))\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1344331,
                "title": "another-perl-solution",
                "content": "\\n```\\n#!/usr/bin/env perl\\nuse strict;\\nuse warnings;\\nuse Data::Dumper;\\n\\nmy (@words, @a, @b);\\n\\nwhile (<DATA>) {\\n    chomp( my $line = $_ );\\n    @words = split / /,$line;\\n    push @a, $words[0];\\n    push @b, $words[1];\\n}\\n\\nprint Dumper @a;\\nprint \"====\\\\n\";\\nprint Dumper @b;\\n\\n__DATA__\\nname age\\nalice 21\\nryan 30\\n```",
                "solutionTags": [],
                "code": "```\\n#!/usr/bin/env perl\\nuse strict;\\nuse warnings;\\nuse Data::Dumper;\\n\\nmy (@words, @a, @b);\\n\\nwhile (<DATA>) {\\n    chomp( my $line = $_ );\\n    @words = split / /,$line;\\n    push @a, $words[0];\\n    push @b, $words[1];\\n}\\n\\nprint Dumper @a;\\nprint \"====\\\\n\";\\nprint Dumper @b;\\n\\n__DATA__\\nname age\\nalice 21\\nryan 30\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1276318,
                "title": "bash",
                "content": "```\\n#!/usr/bin/bash\\nwhile IFS=\\' \\' read -a l; do\\n        for i in ${!l[@]}; do\\n                a[i]=\"${a[i]} ${l[i]}\"\\n        done\\ndone < file.txt\\nfor i in ${!a[@]}; do\\n        echo ${a[i]}\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n#!/usr/bin/bash\\nwhile IFS=\\' \\' read -a l; do\\n        for i in ${!l[@]}; do\\n                a[i]=\"${a[i]} ${l[i]}\"\\n        done\\ndone < file.txt\\nfor i in ${!a[@]}; do\\n        echo ${a[i]}\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1174920,
                "title": "average-awk-solution",
                "content": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        arr[i] = arr[i] \" \" $i;\\n    }\\n}\\n\\nEND {\\n    for (i = 1; i <= NF; i++) {\\n        print gensub(/^[ \\\\t]*|[ \\\\t]*$/, \"\", \"g\", arr[i]);\\n    }\\n}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        arr[i] = arr[i] \" \" $i;\\n    }\\n}\\n\\nEND {\\n    for (i = 1; i <= NF; i++) {\\n        print gensub(/^[ \\\\t]*|[ \\\\t]*$/, \"\", \"g\", arr[i]);\\n    }\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1162707,
                "title": "awk-associative-array-solution",
                "content": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        transposed[NR, i] = $i \\n    }\\n}\\n\\nEND {\\n    for (r = 1; r <= NF; r++) {\\n        sep = \"\"\\n        for (c = 1; c <= NR; c++) {\\n            printf(\"%s%s\", sep, transposed[c, r])\\n            sep = \" \"\\n        }\\n        printf(\"\\\\n\")\\n    }\\n}\\n\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        transposed[NR, i] = $i \\n    }\\n}\\n\\nEND {\\n    for (r = 1; r <= NF; r++) {\\n        sep = \"\"\\n        for (c = 1; c <= NR; c++) {\\n            printf(\"%s%s\", sep, transposed[c, r])\\n            sep = \" \"\\n        }\\n        printf(\"\\\\n\")\\n    }\\n}\\n\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1074958,
                "title": "awk-reading-into-two-dimentional-array-and-printing-it",
                "content": "```\\nawk \\'{for (i=1;i<=NF;i++) {m[i,NR]=$i; a=NR;}}END{i--; for (j=1;j<=i;j++){for (k=1;k<=a;k++){printf(\"%s \",m[j,k])}printf\"\\\\n\"}}\\' file.txt |  sed \\'s/^ *//;s/ *$//;s/  */ /;\\'\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{for (i=1;i<=NF;i++) {m[i,NR]=$i; a=NR;}}END{i--; for (j=1;j<=i;j++){for (k=1;k<=a;k++){printf(\"%s \",m[j,k])}printf\"\\\\n\"}}\\' file.txt |  sed \\'s/^ *//;s/ *$//;s/  */ /;\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1073957,
                "title": "this-works-on-my-computer-usr-bin-bash-not-on-leetcode-strange",
                "content": "```\\ncl1=\"\"; cl2=\"\"; i=0; cat file.txt | while read line; do cl1=\"$cl1 `echo $line| awk \\'{print $1}\\'`\"; cl2=\"$cl2 `echo $line | awk \\'{print $2\\'}`\"; i=`expr $i + 1`; if [ $i -eq 3 ]; then echo $cl1; echo $cl2; fi; done;\\n```",
                "solutionTags": [],
                "code": "```\\ncl1=\"\"; cl2=\"\"; i=0; cat file.txt | while read line; do cl1=\"$cl1 `echo $line| awk \\'{print $1}\\'`\"; cl2=\"$cl2 `echo $line | awk \\'{print $2\\'}`\"; i=`expr $i + 1`; if [ $i -eq 3 ]; then echo $cl1; echo $cl2; fi; done;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1058674,
                "title": "awk-and-sed-awk-and-remove-leading-blank-with-sed",
                "content": "\\ncat file.txt |\\n  awk -F\" \" \\'{for (f=1;f<=NF;f++) str[f] = str[f] FS $f}END{for (f=1;f<=NF;f++) print str[f]}\\' |\\n  sed \\'s/^ //g\\'",
                "solutionTags": [],
                "code": "\\ncat file.txt |\\n  awk -F\" \" \\'{for (f=1;f<=NF;f++) str[f] = str[f] FS $f}END{for (f=1;f<=NF;f++) print str[f]}\\' |\\n  sed \\'s/^ //g\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1001883,
                "title": "why-is-this-wrong",
                "content": "Why is this wrong?\\n\\nWhen I run the test cases on my local machine, I get the expected output\\n\\'\\'\\'\\n#!/bin/bash\\n\\nNO_OF_COLUMNS=$(head -n 1 file.txt | awk \\'{print NF}\\')\\n\\nfor (( i=1 ; i<=${NO_OF_COLUMNS} ; i++ ))\\ndo\\n  awk -v j=$i \\'{print $j}\\' file.txt | while read ITEM\\n  do\\n\\n    echo -n \"${ITEM} \"\\n\\n  done\\n  echo\\n\\ndone\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "Why is this wrong?\\n\\nWhen I run the test cases on my local machine, I get the expected output\\n\\'\\'\\'\\n#!/bin/bash\\n\\nNO_OF_COLUMNS=$(head -n 1 file.txt | awk \\'{print NF}\\')\\n\\nfor (( i=1 ; i<=${NO_OF_COLUMNS} ; i++ ))\\ndo\\n  awk -v j=$i \\'{print $j}\\' file.txt | while read ITEM\\n  do\\n\\n    echo -n \"${ITEM} \"\\n\\n  done\\n  echo\\n\\ndone\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 967824,
                "title": "can-someone-explain-this-test-case",
                "content": "Input: a b c\\n\\nExpected: a\\\\nb\\\\nc\\n\\nI don\\'t understand why that is the expected output for this testcase.\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 966848,
                "title": "simple-solution",
                "content": "```\\nawk \\'\\n{ \\n    for (i=1; i<=NF; i++)  {\\n        a[NR,i] = $i\\n    }\\n}\\nNF>p { p = NF }\\nEND {    \\n    for(j=1; j<=p; j++) {\\n        str=a[1,j]\\n        for(i=2; i<=NR; i++){\\n            str=str\" \"a[i,j];\\n        }\\n        print str\\n    }\\n}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{ \\n    for (i=1; i<=NF; i++)  {\\n        a[NR,i] = $i\\n    }\\n}\\nNF>p { p = NF }\\nEND {    \\n    for(j=1; j<=p; j++) {\\n        str=a[1,j]\\n        for(i=2; i<=NR; i++){\\n            str=str\" \"a[i,j];\\n        }\\n        print str\\n    }\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935870,
                "title": "huh-computer-says-no",
                "content": "input: a\\noutput: a\\nexpected: a\\n*wrong answer*\\n lolwtf",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 871358,
                "title": "very-simple-hashmap-ish-style-solution",
                "content": "```\\nfile=\"file.txt\"\\n\\nIFS=$\\'\\\\n\\'\\narr=()\\n\\nfor line in $(cat $file); do\\n    i=0\\n    for word in $(echo \"$line\" | tr \\' \\' \\'\\\\n\\'); do \\n        [[ -z ${arr[i]} ]] && arr[i]=\"$word\" || arr[i]=\"${arr[i]} $word\" \\n        (( i++ ))\\n    done \\ndone\\n\\nfor line in ${arr[@]}; do echo $line; done \\n```",
                "solutionTags": [],
                "code": "```\\nfile=\"file.txt\"\\n\\nIFS=$\\'\\\\n\\'\\narr=()\\n\\nfor line in $(cat $file); do\\n    i=0\\n    for word in $(echo \"$line\" | tr \\' \\' \\'\\\\n\\'); do \\n        [[ -z ${arr[i]} ]] && arr[i]=\"$word\" || arr[i]=\"${arr[i]} $word\" \\n        (( i++ ))\\n    done \\ndone\\n\\nfor line in ${arr[@]}; do echo $line; done \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 818362,
                "title": "bug-failing-test-case-a-nb",
                "content": "Test case 5 of 17 has the input \\'a\\\\nb\\' (with a literal \\'\\\\n\\' not an actual new line) and it expects \\'a b\\'.\\nMy code below outputs \\'a\\\\nb\\' because it isn\\'t interpreting the newline and thus treating the input as one column and one row.\\nRunning on my Mac (GNU bash, version 5.0.18-release (x86_64-apple-darwin17.7.0)), none of the accepted solutions here appear to work but some of them will be accepted by the website. Is any one else seeing this?\\n\\n```bash\\nn_cols=$(head -n 1 file.txt | wc -w)\\nfor c in $(seq $n_cols); do\\n    echo \"$(cut -d \\' \\' -f \"${c}\" file.txt)\" | xargs\\ndone\\n```",
                "solutionTags": [],
                "code": "```bash\\nn_cols=$(head -n 1 file.txt | wc -w)\\nfor c in $(seq $n_cols); do\\n    echo \"$(cut -d \\' \\' -f \"${c}\" file.txt)\" | xargs\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 705247,
                "title": "why-is-this-getting-wrong-answer",
                "content": "Input is `a`, output is `a`, expected is `a`.\\nWhy does this not work? I don\\'t see any `\\\\n`s in there.\\n\\n```\\nfor i in $(seq 1 \"$(awk \\'{print NF; exit}\\' file.txt)\"); do\\n    awk -v col=$i \\'BEGIN {ORS=\" \"}; {print $col}\\' file.txt\\n\\techo\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\nfor i in $(seq 1 \"$(awk \\'{print NF; exit}\\' file.txt)\"); do\\n    awk -v col=$i \\'BEGIN {ORS=\" \"}; {print $col}\\' file.txt\\n\\techo\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 673853,
                "title": "why-does-this-get-permission-denied",
                "content": "```\\nncol=$(head -n1 file.txt | wc -w)\\nfor i in $(seq 1 $ncol); do\\n    echo $(cut -d \\' \\' -f $i file.txt)\\ndone\\n```\\nI submitted this same code several times. Some times it got accepted, sometimes the same code got permission denied.\\n\\nGot error:\\n```\\nrbash: ./prog.sh: Permission denied\\n```",
                "solutionTags": [],
                "code": "```\\nncol=$(head -n1 file.txt | wc -w)\\nfor i in $(seq 1 $ncol); do\\n    echo $(cut -d \\' \\' -f $i file.txt)\\ndone\\n```\n```\\nrbash: ./prog.sh: Permission denied\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 615067,
                "title": "simple-bash-solution",
                "content": "```\\ncol=\"$(head -1 file.txt | wc -w)\"\\n\\nfor i in $(seq 1 $col);do awk \\'{ print $\\'$i\\' }\\' file.txt | paste -s -d\" \";done\\n```",
                "solutionTags": [],
                "code": "```\\ncol=\"$(head -1 file.txt | wc -w)\"\\n\\nfor i in $(seq 1 $col);do awk \\'{ print $\\'$i\\' }\\' file.txt | paste -s -d\" \";done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 574865,
                "title": "solution-slower-but-better-memory-perf",
                "content": "```\\nfor i in {1..500}\\ndo\\n  cmd=\"cat file.txt | awk \\'{print \\\\$${i}}\\' | tr -s \\\\\"\\\\\\\\\\\\n\\\\\" \\\\\"\\\\ \\\\\"\"\\n  output=$( eval $cmd )\\n  [[ $output == \" \" ]] && exit 0\\n  echo $output\\ndone\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfor i in {1..500}\\ndo\\n  cmd=\"cat file.txt | awk \\'{print \\\\$${i}}\\' | tr -s \\\\\"\\\\\\\\\\\\n\\\\\" \\\\\"\\\\ \\\\\"\"\\n  output=$( eval $cmd )\\n  [[ $output == \" \" ]] && exit 0\\n  echo $output\\ndone\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 568814,
                "title": "a-short-one-liner-awk",
                "content": "awk \\'{a=a\" \"$1; b=b\" \"$2}; END {print a\"\\\\n\"b}\\' file.txt",
                "solutionTags": [],
                "code": "awk \\'{a=a\" \"$1; b=b\" \"$2}; END {print a\"\\\\n\"b}\\' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 553829,
                "title": "script-solution",
                "content": "```\\n#!/bin/bash\\n\\ntarget=\\'file.txt\\';\\n\\nfields=$(head -n 1 $target);\\nvalues=$(tail -n +2 $target | tr \"\\\\n\" \" \");\\n\\nlet count=0;\\nfor i in $fields\\ndo\\n    tarr[$count]=$i;\\n    let count++;\\ndone\\n\\nlet s=0;\\nfor value in $values\\ndo\\n    let index=s%count;\\n    let s++;\\n    tarr[$index]=\"${tarr[index]} $value\";\\ndone\\n\\ni=0;\\nwhile [ $i -lt ${#tarr[*]} ]\\ndo\\n    echo ${tarr[$i]};\\n    let i++;\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\n\\ntarget=\\'file.txt\\';\\n\\nfields=$(head -n 1 $target);\\nvalues=$(tail -n +2 $target | tr \"\\\\n\" \" \");\\n\\nlet count=0;\\nfor i in $fields\\ndo\\n    tarr[$count]=$i;\\n    let count++;\\ndone\\n\\nlet s=0;\\nfor value in $values\\ndo\\n    let index=s%count;\\n    let s++;\\n    tarr[$index]=\"${tarr[index]} $value\";\\ndone\\n\\ni=0;\\nwhile [ $i -lt ${#tarr[*]} ]\\ndo\\n    echo ${tarr[$i]};\\n    let i++;\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540453,
                "title": "my-solution-using-cut-awk-and-while-loop",
                "content": "```\\nfile=file.txt\\ncols=`cat $file | awk \\'{print NF}\\'`\\nfCol=`echo $cols | awk \\'{print $1}\\'`\\nindex=1\\nwhile [ $index -le $fCol ];\\ndo\\ncut -d\\' \\' -f$index $file | xargs\\nindex=$((index + 1))\\ndone\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfile=file.txt\\ncols=`cat $file | awk \\'{print NF}\\'`\\nfCol=`echo $cols | awk \\'{print $1}\\'`\\nindex=1\\nwhile [ $index -le $fCol ];\\ndo\\ncut -d\\' \\' -f$index $file | xargs\\nindex=$((index + 1))\\ndone\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 538800,
                "title": "my-simple-one-liner",
                "content": "```\\nfor i in `seq \\\\`head -n1 file.txt | wc -w\\\\``; do awk -v c=$i \\'{print $c}\\' file.txt | tr \\'\\\\n\\' \\' \\' | awk \\'{$1=$1};1\\';   done\\n```",
                "solutionTags": [],
                "code": "```\\nfor i in `seq \\\\`head -n1 file.txt | wc -w\\\\``; do awk -v c=$i \\'{print $c}\\' file.txt | tr \\'\\\\n\\' \\' \\' | awk \\'{$1=$1};1\\';   done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 521116,
                "title": "cut-columns-one-by-one",
                "content": "\\nCOLS=\\\\`head -1 file.txt | tr \\' \\' \\'\\\\n\\' | wc -l\\\\`\\nfor i in \\\\`seq 1 $COLS\\\\`\\ndo\\n    COL=\\\\`cut -d \\' \\' -f $i file.txt | tr \\'\\\\n\\' \\' \\'\\\\`\\n    echo $COL\\ndone",
                "solutionTags": [],
                "code": "\\nCOLS=\\\\`head -1 file.txt | tr \\' \\' \\'\\\\n\\' | wc -l\\\\`\\nfor i in \\\\`seq 1 $COLS\\\\`\\ndo\\n    COL=\\\\`cut -d \\' \\' -f $i file.txt | tr \\'\\\\n\\' \\' \\'\\\\`\\n    echo $COL\\ndone",
                "codeTag": "Unknown"
            },
            {
                "id": 491321,
                "title": "awk-solution-why-permission-denied",
                "content": "can anyone help me clarify why permission denied?\\n\\n```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++){\\n        #printf \"[%d,%d] %s\\\\n\", NR, i, $i\\n        line[NR][i] = $i\\n    }\\n}\\nEND {\\n#printf \"lines %d \\\\n\", lines\\n#printf \"NR %d \\\\n\", NR\\n#printf \"NF %d \\\\n\", NF\\n    for (j = 1; j <= NF; j++){\\n        for (i = 1; i <= NR; i++){\\n            #printf \"[%d,%d] %s \", j, i, line[i][j]\\n            printf \"%s \", line[i][j]\\n        }\\n        printf \"\\\\n\"\\n    }\\n}\\n\\' < file.txt\\n```\\n\\nthanks in advance",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++){\\n        #printf \"[%d,%d] %s\\\\n\", NR, i, $i\\n        line[NR][i] = $i\\n    }\\n}\\nEND {\\n#printf \"lines %d \\\\n\", lines\\n#printf \"NR %d \\\\n\", NR\\n#printf \"NF %d \\\\n\", NF\\n    for (j = 1; j <= NF; j++){\\n        for (i = 1; i <= NR; i++){\\n            #printf \"[%d,%d] %s \", j, i, line[i][j]\\n            printf \"%s \", line[i][j]\\n        }\\n        printf \"\\\\n\"\\n    }\\n}\\n\\' < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 472807,
                "title": "nothing-fancy-but-very-readable",
                "content": "Looks like a lot of submissions here are focused on trying to make things shorter but the filp side it makes it obscure.\\n\\nSo here is a somewhat opposite approach - keep it readable.\\n\\nThe idea:\\n\\n1. Calculate number of fields\\n2. in a for loop read the file and extract all values from column i into a line \\n\\nA couple notes:\\n\\n1. awk adds a new line at the end, so the \\'tr\\' command will replace new lines with spaces and the \\'sed\\' command will remove the last space in each line.\\n2. the echo command will insert a new line between the lines.\\n\\n\\n\\n\\n```\\nfields=`head -1 file.txt | wc -w`\\nfor i in `seq 1 $fields`\\ndo \\n    cat file.txt | awk \"{print $\"$i\"}\"  |tr \\'\\\\r\\\\n\\' \\' \\' |sed \\'s/ $//g\\'\\n    echo\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\nfields=`head -1 file.txt | wc -w`\\nfor i in `seq 1 $fields`\\ndo \\n    cat file.txt | awk \"{print $\"$i\"}\"  |tr \\'\\\\r\\\\n\\' \\' \\' |sed \\'s/ $//g\\'\\n    echo\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 454464,
                "title": "perl-solution",
                "content": "```perl\\nopen(my $fh, \"<\", \"file.txt\");\\nmy @file;\\nwhile(<$fh>) {\\n\\tmy @sp = split;\\n\\tpush(@file, \\\\@sp);\\n}\\n\\nfor my $i (0 .. @{$file[0]}-1) {\\n\\tfor my $j (0 .. @file-1) {\\n\\t\\tprint($file[$j][$i]);\\n\\t\\tprint(\" \") if $j != @file-1;\\n\\t}\\n\\tprint(\"\\\\n\");\\n}\\n```",
                "solutionTags": [],
                "code": "```perl\\nopen(my $fh, \"<\", \"file.txt\");\\nmy @file;\\nwhile(<$fh>) {\\n\\tmy @sp = split;\\n\\tpush(@file, \\\\@sp);\\n}\\n\\nfor my $i (0 .. @{$file[0]}-1) {\\n\\tfor my $j (0 .. @file-1) {\\n\\t\\tprint($file[$j][$i]);\\n\\t\\tprint(\" \") if $j != @file-1;\\n\\t}\\n\\tprint(\"\\\\n\");\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 400244,
                "title": "no-awk",
                "content": "This bash sciprt works  (tested on Ubuntu on WSL) and works perfectly.  But leet fails it with of the field being passed to ```cut -f```.\\n\\t\\t\\tWhile not as efficient in time or memory as other solutions,  it is easier to understand without having to know ```awk``` syntax.\\n\\n```\\ncols=`head -1 file.txt | wc -w `\\n\\nfor x in $(seq 0 $cols)\\ndo\\n  cat file.txt | while read foo; do echo $foo; done | cut -f$x -d\" \" | xargs echo\\ndone\\n```\\n",
                "solutionTags": [],
                "code": "```cut -f```\n```awk```\n```\\ncols=`head -1 file.txt | wc -w `\\n\\nfor x in $(seq 0 $cols)\\ndo\\n  cat file.txt | while read foo; do echo $foo; done | cut -f$x -d\" \" | xargs echo\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 369851,
                "title": "beat-99-single-line",
                "content": "```\\ncat file.txt | awk \\'{for(i=0;++i<=NF;)a[i]=a[i]?a[i] FS $i:$i}END{for(i=0;i++<NF;)print a[i]}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | awk \\'{for(i=0;++i<=NF;)a[i]=a[i]?a[i] FS $i:$i}END{for(i=0;i++<NF;)print a[i]}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 353080,
                "title": "awk-single-line",
                "content": "awk \\'NR == 1 {for (i = 1; i <= NF; i++) {cols[i] = $i}} NR > 1 {for(i = 1; i <= NF; i++) {cols[i] = cols[i]\" \"$i}} END {for (k in cols) {print cols[k]}}\\' file.txt",
                "solutionTags": [],
                "code": "awk \\'NR == 1 {for (i = 1; i <= NF; i++) {cols[i] = $i}} NR > 1 {for(i = 1; i <= NF; i++) {cols[i] = cols[i]\" \"$i}} END {for (k in cols) {print cols[k]}}\\' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 338464,
                "title": "trailing-whitespace",
                "content": "Heads up: if your answer contains trailing whitespace, an otherwise correct solution may not be accepted. Worth noting if you use awk with `ORS=\\' \\'`.",
                "solutionTags": [],
                "code": "Heads up: if your answer contains trailing whitespace, an otherwise correct solution may not be accepted. Worth noting if you use awk with `ORS=\\' \\'`.",
                "codeTag": "Unknown"
            },
            {
                "id": 337764,
                "title": "as-most-others-sulotion-with-awk",
                "content": "```\\nawk \\'{for(i=1;i<=NF;i++){array[NR][i]=$i;}} END{for (col=1; col <=NF; col++) {for (row=1; row <= NR; row++) {if (row==NR){printf(\"%s\", array[row][col]);}else {printf (\"%s \",array[row][col])}}printf \"\\\\n\";}}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{for(i=1;i<=NF;i++){array[NR][i]=$i;}} END{for (col=1; col <=NF; col++) {for (row=1; row <= NR; row++) {if (row==NR){printf(\"%s\", array[row][col]);}else {printf (\"%s \",array[row][col])}}printf \"\\\\n\";}}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 335023,
                "title": "faster-than-99-5-with-simple-awks",
                "content": "```\\ncat file.txt | head -n1 | awk \\'{print NF}\\' | xargs seq 1 \\\\\\n  | xargs -I {} sh -c \\\\\\n  \"cat file.txt | awk \\'{print \\\\${}}\\' | tr \\'\\\\n\\' \\' \\'  | sed -E \\'s/\\\\ +$//g\\' && echo\"\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | head -n1 | awk \\'{print NF}\\' | xargs seq 1 \\\\\\n  | xargs -I {} sh -c \\\\\\n  \"cat file.txt | awk \\'{print \\\\${}}\\' | tr \\'\\\\n\\' \\' \\'  | sed -E \\'s/\\\\ +$//g\\' && echo\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 331425,
                "title": "memory-usage-3-5-mb-less-than-99-28",
                "content": "```\\nfor ((i=1; i<=$(head -n 1 file.txt | wc -w);i++)){\\n echo $(cut -d \\' \\' -f $i file.txt)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfor ((i=1; i<=$(head -n 1 file.txt | wc -w);i++)){\\n echo $(cut -d \\' \\' -f $i file.txt)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 330250,
                "title": "awk-bash-8ms",
                "content": "```\\nnum_words=$((`cat file.txt | head -n 1 | wc -w`))  # 2\\nfor a in `seq 1 ${num_words}`; do\\n    awk -v col=\"$a\" \\'{\\n        printf \"%s \",$col; \\n    }\\n    END {\\n        print \"\"\\n    }\\' file.txt | sed -e \\'s/ $//\\'; done\\n```\\n\\nPretty simple solution. Had trouble with trailing whitespace so solved it with the sed call at the end.",
                "solutionTags": [],
                "code": "```\\nnum_words=$((`cat file.txt | head -n 1 | wc -w`))  # 2\\nfor a in `seq 1 ${num_words}`; do\\n    awk -v col=\"$a\" \\'{\\n        printf \"%s \",$col; \\n    }\\n    END {\\n        print \"\"\\n    }\\' file.txt | sed -e \\'s/ $//\\'; done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 330024,
                "title": "awk-easy",
                "content": "```\\nawk \\'\\n{\\n\\tfor (i=1;i<=NF;i++) {\\n\\t\\tarr[i] = arr[i]\" \"$i;\\n\\t}\\n}\\nEND {\\n\\tfor (key in arr) {\\n\\t\\tsub(\" \",\"\",arr[key]);\\n\\t\\tprint arr[key]\\n\\t}\\n}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n\\tfor (i=1;i<=NF;i++) {\\n\\t\\tarr[i] = arr[i]\" \"$i;\\n\\t}\\n}\\nEND {\\n\\tfor (key in arr) {\\n\\t\\tsub(\" \",\"\",arr[key]);\\n\\t\\tprint arr[key]\\n\\t}\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 302757,
                "title": "awk-4ms",
                "content": "cat file.txt |awk \\'BEGIN {Col_num=0} {if(NR==1) {for (i=1;i<=NF;++i) {a[i]=$i}; Col_num=NF} else if(NF==Col_num) {for (i=1;i<=NF;++i){a[i]=a[i]\" \"$i}} }   END{ for(i=1;i<=Col_num;++i){ print a[i] }  }\\'",
                "solutionTags": [],
                "code": "cat file.txt |awk \\'BEGIN {Col_num=0} {if(NR==1) {for (i=1;i<=NF;++i) {a[i]=$i}; Col_num=NF} else if(NF==Col_num) {for (i=1;i<=NF;++i){a[i]=a[i]\" \"$i}} }   END{ for(i=1;i<=Col_num;++i){ print a[i] }  }\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 249408,
                "title": "why-can-t-pass",
                "content": "A=`cat file.txt  |awk \\'{print $1}\\' |tr -t \\'\\\\n\\' \\' \\'`;\\necho $A\\nB=`cat file.txt  |awk \\'{print $2}\\' |tr -t  \\'\\\\n\\' \\' \\'`;\\necho $B",
                "solutionTags": [],
                "code": "A=`cat file.txt  |awk \\'{print $1}\\' |tr -t \\'\\\\n\\' \\' \\'`;\\necho $A\\nB=`cat file.txt  |awk \\'{print $2}\\' |tr -t  \\'\\\\n\\' \\' \\'`;\\necho $B",
                "codeTag": "Unknown"
            },
            {
                "id": 240226,
                "title": "one-line-awk",
                "content": "```\\ncat file.txt |awk \\'BEGIN{i=1;}{if(i == 1){for(x=1;x <= NF;x++){a[x-1]=$x}}else{for(x=1;x <= NF;x++){a[x-1]=a[x-1]\" \"$x}};i++}END{for(i=0;i<NF;i++)print a[i]}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt |awk \\'BEGIN{i=1;}{if(i == 1){for(x=1;x <= NF;x++){a[x-1]=$x}}else{for(x=1;x <= NF;x++){a[x-1]=a[x-1]\" \"$x}};i++}END{for(i=0;i<NF;i++)print a[i]}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 235778,
                "title": "use-awk-nf-for-solution",
                "content": "##### first get column number\\ncolnum=`awk \\'END{print NF}\\' file.txt`\\n##### then use for loop print the anwser\\nfor i in $(seq 1 $colnum); \\n    do \\n    awk -v b=$i \\'{print $b}\\' file.txt|xargs; \\n    done",
                "solutionTags": [],
                "code": "##### first get column number\\ncolnum=`awk \\'END{print NF}\\' file.txt`\\n##### then use for loop print the anwser\\nfor i in $(seq 1 $colnum); \\n    do \\n    awk -v b=$i \\'{print $b}\\' file.txt|xargs; \\n    done",
                "codeTag": "Unknown"
            },
            {
                "id": 219569,
                "title": "12ms-awk-solution",
                "content": "awk -F\\' \\' \\'BEGIN{nb=0} {nb=NF;i=1;while(i<=NF){m[i]=m[i]\" \"$i;i=i+1}} END{i=1;while(i<=nb){print substr(m[i],2);i++}}\\' file.txt",
                "solutionTags": [],
                "code": "awk -F\\' \\' \\'BEGIN{nb=0} {nb=NF;i=1;while(i<=NF){m[i]=m[i]\" \"$i;i=i+1}} END{i=1;while(i<=nb){print substr(m[i],2);i++}}\\' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 219457,
                "title": "20ms-awk",
                "content": "```\\nawk \\'{\\n    for(i=1;i<=NF;i++) \\n        a[NR][i]=$i\\n}END{\\n    for (i=1;i<=NF;i++) {\\n        for(j=1;j<=NR;j++)\\n            printf(\"%s \",a[j][i])\\n        print \"\\\\n\"\\n    }\\n}\\' file.txt|sed \\'/^$/d\\'|sed \\'s/ $//g\\'\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{\\n    for(i=1;i<=NF;i++) \\n        a[NR][i]=$i\\n}END{\\n    for (i=1;i<=NF;i++) {\\n        for(j=1;j<=NR;j++)\\n            printf(\"%s \",a[j][i])\\n        print \"\\\\n\"\\n    }\\n}\\' file.txt|sed \\'/^$/d\\'|sed \\'s/ $//g\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 211802,
                "title": "using-bash-arrays",
                "content": "Adding a separator conditionally has added some ugliness, bit otherwise it is relatively clean:\\n```\\ndeclare -a result\\nwhile read p; do \\n\\ti=0\\n\\tfor w in $p; do\\n\\t\\tif [ \"x${result[$i]}\" != \"x\" ]; then\\n\\t\\t\\tresult[$i]+=\" \"\\n\\t\\tfi\\n\\t\\tresult[$i]+=$w\\n\\t\\ti=$(($i+1))\\n\\tdone\\t\\ndone < file.txt\\n\\nfor l in \"${result[@]}\"; do\\n\\techo \"$l\"\\ndone\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndeclare -a result\\nwhile read p; do \\n\\ti=0\\n\\tfor w in $p; do\\n\\t\\tif [ \"x${result[$i]}\" != \"x\" ]; then\\n\\t\\t\\tresult[$i]+=\" \"\\n\\t\\tfi\\n\\t\\tresult[$i]+=$w\\n\\t\\ti=$(($i+1))\\n\\tdone\\t\\ndone < file.txt\\n\\nfor l in \"${result[@]}\"; do\\n\\techo \"$l\"\\ndone\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 204945,
                "title": "supposed-to-work-but-file-doesn-t-exist",
                "content": "My shortest solution:\\n```cat file.txt | awk \\'{line[1]=line[1]\" \"$1;line[2]=line[2]\" \"$2}END{print line[1]; print line[2]}\\'```",
                "solutionTags": [],
                "code": "```cat file.txt | awk \\'{line[1]=line[1]\" \"$1;line[2]=line[2]\" \"$2}END{print line[1]; print line[2]}\\'```",
                "codeTag": "Unknown"
            },
            {
                "id": 204461,
                "title": "awk-why-this-do-not-ok-please-help-me",
                "content": "```\\nawk \\'{for(i=1;i<=NF;i++)file[i][NR]=$i}END{for(i=1;i<=NF;i++){for(j=1;j<=NR;j++){printf(\"%s \",file[i][j])};printf(\"\\\\n\")}}\\' file.txt\\n```\\n\\nwhy this do not ok?",
                "solutionTags": [],
                "code": "```\\nawk \\'{for(i=1;i<=NF;i++)file[i][NR]=$i}END{for(i=1;i<=NF;i++){for(j=1;j<=NR;j++){printf(\"%s \",file[i][j])};printf(\"\\\\n\")}}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 202440,
                "title": "memory-limit-exceeded",
                "content": "This is a simple solution.  I need some help to figure out why this generates a \"memory limit exceeded\" on this problem.  Any tips from anyone?\\n```\\nwords=$(wc -w file.txt | awk {\\'print $1\\'})\\nlines=$(wc -l file.txt | awk {\\'print $1\\'})\\ncolumns=$(( $words / $lines ))\\nif [ $columns -eq 1 ]\\nthen\\n    cut -f 1 -d \" \" file.txt | paste -sd \" \" -\\nelse\\n    for i in `seq 1 $columns`; do cut -f $i -sd \" \" file.txt | paste -sd \" \" -; done\\nfi\\n```",
                "solutionTags": [],
                "code": "```\\nwords=$(wc -w file.txt | awk {\\'print $1\\'})\\nlines=$(wc -l file.txt | awk {\\'print $1\\'})\\ncolumns=$(( $words / $lines ))\\nif [ $columns -eq 1 ]\\nthen\\n    cut -f 1 -d \" \" file.txt | paste -sd \" \" -\\nelse\\n    for i in `seq 1 $columns`; do cut -f $i -sd \" \" file.txt | paste -sd \" \" -; done\\nfi\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 196656,
                "title": "a-very-slow-solution",
                "content": "```\\ntext=`cat file.txt`\\nIFS=$\\'\\\\n\\'\\nlines=($text)\\ndeclare -a array\\narray=()\\nfor line in ${lines[@]}\\ndo\\n    IFS=\\' \\'\\n    words=($line)\\n    for w in ${!words[@]}\\n    do\\n        array[$w]=\"${array[$w]} ${words[$w]}\"\\n    done\\ndone\\nfor i in ${!array[@]}\\ndo\\n    echo ${array[$i]}\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\ntext=`cat file.txt`\\nIFS=$\\'\\\\n\\'\\nlines=($text)\\ndeclare -a array\\narray=()\\nfor line in ${lines[@]}\\ndo\\n    IFS=\\' \\'\\n    words=($line)\\n    for w in ${!words[@]}\\n    do\\n        array[$w]=\"${array[$w]} ${words[$w]}\"\\n    done\\ndone\\nfor i in ${!array[@]}\\ndo\\n    echo ${array[$i]}\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 183456,
                "title": "bash-transpose-file",
                "content": "Why the site says following bash code is wrong to transpose a file, file.txt:\\na 1\\nb 2\\nc 3\\n\\n```#!/bin/bash\\ncut -d \" \" -f1 file.txt|paste -d \" \" -s\\ncut -d \" \" -f2 file.txt|paste -d \" \" -s\\n```",
                "solutionTags": [],
                "code": "```#!/bin/bash\\ncut -d \" \" -f1 file.txt|paste -d \" \" -s\\ncut -d \" \" -f2 file.txt|paste -d \" \" -s\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 173533,
                "title": "solution-that-actually-uses-bash-as-opposed-to-awk-cut-sort-etc",
                "content": "Unlike many others I tried to come up with a solution that actually uses bash (as opposed to awk, cut, sort, etc) However it won\\'t pass and I can\\'t figure out why, here it is:\\n\\n```\\n#!/bin/bash\\n\\ndeclare -a names\\ndeclare -a ages\\n\\nwhile read line\\ndo \\n\\twords=($line)\\n\\tnames+=(${words[0]})\\n\\tages+=(${words[1]})\\ndone < file.txt\\n\\nfor name in ${names[@]}\\ndo \\n\\tprintf \"%s \" $name\\ndone\\n\\nprintf \"\\\\n\"\\n\\nfor age in ${ages[@]}\\ndo \\n\\tprintf \"%s \" $age\\ndone\\n```\\n\\nIt says wrong answer:\\n\\nInput:\\na\\nOutput:\\na \\nExpected:\\na\\n\\nWTF?",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\n\\ndeclare -a names\\ndeclare -a ages\\n\\nwhile read line\\ndo \\n\\twords=($line)\\n\\tnames+=(${words[0]})\\n\\tages+=(${words[1]})\\ndone < file.txt\\n\\nfor name in ${names[@]}\\ndo \\n\\tprintf \"%s \" $name\\ndone\\n\\nprintf \"\\\\n\"\\n\\nfor age in ${ages[@]}\\ndo \\n\\tprintf \"%s \" $age\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168510,
                "title": "what-format-does-it-want-for-bash",
                "content": "A simple stupid solution like..\\n\\n```bash\\nN=$(awk \\'{print $1}\\'< file.txt)\\nA=$(awk \\'{print $2}\\'< file.txt)\\necho $N\\necho $A\\n```\\n\\nGets marked as wrong and says it outputs just \\'a\\'. I assume I\\'m not writing the script the way the site wants it somehow..\\n",
                "solutionTags": [],
                "code": "```bash\\nN=$(awk \\'{print $1}\\'< file.txt)\\nA=$(awk \\'{print $2}\\'< file.txt)\\necho $N\\necho $A\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 163881,
                "title": "my-simple-solution-with-awk",
                "content": "cat  file.txt | awk \\'BEGIN {col=NF;NR=0;} { for (i=1;i<=NF;i++) {a[NR,i]=$i;} }  END { for (i=1;i<=NF;i++) { str=a[1,i]; for (j=2;j<=NR;j++) {str=str\" \"a[j,i];} print str;}}\\'",
                "solutionTags": [],
                "code": "cat  file.txt | awk \\'BEGIN {col=NF;NR=0;} { for (i=1;i<=NF;i++) {a[NR,i]=$i;} }  END { for (i=1;i<=NF;i++) { str=a[1,i]; for (j=2;j<=NR;j++) {str=str\" \"a[j,i];} print str;}}\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 151469,
                "title": "please-help-me-runtime-error",
                "content": "```\\nnum=`cat file.txt | awk \\'END{print NF}\\'`\\nfor ((i=1;i<=$num;i++));do\\n\\trow=`cut -d \" \" -f $i file.txt|tr \\'\\\\n\\' \\' \\'|sed \\'s/ $//g\\'`\\n\\techo $row\\ndone\\n```\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/marcsea/image_1531985514.png)\\nI got the runtime error when I met the input above.",
                "solutionTags": [],
                "code": "```\\nnum=`cat file.txt | awk \\'END{print NF}\\'`\\nfor ((i=1;i<=$num;i++));do\\n\\trow=`cut -d \" \" -f $i file.txt|tr \\'\\\\n\\' \\' \\'|sed \\'s/ $//g\\'`\\n\\techo $row\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 140791,
                "title": "this-is-general-awk-piece-to-convert-from-line-to-col-or-reverse",
                "content": "{\\n    for (i=1;i<=NF;i++) {\\n        arr[i, NR]=$i;\\n        if (nf<=NF) {\\n            nf=NF\\n            }\\n    }\\n}\\nEND {\\n    for (j=1;j<=nf;j++){\\n        for (i=1;i<=NR;i++){\\n            printf(\"%s \", arr[j,i]);\\n            }\\n        printf(\"\\\\n\");\\n        }\\n    }\\n",
                "solutionTags": [],
                "code": "{\\n    for (i=1;i<=NF;i++) {\\n        arr[i, NR]=$i;\\n        if (nf<=NF) {\\n            nf=NF\\n            }\\n    }\\n}\\nEND {\\n    for (j=1;j<=nf;j++){\\n        for (i=1;i<=NR;i++){\\n            printf(\"%s \", arr[j,i]);\\n            }\\n        printf(\"\\\\n\");\\n        }\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 130990,
                "title": "two-solution",
                "content": "first: 16ms\\n```\\nawk \\'{for(i=1;i<=NF;i++){if(NR==1){arr[i]=$i}else{arr[i]=arr[i]\" \"$i}}}END{for(i=1;i<=NF;i++){printf arr[i];if(i!=NF){printf \"\\\\n\"}}}\\' file.txt\\n```\\nsecond: 40ms\\n```\\n awk \\'{for(i=1;i<=NF;i++){arr[i,NR]=$i;}}END{for(i=1;i<=NF;i++){for(j=1;j<=NR;j++){printf arr[i,j];if(j!=NR){printf \" \"}}if(i!=NF){printf \"\\\\n\"}}}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{for(i=1;i<=NF;i++){if(NR==1){arr[i]=$i}else{arr[i]=arr[i]\" \"$i}}}END{for(i=1;i<=NF;i++){printf arr[i];if(i!=NF){printf \"\\\\n\"}}}\\' file.txt\\n```\n```\\n awk \\'{for(i=1;i<=NF;i++){arr[i,NR]=$i;}}END{for(i=1;i<=NF;i++){for(j=1;j<=NR;j++){printf arr[i,j];if(j!=NR){printf \" \"}}if(i!=NF){printf \"\\\\n\"}}}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 130022,
                "title": "simple-oneliner-solution",
                "content": "\\n```for i in `seq 1 $(head -1 file.txt | wc -w)`; do awk -v I=$i \\'{print $I}\\' file.txt | tr \\'\\\\n\\' \\' \\'; echo; done;```",
                "solutionTags": [],
                "code": "```for i in `seq 1 $(head -1 file.txt | wc -w)`; do awk -v I=$i \\'{print $I}\\' file.txt | tr \\'\\\\n\\' \\' \\'; echo; done;```",
                "codeTag": "Unknown"
            },
            {
                "id": 114344,
                "title": "awk-with-2-d-array",
                "content": "```\\nawk '{for(i=1; i<=NF; i++) a[i,NR]=$i} END {for(i=1; a[i,1]!=\"\"; i++) {for(j=1; j<NR; j++) printf a[i,j] \" \"; print a[i,NR]}}' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk '{for(i=1; i<=NF; i++) a[i,NR]=$i} END {for(i=1; a[i,1]!=\"\"; i++) {for(j=1; j<NR; j++) printf a[i,j] \" \"; print a[i,NR]}}' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55505,
                "title": "memory-limit",
                "content": "I've got memory limit with this code but 17/17 passed\\n...\\ncounter=1\\nwhile (( $(head -n1 file.txt | wc -w) >= $counter ))\\ndo \\n    cut -d\" \" -f$counter file.txt | paste -s -d\" \"\\n    counter=$(($counter+1))\\ndone\\n...",
                "solutionTags": [],
                "code": "I've got memory limit with this code but 17/17 passed\\n...\\ncounter=1\\nwhile (( $(head -n1 file.txt | wc -w) >= $counter ))\\ndo \\n    cut -d\" \" -f$counter file.txt | paste -s -d\" \"\\n    counter=$(($counter+1))\\ndone\\n...",
                "codeTag": "Unknown"
            },
            {
                "id": 55506,
                "title": "my-solution-with-awk-and-sed-faster-than-only-awk",
                "content": "awk '{for(i=1; i<=NF;i++){line[i] = line[i]\" \"$i}} END{for(i=1;i<=NF;i++){print line[i]}}' file.txt |sed 's/^\\\\ //g'",
                "solutionTags": [],
                "code": "awk '{for(i=1; i<=NF;i++){line[i] = line[i]\" \"$i}} END{for(i=1;i<=NF;i++){print line[i]}}' file.txt |sed 's/^\\\\ //g'",
                "codeTag": "Unknown"
            },
            {
                "id": 55507,
                "title": "what-is-wrong-with-this-bash-solution",
                "content": "What is wrong with this solution?\\n\\n```\\ncount=`head -1 file.txt | egrep -c \" \"`\\ncount=$(expr $count + 1)\\nfor i in $(seq 1 $count); do\\n   cat file.txt  | cut -f$i -d \" \" | tr \"\\\\n\" \" \" | sed -e 's/ $//g'\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\ncount=`head -1 file.txt | egrep -c \" \"`\\ncount=$(expr $count + 1)\\nfor i in $(seq 1 $count); do\\n   cat file.txt  | cut -f$i -d \" \" | tr \"\\\\n\" \" \" | sed -e 's/ $//g'\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55508,
                "title": "what-is-wrong-with-my-solution",
                "content": "The test seems to be too picky about newlines!\\n\\n```\\ngname=()\\ngage=()\\nwhile read name age; do\\n    gname+=( $name )\\n    gage+=( $age )\\ndone < file.txt\\n\\necho \"${gname[@]}\"\\n#echo \"${gage[@]}\"\\n[[ -n $gage ]] && echo \"${gage[@]}\" #fix first test\\n```",
                "solutionTags": [],
                "code": "```\\ngname=()\\ngage=()\\nwhile read name age; do\\n    gname+=( $name )\\n    gage+=( $age )\\ndone < file.txt\\n\\necho \"${gname[@]}\"\\n#echo \"${gage[@]}\"\\n[[ -n $gage ]] && echo \"${gage[@]}\" #fix first test\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55509,
                "title": "why-i-use-awk-in-my-system-is-right-but-in-leetcode-is-wrong",
                "content": "awk 'BEGIN {ORS=\" \";count=0} {name[count]=$1; age[count]=$2; count++} END {for(i=0;i<NR;i++) print name[i];print \"\\\\n\";for(i=0;i<NR;i++) print age[i]}'",
                "solutionTags": [],
                "code": "awk 'BEGIN {ORS=\" \";count=0} {name[count]=$1; age[count]=$2; count++} END {for(i=0;i<NR;i++) print name[i];print \"\\\\n\";for(i=0;i<NR;i++) print age[i]}'",
                "codeTag": "Unknown"
            },
            {
                "id": 55519,
                "title": "it-gives-me-the-expected-answer-but-does-not-pass-the-test-anything-wrong",
                "content": "NLINES=$(wc -l < \"file.txt\")\\nawk '{printf \"%s \", $1}' file.txt\\nif [ $NLINES -ge 2 ]; then\\n    echo\\nfi\\nawk '{printf \"%s \", $2}' file.txt\\necho",
                "solutionTags": [],
                "code": "NLINES=$(wc -l < \"file.txt\")\\nawk '{printf \"%s \", $1}' file.txt\\nif [ $NLINES -ge 2 ]; then\\n    echo\\nfi\\nawk '{printf \"%s \", $2}' file.txt\\necho",
                "codeTag": "Unknown"
            },
            {
                "id": 55518,
                "title": "my-solution-not-being-accepted",
                "content": "    #!bin/bash\\n    \\n    i=0\\n    while read p; do\\n    \\tj=0\\n    \\tfor word in $p\\n    \\t\\tdo\\n    \\t\\t\\t#echo \"i value:\" $i \"j value:\" $j \"word value:\" $word\\n    \\t\\t\\tif [ $j -eq 0 ];\\n    \\t\\t\\tthen\\n    \\t\\t\\t\\t#echo \"inside name\"\\n    \\t\\t\\t\\tname[$i]=$word\\n    \\t\\t\\t\\t((j++))\\n    \\t\\t\\t\\t#echo \" name value\" ${name[$i]}\\n    \\t\\t\\telse\\n    \\t\\t\\t\\t#echo \"inside age\"\\n    \\t\\t\\t\\tage[$i]=$word\\n    \\t\\t\\t\\t#echo \" age value\" ${age[$i]}\\n    \\t\\t\\tfi\\n    \\t\\tdone\\n    \\t((i++))\\n    done < file.txt\\n    \\n    printf \"%s \" ${name[@]}\\n    echo\\n    printf \"%s \" ${age[@]}",
                "solutionTags": [],
                "code": "    #!bin/bash\\n    \\n    i=0\\n    while read p; do\\n    \\tj=0\\n    \\tfor word in $p\\n    \\t\\tdo\\n    \\t\\t\\t#echo \"i value:\" $i \"j value:\" $j \"word value:\" $word\\n    \\t\\t\\tif [ $j -eq 0 ];\\n    \\t\\t\\tthen\\n    \\t\\t\\t\\t#echo \"inside name\"\\n    \\t\\t\\t\\tname[$i]=$word\\n    \\t\\t\\t\\t((j++))\\n    \\t\\t\\t\\t#echo \" name value\" ${name[$i]}\\n    \\t\\t\\telse\\n    \\t\\t\\t\\t#echo \"inside age\"\\n    \\t\\t\\t\\tage[$i]=$word\\n    \\t\\t\\t\\t#echo \" age value\" ${age[$i]}\\n    \\t\\t\\tfi\\n    \\t\\tdone\\n    \\t((i++))\\n    done < file.txt\\n    \\n    printf \"%s \" ${name[@]}\\n    echo\\n    printf \"%s \" ${age[@]}",
                "codeTag": "Unknown"
            },
            {
                "id": 55521,
                "title": "why-can-t-i-pass-this-problem-by-using-awk",
                "content": "Code is as follows, please give me a suggestion\\uff1a\\nawk -F ' ' '{for (i=1; i <= NF; i++){s[i] = (s[i]\"\"$i\"\"\" \")}} END{for (a in s)print s[a]}'  file.txt",
                "solutionTags": [],
                "code": "Code is as follows, please give me a suggestion\\uff1a\\nawk -F ' ' '{for (i=1; i <= NF; i++){s[i] = (s[i]\"\"$i\"\"\" \")}} END{for (a in s)print s[a]}'  file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 55503,
                "title": "my-solution-written-only-in-bash",
                "content": "    array=()\\n    \\n    while read -a columns; do\\n        for (( i = 0; i < ${#columns[@]}; i++ )); do\\n            array[i]=\"${array[i]} ${columns[i]}\"\\n        done\\n    done < file.txt\\n    \\n    for (( i = 0; i < ${#array[@]}; i++ )); do\\n        echo ${array[i]}\\n    done\\n\\nTaught by @yongjhih",
                "solutionTags": [],
                "code": "    array=()\\n    \\n    while read -a columns; do\\n        for (( i = 0; i < ${#columns[@]}; i++ )); do\\n            array[i]=\"${array[i]} ${columns[i]}\"\\n        done\\n    done < file.txt\\n    \\n    for (( i = 0; i < ${#array[@]}; i++ )); do\\n        echo ${array[i]}\\n    done\\n\\nTaught by @yongjhih",
                "codeTag": "Unknown"
            },
            {
                "id": 55525,
                "title": "my-ac-code-just-use-bash-array",
                "content": "    empty=\" \"\\n    i=0\\n    while read line\\n    do \\n    \\tif [ $i -eq 0 ]; then\\n    \\t\\tarray=($line)\\n    \\telse\\n    \\t\\ttmp=($line)\\n    \\t\\tlen=${#tmp[@]}\\n    \\t\\tk=0\\n    \\t\\twhile [ $k -lt $len ]\\n    \\t\\tdo \\n    \\t\\t\\tarray[$k]=${array[$k]}$empty${tmp[$k]}\\n    \\t\\t\\tlet k++\\n    \\t\\tdone\\n    \\tfi\\n    \\tlet i++\\n    done < file.txt\\n    \\n    #print result\\n    for ((i=0;i<${#array[@]};i++));\\n    do\\n    \\techo ${array[$i]}\\n    done",
                "solutionTags": [],
                "code": "    empty=\" \"\\n    i=0\\n    while read line\\n    do \\n    \\tif [ $i -eq 0 ]; then\\n    \\t\\tarray=($line)\\n    \\telse\\n    \\t\\ttmp=($line)\\n    \\t\\tlen=${#tmp[@]}\\n    \\t\\tk=0\\n    \\t\\twhile [ $k -lt $len ]\\n    \\t\\tdo \\n    \\t\\t\\tarray[$k]=${array[$k]}$empty${tmp[$k]}\\n    \\t\\t\\tlet k++\\n    \\t\\tdone\\n    \\tfi\\n    \\tlet i++\\n    done < file.txt\\n    \\n    #print result\\n    for ((i=0;i<${#array[@]};i++));\\n    do\\n    \\techo ${array[$i]}\\n    done",
                "codeTag": "Unknown"
            },
            {
                "id": 55513,
                "title": "wrong-answer-with-input-a-for-transpose-file-in-bash-oj-s-mistake",
                "content": "I have submitted the following code as an answer to \"transpose file with bash\", and LeetCode OJ decides it spits wrong answer for input 'a' while both the output and the expected values are 'a'. I am confused...\\n\\n    #!/bin/bash\\n    fname='file.txt'\\n    #fname=$1\\n    nlines=$(wc -l < \"$fname\")\\n    ncol=$(awk '{print NF; exit}' $fname)\\n    #echo nlines $nlines ncol $ncol\\n    row_id=0\\n    {![enter image description here][1]\\n      while read -a line; do\\n        row_id=$((row_id+1))\\n        #echo read row $row_id\\n        for j in \"${!line[@]}\"; do\\n          i=$((j+1))\\n          #echo row $row_id column $i\\n          #echo $(( (row_id-1) * (ncol) + i))\\n          r[$(( (row_id-1) * ncol + i))]=${line[$j]}\\n          #echo '####' element ${r[$(( (row_id-1) * (ncol) + i))]} '####'\\n        done\\n      done\\n    } < $fname\\n    \\n    for(( j=1; j<=$ncol; j++)) do\\n      for(( k=1; k<=$((nlines)); k++)) do\\n      if [ -n \"${r[$(( (k-1) * ncol + j))]}\" ]; then\\n          echo -n \"${r[$(( (k-1) * ncol + j))]}\"' '\\n        fi\\n      done\\n      echo\\n    done\\n\\n\\n![Screenshot of the OJ's output][1]\\n\\n\\n  [1]: https://dl.dropboxusercontent.com/u/83334653/LeetCodeOJ_transposeFile.png",
                "solutionTags": [],
                "code": "I have submitted the following code as an answer to \"transpose file with bash\", and LeetCode OJ decides it spits wrong answer for input 'a' while both the output and the expected values are 'a'. I am confused...\\n\\n    #!/bin/bash\\n    fname='file.txt'\\n    #fname=$1\\n    nlines=$(wc -l < \"$fname\")\\n    ncol=$(awk '{print NF; exit}' $fname)\\n    #echo nlines $nlines ncol $ncol\\n    row_id=0\\n    {![enter image description here][1]\\n      while read -a line; do\\n        row_id=$((row_id+1))\\n        #echo read row $row_id\\n        for j in \"${!line[@]}\"; do\\n          i=$((j+1))\\n          #echo row $row_id column $i\\n          #echo $(( (row_id-1) * (ncol) + i))\\n          r[$(( (row_id-1) * ncol + i))]=${line[$j]}\\n          #echo '####' element ${r[$(( (row_id-1) * (ncol) + i))]} '####'\\n        done\\n      done\\n    } < $fname\\n    \\n    for(( j=1; j<=$ncol; j++)) do\\n      for(( k=1; k<=$((nlines)); k++)) do\\n      if [ -n \"${r[$(( (k-1) * ncol + j))]}\" ]; then\\n          echo -n \"${r[$(( (k-1) * ncol + j))]}\"' '\\n        fi\\n      done\\n      echo\\n    done\\n\\n\\n![Screenshot of the OJ's output][1]\\n\\n\\n  [1]: https://dl.dropboxusercontent.com/u/83334653/LeetCodeOJ_transposeFile.png",
                "codeTag": "Unknown"
            },
            {
                "id": 55527,
                "title": "ac-solution-with-question",
                "content": "This is the AC solution using a big array to store all elements from stack exchange\\n\\n    awk '\\n    { \\n        for (i=1; i<=NF; i++)  {\\n            a[NR,i] = $i\\n        }\\n    }\\n    NF>p { p = NF }\\n    END {    \\n        for(j=1; j<=p; j++) {\\n            str=a[1,j]\\n            for(i=2; i<=NR; i++){\\n                str=str\" \"a[i,j];\\n            }\\n            print str\\n        }\\n    }' file.txt\\n\\n\\nThen I tried to improve it somehow by using \"attaching\" idea and got the following code which \"should\" be better I think:\\n\\n\\n     col=`head -1 \"file.txt\"|awk '{print NF'}`\\n     echo $col\\n        \\n        \\n     for((i=1;i<=$col;i++))\\n     do\\n         awk '{printf \"%s %s\",$'\"$i\"',\" \"}END{print \"\"}' file.txt\\n     done\\n\\n\\n\\nthen I got Memory exceed result. Would someone please enlighten me on this?",
                "solutionTags": [],
                "code": "This is the AC solution using a big array to store all elements from stack exchange\\n\\n    awk '\\n    { \\n        for (i=1; i<=NF; i++)  {\\n            a[NR,i] = $i\\n        }\\n    }\\n    NF>p { p = NF }\\n    END {    \\n        for(j=1; j<=p; j++) {\\n            str=a[1,j]\\n            for(i=2; i<=NR; i++){\\n                str=str\" \"a[i,j];\\n            }\\n            print str\\n        }\\n    }' file.txt\\n\\n\\nThen I tried to improve it somehow by using \"attaching\" idea and got the following code which \"should\" be better I think:\\n\\n\\n     col=`head -1 \"file.txt\"|awk '{print NF'}`\\n     echo $col\\n        \\n        \\n     for((i=1;i<=$col;i++))\\n     do\\n         awk '{printf \"%s %s\",$'\"$i\"',\" \"}END{print \"\"}' file.txt\\n     done\\n\\n\\n\\nthen I got Memory exceed result. Would someone please enlighten me on this?",
                "codeTag": "Unknown"
            },
            {
                "id": 3985001,
                "title": "efficient-matrix-transposition-with-awk",
                "content": "# Intuition\\nWhen presented with the problem of transposing a matrix in the form of a file, one might first think of using nested loops: an outer loop for columns and an inner loop for rows. But with AWK, a powerful pattern scanning and processing language, we can perform the transposition in a more elegant manner.\\n\\n# Approach\\nThe script uses the power of associative arrays in AWK:\\n    We loop through each field in the input rows using for (i=1; i<=NF; i++). Here, NF represents the number of fields in the current record, essentially giving us the column count.\\n    Within this loop, we\\'re building our associative array a. The key to this array is the column number i, and we\\'re appending the current field value $i to this key. If a[i] already has a value, we append the new value with a space, otherwise, we simply set the new value.\\n    Once all rows have been processed, we enter the END block where we print out each value of our associative array a using for (i in a). This gives us the transposed matrix.\\n\\n# Complexity\\n- Time complexity:\\n O(n\\xD7m)O(n\\xD7m) where nn is the number of rows and mm is the number of columns. We are effectively visiting each cell of the matrix once.\\n\\n- Space complexity:\\nO(n\\xD7m)O(n\\xD7m) as we need to store the entire transposed matrix in memory.\\n\\n# Code\\n```\\nawk \\'{for (i=1; i<=NF; i++) a[i]=a[i] ? a[i] \" \" $i : $i} END {for (i in a) print a[i]}\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\nawk \\'{for (i=1; i<=NF; i++) a[i]=a[i] ? a[i] \" \" $i : $i} END {for (i in a) print a[i]}\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1392995,
                "title": "map-reduce-type-solution-with-awk",
                "content": "A simple awk-heavy solution which first outputs every field with its field number, e.g.\\n\\n```\\n1   name\\n2   age\\n1   alice\\n2   21\\n1   ryan\\n2   30\\n```\\n\\nthen does a stable sort (`sort -s`) on the field numbers, then combines them with awk again:\\n\\n```\\nawk \\'{for (i=1;i<=NF;i++) print i, \" \", $i}\\' file.txt \\\\\\n   | sort -snk 1 \\\\\\n   | awk \\'BEGIN {i=1; start=1} {\\n\\t   if ($1 != i) {i = $1; printf \"\\\\n\"; start=1}; \\n\\t   if (start != 1) printf \" \"; \\n\\t   printf \"%s\", $2; start=0}\\'\\n```",
                "solutionTags": [],
                "code": "```\\n1   name\\n2   age\\n1   alice\\n2   21\\n1   ryan\\n2   30\\n```\n```\\nawk \\'{for (i=1;i<=NF;i++) print i, \" \", $i}\\' file.txt \\\\\\n   | sort -snk 1 \\\\\\n   | awk \\'BEGIN {i=1; start=1} {\\n\\t   if ($1 != i) {i = $1; printf \"\\\\n\"; start=1}; \\n\\t   if (start != 1) printf \" \"; \\n\\t   printf \"%s\", $2; start=0}\\'\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1569014,
                "content": [
                    {
                        "username": "illuz",
                        "content": "Is O(n) or O(nlogn) space can solve this problem?  \\n\\nI have a idea:  \\n**Record the \"current position\" of every line and loop.**  \\n\\nBut I don't know how to implement it.  \\n\\nIs there an implement or other ideas?"
                    },
                    {
                        "username": "gemtra",
                        "content": "num=`awk \\'END{print NF}\\' file.txt`\\nfor i in `seq 1 $num`;do cut -d \\' \\' -f $i file.txt|xargs; done"
                    },
                    {
                        "username": "firejox",
                        "content": "seq 1 $(head -1 file.txt | wc -w) | xargs -I \\'{}\\' bash -c \"cut -d \\'\"\\' \\'\"\\' -f {} file.txt| xargs\""
                    },
                    {
                        "username": "caspergao",
                        "content": "# awk \\'{print $1;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\';awk \\'{print $2;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\'\\nname alice ryan \\nage 21 30 "
                    },
                    {
                        "username": "patrickfung",
                        "content": "echo $(cat file.txt|cut -d \\' \\' -f 1) && echo $(cat file.txt|cut -d \\' \\' -f 2)\\n\\nname alice ryan\\nage 21 30\\n"
                    }
                ]
            },
            {
                "id": 1573207,
                "content": [
                    {
                        "username": "illuz",
                        "content": "Is O(n) or O(nlogn) space can solve this problem?  \\n\\nI have a idea:  \\n**Record the \"current position\" of every line and loop.**  \\n\\nBut I don't know how to implement it.  \\n\\nIs there an implement or other ideas?"
                    },
                    {
                        "username": "gemtra",
                        "content": "num=`awk \\'END{print NF}\\' file.txt`\\nfor i in `seq 1 $num`;do cut -d \\' \\' -f $i file.txt|xargs; done"
                    },
                    {
                        "username": "firejox",
                        "content": "seq 1 $(head -1 file.txt | wc -w) | xargs -I \\'{}\\' bash -c \"cut -d \\'\"\\' \\'\"\\' -f {} file.txt| xargs\""
                    },
                    {
                        "username": "caspergao",
                        "content": "# awk \\'{print $1;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\';awk \\'{print $2;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\'\\nname alice ryan \\nage 21 30 "
                    },
                    {
                        "username": "patrickfung",
                        "content": "echo $(cat file.txt|cut -d \\' \\' -f 1) && echo $(cat file.txt|cut -d \\' \\' -f 2)\\n\\nname alice ryan\\nage 21 30\\n"
                    }
                ]
            },
            {
                "id": 1572415,
                "content": [
                    {
                        "username": "illuz",
                        "content": "Is O(n) or O(nlogn) space can solve this problem?  \\n\\nI have a idea:  \\n**Record the \"current position\" of every line and loop.**  \\n\\nBut I don't know how to implement it.  \\n\\nIs there an implement or other ideas?"
                    },
                    {
                        "username": "gemtra",
                        "content": "num=`awk \\'END{print NF}\\' file.txt`\\nfor i in `seq 1 $num`;do cut -d \\' \\' -f $i file.txt|xargs; done"
                    },
                    {
                        "username": "firejox",
                        "content": "seq 1 $(head -1 file.txt | wc -w) | xargs -I \\'{}\\' bash -c \"cut -d \\'\"\\' \\'\"\\' -f {} file.txt| xargs\""
                    },
                    {
                        "username": "caspergao",
                        "content": "# awk \\'{print $1;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\';awk \\'{print $2;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\'\\nname alice ryan \\nage 21 30 "
                    },
                    {
                        "username": "patrickfung",
                        "content": "echo $(cat file.txt|cut -d \\' \\' -f 1) && echo $(cat file.txt|cut -d \\' \\' -f 2)\\n\\nname alice ryan\\nage 21 30\\n"
                    }
                ]
            },
            {
                "id": 1571882,
                "content": [
                    {
                        "username": "illuz",
                        "content": "Is O(n) or O(nlogn) space can solve this problem?  \\n\\nI have a idea:  \\n**Record the \"current position\" of every line and loop.**  \\n\\nBut I don't know how to implement it.  \\n\\nIs there an implement or other ideas?"
                    },
                    {
                        "username": "gemtra",
                        "content": "num=`awk \\'END{print NF}\\' file.txt`\\nfor i in `seq 1 $num`;do cut -d \\' \\' -f $i file.txt|xargs; done"
                    },
                    {
                        "username": "firejox",
                        "content": "seq 1 $(head -1 file.txt | wc -w) | xargs -I \\'{}\\' bash -c \"cut -d \\'\"\\' \\'\"\\' -f {} file.txt| xargs\""
                    },
                    {
                        "username": "caspergao",
                        "content": "# awk \\'{print $1;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\';awk \\'{print $2;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\'\\nname alice ryan \\nage 21 30 "
                    },
                    {
                        "username": "patrickfung",
                        "content": "echo $(cat file.txt|cut -d \\' \\' -f 1) && echo $(cat file.txt|cut -d \\' \\' -f 2)\\n\\nname alice ryan\\nage 21 30\\n"
                    }
                ]
            },
            {
                "id": 1973625,
                "content": [
                    {
                        "username": "illuz",
                        "content": "Is O(n) or O(nlogn) space can solve this problem?  \\n\\nI have a idea:  \\n**Record the \"current position\" of every line and loop.**  \\n\\nBut I don't know how to implement it.  \\n\\nIs there an implement or other ideas?"
                    },
                    {
                        "username": "gemtra",
                        "content": "num=`awk \\'END{print NF}\\' file.txt`\\nfor i in `seq 1 $num`;do cut -d \\' \\' -f $i file.txt|xargs; done"
                    },
                    {
                        "username": "firejox",
                        "content": "seq 1 $(head -1 file.txt | wc -w) | xargs -I \\'{}\\' bash -c \"cut -d \\'\"\\' \\'\"\\' -f {} file.txt| xargs\""
                    },
                    {
                        "username": "caspergao",
                        "content": "# awk \\'{print $1;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\';awk \\'{print $2;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\'\\nname alice ryan \\nage 21 30 "
                    },
                    {
                        "username": "patrickfung",
                        "content": "echo $(cat file.txt|cut -d \\' \\' -f 1) && echo $(cat file.txt|cut -d \\' \\' -f 2)\\n\\nname alice ryan\\nage 21 30\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Flip Game II",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565434,
                "content": [
                    {
                        "username": "SylvanasWindrunner",
                        "content": "I'm not sure why the simple recursive algorithm would work. It replaces every pair of \"++\" in the original string with \"--\" and ask the questions: can my opponent win? \\n\\nHowever, the canWin() function returns true if the current player is \"guarantee a win\", and it returns false if the current player cannot guarantee a win - meaning the current player might win or lose depending on the action of the opponent. If this is the case, why algorithm like [this][1] works?\\n\\n\\n\\n \\n\\n\\n  [1]: https://leetcode.com/discuss/64291/share-my-java-backtracking-solution"
                    },
                    {
                        "username": "n_leetcode",
                        "content": "\"+++++++++\"\\n\\nPlayer a plays: \"+--++++++\"\\nPlayer b plays: \"+--+--+++\"\\nPlayer a plays: \"+--+--+--\"\\nPlayer b\\'s turn, he has no move to play. So (starting) player A wins.\\n\\nwhy does this testcase return false?\\n"
                    },
                    {
                        "username": "sachinppuranik",
                        "content": "Player a plays: \"+--++++++\"\\nPlayer b plays: \"+--++--++\"\\nPlayer a plays: \"+------++\"\\nPlayer b plays: \"+--------\"\\nNow player a has no move."
                    },
                    {
                        "username": "dilit",
                        "content": "You have to account for turn switching.  \nIf A plays +++--++++, B can play in ++++ half to lose in that half, but grab the turn to play first on the +++ side where it wins."
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "Can anyone please confirm why the expected result for the following test case is TRUE?\\n\"++++-++++++\"\\n\\nMy code failed because my alg is giving 'false', but I am a little confused why the OJ gives 'TRUE'. No matter what the first player does, the second player can find a way to eventually win the game. Am I missing some critical info here?"
                    },
                    {
                        "username": "dilit",
                        "content": "On both sides 1st player can make the 2nd player win or lose depending on the 1st player\\'s strategy.  Losing on one side gives an opportunity to win on the other one..."
                    },
                    {
                        "username": "xuankushuocai2",
                        "content": "I\\'m also confused about it. I think this case is false. \"Garanteed to win\" means as long as the first person did the first move, no matter what moves were done after it, the first person will win, right? I don\\'t think it\\'s true for this case. Could anyone tell me the reason to be true? Thank you."
                    },
                    {
                        "username": "yoursyj",
                        "content": "Update:\\n\\nThanks  bravejia for pointing out one case which was missing in my original post.\\n\\nthe winning strategy is that after flip, two strings are still both can-win-or-lose strings. Basically, starting player can choose not to make decision in his first turn.\\n\\nTake \"++++-++++++\" as an example again:\\n\\nA: ++++---++++\\n\\nThis will leave B with two both can-win-or-lose strings. And there will be no further subset can-win-or-lose strings. \\n\\n-----------------------------------------------------------------------\\nOrignal Post:\\n\\nI think  \"++++-++++++\" is a lose. And here is why.\\n\\nBoth ++++ and ++++++ are can-win-or-lose strings. A can-win-or-lose string is a case where first player can choose if he wants to win or lose. \\nFor example, in case of ++++, first player can choose flip middle two to win, or to flip first two to lose.\\n\\nSo in case of two can-win-or-lose strings, or even number of can-win-or-lose strings, second player can always adjust his strategy based on first player's move. \\n\\nTake \"++++-++++++\" as an example, \\n\\nIf A choose to win \"++++\", B can win by winning\"++++++\".\\n\\nA: +--+-++++++\\n\\nB: +--+-++--++\\n\\nIf A choose to lose \"++++\", B can win by losing\"++++++\".\\n\\nA: --++-++++++\\n\\nB: --++-+--+++\\n\\nB can have same strategy If A choose to flip second  can-win-or-lose strings first.\\n\\nSo  \"++++-++++++\" is a lose. Feel free to correct me if I am wrong."
                    },
                    {
                        "username": "harperjiang",
                        "content": "I was using Java and replaced StringBuilder with char array and reduce the running time from 137ms to 11ms. But I don\\'t think StringBuilder is that slow"
                    }
                ]
            },
            {
                "id": 1568060,
                "content": [
                    {
                        "username": "SylvanasWindrunner",
                        "content": "I'm not sure why the simple recursive algorithm would work. It replaces every pair of \"++\" in the original string with \"--\" and ask the questions: can my opponent win? \\n\\nHowever, the canWin() function returns true if the current player is \"guarantee a win\", and it returns false if the current player cannot guarantee a win - meaning the current player might win or lose depending on the action of the opponent. If this is the case, why algorithm like [this][1] works?\\n\\n\\n\\n \\n\\n\\n  [1]: https://leetcode.com/discuss/64291/share-my-java-backtracking-solution"
                    },
                    {
                        "username": "n_leetcode",
                        "content": "\"+++++++++\"\\n\\nPlayer a plays: \"+--++++++\"\\nPlayer b plays: \"+--+--+++\"\\nPlayer a plays: \"+--+--+--\"\\nPlayer b\\'s turn, he has no move to play. So (starting) player A wins.\\n\\nwhy does this testcase return false?\\n"
                    },
                    {
                        "username": "sachinppuranik",
                        "content": "Player a plays: \"+--++++++\"\\nPlayer b plays: \"+--++--++\"\\nPlayer a plays: \"+------++\"\\nPlayer b plays: \"+--------\"\\nNow player a has no move."
                    },
                    {
                        "username": "dilit",
                        "content": "You have to account for turn switching.  \nIf A plays +++--++++, B can play in ++++ half to lose in that half, but grab the turn to play first on the +++ side where it wins."
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "Can anyone please confirm why the expected result for the following test case is TRUE?\\n\"++++-++++++\"\\n\\nMy code failed because my alg is giving 'false', but I am a little confused why the OJ gives 'TRUE'. No matter what the first player does, the second player can find a way to eventually win the game. Am I missing some critical info here?"
                    },
                    {
                        "username": "dilit",
                        "content": "On both sides 1st player can make the 2nd player win or lose depending on the 1st player\\'s strategy.  Losing on one side gives an opportunity to win on the other one..."
                    },
                    {
                        "username": "xuankushuocai2",
                        "content": "I\\'m also confused about it. I think this case is false. \"Garanteed to win\" means as long as the first person did the first move, no matter what moves were done after it, the first person will win, right? I don\\'t think it\\'s true for this case. Could anyone tell me the reason to be true? Thank you."
                    },
                    {
                        "username": "yoursyj",
                        "content": "Update:\\n\\nThanks  bravejia for pointing out one case which was missing in my original post.\\n\\nthe winning strategy is that after flip, two strings are still both can-win-or-lose strings. Basically, starting player can choose not to make decision in his first turn.\\n\\nTake \"++++-++++++\" as an example again:\\n\\nA: ++++---++++\\n\\nThis will leave B with two both can-win-or-lose strings. And there will be no further subset can-win-or-lose strings. \\n\\n-----------------------------------------------------------------------\\nOrignal Post:\\n\\nI think  \"++++-++++++\" is a lose. And here is why.\\n\\nBoth ++++ and ++++++ are can-win-or-lose strings. A can-win-or-lose string is a case where first player can choose if he wants to win or lose. \\nFor example, in case of ++++, first player can choose flip middle two to win, or to flip first two to lose.\\n\\nSo in case of two can-win-or-lose strings, or even number of can-win-or-lose strings, second player can always adjust his strategy based on first player's move. \\n\\nTake \"++++-++++++\" as an example, \\n\\nIf A choose to win \"++++\", B can win by winning\"++++++\".\\n\\nA: +--+-++++++\\n\\nB: +--+-++--++\\n\\nIf A choose to lose \"++++\", B can win by losing\"++++++\".\\n\\nA: --++-++++++\\n\\nB: --++-+--+++\\n\\nB can have same strategy If A choose to flip second  can-win-or-lose strings first.\\n\\nSo  \"++++-++++++\" is a lose. Feel free to correct me if I am wrong."
                    },
                    {
                        "username": "harperjiang",
                        "content": "I was using Java and replaced StringBuilder with char array and reduce the running time from 137ms to 11ms. But I don\\'t think StringBuilder is that slow"
                    }
                ]
            },
            {
                "id": 1567949,
                "content": [
                    {
                        "username": "SylvanasWindrunner",
                        "content": "I'm not sure why the simple recursive algorithm would work. It replaces every pair of \"++\" in the original string with \"--\" and ask the questions: can my opponent win? \\n\\nHowever, the canWin() function returns true if the current player is \"guarantee a win\", and it returns false if the current player cannot guarantee a win - meaning the current player might win or lose depending on the action of the opponent. If this is the case, why algorithm like [this][1] works?\\n\\n\\n\\n \\n\\n\\n  [1]: https://leetcode.com/discuss/64291/share-my-java-backtracking-solution"
                    },
                    {
                        "username": "n_leetcode",
                        "content": "\"+++++++++\"\\n\\nPlayer a plays: \"+--++++++\"\\nPlayer b plays: \"+--+--+++\"\\nPlayer a plays: \"+--+--+--\"\\nPlayer b\\'s turn, he has no move to play. So (starting) player A wins.\\n\\nwhy does this testcase return false?\\n"
                    },
                    {
                        "username": "sachinppuranik",
                        "content": "Player a plays: \"+--++++++\"\\nPlayer b plays: \"+--++--++\"\\nPlayer a plays: \"+------++\"\\nPlayer b plays: \"+--------\"\\nNow player a has no move."
                    },
                    {
                        "username": "dilit",
                        "content": "You have to account for turn switching.  \nIf A plays +++--++++, B can play in ++++ half to lose in that half, but grab the turn to play first on the +++ side where it wins."
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "Can anyone please confirm why the expected result for the following test case is TRUE?\\n\"++++-++++++\"\\n\\nMy code failed because my alg is giving 'false', but I am a little confused why the OJ gives 'TRUE'. No matter what the first player does, the second player can find a way to eventually win the game. Am I missing some critical info here?"
                    },
                    {
                        "username": "dilit",
                        "content": "On both sides 1st player can make the 2nd player win or lose depending on the 1st player\\'s strategy.  Losing on one side gives an opportunity to win on the other one..."
                    },
                    {
                        "username": "xuankushuocai2",
                        "content": "I\\'m also confused about it. I think this case is false. \"Garanteed to win\" means as long as the first person did the first move, no matter what moves were done after it, the first person will win, right? I don\\'t think it\\'s true for this case. Could anyone tell me the reason to be true? Thank you."
                    },
                    {
                        "username": "yoursyj",
                        "content": "Update:\\n\\nThanks  bravejia for pointing out one case which was missing in my original post.\\n\\nthe winning strategy is that after flip, two strings are still both can-win-or-lose strings. Basically, starting player can choose not to make decision in his first turn.\\n\\nTake \"++++-++++++\" as an example again:\\n\\nA: ++++---++++\\n\\nThis will leave B with two both can-win-or-lose strings. And there will be no further subset can-win-or-lose strings. \\n\\n-----------------------------------------------------------------------\\nOrignal Post:\\n\\nI think  \"++++-++++++\" is a lose. And here is why.\\n\\nBoth ++++ and ++++++ are can-win-or-lose strings. A can-win-or-lose string is a case where first player can choose if he wants to win or lose. \\nFor example, in case of ++++, first player can choose flip middle two to win, or to flip first two to lose.\\n\\nSo in case of two can-win-or-lose strings, or even number of can-win-or-lose strings, second player can always adjust his strategy based on first player's move. \\n\\nTake \"++++-++++++\" as an example, \\n\\nIf A choose to win \"++++\", B can win by winning\"++++++\".\\n\\nA: +--+-++++++\\n\\nB: +--+-++--++\\n\\nIf A choose to lose \"++++\", B can win by losing\"++++++\".\\n\\nA: --++-++++++\\n\\nB: --++-+--+++\\n\\nB can have same strategy If A choose to flip second  can-win-or-lose strings first.\\n\\nSo  \"++++-++++++\" is a lose. Feel free to correct me if I am wrong."
                    },
                    {
                        "username": "harperjiang",
                        "content": "I was using Java and replaced StringBuilder with char array and reduce the running time from 137ms to 11ms. But I don\\'t think StringBuilder is that slow"
                    }
                ]
            },
            {
                "id": 1569260,
                "content": [
                    {
                        "username": "SylvanasWindrunner",
                        "content": "I'm not sure why the simple recursive algorithm would work. It replaces every pair of \"++\" in the original string with \"--\" and ask the questions: can my opponent win? \\n\\nHowever, the canWin() function returns true if the current player is \"guarantee a win\", and it returns false if the current player cannot guarantee a win - meaning the current player might win or lose depending on the action of the opponent. If this is the case, why algorithm like [this][1] works?\\n\\n\\n\\n \\n\\n\\n  [1]: https://leetcode.com/discuss/64291/share-my-java-backtracking-solution"
                    },
                    {
                        "username": "n_leetcode",
                        "content": "\"+++++++++\"\\n\\nPlayer a plays: \"+--++++++\"\\nPlayer b plays: \"+--+--+++\"\\nPlayer a plays: \"+--+--+--\"\\nPlayer b\\'s turn, he has no move to play. So (starting) player A wins.\\n\\nwhy does this testcase return false?\\n"
                    },
                    {
                        "username": "sachinppuranik",
                        "content": "Player a plays: \"+--++++++\"\\nPlayer b plays: \"+--++--++\"\\nPlayer a plays: \"+------++\"\\nPlayer b plays: \"+--------\"\\nNow player a has no move."
                    },
                    {
                        "username": "dilit",
                        "content": "You have to account for turn switching.  \nIf A plays +++--++++, B can play in ++++ half to lose in that half, but grab the turn to play first on the +++ side where it wins."
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "Can anyone please confirm why the expected result for the following test case is TRUE?\\n\"++++-++++++\"\\n\\nMy code failed because my alg is giving 'false', but I am a little confused why the OJ gives 'TRUE'. No matter what the first player does, the second player can find a way to eventually win the game. Am I missing some critical info here?"
                    },
                    {
                        "username": "dilit",
                        "content": "On both sides 1st player can make the 2nd player win or lose depending on the 1st player\\'s strategy.  Losing on one side gives an opportunity to win on the other one..."
                    },
                    {
                        "username": "xuankushuocai2",
                        "content": "I\\'m also confused about it. I think this case is false. \"Garanteed to win\" means as long as the first person did the first move, no matter what moves were done after it, the first person will win, right? I don\\'t think it\\'s true for this case. Could anyone tell me the reason to be true? Thank you."
                    },
                    {
                        "username": "yoursyj",
                        "content": "Update:\\n\\nThanks  bravejia for pointing out one case which was missing in my original post.\\n\\nthe winning strategy is that after flip, two strings are still both can-win-or-lose strings. Basically, starting player can choose not to make decision in his first turn.\\n\\nTake \"++++-++++++\" as an example again:\\n\\nA: ++++---++++\\n\\nThis will leave B with two both can-win-or-lose strings. And there will be no further subset can-win-or-lose strings. \\n\\n-----------------------------------------------------------------------\\nOrignal Post:\\n\\nI think  \"++++-++++++\" is a lose. And here is why.\\n\\nBoth ++++ and ++++++ are can-win-or-lose strings. A can-win-or-lose string is a case where first player can choose if he wants to win or lose. \\nFor example, in case of ++++, first player can choose flip middle two to win, or to flip first two to lose.\\n\\nSo in case of two can-win-or-lose strings, or even number of can-win-or-lose strings, second player can always adjust his strategy based on first player's move. \\n\\nTake \"++++-++++++\" as an example, \\n\\nIf A choose to win \"++++\", B can win by winning\"++++++\".\\n\\nA: +--+-++++++\\n\\nB: +--+-++--++\\n\\nIf A choose to lose \"++++\", B can win by losing\"++++++\".\\n\\nA: --++-++++++\\n\\nB: --++-+--+++\\n\\nB can have same strategy If A choose to flip second  can-win-or-lose strings first.\\n\\nSo  \"++++-++++++\" is a lose. Feel free to correct me if I am wrong."
                    },
                    {
                        "username": "harperjiang",
                        "content": "I was using Java and replaced StringBuilder with char array and reduce the running time from 137ms to 11ms. But I don\\'t think StringBuilder is that slow"
                    }
                ]
            },
            {
                "id": 1569057,
                "content": [
                    {
                        "username": "SylvanasWindrunner",
                        "content": "I'm not sure why the simple recursive algorithm would work. It replaces every pair of \"++\" in the original string with \"--\" and ask the questions: can my opponent win? \\n\\nHowever, the canWin() function returns true if the current player is \"guarantee a win\", and it returns false if the current player cannot guarantee a win - meaning the current player might win or lose depending on the action of the opponent. If this is the case, why algorithm like [this][1] works?\\n\\n\\n\\n \\n\\n\\n  [1]: https://leetcode.com/discuss/64291/share-my-java-backtracking-solution"
                    },
                    {
                        "username": "n_leetcode",
                        "content": "\"+++++++++\"\\n\\nPlayer a plays: \"+--++++++\"\\nPlayer b plays: \"+--+--+++\"\\nPlayer a plays: \"+--+--+--\"\\nPlayer b\\'s turn, he has no move to play. So (starting) player A wins.\\n\\nwhy does this testcase return false?\\n"
                    },
                    {
                        "username": "sachinppuranik",
                        "content": "Player a plays: \"+--++++++\"\\nPlayer b plays: \"+--++--++\"\\nPlayer a plays: \"+------++\"\\nPlayer b plays: \"+--------\"\\nNow player a has no move."
                    },
                    {
                        "username": "dilit",
                        "content": "You have to account for turn switching.  \nIf A plays +++--++++, B can play in ++++ half to lose in that half, but grab the turn to play first on the +++ side where it wins."
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "Can anyone please confirm why the expected result for the following test case is TRUE?\\n\"++++-++++++\"\\n\\nMy code failed because my alg is giving 'false', but I am a little confused why the OJ gives 'TRUE'. No matter what the first player does, the second player can find a way to eventually win the game. Am I missing some critical info here?"
                    },
                    {
                        "username": "dilit",
                        "content": "On both sides 1st player can make the 2nd player win or lose depending on the 1st player\\'s strategy.  Losing on one side gives an opportunity to win on the other one..."
                    },
                    {
                        "username": "xuankushuocai2",
                        "content": "I\\'m also confused about it. I think this case is false. \"Garanteed to win\" means as long as the first person did the first move, no matter what moves were done after it, the first person will win, right? I don\\'t think it\\'s true for this case. Could anyone tell me the reason to be true? Thank you."
                    },
                    {
                        "username": "yoursyj",
                        "content": "Update:\\n\\nThanks  bravejia for pointing out one case which was missing in my original post.\\n\\nthe winning strategy is that after flip, two strings are still both can-win-or-lose strings. Basically, starting player can choose not to make decision in his first turn.\\n\\nTake \"++++-++++++\" as an example again:\\n\\nA: ++++---++++\\n\\nThis will leave B with two both can-win-or-lose strings. And there will be no further subset can-win-or-lose strings. \\n\\n-----------------------------------------------------------------------\\nOrignal Post:\\n\\nI think  \"++++-++++++\" is a lose. And here is why.\\n\\nBoth ++++ and ++++++ are can-win-or-lose strings. A can-win-or-lose string is a case where first player can choose if he wants to win or lose. \\nFor example, in case of ++++, first player can choose flip middle two to win, or to flip first two to lose.\\n\\nSo in case of two can-win-or-lose strings, or even number of can-win-or-lose strings, second player can always adjust his strategy based on first player's move. \\n\\nTake \"++++-++++++\" as an example, \\n\\nIf A choose to win \"++++\", B can win by winning\"++++++\".\\n\\nA: +--+-++++++\\n\\nB: +--+-++--++\\n\\nIf A choose to lose \"++++\", B can win by losing\"++++++\".\\n\\nA: --++-++++++\\n\\nB: --++-+--+++\\n\\nB can have same strategy If A choose to flip second  can-win-or-lose strings first.\\n\\nSo  \"++++-++++++\" is a lose. Feel free to correct me if I am wrong."
                    },
                    {
                        "username": "harperjiang",
                        "content": "I was using Java and replaced StringBuilder with char array and reduce the running time from 137ms to 11ms. But I don\\'t think StringBuilder is that slow"
                    }
                ]
            },
            {
                "id": 1707575,
                "content": [
                    {
                        "username": "SylvanasWindrunner",
                        "content": "I'm not sure why the simple recursive algorithm would work. It replaces every pair of \"++\" in the original string with \"--\" and ask the questions: can my opponent win? \\n\\nHowever, the canWin() function returns true if the current player is \"guarantee a win\", and it returns false if the current player cannot guarantee a win - meaning the current player might win or lose depending on the action of the opponent. If this is the case, why algorithm like [this][1] works?\\n\\n\\n\\n \\n\\n\\n  [1]: https://leetcode.com/discuss/64291/share-my-java-backtracking-solution"
                    },
                    {
                        "username": "n_leetcode",
                        "content": "\"+++++++++\"\\n\\nPlayer a plays: \"+--++++++\"\\nPlayer b plays: \"+--+--+++\"\\nPlayer a plays: \"+--+--+--\"\\nPlayer b\\'s turn, he has no move to play. So (starting) player A wins.\\n\\nwhy does this testcase return false?\\n"
                    },
                    {
                        "username": "sachinppuranik",
                        "content": "Player a plays: \"+--++++++\"\\nPlayer b plays: \"+--++--++\"\\nPlayer a plays: \"+------++\"\\nPlayer b plays: \"+--------\"\\nNow player a has no move."
                    },
                    {
                        "username": "dilit",
                        "content": "You have to account for turn switching.  \nIf A plays +++--++++, B can play in ++++ half to lose in that half, but grab the turn to play first on the +++ side where it wins."
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "Can anyone please confirm why the expected result for the following test case is TRUE?\\n\"++++-++++++\"\\n\\nMy code failed because my alg is giving 'false', but I am a little confused why the OJ gives 'TRUE'. No matter what the first player does, the second player can find a way to eventually win the game. Am I missing some critical info here?"
                    },
                    {
                        "username": "dilit",
                        "content": "On both sides 1st player can make the 2nd player win or lose depending on the 1st player\\'s strategy.  Losing on one side gives an opportunity to win on the other one..."
                    },
                    {
                        "username": "xuankushuocai2",
                        "content": "I\\'m also confused about it. I think this case is false. \"Garanteed to win\" means as long as the first person did the first move, no matter what moves were done after it, the first person will win, right? I don\\'t think it\\'s true for this case. Could anyone tell me the reason to be true? Thank you."
                    },
                    {
                        "username": "yoursyj",
                        "content": "Update:\\n\\nThanks  bravejia for pointing out one case which was missing in my original post.\\n\\nthe winning strategy is that after flip, two strings are still both can-win-or-lose strings. Basically, starting player can choose not to make decision in his first turn.\\n\\nTake \"++++-++++++\" as an example again:\\n\\nA: ++++---++++\\n\\nThis will leave B with two both can-win-or-lose strings. And there will be no further subset can-win-or-lose strings. \\n\\n-----------------------------------------------------------------------\\nOrignal Post:\\n\\nI think  \"++++-++++++\" is a lose. And here is why.\\n\\nBoth ++++ and ++++++ are can-win-or-lose strings. A can-win-or-lose string is a case where first player can choose if he wants to win or lose. \\nFor example, in case of ++++, first player can choose flip middle two to win, or to flip first two to lose.\\n\\nSo in case of two can-win-or-lose strings, or even number of can-win-or-lose strings, second player can always adjust his strategy based on first player's move. \\n\\nTake \"++++-++++++\" as an example, \\n\\nIf A choose to win \"++++\", B can win by winning\"++++++\".\\n\\nA: +--+-++++++\\n\\nB: +--+-++--++\\n\\nIf A choose to lose \"++++\", B can win by losing\"++++++\".\\n\\nA: --++-++++++\\n\\nB: --++-+--+++\\n\\nB can have same strategy If A choose to flip second  can-win-or-lose strings first.\\n\\nSo  \"++++-++++++\" is a lose. Feel free to correct me if I am wrong."
                    },
                    {
                        "username": "harperjiang",
                        "content": "I was using Java and replaced StringBuilder with char array and reduce the running time from 137ms to 11ms. But I don\\'t think StringBuilder is that slow"
                    }
                ]
            }
        ]
    },
    {
        "title": "Decode String",
        "question_content": "<p>Given an encoded string, return its decoded string.</p>\n\n<p>The encoding rule is: <code>k[encoded_string]</code>, where the <code>encoded_string</code> inside the square brackets is being repeated exactly <code>k</code> times. Note that <code>k</code> is guaranteed to be a positive integer.</p>\n\n<p>You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <code>k</code>. For example, there will not be input like <code>3a</code> or <code>2[4]</code>.</p>\n\n<p>The test cases are generated so that the length of the output will never exceed <code>10<sup>5</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;3[a]2[bc]&quot;\n<strong>Output:</strong> &quot;aaabcbc&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;3[a2[c]]&quot;\n<strong>Output:</strong> &quot;accaccacc&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;2[abc]3[cd]ef&quot;\n<strong>Output:</strong> &quot;abcabccdcdcdef&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 30</code></li>\n\t<li><code>s</code> consists of lowercase English letters, digits, and square brackets <code>&#39;[]&#39;</code>.</li>\n\t<li><code>s</code> is guaranteed to be <strong>a valid</strong> input.</li>\n\t<li>All the integers in <code>s</code> are in the range <code>[1, 300]</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 87662,
                "title": "python-solution-using-stack",
                "content": "```\\nclass Solution(object):\\n    def decodeString(self, s):\\n        stack = []; curNum = 0; curString = ''\\n        for c in s:\\n            if c == '[':\\n                stack.append(curString)\\n                stack.append(curNum)\\n                curString = ''\\n                curNum = 0\\n            elif c == ']':\\n                num = stack.pop()\\n                prevString = stack.pop()\\n                curString = prevString + num*curString\\n            elif c.isdigit():\\n                curNum = curNum*10 + int(c)\\n            else:\\n                curString += c\\n        return curString\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def decodeString(self, s):\\n        stack = []; curNum = 0; curString = ''\\n        for c in s:\\n            if c == '[':\\n                stack.append(curString)\\n                stack.append(curNum)\\n                curString = ''\\n                curNum = 0\\n            elif c == ']':\\n                num = stack.pop()\\n                prevString = stack.pop()\\n                curString = prevString + num*curString\\n            elif c.isdigit():\\n                curNum = curNum*10 + int(c)\\n            else:\\n                curString += c\\n        return curString\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87543,
                "title": "0ms-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeString(const string& s, int& i) {\\n        string res;\\n        \\n        while (i < s.length() && s[i] != ']') {\\n            if (!isdigit(s[i]))\\n                res += s[i++];\\n            else {\\n                int n = 0;\\n                while (i < s.length() && isdigit(s[i]))\\n                    n = n * 10 + s[i++] - '0';\\n                    \\n                i++; // '['\\n                string t = decodeString(s, i);\\n                i++; // ']'\\n                \\n                while (n-- > 0)\\n                    res += t;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n    string decodeString(string s) {\\n        int i = 0;\\n        return decodeString(s, i);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(const string& s, int& i) {\\n        string res;\\n        \\n        while (i < s.length() && s[i] != ']') {\\n            if (!isdigit(s[i]))\\n                res += s[i++];\\n            else {\\n                int n = 0;\\n                while (i < s.length() && isdigit(s[i]))\\n                    n = n * 10 + s[i++] - '0';\\n                    \\n                i++; // '['\\n                string t = decodeString(s, i);\\n                i++; // ']'\\n                \\n                while (n-- > 0)\\n                    res += t;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n    string decodeString(string s) {\\n        int i = 0;\\n        return decodeString(s, i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87534,
                "title": "simple-java-solution-using-stack",
                "content": "```\\npublic class Solution {\\n    public String decodeString(String s) {\\n        String res = \"\";\\n        Stack<Integer> countStack = new Stack<>();\\n        Stack<String> resStack = new Stack<>();\\n        int idx = 0;\\n        while (idx < s.length()) {\\n            if (Character.isDigit(s.charAt(idx))) {\\n                int count = 0;\\n                while (Character.isDigit(s.charAt(idx))) {\\n                    count = 10 * count + (s.charAt(idx) - '0');\\n                    idx++;\\n                }\\n                countStack.push(count);\\n            }\\n            else if (s.charAt(idx) == '[') {\\n                resStack.push(res);\\n                res = \"\";\\n                idx++;\\n            }\\n            else if (s.charAt(idx) == ']') {\\n                StringBuilder temp = new StringBuilder (resStack.pop());\\n                int repeatTimes = countStack.pop();\\n                for (int i = 0; i < repeatTimes; i++) {\\n                    temp.append(res);\\n                }\\n                res = temp.toString();\\n                idx++;\\n            }\\n            else {\\n                res += s.charAt(idx++);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String decodeString(String s) {\\n        String res = \"\";\\n        Stack<Integer> countStack = new Stack<>();\\n        Stack<String> resStack = new Stack<>();\\n        int idx = 0;\\n        while (idx < s.length()) {\\n            if (Character.isDigit(s.charAt(idx))) {\\n                int count = 0;\\n                while (Character.isDigit(s.charAt(idx))) {\\n                    count = 10 * count + (s.charAt(idx) - '0');\\n                    idx++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 210284,
                "title": "java-recursive",
                "content": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Deque<Character> queue = new LinkedList<>();\\n        for (char c : s.toCharArray()) queue.offer(c);\\n        return helper(queue);\\n    }\\n    \\n    public String helper(Deque<Character> queue) {\\n        StringBuilder sb = new StringBuilder();\\n        int num = 0;\\n        while (!queue.isEmpty()) {\\n            char c= queue.poll();\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + c - \\'0\\';\\n            } else if (c == \\'[\\') {\\n                String sub = helper(queue);\\n                for (int i = 0; i < num; i++) sb.append(sub);   \\n                num = 0;\\n            } else if (c == \\']\\') {\\n                break;\\n            } else {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Deque<Character> queue = new LinkedList<>();\\n        for (char c : s.toCharArray()) queue.offer(c);\\n        return helper(queue);\\n    }\\n    \\n    public String helper(Deque<Character> queue) {\\n        StringBuilder sb = new StringBuilder();\\n        int num = 0;\\n        while (!queue.isEmpty()) {\\n            char c= queue.poll();\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + c - \\'0\\';\\n            } else if (c == \\'[\\') {\\n                String sub = helper(queue);\\n                for (int i = 0; i < num; i++) sb.append(sub);   \\n                num = 0;\\n            } else if (c == \\']\\') {\\n                break;\\n            } else {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87544,
                "title": "clean-c-recursive-solution-with-explanation",
                "content": "Every time we meet a '[', we treat it as a subproblem so call our recursive function to get the content in that '[' and ']'. After that, repeat that content for 'num' times.\\nEvery time we meet a ']', we know a subproblem finished and just return the 'word' we got in this subproblem.\\nPlease notice that the 'pos' is passed by reference, use it to record the position of the original string we are looking at.\\n\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        int pos = 0;\\n        return helper(pos, s);\\n    }\\n    \\n    string helper(int& pos, string s) {\\n        int num=0;\\n        string word = \"\";\\n        for(;pos<s.size(); pos++) {\\n            char cur = s[pos];\\n            if(cur == '[') {\\n                string curStr = helper(++pos, s);\\n                for(;num>0;num--) word += curStr;\\n            } else if (cur >= '0' && cur <='9') {\\n                num = num*10 + cur - '0';\\n            } else if (cur == ']') {\\n                return word;\\n            } else {    // Normal characters\\n                word += cur;\\n            }\\n        }\\n        return word;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        int pos = 0;\\n        return helper(pos, s);\\n    }\\n    \\n    string helper(int& pos, string s) {\\n        int num=0;\\n        string word = \"\";\\n        for(;pos<s.size(); pos++) {\\n            char cur = s[pos];\\n            if(cur == '[') {\\n                string curStr = helper(++pos, s);\\n                for(;num>0;num--) word += curStr;\\n            } else if (cur >= '0' && cur <='9') {\\n                num = num*10 + cur - '0';\\n            } else if (cur == ']') {\\n                return word;\\n            } else {    // Normal characters\\n                word += cur;\\n            }\\n        }\\n        return word;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87563,
                "title": "share-my-python-stack-simple-solution-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def decodeString(self, s):\\n        stack = []\\n        stack.append([\"\", 1])\\n        num = \"\"\\n        for ch in s:\\n            if ch.isdigit():\\n              num += ch\\n            elif ch == '[':\\n                stack.append([\"\", int(num)])\\n                num = \"\"\\n            elif ch == ']':\\n                st, k = stack.pop()\\n                stack[-1][0] += st*k\\n            else:\\n                stack[-1][0] += ch\\n        return stack[0][0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def decodeString(self, s):\\n        stack = []\\n        stack.append([\"\", 1])\\n        num = \"\"\\n        for ch in s:\\n            if ch.isdigit():\\n              num += ch\\n            elif ch == '[':\\n                stack.append([\"\", int(num)])\\n                num = \"\"\\n            elif ch == ']':\\n                st, k = stack.pop()\\n                stack[-1][0] += st*k\\n            else:\\n                stack[-1][0] += ch\\n        return stack[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941309,
                "title": "python-stack-solution-explained",
                "content": "For me it was not medium problem, more like hard, I am not very good at all these parser problems. However if you spend some time on this problem, logic will be not very difficult. The idea is to read symbol by symbol and check options:\\n\\n1. If we see digit, it means that we need to form number, so just do it: multiply already formed number by `10` and add this digit.\\n2. If we see open bracket `[`, it means, that we just right before finished to form our number: so we put it into our stack. Also we put in our stack empty string.\\n3. If we have close bracket `]`, it means that we just finished `[...]` block and what we have in our stack: on the top it is solution for what we have inside bracktes, before we have number of repetitions of this string `rep` and finally, before we have string built previously: so we concatenate `str2` and `str1 * rep`.\\n4. Finally, if we have some other symbol, that is letter, we add it the the last element of our stack.\\n\\nFor better understanding the process, let us consider example `s = 3[a5[c]]4[b]`:\\n1. `[\\'\\']` at first we have stack with empty string.\\n2. `[\\'\\', 3, \\'\\']`, open bracket: now we have stack with 3 elements: empty string, number `3` and empty string.\\n3. `[\\'\\', 3, \\'a\\']`: build our string\\n4. `[\\'\\', 3, \\'a\\', 5, \\'\\']`, open bracket: add number and empty string\\n5. `[\\'\\', 3, \\'a\\', 5, \\'c\\']` build string\\n6. `[\\'\\', 3, \\'accccc\\']` : now we have closing bracket, so we remove last `3` elements and put `accccc` into our stack\\n7. `[\\'acccccacccccaccccc\\']` we again have closing bracket, so we remove last `3` elements and put new one.\\n8. `[\\'acccccacccccaccccc\\', 4, \\'\\']`: open bracket, add number and empty string to stack\\n9. `[\\'acccccacccccaccccc\\', 4, \\'b\\']` build string\\n10. `[\\'acccccacccccacccccbbbb\\']` closing bracket: remove last 3 elements and put one new.\\n\\nFinally, return joined strings from our stack.\\n\\n**Complexity**: we can say, that time and space complexity is `O(m)`, where `m` is size of our answer. Potentially it can be very big, for strings like `999999999999999[a]`, but I do not think leetcode will have such tests.\\n\\n\\n```\\nclass Solution:\\n    def decodeString(self, s):\\n        it, num, stack = 0, 0, [\"\"]\\n        while it < len(s):\\n            if s[it].isdigit():\\n                num = num * 10 + int(s[it])\\n            elif s[it] == \"[\":\\n                stack.append(num)\\n                num = 0\\n                stack.append(\"\")\\n            elif s[it] == \"]\":\\n                str1 = stack.pop()\\n                rep = stack.pop()\\n                str2 = stack.pop()\\n                stack.append(str2 + str1 * rep)\\n            else:\\n                stack[-1] += s[it]              \\n            it += 1           \\n        return \"\".join(stack)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s):\\n        it, num, stack = 0, 0, [\"\"]\\n        while it < len(s):\\n            if s[it].isdigit():\\n                num = num * 10 + int(s[it])\\n            elif s[it] == \"[\":\\n                stack.append(num)\\n                num = 0\\n                stack.append(\"\")\\n            elif s[it] == \"]\":\\n                str1 = stack.pop()\\n                rep = stack.pop()\\n                str2 = stack.pop()\\n                stack.append(str2 + str1 * rep)\\n            else:\\n                stack[-1] += s[it]              \\n            it += 1           \\n        return \"\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87651,
                "title": "c-simple-and-clear-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> chars;\\n        stack<int> nums;\\n        string res;\\n        int num = 0;\\n        for(char c : s) {\\n            if(isdigit(c)) {\\n                num = num*10 + (c-'0');                              \\n            }\\n            else if(isalpha(c)) {\\n                res.push_back(c);                \\n            }\\n            else if(c == '[') {\\n                chars.push(res);\\n                nums.push(num);\\n                res = \"\";\\n                num = 0;\\n            }\\n            else if(c == ']') {\\n                string tmp = res;\\n                for(int i = 0; i < nums.top()-1; ++i) {\\n                    res += tmp;\\n                }\\n                res = chars.top() + res;\\n                chars.pop(); nums.pop();\\n            }\\n        }\\n        return res;\\n     }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> chars;\\n        stack<int> nums;\\n        string res;\\n        int num = 0;\\n        for(char c : s) {\\n            if(isdigit(c)) {\\n                num = num*10 + (c-'0');                              \\n            }\\n            else if(isalpha(c)) {\\n                res.push_back(c);                \\n            }\\n            else if(c == '[') {\\n                chars.push(res);\\n                nums.push(num);\\n                res = \"\";\\n                num = 0;\\n            }\\n            else if(c == ']') {\\n                string tmp = res;\\n                for(int i = 0; i < nums.top()-1; ++i) {\\n                    res += tmp;\\n                }\\n                res = chars.top() + res;\\n                chars.pop(); nums.pop();\\n            }\\n        }\\n        return res;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472087,
                "title": "0ms-c-solution-using-one-stack",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    string decodeString(string s) {\\n        stack<char> st;\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] != \\']\\') {\\n                st.push(s[i]);\\n            }\\n            else{\\n                string curr_str = \"\";\\n                \\n                while(st.top() != \\'[\\'){\\n                    curr_str = st.top() + curr_str ;\\n                    st.pop();\\n                }\\n                \\n                st.pop();   // for \\'[\\'\\n                string number = \"\";\\n                \\n                // for calculating number\\n                \\n                while(!st.empty() && isdigit(st.top())){\\n                    number = st.top() + number;\\n                    st.pop();\\n                }\\n                int k_time = stoi(number);    // convert string to number\\n                \\n                while(k_time--){\\n                    for(int p = 0; p < curr_str.size() ; p++)\\n                        st.push(curr_str[p]);\\n                }\\n            }\\n        }\\n        \\n        s = \"\";\\n        while(!st.empty()){\\n            s = st.top() + s;\\n            st.pop();\\n        }\\n        return s;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    string decodeString(string s) {\\n        stack<char> st;\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] != \\']\\') {\\n                st.push(s[i]);\\n            }\\n            else{\\n                string curr_str = \"\";\\n                \\n                while(st.top() != \\'[\\'){\\n                    curr_str = st.top() + curr_str ;\\n                    st.pop();\\n                }\\n                \\n                st.pop();   // for \\'[\\'\\n                string number = \"\";\\n                \\n                // for calculating number\\n                \\n                while(!st.empty() && isdigit(st.top())){\\n                    number = st.top() + number;\\n                    st.pop();\\n                }\\n                int k_time = stoi(number);    // convert string to number\\n                \\n                while(k_time--){\\n                    for(int p = 0; p < curr_str.size() ; p++)\\n                        st.push(curr_str[p]);\\n                }\\n            }\\n        }\\n        \\n        s = \"\";\\n        while(!st.empty()){\\n            s = st.top() + s;\\n            st.pop();\\n        }\\n        return s;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332601,
                "title": "c-java-python-bracket-matching-recursion-easy-to-understand-clean-concise",
                "content": "**Idea**\\n- Example: `\"3[a2[c]]\"`\\n- Iterate to find the position of the matching **close bracket** for an **open bracket**, let name it `closePos`.\\n\\t- In the above example: `closePos[1] = 7, closePos[4] = 6`.\\n- Build a `dfs(l, r)` function to return decoded string from index left `l` to `r` (inclusive):\\n\\t- Iterate from i in range `[l..r]`\\n\\t\\t- If `s[i]` is digit then `num = num * 10 + int(s[i])`\\n\\t\\t- Else if `s[i]` == `[` then `ans += num * dfs(i + 1, closePos[i] - 1)`\\n\\t\\t- Else `ans += s[i]`\\n- Return `dfs(0, len(s) - 1)`.\\n\\n<iframe src=\"https://leetcode.com/playground/3Ju2heYr/shared\" frameBorder=\"0\" width=\"100%\" height=\"680\"></iframe>\\n\\n**Complexity:**\\n- Time: `O(M)`, where `M` is the size of the output answer.\\n- Space: `O(M)`",
                "solutionTags": [],
                "code": "**Idea**\\n- Example: `\"3[a2[c]]\"`\\n- Iterate to find the position of the matching **close bracket** for an **open bracket**, let name it `closePos`.\\n\\t- In the above example: `closePos[1] = 7, closePos[4] = 6`.\\n- Build a `dfs(l, r)` function to return decoded string from index left `l` to `r` (inclusive):\\n\\t- Iterate from i in range `[l..r]`\\n\\t\\t- If `s[i]` is digit then `num = num * 10 + int(s[i])`\\n\\t\\t- Else if `s[i]` == `[` then `ans += num * dfs(i + 1, closePos[i] - 1)`\\n\\t\\t- Else `ans += s[i]`\\n- Return `dfs(0, len(s) - 1)`.\\n\\n<iframe src=\"https://leetcode.com/playground/3Ju2heYr/shared\" frameBorder=\"0\" width=\"100%\" height=\"680\"></iframe>\\n\\n**Complexity:**\\n- Time: `O(M)`, where `M` is the size of the output answer.\\n- Space: `O(M)`",
                "codeTag": "Unknown"
            },
            {
                "id": 87556,
                "title": "java-short-and-easy-understanding-solution-using-stack",
                "content": "```\\npublic class Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> count = new Stack<>();\\n        Stack<String> result = new Stack<>();\\n        int i = 0;\\n        result.push(\"\");\\n        while (i < s.length()) {\\n            char ch = s.charAt(i);\\n            if (ch >= '0' && ch <= '9') {\\n                int start = i;\\n                while (s.charAt(i + 1) >= '0' && s.charAt(i + 1) <= '9') i++;\\n                count.push(Integer.parseInt(s.substring(start, i + 1)));\\n            } else if (ch == '[') {\\n                result.push(\"\");\\n            } else if (ch == ']') {\\n                String str = result.pop();\\n                StringBuilder sb = new StringBuilder();\\n                int times = count.pop();\\n                for (int j = 0; j < times; j += 1) {\\n                    sb.append(str);\\n                }\\n                result.push(result.pop() + sb.toString());\\n            } else {\\n                result.push(result.pop() + ch);\\n            }\\n            i += 1;\\n        }\\n        return result.pop();\\n    }\\n}\\n```\\nQuite clear, isn't it?",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> count = new Stack<>();\\n        Stack<String> result = new Stack<>();\\n        int i = 0;\\n        result.push(\"\");\\n        while (i < s.length()) {\\n            char ch = s.charAt(i);\\n            if (ch >= '0' && ch <= '9') {\\n                int start = i;\\n                while (s.charAt(i + 1) >= '0' && s.charAt(i + 1) <= '9') i++;\\n                count.push(Integer.parseInt(s.substring(start, i + 1)));\\n            } else if (ch == '[') {\\n                result.push(\"\");\\n            } else if (ch == ']') {\\n                String str = result.pop();\\n                StringBuilder sb = new StringBuilder();\\n                int times = count.pop();\\n                for (int j = 0; j < times; j += 1) {\\n                    sb.append(str);\\n                }\\n                result.push(result.pop() + sb.toString());\\n            } else {\\n                result.push(result.pop() + ch);\\n            }\\n            i += 1;\\n        }\\n        return result.pop();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87536,
                "title": "3-lines-python-2-lines-ruby-regular-expression",
                "content": "## Python\\n\\n    def decodeString(self, s):\\n        while '[' in s:\\n            s = re.sub(r'(\\\\d+)\\\\[([a-z]*)\\\\]', lambda m: int(m.group(1)) * m.group(2), s)\\n        return s\\n\\nSubmitted once, got accepted in 32 ms.\\n\\n## Ruby\\n\\n```\\ndef decode_string(s)\\n  1 while s.gsub!(/(\\\\d+)\\\\[([a-z]*)\\\\]/) { $2 * $1.to_i }\\n  s\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef decode_string(s)\\n  1 while s.gsub!(/(\\\\d+)\\\\[([a-z]*)\\\\]/) { $2 * $1.to_i }\\n  s\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 87570,
                "title": "simple-1-pass-java-solution-with-only-1-stack-with-explanation",
                "content": "We don't have to use more than one stack. the concept is simple : If you see a closing bracket, repeat the string it contains inside given number of time and then push it back. [Recursion call, turned into iteration]. \\n\\n```\\npublic String decodeString(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        \\n        for(char c : s.toCharArray())\\n        {\\n            if(c != ']') \\n                stack.push(c); //push everything but ]\\n            \\n            else \\n            {\\n                //step 1: \\n                    //if you find a closing ] then \\n                   //retrieve the string it encapsulates\\n                \\n                StringBuilder sb = new StringBuilder();\\n                while(!stack.isEmpty() && Character.isLetter(stack.peek()))\\n                    sb.insert(0, stack.pop());\\n                \\n                String sub = sb.toString(); //this is the string contained in [ ]\\n                stack.pop(); //Discard the '[';\\n                \\n                \\n                //step 2: \\n                    //after that get the number of\\n                  // times it should repeat from stack\\n                    \\n                sb = new StringBuilder();\\n                while(!stack.isEmpty() && Character.isDigit(stack.peek()))\\n                    sb.insert(0, stack.pop());\\n                    \\n                int count = Integer.valueOf(sb.toString()); //this is the number\\n                \\n                \\n                //step 3: \\n                    //repeat the string within the [ ] count \\n                  //number of times and push it back into stack\\n                \\n                while(count > 0)\\n                {\\n                    for(char ch : sub.toCharArray())  \\n                        stack.push(ch);\\n                    count--;\\n                }\\n            }\\n        }\\n        \\n      //final fetching and returning the value in stack \\n        StringBuilder retv = new StringBuilder();\\n        while(!stack.isEmpty())\\n            retv.insert(0, stack.pop());\\n\\n        return retv.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\npublic String decodeString(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        \\n        for(char c : s.toCharArray())\\n        {\\n            if(c != ']') \\n                stack.push(c); //push everything but ]\\n            \\n            else \\n            {\\n                //step 1: \\n                    //if you find a closing ] then \\n                   //retrieve the string it encapsulates\\n                \\n                StringBuilder sb = new StringBuilder();\\n                while(!stack.isEmpty() && Character.isLetter(stack.peek()))\\n                    sb.insert(0, stack.pop());\\n                \\n                String sub = sb.toString(); //this is the string contained in [ ]\\n                stack.pop(); //Discard the '[';\\n                \\n                \\n                //step 2: \\n                    //after that get the number of\\n                  // times it should repeat from stack\\n                    \\n                sb = new StringBuilder();\\n                while(!stack.isEmpty() && Character.isDigit(stack.peek()))\\n                    sb.insert(0, stack.pop());\\n                    \\n                int count = Integer.valueOf(sb.toString()); //this is the number\\n                \\n                \\n                //step 3: \\n                    //repeat the string within the [ ] count \\n                  //number of times and push it back into stack\\n                \\n                while(count > 0)\\n                {\\n                    for(char ch : sub.toCharArray())  \\n                        stack.push(ch);\\n                    count--;\\n                }\\n            }\\n        }\\n        \\n      //final fetching and returning the value in stack \\n        StringBuilder retv = new StringBuilder();\\n        while(!stack.isEmpty())\\n            retv.insert(0, stack.pop());\\n\\n        return retv.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 384193,
                "title": "javascript-easy-to-understand-using-stack-44ms",
                "content": "- Traversal the string `s` and push into a stack for non-`]` character\\n- When we meets the `]` character, we should do these steps\\n\\t- pop all characters until meets `[`\\n\\t- pop all numbers to get the repeat count\\n\\t- repeat the substring and push it back to stack\\n- Finally, we `join` all the pieces in the stack\\n\\n```js\\nconst decodeString = s => {\\n  const stack = [];\\n  for (const char of s) {\\n    if (char !== \"]\") { stack.push(char); continue; }\\n    let cur = stack.pop();\\n    let str = \\'\\';\\n    while (cur !== \\'[\\') {\\n      str = cur + str;\\n      cur = stack.pop();\\n    }\\n    let num = \\'\\';\\n    cur = stack.pop();\\n    while (!Number.isNaN(Number(cur))) {\\n      num = cur + num;\\n      cur = stack.pop();\\n    }\\n    stack.push(cur);\\n    stack.push(str.repeat(Number(num)));\\n  }\\n  return stack.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst decodeString = s => {\\n  const stack = [];\\n  for (const char of s) {\\n    if (char !== \"]\") { stack.push(char); continue; }\\n    let cur = stack.pop();\\n    let str = \\'\\';\\n    while (cur !== \\'[\\') {\\n      str = cur + str;\\n      cur = stack.pop();\\n    }\\n    let num = \\'\\';\\n    cur = stack.pop();\\n    while (!Number.isNaN(Number(cur))) {\\n      num = cur + num;\\n      cur = stack.pop();\\n    }\\n    stack.push(cur);\\n    stack.push(str.repeat(Number(num)));\\n  }\\n  return stack.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87615,
                "title": "simple-java-dfs-solution",
                "content": "```\\npublic class Solution {\\n    private int pos = 0;\\n    public String decodeString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        String num = \"\";\\n        for (int i = pos; i < s.length(); i++) {\\n            if (s.charAt(i) != '[' && s.charAt(i) != ']' && !Character.isDigit(s.charAt(i))) {\\n                sb.append(s.charAt(i));\\n            } else if (Character.isDigit(s.charAt(i))) {\\n                num += s.charAt(i);\\n            } else if (s.charAt(i) == '[') {\\n                pos = i + 1;\\n                String next = decodeString(s);\\n                for (int n = Integer.valueOf(num); n > 0; n--) sb.append(next);\\n                num = \"\";\\n                i = pos;\\n            } else if (s.charAt(i) == ']') {\\n                pos = i;\\n                return sb.toString();\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private int pos = 0;\\n    public String decodeString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        String num = \"\";\\n        for (int i = pos; i < s.length(); i++) {\\n            if (s.charAt(i) != '[' && s.charAt(i) != ']' && !Character.isDigit(s.charAt(i))) {\\n                sb.append(s.charAt(i));\\n            } else if (Character.isDigit(s.charAt(i))) {\\n                num += s.charAt(i);\\n            } else if (s.charAt(i) == '[') {\\n                pos = i + 1;\\n                String next = decodeString(s);\\n                for (int n = Integer.valueOf(num); n > 0; n--) sb.append(next);\\n                num = \"\";\\n                i = pos;\\n            } else if (s.charAt(i) == ']') {\\n                pos = i;\\n                return sb.toString();\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 586930,
                "title": "explained-python-solution-using-single-stack",
                "content": "\\nExplanation:\\nSolved using stack\\n1. Possible inputs are - \\'[\\' , \\']\\', alphabet(s) or numbers. Lets talk about each one by one.\\n\\n2. We will start for loop for traversing through each element of \\'s\\'. If we encounter a number, it will be handled by checking isdigit() condition. curNum10+int(c) helps in storing the number in curnum ,when the number is more than single digit.\\n\\n3.When we encounter a character, we will start it adding to a string named curString. The character can be single or multiple. curString+=c will keep the character string.\\n\\n4.The easy part is over.Now, when we encounter \\'[\\' it means thats a start of a new substring, meaning the previous substring (if there was one) has already been traversed and handled. So , we will append the current curString and curNum to stack and,  reset our curString as empty string and curNum as 0 to use in further porcessing as we have a open bracket which means start of a new substring.\\n\\n5.Finally when we encounter a close bracket \\']\\', it certainely means we have reached where our substring is complete, now we have to find a way to calculate it. Thats when we go back to stack to find what we have stored there which will help us in calculating the current substring. In the stack we will find a number on top which is popped and then a previous string which we will need to add with the curstringnum, and everything will be stored in curString after calculation.  \\n\\n6.The calculated curstring will be returned as answer if \\'s\\' is over else it will be again appended to stack when an open bracket is encountered. And the above process will be repeated per condition.\\n\\n\\n```\\n\\nclass Solution(object):\\n    def decodeString(self, s):\\n        stack = []; curNum = 0; curString = \\'\\'\\n        for c in s:\\n            if c == \\'[\\':\\n                stack.append(curString)\\n                stack.append(curNum)\\n                curString = \\'\\'\\n                curNum = 0\\n            elif c == \\']\\':\\n                num = stack.pop()\\n                prevString = stack.pop()\\n                curString = prevString + num*curString\\n            elif c.isdigit():     # curNum*10+int(c) is helpful in keep track of more than 1 digit number\\n                curNum = curNum*10 + int(c)\\n            else:\\n                curString += c\\n        return curString\\n```\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution(object):\\n    def decodeString(self, s):\\n        stack = []; curNum = 0; curString = \\'\\'\\n        for c in s:\\n            if c == \\'[\\':\\n                stack.append(curString)\\n                stack.append(curNum)\\n                curString = \\'\\'\\n                curNum = 0\\n            elif c == \\']\\':\\n                num = stack.pop()\\n                prevString = stack.pop()\\n                curString = prevString + num*curString\\n            elif c.isdigit():     # curNum*10+int(c) is helpful in keep track of more than 1 digit number\\n                curNum = curNum*10 + int(c)\\n            else:\\n                curString += c\\n        return curString\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635464,
                "title": "c-python-clean-simple-solutions-w-explanation-recursive-iterative-using-custom-stack",
                "content": "We are given an encoded string with rule: `k[encoded_string]` and we need to return the decoded string.\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Recursion)***\\n\\nIt\\'s important to observe the pattern of the encoded string. The encoded string is of the format - \\n\\n```\\n\"alphabets + number[encoded_string] + alphabets + number[encoded_string] + ... + alphabets\"\\n```\\n\\nEach of the term is optional which means string may or may not start/end with alphabets or contain numbers within it. Some examples are `\"ab2[cd]ef\"`, `\"2[cd]ef\"`, `\"ab2[cd]\"`, `\"abef\"`, `\"ab2[cd]ef3[gh]ij\"` and so on...\\n\\nAlso, each of encoded-string in bracket is itself an encoded string and thus it can also contain a string with similar format as mentioned above. Thus, an encoded string may consists of multiple encoded string recursively. This gives us the intuition to solve this problem recursively. \\n* Each time we decode **1st part of encoded string which string of alphabets**. We can simply add these to the final string directly.\\n* Then we decode the **2nd part of encoded string which is a digits followed by next level of encoded string**. We form the number from digits and recurse for next level of encoded string.\\n* Each recursive call will return the decoded string of the encoded string present on that level. The recursive call will return / end when we reach the end of string (only possible in base level) or find an extra closing bracket which denotes end of current level.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int i = 0;                                                // global variable used to track current index\\n    string repeat(string s, int times) {                      // repeats a string for given number of times\\n        for(int n = size(s); --times; s += s.substr(0, n));\\n        return s;\\n    }\\n    string decodeString(string& s) {\\n        string ans = \"\", n = \"\";\\n        while(i < size(s) && s[i] != \\']\\') {                   // loop till reach end or decode current level by reaching \\']\\'\\n            for(; i < size(s) && isalpha(s[i]); i++)          // 1st part\\n                ans += s[i]; \\n            if(i >= size(s) || s[i] == \\']\\') continue;         // skip if next part doesn\\'t contain number\\n            for(n = \"\"; i < size(s) && isdigit(s[i]); i++)    // 2nd part\\n                n += s[i];\\n            i++;                                              // skip opening bracket   \\n            ans += repeat(decodeString(s), stoi(n));          // repeats string decoded from bracket n times\\n            i++;                                              // skip closing bracket    \\n        } \\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def decodeString(self, s):\\n        def decode(i):\\n            ans = \"\"\\n            while i < len(s) and s[i] != \\']\\':\\n                while i < len(s) and s[i].isalpha():\\n                    ans += s[i]\\n                    i += 1\\n                if i >= len(s) or s[i] == \\']\\': continue\\n                n = \"\"\\n                while i < len(s) and s[i].isdigit():\\n                    n += s[i]\\n                    i += 1\\n                tmp, i = decode(i+1)\\n                ans += tmp * int(n)\\n            return (ans, i+1)\\n        return decode(0)[0]\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, where `N` is the length of output\\n***Space Complexity :*** `O(L)`, where `L` is the maximum depth/levels of nested encoded string\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Using Custom Stack)***\\n\\nA solution with similar logic as above but the iterative version using explicit custom stack. \\n* As done above, for string of alphabets, we will simply add them to `ans`. \\n* If we get digits, we add them in `n` string till we find `[`\\n* Once we find `[`, we will push `n` and `ans` formed till now\\n* When we find `]`, we will pop top element (denoted by `cnt` and `prev` in the code below) which will be count to repeat string formed in this level and the previous string formed. We simply repeat current string `ans` for `cnt` number of times and add it to `prev` string.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    string repeat(string& s, int times) {\\n        for(int n = size(s); --times; s += s.substr(0, n));\\n        return s;\\n    }    \\n    string decodeString(string& s) {\\n        stack<pair<string, string>> stk;                          // {n, ans} = {count to repeat, string formed in this level till now}\\n        string ans = \"\", n = \"\";\\n        for(auto c : s)\\n            if(isalpha(c))      ans += c;\\n            else if(isdigit(c)) n += c;\\n            else if(c == \\'[\\')   stk.push({move(n), move(ans)});   // directly moves into stack avoiding copy & thus also clears n and ans\\n            else {\\n                auto [cnt, prev] = stk.top(); stk.pop();\\n                ans = prev + repeat(ans, stoi(cnt));\\n            }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def decodeString(self, s):\\n        stk, ans, n = deque(), \"\", \"\"\\n        for c in s:\\n            if c.isalpha():   ans += c\\n            elif c.isdigit(): n += c\\n            elif c == \\'[\\': \\n                stk.append((n, ans))\\n                n, ans = \"\", \"\"\\n            else:\\n                cnt, prev = stk.pop()\\n                ans = prev + ans * int(cnt)\\n        return ans\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>\\n***Space Complexity :*** `O(L)`\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```\\n\"alphabets + number[encoded_string] + alphabets + number[encoded_string] + ... + alphabets\"\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int i = 0;                                                // global variable used to track current index\\n    string repeat(string s, int times) {                      // repeats a string for given number of times\\n        for(int n = size(s); --times; s += s.substr(0, n));\\n        return s;\\n    }\\n    string decodeString(string& s) {\\n        string ans = \"\", n = \"\";\\n        while(i < size(s) && s[i] != \\']\\') {                   // loop till reach end or decode current level by reaching \\']\\'\\n            for(; i < size(s) && isalpha(s[i]); i++)          // 1st part\\n                ans += s[i]; \\n            if(i >= size(s) || s[i] == \\']\\') continue;         // skip if next part doesn\\'t contain number\\n            for(n = \"\"; i < size(s) && isdigit(s[i]); i++)    // 2nd part\\n                n += s[i];\\n            i++;                                              // skip opening bracket   \\n            ans += repeat(decodeString(s), stoi(n));          // repeats string decoded from bracket n times\\n            i++;                                              // skip closing bracket    \\n        } \\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def decodeString(self, s):\\n        def decode(i):\\n            ans = \"\"\\n            while i < len(s) and s[i] != \\']\\':\\n                while i < len(s) and s[i].isalpha():\\n                    ans += s[i]\\n                    i += 1\\n                if i >= len(s) or s[i] == \\']\\': continue\\n                n = \"\"\\n                while i < len(s) and s[i].isdigit():\\n                    n += s[i]\\n                    i += 1\\n                tmp, i = decode(i+1)\\n                ans += tmp * int(n)\\n            return (ans, i+1)\\n        return decode(0)[0]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string repeat(string& s, int times) {\\n        for(int n = size(s); --times; s += s.substr(0, n));\\n        return s;\\n    }    \\n    string decodeString(string& s) {\\n        stack<pair<string, string>> stk;                          // {n, ans} = {count to repeat, string formed in this level till now}\\n        string ans = \"\", n = \"\";\\n        for(auto c : s)\\n            if(isalpha(c))      ans += c;\\n            else if(isdigit(c)) n += c;\\n            else if(c == \\'[\\')   stk.push({move(n), move(ans)});   // directly moves into stack avoiding copy & thus also clears n and ans\\n            else {\\n                auto [cnt, prev] = stk.top(); stk.pop();\\n                ans = prev + repeat(ans, stoi(cnt));\\n            }\\n\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def decodeString(self, s):\\n        stk, ans, n = deque(), \"\", \"\"\\n        for c in s:\\n            if c.isalpha():   ans += c\\n            elif c.isdigit(): n += c\\n            elif c == \\'[\\': \\n                stk.append((n, ans))\\n                n, ans = \"\", \"\"\\n            else:\\n                cnt, prev = stk.pop()\\n                ans = prev + ans * int(cnt)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163479,
                "title": "python-short-and-simple-stack-solution-beats-100-with-explanation",
                "content": "The solution is a simple stack based one which evalutes the innermost brackets first. You iterate through the string, and push everything to a stack until you\\'ve found a right bracket. Once you\\'ve found a right bracket, you use that and pop from the stack to evaluate the innermost expression in the string. For example, if you have `2[a3[b]]`, your stack would be ` [2, \"[\", \"a\", 3, \"[\", \"b\"] ` when it reaches the first right bracket. Once it reaches the first right bracket, it attempts to evaluate everything in the innermost bracket by popping from the stack to form the entire string you need to multiply, and finding the number you need to multiply by. After this, the stack will look like: `[2, \"[\", \"a\", \"bbb\" ]`. The innermost expression of `3, \"[\", \"b\"` was turned into `bbb` and put back into the stack. At the next right bracket, we will similarily evaluate the innermost bracket , so that the stack turns into `[\"abbbabbb\"]`. If there are multiple sets of enclosed brackets in the expression, our stack will end up with multiple strings in the end. Simply join them for the result. \\n\\n```\\n    def decodeString(self, s):\\n        stack = []\\n        for i in range(len(s)):\\n            if s[i] == \"]\":\\n                current = \\'\\'\\n                while stack:\\n                    val = stack.pop()\\n                    if val ==  \"[\":\\n                        break\\n                    current = val + current\\n                num = \\'\\'\\n                while stack and stack[-1].isdigit():\\n                    num = stack.pop() + num\\n                stack.append(int(num)*current)\\n            else:\\n                stack.append(s[i])\\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [],
                "code": "```\\n    def decodeString(self, s):\\n        stack = []\\n        for i in range(len(s)):\\n            if s[i] == \"]\":\\n                current = \\'\\'\\n                while stack:\\n                    val = stack.pop()\\n                    if val ==  \"[\":\\n                        break\\n                    current = val + current\\n                num = \\'\\'\\n                while stack and stack[-1].isdigit():\\n                    num = stack.pop() + num\\n                stack.append(int(num)*current)\\n            else:\\n                stack.append(s[i])\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 810400,
                "title": "clean-java-solution-beats-100-stringbuilder",
                "content": "Clean solution easy to understand. The idea is similar to [basic calculator](https://leetcode.com/problems/basic-calculator/). We use a counter `i` to keep track of our progress in string `s` and recursively calculate subproblems quoted by `[]`.\\n\\n\\n    int i = 0;\\n    public String decodeString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = 0;\\n        String tmp_string = \"\";\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            i++;\\n            \\n            if (c == \\'[\\') {\\n                tmp_string = decodeString(s); // do subproblem\\n                for (int j = 0; j < count; j++) {\\n                    sb.append(tmp_string);\\n                }\\n                count = 0; // reset counter\\n            } else if (c == \\']\\') { // subproblem complete\\n                break;\\n            } else if (Character.isAlphabetic(c)) {\\n                sb.append(c);\\n            } else {\\n                count = count * 10 + c - \\'0\\';\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Recursion"
                ],
                "code": "Clean solution easy to understand. The idea is similar to [basic calculator](https://leetcode.com/problems/basic-calculator/). We use a counter `i` to keep track of our progress in string `s` and recursively calculate subproblems quoted by `[]`.\\n\\n\\n    int i = 0;\\n    public String decodeString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = 0;\\n        String tmp_string = \"\";\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            i++;\\n            \\n            if (c == \\'[\\') {\\n                tmp_string = decodeString(s); // do subproblem\\n                for (int j = 0; j < count; j++) {\\n                    sb.append(tmp_string);\\n                }\\n                count = 0; // reset counter\\n            } else if (c == \\']\\') { // subproblem complete\\n                break;\\n            } else if (Character.isAlphabetic(c)) {\\n                sb.append(c);\\n            } else {\\n                count = count * 10 + c - \\'0\\';\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 87567,
                "title": "java-simple-recursive-solution",
                "content": "the run time is 3 ms. And the method is really straight-forward: every time when you meet a number, it must be followed by [...], we just need to recursively call our method to decode \"...\", then repeat the result \"num\" times.\\n\\n'''\\npublic class Solution {\\n    public String decodeString(String s) {\\n\\n        if (s.length() == 0) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < s.length(); i ++) {\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c)) {\\n                int digit_begin = i;\\n                while (s.charAt(i) != '[') i++;\\n                int num = Integer.valueOf(s.substring(digit_begin, i));\\n                int count = 1;\\n                int str_begin = i+1;\\n                i ++;\\n                while (count != 0) {\\n                    if (s.charAt(i) == '[') count ++;\\n                    else if (s.charAt(i) == ']') count --;\\n                    i ++;\\n                }\\n                i--;\\n                String str = decodeString(s.substring(str_begin, i));\\n                for (int j = 0; j < num; j ++) {\\n                    sb.append(str);\\n                }\\n            } else {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n'''",
                "solutionTags": [],
                "code": "class Solution {\\n    public String decodeString(String s) {\\n\\n        if (s.length() == 0) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < s.length(); i ++) {\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c)) {\\n                int digit_begin = i;\\n                while (s.charAt(i) != '[') i++;\\n                int num = Integer.valueOf(s.substring(digit_begin, i));\\n                int count = 1;\\n                int str_begin = i+1;\\n                i ++;\\n                while (count != 0) {\\n                    if (s.charAt(i) == '[') count ++;\\n                    else if (s.charAt(i) == ']') count --;\\n                    i ++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3224703,
                "title": "stack-java-1ms-beat",
                "content": "\\n# Approach\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer>numStack=new Stack<>();\\n        Stack<StringBuilder>strBuild=new Stack<>();\\n        StringBuilder str = new StringBuilder();\\n        int num=0;\\n        for(char c:s.toCharArray()){\\n            if(c>=\\'0\\' && c<=\\'9\\'){\\n                num=num*10 +c -\\'0\\';\\n            }\\n            else if(c==\\'[\\'){\\n                strBuild.push(str);\\n                str=new StringBuilder();\\n                numStack.push(num);\\n                num=0;\\n            }else if(c==\\']\\'){\\n                StringBuilder temp=str;\\n                str=strBuild.pop();\\n                int count=numStack.pop();\\n                while(count-->0){\\n                    str.append(temp);\\n                }\\n            }else{\\n                str.append(c);\\n            }\\n        }\\n        return str.toString();\\n    }   \\n}\\n```\\n\\n![8873f9b1-dfa4-4d9c-bb67-1b6db9d65e35_1674992431.3815322.jpeg](https://assets.leetcode.com/users/images/87473a41-9c53-4e65-967e-15f92ebc9310_1677233624.267395.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer>numStack=new Stack<>();\\n        Stack<StringBuilder>strBuild=new Stack<>();\\n        StringBuilder str = new StringBuilder();\\n        int num=0;\\n        for(char c:s.toCharArray()){\\n            if(c>=\\'0\\' && c<=\\'9\\'){\\n                num=num*10 +c -\\'0\\';\\n            }\\n            else if(c==\\'[\\'){\\n                strBuild.push(str);\\n                str=new StringBuilder();\\n                numStack.push(num);\\n                num=0;\\n            }else if(c==\\']\\'){\\n                StringBuilder temp=str;\\n                str=strBuild.pop();\\n                int count=numStack.pop();\\n                while(count-->0){\\n                    str.append(temp);\\n                }\\n            }else{\\n                str.append(c);\\n            }\\n        }\\n        return str.toString();\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400105,
                "title": "98-faster-with-and-without-stack-cleane-concise",
                "content": "## IDEA :\\n**Using stack** to store the previously stored string and the number which we have to use instantly after bracket(if any) gets closed.\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        \\n        res,num = \"\",0\\n        st = []\\n        for c in s:\\n            if c.isdigit():\\n                num = num*10+int(c)    \\n            elif c==\"[\":\\n                st.append(res)\\n                st.append(num)\\n                res=\"\"\\n                num=0\\n            elif c==\"]\":\\n                pnum = st.pop()\\n                pstr = st.pop()\\n                res = pstr + pnum*res\\n            else:\\n                res+=c\\n        \\n        return res\\n\\t\\t\\n****\\n### IDEA :\\n**Using RECURSION :**\\n\\'\\'\\'\\n\\t\\n\\tclass Solution:\\n    def decodeString(self, s: str) -> str:       \\n        def dfs(s,p):\\n            res = \"\"\\n            i,num = p,0\\n            while i<len(s):\\n                asc = (ord(s[i])-48)\\n                if 0<=asc<=9:           # can also be written as if s[i].isdigit()\\n                    num=num*10+asc\\n                elif s[i]==\"[\":\\n                    local,pos = dfs(s,i+1)\\n                    res+=local*num\\n                    i=pos\\n                    num=0\\n                elif s[i]==\"]\":\\n                    return res,i\\n                else:\\n                    res+=s[i]\\n                i+=1\\n            return res,i\\n        \\n        return dfs(s,0)[0]\\n\\t\\t\\n***Thanks*** and feel free to ask if you have any doubt!! \\uD83E\\uDD17\\n**Upvote** if you found interesting !!\\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Recursion"
                ],
                "code": "## IDEA :\\n**Using stack** to store the previously stored string and the number which we have to use instantly after bracket(if any) gets closed.\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        \\n        res,num = \"\",0\\n        st = []\\n        for c in s:\\n            if c.isdigit():\\n                num = num*10+int(c)    \\n            elif c==\"[\":\\n                st.append(res)\\n                st.append(num)\\n                res=\"\"\\n                num=0\\n            elif c==\"]\":\\n                pnum = st.pop()\\n                pstr = st.pop()\\n                res = pstr + pnum*res\\n            else:\\n                res+=c\\n        \\n        return res\\n\\t\\t\\n****\\n### IDEA :\\n**Using RECURSION :**\\n\\'\\'\\'\\n\\t\\n\\tclass Solution:\\n    def decodeString(self, s: str) -> str:       \\n        def dfs(s,p):\\n            res = \"\"\\n            i,num = p,0\\n            while i<len(s):\\n                asc = (ord(s[i])-48)\\n                if 0<=asc<=9:           # can also be written as if s[i].isdigit()\\n                    num=num*10+asc\\n                elif s[i]==\"[\":\\n                    local,pos = dfs(s,i+1)\\n                    res+=local*num\\n                    i=pos\\n                    num=0\\n                elif s[i]==\"]\":\\n                    return res,i\\n                else:\\n                    res+=s[i]\\n                i+=1\\n            return res,i\\n        \\n        return dfs(s,0)[0]\\n\\t\\t\\n***Thanks*** and feel free to ask if you have any doubt!! \\uD83E\\uDD17\\n**Upvote** if you found interesting !!\\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 941380,
                "title": "c-amazing-easy-iterative-fully-explained-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    // Helper function to repeat substring a number of times:\\n    string repeat(string str, int times) {\\n        string res = \"\";\\n        for (int i=0; i<times; i++)\\n            res += str;\\n        return res;\\n    }\\n    \\n    string decodeString(string s) {\\n        int i=0;\\n        while (i < s.size()) {\\n            if (s[i] != \\']\\') {\\n                i++;\\n                continue;\\n            }\\n            \\n            // When we get to closing parenthesis,\\n            // we will look back to get the letters to repeat and the number of times\\n            // then we replace the original part in the string and place i after that to continue.\\n            int j = i;\\n            while (s[j] != \\'[\\') // Extract letters\\n                j--;\\n        \\n            string letters_to_repeat = s.substr(j+1, i-j-1);\\n            int k = j;\\n            j--;\\n            while ((j > 0) &&(isdigit(s[j]))) // Before opening parethesis we get the number\\n                j--;\\n            \\n            if (j != 0) j++; // Edge case where we are at the beginning of the string\\n            int times_to_repeat = stoi(s.substr(j, k-j));\\n            \\n            s.replace(j, i-j+1, repeat(letters_to_repeat, times_to_repeat));\\n\\t\\t\\t\\n            // Put i in the right place now\\n            i = j+letters_to_repeat.size()*times_to_repeat;\\n        }\\n        return s;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Helper function to repeat substring a number of times:\\n    string repeat(string str, int times) {\\n        string res = \"\";\\n        for (int i=0; i<times; i++)\\n            res += str;\\n        return res;\\n    }\\n    \\n    string decodeString(string s) {\\n        int i=0;\\n        while (i < s.size()) {\\n            if (s[i] != \\']\\') {\\n                i++;\\n                continue;\\n            }\\n            \\n            // When we get to closing parenthesis,\\n            // we will look back to get the letters to repeat and the number of times\\n            // then we replace the original part in the string and place i after that to continue.\\n            int j = i;\\n            while (s[j] != \\'[\\') // Extract letters\\n                j--;\\n        \\n            string letters_to_repeat = s.substr(j+1, i-j-1);\\n            int k = j;\\n            j--;\\n            while ((j > 0) &&(isdigit(s[j]))) // Before opening parethesis we get the number\\n                j--;\\n            \\n            if (j != 0) j++; // Edge case where we are at the beginning of the string\\n            int times_to_repeat = stoi(s.substr(j, k-j));\\n            \\n            s.replace(j, i-j+1, repeat(letters_to_repeat, times_to_repeat));\\n\\t\\t\\t\\n            // Put i in the right place now\\n            i = j+letters_to_repeat.size()*times_to_repeat;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87598,
                "title": "simple-linear-time-python-solution-with-notes",
                "content": "Concatenate digits and alphabets. When `[` appears, push the current alphas and digits (as an integer `n`) into the stack, and start a new concatenation for alphas and digits. When a `]` appears, pop the stack and extend the popped alphas `n` times to the current alphas. \\n\\nComplexity is linear in both time and space.\\n\\n```\\nclass Solution(object):\\n    def decodeString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        stack = []\\n        \\n        alphas, digits = '', ''\\n\\n        for c in s:\\n            if c.isdigit():\\n                digits += c\\n            elif c == '[':\\n                stack.append((alphas, int(digits)))\\n                alphas, digits = '', ''\\n            elif c == ']':\\n                prev, n = stack.pop()\\n                alphas = prev + alphas * n\\n            elif c.isalpha():\\n                alphas += c\\n\\n        return alphas\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def decodeString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        stack = []\\n        \\n        alphas, digits = '', ''\\n\\n        for c in s:\\n            if c.isdigit():\\n                digits += c\\n            elif c == '[':\\n                stack.append((alphas, int(digits)))\\n                alphas, digits = '', ''\\n            elif c == ']':\\n                prev, n = stack.pop()\\n                alphas = prev + alphas * n\\n            elif c.isalpha():\\n                alphas += c\\n\\n        return alphas\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162986,
                "title": "stack-javascript-with-explanation",
                "content": "```\\nvar decodeString = function(str) {\\n    /*\\n        we have 4 possibilities\\n        1) opening braces -> new sequence starts, so \\n        add curr string and curr number to the stack, reassign both\\n        to initial values\\n        2) closing braces -> the sequence is over, it is time to create a substring\\n        by getting prev string and prev number from the stack, add prev string(repeated prev num times)\\n        to curr string\\n        3) if it is number add to curr num\\n        4) if it is char add to curr string\\n    */\\n    let stack = [];\\n    let currStr = \\'\\';\\n    let currNum = 0;\\n    \\n    for (let i = 0; i < str.length; i ++) {\\n        if (str[i] === \\'[\\') {\\n            stack.push(currStr);\\n            stack.push(currNum);\\n            currStr = \\'\\';\\n            currNum = 0;\\n        } else if (str[i] === \\']\\') {\\n            let prevNum = stack.pop();\\n            let prevStr = stack.pop();\\n            currStr = prevStr + currStr.repeat(prevNum);\\n        } else if (str[i] >= \\'0\\' && str[i] <= \\'9\\') {\\n            currNum = currNum * 10 + Number(str[i]);\\n        } else {\\n            currStr += str[i];\\n        }\\n    }\\n    \\n    return currStr;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar decodeString = function(str) {\\n    /*\\n        we have 4 possibilities\\n        1) opening braces -> new sequence starts, so \\n        add curr string and curr number to the stack, reassign both\\n        to initial values\\n        2) closing braces -> the sequence is over, it is time to create a substring\\n        by getting prev string and prev number from the stack, add prev string(repeated prev num times)\\n        to curr string\\n        3) if it is number add to curr num\\n        4) if it is char add to curr string\\n    */\\n    let stack = [];\\n    let currStr = \\'\\';\\n    let currNum = 0;\\n    \\n    for (let i = 0; i < str.length; i ++) {\\n        if (str[i] === \\'[\\') {\\n            stack.push(currStr);\\n            stack.push(currNum);\\n            currStr = \\'\\';\\n            currNum = 0;\\n        } else if (str[i] === \\']\\') {\\n            let prevNum = stack.pop();\\n            let prevStr = stack.pop();\\n            currStr = prevStr + currStr.repeat(prevNum);\\n        } else if (str[i] >= \\'0\\' && str[i] <= \\'9\\') {\\n            currNum = currNum * 10 + Number(str[i]);\\n        } else {\\n            currStr += str[i];\\n        }\\n    }\\n    \\n    return currStr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3258413,
                "title": "394-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize the stack and the current string:\\n```\\nstack = []\\ncurr_str = \"\"\\n```\\nThe stack is used to keep track of the current number and string that are being processed. The curr_str variable will store the current string that is being decoded.\\n\\n2. Initialize the current number to 0:\\n```\\ncurr_num = 0\\n```\\nThe curr_num variable is used to keep track of the current number that is being processed.\\n\\n3. Iterate through each character of the string:\\n```\\nfor c in s:\\n```\\nThis loop will iterate through each character of the given string s.\\n\\n4. If the character is a digit, update the current number:\\n```\\nif c.isdigit():\\n    curr_num = curr_num * 10 + int(c)\\n```\\nIf the current character is a digit, it is part of a number that needs to be decoded. The curr_num variable is updated by multiplying the current number by 10 and adding the value of the current digit.\\n\\n5. If the character is an opening bracket, push the current number and current string onto the stack:\\n```\\nelif c == \"[\":\\n    stack.append(curr_num)\\n    stack.append(curr_str)\\n    curr_num = 0\\n    curr_str = \"\"\\n```\\nIf the current character is an opening bracket, it means that a new string is to be decoded. The curr_num and curr_str variables are pushed onto the stack, and are reset to their initial values.\\n\\n6. If the character is a closing bracket, repeat the popped characters and push the result back onto the stack:\\n```\\nelif c == \"]\":\\n    prev_str = stack.pop()\\n    prev_num = stack.pop()\\n    curr_str = prev_str + curr_str * prev_num\\n```\\nIf the current character is a closing bracket, it means that a string needs to be repeated. The prev_str and prev_num variables are popped from the stack and the curr_str variable is updated by concatenating the previous string with the current string repeated prev_num times.\\n\\n7. If the character is a letter, append it to the current string:\\n```\\nelse:\\n    curr_str += c\\n```\\nIf the current character is a letter, it is part of the string that needs to be decoded. The current character is appended to the curr_str variable.\\n\\n8. Pop any remaining characters from the stack and concatenate them to the final result:\\n```\\nwhile stack:\\n    curr_str = stack.pop() + curr_str\\n```\\nAfter the loop has finished, there may be remaining characters in the stack that need to be added to the final result. The remaining characters are popped from the stack and concatenated to the beginning of the curr_str variable.\\n\\n9. Return the final decoded string:\\n```\\nreturn curr_str\\n```\\nThe final decoded string is returned.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        # Initialize the stack and the current string\\n        stack = []\\n        curr_str = \"\"\\n        # Initialize the current number to 0\\n        curr_num = 0\\n        \\n        # Iterate through each character of the string\\n        for c in s:\\n            # If the character is a digit, update the current number\\n            if c.isdigit():\\n                curr_num = curr_num * 10 + int(c)\\n            # If the character is an opening bracket, push the current number and current string onto the stack\\n            elif c == \"[\":\\n                stack.append(curr_num)\\n                stack.append(curr_str)\\n                # Reset the current number and current string\\n                curr_num = 0\\n                curr_str = \"\"\\n            # If the character is a closing bracket, repeat the popped characters and push the result back onto the stack\\n            elif c == \"]\":\\n                prev_str = stack.pop()\\n                prev_num = stack.pop()\\n                curr_str = prev_str + curr_str * prev_num\\n            # If the character is a letter, append it to the current string\\n            else:\\n                curr_str += c\\n        \\n        # Pop any remaining characters from the stack and concatenate them to the final result\\n        while stack:\\n            curr_str = stack.pop() + curr_str\\n        \\n        return curr_str\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nstack = []\\ncurr_str = \"\"\\n```\n```\\ncurr_num = 0\\n```\n```\\nfor c in s:\\n```\n```\\nif c.isdigit():\\n    curr_num = curr_num * 10 + int(c)\\n```\n```\\nelif c == \"[\":\\n    stack.append(curr_num)\\n    stack.append(curr_str)\\n    curr_num = 0\\n    curr_str = \"\"\\n```\n```\\nelif c == \"]\":\\n    prev_str = stack.pop()\\n    prev_num = stack.pop()\\n    curr_str = prev_str + curr_str * prev_num\\n```\n```\\nelse:\\n    curr_str += c\\n```\n```\\nwhile stack:\\n    curr_str = stack.pop() + curr_str\\n```\n```\\nreturn curr_str\\n```\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        # Initialize the stack and the current string\\n        stack = []\\n        curr_str = \"\"\\n        # Initialize the current number to 0\\n        curr_num = 0\\n        \\n        # Iterate through each character of the string\\n        for c in s:\\n            # If the character is a digit, update the current number\\n            if c.isdigit():\\n                curr_num = curr_num * 10 + int(c)\\n            # If the character is an opening bracket, push the current number and current string onto the stack\\n            elif c == \"[\":\\n                stack.append(curr_num)\\n                stack.append(curr_str)\\n                # Reset the current number and current string\\n                curr_num = 0\\n                curr_str = \"\"\\n            # If the character is a closing bracket, repeat the popped characters and push the result back onto the stack\\n            elif c == \"]\":\\n                prev_str = stack.pop()\\n                prev_num = stack.pop()\\n                curr_str = prev_str + curr_str * prev_num\\n            # If the character is a letter, append it to the current string\\n            else:\\n                curr_str += c\\n        \\n        # Pop any remaining characters from the stack and concatenate them to the final result\\n        while stack:\\n            curr_str = stack.pop() + curr_str\\n        \\n        return curr_str\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378711,
                "title": "easy-understand-python-solution-88-beat",
                "content": "When meet \\'[\\' append the previous num and string to stack, when meet the \\']\\' pop the previous num and string to calculate. Notice the num*10 + num is for some case like \"100[leetcode]\" that num is greater than 10.\\n\\n```\\n\\tdef decodeString(self, s: str) -> str:\\n        num = 0\\n        string = \\'\\'\\n        stack = []\\n        for c in s:\\n            if c.isdigit():\\n                num = num*10 + int(c)\\n            elif c == \"[\":\\n                stack.append(string)\\n                stack.append(num)\\n                string = \\'\\'\\n                num = 0\\n            elif c.isalpha():\\n                string += c\\n            elif c == \\']\\':\\n                pre_num = stack.pop()\\n                pre_string = stack.pop()\\n                string = pre_string + pre_num * string\\n        return string\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n\\tdef decodeString(self, s: str) -> str:\\n        num = 0\\n        string = \\'\\'\\n        stack = []\\n        for c in s:\\n            if c.isdigit():\\n                num = num*10 + int(c)\\n            elif c == \"[\":\\n                stack.append(string)\\n                stack.append(num)\\n                string = \\'\\'\\n                num = 0\\n            elif c.isalpha():\\n                string += c\\n            elif c == \\']\\':\\n                pre_num = stack.pop()\\n                pre_string = stack.pop()\\n                string = pre_string + pre_num * string\\n        return string\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 738090,
                "title": "c-recursion-and-short",
                "content": "Four cases are considered. 1st when we encounter a `[`. 2nd when we encounter a `digit`. 3rd encountering a `]`. and last simple `words`. Please note that index i is passed by reference not by value.\\n```\\nclass Solution {\\npublic:\\n    string helper(int &i,string s){\\n        int num=0;\\n        string word=\"\";\\n        for(;i<s.length();i++)\\n        {\\n            if(s[i]>=\\'0\\' and s[i]<=\\'9\\')\\n                num=num*10+s[i]-\\'0\\';\\n            else if(s[i]==\\'[\\')\\n            {\\n                string ans=helper(++i,s);\\n                for(;num>0;num--)word+=ans;\\n            }\\n            else if(s[i]==\\']\\')\\n                return word;\\n            else\\n                word+=s[i];\\n        }\\n        return word;\\n    }\\n    string decodeString(string s) {\\n        int i=0;\\n        return helper(i,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string helper(int &i,string s){\\n        int num=0;\\n        string word=\"\";\\n        for(;i<s.length();i++)\\n        {\\n            if(s[i]>=\\'0\\' and s[i]<=\\'9\\')\\n                num=num*10+s[i]-\\'0\\';\\n            else if(s[i]==\\'[\\')\\n            {\\n                string ans=helper(++i,s);\\n                for(;num>0;num--)word+=ans;\\n            }\\n            else if(s[i]==\\']\\')\\n                return word;\\n            else\\n                word+=s[i];\\n        }\\n        return word;\\n    }\\n    string decodeString(string s) {\\n        int i=0;\\n        return helper(i,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927099,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n         stack<string> chars;\\n        stack<int> nums;\\n        string res;\\n        int num = 0;\\n        for(char c : s) {\\n            if(isdigit(c)) {\\n                num = num*10 + (c-\\'0\\');                              \\n            }\\n            else if(isalpha(c)) {\\n                res.push_back(c);                \\n            }\\n            else if(c == \\'[\\') {\\n                chars.push(res);\\n                nums.push(num);\\n                res = \"\";\\n                num = 0;\\n            }\\n            else if(c == \\']\\') {\\n                string tmp = res;\\n                for(int i = 0; i < nums.top()-1; ++i) {\\n                    res += tmp;\\n                }\\n                res = chars.top() + res;\\n                chars.pop(); nums.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n         stack<string> chars;\\n        stack<int> nums;\\n        string res;\\n        int num = 0;\\n        for(char c : s) {\\n            if(isdigit(c)) {\\n                num = num*10 + (c-\\'0\\');                              \\n            }\\n            else if(isalpha(c)) {\\n                res.push_back(c);                \\n            }\\n            else if(c == \\'[\\') {\\n                chars.push(res);\\n                nums.push(num);\\n                res = \"\";\\n                num = 0;\\n            }\\n            else if(c == \\']\\') {\\n                string tmp = res;\\n                for(int i = 0; i < nums.top()-1; ++i) {\\n                    res += tmp;\\n                }\\n                res = chars.top() + res;\\n                chars.pop(); nums.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87690,
                "title": "simple-java-solution-single-stack-5ms",
                "content": "```\\npublic String decodeString(String s) {\\n\\tif(s==null || s.isEmpty()) return \"\";\\n\\tStringBuilder sb = new StringBuilder();\\n\\tchar[] charsS = s.toCharArray();\\n\\tDeque<String> stack = new ArrayDeque<>();\\n\\tfor(int i=0;i<charsS.length;i++) {\\n\\t\\tchar c = charsS[i];\\n\\t\\tif(c==']') { // if char is ], pop out the string to repeat and the repeat number\\n\\t\\t\\tStringBuilder sbCharsToRepeat = new StringBuilder();\\n\\t\\t\\twhile(!stack.isEmpty() && Character.isLetter(stack.peek().charAt(0))) { // build the string to repeat\\n\\t\\t\\t\\tsbCharsToRepeat.insert(0,stack.pop());\\n\\t\\t\\t}\\n\\t\\t\\tif(\"[\".equals(stack.peek())) stack.pop(); // pop out the [ char next to the repeat number\\n\\t\\t\\tStringBuilder kRepeats = new StringBuilder();\\n\\t\\t\\twhile(!stack.isEmpty() && Character.isDigit(stack.peek().charAt(0))) { // build the repeat number\\n\\t\\t\\t\\tkRepeats.insert(0,stack.pop());\\n\\t\\t\\t}\\n\\t\\t\\tInteger k = kRepeats.length()>0?Integer.parseInt(kRepeats.toString()):1;\\n\\t\\t\\tStringBuilder charsToPush = new StringBuilder();\\n\\t\\t\\tfor(int j=0;j<k;j++) { // build the string to repeat k times\\n\\t\\t\\t\\tcharsToPush.append(sbCharsToRepeat);\\n\\t\\t\\t}\\n\\t\\t\\tstack.push(charsToPush.toString()); // push back the repeated string into the stack\\n\\t\\t} else {\\n\\t\\t\\tstack.push(\"\"+c); // push the characters until you find a ]\\n\\t\\t}\\n\\t}\\n\\twhile(!stack.isEmpty()) { // build the final string\\n\\t\\tsb.insert(0, stack.pop());\\n\\t}\\n\\treturn sb.toString();\\n}\\n```\\n\\nExecution stacks examples:\\n```\\nInput String: 3[a]2[bc]\\n\\nStack steps:\\n[3]\\n[[, 3]\\n[a, [, 3]\\n[aaa]\\n[2, aaa]\\n[[, 2, aaa]\\n[b, [, 2, aaa]\\n[c, b, [, 2, aaa]\\n[bcbc, aaa]\\n\\nOutput String: aaabcbc\\n\\n```\\n\\n```\\nInput String: 3[a2[c]]\\n\\nStack steps:\\n[3]\\n[[, 3]\\n[a, [, 3]\\n[2, a, [, 3]\\n[[, 2, a, [, 3]\\n[c, [, 2, a, [, 3]\\n[cc, a, [, 3]\\n[accaccacc]\\n\\nOutput String: accaccacc\\n```\\n\\n```\\nInput String: 2[abc]3[cd]ef\\n\\nStack steps:\\n[2]\\n[[, 2]\\n[a, [, 2]\\n[b, a, [, 2]\\n[c, b, a, [, 2]\\n[abcabc]\\n[3, abcabc]\\n[[, 3, abcabc]\\n[c, [, 3, abcabc]\\n[d, c, [, 3, abcabc]\\n[cdcdcd, abcabc]\\n[e, cdcdcd, abcabc]\\n[f, e, cdcdcd, abcabc]\\n\\nOutput String: abcabccdcdcdef\\n```\\n\\n```\\nInput String: 2[2[ab]]\\n\\nStack steps:\\n[2]\\n[[, 2]\\n[2, [, 2]\\n[[, 2, [, 2]\\n[a, [, 2, [, 2]\\n[b, a, [, 2, [, 2]\\n[abab, [, 2]\\n[abababab]\\n\\nOutput String: abababab\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\npublic String decodeString(String s) {\\n\\tif(s==null || s.isEmpty()) return \"\";\\n\\tStringBuilder sb = new StringBuilder();\\n\\tchar[] charsS = s.toCharArray();\\n\\tDeque<String> stack = new ArrayDeque<>();\\n\\tfor(int i=0;i<charsS.length;i++) {\\n\\t\\tchar c = charsS[i];\\n\\t\\tif(c==']') { // if char is ], pop out the string to repeat and the repeat number\\n\\t\\t\\tStringBuilder sbCharsToRepeat = new StringBuilder();\\n\\t\\t\\twhile(!stack.isEmpty() && Character.isLetter(stack.peek().charAt(0))) { // build the string to repeat\\n\\t\\t\\t\\tsbCharsToRepeat.insert(0,stack.pop());\\n\\t\\t\\t}\\n\\t\\t\\tif(\"[\".equals(stack.peek())) stack.pop(); // pop out the [ char next to the repeat number\\n\\t\\t\\tStringBuilder kRepeats = new StringBuilder();\\n\\t\\t\\twhile(!stack.isEmpty() && Character.isDigit(stack.peek().charAt(0))) { // build the repeat number\\n\\t\\t\\t\\tkRepeats.insert(0,stack.pop());\\n\\t\\t\\t}\\n\\t\\t\\tInteger k = kRepeats.length()>0?Integer.parseInt(kRepeats.toString()):1;\\n\\t\\t\\tStringBuilder charsToPush = new StringBuilder();\\n\\t\\t\\tfor(int j=0;j<k;j++) { // build the string to repeat k times\\n\\t\\t\\t\\tcharsToPush.append(sbCharsToRepeat);\\n\\t\\t\\t}\\n\\t\\t\\tstack.push(charsToPush.toString()); // push back the repeated string into the stack\\n\\t\\t} else {\\n\\t\\t\\tstack.push(\"\"+c); // push the characters until you find a ]\\n\\t\\t}\\n\\t}\\n\\twhile(!stack.isEmpty()) { // build the final string\\n\\t\\tsb.insert(0, stack.pop());\\n\\t}\\n\\treturn sb.toString();\\n}\\n```\n```\\nInput String: 3[a]2[bc]\\n\\nStack steps:\\n[3]\\n[[, 3]\\n[a, [, 3]\\n[aaa]\\n[2, aaa]\\n[[, 2, aaa]\\n[b, [, 2, aaa]\\n[c, b, [, 2, aaa]\\n[bcbc, aaa]\\n\\nOutput String: aaabcbc\\n\\n```\n```\\nInput String: 3[a2[c]]\\n\\nStack steps:\\n[3]\\n[[, 3]\\n[a, [, 3]\\n[2, a, [, 3]\\n[[, 2, a, [, 3]\\n[c, [, 2, a, [, 3]\\n[cc, a, [, 3]\\n[accaccacc]\\n\\nOutput String: accaccacc\\n```\n```\\nInput String: 2[abc]3[cd]ef\\n\\nStack steps:\\n[2]\\n[[, 2]\\n[a, [, 2]\\n[b, a, [, 2]\\n[c, b, a, [, 2]\\n[abcabc]\\n[3, abcabc]\\n[[, 3, abcabc]\\n[c, [, 3, abcabc]\\n[d, c, [, 3, abcabc]\\n[cdcdcd, abcabc]\\n[e, cdcdcd, abcabc]\\n[f, e, cdcdcd, abcabc]\\n\\nOutput String: abcabccdcdcdef\\n```\n```\\nInput String: 2[2[ab]]\\n\\nStack steps:\\n[2]\\n[[, 2]\\n[2, [, 2]\\n[[, 2, [, 2]\\n[a, [, 2, [, 2]\\n[b, a, [, 2, [, 2]\\n[abab, [, 2]\\n[abababab]\\n\\nOutput String: abababab\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1635242,
                "title": "c-easy-to-solve-beginner-friendly-with-detailed-explanations-and-comments",
                "content": "**Intuition:-**\\nAfter reading the question let\\'s track some general terms like what type of observation will lead us to problem solving. In the question they told us about the repeatation and to show that there will be numbers outside the square brackets `[...]`. So we need to use this information of square brackets . Let\\'s see how :\\n* Before opening parenthesis we will get the number that we will be using for repeatations of our string .\\n* when we get our closing parenthesis we will go back to our string letters to repeat them the number of times the number and replace the originial part of that string and place `i` after that to continue .\\n\\n**Algorithm:-**\\n1. Let\\'s first initialize some variables and functions `string repeat()`->our helper function to repeat our substring that many number of times , `s`->our final decoded string , `repeatLetters`->This are the letters that should be repeated , `repeatTimes`->Number of times the letters should be repeated .\\n2. Let\\'s create a helper function which repeates the substring that many number of times the logic is quiet simple\\n3. After the first `[` parenthesis we need to extract those letters to repeate that many times\\n4. After getting the decode part we will just replace the original encoded string with our repeated decoded string by the `s.replace() built in method in c++`\\n\\n**Code:-**\\n```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    //Function to help repeat the substring a number of times\\n    string repeat(string str,int times){\\n        string result=\"\";\\n        for(int i=0;i<times;i++) result += str;\\n        return result;\\n    }\\n    string decodeString(string s) {\\n        int i=0;\\n        while(i<s.size()){\\n            if(s[i]!=\\']\\'){\\n                i++;\\n                continue;\\n            }\\n            //The string that needs to get repeated after the first parenthesis \\'[\\'\\n            int j=i;\\n            while(s[j]!=\\'[\\') j--;\\n            //The letters that we will be repeating\\n            string repeatLetters = s.substr(j+1,i-j-1);\\n            int k=j;\\n            j--;\\n            //checking the number before opening the parenthesis so we can get a count that how many times we need to repeat the strin\\n            while((j>0) && (isdigit(s[j])))\\n                j--;\\n            \\n            //Corner case : When we r at the start of our string\\n            if(j!=0) j++;\\n            //Find the number of times the letter should be repeated\\n            int repeatTimes = stoi(s.substr(j,k-j));\\n            //replace the encoded part of string with decoded part\\n            s.replace(j,i-j+1,repeat(repeatLetters,repeatTimes));\\n            //Putting i in the right place of our string\\n            i=j+repeatLetters.size()*repeatTimes;\\n        }\\n        return s;\\n    }\\n};\\n```\\n\\n\\n**Feel free to comment and Upvote if you liked my post :))**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    //Function to help repeat the substring a number of times\\n    string repeat(string str,int times){\\n        string result=\"\";\\n        for(int i=0;i<times;i++) result += str;\\n        return result;\\n    }\\n    string decodeString(string s) {\\n        int i=0;\\n        while(i<s.size()){\\n            if(s[i]!=\\']\\'){\\n                i++;\\n                continue;\\n            }\\n            //The string that needs to get repeated after the first parenthesis \\'[\\'\\n            int j=i;\\n            while(s[j]!=\\'[\\') j--;\\n            //The letters that we will be repeating\\n            string repeatLetters = s.substr(j+1,i-j-1);\\n            int k=j;\\n            j--;\\n            //checking the number before opening the parenthesis so we can get a count that how many times we need to repeat the strin\\n            while((j>0) && (isdigit(s[j])))\\n                j--;\\n            \\n            //Corner case : When we r at the start of our string\\n            if(j!=0) j++;\\n            //Find the number of times the letter should be repeated\\n            int repeatTimes = stoi(s.substr(j,k-j));\\n            //replace the encoded part of string with decoded part\\n            s.replace(j,i-j+1,repeat(repeatLetters,repeatTimes));\\n            //Putting i in the right place of our string\\n            i=j+repeatLetters.size()*repeatTimes;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782552,
                "title": "swift-solution-clean-concise",
                "content": "Here is a concise Swift solution. It uses a `switch` statement to simplify the logic and it uses an `Array` as a stack to simulate recursion. It\\'s similar to the [most voted answer](https://leetcode.com/problems/decode-string/discuss/87662/Python-solution-using-stack) but using Swift instead of Python. \\n\\n```swift \\nfunc decodeString(_ s: String) -> String {\\n\\tvar stack = [(String, Int)]()\\n\\tvar result = \"\" \\n\\tvar num = 0\\n\\n\\tfor char in s {\\n\\t\\tswitch char {\\n\\t\\tcase \"[\":\\n\\t\\t\\tstack.append((result, num))\\n\\t\\t\\tresult = \"\"\\n\\t\\t\\tnum = 0\\n\\t\\tcase \"]\":\\n\\t\\t\\tlet (prev, num) = stack.removeLast() \\n\\t\\t\\tresult = prev + String(repeating: result, count: num)\\n\\t\\tcase _ where char.isNumber:\\n\\t\\t\\tnum *= 10 \\n\\t\\t\\tnum += Int(String(char))!\\n\\t\\tdefault: \\n\\t\\t\\tresult += String(char)\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [],
                "code": "```swift \\nfunc decodeString(_ s: String) -> String {\\n\\tvar stack = [(String, Int)]()\\n\\tvar result = \"\" \\n\\tvar num = 0\\n\\n\\tfor char in s {\\n\\t\\tswitch char {\\n\\t\\tcase \"[\":\\n\\t\\t\\tstack.append((result, num))\\n\\t\\t\\tresult = \"\"\\n\\t\\t\\tnum = 0\\n\\t\\tcase \"]\":\\n\\t\\t\\tlet (prev, num) = stack.removeLast() \\n\\t\\t\\tresult = prev + String(repeating: result, count: num)\\n\\t\\tcase _ where char.isNumber:\\n\\t\\t\\tnum *= 10 \\n\\t\\t\\tnum += Int(String(char))!\\n\\t\\tdefault: \\n\\t\\t\\tresult += String(char)\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87576,
                "title": "no-stack-o-n-recursive-solution-in-python",
                "content": "```\\ndef helper(s):\\n    res = \"\"\\n    while s:\\n        num = \"\"\\n        while s and s[-1] in '0123456789':\\n            num += s.pop()\\n        if num:\\n            num = int(num)\\n            s.pop()\\n            res += helper(s) * num\\n        else:\\n            c = s.pop()\\n            if c not in \"[]\":\\n                res += c\\n            if c == ']':\\n                break\\n    return res\\n\\nclass Solution(object):\\n    def decodeString(self, s):\\n        return helper(list(s)[::-1])\\n```",
                "solutionTags": [],
                "code": "```\\ndef helper(s):\\n    res = \"\"\\n    while s:\\n        num = \"\"\\n        while s and s[-1] in '0123456789':\\n            num += s.pop()\\n        if num:\\n            num = int(num)\\n            s.pop()\\n            res += helper(s) * num\\n        else:\\n            c = s.pop()\\n            if c not in \"[]\":\\n                res += c\\n            if c == ']':\\n                break\\n    return res\\n\\nclass Solution(object):\\n    def decodeString(self, s):\\n        return helper(list(s)[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635424,
                "title": "easy-c-solution-with-explanation",
                "content": "```\\n    string decodeString(string s)\\n    {\\n        int n=s.length();\\n        stack<char>st;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=\\']\\')\\n                st.push(s[i]);\\n            else\\n            {\\n                string ss=\"\";\\n                while(!st.empty() && st.top()!=\\'[\\')\\n                {\\n                    ss=st.top()+ss;\\n                    st.pop();\\n                }\\n            \\n                st.pop();\\n            \\n                string number=\"\";\\n                while(!st.empty() && isdigit(st.top()))\\n                {\\n                   number=st.top()+number;\\n                   st.pop();\\n                }\\n            \\n                int k=stoi(number);\\n            \\n                while(k--)\\n                {\\n                   for(int j=0;j<ss.length();j++)\\n                       st.push(ss[j]);\\n                }\\n           }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty())\\n        {\\n            ans=st.top()+ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n/*\\nLogic\\n\\nFirst make a char stack.\\nTraverse the string.\\nIf the char is not a ] \\n    push it into the stack.\\nElse \\n    store all elements of the stack in a string in reverse fashion until we encounter a [.\\n    pop the top element of stack as it it [.\\n    After that create a number string and store the frequency in reverse fashion. We use while here and not if because we can also have 2 digit or 3 digit number as frequency. Keep popping from stack.\\n    Then convert that number string into int k.\\n    now use a while loop until k>0 and store each char of string k number of times.\\n    \\nNow traverse through the stack and store all the characters in reverse order until stack becomes empty.\\nFinally, return ans.\\n\\n*/",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\n    string decodeString(string s)\\n    {\\n        int n=s.length();\\n        stack<char>st;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=\\']\\')\\n                st.push(s[i]);\\n            else\\n            {\\n                string ss=\"\";\\n                while(!st.empty() && st.top()!=\\'[\\')\\n                {\\n                    ss=st.top()+ss;\\n                    st.pop();\\n                }\\n            \\n                st.pop();\\n            \\n                string number=\"\";\\n                while(!st.empty() && isdigit(st.top()))\\n                {\\n                   number=st.top()+number;\\n                   st.pop();\\n                }\\n            \\n                int k=stoi(number);\\n            \\n                while(k--)\\n                {\\n                   for(int j=0;j<ss.length();j++)\\n                       st.push(ss[j]);\\n                }\\n           }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty())\\n        {\\n            ans=st.top()+ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n/*\\nLogic\\n\\nFirst make a char stack.\\nTraverse the string.\\nIf the char is not a ] \\n    push it into the stack.\\nElse \\n    store all elements of the stack in a string in reverse fashion until we encounter a [.\\n    pop the top element of stack as it it [.\\n    After that create a number string and store the frequency in reverse fashion. We use while here and not if because we can also have 2 digit or 3 digit number as frequency. Keep popping from stack.\\n    Then convert that number string into int k.\\n    now use a while loop until k>0 and store each char of string k number of times.\\n    \\nNow traverse through the stack and store all the characters in reverse order until stack becomes empty.\\nFinally, return ans.\\n\\n*/",
                "codeTag": "Unknown"
            },
            {
                "id": 975185,
                "title": "decode-string-with-regex",
                "content": "Another alternative could be using regular expression. (**[Try it on Regex101](https://regex101.com/r/7leAKA/1)**)\\n`const regex = /(\\\\d+)\\\\[([A-Za-z]+)\\\\]/g;`\\n\\nThe above regex will find a string pattern which match `number[letter]` like `3[a]`, `2[bc]`, etc.\\nFor example, if full match the string part of `2[bc]`.\\n* The *1<sup>st</sup> Capturing Group* (**number**) is `2`\\n* The *2<sup>nd</sup> Capturing Group* (**letter**) is `bc`\\n\\n\\nThen, replace it with letter repeated number of times by using `letter.repeat(number)`. And now you can get the decode string of `bcbc`.\\n\\nThis is how I\\'m trying to do it:\\n\\n```\\nvar decodeString = function (s) {\\n  const regex = /(\\\\d+)\\\\[([A-Za-z]+)\\\\]/g;\\n\\n  function replacer(match, number, letter) {\\n    return letter.repeat(number);\\n  }\\n\\n  while (s.includes(\\'[\\')) {\\n    s = s.replace(regex, replacer);\\n  }\\n  return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decodeString = function (s) {\\n  const regex = /(\\\\d+)\\\\[([A-Za-z]+)\\\\]/g;\\n\\n  function replacer(match, number, letter) {\\n    return letter.repeat(number);\\n  }\\n\\n  while (s.includes(\\'[\\')) {\\n    s = s.replace(regex, replacer);\\n  }\\n  return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1634874,
                "title": "java-dfs-0ms-easy-understanding",
                "content": "The idea is: for the string in [ ] pair, we can recurse it as the source string. The codes go into the lower level at \\'[\\', and back to parent at \\']\\'.\\nThe int pos is a globle parameter to indicate the current index of char in the String s.\\n```\\n\\tprivate int pos = 0;\\n    public String decodeString(String s) {\\n    \\tint n = s.length(), repeat = 0;\\n    \\tStringBuilder buf = new StringBuilder();\\n    \\twhile (pos < n) {\\n    \\t\\tchar c = s.charAt(pos);\\n    \\t\\tif (c >= \\'a\\' && c <= \\'z\\') {\\n    \\t\\t\\tbuf.append(c);\\n    \\t\\t} else if (c >= \\'0\\' && c <= \\'9\\') {\\n    \\t\\t\\trepeat = repeat * 10 + (c - \\'0\\');\\n    \\t\\t} else if (c == \\'[\\') {\\n    \\t\\t\\tpos++;  // skip the char \\'[\\'\\n    \\t\\t\\tString str = decodeString(s);  // pos is diff for each call\\n    \\t\\t\\tfor (int i = 0; i < repeat; i++)\\n   \\t\\t\\t\\t\\tbuf.append(str);\\n    \\t\\t\\trepeat = 0;  // reset the value for the next input\\n    \\t\\t} else if (c == \\']\\')\\n    \\t\\t\\tbreak;\\n    \\t\\tpos++;\\n    \\t}\\n    \\treturn buf.toString();\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "The idea is: for the string in [ ] pair, we can recurse it as the source string. The codes go into the lower level at \\'[\\', and back to parent at \\']\\'.\\nThe int pos is a globle parameter to indicate the current index of char in the String s.\\n```\\n\\tprivate int pos = 0;\\n    public String decodeString(String s) {\\n    \\tint n = s.length(), repeat = 0;\\n    \\tStringBuilder buf = new StringBuilder();\\n    \\twhile (pos < n) {\\n    \\t\\tchar c = s.charAt(pos);\\n    \\t\\tif (c >= \\'a\\' && c <= \\'z\\') {\\n    \\t\\t\\tbuf.append(c);\\n    \\t\\t} else if (c >= \\'0\\' && c <= \\'9\\') {\\n    \\t\\t\\trepeat = repeat * 10 + (c - \\'0\\');\\n    \\t\\t} else if (c == \\'[\\') {\\n    \\t\\t\\tpos++;  // skip the char \\'[\\'\\n    \\t\\t\\tString str = decodeString(s);  // pos is diff for each call\\n    \\t\\t\\tfor (int i = 0; i < repeat; i++)\\n   \\t\\t\\t\\t\\tbuf.append(str);\\n    \\t\\t\\trepeat = 0;  // reset the value for the next input\\n    \\t\\t} else if (c == \\']\\')\\n    \\t\\t\\tbreak;\\n    \\t\\tpos++;\\n    \\t}\\n    \\treturn buf.toString();\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 518155,
                "title": "concise-recursion-in-python-beats-99",
                "content": "\\tclass Solution:\\n\\t\\tdef decodeString(self, s):\\n\\n\\t\\t\\tif not s or len(s) == 0:\\n\\t\\t\\t\\treturn s\\n\\t\\t\\tresult, position = self.dfs(0,s,0,\\'\\')\\n\\t\\t\\treturn result\\n\\n\\t\\tdef dfs(self, position, s, prev_num, prev_str):\\n\\t\\t\\twhile position < len(s):\\n\\t\\t\\t\\twhile s[position].isdigit():\\n\\t\\t\\t\\t\\tprev_num  = prev_num*10 + int(s[position])\\n\\t\\t\\t\\t\\tposition += 1\\n\\n\\t\\t\\t\\tif s[position] == \"[\":\\n\\t\\t\\t\\t\\t#reset the prev_str\\n\\t\\t\\t\\t\\treturned_str, ending_pos = self.dfs(position+1, s, prev_num=0, prev_str=\"\")\\n\\t\\t\\t\\t\\t#backtrack\\n\\t\\t\\t\\t\\tprev_str = prev_str + returned_str*prev_num\\n\\t\\t\\t\\t\\tposition = ending_pos\\n\\t\\t\\t\\t\\tprev_num = 0\\n\\t\\t\\t\\t#return the result\\n\\t\\t\\t\\telif s[position] == \\']\\':\\n\\t\\t\\t\\t\\treturn prev_str, position\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tprev_str += s[position]\\n\\t\\t\\t\\tposition += 1\\n\\t\\t\\treturn prev_str, position",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef decodeString(self, s):\\n\\n\\t\\t\\tif not s or len(s) == 0:\\n\\t\\t\\t\\treturn s\\n\\t\\t\\tresult, position = self.dfs(0,s,0,\\'\\')\\n\\t\\t\\treturn result\\n\\n\\t\\tdef dfs(self, position, s, prev_num, prev_str):\\n\\t\\t\\twhile position < len(s):\\n\\t\\t\\t\\twhile s[position].isdigit():\\n\\t\\t\\t\\t\\tprev_num  = prev_num*10 + int(s[position])\\n\\t\\t\\t\\t\\tposition += 1\\n\\n\\t\\t\\t\\tif s[position] == \"[\":\\n\\t\\t\\t\\t\\t#reset the prev_str\\n\\t\\t\\t\\t\\treturned_str, ending_pos = self.dfs(position+1, s, prev_num=0, prev_str=\"\")\\n\\t\\t\\t\\t\\t#backtrack\\n\\t\\t\\t\\t\\tprev_str = prev_str + returned_str*prev_num\\n\\t\\t\\t\\t\\tposition = ending_pos\\n\\t\\t\\t\\t\\tprev_num = 0\\n\\t\\t\\t\\t#return the result\\n\\t\\t\\t\\telif s[position] == \\']\\':\\n\\t\\t\\t\\t\\treturn prev_str, position\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tprev_str += s[position]\\n\\t\\t\\t\\tposition += 1\\n\\t\\t\\treturn prev_str, position",
                "codeTag": "Java"
            },
            {
                "id": 1031958,
                "title": "java-recursive-0ms-100-with-explanation-o-n-solution",
                "content": "```\\npublic String decodeString(String s) {\\n        int[] i = {0}; // maintains the index we\\'re at through out the recursion. \\n        return decode(s, i);\\n    }\\n    \\n    public String decode(String s, int[] i){\\n        StringBuilder sb = new StringBuilder();\\n        int num = 0;\\n        \\n        while(i[0] < s.length()){\\n            char ch = s.charAt(i[0]);\\n            i[0]++; \\n            \\n            if(Character.isDigit(ch)){\\n                num = num * 10+ (ch -\\'0\\'); // if curr char is a number, store it\\n            }\\n            else if(ch == \\'[\\'){\\n                String innerStr = decode(s, i); // start recursion to solve sub problem. Returns the string between [ and ].\\n                while(num != 0){ \\n                    sb.append(innerStr); // multiply returned string with the num. \\n                    num--; // num resets to 0.\\n                }\\n            }\\n            else if(ch == \\']\\'){ // At this point, we\\'re finishing up a recursive call. \\n                break;  // break from the sub call and return innerString.\\n            }\\n            else{\\n                sb.append(ch); // appends any extra characters that do not need multiplying Ex: abc2[a], a2[b]a\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic String decodeString(String s) {\\n        int[] i = {0}; // maintains the index we\\'re at through out the recursion. \\n        return decode(s, i);\\n    }\\n    \\n    public String decode(String s, int[] i){\\n        StringBuilder sb = new StringBuilder();\\n        int num = 0;\\n        \\n        while(i[0] < s.length()){\\n            char ch = s.charAt(i[0]);\\n            i[0]++; \\n            \\n            if(Character.isDigit(ch)){\\n                num = num * 10+ (ch -\\'0\\'); // if curr char is a number, store it\\n            }\\n            else if(ch == \\'[\\'){\\n                String innerStr = decode(s, i); // start recursion to solve sub problem. Returns the string between [ and ].\\n                while(num != 0){ \\n                    sb.append(innerStr); // multiply returned string with the num. \\n                    num--; // num resets to 0.\\n                }\\n            }\\n            else if(ch == \\']\\'){ // At this point, we\\'re finishing up a recursive call. \\n                break;  // break from the sub call and return innerString.\\n            }\\n            else{\\n                sb.append(ch); // appends any extra characters that do not need multiplying Ex: abc2[a], a2[b]a\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 941382,
                "title": "python-dfs-with-comments",
                "content": "Here we need to evaluate the expression in the deepest levels first, so it is a depth-first search question. \\n\\nYou need to be aware of a **trick applied in paranthesis questions** here: As you notice, to apply DFS you need to find the end-point of each bracket opened. The idea is to use a variable called `bal` (balance) which is initially set to `1`. You increment `bal` for each `[` and decrement for each `]`. When `bal=0` you have reached the corresponding `]` for the initial `[`. This way you can segment the string, and carrying out the rest of recursion is straightforward. Not the easiest recursion question, though.\\n\\n``` python\\nclass Solution:\\n    def decodeString(self, s):\\n        def recur(s):\\n            ans = \\'\\' #answer from this step of recursion\\n            i = 0 #index of input string s\\n            num = \\'\\' #repetition number if any character is repeated\\n            while i<len(s):\\n                x = s[i]\\n                if x.isnumeric(): #we get a digit, append it to num\\n                    num += x\\n                elif x==\\'[\\': #we are opening a bracket\\n                    #now find j and i such that s[j:i] is the string inside the bracket\\n                    bal = 1 \\n                    j = i+1\\n                    while bal:\\n                        i += 1\\n                        if s[i]==\\'[\\': bal += 1\\n                        if s[i]==\\']\\': bal -= 1\\n                    #we add num*s[j:i]\\n                    #but we apply the function recursively in case there is a nested bracket\\n                    ans += int(float(num))*recur(s[j:i]) \\n                    num = \\'\\' #reset num\\n                else: #we get a regular character, just append it\\n                    ans += x\\n                i += 1 #increment counter\\n            return ans\\n        \\n        return recur(s)\\n```",
                "solutionTags": [],
                "code": "``` python\\nclass Solution:\\n    def decodeString(self, s):\\n        def recur(s):\\n            ans = \\'\\' #answer from this step of recursion\\n            i = 0 #index of input string s\\n            num = \\'\\' #repetition number if any character is repeated\\n            while i<len(s):\\n                x = s[i]\\n                if x.isnumeric(): #we get a digit, append it to num\\n                    num += x\\n                elif x==\\'[\\': #we are opening a bracket\\n                    #now find j and i such that s[j:i] is the string inside the bracket\\n                    bal = 1 \\n                    j = i+1\\n                    while bal:\\n                        i += 1\\n                        if s[i]==\\'[\\': bal += 1\\n                        if s[i]==\\']\\': bal -= 1\\n                    #we add num*s[j:i]\\n                    #but we apply the function recursively in case there is a nested bracket\\n                    ans += int(float(num))*recur(s[j:i]) \\n                    num = \\'\\' #reset num\\n                else: #we get a regular character, just append it\\n                    ans += x\\n                i += 1 #increment counter\\n            return ans\\n        \\n        return recur(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680089,
                "title": "beginner-friendly-solution-using-stacks-most-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIdea here is to use a stack.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe initialize an empty stack to store characters.\\n\\nWe iterate through each character in the given string.\\n\\nIf the current character is not \\']\\', we push it onto the stack.\\n\\nIf the current character is \\']\\', we start the decoding process:\\n-->We pop characters from the stack until we encounter a \\'[\\'. These characters represent a substring that needs to be repeated.\\n-->After popping the substring, we pop the next characters from the stack until we reach a digit. These characters represent the number that specifies the repetition count.\\n-->We reverse the extracted number and convert it to an integer.\\n-->We multiply the substring by the repetition count and push the result back onto the stack.\\n\\nOnce we have processed all the characters in the input string, we join the remaining characters in the stack to obtain the final decoded string. Since the characters were pushed onto the stack in reverse order, we reverse each substring before joining them to maintain the original order.\\n\\n![Stack img.jpeg](https://assets.leetcode.com/users/images/58154099-73ae-48d3-bd1c-ac608d933f89_1687678647.316495.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n\\n        stack=[]\\n\\n        for c in s:\\n            if c!=\\']\\':\\n                stack.append(c)\\n            else:\\n                res=\\'\\'\\n                while stack[-1]!=\\'[\\':\\n                    res+=stack.pop()\\n                stack.pop()\\n                n=\\'\\'\\n                while len(stack)!=0 and stack[-1].isdigit()==True:\\n                    n+=stack.pop()\\n                stack.append(res*int(n[::-1]))\\n\\n        return \\'\\'.join([word[::-1] for word in stack])\\n\\n\\n    \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n\\n        stack=[]\\n\\n        for c in s:\\n            if c!=\\']\\':\\n                stack.append(c)\\n            else:\\n                res=\\'\\'\\n                while stack[-1]!=\\'[\\':\\n                    res+=stack.pop()\\n                stack.pop()\\n                n=\\'\\'\\n                while len(stack)!=0 and stack[-1].isdigit()==True:\\n                    n+=stack.pop()\\n                stack.append(res*int(n[::-1]))\\n\\n        return \\'\\'.join([word[::-1] for word in stack])\\n\\n\\n    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448843,
                "title": "python-simple-clean-code-easy-sol-using-stack",
                "content": "- One of the Best problems to learn how to use stack.\\n# Code\\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        st = []\\n        num = 0\\n        res = \\'\\'\\n\\n        for ch in s:\\n            if ch.isnumeric():\\n                num = num * 10 + int(ch)\\n            elif ch == \\'[\\':\\n                st.append(res)\\n                st.append(num)\\n                res = \\'\\'\\n                num = 0\\n            elif ch == \\']\\':\\n                cnt = st.pop()\\n                prev = st.pop()\\n                res = prev + cnt * res\\n            else:\\n                res += ch\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        st = []\\n        num = 0\\n        res = \\'\\'\\n\\n        for ch in s:\\n            if ch.isnumeric():\\n                num = num * 10 + int(ch)\\n            elif ch == \\'[\\':\\n                st.append(res)\\n                st.append(num)\\n                res = \\'\\'\\n                num = 0\\n            elif ch == \\']\\':\\n                cnt = st.pop()\\n                prev = st.pop()\\n                res = prev + cnt * res\\n            else:\\n                res += ch\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941345,
                "title": "python-o-n-by-stack-w-comment",
                "content": "Python O(n) by stack \\n\\n---\\n\\n**Implementation** by stack:\\n\\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        \\n\\t\\t# record of tuple ( previous token, repeat times of current token)\\n        stack = []\\n        \\n        cur_token, cur_number =  \\'\\', 0\\n        \\n        for char in s:\\n            \\n            if char == \\'[\\':\\n                # meet start symbol \\'[\\'\\n                # save current token and current number into stack\\n                stack.append( (cur_token, cur_number) )\\n                \\n                # clear cur_token for new symbol in [ ]\\n                cur_token = \\'\\'\\n                \\n                # clear cur_number for new number in [ ]\\n                cur_number = 0\\n                \\n            elif char == \\']\\':\\n                # meet ending symbol \\']\\'\\n                # pop previous token and repeat times of current token from stack\\n                prev_token, repeat_times = stack.pop()\\n                \\n                # update current token with specified repeat times\\n                cur_token = prev_token + cur_token * repeat_times\\n                \\n            elif char.isdigit():\\n            \\n                # update current number\\n                cur_number = cur_number*10 + int(char)\\n            \\n            else:\\n                \\n                # update current token\\n                cur_token += char\\n                \\n                \\n        return cur_token\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        \\n\\t\\t# record of tuple ( previous token, repeat times of current token)\\n        stack = []\\n        \\n        cur_token, cur_number =  \\'\\', 0\\n        \\n        for char in s:\\n            \\n            if char == \\'[\\':\\n                # meet start symbol \\'[\\'\\n                # save current token and current number into stack\\n                stack.append( (cur_token, cur_number) )\\n                \\n                # clear cur_token for new symbol in [ ]\\n                cur_token = \\'\\'\\n                \\n                # clear cur_number for new number in [ ]\\n                cur_number = 0\\n                \\n            elif char == \\']\\':\\n                # meet ending symbol \\']\\'\\n                # pop previous token and repeat times of current token from stack\\n                prev_token, repeat_times = stack.pop()\\n                \\n                # update current token with specified repeat times\\n                cur_token = prev_token + cur_token * repeat_times\\n                \\n            elif char.isdigit():\\n            \\n                # update current number\\n                cur_number = cur_number*10 + int(char)\\n            \\n            else:\\n                \\n                # update current token\\n                cur_token += char\\n                \\n                \\n        return cur_token\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699980,
                "title": "python-simple-solution-using-2-stacks",
                "content": "```\\nclass Solution:\\n    def decodeString(self, string: str) -> str:\\n        ## RC ##        \\n        ## APPROACH : 2 Stacks ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        nums = []\\n        strs = []\\n        num = \"\"\\n        s = \"\"\\n        for i, ch in enumerate(string):\\n            if ch.isdigit():\\n                num += ch\\n            elif ch == \"[\":\\n                nums.append(int(num))\\n                strs.append(s)\\n                num = \"\"\\n                s = \"\"\\n            elif ch == \"]\":\\n                s =  strs.pop() + nums.pop() * s        # watchout, replacing with the same string\\n            else:\\n                s += ch\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, string: str) -> str:\\n        ## RC ##        \\n        ## APPROACH : 2 Stacks ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        nums = []\\n        strs = []\\n        num = \"\"\\n        s = \"\"\\n        for i, ch in enumerate(string):\\n            if ch.isdigit():\\n                num += ch\\n            elif ch == \"[\":\\n                nums.append(int(num))\\n                strs.append(s)\\n                num = \"\"\\n                s = \"\"\\n            elif ch == \"]\":\\n                s =  strs.pop() + nums.pop() * s        # watchout, replacing with the same string\\n            else:\\n                s += ch\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208633,
                "title": "dfs-simple-python",
                "content": "```py\\n\\'\\'\\'\\ndfs post-order, make sure recurisve calls refer the same i, same s \\n\\'\\'\\'\\nclass Solution:\\n    def __init__(self):\\n        self.i = 0\\n        \\n    def decodeString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        return self.dfs(list(s))\\n    \\n    def dfs(self, s):\\n        r = []\\n        \\n        while self.i < len(s): \\n            if s[self.i] == \\']\\':\\n                self.i +=1 \\n                return \\'\\'.join(r)\\n            \\n            elif s[self.i] == \\'[\\':\\n                self.i += 1 \\n                sub = self.dfs(s) \\n                r.append(sub * n)\\n            \\n            elif s[self.i].isdigit():\\n                n = 0 \\n                while self.i < len(s) and s[self.i].isdigit():\\n                    n = n * 10 + int(s[self.i]) \\n                    self.i += 1\\n                    \\n            else:\\n                r.append(s[self.i]);\\n                self.i += 1 \\n        \\n        return \\'\\'.join(r)\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n\\'\\'\\'\\ndfs post-order, make sure recurisve calls refer the same i, same s \\n\\'\\'\\'\\nclass Solution:\\n    def __init__(self):\\n        self.i = 0\\n        \\n    def decodeString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        return self.dfs(list(s))\\n    \\n    def dfs(self, s):\\n        r = []\\n        \\n        while self.i < len(s): \\n            if s[self.i] == \\']\\':\\n                self.i +=1 \\n                return \\'\\'.join(r)\\n            \\n            elif s[self.i] == \\'[\\':\\n                self.i += 1 \\n                sub = self.dfs(s) \\n                r.append(sub * n)\\n            \\n            elif s[self.i].isdigit():\\n                n = 0 \\n                while self.i < len(s) and s[self.i].isdigit():\\n                    n = n * 10 + int(s[self.i]) \\n                    self.i += 1\\n                    \\n            else:\\n                r.append(s[self.i]);\\n                self.i += 1 \\n        \\n        return \\'\\'.join(r)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1559008,
                "title": "c-solution-0ms-using-stacks-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        string ans=\"\";\\n        int num=0;\\n        stack<pair<string,int>>stk;//Stack to store the string between [] and the number of times it needs to be generated\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(isdigit(s[i]))\\n                num=(num*10)+(s[i]-48);//Since the number can be 2 digit or more we are generating the number\\n           else if(isalpha(s[i]))//IF given character is al[habet we build the string\\n                ans+=s[i];\\n           else if(s[i]==\\'[\\')//The moment the first [ is encountered we push the substring and the number generated to the stack\\n            {\\n                stk.push({ans,num});\\n                ans=\"\";// making the substring variable blank and number zero to prepare it for the next iteration\\n                    num=0;\\n            }\\n            else if(s[i]==\\']\\')//As a ] is encountered we generate the given substring according to \\'k\\' times given on stack top.We add the string at stack top and generated string so that it may be processed again if required\\n            {\\n                string tmp=ans;\\n                for(int i=1;i<stk.top().second;i++)                \\n                   tmp+=ans;\\n                ans=stk.top().first+tmp;\\n                stk.pop();\\n                \\n            }\\n                \\n        }\\n     \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        string ans=\"\";\\n        int num=0;\\n        stack<pair<string,int>>stk;//Stack to store the string between [] and the number of times it needs to be generated\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(isdigit(s[i]))\\n                num=(num*10)+(s[i]-48);//Since the number can be 2 digit or more we are generating the number\\n           else if(isalpha(s[i]))//IF given character is al[habet we build the string\\n                ans+=s[i];\\n           else if(s[i]==\\'[\\')//The moment the first [ is encountered we push the substring and the number generated to the stack\\n            {\\n                stk.push({ans,num});\\n                ans=\"\";// making the substring variable blank and number zero to prepare it for the next iteration\\n                    num=0;\\n            }\\n            else if(s[i]==\\']\\')//As a ] is encountered we generate the given substring according to \\'k\\' times given on stack top.We add the string at stack top and generated string so that it may be processed again if required\\n            {\\n                string tmp=ans;\\n                for(int i=1;i<stk.top().second;i++)                \\n                   tmp+=ans;\\n                ans=stk.top().first+tmp;\\n                stk.pop();\\n                \\n            }\\n                \\n        }\\n     \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985821,
                "title": "parse-with-stack-o-n-faster-than-100-fluent",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nThe problem can be seen as a stack problem because the ordering of the closed brackets and opening ones is analogous to the `LIFO` princile of stacks. \\r\\n\\r\\n![faster.PNG](https://assets.leetcode.com/users/images/48ee7572-1d6f-4ac9-a67d-77522cee5396_1672660823.216575.png)\\r\\n\\r\\n> I know I know LeetCode\\'s Runtime is biased :)\\r\\n\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nWhenever we find opening brackets(`[`) we append the characters after it and until a digit is found, and the digit before it to the stack. That means as a tuple in Python.\\r\\n\\r\\nWhenever we find closing brackets(`]`) we will pop the last element in the stack. And update our running current string `cur`.\\r\\n\\r\\n> Well, how do we keep track of both the characters in between `[` and `]` and the integer with which we are going to multiply the former with?\\r\\n\\r\\nThat is a good question actually. We will keep checking whether the character at hand is one of the brackets, or whether it is a digit, or it is a lower case English letter.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: $$O(n)$$\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: $$O(n)$$\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def decodeString(self, s: str) -> str:\\r\\n        stack = []\\r\\n        cur = \"\"\\r\\n        k = 0\\r\\n        for c in s:\\r\\n            if c == \"[\":\\r\\n                stack.append((cur, k))\\r\\n                cur, k = \"\", 0 # reset global vars\\r\\n            elif c == \"]\":\\r\\n                enc, n = stack.pop()\\r\\n                cur = enc + n * cur \\r\\n            elif c.isdigit():\\r\\n                k = k * 10 + int(c) # for two and three digit numbers\\r\\n            else:\\r\\n                cur += c # track the lower case letters\\r\\n        return cur\\r\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def decodeString(self, s: str) -> str:\\r\\n        stack = []\\r\\n        cur = \"\"\\r\\n        k = 0\\r\\n        for c in s:\\r\\n            if c == \"[\":\\r\\n                stack.append((cur, k))\\r\\n                cur, k = \"\", 0 # reset global vars\\r\\n            elif c == \"]\":\\r\\n                enc, n = stack.pop()\\r\\n                cur = enc + n * cur \\r\\n            elif c.isdigit():\\r\\n                k = k * 10 + int(c) # for two and three digit numbers\\r\\n            else:\\r\\n                cur += c # track the lower case letters\\r\\n        return cur\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772227,
                "title": "python-solution-using-stack-beats-98-3",
                "content": "```python\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = []\\n        a, d = \\'\\', \\'\\'\\n        for letter in s:\\n            if letter.isdigit():\\n                d+=letter\\n            elif letter.isalpha():\\n                a+=letter\\n            elif letter==\\'[\\':\\n                stack.append((a, int(d)))\\n                a, d = \\'\\', \\'\\'\\n            elif letter==\\']\\':\\n                p, n = stack.pop()\\n                a = p+a*n\\n            \\n        return a\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = []\\n        a, d = \\'\\', \\'\\'\\n        for letter in s:\\n            if letter.isdigit():\\n                d+=letter\\n            elif letter.isalpha():\\n                a+=letter\\n            elif letter==\\'[\\':\\n                stack.append((a, int(d)))\\n                a, d = \\'\\', \\'\\'\\n            elif letter==\\']\\':\\n                p, n = stack.pop()\\n                a = p+a*n\\n            \\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549026,
                "title": "how-to-explain-to-the-interviewer-in-an-interview-394-decode-string",
                "content": "Similar problems:\\n[224. Basic Calculator](https://leetcode.com/problems/basic-calculator/)\\n\\n#### 1. Clarify\\n(1) Is the input \"[abc]\" a valid input? -No, if there is a [], there must be a number in front of it\\n\\n#### 2. Idea\\nThis is a DFS problem, for example s = \"2[ab3[cd4[ef]]5[gh]]\", the tree is\\n<img src=\"https://assets.leetcode.com/users/qy9mg/image_1584966338.png\" width=\"300\">\\nIf a node is a number k, it means its children will be repeated k times. \\nIf a node is a string, it means you can use it directly. \\nIf two nodes are in the same level, that means we need to append the string represented by the next tree to the string represented by the previous tree, for example, string rooted at ab + string rooted at 3 + string rooted at 5\\n\\nif dfs(node) returns the string rooted at node, we should define dfs(node) like this:\\n```\\ndfs(node){\\n\\tStringBuilder sb = new StringBuilder();\\n\\tString children = dfs(child1) + dfs(child2) + dfs(child3) + ...\\n\\tfor(int i = 0; i < node.k; i ++){\\n\\t\\tsb.append(children);\\n\\t}\\n\\treturn sb.toString();\\n}\\n```\\n\\n#### 3. Solution\\n**Solution 1. Recursive** [This solution is from this post](https://leetcode.com/problems/decode-string/discuss/87544/Clean-C%2B%2B-Recursive-Solution-with-Explanation)\\n```\\nclass Solution {\\n    \\n    private int idx;\\n    private String s;\\n\\n    public String decodeString(String s) {\\n        idx = 0;\\n        this.s = s;\\n        return helper();\\n    }\\n\\n    private String helper() {\\n        int num = 0;\\n        String word = \"\";\\n        for(; idx < s.length(); idx++) {\\n            char cur = s.charAt(idx);\\n            if(cur == \\'[\\') {\\n                idx ++;\\n                String curStr = helper();\\n                for(; num > 0; num--) word += curStr;\\n            }\\n            else if (cur >= \\'0\\' && cur <=\\'9\\') {\\n                num = num * 10 + cur - \\'0\\';\\n            }\\n            else if (cur == \\']\\') {\\n                return word;\\n            }\\n            else { \\n                word += cur;\\n            }\\n        }\\n        return word;\\n    }\\n}\\n```\\n\\n-----\\n**Solution 2 Interative**\\nIterative solution explanation:\\nThe way the operation system deals with recursion is, before enter the next level of the recursive method, push the current state into a stack; after the next level of recursive method is done, fetch the state before it\\'s excuted, and do calcuation using the state and the result of the next level of recursive method, for example, the fibonacci series:\\n\\nBefore fibonacci(n - 2) runs, the OS must run fibonacci(n - 1)  and push its result into a stack, after fibonacci(n - 1) is run and get the result, the OS fetch the result of fibonacci(n - 2) and sum up with fibonacci(n - 1) and return.\\n\\n```\\nint fibonacci(n){\\n\\tif(n == 1) return 1;\\n\\tif(n == 2) return 2;\\n\\t\\n\\treturn fibonacci(n - 1) + fibonacci(n - 2);\\n}\\n```\\n\\nIn this problem, as is written in the top, we are using dfs to solve this problem:\\n```\\ndfs(node){\\n\\tStringBuilder sb = new StringBuilder(node.stringBeforeFirstChild);\\n\\tString children = dfs(node.child0) + dfs(node.child1) + dfs(node.child2) + ...\\n\\tfor(int i = 0; i < node.k; i ++){\\n\\t\\tsb.append(children);\\n\\t}\\n\\t\\n\\tsb.append(node.stringAfterLastChild);\\n\\treturn sb.toString();\\n}\\n```\\n\\n(1) When we encounter \\'[\\', it means we are going into the child, so we must push the current state into stacks. The current state includes the number k and the current String we get. Then we must reset the number and the current string because now we are processing the next level.\\n(2) when we encounter \\']\\', it means we finish the current level, now we must fetch the state before we go into this level, append the current level\\'s result after the previous state. \\n\\n```\\nclass Solution {\\n    public String decodeString(String s){\\n        Stack<Integer> counts = new Stack<>();\\n        Stack<String> prefixes = new Stack<>();\\n\\n        int count = 0;\\n        StringBuilder curString = new StringBuilder();\\n\\n        for (char c: s.toCharArray()){\\n            if (Character.isDigit(c)){\\n                count = count * 10 + c - \\'0\\';\\n            }\\n            else if (Character.isLetter(c)){\\n                curString.append(c);\\n            }\\n            else if (c == \\'[\\'){\\n                counts.add(count);\\n                prefixes.add(curString.toString());\\n\\n                count = 0;\\n                curString = new StringBuilder();\\n            }\\n            else {\\n                String temp = curString.toString();\\n                curString = new StringBuilder(prefixes.pop());\\n                int repeatTimes = counts.pop();\\n\\n                for(int i = 0; i < repeatTimes; i ++){\\n                    curString.append(temp);\\n                }\\n            }\\n        }\\n        return curString.toString();\\n    }\\n}\\n```\\n\\n#### 4. Complexity\\nTC: Both solutions are O(n) where n is the length of the string\\nSC: solution 1 is O(1), solution 2 is O(n)\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\ndfs(node){\\n\\tStringBuilder sb = new StringBuilder();\\n\\tString children = dfs(child1) + dfs(child2) + dfs(child3) + ...\\n\\tfor(int i = 0; i < node.k; i ++){\\n\\t\\tsb.append(children);\\n\\t}\\n\\treturn sb.toString();\\n}\\n```\n```\\nclass Solution {\\n    \\n    private int idx;\\n    private String s;\\n\\n    public String decodeString(String s) {\\n        idx = 0;\\n        this.s = s;\\n        return helper();\\n    }\\n\\n    private String helper() {\\n        int num = 0;\\n        String word = \"\";\\n        for(; idx < s.length(); idx++) {\\n            char cur = s.charAt(idx);\\n            if(cur == \\'[\\') {\\n                idx ++;\\n                String curStr = helper();\\n                for(; num > 0; num--) word += curStr;\\n            }\\n            else if (cur >= \\'0\\' && cur <=\\'9\\') {\\n                num = num * 10 + cur - \\'0\\';\\n            }\\n            else if (cur == \\']\\') {\\n                return word;\\n            }\\n            else { \\n                word += cur;\\n            }\\n        }\\n        return word;\\n    }\\n}\\n```\n```\\nint fibonacci(n){\\n\\tif(n == 1) return 1;\\n\\tif(n == 2) return 2;\\n\\t\\n\\treturn fibonacci(n - 1) + fibonacci(n - 2);\\n}\\n```\n```\\ndfs(node){\\n\\tStringBuilder sb = new StringBuilder(node.stringBeforeFirstChild);\\n\\tString children = dfs(node.child0) + dfs(node.child1) + dfs(node.child2) + ...\\n\\tfor(int i = 0; i < node.k; i ++){\\n\\t\\tsb.append(children);\\n\\t}\\n\\t\\n\\tsb.append(node.stringAfterLastChild);\\n\\treturn sb.toString();\\n}\\n```\n```\\nclass Solution {\\n    public String decodeString(String s){\\n        Stack<Integer> counts = new Stack<>();\\n        Stack<String> prefixes = new Stack<>();\\n\\n        int count = 0;\\n        StringBuilder curString = new StringBuilder();\\n\\n        for (char c: s.toCharArray()){\\n            if (Character.isDigit(c)){\\n                count = count * 10 + c - \\'0\\';\\n            }\\n            else if (Character.isLetter(c)){\\n                curString.append(c);\\n            }\\n            else if (c == \\'[\\'){\\n                counts.add(count);\\n                prefixes.add(curString.toString());\\n\\n                count = 0;\\n                curString = new StringBuilder();\\n            }\\n            else {\\n                String temp = curString.toString();\\n                curString = new StringBuilder(prefixes.pop());\\n                int repeatTimes = counts.pop();\\n\\n                for(int i = 0; i < repeatTimes; i ++){\\n                    curString.append(temp);\\n                }\\n            }\\n        }\\n        return curString.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 424563,
                "title": "java-o-n-solution-using-two-stacks-with-easy-explanation-and-comments",
                "content": "Three line explanation for interviews\\n1. Maintain two stacks nums and strings\\n\\t* The number stacks stores number of times a future string ( a string that is in upcoming square brackets) needs to be processed at the top.\\n\\t* The strings stack contains all the past strings have been processed. These past strings needs to be contactenated with future strings to give out the resultant strings\\n\\n\\nTime Complexity: O(n) \\nSpace Complexity: O(n) \\n\\nYou can follow me on https://twitter.com/Jaspind07199761 for DS and Algo tips\\nor connect on https://www.linkedin.com/in/jaspindersingh1/\\n\\n```\\nclass Solution {\\n    public String decodeString(String s) {\\n      Stack <Integer> num = new Stack<>();\\n      Stack <String> str = new Stack<>();\\n      String currStr = \"\";\\n      int currNum = 0;\\n      for(int i = 0; i < s.length(); i++){\\n          char c = s.charAt(i);\\n          if(Character.isDigit(c)){\\n              currNum = currNum * 10 + c - \\'0\\';\\n          } else if (c == \\'[\\'){\\n              // At the starting of square bracket push the past strings in string stack and num for future string in num stack\\n              num.push(currNum);\\n              str.push(currStr);\\n              currNum = 0;\\n              currStr = \"\";\\n          } else if ( c == \\']\\'){\\n              // At end of square bracket process the past string\\n              int times = num.pop();\\n              StringBuilder newStr = new StringBuilder(); // newString = \"\"\\n              for(int j = 0;j < times; j++){\\n                   newStr.append(currStr);\\n              }\\n              currStr = str.pop();\\n              currStr += newStr;\\n          } else {\\n              currStr += c;\\n          }\\n      }\\n        return currStr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n      Stack <Integer> num = new Stack<>();\\n      Stack <String> str = new Stack<>();\\n      String currStr = \"\";\\n      int currNum = 0;\\n      for(int i = 0; i < s.length(); i++){\\n          char c = s.charAt(i);\\n          if(Character.isDigit(c)){\\n              currNum = currNum * 10 + c - \\'0\\';\\n          } else if (c == \\'[\\'){\\n              // At the starting of square bracket push the past strings in string stack and num for future string in num stack\\n              num.push(currNum);\\n              str.push(currStr);\\n              currNum = 0;\\n              currStr = \"\";\\n          } else if ( c == \\']\\'){\\n              // At end of square bracket process the past string\\n              int times = num.pop();\\n              StringBuilder newStr = new StringBuilder(); // newString = \"\"\\n              for(int j = 0;j < times; j++){\\n                   newStr.append(currStr);\\n              }\\n              currStr = str.pop();\\n              currStr += newStr;\\n          } else {\\n              currStr += c;\\n          }\\n      }\\n        return currStr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924309,
                "title": "easy-solution-using-stack-c-tc-beats-100-mem-beats-90-72",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an empty string `ans` to store the decoded result.\\n2. Initialize a variable `num` to keep track of the current number being built.\\n3. Iterate through each character `s[i]` in the input string:\\n   - If `s[i]` is a digit, update the `num` accordingly.\\n   - If `s[i]` is an opening bracket `[`, push the current `ans` to the `str` stack, reset `ans` to an empty string, and push `num` to the `count` stack. Reset `num` to 0.\\n   - If `s[i]` is a closing bracket `]`, pop the top string from the `str` stack into `temp`, pop the top count from the `count` stack into `times`, and append `times` copies of `temp` to the current `ans`.\\n   - Otherwise, if `s[i]` is an alphabet character, add it to the current `ans`.\\n4. After iterating through all characters, the `ans` will contain the decoded string.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n![image.png](https://assets.leetcode.com/users/images/15cb1e2c-a86c-4a14-9a11-a1f6d7d0dc7a_1692303892.3943768.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string>str;\\n        stack<int>count;\\n        string ans=\"\";\\n        int num=0;\\n        for (int i=0;i<s.size();i++){\\n           if (s[i]>=\\'0\\' && s[i]<=\\'9\\'){ \\n               num=10*num+s[i]-\\'0\\';\\n           }\\n           else if (s[i]==\\'[\\') {//reset\\n                str.push(ans);\\n                ans=\"\";\\n                count.push(num);\\n                num=0;\\n           }\\n           else if(s[i]==\\']\\'){ //add the num times to the ans\\n               string temp=ans;\\n               ans=str.top();\\n               str.pop();\\n               int times=count.top();\\n               count.pop();\\n               while (times--){\\n                   ans+=temp;\\n               }\\n           }\\n           else { // for char \\n               ans+=s[i];\\n           }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf it\\'s helpfull , then please upvote \\u2B06\\uFE0F",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string>str;\\n        stack<int>count;\\n        string ans=\"\";\\n        int num=0;\\n        for (int i=0;i<s.size();i++){\\n           if (s[i]>=\\'0\\' && s[i]<=\\'9\\'){ \\n               num=10*num+s[i]-\\'0\\';\\n           }\\n           else if (s[i]==\\'[\\') {//reset\\n                str.push(ans);\\n                ans=\"\";\\n                count.push(num);\\n                num=0;\\n           }\\n           else if(s[i]==\\']\\'){ //add the num times to the ans\\n               string temp=ans;\\n               ans=str.top();\\n               str.pop();\\n               int times=count.top();\\n               count.pop();\\n               while (times--){\\n                   ans+=temp;\\n               }\\n           }\\n           else { // for char \\n               ans+=s[i];\\n           }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671952,
                "title": "c-python-clean-simple-solutions-w-explanation-recursive",
                "content": "\\u2714\\uFE0F Solution\\n1. add every character to the stack untill we get `\"]\"` \\n2. else decode the substring till we get `[`\\n3. and also decode the number untill there is no digit on the top of the stack\\n\\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = []\\n        for c in range(len(s)):\\n            if s[c] != \\']\\':\\n                stack.append(s[c])\\n            else:\\n                string = \\'\\'\\n                num = \\'\\'\\n                while stack[-1] != \\'[\\':\\n                    string = stack.pop() + string\\n                stack.pop()\\n                while stack and stack[-1].isdigit():\\n                    num = stack.pop() + num\\n                stack.append(int(num) * string)\\n                print(num)\\n        return \"\".join(stack)\\n```\\n\\n# ****\\u2714\\uFE0F UP VOTE IF HELPFUL",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = []\\n        for c in range(len(s)):\\n            if s[c] != \\']\\':\\n                stack.append(s[c])\\n            else:\\n                string = \\'\\'\\n                num = \\'\\'\\n                while stack[-1] != \\'[\\':\\n                    string = stack.pop() + string\\n                stack.pop()\\n                while stack and stack[-1].isdigit():\\n                    num = stack.pop() + num\\n                stack.append(int(num) * string)\\n                print(num)\\n        return \"\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515445,
                "title": "c-stack-0-ms-faster-than-100-approach-explained-easy-solution",
                "content": "\\uD83D\\uDC49 Approach :- We traverse the string and we push every character in the stack except the closing bracket. When we find the closing bracket we pop the element till we find the opening bracket. After doing this we will have the string that we have to copy. Then we pop the element unitl we are finding a digit. After doing this we will have the number till which we have to repeat the string we got. Then we push the string we got (number) times back in the stack. After traversing the given string completely we will have our answer in stack in reverse order\\n\\n**CODE:-**\\n\\nclass Solution {\\npublic:\\n*     string decodeString(string s) {\\n        stack<char>st;\\n        string ans = \"\";\\n        int len = s.length();\\n        for(int i = 0;i < len; i++)\\n        {\\n            if(s[i] != \\']\\')\\n            {\\n                st.push(s[i]);\\n            }else\\n            {\\n                string temp = \"\";\\n                while(st.top() != \\'[\\')\\n                {\\n                    temp += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                string num = \"\";\\n                while(st.size() > 0 && isdigit(st.top()))\\n                {\\n                    num += st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                int number = stoi(num);\\n                reverse(temp.begin(),temp.end());\\n                string copy = \"\";\\n                for(int j = 0;j < number; j++)\\n                {\\n                    for(int k = 0;k < temp.length(); k++)\\n                    {\\n                        st.push(temp[k]);\\n                    }\\n                }\\n            }\\n        }\\n        while(st.size() > 0)\\n        {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n**DO upvote if you understood it !**",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n*     string decodeString(string s) {\\n        stack<char>st;\\n        string ans = \"\";\\n        int len = s.length();\\n        for(int i = 0;i < len; i++)\\n        {\\n            if(s[i] != \\']\\')\\n            {\\n                st.push(s[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1635433,
                "title": "100-faster-recursive-solution-detailed-explanation",
                "content": "<br/> The crux of this recursive problem is that solve the substring between \\'[\\' and \\']\\' as an independent problem, because that may also contain other such bracket sequences. <br/>\\n\\n**Steps:**\\n* let cur = s[pos]\\n* if cur is an alphabet, then just add it our ans string\\n* if cur is a digit, then take it in a variable num, to keep track of how many times we need to repeat the subtring after it (remember that the integer can be `between [1, 300]` not just single digit\\n* if cur is \\'[\\' (`opening bracket`) then call the function recursively with pos starting from the next character\\n* append the string returned by recursive call num times to our ans\\n* if cur is \\']\\' (`closing bracket`) then just return the ans, see carefully that \\']\\' will be encountered only at the end of a recursive call, so the ans formed in current call will be returned to caller (after getting \\'[\\') and `appended num times`\\n* reason for passing pos by reference is that in the recursive call also we don\\'t want to repeat any operation, i.e. `when recursive call ends, we want to continue after \\']\\'` so pos should be changed in each call\\n\\n<br/>\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    string solve(string s, int& pos) {\\n        \\n        int n = s.size(), num = 0;\\n        string ans = \"\";\\n        \\n        for(; pos < n; pos++) {\\n            \\n            char cur = s[pos];\\n            if(isalpha(cur)) ans += cur;\\n            else if(isdigit(cur)) num = num * 10 + cur - \\'0\\';\\n            else if(cur == \\']\\') return ans;\\n\\t\\t\\t// cur == \\'[\\'\\n            else {\\n                string tmp = solve(s, ++pos);\\n                while(num--) ans += tmp;\\n                num = 0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    string decodeString(string s) {\\n        int i = 0;\\n        return solve(s, i);\\n    }\\n};\\n```\\n\\n<br/>",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string solve(string s, int& pos) {\\n        \\n        int n = s.size(), num = 0;\\n        string ans = \"\";\\n        \\n        for(; pos < n; pos++) {\\n            \\n            char cur = s[pos];\\n            if(isalpha(cur)) ans += cur;\\n            else if(isdigit(cur)) num = num * 10 + cur - \\'0\\';\\n            else if(cur == \\']\\') return ans;\\n\\t\\t\\t// cur == \\'[\\'\\n            else {\\n                string tmp = solve(s, ++pos);\\n                while(num--) ans += tmp;\\n                num = 0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    string decodeString(string s) {\\n        int i = 0;\\n        return solve(s, i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385397,
                "title": "100-faster-java-solution-using-two-stack-efficient-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> is = new Stack<>();\\n        Stack<StringBuilder> ss = new Stack<>();\\n\\n        int n = s.length(), num = 0;\\n        StringBuilder str = new StringBuilder();\\n\\n        for(char ch : s.toCharArray()) {\\n            // There will be 4 types of characters --> number, [ , ], character\\n\\n            if(ch >= \\'0\\' && ch <= \\'9\\') {\\n                num = (num * 10) + ch - \\'0\\';\\n            } else if(ch == \\'[\\') {\\n                ss.push(str);\\n                str = new StringBuilder();\\n\\n                is.push(num);\\n                num = 0;\\n            } else if(ch == \\']\\') {\\n                StringBuilder temp = str;\\n                str = ss.pop();\\n                int count = is.pop();\\n\\n                while(count-- > 0) {\\n                    str.append(temp);\\n                }\\n            } else {\\n                str.append(ch);\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> is = new Stack<>();\\n        Stack<StringBuilder> ss = new Stack<>();\\n\\n        int n = s.length(), num = 0;\\n        StringBuilder str = new StringBuilder();\\n\\n        for(char ch : s.toCharArray()) {\\n            // There will be 4 types of characters --> number, [ , ], character\\n\\n            if(ch >= \\'0\\' && ch <= \\'9\\') {\\n                num = (num * 10) + ch - \\'0\\';\\n            } else if(ch == \\'[\\') {\\n                ss.push(str);\\n                str = new StringBuilder();\\n\\n                is.push(num);\\n                num = 0;\\n            } else if(ch == \\']\\') {\\n                StringBuilder temp = str;\\n                str = ss.pop();\\n                int count = is.pop();\\n\\n                while(count-- > 0) {\\n                    str.append(temp);\\n                }\\n            } else {\\n                str.append(ch);\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941375,
                "title": "js-4-line-solution-with-regexp",
                "content": "The idea is simple. While we have a bracket in the input string, find all encoded strings, which are patterns like *number[word]* and replace them with *word* repeated *number* of times\\n\\n```js\\nconst decodeString = s => {\\n    while (s.includes(\\'[\\')) {\\n        s = s.replace(/(\\\\d+)\\\\[(\\\\w+)\\\\]/g, (_, number, word) => word.repeat(number));\\n    }\\n    return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst decodeString = s => {\\n    while (s.includes(\\'[\\')) {\\n        s = s.replace(/(\\\\d+)\\\\[(\\\\w+)\\\\]/g, (_, number, word) => word.repeat(number));\\n    }\\n    return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 827515,
                "title": "python-recursive-soln-o-n-95-performance-commented",
                "content": "My recursive solution below will make a single pass of some input string \\'s\\'. A pointer variable `idx` is used as a \"global-like\" pointer for all nested recursive calls. Using my helper function `decode`, I parse \\'s\\' from the first index, and build a string.\\n* Anytime we encounter a digit, we trigger the steps that result in a recursive call.\\n* Anytime we encounter a alphabetical character, we build our string\\n* Anytime we encounter a right bracket, \\']\\', we return the string multiplied by the multiplier passed from its caller\\n\\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        idx = 0                                      # index pointer for \\'s\\' string\\n        def decode(s, mult=1) -> str:                # define recursive decode helper function\\n            nonlocal idx                             # reference our index pointer\\n            curr_str = \\'\\'                            # begin with an empty string\\n            while idx < len(s):                      # while there remains un-parsed letters\\n                if s[idx].isdigit():                 # parse digit, triggers recursive call\\n                    curr_mult = \\'\\'                   # derive the multiplier\\n                    while s[idx].isdigit():          # parse all digits\\n                        curr_mult += s[idx]\\n                        idx += 1\\n                    idx += 1                         # move the pointer past left bracket \\'[\\'\\n                    curr_str += decode(s, mult=int(curr_mult))  # recursive call\\n                elif s[idx].isalpha():               # parse alphabet char, build the string\\n                    curr_str += s[idx]\\n                    idx += 1\\n                else:                                # parse right bracket \\']\\', call end condition\\n                    idx += 1\\n                    return mult * curr_str           # multiply the resulting string from this call and return\\n            return mult * curr_str\\n        return decode(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        idx = 0                                      # index pointer for \\'s\\' string\\n        def decode(s, mult=1) -> str:                # define recursive decode helper function\\n            nonlocal idx                             # reference our index pointer\\n            curr_str = \\'\\'                            # begin with an empty string\\n            while idx < len(s):                      # while there remains un-parsed letters\\n                if s[idx].isdigit():                 # parse digit, triggers recursive call\\n                    curr_mult = \\'\\'                   # derive the multiplier\\n                    while s[idx].isdigit():          # parse all digits\\n                        curr_mult += s[idx]\\n                        idx += 1\\n                    idx += 1                         # move the pointer past left bracket \\'[\\'\\n                    curr_str += decode(s, mult=int(curr_mult))  # recursive call\\n                elif s[idx].isalpha():               # parse alphabet char, build the string\\n                    curr_str += s[idx]\\n                    idx += 1\\n                else:                                # parse right bracket \\']\\', call end condition\\n                    idx += 1\\n                    return mult * curr_str           # multiply the resulting string from this call and return\\n            return mult * curr_str\\n        return decode(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846797,
                "title": "go-simple-solution-using-stack-100-runtime-92-memory",
                "content": "# Code\\n```\\ntype item struct {\\n\\tn     int\\n\\tbytes []byte\\n}\\n\\nfunc decodeString(str string) string {\\n\\tnum := 0\\n\\tst := []item{{1, []byte{}}}\\n\\n\\tfor i := range str {\\n\\t\\tswitch {\\n\\t\\tcase str[i] == \\'0\\':\\n\\t\\t\\tnum *= 10\\n\\t\\tcase str[i] > \\'0\\' && str[i] <= \\'9\\':\\n\\t\\t\\tnum = num*10 + int(str[i]-\\'0\\')\\n\\t\\tcase str[i] == \\'[\\':\\n\\t\\t\\tst = append(st, item{num, []byte{}})\\n\\t\\t\\tnum = 0\\n\\t\\tcase str[i] == \\']\\':\\n\\t\\t\\ttmp := st[len(st)-1]\\n\\t\\t\\tst = st[:len(st)-1]\\n\\t\\t\\tfor j := 0; j < tmp.n; j++ {\\n\\t\\t\\t\\tst[len(st)-1].bytes = append(st[len(st)-1].bytes, tmp.bytes...)\\n\\t\\t\\t}\\n\\t\\tdefault:\\n\\t\\t\\tst[len(st)-1].bytes = append(st[len(st)-1].bytes, str[i])\\n\\t\\t}\\n\\t}\\n\\n\\treturn string(st[0].bytes)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype item struct {\\n\\tn     int\\n\\tbytes []byte\\n}\\n\\nfunc decodeString(str string) string {\\n\\tnum := 0\\n\\tst := []item{{1, []byte{}}}\\n\\n\\tfor i := range str {\\n\\t\\tswitch {\\n\\t\\tcase str[i] == \\'0\\':\\n\\t\\t\\tnum *= 10\\n\\t\\tcase str[i] > \\'0\\' && str[i] <= \\'9\\':\\n\\t\\t\\tnum = num*10 + int(str[i]-\\'0\\')\\n\\t\\tcase str[i] == \\'[\\':\\n\\t\\t\\tst = append(st, item{num, []byte{}})\\n\\t\\t\\tnum = 0\\n\\t\\tcase str[i] == \\']\\':\\n\\t\\t\\ttmp := st[len(st)-1]\\n\\t\\t\\tst = st[:len(st)-1]\\n\\t\\t\\tfor j := 0; j < tmp.n; j++ {\\n\\t\\t\\t\\tst[len(st)-1].bytes = append(st[len(st)-1].bytes, tmp.bytes...)\\n\\t\\t\\t}\\n\\t\\tdefault:\\n\\t\\t\\tst[len(st)-1].bytes = append(st[len(st)-1].bytes, str[i])\\n\\t\\t}\\n\\t}\\n\\n\\treturn string(st[0].bytes)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2769142,
                "title": "easy-jav-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        String res = \"\";\\n        Stack<Integer> countStack = new Stack<>();\\n        Stack<String> resStack = new Stack<>();\\n        int idx = 0;\\n        while (idx < s.length()) {\\n            if (Character.isDigit(s.charAt(idx))) {\\n                int count = 0;\\n                while (Character.isDigit(s.charAt(idx))) {\\n                    count = 10 * count + (s.charAt(idx) - \\'0\\');\\n                    idx++;\\n                }\\n                countStack.push(count);\\n            }\\n            else if (s.charAt(idx) == \\'[\\') {\\n                resStack.push(res);\\n                res = \"\";\\n                idx++;\\n            }\\n            else if (s.charAt(idx) == \\']\\') {\\n                StringBuilder temp = new StringBuilder (resStack.pop());\\n                int repeatTimes = countStack.pop();\\n                for (int i = 0; i < repeatTimes; i++) {\\n                    temp.append(res);\\n                }\\n                res = temp.toString();\\n                idx++;\\n            }\\n            else {\\n                res += s.charAt(idx++);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        String res = \"\";\\n        Stack<Integer> countStack = new Stack<>();\\n        Stack<String> resStack = new Stack<>();\\n        int idx = 0;\\n        while (idx < s.length()) {\\n            if (Character.isDigit(s.charAt(idx))) {\\n                int count = 0;\\n                while (Character.isDigit(s.charAt(idx))) {\\n                    count = 10 * count + (s.charAt(idx) - \\'0\\');\\n                    idx++;\\n                }\\n                countStack.push(count);\\n            }\\n            else if (s.charAt(idx) == \\'[\\') {\\n                resStack.push(res);\\n                res = \"\";\\n                idx++;\\n            }\\n            else if (s.charAt(idx) == \\']\\') {\\n                StringBuilder temp = new StringBuilder (resStack.pop());\\n                int repeatTimes = countStack.pop();\\n                for (int i = 0; i < repeatTimes; i++) {\\n                    temp.append(res);\\n                }\\n                res = temp.toString();\\n                idx++;\\n            }\\n            else {\\n                res += s.charAt(idx++);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014602,
                "title": "simple-c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char>st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\']\\')\\n                st.push(s[i]);\\n            else\\n            {\\n                string characters=\"\";\\n                while(st.top()!=\\'[\\')\\n                {\\n                    characters=st.top()+characters;\\n                    st.pop();\\n                }\\n                st.pop();\\n                string number=\"\";\\n                while(!st.empty() && isdigit(st.top()))\\n                {\\n                    number=st.top()+number;\\n                    st.pop();\\n                   \\n                }\\n                for(int j=0;j<stoll(number);j++)\\n                {\\n                    for(int k=0;k<characters.size();k++)\\n                     {\\n                            st.push(characters[k]);\\n                     }\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty())\\n         {  \\n             ans=st.top()+ans;\\n             st.pop();\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char>st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\']\\')\\n                st.push(s[i]);\\n            else\\n            {\\n                string characters=\"\";\\n                while(st.top()!=\\'[\\')\\n                {\\n                    characters=st.top()+characters;\\n                    st.pop();\\n                }\\n                st.pop();\\n                string number=\"\";\\n                while(!st.empty() && isdigit(st.top()))\\n                {\\n                    number=st.top()+number;\\n                    st.pop();\\n                   \\n                }\\n                for(int j=0;j<stoll(number);j++)\\n                {\\n                    for(int k=0;k<characters.size();k++)\\n                     {\\n                            st.push(characters[k]);\\n                     }\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty())\\n         {  \\n             ans=st.top()+ans;\\n             st.pop();\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851228,
                "title": "java-and-python3-stack-clear-annotation",
                "content": "***Please upvote if it helps\\uD83D\\uDE0A.***\\n\\n\\tStep1:put the char into the stack, except \\']\\'\\n\\tStep2:if char == \\']\\',start to find the (1)subStr;(2)k due to the formation of k[subStr]\\n\\t\\tStep2-1:find the (1)subStr and remove the \\'[\\' in the stack\\n\\t\\tStep2-2:find the (2)k and remove the k in the stack. k is in range [1,300]\\n\\t\\tStep2-3:push the subStr into the stack\\n\\tStep3:reverse the stack\\n\\n***Thanks a lot for [this answer](https://leetcode.com/problems/decode-string/discuss/1635285/Java-or-Single-Stack-or-Iterative-Approach-or-Detailed-Explanation)***\\n\\nJava codes:\\n```\\n   public String decodeString(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\n        for(char c : s.toCharArray()){\\n\\n            // Step2:if char == \\']\\',start to find the (1)subStr;(2)k due to the formation of k[subStr]\\n            if(c == \\']\\'){\\n                StringBuilder subStr = new StringBuilder();\\n                String temp = new String();\\n                int k;\\n                //Step2-1:find the (1)subStr and remove the \\'[\\' in the stack\\n                while(!stack.isEmpty() && stack.peek() != \\'[\\'){\\n                    subStr.append(stack.pop());\\n                }\\n                stack.pop();\\n\\n                //Step2-2:find the (2)k and remove the k in the stack. k is in range [1,300]\\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\\n                    temp = stack.pop() + temp;\\n                }\\n                k = Integer.parseInt(temp);\\n\\n                //Step2-3:push the subStr into the stack\\n                while(k-- > 0){\\n                    for(int i = subStr.length() - 1;i >= 0;i--){\\n                        stack.push(subStr.charAt(i));\\n                    }\\n                }\\n            }else{\\n                // Step1:put the char into the stack, except \\']\\'\\n                stack.push(c);\\n            }\\n        }\\n\\n        //Step3:reverse the stack\\n        char[] result = new char[stack.size()];\\n        int i = stack.size() - 1;\\n        while(!stack.isEmpty()){\\n            result[i--] = stack.pop();\\n        }\\n        return new String(result);\\n```\\nPython3 codes:\\n```\\nclass Solution:\\n    def decodeString(self, s):\\n        # In python, List can be used as stack(by using pop()) and queue(by using pop(0))\\n        result = []\\n        for curr_char in s:\\n            if curr_char == \"]\":\\n                # Step2-1 : Find the (1)subStr and remove \"[\" in the stack\\n                sub_str = []\\n                while result[-1] != \"[\":\\n                    sub_str.append(result.pop())\\n                sub_str = \"\".join(sub_str[::-1])\\n\\n                # Step2-2 : Find the (2)k and remove k in the stack\\n                result.pop()\\n                k = []\\n                while len(result) > 0 and result[-1] <= \"9\":\\n                    k.append(result.pop())\\n                k = int(\"\".join(k[::-1]))\\n\\n                # Step2-3 : Repeat sub_str k times after stack\\n                result += k*sub_str\\n\\n            else:\\n                # Step1 : Put the char into the stack, except \"]\"\\n                result.append(curr_char)\\n        return \"\".join(result)\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n   public String decodeString(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\n        for(char c : s.toCharArray()){\\n\\n            // Step2:if char == \\']\\',start to find the (1)subStr;(2)k due to the formation of k[subStr]\\n            if(c == \\']\\'){\\n                StringBuilder subStr = new StringBuilder();\\n                String temp = new String();\\n                int k;\\n                //Step2-1:find the (1)subStr and remove the \\'[\\' in the stack\\n                while(!stack.isEmpty() && stack.peek() != \\'[\\'){\\n                    subStr.append(stack.pop());\\n                }\\n                stack.pop();\\n\\n                //Step2-2:find the (2)k and remove the k in the stack. k is in range [1,300]\\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\\n                    temp = stack.pop() + temp;\\n                }\\n                k = Integer.parseInt(temp);\\n\\n                //Step2-3:push the subStr into the stack\\n                while(k-- > 0){\\n                    for(int i = subStr.length() - 1;i >= 0;i--){\\n                        stack.push(subStr.charAt(i));\\n                    }\\n                }\\n            }else{\\n                // Step1:put the char into the stack, except \\']\\'\\n                stack.push(c);\\n            }\\n        }\\n\\n        //Step3:reverse the stack\\n        char[] result = new char[stack.size()];\\n        int i = stack.size() - 1;\\n        while(!stack.isEmpty()){\\n            result[i--] = stack.pop();\\n        }\\n        return new String(result);\\n```\n```\\nclass Solution:\\n    def decodeString(self, s):\\n        # In python, List can be used as stack(by using pop()) and queue(by using pop(0))\\n        result = []\\n        for curr_char in s:\\n            if curr_char == \"]\":\\n                # Step2-1 : Find the (1)subStr and remove \"[\" in the stack\\n                sub_str = []\\n                while result[-1] != \"[\":\\n                    sub_str.append(result.pop())\\n                sub_str = \"\".join(sub_str[::-1])\\n\\n                # Step2-2 : Find the (2)k and remove k in the stack\\n                result.pop()\\n                k = []\\n                while len(result) > 0 and result[-1] <= \"9\":\\n                    k.append(result.pop())\\n                k = int(\"\".join(k[::-1]))\\n\\n                # Step2-3 : Repeat sub_str k times after stack\\n                result += k*sub_str\\n\\n            else:\\n                # Step1 : Put the char into the stack, except \"]\"\\n                result.append(curr_char)\\n        return \"\".join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635533,
                "title": "python-stack-beats-95-simplest-solution",
                "content": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = []\\n        lenS = len(s)\\n        i = 0\\n        while i < lenS:\\n            if s[i] == \\']\\':\\n                decoded = \\'\\'\\n                while stack and stack[-1] != \\'[\\':\\n                    decoded = stack.pop() + decoded\\n                stack.pop()\\n                decoded *= int(stack.pop())\\n                stack.append(decoded)\\n            elif s[i].isdigit():\\n                if stack and stack[-1].isdigit():\\n                    stack[-1] += s[i]\\n                else:\\n                    stack.append(s[i])\\n            else:\\n                stack.append(s[i])\\n            i += 1\\n        decoded = \\'\\'\\n        while stack:\\n            decoded = stack.pop() + decoded\\n        return decoded\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = []\\n        lenS = len(s)\\n        i = 0\\n        while i < lenS:\\n            if s[i] == \\']\\':\\n                decoded = \\'\\'\\n                while stack and stack[-1] != \\'[\\':\\n                    decoded = stack.pop() + decoded\\n                stack.pop()\\n                decoded *= int(stack.pop())\\n                stack.append(decoded)\\n            elif s[i].isdigit():\\n                if stack and stack[-1].isdigit():\\n                    stack[-1] += s[i]\\n                else:\\n                    stack.append(s[i])\\n            else:\\n                stack.append(s[i])\\n            i += 1\\n        decoded = \\'\\'\\n        while stack:\\n            decoded = stack.pop() + decoded\\n        return decoded\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635285,
                "title": "java-single-stack-iterative-approach-detailed-explanation",
                "content": "```\\nIntuition :\\n1) If string does not have inner substring like this 3[a5[cd]] then it can be solved easily (simple iteration)\\n2) In some cases, we can have inner sub string as I mentioned above then it is best to solve with stack. Solve inner substring first.(Iterative approach)\\n3) Insert the character in stack until you find \\']\\' char\\n4) If you find \\']\\' char then pop the character until you find \\'[\\', This is how you can get the substring.\\n5) Remove the \\'[\\' character\\n6) Find the number k, number can be in single digit, two digits, .. so on.\\n7) Put back the substring k times in stack\\n8) Atlast take the result in one char array because stack format will not in string format.\\n9) return the result\\n```\\n```\\npublic String decodeString(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char ch : s.toCharArray()){\\n            if(ch != \\']\\'){\\n                stack.push(ch);\\n            }else{\\n                //get the sub string\\n                StringBuilder sb = new StringBuilder();\\n                while(stack.peek() != \\'[\\'){\\n                    sb.append(stack.pop());\\n                }\\n                //remove the \\'[\\' character\\n                stack.pop();\\n                //get the number\\n                int k = 0;\\n                int base = 1;\\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\\n                    k = (stack.pop() - \\'0\\') * base + k;\\n                    base *= 10;\\n                }\\n                //put back the substring in stack k times\\n                while(k-- > 0){\\n                    for(int i=sb.length()-1; i>=0; i--){\\n                        stack.push(sb.charAt(i));\\n                    }\\n                }\\n            }\\n        }\\n        char[] result = new char[stack.size()];\\n        for(int i=stack.size()-1;i>=0;i--)\\n            result[i] = stack.pop();\\n        return new String(result);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nIntuition :\\n1) If string does not have inner substring like this 3[a5[cd]] then it can be solved easily (simple iteration)\\n2) In some cases, we can have inner sub string as I mentioned above then it is best to solve with stack. Solve inner substring first.(Iterative approach)\\n3) Insert the character in stack until you find \\']\\' char\\n4) If you find \\']\\' char then pop the character until you find \\'[\\', This is how you can get the substring.\\n5) Remove the \\'[\\' character\\n6) Find the number k, number can be in single digit, two digits, .. so on.\\n7) Put back the substring k times in stack\\n8) Atlast take the result in one char array because stack format will not in string format.\\n9) return the result\\n```\n```\\npublic String decodeString(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char ch : s.toCharArray()){\\n            if(ch != \\']\\'){\\n                stack.push(ch);\\n            }else{\\n                //get the sub string\\n                StringBuilder sb = new StringBuilder();\\n                while(stack.peek() != \\'[\\'){\\n                    sb.append(stack.pop());\\n                }\\n                //remove the \\'[\\' character\\n                stack.pop();\\n                //get the number\\n                int k = 0;\\n                int base = 1;\\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\\n                    k = (stack.pop() - \\'0\\') * base + k;\\n                    base *= 10;\\n                }\\n                //put back the substring in stack k times\\n                while(k-- > 0){\\n                    for(int i=sb.length()-1; i>=0; i--){\\n                        stack.push(sb.charAt(i));\\n                    }\\n                }\\n            }\\n        }\\n        char[] result = new char[stack.size()];\\n        for(int i=stack.size()-1;i>=0;i--)\\n            result[i] = stack.pop();\\n        return new String(result);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 818463,
                "title": "c-0-ms-solution-100-00-1-stack-approach-easy-to-understand",
                "content": "***Runtime: 0 ms, faster than 100.00% of C++ online submissions for Decode String.\\nMemory Usage: 6.6 MB, less than 60.19% of C++ online submissions for Decode String.***\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        string result;\\n        stack<string> st;\\n        for(int i = 0 ;i < s.size(); i++){\\n            if(isdigit(s[i])){\\n                int num = 0;\\n                while(i < s.size() && isdigit(s[i])){\\n                    num = num * 10 + (s[i++] - \\'0\\');\\n                }\\n                i--;\\n                st.push(to_string(num));\\n            }else if(isalpha(s[i])){\\n                string word = \"\";\\n                while(i < s.size() && isalpha(s[i])){\\n                    word = word + s[i++];\\n                }\\n                i--;\\n                st.push(word);\\n            }else if(s[i] == \\'[\\'){\\n                st.push(\"[\");\\n            }else if(s[i] == \\']\\'){\\n                string word, current;\\n                while(st.top() != \"[\"){\\n                    word = st.top() + word;\\n                    st.pop();\\n                }\\n                st.pop();\\n                int times = stoi(st.top());  st.pop();\\n                while(times--){\\n                    current += word;\\n                }\\n                st.push(current);\\n            }\\n        }\\n        while(!st.empty()){\\n            result = st.top() + result; \\n            st.pop();\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        string result;\\n        stack<string> st;\\n        for(int i = 0 ;i < s.size(); i++){\\n            if(isdigit(s[i])){\\n                int num = 0;\\n                while(i < s.size() && isdigit(s[i])){\\n                    num = num * 10 + (s[i++] - \\'0\\');\\n                }\\n                i--;\\n                st.push(to_string(num));\\n            }else if(isalpha(s[i])){\\n                string word = \"\";\\n                while(i < s.size() && isalpha(s[i])){\\n                    word = word + s[i++];\\n                }\\n                i--;\\n                st.push(word);\\n            }else if(s[i] == \\'[\\'){\\n                st.push(\"[\");\\n            }else if(s[i] == \\']\\'){\\n                string word, current;\\n                while(st.top() != \"[\"){\\n                    word = st.top() + word;\\n                    st.pop();\\n                }\\n                st.pop();\\n                int times = stoi(st.top());  st.pop();\\n                while(times--){\\n                    current += word;\\n                }\\n                st.push(current);\\n            }\\n        }\\n        while(!st.empty()){\\n            result = st.top() + result; \\n            st.pop();\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762300,
                "title": "python-stack",
                "content": "Note:\\nI use cur_level string as an array because strings are immutable in python and it\\'s better working with arrays and then concat\\n\\n```\\ndef decodeString(self, s: str) -> str:\\n        stack = []\\n        cur_level = []\\n        num = 0\\n        \\n        for char in s:\\n            if char.isdigit():\\n                num = num * 10 + int(char)\\n            \\n            elif char.isalpha():\\n                cur_level.append(char)\\n            \\n            elif char == \\'[\\':\\n                stack.append((num, [*cur_level]))\\n                cur_level = []\\n                num = 0\\n            \\n            elif char == \\']\\':\\n                prev_level_num, prev_level = stack.pop()\\n                cur_level_string = \"\".join(cur_level)\\n                cur_level = [*prev_level, prev_level_num * cur_level_string] \\n            \\n        return \"\".join(cur_level)\\n```",
                "solutionTags": [],
                "code": "```\\ndef decodeString(self, s: str) -> str:\\n        stack = []\\n        cur_level = []\\n        num = 0\\n        \\n        for char in s:\\n            if char.isdigit():\\n                num = num * 10 + int(char)\\n            \\n            elif char.isalpha():\\n                cur_level.append(char)\\n            \\n            elif char == \\'[\\':\\n                stack.append((num, [*cur_level]))\\n                cur_level = []\\n                num = 0\\n            \\n            elif char == \\']\\':\\n                prev_level_num, prev_level = stack.pop()\\n                cur_level_string = \"\".join(cur_level)\\n                cur_level = [*prev_level, prev_level_num * cur_level_string] \\n            \\n        return \"\".join(cur_level)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 752163,
                "title": "python-regex-beats-99",
                "content": "```\\nimport re\\n\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n\\t\\n        while True:\\n\\t\\t\\t# find a match with a number followed by a bracket enclosing a substring (with no more brackets inside)\\n            match = re.search(\\'(\\\\d+)\\\\[(\\\\w+)\\\\]\\', s)\\n\\t\\t\\t\\n\\t\\t\\t# if no match we are done\\n            if not match:\\n                break\\n\\t\\t\\t\\t\\n\\t\\t\\t# break the match into the number and substring\\n            mult = int(match.group(1))\\n            sub = match.group(2)\\n\\t\\t\\t\\n\\t\\t\\t# substitute the original match with the substring multiplied by the number and continue with the updated string\\n            s = re.sub(\\'\\\\d+\\\\[\\\\w+\\\\]\\', mult*sub, s, 1)\\n\\t\\t\\t\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport re\\n\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n\\t\\n        while True:\\n\\t\\t\\t# find a match with a number followed by a bracket enclosing a substring (with no more brackets inside)\\n            match = re.search(\\'(\\\\d+)\\\\[(\\\\w+)\\\\]\\', s)\\n\\t\\t\\t\\n\\t\\t\\t# if no match we are done\\n            if not match:\\n                break\\n\\t\\t\\t\\t\\n\\t\\t\\t# break the match into the number and substring\\n            mult = int(match.group(1))\\n            sub = match.group(2)\\n\\t\\t\\t\\n\\t\\t\\t# substitute the original match with the substring multiplied by the number and continue with the updated string\\n            s = re.sub(\\'\\\\d+\\\\[\\\\w+\\\\]\\', mult*sub, s, 1)\\n\\t\\t\\t\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 618832,
                "title": "javascript-clean",
                "content": "```javascript\\nconst decodeString = (s) => {\\n    const stack = new Array();\\n    \\n    for(let i = 0; i < s.length; i++) { \\n        const char = s.charAt(i);\\n        if(isClose(char)) {\\n            let decoded = getInner(stack);\\n            let counter = getCounter(stack);\\n            let repeated = decoded.repeat(counter);\\n            \\n            stack.push(repeated);\\n\\n        } else stack.push(char);\\n    }\\n    \\n    let ans = \\'\\';\\n    while(stack.length) ans = `${stack.pop()}${ans}`;\\n    \\n    return ans;\\n};\\n\\nconst getCounter = (stack) => {\\n    let ans = \\'\\';\\n    while( isNum(stack[stack.length - 1]) ) ans = `${stack.pop()}${ans}`;\\n    return parseInt(ans);\\n};\\n\\nconst getInner = (stack) => {\\n    let ans = \\'\\';\\n    while(!isOpen(stack[stack.length - 1] )) {\\n        ans = `${stack.pop()}${ans}`;\\n    }\\n    stack.pop(); // leftover\\n    return ans;\\n}\\n\\nconst isNum = char => char >= \\'0\\' && char <= \\'9\\';\\nconst isOpen = char => char ===\\'[\\';\\nconst isClose = char => char === \\']\\';\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst decodeString = (s) => {\\n    const stack = new Array();\\n    \\n    for(let i = 0; i < s.length; i++) { \\n        const char = s.charAt(i);\\n        if(isClose(char)) {\\n            let decoded = getInner(stack);\\n            let counter = getCounter(stack);\\n            let repeated = decoded.repeat(counter);\\n            \\n            stack.push(repeated);\\n\\n        } else stack.push(char);\\n    }\\n    \\n    let ans = \\'\\';\\n    while(stack.length) ans = `${stack.pop()}${ans}`;\\n    \\n    return ans;\\n};\\n\\nconst getCounter = (stack) => {\\n    let ans = \\'\\';\\n    while( isNum(stack[stack.length - 1]) ) ans = `${stack.pop()}${ans}`;\\n    return parseInt(ans);\\n};\\n\\nconst getInner = (stack) => {\\n    let ans = \\'\\';\\n    while(!isOpen(stack[stack.length - 1] )) {\\n        ans = `${stack.pop()}${ans}`;\\n    }\\n    stack.pop(); // leftover\\n    return ans;\\n}\\n\\nconst isNum = char => char >= \\'0\\' && char <= \\'9\\';\\nconst isOpen = char => char ===\\'[\\';\\nconst isClose = char => char === \\']\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 408777,
                "title": "javascript-simple-logic-solution-w-explanation",
                "content": "#### The idea\\nGiven the example from the description,  `s = \"3[a2[c]]\"`, since it is possible for us to encounter nested brackets, my intuition is to always figure out the inner-most bracket first. So, In order to find the inner-most brackets, I  try to find the last `[`, and the first `]` after that, and with a `while` loop to figure our how many repetitions we need.\\n\\n``` javascript\\nvar decodeString = function(s) {\\n    while(s.indexOf(\\'[\\')!=-1) { // base case, breaks when there\\'s no bracket found\\n        let left = s.lastIndexOf(\\'[\\'); // left position of the inner-most `[`\\n        let right = left + s.substring(left).indexOf(\\']\\'); // right positio of the inner-most `]`\\n        let word = s.substring(left+1, right); // between them is the string\\n        let count = \"\";\\n        while(s[left-1] >= 0 && s[left-1]<=9) { // try to find a valid number\\n            left--;\\n            count = s[left] + count;\\n        }\\n        s = s.substring(0,left) + word.repeat(count) + s.substring(right+1); // put them all togher and repeat :)\\n    }\\n    return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar decodeString = function(s) {\\n    while(s.indexOf(\\'[\\')!=-1) { // base case, breaks when there\\'s no bracket found\\n        let left = s.lastIndexOf(\\'[\\'); // left position of the inner-most `[`\\n        let right = left + s.substring(left).indexOf(\\']\\'); // right positio of the inner-most `]`\\n        let word = s.substring(left+1, right); // between them is the string\\n        let count = \"\";\\n        while(s[left-1] >= 0 && s[left-1]<=9) { // try to find a valid number\\n            left--;\\n            count = s[left] + count;\\n        }\\n        s = s.substring(0,left) + word.repeat(count) + s.substring(right+1); // put them all togher and repeat :)\\n    }\\n    return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 203854,
                "title": "easy-to-understand-javascript",
                "content": "Modified from a python solution by user simkieu\\n\\n```\\nfunction decocdeString(s) {\\n  let stack = []\\n  let curNum = 0\\n  let curString = \\'\\'\\n  for (let c of s) {\\n    if (c === \\'[\\') {\\n      stack.push(curString)\\n      stack.push(curNum)\\n      curNum = 0\\n      curString = \\'\\'\\n    } else if (c === \\']\\') {\\n      let num = stack.pop()\\n      let prevString = stack.pop()\\n      curString = prevString + curString.repeat(parseInt(num))\\n    } else if (parseInt(c) || c === \\'0\\') {\\n      curNum = curNum*10 + parseInt(c)\\n    } else {\\n      curString += c\\n    }\\n  }\\n  return curString\\n}",
                "solutionTags": [],
                "code": "Modified from a python solution by user simkieu\\n\\n```\\nfunction decocdeString(s) {\\n  let stack = []\\n  let curNum = 0\\n  let curString = \\'\\'\\n  for (let c of s) {\\n    if (c === \\'[\\') {\\n      stack.push(curString)\\n      stack.push(curNum)\\n      curNum = 0\\n      curString = \\'\\'\\n    } else if (c === \\']\\') {\\n      let num = stack.pop()\\n      let prevString = stack.pop()\\n      curString = prevString + curString.repeat(parseInt(num))\\n    } else if (parseInt(c) || c === \\'0\\') {\\n      curNum = curNum*10 + parseInt(c)\\n    } else {\\n      curString += c\\n    }\\n  }\\n  return curString\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2723127,
                "title": "c-faster-than-100-solution-with-comments-recursion-o-n",
                "content": "# Code\\n```\\nclass Solution {\\n\\n   // starting Index of encoding string\\n   int start = 0;\\n\\n   string Solve(string &s )\\n   {\\n       // Variable To store our answer\\n       string ans = \"\";\\n\\n      //We will Traverse forward till wo dont get a numeric alphabet \\n      // or closing bracket or we reach till end\\n\\n       while( start < s.length() && s[start] >= \\'a\\' && s[start]<= \\'z\\' && s[start] != \\']\\' )\\n       ans.push_back(s[start++]);\\n       \\n     // if We reach end or we are at closing bracket we return \\n     // our ans as it is \\n     // eg1 : string = abcdef\\n     // we will have reache the end after starting from 0\\n     \\n     // eg2 : string = ab2[def]ghi\\n     // we will have reach at \\']\\' after starting from \\'d\\'\\n     \\n    \\n       if(start >= s.length() || s[start] == \\']\\')\\n       return ans;\\n    \\n     // We have reach the numerical character\\n       string num = \"\";\\n     \\n     // store the number to be repeated\\n       while(s[start] != \\'[\\' )\\n       num.push_back(s[start++]);\\n       int n = stoi(num) ;\\n     \\n     // Jump one index from \\'[\\' and get the repeating substring \\n       start++;\\n    \\n       string repeat = Solve(s );\\n    // Attach the repeating substring to our ans\\n      for(int k = 0 ; k< n ; k++)\\n           ans+= repeat;\\n\\n     // Jump one index from \\']\\' and get the substring ahead of\\n     //  repeating substring if any \\n\\n       start++;\\n     \\n     //Return ans\\n        return ans + Solve(s);\\n        \\n}\\n\\npublic:\\n    string decodeString(string s) {\\n        \\n        return Solve(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n   // starting Index of encoding string\\n   int start = 0;\\n\\n   string Solve(string &s )\\n   {\\n       // Variable To store our answer\\n       string ans = \"\";\\n\\n      //We will Traverse forward till wo dont get a numeric alphabet \\n      // or closing bracket or we reach till end\\n\\n       while( start < s.length() && s[start] >= \\'a\\' && s[start]<= \\'z\\' && s[start] != \\']\\' )\\n       ans.push_back(s[start++]);\\n       \\n     // if We reach end or we are at closing bracket we return \\n     // our ans as it is \\n     // eg1 : string = abcdef\\n     // we will have reache the end after starting from 0\\n     \\n     // eg2 : string = ab2[def]ghi\\n     // we will have reach at \\']\\' after starting from \\'d\\'\\n     \\n    \\n       if(start >= s.length() || s[start] == \\']\\')\\n       return ans;\\n    \\n     // We have reach the numerical character\\n       string num = \"\";\\n     \\n     // store the number to be repeated\\n       while(s[start] != \\'[\\' )\\n       num.push_back(s[start++]);\\n       int n = stoi(num) ;\\n     \\n     // Jump one index from \\'[\\' and get the repeating substring \\n       start++;\\n    \\n       string repeat = Solve(s );\\n    // Attach the repeating substring to our ans\\n      for(int k = 0 ; k< n ; k++)\\n           ans+= repeat;\\n\\n     // Jump one index from \\']\\' and get the substring ahead of\\n     //  repeating substring if any \\n\\n       start++;\\n     \\n     //Return ans\\n        return ans + Solve(s);\\n        \\n}\\n\\npublic:\\n    string decodeString(string s) {\\n        \\n        return Solve(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399359,
                "title": "python-soln-using-stack",
                "content": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        \\n        stack = []\\n        \\n        for i in range(len(s)):\\n            \\n            if s[i] != \\']\\':\\n                stack.append(s[i])\\n                \\n            else:\\n                subStr = \\'\\'\\n                while stack[-1] != \\'[\\':\\n                    subStr = stack.pop() + subStr\\n                stack.pop()\\n                \\n                digit = \\'\\'\\n                while stack and stack[-1].isdigit():\\n                    digit = stack.pop() + digit\\n                    \\n                stack.append(int(digit) * subStr)\\n                \\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        \\n        stack = []\\n        \\n        for i in range(len(s)):\\n            \\n            if s[i] != \\']\\':\\n                stack.append(s[i])\\n                \\n            else:\\n                subStr = \\'\\'\\n                while stack[-1] != \\'[\\':\\n                    subStr = stack.pop() + subStr\\n                stack.pop()\\n                \\n                digit = \\'\\'\\n                while stack and stack[-1].isdigit():\\n                    digit = stack.pop() + digit\\n                    \\n                stack.append(int(digit) * subStr)\\n                \\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220962,
                "title": "java-easy-to-understand-with-explanation",
                "content": "We will solve the problem by dividing it into subproblems. The algorithm is as follows:\\n\\n1. Iterate through the string\\n2. If we have a closing bracket, subproblem is done\\n3. If the current character is a letter, append it and continue\\n4. If the current character is an opening bracket, append it as count times\\n5. If none of the above, we have a digit that represents how many times we should append the subproblem. To accomplish it, don\\'t forget that we may have digits which has more than one digit. So, if we see sequential digits, the previous one should be multiplied by 10 to calculate the count number.\\n\\n```\\nclass Solution {\\n    int i = 0; //tricky part, we globally iterate forward with the help of defining this variable as global\\n    \\n    public String decodeString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = 0;\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            i++;\\n            \\n            if (c == \\']\\') { //subproblem is done\\n                break;\\n            }\\n            \\n            if (Character.isLetter(c)) { //append and continue\\n                sb.append(c);\\n                continue;\\n            }\\n            \\n            if (c == \\'[\\') {\\n                String tmp = decodeString(s); //recursive call to solve the subproblem\\n                for (int j = 0; j < count; j++) {\\n                    sb.append(tmp);\\n                }\\n                count = 0; // reset the counter\\n            } else {\\n                count = count * 10 + c - \\'0\\'; //handle count case which has more than one digit\\n            }\\n            \\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int i = 0; //tricky part, we globally iterate forward with the help of defining this variable as global\\n    \\n    public String decodeString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = 0;\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            i++;\\n            \\n            if (c == \\']\\') { //subproblem is done\\n                break;\\n            }\\n            \\n            if (Character.isLetter(c)) { //append and continue\\n                sb.append(c);\\n                continue;\\n            }\\n            \\n            if (c == \\'[\\') {\\n                String tmp = decodeString(s); //recursive call to solve the subproblem\\n                for (int j = 0; j < count; j++) {\\n                    sb.append(tmp);\\n                }\\n                count = 0; // reset the counter\\n            } else {\\n                count = count * 10 + c - \\'0\\'; //handle count case which has more than one digit\\n            }\\n            \\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87631,
                "title": "can-we-do-the-encode-way-i-post-one-the-return-is-the-shortest-length-of-encoded-string",
                "content": "Suppose we have a string with only lowercase letters and the problem asked us to encode it and return the shortest one. \\nHow can we do that? Does anyone have the idea?\\n\\n\\n\\nupdate: I write a solution for the problem. Does anyone have some suggestion?\\n\\n11/18 update: This solution return the shortest encode string, this means if the string is ```\"aaa\"```, it will return ```\"aaa\"```.\\n             if the string is ```\"aaaaa\"```, it will return ```\"5[a]\"```\\n\\n```\\n// this function is used to check if a string is combined by repeating a substring. \\n// Also Here can be replaced by doing KMP algorithm for whole string to improvement\\nbool checkRepeating(string& s, int l, int r, int start, int end){  \\n    if((end-start+1)%(r-l+1) != 0)\\n        return false;\\n    int len = r-l+1;\\n    bool res = true;\\n    for(int i=start; i<=end; i++){\\n        if(s[(i-start)%len+l] != s[i]){\\n            res = false;\\n            break;\\n        }\\n    }\\n    return res;\\n}\\n\\n// this function is used to get the length of the current number\\nint getLength(int l1, int l2){\\n    return (int)(log10(l2/l1+1)+1);\\n}\\n\\nstring shortestEncodeString(string s){\\n    int len = s.length();\\n\\n    vector< vector<int> > res(len, vector<int>(len, 0));\\n    //Initial the matrix \\n    for(int i=0; i<len; i++){\\n        for(int j=0; j<=i; j++){\\n            res[j][i] = i-j+1;\\n        }\\n    }\\n\\n    unordered_map<string, string> record;\\n\\n    for(int i=0; i<len; i++){\\n        for(int j=i; j>=0; j--){\\n\\n            string temp = s.substr(j, i-j+1);\\n/* if the current substring has showed before, then no need to compute again\\n * Here is a example for this part: if the string is \"abcabc\".\\n * if we see the second \"abc\", then no need to compute again, just use the\\n * result from first \"abc\".\\n**/\\n            if(record.find(temp) != record.end()){\\n                res[j][i] = record[temp].size();\\n                continue;\\n            }\\n            string ans = temp;\\n            for(int k=j; k<i; k++){\\n\\n                string str1 = s.substr(j, k-j+1);\\n                string str2 = s.substr(k+1, i-k);\\n                if(res[j][i] > res[j][k] + res[k+1][i]){\\n                    res[j][i] = res[j][k]+res[k+1][i];\\n                    ans = record[str1] + record[str2];\\n                }\\n\\n                if(checkRepeating(s, j, k, k+1, i) == true && res[j][i] > 2+getLength(k-j+1, i-k)+res[j][k]){\\n                    res[j][i] = 2+getLength(k-j+1, i-k)+res[j][k];\\n                    ans = to_string((i-j+1)/(k-j+1)) + '[' + record[str1] +']';\\n                }\\n            }\\n            record[temp] = ans;\\n        }\\n\\n    }\\n\\n    return record[s];\\n}\\n```",
                "solutionTags": [],
                "code": "```\"aaa\"```\n```\"aaa\"```\n```\"aaaaa\"```\n```\"5[a]\"```\n```\\n// this function is used to check if a string is combined by repeating a substring. \\n// Also Here can be replaced by doing KMP algorithm for whole string to improvement\\nbool checkRepeating(string& s, int l, int r, int start, int end){  \\n    if((end-start+1)%(r-l+1) != 0)\\n        return false;\\n    int len = r-l+1;\\n    bool res = true;\\n    for(int i=start; i<=end; i++){\\n        if(s[(i-start)%len+l] != s[i]){\\n            res = false;\\n            break;\\n        }\\n    }\\n    return res;\\n}\\n\\n// this function is used to get the length of the current number\\nint getLength(int l1, int l2){\\n    return (int)(log10(l2/l1+1)+1);\\n}\\n\\nstring shortestEncodeString(string s){\\n    int len = s.length();\\n\\n    vector< vector<int> > res(len, vector<int>(len, 0));\\n    //Initial the matrix \\n    for(int i=0; i<len; i++){\\n        for(int j=0; j<=i; j++){\\n            res[j][i] = i-j+1;\\n        }\\n    }\\n\\n    unordered_map<string, string> record;\\n\\n    for(int i=0; i<len; i++){\\n        for(int j=i; j>=0; j--){\\n\\n            string temp = s.substr(j, i-j+1);\\n/* if the current substring has showed before, then no need to compute again\\n * Here is a example for this part: if the string is \"abcabc\".\\n * if we see the second \"abc\", then no need to compute again, just use the\\n * result from first \"abc\".\\n**/\\n            if(record.find(temp) != record.end()){\\n                res[j][i] = record[temp].size();\\n                continue;\\n            }\\n            string ans = temp;\\n            for(int k=j; k<i; k++){\\n\\n                string str1 = s.substr(j, k-j+1);\\n                string str2 = s.substr(k+1, i-k);\\n                if(res[j][i] > res[j][k] + res[k+1][i]){\\n                    res[j][i] = res[j][k]+res[k+1][i];\\n                    ans = record[str1] + record[str2];\\n                }\\n\\n                if(checkRepeating(s, j, k, k+1, i) == true && res[j][i] > 2+getLength(k-j+1, i-k)+res[j][k]){\\n                    res[j][i] = 2+getLength(k-j+1, i-k)+res[j][k];\\n                    ans = to_string((i-j+1)/(k-j+1)) + '[' + record[str1] +']';\\n                }\\n            }\\n            record[temp] = ans;\\n        }\\n\\n    }\\n\\n    return record[s];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3838764,
                "title": "c-solution-using-stack-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse 1 stack to store the number of times the string has to be repeated and one to keep the letters of the string\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse ] to indicate the end of the repeated part when encountered take the top most integer from the integer stack and the part to be repeated from the other stack. the repeated part will be until we have encountred [ this in stack. repeat the string. then store the string in ans string if stack is empty but if stack is not empty then that string is in another [] so it has to be repeated again so store it back in stack.  \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n ## **please upvote**\\n\\n---\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        string ans = \"\";\\n        stack<char> st;\\n        stack<int> m;\\n        for(int i = 0; i < s.size() ; i++){\\n            if(s[i] >= \\'0\\' && s[i] <= \\'9\\'){\\n                string t = \"\";\\n                t.push_back(s[i]);\\n                for(int j = i+1 ; j < s.size();j++){\\n                    if(s[j] >= \\'0\\' && s[j] <= \\'9\\'){\\n                        t.push_back(s[j]);\\n                    }\\n                    else{\\n                        i = j - 1;\\n                        break;\\n                    }\\n                }\\n                int num = stoi(t);\\n                m.push(num);\\n            }\\n            else if(s[i] == \\']\\'){\\n                int rep = m.top();\\n                m.pop();\\n                string temp = \"\";\\n                while(!st.empty() && st.top() != \\'[\\'){\\n                    temp += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                reverse(temp.begin(),temp.end());\\n                string str = temp;\\n                for(int j = 1; j < rep; j++){\\n                    str += temp;\\n                }\\n\\n                if(!st.empty()){\\n                    for(int k = 0; k < str.size(); k++){\\n                        st.push(str[k]);\\n                    }\\n                }\\n                else{\\n                    ans += str;\\n                }\\n            }\\n            else{\\n                st.push(s[i]);\\n            }\\n        }\\n        string te = \"\";\\n        while(!st.empty()){\\n            te += st.top();\\n            st.pop();\\n        }\\n        reverse(te.begin(),te.end());\\n        ans += te;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        string ans = \"\";\\n        stack<char> st;\\n        stack<int> m;\\n        for(int i = 0; i < s.size() ; i++){\\n            if(s[i] >= \\'0\\' && s[i] <= \\'9\\'){\\n                string t = \"\";\\n                t.push_back(s[i]);\\n                for(int j = i+1 ; j < s.size();j++){\\n                    if(s[j] >= \\'0\\' && s[j] <= \\'9\\'){\\n                        t.push_back(s[j]);\\n                    }\\n                    else{\\n                        i = j - 1;\\n                        break;\\n                    }\\n                }\\n                int num = stoi(t);\\n                m.push(num);\\n            }\\n            else if(s[i] == \\']\\'){\\n                int rep = m.top();\\n                m.pop();\\n                string temp = \"\";\\n                while(!st.empty() && st.top() != \\'[\\'){\\n                    temp += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                reverse(temp.begin(),temp.end());\\n                string str = temp;\\n                for(int j = 1; j < rep; j++){\\n                    str += temp;\\n                }\\n\\n                if(!st.empty()){\\n                    for(int k = 0; k < str.size(); k++){\\n                        st.push(str[k]);\\n                    }\\n                }\\n                else{\\n                    ans += str;\\n                }\\n            }\\n            else{\\n                st.push(s[i]);\\n            }\\n        }\\n        string te = \"\";\\n        while(!st.empty()){\\n            te += st.top();\\n            st.pop();\\n        }\\n        reverse(te.begin(),te.end());\\n        ans += te;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051710,
                "title": "stack-ts-solution",
                "content": "\\n# Code\\n```\\nfunction decodeString(s: string): string {\\n    const stack: [number, string][] = []\\n    let currentString = \\'\\'\\n    let currentMultiplier = 0\\n\\n    for (let ch of s) {\\n        if (ch === \\'[\\') {\\n            stack.push([currentMultiplier, currentString])\\n            currentMultiplier = 0\\n            currentString = \\'\\'\\n        } else if (ch === \\']\\') {\\n            const [prevMultiplier, prevString] = stack.pop()\\n            currentString = prevString + currentString.repeat(prevMultiplier)\\n        } else if (!isNaN(Number(ch))) {\\n            // it\\'s digit\\n            currentMultiplier = currentMultiplier*10 + +ch\\n        } else {\\n            // it\\'s a char\\n            currentString += ch\\n        }\\n    }\\n\\n    return currentString\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction decodeString(s: string): string {\\n    const stack: [number, string][] = []\\n    let currentString = \\'\\'\\n    let currentMultiplier = 0\\n\\n    for (let ch of s) {\\n        if (ch === \\'[\\') {\\n            stack.push([currentMultiplier, currentString])\\n            currentMultiplier = 0\\n            currentString = \\'\\'\\n        } else if (ch === \\']\\') {\\n            const [prevMultiplier, prevString] = stack.pop()\\n            currentString = prevString + currentString.repeat(prevMultiplier)\\n        } else if (!isNaN(Number(ch))) {\\n            // it\\'s digit\\n            currentMultiplier = currentMultiplier*10 + +ch\\n        } else {\\n            // it\\'s a char\\n            currentString += ch\\n        }\\n    }\\n\\n    return currentString\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2251889,
                "title": "c-recursion-clean-code-100-faster",
                "content": "class Solution {\\npublic:\\n\\n    string helper(string &s, int &i){\\n        string res;\\n        \\n        while(i < s.length() and s[i] != \\']\\'){\\n            if(!isdigit(s[i])){\\n                res += s[i++]; // if its a character just add to res.\\n            } else {\\n                int n = 0;\\n                \\n                while(i < s.length() and isdigit(s[i])){\\n                    n = n * 10 + s[i++] - \\'0\\'; \\n                }\\n                \\n                i++; // skip \\'[\\'\\n                string ans = helper(s, i);\\n                i++; // skip \\']\\'\\n                \\n                while(n-- > 0){\\n                    res += ans;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    string decodeString(string s) {\\n        int i = 0;\\n        string ans = helper(s, i);\\n        return ans;\\n    }\\n};\\n\\n**Time: O(N), Space: O(N) for storing result.**\\n\\nNote: For better understanding and learning, consider dry running the code yourself.\\nFor doubt or query comment below.\\n**PLEASE UPVOTE IF HELPFUL!!!**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string helper(string &s, int &i){\\n        string res;\\n        \\n        while(i < s.length() and s[i] != \\']\\'){\\n            if(!isdigit(s[i])){\\n                res += s[i++]; // if its a character just add to res.\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1651984,
                "title": "faster-than-99-07-python-with-stack",
                "content": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        #Time: O(n)\\n        #Space: O(n)\\n        stack = []\\n        \\n        for char in s:\\n            if char == \\']\\': #Only with \\']\\', do we start decoding strings\\n                encodedString, multiplier = \\'\\', \\'\\'\\n                \\n                #Inserting in them front of another maintains the original order\\n                while len(stack) and stack[-1].isalpha():\\n                    encodedString = stack.pop() + encodedString\\n                stack.pop() #Dispose of \\'[\\'\\n                \\n                while len(stack) and stack[-1].isdigit():\\n                    multiplier = stack.pop() + multiplier\\n                \\n                stack.append(encodedString * int(multiplier))\\n            else:\\n                stack.append(char)\\n                \\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        #Time: O(n)\\n        #Space: O(n)\\n        stack = []\\n        \\n        for char in s:\\n            if char == \\']\\': #Only with \\']\\', do we start decoding strings\\n                encodedString, multiplier = \\'\\', \\'\\'\\n                \\n                #Inserting in them front of another maintains the original order\\n                while len(stack) and stack[-1].isalpha():\\n                    encodedString = stack.pop() + encodedString\\n                stack.pop() #Dispose of \\'[\\'\\n                \\n                while len(stack) and stack[-1].isdigit():\\n                    multiplier = stack.pop() + multiplier\\n                \\n                stack.append(encodedString * int(multiplier))\\n            else:\\n                stack.append(char)\\n                \\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167364,
                "title": "concise-and-simple-recursive-solution",
                "content": "My intuition is the same as the rest but I think my implementation is simpler. \\n\\n1. If digit, calculate the multiplier\\n2. If opening bracket, recurse (more on this in a bit)\\n3. If closing bracket, base case so return. \\n4. Otherwise, just collect the char local result\\n\\nIn the recursion, I pass in the current value of index and return the final value from recursion. Makes it really simple I believe. Once returned, multiply, append, and update the index to the last location from the recursion. Don\\'t forget to reset the multiplier number otherwise it would keep on growing. \\n\\nHope you like it. \\n\\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:                         \\n        \\n        def recurse(s, pos):       \\n            result = \"\"\\n            i, num = pos, 0\\n            \\n            while i < len(s):\\n                c = s[i]\\n                if c.isdigit():\\n                    num = num * 10 + int(c)\\n                elif c == \\'[\\':\\n                    string, end = recurse(s, i + 1)\\n                    result += num * string\\n                    i = end\\n                    num = 0\\n                elif c == \\']\\':\\n                    return result, i\\n                else:\\n                    result += c\\n                i += 1\\n            \\n            return result, i\\n                \\n        return recurse(s, 0)[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:                         \\n        \\n        def recurse(s, pos):       \\n            result = \"\"\\n            i, num = pos, 0\\n            \\n            while i < len(s):\\n                c = s[i]\\n                if c.isdigit():\\n                    num = num * 10 + int(c)\\n                elif c == \\'[\\':\\n                    string, end = recurse(s, i + 1)\\n                    result += num * string\\n                    i = end\\n                    num = 0\\n                elif c == \\']\\':\\n                    return result, i\\n                else:\\n                    result += c\\n                i += 1\\n            \\n            return result, i\\n                \\n        return recurse(s, 0)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941553,
                "title": "rust-stack-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn decode_string(s: String) -> String {\\n        let mut stack: Vec<(usize, String)> = Vec::new();\\n        let (mut n, mut str) = (0, String::new());\\n        for c in s.chars() {\\n            match c {\\n                \\'[\\' => {\\n                    stack.push((n, str.clone()));\\n                    n = 0;\\n                    str.clear();\\n                }\\n                \\']\\' => {\\n                    if let Some(last) = stack.pop() {\\n                        str = last.1 + str.repeat(last.0).as_str();\\n                    }\\n                }\\n                \\'0\\'..=\\'9\\' => n = n * 10 + (c as u8 - b\\'0\\') as usize,\\n                c => str.push(c),\\n            }\\n        }\\n        str\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Stack"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn decode_string(s: String) -> String {\\n        let mut stack: Vec<(usize, String)> = Vec::new();\\n        let (mut n, mut str) = (0, String::new());\\n        for c in s.chars() {\\n            match c {\\n                \\'[\\' => {\\n                    stack.push((n, str.clone()));\\n                    n = 0;\\n                    str.clear();\\n                }\\n                \\']\\' => {\\n                    if let Some(last) = stack.pop() {\\n                        str = last.1 + str.repeat(last.0).as_str();\\n                    }\\n                }\\n                \\'0\\'..=\\'9\\' => n = n * 10 + (c as u8 - b\\'0\\') as usize,\\n                c => str.push(c),\\n            }\\n        }\\n        str\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 714732,
                "title": "python-solution-using-stacks-o-n",
                "content": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        # instantiate stacks to store the number and the string to repeat.\\n        repeatStr = []\\n        numRepeat = []\\n        \\n        # initialize empty strings. One to store a multidigit number and other one to store the decoded string. \\n        tempNum = \\'\\'\\n        decodedStr = \\'\\'        \\n        \\n        # start iterating throught the encoded string\\n        for char in s:\\n            # check if the char is a digit. \\n            if char.isdigit():\\n                tempNum += char # add the number to tempNum\\n                \\n            # check if the char is an opening bracket\\n            elif char == \\'[\\':\\n                repeatStr.append(decodedStr)\\n                numRepeat.append(tempNum)\\n                tempNum = \\'\\'\\n                decodedStr = \\'\\'\\n                \\n            # check when the bracket closes\\n            elif char == \\']\\':\\n                decodedStr = repeatStr.pop() + (decodedStr * int(numRepeat.pop()))\\n                \\n            # else build the substring to repeat\\n            else:\\n                decodedStr += char            \\n                \\n        return decodedStr\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        # instantiate stacks to store the number and the string to repeat.\\n        repeatStr = []\\n        numRepeat = []\\n        \\n        # initialize empty strings. One to store a multidigit number and other one to store the decoded string. \\n        tempNum = \\'\\'\\n        decodedStr = \\'\\'        \\n        \\n        # start iterating throught the encoded string\\n        for char in s:\\n            # check if the char is a digit. \\n            if char.isdigit():\\n                tempNum += char # add the number to tempNum\\n                \\n            # check if the char is an opening bracket\\n            elif char == \\'[\\':\\n                repeatStr.append(decodedStr)\\n                numRepeat.append(tempNum)\\n                tempNum = \\'\\'\\n                decodedStr = \\'\\'\\n                \\n            # check when the bracket closes\\n            elif char == \\']\\':\\n                decodedStr = repeatStr.pop() + (decodedStr * int(numRepeat.pop()))\\n                \\n            # else build the substring to repeat\\n            else:\\n                decodedStr += char            \\n                \\n        return decodedStr\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 629715,
                "title": "java-solution-with-two-stacks-beats-100",
                "content": "Use two stacks - one for the numbers and another for the prefixes.\\nReuse the same StringBuilder instance.\\n\\n```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<String> prefixes = new Stack<>();\\n        Stack<Integer> numbers = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c)) {\\n                int number = 0;\\n                while (Character.isDigit(s.charAt(i))) {\\n                    number = number*10 + (s.charAt(i) - \\'0\\');\\n                    i++;\\n                }\\n                numbers.push(number);\\n                prefixes.push(sb.toString());\\n                sb.setLength(0);\\n                // the loop increment i++ skips the next opening bracket\\n            } else if (c == \\']\\') {\\n                String inner = sb.toString();\\n                sb.setLength(0);\\n                sb.append(prefixes.pop());\\n                int number = numbers.pop();\\n                for (int j = 0; j < number; j++) {\\n                    sb.append(inner);\\n                }\\n            } else {// a regular character\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<String> prefixes = new Stack<>();\\n        Stack<Integer> numbers = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c)) {\\n                int number = 0;\\n                while (Character.isDigit(s.charAt(i))) {\\n                    number = number*10 + (s.charAt(i) - \\'0\\');\\n                    i++;\\n                }\\n                numbers.push(number);\\n                prefixes.push(sb.toString());\\n                sb.setLength(0);\\n                // the loop increment i++ skips the next opening bracket\\n            } else if (c == \\']\\') {\\n                String inner = sb.toString();\\n                sb.setLength(0);\\n                sb.append(prefixes.pop());\\n                int number = numbers.pop();\\n                for (int j = 0; j < number; j++) {\\n                    sb.append(inner);\\n                }\\n            } else {// a regular character\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617892,
                "title": "easy-understand-o-n-explanation-stack",
                "content": "\\tclass Solution:\\n\\t\\tdef decodeString(self, s: str) -> str:\\n\\t\\t\\t# if string is None\\n\\t\\t\\tif not s:\\n\\t\\t\\t\\treturn s\\n\\n\\t\\t\\t# stack for stirng\\n\\t\\t\\tstring_stack = []\\n\\t\\t\\t# stack for integer\\n\\t\\t\\tnum_stack = []\\n\\n\\t\\t\\t# result \\n\\t\\t\\tres = \\'\\'\\n\\t\\t\\t# handle the num\\n\\t\\t\\tnum = 0\\n\\n\\t\\t\\t# four situations: \\n\\t\\t\\t# 1. integer\\n\\t\\t\\t# 2. letter\\n\\t\\t\\t# 3. left square bracket \\n\\t\\t\\t# 4. right square bracket \\n\\n\\t\\t\\t# push & pop data\\n\\t\\t\\tfor index in range(len(s)):\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Situation 1: digit\\n\\t\\t\\t\\tif s[index].isdigit():\\n\\t\\t\\t\\t\\t# put all of the digit together and get the num\\n\\t\\t\\t\\t\\tnum = num*10 + int(s[index])\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t# Situation 3: left square bracket\\n\\t\\t\\t\\telif  s[index] == \\'[\\':\\n\\t\\t\\t\\t\\t# means there is no more num, so push to num stack\\n\\t\\t\\t\\t\\tnum_stack.append(num)\\n\\t\\t\\t\\t\\t# and reset the num \\n\\t\\t\\t\\t\\tnum = 0\\n\\n\\t\\t\\t\\t\\t# put exisit (temp)res to string_stack and rest it\\n\\t\\t\\t\\t\\tstring_stack.append(res)\\n\\t\\t\\t\\t\\tres = \\'\\'\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t# Situation 4: right square bracket\\n\\t\\t\\t\\t# pop num & string: add string on res\\n\\t\\t\\t\\telif s[index] == \\']\\':\\n\\t\\t\\t\\t\\tres = string_stack.pop() + res * num_stack.pop()\\n\\t\\t\\n\\t\\t\\t\\t# Situation 2: letter\\n\\t\\t\\t\\t# do the easiest part: situation 2 first\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres += s[index]\\n\\n\\n\\t\\t\\treturn res\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef decodeString(self, s: str) -> str:\\n\\t\\t\\t# if string is None\\n\\t\\t\\tif not s:\\n\\t\\t\\t\\treturn s\\n\\n\\t\\t\\t# stack for stirng\\n\\t\\t\\tstring_stack = []\\n\\t\\t\\t# stack for integer\\n\\t\\t\\tnum_stack = []\\n\\n\\t\\t\\t# result \\n\\t\\t\\tres = \\'\\'\\n\\t\\t\\t# handle the num\\n\\t\\t\\tnum = 0\\n\\n\\t\\t\\t# four situations: \\n\\t\\t\\t# 1. integer\\n\\t\\t\\t# 2. letter\\n\\t\\t\\t# 3. left square bracket \\n\\t\\t\\t# 4. right square bracket \\n\\n\\t\\t\\t# push & pop data\\n\\t\\t\\tfor index in range(len(s)):\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Situation 1: digit\\n\\t\\t\\t\\tif s[index].isdigit():\\n\\t\\t\\t\\t\\t# put all of the digit together and get the num\\n\\t\\t\\t\\t\\tnum = num*10 + int(s[index])\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t# Situation 3: left square bracket\\n\\t\\t\\t\\telif  s[index] == \\'[\\':\\n\\t\\t\\t\\t\\t# means there is no more num, so push to num stack\\n\\t\\t\\t\\t\\tnum_stack.append(num)\\n\\t\\t\\t\\t\\t# and reset the num \\n\\t\\t\\t\\t\\tnum = 0\\n\\n\\t\\t\\t\\t\\t# put exisit (temp)res to string_stack and rest it\\n\\t\\t\\t\\t\\tstring_stack.append(res)\\n\\t\\t\\t\\t\\tres = \\'\\'\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t# Situation 4: right square bracket\\n\\t\\t\\t\\t# pop num & string: add string on res\\n\\t\\t\\t\\telif s[index] == \\']\\':\\n\\t\\t\\t\\t\\tres = string_stack.pop() + res * num_stack.pop()\\n\\t\\t\\n\\t\\t\\t\\t# Situation 2: letter\\n\\t\\t\\t\\t# do the easiest part: situation 2 first\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres += s[index]\\n\\n\\n\\t\\t\\treturn res\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 533390,
                "title": "java-clean-code-with-recursion",
                "content": "**Tips**\\nTo avoid global variable use the array with length 1\\n\\n```java\\npublic String decodeString(String s) {\\n\\tint[] index = new int[1];\\n\\tindex[0] = 0;\\n\\treturn decodeStringHelper(s, index);\\n}\\nprivate String decodeStringHelper(String s, int[] index) {\\n\\tStringBuilder sb = new StringBuilder();\\n\\tString num = \"\";\\n\\tfor (int i = index[0]; i < s.length(); i++) {\\n\\t\\tchar c = s.charAt(i);\\n\\t\\tif (c != \\'[\\' && c != \\']\\' && !Character.isDigit(c))\\n\\t\\t\\tsb.append(c);\\n\\t\\telse if (Character.isDigit(c))\\n\\t\\t\\tnum += c;\\n\\t\\telse if (c == \\'[\\') {\\n\\t\\t\\tindex[0] = i + 1;\\n\\t\\t\\tString next = decodeStringHelper(s, index);\\n\\t\\t\\tfor (int n = Integer.valueOf(num); n > 0; n--)\\n\\t\\t\\t\\tsb.append(next);\\n\\t\\t\\tnum = \"\";\\n\\t\\t\\ti = index[0];\\n\\t\\t} else if (c == \\']\\') {\\n\\t\\t\\tindex[0] = i;\\n\\t\\t\\treturn sb.toString();\\n\\t\\t}\\n\\t}\\n\\treturn sb.toString();\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "**Tips**\\nTo avoid global variable use the array with length 1\\n\\n```java\\npublic String decodeString(String s) {\\n\\tint[] index = new int[1];\\n\\tindex[0] = 0;\\n\\treturn decodeStringHelper(s, index);\\n}\\nprivate String decodeStringHelper(String s, int[] index) {\\n\\tStringBuilder sb = new StringBuilder();\\n\\tString num = \"\";\\n\\tfor (int i = index[0]; i < s.length(); i++) {\\n\\t\\tchar c = s.charAt(i);\\n\\t\\tif (c != \\'[\\' && c != \\']\\' && !Character.isDigit(c))\\n\\t\\t\\tsb.append(c);\\n\\t\\telse if (Character.isDigit(c))\\n\\t\\t\\tnum += c;\\n\\t\\telse if (c == \\'[\\') {\\n\\t\\t\\tindex[0] = i + 1;\\n\\t\\t\\tString next = decodeStringHelper(s, index);\\n\\t\\t\\tfor (int n = Integer.valueOf(num); n > 0; n--)\\n\\t\\t\\t\\tsb.append(next);\\n\\t\\t\\tnum = \"\";\\n\\t\\t\\ti = index[0];\\n\\t\\t} else if (c == \\']\\') {\\n\\t\\t\\tindex[0] = i;\\n\\t\\t\\treturn sb.toString();\\n\\t\\t}\\n\\t}\\n\\treturn sb.toString();\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 346959,
                "title": "golang-solution-using-recursion-with-my-analysis",
                "content": "After my [previous post](https://leetcode.com/problems/decode-string/discuss/346216/Golang-solution-using-2-stacks-with-my-thoughts-and-notes), I thought what if we can\\'t came up with a solution using stacks, then could we use recursion to solve the problem? The answer is yes.\\n\\nWe need to see the pattern of the encoded string.\\n`s = \"3[a2[c]]\", return \"accaccacc\". `\\nWhen we meet a `[ `, we will go deep into next level, which is where a recursion starts. When should we return from the recursion? That\\u2019s the time when we meet `]` .\\n\\n```\\nfunc decodeString(s string) string {\\n\\tr, _ := helper(s, 0)\\n\\treturn r\\n}\\n\\nfunc helper(s string, start int) (cur string, end int) {\\n\\tif len(s) == 0 {\\n\\t\\treturn \"\", 0\\n\\t}\\n\\tk := 0\\n\\ti := start\\n\\tfor i < len(s) {\\n\\t\\tch := string(s[i])\\n\\t\\tif n, err := strconv.Atoi(ch); err == nil {\\n\\t\\t\\tk = k*10 + n\\n\\t\\t} else if ch == \"[\" {\\n\\t\\t\\tdecoded, end := helper(s, i+1)\\n\\t\\t\\tcur += strings.Repeat(decoded, k)\\n\\t\\t\\ti = end\\n\\t\\t\\tk = 0\\n\\t\\t} else if ch == \"]\" {\\n\\t\\t\\t// this is the base case\\n\\t\\t\\treturn cur, i\\n\\t\\t} else {\\n\\t\\t\\tcur += ch\\n\\t\\t}\\n\\t\\ti++\\n\\t}\\n\\treturn cur, i\\n}\\n```\\n\\nAt this point, I would prefer recursion.",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nfunc decodeString(s string) string {\\n\\tr, _ := helper(s, 0)\\n\\treturn r\\n}\\n\\nfunc helper(s string, start int) (cur string, end int) {\\n\\tif len(s) == 0 {\\n\\t\\treturn \"\", 0\\n\\t}\\n\\tk := 0\\n\\ti := start\\n\\tfor i < len(s) {\\n\\t\\tch := string(s[i])\\n\\t\\tif n, err := strconv.Atoi(ch); err == nil {\\n\\t\\t\\tk = k*10 + n\\n\\t\\t} else if ch == \"[\" {\\n\\t\\t\\tdecoded, end := helper(s, i+1)\\n\\t\\t\\tcur += strings.Repeat(decoded, k)\\n\\t\\t\\ti = end\\n\\t\\t\\tk = 0\\n\\t\\t} else if ch == \"]\" {\\n\\t\\t\\t// this is the base case\\n\\t\\t\\treturn cur, i\\n\\t\\t} else {\\n\\t\\t\\tcur += ch\\n\\t\\t}\\n\\t\\ti++\\n\\t}\\n\\treturn cur, i\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 300067,
                "title": "14-lines-python-stack",
                "content": "```python\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = [[\\'\\', 1, \\'\\']]\\n        a = n = \\'\\'\\n        for c in s:\\n            if c.isalpha():\\n                a += c\\n            elif c.isdigit():\\n                n += c\\n            elif c == \\'[\\':\\n                stack.append([a, int(n), \\'\\'])\\n                a = n = \\'\\'\\n            else:\\n                p, t, b = stack.pop()\\n                stack[-1][-1] += p + t * (b + a)\\n                a = \\'\\'\\n        return stack.pop()[-1] + a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = [[\\'\\', 1, \\'\\']]\\n        a = n = \\'\\'\\n        for c in s:\\n            if c.isalpha():\\n                a += c\\n            elif c.isdigit():\\n                n += c\\n            elif c == \\'[\\':\\n                stack.append([a, int(n), \\'\\'])\\n                a = n = \\'\\'\\n            else:\\n                p, t, b = stack.pop()\\n                stack[-1][-1] += p + t * (b + a)\\n                a = \\'\\'\\n        return stack.pop()[-1] + a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87705,
                "title": "java-one-pass-recursive-solution",
                "content": "```\\n/*\\n * Recursive. helper(s) consumes one layer of \"[ ]\".\\n */\\n    int idx;\\n    public String decodeString(String s) {\\n        idx = 0;\\n        return helper(s);\\n    }\\n    String helper(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        for (int k = 0; idx < s.length(); ++idx) {\\n            char ch = s.charAt(idx);\\n            if (ch == '[') {\\n                ++idx;\\n                String str = helper(s);\\n                while (k > 0) {\\n                    ans.append(str);\\n                    --k;\\n                }\\n            } else if (ch == ']') {\\n                break;\\n            } else if (Character.isDigit(ch)) {\\n                k = k * 10 + ch - '0';\\n            } else ans.append(ch);\\n        }\\n        return ans.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n * Recursive. helper(s) consumes one layer of \"[ ]\".\\n */\\n    int idx;\\n    public String decodeString(String s) {\\n        idx = 0;\\n        return helper(s);\\n    }\\n    String helper(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        for (int k = 0; idx < s.length(); ++idx) {\\n            char ch = s.charAt(idx);\\n            if (ch == '[') {\\n                ++idx;\\n                String str = helper(s);\\n                while (k > 0) {\\n                    ans.append(str);\\n                    --k;\\n                }\\n            } else if (ch == ']') {\\n                break;\\n            } else if (Character.isDigit(ch)) {\\n                k = k * 10 + ch - '0';\\n            } else ans.append(ch);\\n        }\\n        return ans.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3359679,
                "title": "java-stack-decode-string",
                "content": "\\n```\\nclass Solution {\\n    public int alphaDigtSearch(int finish, String sourse, ArrayList<String> stack, boolean isAlpha)\\n    {\\n        int start = finish;\\n\\n        if (isAlpha)\\n            while (finish < sourse.length() && Character.isAlphabetic(sourse.charAt(finish))) finish++;\\n        else\\n            while (finish < sourse.length() && Character.isDigit(sourse.charAt(finish))) finish++;\\n\\n        if (start != finish)\\n            stack.add(sourse.substring(start, finish));\\n        if (finish < sourse.length() && sourse.charAt(finish) == \\'[\\')\\n            finish++;\\n        return finish;\\n    }\\n\\n    public void stackWork(ArrayList<String> stack)\\n    {\\n        String str = null;\\n        int repeat;\\n        StringBuilder answ = new StringBuilder();\\n\\n        if (stack.size() > 0)\\n        {\\n            answ = new StringBuilder(stack.get(stack.size() - 1));\\n            stack.remove(stack.size() - 1);\\n        }\\n        while (stack.size() > 0 && !Character.isDigit(stack.get(stack.size() - 1).charAt(0))) {\\n            answ.insert(0, stack.get(stack.size() - 1));\\n            stack.remove(stack.size() - 1);\\n        }\\n        if (stack.size() > 0 && Character.isDigit(stack.get(stack.size() - 1).charAt(0)))\\n        {\\n            repeat = Integer.parseInt(stack.get(stack.size() - 1));\\n            stack.remove(stack.size() - 1);\\n            answ = repeat(answ, repeat);\\n        }\\n\\n        while (stack.size() > 0 && Character.isAlphabetic(stack.get(stack.size() - 1).charAt(0))) {\\n            answ.insert(0, stack.get(stack.size() - 1));\\n            stack.remove(stack.size() - 1);\\n        }\\n        stack.add(answ.toString());\\n    }\\n\\n    private StringBuilder repeat(StringBuilder answ, int i) {\\n        StringBuilder tmp = new StringBuilder();\\n        for (int j = 0; j < i; j++)\\n            tmp.append(answ);\\n        return tmp;\\n    }\\n\\n    public String decodeString(String s)\\n    {\\n        ArrayList<String> stack = new ArrayList<>();\\n        int finish = 0;\\n        finish = alphaDigtSearch(finish, s, stack, true);\\n        while (finish < s.length())\\n        {\\n            finish = alphaDigtSearch(finish, s, stack, false);\\n            finish = alphaDigtSearch(finish, s, stack, true);\\n            if (finish < s.length() && s.charAt(finish) == \\']\\') {\\n                stackWork(stack);\\n                finish++;\\n            }\\n        }\\n        if (stack.size() > 1)\\n            stackWork(stack);\\n        return stack.get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alphaDigtSearch(int finish, String sourse, ArrayList<String> stack, boolean isAlpha)\\n    {\\n        int start = finish;\\n\\n        if (isAlpha)\\n            while (finish < sourse.length() && Character.isAlphabetic(sourse.charAt(finish))) finish++;\\n        else\\n            while (finish < sourse.length() && Character.isDigit(sourse.charAt(finish))) finish++;\\n\\n        if (start != finish)\\n            stack.add(sourse.substring(start, finish));\\n        if (finish < sourse.length() && sourse.charAt(finish) == \\'[\\')\\n            finish++;\\n        return finish;\\n    }\\n\\n    public void stackWork(ArrayList<String> stack)\\n    {\\n        String str = null;\\n        int repeat;\\n        StringBuilder answ = new StringBuilder();\\n\\n        if (stack.size() > 0)\\n        {\\n            answ = new StringBuilder(stack.get(stack.size() - 1));\\n            stack.remove(stack.size() - 1);\\n        }\\n        while (stack.size() > 0 && !Character.isDigit(stack.get(stack.size() - 1).charAt(0))) {\\n            answ.insert(0, stack.get(stack.size() - 1));\\n            stack.remove(stack.size() - 1);\\n        }\\n        if (stack.size() > 0 && Character.isDigit(stack.get(stack.size() - 1).charAt(0)))\\n        {\\n            repeat = Integer.parseInt(stack.get(stack.size() - 1));\\n            stack.remove(stack.size() - 1);\\n            answ = repeat(answ, repeat);\\n        }\\n\\n        while (stack.size() > 0 && Character.isAlphabetic(stack.get(stack.size() - 1).charAt(0))) {\\n            answ.insert(0, stack.get(stack.size() - 1));\\n            stack.remove(stack.size() - 1);\\n        }\\n        stack.add(answ.toString());\\n    }\\n\\n    private StringBuilder repeat(StringBuilder answ, int i) {\\n        StringBuilder tmp = new StringBuilder();\\n        for (int j = 0; j < i; j++)\\n            tmp.append(answ);\\n        return tmp;\\n    }\\n\\n    public String decodeString(String s)\\n    {\\n        ArrayList<String> stack = new ArrayList<>();\\n        int finish = 0;\\n        finish = alphaDigtSearch(finish, s, stack, true);\\n        while (finish < s.length())\\n        {\\n            finish = alphaDigtSearch(finish, s, stack, false);\\n            finish = alphaDigtSearch(finish, s, stack, true);\\n            if (finish < s.length() && s.charAt(finish) == \\']\\') {\\n                stackWork(stack);\\n                finish++;\\n            }\\n        }\\n        if (stack.size() > 1)\\n            stackWork(stack);\\n        return stack.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123975,
                "title": "java-solution-using-stack-beginner-friendly-heavily-commented",
                "content": "Kindly upvote if you find this solution useful :)\\n```\\npublic String decodeString(String s) {\\n        Stack<String> wordstk = new Stack<String>();   //to store characters present in the string\\n        Stack<Integer> intstk = new Stack<Integer>();  //to store integer values present in the string\\n        StringBuilder temp = new StringBuilder();  //storing the string\\n        int number = 0;   //stores the number of times temp has to be duplicated\\n        for(int i = 0; i < s.length();i++)\\n        {\\n            char c = s.charAt(i);\\n            if(Character.isDigit(c))    number = number * 10 + (c - \\'0\\');   //goes over digitwise and gives the number\\n            else if(Character.isLetter(c)) temp.append(c);\\n            else if(c == \\'[\\')   // denotes the start of another encoded string, so add temp and number to their respective stacks\\n            {\\n                intstk.add(number);\\n                wordstk.add(temp.toString());\\n                number = 0;\\n                temp = new StringBuilder();\\n            }\\n            else\\n            {\\n                int count = intstk.pop();\\n                StringBuilder dupe = new StringBuilder(wordstk.pop());\\n                for(int j = 1; j <= count;j++)    dupe.append(temp);\\n                temp = dupe;\\n            }\\n\\t\\t}\\n        return temp.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic String decodeString(String s) {\\n        Stack<String> wordstk = new Stack<String>();   //to store characters present in the string\\n        Stack<Integer> intstk = new Stack<Integer>();  //to store integer values present in the string\\n        StringBuilder temp = new StringBuilder();  //storing the string\\n        int number = 0;   //stores the number of times temp has to be duplicated\\n        for(int i = 0; i < s.length();i++)\\n        {\\n            char c = s.charAt(i);\\n            if(Character.isDigit(c))    number = number * 10 + (c - \\'0\\');   //goes over digitwise and gives the number\\n            else if(Character.isLetter(c)) temp.append(c);\\n            else if(c == \\'[\\')   // denotes the start of another encoded string, so add temp and number to their respective stacks\\n            {\\n                intstk.add(number);\\n                wordstk.add(temp.toString());\\n                number = 0;\\n                temp = new StringBuilder();\\n            }\\n            else\\n            {\\n                int count = intstk.pop();\\n                StringBuilder dupe = new StringBuilder(wordstk.pop());\\n                for(int j = 1; j <= count;j++)    dupe.append(temp);\\n                temp = dupe;\\n            }\\n\\t\\t}\\n        return temp.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2628412,
                "title": "c-solution-with-explanation-using-recursion",
                "content": "This is the standard solution given under the tab \\'Solution\\' of the same problem: https://leetcode.com/problems/decode-string/solution/\\nWe start with the original string s and index = 0. If the index is not \\']\\', meaning its a digit or alphabet (but not \\'[\\' -> this is ensured in the later part of the code). Also note that the string won\\'t start with \\'[\\' so there is no chance of having it initially. \\nFirst lets take the case when the string isdigit. In that case, count the number of times the inner string need to be repeated. For example 26[X], string X will be repeated 26 times and 26 is stored in k. Now increment the index -> this is done as we know that number will be accompanied by [. \\nNow recurse on the inner string s and also increment index, this time for ]. While recursing for inner string, if the character is not digit, we store that and return it as a string. Now remember this inner string needs to be repeated \\'k\\' times so we add that to current return string \\'ret\\'. Return the ret string.\\n\\n```\\nclass Solution {\\npublic:\\n    string recurse(string &s, int &index)\\n    {\\n        string ret;\\n        while(index<s.length() && s[index]!=\\']\\')\\n        {\\n            if(!isdigit(s[index]))\\n                ret+=s[index++];\\n            else\\n            {\\n                int k=0;\\n                while(index<s.length()&&isdigit(s[index]))\\n                    k = k*10 + s[index++]-\\'0\\';\\n                index++; //because digit always accompained by \\'[\\'\\n                string dec = recurse(s, index);\\n                index++; //and accompanied by a closing \\']\\' too\\n                while(k-- > 0)\\n                    ret+=dec;\\n            }\\n        }\\n        return ret;\\n    }\\n    string decodeString(string s) {\\n        int index = 0;\\n        return recurse(s, index);\\n        \\n    }\\n};\\n```\\nTime complexity: O(max(K).N) //as maximum repeatitions are bounded by max(K)\\nSpace complexity: O(N) //N = length of the string",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string recurse(string &s, int &index)\\n    {\\n        string ret;\\n        while(index<s.length() && s[index]!=\\']\\')\\n        {\\n            if(!isdigit(s[index]))\\n                ret+=s[index++];\\n            else\\n            {\\n                int k=0;\\n                while(index<s.length()&&isdigit(s[index]))\\n                    k = k*10 + s[index++]-\\'0\\';\\n                index++; //because digit always accompained by \\'[\\'\\n                string dec = recurse(s, index);\\n                index++; //and accompanied by a closing \\']\\' too\\n                while(k-- > 0)\\n                    ret+=dec;\\n            }\\n        }\\n        return ret;\\n    }\\n    string decodeString(string s) {\\n        int index = 0;\\n        return recurse(s, index);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611211,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    int i = 0;\\n\\n    public String decodeString(String s) {\\n        int count = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            i++;\\n            if (Character.isLetter(c)) {\\n                sb.append(c);\\n            } else if (Character.isDigit(c)) {\\n                count = count * 10 + Character.getNumericValue(c);\\n            } else if (c == \\']\\') {\\n                break;\\n            } else if (c == \\'[\\') {\\n                // sub problem\\n                String repeat = decodeString(s);\\n                while (count > 0) {\\n                    sb.append(repeat);\\n                    count--;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    int i = 0;\\n\\n    public String decodeString(String s) {\\n        int count = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            i++;\\n            if (Character.isLetter(c)) {\\n                sb.append(c);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2595784,
                "title": "simple-recursive-c-solution-with-explanation-0-ms-100",
                "content": "First, we have to find an opening bracket from the end. This is due to the fact that the brackets can be stacked within each other. The right-most opening bracket is guaranteed to be the innermost one.\\n\\n```c++\\nint first = s.rfind(\\'[\\');\\n```\\n\\nIf no opening bracket exists, we can return the initial string, otherwise, we should find the matching closing bracket, which is guaranteed to be the one after the opening bracket.\\n\\n```c++\\nif (first == string::npos) return s;\\nint second = s.find(\\']\\', first + 1);\\n```\\n\\nAfter finding the brackets, we now have to find `k`, which is the amount of repetitions for the value inside the brackets. For this, we can search backward until we reach a non-digit, or the beginning of the string.\\n\\n```c++\\nint kLength = 1;\\nfor (;; ++kLength) {\\n\\tif (first - kLength < 0 || !isdigit(s[first - kLength])) {\\n\\t\\t--kLength;\\n\\t\\tbreak;\\n\\t}\\n}\\n```\\n\\nAfter our search is complete, we can convert the found string to an integer using `stoi`.\\n\\n```c++\\nint k = stoi(s.substr(first - kLength, kLength));\\n```\\n\\nNow that we have the values for the `k` and the encoded string, we can split `s` into three parts: \\n- Before `k` and the encoded string\\n- The encoded string repeated `k` times\\n- After `k` and the encoded string\\n\\nTo find the before and after strings, we can use\\n\\n```c++\\nstring before = s.substr(0, first - kLength);\\nstring after = s.substr(second + 1);\\n```\\n\\nTo get the encoded string repeated `k` times, we can use\\n\\n```c++\\nstring decoded = \"\";\\nstring substr = s.substr(first + 1, second - first - 1);\\nfor (int i = 0; i < k; ++i) {\\n\\tdecoded += substr;\\n}\\n```\\n\\nand reconstruct `s` using\\n\\n```c++\\ns = before + decoded + after;\\n```\\n\\nWe then will apply this operation recursively until no brackets remain, and return the `s` value.\\n\\n```c++\\nreturn decodeString(s);\\n```\\n\\nThe overall code can be found below. Note that we are using the reference value of `s`, using `&` operator. This is due to the fact that we are changing the value of `s` in each iteration.\\n\\n```c++\\nstring decodeString(string& s) {\\n\\tint first = s.rfind(\\'[\\');\\n\\tif (first == string::npos) return s;\\n\\tint second = s.find(\\']\\', first + 1);\\n\\n\\tint kLength = 1;\\n\\tfor (;; ++kLength) {\\n\\t\\tif (first - kLength < 0 || !isdigit(s[first - kLength])) {\\n\\t\\t\\t--kLength;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tint k = stoi(s.substr(first - kLength, kLength));\\n\\n\\tstring before = s.substr(0, first - kLength);\\n\\tstring after = s.substr(second + 1);\\n\\n\\tstring decoded = \"\";\\n\\tstring substr = s.substr(first + 1, second - first - 1);\\n\\tfor (int i = 0; i < k; ++i) {\\n\\t\\tdecoded += substr;\\n\\t}\\n\\n\\ts = before + decoded + after;\\n\\n\\treturn decodeString(s);\\n}\\n```\\n\\nHope this helped you! Good luck on your interview.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```c++\\nint first = s.rfind(\\'[\\');\\n```\n```c++\\nif (first == string::npos) return s;\\nint second = s.find(\\']\\', first + 1);\\n```\n```c++\\nint kLength = 1;\\nfor (;; ++kLength) {\\n\\tif (first - kLength < 0 || !isdigit(s[first - kLength])) {\\n\\t\\t--kLength;\\n\\t\\tbreak;\\n\\t}\\n}\\n```\n```c++\\nint k = stoi(s.substr(first - kLength, kLength));\\n```\n```c++\\nstring before = s.substr(0, first - kLength);\\nstring after = s.substr(second + 1);\\n```\n```c++\\nstring decoded = \"\";\\nstring substr = s.substr(first + 1, second - first - 1);\\nfor (int i = 0; i < k; ++i) {\\n\\tdecoded += substr;\\n}\\n```\n```c++\\ns = before + decoded + after;\\n```\n```c++\\nreturn decodeString(s);\\n```\n```c++\\nstring decodeString(string& s) {\\n\\tint first = s.rfind(\\'[\\');\\n\\tif (first == string::npos) return s;\\n\\tint second = s.find(\\']\\', first + 1);\\n\\n\\tint kLength = 1;\\n\\tfor (;; ++kLength) {\\n\\t\\tif (first - kLength < 0 || !isdigit(s[first - kLength])) {\\n\\t\\t\\t--kLength;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tint k = stoi(s.substr(first - kLength, kLength));\\n\\n\\tstring before = s.substr(0, first - kLength);\\n\\tstring after = s.substr(second + 1);\\n\\n\\tstring decoded = \"\";\\n\\tstring substr = s.substr(first + 1, second - first - 1);\\n\\tfor (int i = 0; i < k; ++i) {\\n\\t\\tdecoded += substr;\\n\\t}\\n\\n\\ts = before + decoded + after;\\n\\n\\treturn decodeString(s);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1861915,
                "title": "c-simple-and-clean-solution-with-comments-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) \\n    {\\n        // encoding rule is k[encoded_string]\\n        stack<string> chars; // stack for keeping track of the already decoded string\\n        stack<int> nums; // stack for k\\n        string res;\\n        int num = 0;\\n        \\n        //Iterate through every single character in s -->o(n); n is size of s\\n        for(char c : s) {\\n            /*\\n            There are 4 possible states that we can see\\n            (1) number --> use built in isdigit(char)\\n            (2) alphabet --> use built in isaplha(char)\\n                >> Just add the character to the result if we see a letter\\n            (3) \\'[\\' -->just compare with that char\\n            (4) \\']\\' --> just compare with that char\\n            */\\n            if(isdigit(c)) \\n            {\\n                num = num*10 + (c-\\'0\\');  // coverts the string number to integer\\n                // Note that we need to handle cases like 22[a], this is just using increasing the place value by one and then adding the single digit to the ones place value\\n            }\\n            else if(isalpha(c)) \\n            { // check if character is a letter\\n                res.push_back(c);            \\n            }\\n            else if(c == \\'[\\') \\n            { // From the encoding rule, we are guaranteed a number\\n                // prior to \\'[\\' and an encoded_string after \\'[\\'\\n                // Hence we can push all number and encoded_string to their stacks\\n                \\n                chars.push(res); // put the encoded_string to stack\\n                nums.push(num); // put the number into the stack\\n                \\n                // reset back to default \\n                res = \"\";\\n                num = 0;\\n            }\\n            else if(c == \\']\\') \\n            {\\n                // every time we see \\']\\' we are guaranteed to have finished a set of \\n                // k[encoded_string]. Hence we can start processing the stacks                       // emptying them and moving it to res.  \\n                \\n                string tmp = res; \\n                for(int i=0; i<nums.top()-1; i++) res += tmp;\\n                \\n                res = chars.top() + res;\\n                chars.pop(); \\n                nums.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) \\n    {\\n        // encoding rule is k[encoded_string]\\n        stack<string> chars; // stack for keeping track of the already decoded string\\n        stack<int> nums; // stack for k\\n        string res;\\n        int num = 0;\\n        \\n        //Iterate through every single character in s -->o(n); n is size of s\\n        for(char c : s) {\\n            /*\\n            There are 4 possible states that we can see\\n            (1) number --> use built in isdigit(char)\\n            (2) alphabet --> use built in isaplha(char)\\n                >> Just add the character to the result if we see a letter\\n            (3) \\'[\\' -->just compare with that char\\n            (4) \\']\\' --> just compare with that char\\n            */\\n            if(isdigit(c)) \\n            {\\n                num = num*10 + (c-\\'0\\');  // coverts the string number to integer\\n                // Note that we need to handle cases like 22[a], this is just using increasing the place value by one and then adding the single digit to the ones place value\\n            }\\n            else if(isalpha(c)) \\n            { // check if character is a letter\\n                res.push_back(c);            \\n            }\\n            else if(c == \\'[\\') \\n            { // From the encoding rule, we are guaranteed a number\\n                // prior to \\'[\\' and an encoded_string after \\'[\\'\\n                // Hence we can push all number and encoded_string to their stacks\\n                \\n                chars.push(res); // put the encoded_string to stack\\n                nums.push(num); // put the number into the stack\\n                \\n                // reset back to default \\n                res = \"\";\\n                num = 0;\\n            }\\n            else if(c == \\']\\') \\n            {\\n                // every time we see \\']\\' we are guaranteed to have finished a set of \\n                // k[encoded_string]. Hence we can start processing the stacks                       // emptying them and moving it to res.  \\n                \\n                string tmp = res; \\n                for(int i=0; i<nums.top()-1; i++) res += tmp;\\n                \\n                res = chars.top() + res;\\n                chars.pop(); \\n                nums.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635529,
                "title": "fastest-solution-0ms-well-explained-c-recursion",
                "content": "This solutin can be very fast with recusrion.\\nLets take an example...\\n\\n![image](https://assets.leetcode.com/users/images/b5116ec6-72cf-414f-b0cc-d9efd5f3d4d9_1639896946.4418724.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    string solve(const string &s, int &i)\\n    {\\n        string z;\\n        \\n        while(i<s.size() && s[i]!=\\']\\')\\n        {\\n\\t\\t\\t// This loop will continue till we get \\']\\'\\n            if(isdigit(s[i]))\\n            {\\n                int k=0;\\n                \\n                while(i<s.size() && isdigit(s[i]))\\n                {\\n                    k=k*10 +(s[i++]-\\'0\\'); // For numbers like 12,100,1212....\\n                }\\n                \\n                i++; // For \\'[\\'\\n                \\n                string t=solve(s,i); // string got from recursion\\n                \\n                i++; // For \\']\\'\\n                \\n                while(k--)\\n                {\\n                    z+=t; // Adding string got from recursion k*(string)...\\n                }      \\n            }\\n            else\\n                z+=s[i++]; // Adding string which are before digits.\\n        }\\n        return z;\\n    }\\n    \\n    string decodeString(string s) \\n    {\\n        int i=0;\\n        return solve(s,i);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string solve(const string &s, int &i)\\n    {\\n        string z;\\n        \\n        while(i<s.size() && s[i]!=\\']\\')\\n        {\\n\\t\\t\\t// This loop will continue till we get \\']\\'\\n            if(isdigit(s[i]))\\n            {\\n                int k=0;\\n                \\n                while(i<s.size() && isdigit(s[i]))\\n                {\\n                    k=k*10 +(s[i++]-\\'0\\'); // For numbers like 12,100,1212....\\n                }\\n                \\n                i++; // For \\'[\\'\\n                \\n                string t=solve(s,i); // string got from recursion\\n                \\n                i++; // For \\']\\'\\n                \\n                while(k--)\\n                {\\n                    z+=t; // Adding string got from recursion k*(string)...\\n                }      \\n            }\\n            else\\n                z+=s[i++]; // Adding string which are before digits.\\n        }\\n        return z;\\n    }\\n    \\n    string decodeString(string s) \\n    {\\n        int i=0;\\n        return solve(s,i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452908,
                "title": "easy-to-understand-javascript-solution-using-stack",
                "content": "```\\nvar decodeString = function(s) {\\n    const stack = [];\\n    \\n    for (let letter of s) {\\n        if (letter != \"]\") {\\n            stack.push(letter);\\n        } else {\\n            let substr = \"\";\\n            while (stack[stack.length - 1] != \"[\")\\n                substr = stack.pop() + substr;\\n            \\n            // remove closing open bracket\\n            stack.pop();\\n            \\n            let k = \"\";\\n            \\n            while (stack.length && /^\\\\d+$/.test(stack[stack.length - 1])) \\n                k = stack.pop() + k;\\n\\n            stack.push(substr.repeat(Number(k)))            \\n        }\\n    }\\n    \\n    return stack.join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar decodeString = function(s) {\\n    const stack = [];\\n    \\n    for (let letter of s) {\\n        if (letter != \"]\") {\\n            stack.push(letter);\\n        } else {\\n            let substr = \"\";\\n            while (stack[stack.length - 1] != \"[\")\\n                substr = stack.pop() + substr;\\n            \\n            // remove closing open bracket\\n            stack.pop();\\n            \\n            let k = \"\";\\n            \\n            while (stack.length && /^\\\\d+$/.test(stack[stack.length - 1])) \\n                k = stack.pop() + k;\\n\\n            stack.push(substr.repeat(Number(k)))            \\n        }\\n    }\\n    \\n    return stack.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1450881,
                "title": "js-using-stack-o-n-time-and-space",
                "content": "```\\nfunction decodeString(s) {\\n\\t// stack is used to maintain the string that is decoded already and the count of the current string into consideration\\n    const stack = [];\\n\\tlet currStr = \\'\\', k = 0;\\n\\t\\n\\t// iterating through each character in the string\\n    for(let idx = 0; idx < s.length; ++idx) {    // O(n)\\n        const char = s[idx];\\n        if(char === \\'[\\') {\\n\\t\\t// if the char is `[`, that means the following string is encoded string, so we add the previous string and k (already processed) to the stack \\n            stack.push([currStr, k]);\\n            currStr = \\'\\';    // reset the value before the following string\\n            k = 0;\\n        } else if(char === \\']\\') {\\n\\t\\t// if the char is `]`, we have processed the encoded string, and we need to append it k times to the previous string (we can get these values from the stack - LIFO)\\n            const [prevStr, times] = stack.pop();\\n            currStr = prevStr + currStr.repeat(times);\\n        } else if(char.charCodeAt(0) >= 48 && char.charCodeAt(0) <= 57) {\\n\\t\\t// if the char is a digit, update the value of k\\n            k = k * 10 + parseInt(char);\\n        } else {\\n\\t\\t// otherwise, the char is a letter, we can append it to the currStr (which is the curr string into consideration) \\n            currStr += char;\\n        }\\n    }\\n    return currStr;    // after the loop finishes, currStr will be the resultant decoded string\\n}\\n```\\n\\nTime Complexity = O(m)\\nSpace Complexity = O(m) [stack]\\n[m - length of the output string]\\n\\n-----\\n\\nEdit: `Intuitive approach`\\n\\nThe encoded part will be of structure: `k[encoded_str]`\\nIf we start iterating the input string, number `k` will always be followed by `[` which will be followed by another number of a character.\\n\\n```\\nvar decodeString = function(s) {\\n    const stack = [];\\n    let i = 0, num = 1, m = 10, curr_str = [];\\n    while(i < s.length) {\\n\\t\\t// constructing the number `k`\\n        num = 0;\\n        while(s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n            num = num * m + parseInt(s[i]);\\n            ++i;\\n        }\\n\\t\\t// a number is always followed by `[`\\n        if(s[i] === \\'[\\') {\\n\\t\\t\\t++i;\\n\\t\\t}\\n\\t\\t// add the number to the stack\\n        if(num) {\\n            stack.push(num);\\n        }\\n\\t\\t// `k[` can be followed either by another number or a string, in case of a string, this block will construct the complete string until we find another type of character\\n        curr_str = [];\\n        while(s[i] >= \\'a\\' && s[i] <= \\'z\\') {\\n            curr_str.push(s[i]);\\n            ++i;\\n        }\\n        if(curr_str.length) {\\n\\t\\t\\t// stack will always have a number followed by a string until all the decoding is done\\n\\t\\t\\t// so if the top value in the stack is another string, we prepend it to the curr_str before pushing the complete string into the stack\\n            if(stack.length && typeof stack[stack.length - 1] === \"string\") {\\n                stack.push(stack.pop() + curr_str.join(\\'\\'));\\n            } else {\\n                stack.push(curr_str.join(\\'\\'));\\n            }\\n        }\\n        if(s[i] === \\']\\') {\\n\\t\\t\\t// as mentioned above, stack will always have a number followed by a string\\n            let top_str = stack.pop(), count = stack.pop();\\n\\t\\t\\t// similarly, if top value is a string, we prepend it to the new decoded string before pushing the complete string into the stack\\n            const temp_str = [];\\n\\t\\t\\tif(stack.length && typeof stack[stack.length - 1] === \"string\") {\\n                temp_str.push(stack.pop());\\n            }\\n            while(count--) {    // O(k)\\n                temp_str.push(top_str);\\n            }\\n            stack.push(temp_str.join(\\'\\'));\\n            ++i;\\n        } \\n    }\\n\\t// if using pure stack then we cannot perform this, so we can have another block where we construct the result by popping chars from the stack and then reverse the order and join\\n    return stack.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nfunction decodeString(s) {\\n\\t// stack is used to maintain the string that is decoded already and the count of the current string into consideration\\n    const stack = [];\\n\\tlet currStr = \\'\\', k = 0;\\n\\t\\n\\t// iterating through each character in the string\\n    for(let idx = 0; idx < s.length; ++idx) {    // O(n)\\n        const char = s[idx];\\n        if(char === \\'[\\') {\\n\\t\\t// if the char is `[`, that means the following string is encoded string, so we add the previous string and k (already processed) to the stack \\n            stack.push([currStr, k]);\\n            currStr = \\'\\';    // reset the value before the following string\\n            k = 0;\\n        } else if(char === \\']\\') {\\n\\t\\t// if the char is `]`, we have processed the encoded string, and we need to append it k times to the previous string (we can get these values from the stack - LIFO)\\n            const [prevStr, times] = stack.pop();\\n            currStr = prevStr + currStr.repeat(times);\\n        } else if(char.charCodeAt(0) >= 48 && char.charCodeAt(0) <= 57) {\\n\\t\\t// if the char is a digit, update the value of k\\n            k = k * 10 + parseInt(char);\\n        } else {\\n\\t\\t// otherwise, the char is a letter, we can append it to the currStr (which is the curr string into consideration) \\n            currStr += char;\\n        }\\n    }\\n    return currStr;    // after the loop finishes, currStr will be the resultant decoded string\\n}\\n```\n```\\nvar decodeString = function(s) {\\n    const stack = [];\\n    let i = 0, num = 1, m = 10, curr_str = [];\\n    while(i < s.length) {\\n\\t\\t// constructing the number `k`\\n        num = 0;\\n        while(s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n            num = num * m + parseInt(s[i]);\\n            ++i;\\n        }\\n\\t\\t// a number is always followed by `[`\\n        if(s[i] === \\'[\\') {\\n\\t\\t\\t++i;\\n\\t\\t}\\n\\t\\t// add the number to the stack\\n        if(num) {\\n            stack.push(num);\\n        }\\n\\t\\t// `k[` can be followed either by another number or a string, in case of a string, this block will construct the complete string until we find another type of character\\n        curr_str = [];\\n        while(s[i] >= \\'a\\' && s[i] <= \\'z\\') {\\n            curr_str.push(s[i]);\\n            ++i;\\n        }\\n        if(curr_str.length) {\\n\\t\\t\\t// stack will always have a number followed by a string until all the decoding is done\\n\\t\\t\\t// so if the top value in the stack is another string, we prepend it to the curr_str before pushing the complete string into the stack\\n            if(stack.length && typeof stack[stack.length - 1] === \"string\") {\\n                stack.push(stack.pop() + curr_str.join(\\'\\'));\\n            } else {\\n                stack.push(curr_str.join(\\'\\'));\\n            }\\n        }\\n        if(s[i] === \\']\\') {\\n\\t\\t\\t// as mentioned above, stack will always have a number followed by a string\\n            let top_str = stack.pop(), count = stack.pop();\\n\\t\\t\\t// similarly, if top value is a string, we prepend it to the new decoded string before pushing the complete string into the stack\\n            const temp_str = [];\\n\\t\\t\\tif(stack.length && typeof stack[stack.length - 1] === \"string\") {\\n                temp_str.push(stack.pop());\\n            }\\n            while(count--) {    // O(k)\\n                temp_str.push(top_str);\\n            }\\n            stack.push(temp_str.join(\\'\\'));\\n            ++i;\\n        } \\n    }\\n\\t// if using pure stack then we cannot perform this, so we can have another block where we construct the result by popping chars from the stack and then reverse the order and join\\n    return stack.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1212911,
                "title": "best-and-simple-stack-solution-beats-100-submissions-0-ms",
                "content": "```\\nstring decodeString(string s) {\\n        stack<char> stk;\\n        string ans = \"\";\\n        string temp = \"\";\\n        string no;\\n        \\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s[i]==\\'[\\'){\\n                stk.push(\\'[\\');\\n            }\\n            else if(s[i] == \\']\\'){\\n                temp = \"\";\\n                no = \"\" ;\\n                while(stk.top()!=\\'[\\'){\\n                    temp += stk.top();\\n                    stk.pop();\\n                }\\n                stk.pop();\\n                reverse(temp.begin(),temp.end());\\n                while(!stk.empty() and (stk.top() - \\'0\\' <= 9 and stk.top() - \\'0\\' >= 0 )){\\n                    no += stk.top();\\n                    stk.pop();\\n                }\\n                int num = 0;\\n                int p = 1;\\n                for(int k = 0 ; k < no.length() ; k++){\\n                     int x = no[k] - \\'0\\';\\n                     num += x*p;\\n                     p = p*10;\\n                }           \\n                string ch = temp;\\n                while(num>1){\\n                    temp += ch;\\n                    num--;\\n                }\\n\\n                if(stk.empty()){\\n                    ans += temp;\\n                }\\n                else{\\n                    for(int j = 0 ; j < temp.length() ; j++){\\n                        stk.push(temp[j]);\\n                    }\\n                }\\n                \\n            }\\n            else{\\n                if(stk.empty() and ((s[i] - \\'0\\' < 0) or (s[i] - \\'0\\' > 9))){\\n                    ans += s[i];\\n                }\\n                else{\\n                    stk.push(s[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nstring decodeString(string s) {\\n        stack<char> stk;\\n        string ans = \"\";\\n        string temp = \"\";\\n        string no;\\n        \\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s[i]==\\'[\\'){\\n                stk.push(\\'[\\');\\n            }\\n            else if(s[i] == \\']\\'){\\n                temp = \"\";\\n                no = \"\" ;\\n                while(stk.top()!=\\'[\\'){\\n                    temp += stk.top();\\n                    stk.pop();\\n                }\\n                stk.pop();\\n                reverse(temp.begin(),temp.end());\\n                while(!stk.empty() and (stk.top() - \\'0\\' <= 9 and stk.top() - \\'0\\' >= 0 )){\\n                    no += stk.top();\\n                    stk.pop();\\n                }\\n                int num = 0;\\n                int p = 1;\\n                for(int k = 0 ; k < no.length() ; k++){\\n                     int x = no[k] - \\'0\\';\\n                     num += x*p;\\n                     p = p*10;\\n                }           \\n                string ch = temp;\\n                while(num>1){\\n                    temp += ch;\\n                    num--;\\n                }\\n\\n                if(stk.empty()){\\n                    ans += temp;\\n                }\\n                else{\\n                    for(int j = 0 ; j < temp.length() ; j++){\\n                        stk.push(temp[j]);\\n                    }\\n                }\\n                \\n            }\\n            else{\\n                if(stk.empty() and ((s[i] - \\'0\\' < 0) or (s[i] - \\'0\\' > 9))){\\n                    ans += s[i];\\n                }\\n                else{\\n                    stk.push(s[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1127720,
                "title": "ruby-stack-solution",
                "content": "```\\ndef decode_string(s)\\n  stack = []\\n  s.each_char do |c|\\n    if c == \\']\\'\\n      s1 = \\'\\'\\n      while stack.last != \\'[\\'\\n        s1 = stack.pop + s1\\n      end\\n      stack.pop # remove \\'[\\'\\n      n = \\'\\'\\n      while !stack.empty? && stack.last.match?(/[0-9]/) # eg. \"100[leetcode]\"\\n        n = stack.pop + n\\n      end\\n      stack.push(s1 * n.to_i)\\n    else\\n      stack.push(c)\\n    end\\n  end\\n  stack.join\\nend",
                "solutionTags": [
                    "Ruby",
                    "Stack"
                ],
                "code": "```\\ndef decode_string(s)\\n  stack = []\\n  s.each_char do |c|\\n    if c == \\']\\'\\n      s1 = \\'\\'\\n      while stack.last != \\'[\\'\\n        s1 = stack.pop + s1\\n      end\\n      stack.pop # remove \\'[\\'\\n      n = \\'\\'\\n      while !stack.empty? && stack.last.match?(/[0-9]/) # eg. \"100[leetcode]\"\\n        n = stack.pop + n\\n      end\\n      stack.push(s1 * n.to_i)\\n    else\\n      stack.push(c)\\n    end\\n  end\\n  stack.join\\nend",
                "codeTag": "Python3"
            },
            {
                "id": 989421,
                "title": "c-two-approaches-recursion-two-stack-time-o-n-space-o-n",
                "content": "**Recursive**\\nThis is a smart af solution, originally by @bluedawnstar (I guess). If you\\'re wondering why i needs to be passed as a reference, it is because, we are changing the instance of the i variable by calling it in the middle of decodeStringUtil. Try cout-ing the i when the i is passed as a value and as a reference. :)\\nTime Complexity: O (size of original string + size of the result string) ~ O (n)\\nSpace Complexity: O (n)\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        int i = 0;\\n        return decodeStringUtil(s, i);\\n    }\\n    string decodeStringUtil (string s, int &i) {\\n        string res; \\n        while (i < s.length() && s[i] != \\']\\') {\\n\\n            if (!isdigit(s[i]))\\n                res += s[i++];\\n            else {\\n                int n = 0;\\n                while (i < s.length() && isdigit(s[i]))\\n                    n = n * 10 + s[i++] - \\'0\\';\\n                i++; \\n                string t = decodeStringUtil(s, i);\\n\\t\\t\\t\\t\\t\\t\\t\\t//cout<<i;\\n                i++; \\n                while (n--)\\n                    res += t;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Stack Based Solution**\\nTime Complexity: O (size of original string + size of the result string) ~ O (n)\\nSpace Complexity: O (n)\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack <string> sString;\\n        stack <int> sInt; \\n        string res;\\n        int n=0;\\n        \\n        for (int i=0; i<s.size(); i++) {\\n            if (isdigit(s[i])) {\\n                    n=n*10+s[i]-\\'0\\';\\n            }\\n            else if (isalpha(s[i])) {\\n                res.push_back(s[i]);\\n            }\\n            else if (s[i]==\\'[\\') {\\n                sString.push(res);\\n                sInt.push(n);\\n                \\n                res=\"\";\\n                n=0;\\n            }\\n\\n            else if (s[i]==\\']\\'){\\n                string tmp = res;\\n                for(int i = 0; i < sInt.top()-1; ++i) {\\n                    res += tmp;\\n                }\\n                res = sString.top() + res;\\n                sString.pop(); sInt.pop();\\n            }\\n        }\\n    return res;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        int i = 0;\\n        return decodeStringUtil(s, i);\\n    }\\n    string decodeStringUtil (string s, int &i) {\\n        string res; \\n        while (i < s.length() && s[i] != \\']\\') {\\n\\n            if (!isdigit(s[i]))\\n                res += s[i++];\\n            else {\\n                int n = 0;\\n                while (i < s.length() && isdigit(s[i]))\\n                    n = n * 10 + s[i++] - \\'0\\';\\n                i++; \\n                string t = decodeStringUtil(s, i);\\n\\t\\t\\t\\t\\t\\t\\t\\t//cout<<i;\\n                i++; \\n                while (n--)\\n                    res += t;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack <string> sString;\\n        stack <int> sInt; \\n        string res;\\n        int n=0;\\n        \\n        for (int i=0; i<s.size(); i++) {\\n            if (isdigit(s[i])) {\\n                    n=n*10+s[i]-\\'0\\';\\n            }\\n            else if (isalpha(s[i])) {\\n                res.push_back(s[i]);\\n            }\\n            else if (s[i]==\\'[\\') {\\n                sString.push(res);\\n                sInt.push(n);\\n                \\n                res=\"\";\\n                n=0;\\n            }\\n\\n            else if (s[i]==\\']\\'){\\n                string tmp = res;\\n                for(int i = 0; i < sInt.top()-1; ++i) {\\n                    res += tmp;\\n                }\\n                res = sString.top() + res;\\n                sString.pop(); sInt.pop();\\n            }\\n        }\\n    return res;\\n      \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 941687,
                "title": "python-3-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=-LNwE2E-8eE)\\nhttps://www.youtube.com/watch?v=-LNwE2E-8eE\\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = [[\"\",1]]\\n        num = \"\"\\n        nums = [str(x) for x in range(10)]\\n        \\n        for char in s:\\n            if char in nums:\\n                num += char\\n            elif char == \"[\":\\n                stack.append([\"\", int(num)])\\n                num = \"\"\\n            elif char == \"]\":\\n                string_, k = stack.pop()\\n                stack[-1][0] += string_ * k\\n            else:\\n                stack[-1][0] += char\\n        \\n        return stack[-1][0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = [[\"\",1]]\\n        num = \"\"\\n        nums = [str(x) for x in range(10)]\\n        \\n        for char in s:\\n            if char in nums:\\n                num += char\\n            elif char == \"[\":\\n                stack.append([\"\", int(num)])\\n                num = \"\"\\n            elif char == \"]\":\\n                string_, k = stack.pop()\\n                stack[-1][0] += string_ * k\\n            else:\\n                stack[-1][0] += char\\n        \\n        return stack[-1][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760318,
                "title": "c-solution-0ms-explanations-no-recursion-two-stacks",
                "content": "```\\nstruct node_times {\\n    int times;\\n    struct node_times* next;\\n};\\nstruct node_char {\\n    char c;\\n    struct node_char* next;\\n};\\nvoid push_num(struct node_times** head, int num) {\\n    struct node_times* new_node = (struct node_times*)malloc(sizeof(struct node_times));\\n    new_node->times = num;\\n    new_node->next = *head;\\n    *head = new_node;\\n}\\nvoid push_char(struct node_char** head, char c) {\\n    struct node_char* new_node = (struct node_char*)malloc(sizeof(struct node_char));\\n    new_node->c = c;\\n    new_node->next = *head;\\n    *head = new_node;\\n}\\nint pop_number(struct node_times** head) {\\n    struct node_times* tmp = *head;\\n    int ret_n = tmp->times;\\n    *head = (*head)->next;\\n    free(tmp);\\n    return ret_n;\\n}\\nchar pop_char(struct node_char** head) {\\n    struct node_char* tmp = *head;\\n    char ret_c = tmp->c;\\n    (*head) = (*head)->next;\\n    free(tmp);\\n    return ret_c;\\n}\\nint get_word_size(struct node_char* head) {\\n    int size = 0;\\n    while (head) {\\n        if (head->c == \\'[\\') break;\\n        size++;\\n        head = head->next;\\n    }\\n    return size;\\n}\\nchar* decodeString(char* s) {\\n    struct node_times* head_num_stack = NULL;\\n    struct node_char* head_char_stack = NULL;\\n    int i = 0;\\n    int w_size;\\n    int k;\\n    while (s[i]) {\\n        // if its a number push it to number\\'s stack\\n        if (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n            int num = atoi(&s[i]);\\n            while (s[i] >= \\'0\\' && s[i] <= \\'9\\') i++;// increment index to pass by the number\\n            // push the number to numbers stack\\n            push_num(&head_num_stack, num);\\n        }\\n        else if (s[i] > \\'9\\' && s[i] != \\']\\') {\\n            // if its any letter but not \\']\\' then just push it to char stack\\n            push_char(&head_char_stack, s[i]);\\n            i++;\\n        }\\n        else if (s[i] == \\'[\\') {\\n            // if its an opnening bracket push it to char stack\\n            push_char(&head_char_stack, \\'[\\');\\n            i++;\\n        }\\n        else if (s[i] == \\']\\') {\\n            // here we need building word procedure to begin\\n            w_size = get_word_size(head_char_stack); // get word size\\n            int n_times = pop_number(&head_num_stack); // get how much we need to repeat the word\\n            char* word = (char*)malloc(w_size * sizeof(char));// allocate memory for word for temporary work\\n            // read word chars into temporary word, also empty it from chars stack\\n            for (k = 0; k < w_size; k++) {\\n                word[k] = pop_char(&head_char_stack);\\n            }\\n            // now we have the word we need to push it the multiplier amount of times:\\n            // we have to push it in reversed order because we pulled it from char stack ( which is reversed )\\n           \\n            pop_char(&head_char_stack); // get rid of the opening bracket at char stack - \\'[\\'\\n            // now we need to push the word n_times\\n            for (; n_times > 0; n_times--) {\\n                for (k = w_size - 1; k >= 0; k--) {\\n                    push_char(&head_char_stack, word[k]);\\n                }\\n            }\\n            free(word); // free the temp string\\n            i++;\\n        }\\n    }\\n    // now we have the complete decoded string at the char_stack, all we need to do is to pop it out char by char and then reverse the chars order!\\n\\t // and dont forget we need 1 null byte for ending string Muhahaha!\\n    w_size = get_word_size(head_char_stack);// get overall string size - how many chars\\n    char* res = (char*)calloc(w_size + 1, sizeof(char)); // allocate memory for solution string\\n    //free(s); // free memory of instruction string - this is optional \\n    for (k = w_size - 1; k >= 0; k--) res[k] = pop_char(&head_char_stack);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nstruct node_times {\\n    int times;\\n    struct node_times* next;\\n};\\nstruct node_char {\\n    char c;\\n    struct node_char* next;\\n};\\nvoid push_num(struct node_times** head, int num) {\\n    struct node_times* new_node = (struct node_times*)malloc(sizeof(struct node_times));\\n    new_node->times = num;\\n    new_node->next = *head;\\n    *head = new_node;\\n}\\nvoid push_char(struct node_char** head, char c) {\\n    struct node_char* new_node = (struct node_char*)malloc(sizeof(struct node_char));\\n    new_node->c = c;\\n    new_node->next = *head;\\n    *head = new_node;\\n}\\nint pop_number(struct node_times** head) {\\n    struct node_times* tmp = *head;\\n    int ret_n = tmp->times;\\n    *head = (*head)->next;\\n    free(tmp);\\n    return ret_n;\\n}\\nchar pop_char(struct node_char** head) {\\n    struct node_char* tmp = *head;\\n    char ret_c = tmp->c;\\n    (*head) = (*head)->next;\\n    free(tmp);\\n    return ret_c;\\n}\\nint get_word_size(struct node_char* head) {\\n    int size = 0;\\n    while (head) {\\n        if (head->c == \\'[\\') break;\\n        size++;\\n        head = head->next;\\n    }\\n    return size;\\n}\\nchar* decodeString(char* s) {\\n    struct node_times* head_num_stack = NULL;\\n    struct node_char* head_char_stack = NULL;\\n    int i = 0;\\n    int w_size;\\n    int k;\\n    while (s[i]) {\\n        // if its a number push it to number\\'s stack\\n        if (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n            int num = atoi(&s[i]);\\n            while (s[i] >= \\'0\\' && s[i] <= \\'9\\') i++;// increment index to pass by the number\\n            // push the number to numbers stack\\n            push_num(&head_num_stack, num);\\n        }\\n        else if (s[i] > \\'9\\' && s[i] != \\']\\') {\\n            // if its any letter but not \\']\\' then just push it to char stack\\n            push_char(&head_char_stack, s[i]);\\n            i++;\\n        }\\n        else if (s[i] == \\'[\\') {\\n            // if its an opnening bracket push it to char stack\\n            push_char(&head_char_stack, \\'[\\');\\n            i++;\\n        }\\n        else if (s[i] == \\']\\') {\\n            // here we need building word procedure to begin\\n            w_size = get_word_size(head_char_stack); // get word size\\n            int n_times = pop_number(&head_num_stack); // get how much we need to repeat the word\\n            char* word = (char*)malloc(w_size * sizeof(char));// allocate memory for word for temporary work\\n            // read word chars into temporary word, also empty it from chars stack\\n            for (k = 0; k < w_size; k++) {\\n                word[k] = pop_char(&head_char_stack);\\n            }\\n            // now we have the word we need to push it the multiplier amount of times:\\n            // we have to push it in reversed order because we pulled it from char stack ( which is reversed )\\n           \\n            pop_char(&head_char_stack); // get rid of the opening bracket at char stack - \\'[\\'\\n            // now we need to push the word n_times\\n            for (; n_times > 0; n_times--) {\\n                for (k = w_size - 1; k >= 0; k--) {\\n                    push_char(&head_char_stack, word[k]);\\n                }\\n            }\\n            free(word); // free the temp string\\n            i++;\\n        }\\n    }\\n    // now we have the complete decoded string at the char_stack, all we need to do is to pop it out char by char and then reverse the chars order!\\n\\t // and dont forget we need 1 null byte for ending string Muhahaha!\\n    w_size = get_word_size(head_char_stack);// get overall string size - how many chars\\n    char* res = (char*)calloc(w_size + 1, sizeof(char)); // allocate memory for solution string\\n    //free(s); // free memory of instruction string - this is optional \\n    for (k = w_size - 1; k >= 0; k--) res[k] = pop_char(&head_char_stack);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 442453,
                "title": "easy-to-understand-c-stack-solution-0ms-beats-100",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Decode String.\\nMemory Usage: 9.2 MB, less than 7.84% of C++ online submissions for Decode String.\\n\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        \\n        if(s.size() == 0) return \"\";\\n        string res = \"\";\\n        stack<int> count;\\n        stack<string> st;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(isdigit(s[i]))\\n            {\\n                string str = \"\";\\n                while(i < s.size() && s[i+1] != \\'[\\')\\n                    str += s[i++];\\n                str += s[i];\\n                count.push(stoi(str));\\n            }\\n            else if(s[i] == \\']\\')\\n            {\\n                int cnt = count.top();\\n                count.pop();\\n                \\n                string str = \"\";\\n                while(!st.empty() && st.top() != \"[\")\\n                {\\n                    str =  st.top() + str;\\n                    st.pop();\\n                }\\n                \\n                st.pop();\\n                string temp = \"\";\\n                for(int k=0; k<cnt; k++)\\n                    temp = str + temp;\\n                \\n                st.push(temp);\\n            }\\n            else\\n                st.push(string(1,s[i]));\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            res = st.top() + res;\\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string decodeString(string s) {\\n        \\n        if(s.size() == 0) return \"\";\\n        string res = \"\";\\n        stack<int> count;\\n        stack<string> st;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(isdigit(s[i]))\\n            {\\n                string str = \"\";\\n                while(i < s.size() && s[i+1] != \\'[\\')\\n                    str += s[i++];\\n                str += s[i];\\n                count.push(stoi(str));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 326178,
                "title": "go-solution-using-stack",
                "content": "```\\nfunc decodeString(s string) string {\\n\\tstackNums := make([]int, 0)\\n\\tstackStr := make([]string, 0)\\n\\tvar res string\\n\\tvar num int\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tswitch {\\n\\t\\tcase s[i] >= \\'0\\' && s[i] <= \\'9\\':\\n\\t\\t\\tnum = 10*num + int(s[i]) - \\'0\\'\\n\\t\\tcase s[i] == \\'[\\':\\n\\t\\t\\tstackNums = append(stackNums, num)\\n\\t\\t\\tnum = 0\\n\\t\\t\\tstackStr = append(stackStr, res)\\n\\t\\t\\tres = \"\"\\n\\t\\tcase s[i] == \\']\\':\\n\\t\\t\\ttmp := stackStr[len(stackStr)-1]\\n\\t\\t\\tstackStr = stackStr[:len(stackStr)-1]\\n\\t\\t\\tcount := stackNums[len(stackNums)-1]\\n\\t\\t\\tstackNums = stackNums[:len(stackNums)-1]\\n\\t\\t\\tres = tmp + strings.Repeat(res, count)\\n\\t\\tdefault:\\n\\t\\t\\tres += string(s[i])\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc decodeString(s string) string {\\n\\tstackNums := make([]int, 0)\\n\\tstackStr := make([]string, 0)\\n\\tvar res string\\n\\tvar num int\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tswitch {\\n\\t\\tcase s[i] >= \\'0\\' && s[i] <= \\'9\\':\\n\\t\\t\\tnum = 10*num + int(s[i]) - \\'0\\'\\n\\t\\tcase s[i] == \\'[\\':\\n\\t\\t\\tstackNums = append(stackNums, num)\\n\\t\\t\\tnum = 0\\n\\t\\t\\tstackStr = append(stackStr, res)\\n\\t\\t\\tres = \"\"\\n\\t\\tcase s[i] == \\']\\':\\n\\t\\t\\ttmp := stackStr[len(stackStr)-1]\\n\\t\\t\\tstackStr = stackStr[:len(stackStr)-1]\\n\\t\\t\\tcount := stackNums[len(stackNums)-1]\\n\\t\\t\\tstackNums = stackNums[:len(stackNums)-1]\\n\\t\\t\\tres = tmp + strings.Repeat(res, count)\\n\\t\\tdefault:\\n\\t\\t\\tres += string(s[i])\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 195133,
                "title": "recursive-descent-parser-solution",
                "content": "Maybe it\\'s an overkill, but definitely easier to reason. No need to handle edge cases or anything. \\n\\nThe hardest thing  is come up with the grammar. As long as you come up with the grammar is mechanical parser implementation.\\n```\\nGrammar:\\nenc_s := multiplier enc_s | s enc_s | eps\\nmultiplier := num [ enc_s ]\\ns := w+\\nnum := d+\\n```\\n\\nI use regex for the lexing part in order not to play with the input, like:\\n```\\nif char.isdigit():\\n\\taccumulator = accumulator * 10 + (ord(char) - ord(\\'0\\'))\\n```\\n\\nJust split into tokens, parse and then eval and eval function is easy for all of the non-terminals\\n\\nCode:\\n```\\nimport re\\n\\nclass String(object):\\n    def __init__(self, s): self.s = s\\n    def eval(self): return self.s\\n\\nclass EncodedString(object):\\n    def __init__(self, left, right=String(\"\")):\\n        self.left = left\\n        self.right = right\\n    \\n    def eval(self): return \"\".join([self.left.eval(), self.right.eval()])\\n\\nclass MultiplierNode(object):\\n    def __init__(self, num, child):\\n        self.multiplier = num\\n        self.child = child\\n    \\n    def eval(self): return self.multiplier * self.child.eval()\\n\\nclass Parser(object):\\n    def consume(self):\\n        val = self.lookahead()\\n        self.idx += 1\\n        return val\\n    \\n    def lookahead(self): return self.tokens[self.idx]\\n    \\n    def parse(self, tokens):\\n        self.idx = 0\\n        self.tokens = tokens\\n        return self.__enc_s__()\\n    \\n    def __enc_s__(self):\\n        node = String(\"\") ## empty string\\n        \\n        while self.idx < len(self.tokens) and (self.lookahead().isdigit() or self.lookahead().isalpha()):\\n            if self.lookahead().isdigit():  node = EncodedString(node, self.__multiplier__())\\n            else:                           node = EncodedString(node, String(self.consume()))\\n        \\n        return node\\n    \\n    def __multiplier__(self):\\n        multiplier = int(self.consume())\\n\\n        self.consume() ## skip [\\n        node = MultiplierNode(multiplier, self.__enc_s__())\\n        self.consume() ## skip ]\\n\\n        return node\\n\\nclass Solution(object):\\n    def decodeString(self, s): \\n        def scan(s): return re.findall(\"\\\\d+|\\\\[|\\\\]|[a-zA-Z]+\", s)\\n        \\n        parser = Parser()\\n        return parser.parse(scan(s)).eval()\\n```",
                "solutionTags": [],
                "code": "```\\nGrammar:\\nenc_s := multiplier enc_s | s enc_s | eps\\nmultiplier := num [ enc_s ]\\ns := w+\\nnum := d+\\n```\n```\\nif char.isdigit():\\n\\taccumulator = accumulator * 10 + (ord(char) - ord(\\'0\\'))\\n```\n```\\nimport re\\n\\nclass String(object):\\n    def __init__(self, s): self.s = s\\n    def eval(self): return self.s\\n\\nclass EncodedString(object):\\n    def __init__(self, left, right=String(\"\")):\\n        self.left = left\\n        self.right = right\\n    \\n    def eval(self): return \"\".join([self.left.eval(), self.right.eval()])\\n\\nclass MultiplierNode(object):\\n    def __init__(self, num, child):\\n        self.multiplier = num\\n        self.child = child\\n    \\n    def eval(self): return self.multiplier * self.child.eval()\\n\\nclass Parser(object):\\n    def consume(self):\\n        val = self.lookahead()\\n        self.idx += 1\\n        return val\\n    \\n    def lookahead(self): return self.tokens[self.idx]\\n    \\n    def parse(self, tokens):\\n        self.idx = 0\\n        self.tokens = tokens\\n        return self.__enc_s__()\\n    \\n    def __enc_s__(self):\\n        node = String(\"\") ## empty string\\n        \\n        while self.idx < len(self.tokens) and (self.lookahead().isdigit() or self.lookahead().isalpha()):\\n            if self.lookahead().isdigit():  node = EncodedString(node, self.__multiplier__())\\n            else:                           node = EncodedString(node, String(self.consume()))\\n        \\n        return node\\n    \\n    def __multiplier__(self):\\n        multiplier = int(self.consume())\\n\\n        self.consume() ## skip [\\n        node = MultiplierNode(multiplier, self.__enc_s__())\\n        self.consume() ## skip ]\\n\\n        return node\\n\\nclass Solution(object):\\n    def decodeString(self, s): \\n        def scan(s): return re.findall(\"\\\\d+|\\\\[|\\\\]|[a-zA-Z]+\", s)\\n        \\n        parser = Parser()\\n        return parser.parse(scan(s)).eval()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87587,
                "title": "python-recursion-and-iteration-dfs",
                "content": "The recursion is a little bit strange. Since Python's Integer is immutable, and Python 2.7 doesn't support `nonlocal`, I return both `i` and processed string in the recursion function.\\n\\n```python\\nclass Solution(object):\\n    def dfs(self, s, i):\\n        length = len(s)\\n        result = []\\n        while i < length:\\n            if s[i].isdigit():\\n                count_str = ''\\n                while s[i] != '[':\\n                    count_str += s[i]\\n                    i += 1\\n                count = int(count_str)\\n                i += 1\\n                i, substr = self.dfs(s, i)\\n                result.append(count * substr)\\n            elif s[i] == ']':\\n                i += 1\\n                return i, ''.join(result)\\n            else:\\n                result.append(s[i])\\n                i += 1\\n\\n        return ''.join(result)\\n\\n    def decodeString(self, s):\\n        if not s or len(s) == 0:\\n            return ''\\n\\n        return self.dfs(s, 0)\\n```\\n\\n\\n```python\\nclass Solution(object):\\n    def decodeString(self, s):\\n        if not s or len(s) == 0:\\n            return ''\\n\\n        i, length = 0, len(s)\\n        substr = []\\n        stack = []\\n        while i < length:\\n            if s[i].isdigit():\\n                count_str = ''\\n                while s[i] != '[':\\n                    count_str += s[i]\\n                    i += 1\\n                count = int(count_str)\\n                stack.append(substr)\\n                stack.append(count)\\n                substr = []\\n            elif s[i] == ']':\\n                count = stack.pop()\\n                outer_substr = stack.pop()\\n                outer_substr.append(''.join(substr) * count)\\n                substr = outer_substr\\n            else:\\n                substr.append(s[i])\\n\\n            i += 1\\n\\n        return ''.join(substr)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def dfs(self, s, i):\\n        length = len(s)\\n        result = []\\n        while i < length:\\n            if s[i].isdigit():\\n                count_str = ''\\n                while s[i] != '[':\\n                    count_str += s[i]\\n                    i += 1\\n                count = int(count_str)\\n                i += 1\\n                i, substr = self.dfs(s, i)\\n                result.append(count * substr)\\n            elif s[i] == ']':\\n                i += 1\\n                return i, ''.join(result)\\n            else:\\n                result.append(s[i])\\n                i += 1\\n\\n        return ''.join(result)\\n\\n    def decodeString(self, s):\\n        if not s or len(s) == 0:\\n            return ''\\n\\n        return self.dfs(s, 0)\\n```\n```python\\nclass Solution(object):\\n    def decodeString(self, s):\\n        if not s or len(s) == 0:\\n            return ''\\n\\n        i, length = 0, len(s)\\n        substr = []\\n        stack = []\\n        while i < length:\\n            if s[i].isdigit():\\n                count_str = ''\\n                while s[i] != '[':\\n                    count_str += s[i]\\n                    i += 1\\n                count = int(count_str)\\n                stack.append(substr)\\n                stack.append(count)\\n                substr = []\\n            elif s[i] == ']':\\n                count = stack.pop()\\n                outer_substr = stack.pop()\\n                outer_substr.append(''.join(substr) * count)\\n                substr = outer_substr\\n            else:\\n                substr.append(s[i])\\n\\n            i += 1\\n\\n        return ''.join(substr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87720,
                "title": "javascript-solution-with-stack",
                "content": "Javascript solution with stack\\n```\\nvar decodeString = function(s) {\\n    var stack = [];\\n    var i=0;\\n    var j=0;\\n    for(; i<s.length; i++) {\\n        var buf = [];\\n        var seq;\\n        var freq = 0;\\n        var c = s.charAt(i);\\n        if (c===']') {\\n            for(j = stack.length-1; j>=0; j--) {\\n                var p = stack.pop();\\n                if (p === '[') {\\n                    seq = buf.join('');\\n                    buf = [];\\n                    for(var k=j-1; k>=0 && stack[k]>='0' && stack[k]<='9'; k--) {\\n                        buf.unshift(stack.pop());\\n                    }\\n                    freq=parseInt(buf.join(''));\\n                    stack.push(Array(freq+1).join(seq));\\n                    buf = [];\\n                    break;\\n                }\\n                else {\\n                    buf.unshift(p);\\n                }\\n            }\\n        }\\n        else {\\n            stack.push(c);\\n        }\\n    }\\n    return stack.join('');\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "Javascript solution with stack\\n```\\nvar decodeString = function(s) {\\n    var stack = [];\\n    var i=0;\\n    var j=0;\\n    for(; i<s.length; i++) {\\n        var buf = [];\\n        var seq;\\n        var freq = 0;\\n        var c = s.charAt(i);\\n        if (c===']') {\\n            for(j = stack.length-1; j>=0; j--) {\\n                var p = stack.pop();\\n                if (p === '[') {\\n                    seq = buf.join('');\\n                    buf = [];\\n                    for(var k=j-1; k>=0 && stack[k]>='0' && stack[k]<='9'; k--) {\\n                        buf.unshift(stack.pop());\\n                    }\\n                    freq=parseInt(buf.join(''));\\n                    stack.push(Array(freq+1).join(seq));\\n                    buf = [];\\n                    break;\\n                }\\n                else {\\n                    buf.unshift(p);\\n                }\\n            }\\n        }\\n        else {\\n            stack.push(c);\\n        }\\n    }\\n    return stack.join('');\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3776871,
                "title": "simple-explained-c-solution-using-1-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing stack and looping through string and checking for each character\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are traversing string and pushing element is stack if it\\'s not \\']\\'.\\nWhen we encounter \\']\\', we pop elements of stack and process then until we find \\'[\\'. We  make string temp which stores the string which is to be processed latest and we store the integer n, ie number of times that string is to be repeated. then for n times we push the characters of that string back to the stack and continue it for same. At last we pop elements and store in ans string.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]!=\\']\\')\\n            st.push(s[i]);\\n            else\\n            {\\n                string temp=\"\";\\n                while(st.top()!=\\'[\\')\\n                {\\n                    temp+=st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n\\n                string num=\"\";\\n                while(st.empty()==false && isdigit(st.top()))\\n                {\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                if(num.size()>0)\\n                {\\n                    reverse(num.begin(),num.end());\\n                    int n = stoi(num);\\n                    while(n>0)\\n                    {\\n                        for(int j=0;j<temp.size();j++)\\n                        {\\n                            st.push(temp[j]);\\n                        }\\n                        n--;\\n                    }\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty())\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if you liked solution",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]!=\\']\\')\\n            st.push(s[i]);\\n            else\\n            {\\n                string temp=\"\";\\n                while(st.top()!=\\'[\\')\\n                {\\n                    temp+=st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n\\n                string num=\"\";\\n                while(st.empty()==false && isdigit(st.top()))\\n                {\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                if(num.size()>0)\\n                {\\n                    reverse(num.begin(),num.end());\\n                    int n = stoi(num);\\n                    while(n>0)\\n                    {\\n                        for(int j=0;j<temp.size();j++)\\n                        {\\n                            st.push(temp[j]);\\n                        }\\n                        n--;\\n                    }\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty())\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637054,
                "title": "easy-c-solution-beat-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        for(auto ch: s){\\n            if(ch==\\']\\'){\\n                string stringtorepeat=\"\";\\n                while(!st.empty()&& st.top()!=\"[\"){\\n                    string top=st.top();\\n                    stringtorepeat+=top;\\n                    st.pop();\\n                }\\n                st.pop();//st.top has \\'[\\' this one the top so pop\\n                //now we will take number of time we want to repeat \\n                string num=\"\";\\n                while(!st.empty() && isdigit(st.top()[0])){\\n                    string top=st.top();\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                // reverse 321 to 123\\n                reverse(num.begin(),num.end());\\n                int n=stoi(num);\\n            \\n\\n                //final decoding \\n                string currdecode=\"\";\\n                while(n--){\\n                    currdecode+=stringtorepeat;\\n                }\\n                st.push(currdecode);\\n            }\\n            else \\n            {\\n                string temp(1,ch);///convert char to string\\n                st.push(temp);\\n            }\\n        }\\n        ///ye mujhe sari stirng dedega abh m inko final rev karke ans return kardunga \\n                string ans=\"\";\\n                while(!st.empty()){\\n                    ans+=st.top();\\n                    st.pop();\\n                }\\n                reverse(ans.begin(),ans.end());\\n                return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        for(auto ch: s){\\n            if(ch==\\']\\'){\\n                string stringtorepeat=\"\";\\n                while(!st.empty()&& st.top()!=\"[\"){\\n                    string top=st.top();\\n                    stringtorepeat+=top;\\n                    st.pop();\\n                }\\n                st.pop();//st.top has \\'[\\' this one the top so pop\\n                //now we will take number of time we want to repeat \\n                string num=\"\";\\n                while(!st.empty() && isdigit(st.top()[0])){\\n                    string top=st.top();\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                // reverse 321 to 123\\n                reverse(num.begin(),num.end());\\n                int n=stoi(num);\\n            \\n\\n                //final decoding \\n                string currdecode=\"\";\\n                while(n--){\\n                    currdecode+=stringtorepeat;\\n                }\\n                st.push(currdecode);\\n            }\\n            else \\n            {\\n                string temp(1,ch);///convert char to string\\n                st.push(temp);\\n            }\\n        }\\n        ///ye mujhe sari stirng dedega abh m inko final rev karke ans return kardunga \\n                string ans=\"\";\\n                while(!st.empty()){\\n                    ans+=st.top();\\n                    st.pop();\\n                }\\n                reverse(ans.begin(),ans.end());\\n                return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232199,
                "title": "javascript-easy-fun-solution-o-m-n",
                "content": "# Approach\\nFirst I defiened ```stack``` data structure to keep track of the characters in the input string.\\n\\nThen the function iterates over each character in the string, and if the character is a closing square bracket ```\"]\"```, it pops characters off the stack until it finds the corresponding opening square bracket ```\"[\"```\\n```\\nwhile (true) { \\n    const char = stack.pop()\\n    if (char === \\'[\\') break \\n    str = char + str\\n}\\n```\\nIt then pops off any numbers that are immediately before the opening bracket\\n```\\n while (Number.isInteger(+stack[stack.length - 1])) { \\n    const number = stack.pop()\\n    n = number + n\\n}\\n```\\nthe function then uses those numbers to repeat the string that was just popped off the stack. The repeated string is then pushed back onto the stack.\\n\\n``` stack.push(str.repeat(+n))```\\n\\nIf the character is not a closing square bracket, it is simply pushed onto the stack. Once all characters have been processed, the remaining contents of the stack are joined together into a single string, which is returned as the final result.\\n# Time Complexity: O(n * m)\\nThe time complexity of my code is O(n*m), where n is the length of the input string and m is the maximum number that appears in the input string.\\n\\nThis is because for each character in the input string, the code either pushes it onto the stack or pops characters off the stack until it finds a matching opening bracket. In the worst case, each character in the string could correspond to a bracket, which means the code would need to traverse the entire stack for each character. \\n\\n```return stack.join(\\'\\')```\\n# Space Complexity: O(n)\\n# Enjoy with my code (^_^)\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nconst decodeString = s => {\\n    if (s.length === 1) { \\n        if (Number.isInteger(+s)) return \"\"\\n        else return s\\n    }\\n    const stack = []\\n    for (let i = 0; i < s.length; i++) { \\n        if (s[i] === \\']\\') { \\n            let str = \\'\\'\\n            while (true) { \\n                const char = stack.pop()\\n                if (char === \\'[\\') break \\n                str = char + str\\n            }\\n            let n = \\'\\'\\n            while (Number.isInteger( +stack[stack.length - 1])) { \\n                const number = stack.pop()\\n                n = number + n\\n            }\\n            stack.push(str.repeat(+n))\\n        } \\n        else stack.push(s[i])\\n    }\\n    return stack.join(\\'\\')\\n};\\n```\\n# that\\'s it bro\\n![T\\xED \\uD83D\\uDC2D.jfif](https://assets.leetcode.com/users/images/13be616b-964e-4d47-9798-2fbbb7f0eed0_1677404287.5793607.jpeg)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```stack```\n```\"]\"```\n```\"[\"```\n```\\nwhile (true) { \\n    const char = stack.pop()\\n    if (char === \\'[\\') break \\n    str = char + str\\n}\\n```\n```\\n while (Number.isInteger(+stack[stack.length - 1])) { \\n    const number = stack.pop()\\n    n = number + n\\n}\\n```\n``` stack.push(str.repeat(+n))```\n```return stack.join(\\'\\')```\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nconst decodeString = s => {\\n    if (s.length === 1) { \\n        if (Number.isInteger(+s)) return \"\"\\n        else return s\\n    }\\n    const stack = []\\n    for (let i = 0; i < s.length; i++) { \\n        if (s[i] === \\']\\') { \\n            let str = \\'\\'\\n            while (true) { \\n                const char = stack.pop()\\n                if (char === \\'[\\') break \\n                str = char + str\\n            }\\n            let n = \\'\\'\\n            while (Number.isInteger( +stack[stack.length - 1])) { \\n                const number = stack.pop()\\n                n = number + n\\n            }\\n            stack.push(str.repeat(+n))\\n        } \\n        else stack.push(s[i])\\n    }\\n    return stack.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3134985,
                "title": "0ms-easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer>numStack=new Stack<>();\\n        Stack<StringBuilder>strBuild=new Stack<>();\\n        StringBuilder str = new StringBuilder();\\n        int num=0;\\n        for(char c:s.toCharArray()){\\n            if(c>=\\'0\\' && c<=\\'9\\'){\\n                num=num*10 +c -\\'0\\';\\n            }\\n            else if(c==\\'[\\'){\\n                strBuild.push(str);\\n                str=new StringBuilder();\\n                numStack.push(num);\\n                num=0;\\n            }else if(c==\\']\\'){\\n                StringBuilder temp=str;\\n                str=strBuild.pop();\\n                int count=numStack.pop();\\n                while(count-->0){\\n                    str.append(temp);\\n                }\\n            }else{\\n                str.append(c);\\n            }\\n        }\\n        return str.toString();\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer>numStack=new Stack<>();\\n        Stack<StringBuilder>strBuild=new Stack<>();\\n        StringBuilder str = new StringBuilder();\\n        int num=0;\\n        for(char c:s.toCharArray()){\\n            if(c>=\\'0\\' && c<=\\'9\\'){\\n                num=num*10 +c -\\'0\\';\\n            }\\n            else if(c==\\'[\\'){\\n                strBuild.push(str);\\n                str=new StringBuilder();\\n                numStack.push(num);\\n                num=0;\\n            }else if(c==\\']\\'){\\n                StringBuilder temp=str;\\n                str=strBuild.pop();\\n                int count=numStack.pop();\\n                while(count-->0){\\n                    str.append(temp);\\n                }\\n            }else{\\n                str.append(c);\\n            }\\n        }\\n        return str.toString();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019418,
                "title": "c-beats-100-recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n     string solve(string s, int &index) {\\n        string ans; \\n        while (index < s.size() && s[index] != \\']\\')\\n        {\\n            if (!isdigit(s[index]))\\n                ans += s[index++];\\n            else \\n            {\\n                int n = 0;\\n                while (index < s.size() && isdigit(s[index]))\\n                    n = n * 10 + s[index++] - \\'0\\';\\n                index++; \\n                string temp = solve(s, index);\\n                index++; \\n                while (n--)\\n                    ans += temp;\\n            }\\n        }\\n        return ans;\\n    }\\n    string decodeString(string s) {\\n        int index = 0;\\n        return solve(s, index);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     string solve(string s, int &index) {\\n        string ans; \\n        while (index < s.size() && s[index] != \\']\\')\\n        {\\n            if (!isdigit(s[index]))\\n                ans += s[index++];\\n            else \\n            {\\n                int n = 0;\\n                while (index < s.size() && isdigit(s[index]))\\n                    n = n * 10 + s[index++] - \\'0\\';\\n                index++; \\n                string temp = solve(s, index);\\n                index++; \\n                while (n--)\\n                    ans += temp;\\n            }\\n        }\\n        return ans;\\n    }\\n    string decodeString(string s) {\\n        int index = 0;\\n        return solve(s, index);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571855,
                "title": "python-code-using-recursion",
                "content": "**Points to Note:**\\n1. Until we encounter an opening bracket \\'[\\' it must be an integer.\\n\\n2. When we encounter a closing bracket \\']\\' it means from the preceeding opening bracket \\'[\\' the expression between the brackets \\'[.....]\\' needs to be evaluated and multiplied with the number before the opening bracket. eg. number * [....]\\n\\n3. So, the idea is to go as deep inside as possible and evaluate the inner expression first then the outer ones.\\neg. \"3[a2[c]]\"\\n* \\tWe need to evaluate 2[c] first, then we get 3[acc]\\n* \\twe evaluate 3[acc] we get \"accaccacc\".\\n\\nAnother case to remember:\\n* If we encounter an closing bracket that doesn\\'t mean we are done there may be string ahead so we need to move forward to check.\\n* So, after encountering a \\']\\' remember the index and return so that you can check if there is string ahead\\n\\n` int(n)*helper(i+1,\"\",l)+helper(l[0]+1,\"\",l)`\\n That is exactly what the above expression does,\\n*  we multiply the number to the expression in the brackets i,e., `int(n)*helper(i+1,\"\",l)`\\n*  Then with that function call we get the evaluated string and then to check ahead in the string we call the function `helper(l[0]+1,\"\",l)` and append it to the return value\\n\\n\\t` int(n)*helper(i+1,\"\",l)+helper(l[0]+1,\"\",l)`.\\n\\n\\tHere, l is the list with index 0 to remember the index from where we returned after evaluating the expression in the brackets [...]\\n\\t\\n\\t**Note:**  *list is used instead of a variable because list is passed by reference so value can be retained.*\\n\\t\\n\\t\\t \\n\\t\\t \\n```    def decodeString(self, s: str) -> str:\\n        def helper(i,n,l):\\n            if i>=len(s):\\n                return \"\"\\n\\t\\t\\t\\t\\n            if s[i]==\"]\":\\n                l[0] = i #we keep track where we left\\n                return \"\"\\n\\t\\t\\t\\t\\n            if s[i]==\"[\":\\n                return int(n)*helper(i+1,\"\",l)+helper(l[0]+1,\"\",l)\\n\\t\\t\\t\\t\\n            if s[i].isnumeric():\\n                return helper(i+1,n+s[i],l)\\n\\t\\t\\t\\t\\n            else:\\n                return s[i]+helper(i+1,n,l)\\n\\t\\t\\t\\t\\n        l = [0]\\n        return helper(0,\"\",l)\\n\\t```\\n\\t\\n\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```    def decodeString(self, s: str) -> str:\\n        def helper(i,n,l):\\n            if i>=len(s):\\n                return \"\"\\n\\t\\t\\t\\t\\n            if s[i]==\"]\":\\n                l[0] = i #we keep track where we left\\n                return \"\"\\n\\t\\t\\t\\t\\n            if s[i]==\"[\":\\n                return int(n)*helper(i+1,\"\",l)+helper(l[0]+1,\"\",l)\\n\\t\\t\\t\\t\\n            if s[i].isnumeric():\\n                return helper(i+1,n+s[i],l)\\n\\t\\t\\t\\t\\n            else:\\n                return s[i]+helper(i+1,n,l)\\n\\t\\t\\t\\t\\n        l = [0]\\n        return helper(0,\"\",l)\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 2467138,
                "title": "python-solution-with-some-comments",
                "content": "Inspired by [simkieu\\'s solution](https://leetcode.com/problems/decode-string/discuss/87662/Python-solution-using-stack). I just added some comments to make it clear:\\n\\nWe have to understand the meaning of \\'[\\' and \\']\\'.\\nEvery time we see a **number** followed by a **\\'[\\'**, we are going to repeat the string in the bracket. The bracket is going to create a lower level.\\n\\nThere are 4 cases:\\n1. **digit**: keep reading until we get a \\'[\\'.\\n\\n2. **\\'[\\'**: the start of a lower level.\\n\\n    push the current number and string to stack, set num=0 and string=\\'\\'\\n\\n3. **\\']\\'**: the end of a lower level. \\n    \\n    Multiply the string in this level by the number before \\'[\\', then append it to the previous string in the upper level.\\n\\n4. **letter**: add to string, there is nothing else to do.\\n\\nI made a simple diagram showing different levels of strings.\\n![image](https://assets.leetcode.com/users/images/698de091-8d25-420e-bff5-3c73e910a9a4_1661235013.145312.png)\\n\\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack=[]\\n        num=0\\n        string=\\'\\'\\n        for x in s:\\n            ordx=ord(x)\\n            if ordx>=ord(\\'a\\') and ordx<=ord(\\'z\\'): # is a letter\\n                string+=x # append it to the current level string\\n            elif ordx>=ord(\\'0\\') and ordx<=ord(\\'9\\'): # is a number\\n                num=num*10+int(x) # append it to the current level number\\n            elif x==\\'[\\':\\n                # start a lower level, push string and num to stack\\n                stack.append(string)\\n                stack.append(num)\\n                # reset \\n                num=0\\n                string=\\'\\'\\n            else: # \\']\\', end of a lower level\\n                lower_level_string=string*stack.pop() # decode this bracket\\n                string=stack.pop()+lower_level_string # append the decoded bracket to string before the bracket, which is of upper level\\n        return string\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack=[]\\n        num=0\\n        string=\\'\\'\\n        for x in s:\\n            ordx=ord(x)\\n            if ordx>=ord(\\'a\\') and ordx<=ord(\\'z\\'): # is a letter\\n                string+=x # append it to the current level string\\n            elif ordx>=ord(\\'0\\') and ordx<=ord(\\'9\\'): # is a number\\n                num=num*10+int(x) # append it to the current level number\\n            elif x==\\'[\\':\\n                # start a lower level, push string and num to stack\\n                stack.append(string)\\n                stack.append(num)\\n                # reset \\n                num=0\\n                string=\\'\\'\\n            else: # \\']\\', end of a lower level\\n                lower_level_string=string*stack.pop() # decode this bracket\\n                string=stack.pop()+lower_level_string # append the decoded bracket to string before the bracket, which is of upper level\\n        return string\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346290,
                "title": "easy-c-solution-stack-string",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char> st;\\n        \\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]!=\\']\\')\\n                st.push(s[i]);\\n            else{\\n                string str = \"\";\\n        \\n                while(st.top() != \\'[\\'){\\n                    str =st.top()+str;\\n                    st.pop();\\n                }\\n                st.pop();\\n                \\n                string number = \"\";\\n                while(!st.empty() && isdigit(st.top())){\\n                    number = st.top() + number;\\n                    st.pop();\\n                }\\n                int freq=stoi(number);\\n                \\n                while(freq--)\\n                    for(int j=0; j<str.length() ; j++)\\n                        st.push(str[j]);\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans = st.top() + ans;\\n            st.pop();\\n        }\\n                \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char> st;\\n        \\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]!=\\']\\')\\n                st.push(s[i]);\\n            else{\\n                string str = \"\";\\n        \\n                while(st.top() != \\'[\\'){\\n                    str =st.top()+str;\\n                    st.pop();\\n                }\\n                st.pop();\\n                \\n                string number = \"\";\\n                while(!st.empty() && isdigit(st.top())){\\n                    number = st.top() + number;\\n                    st.pop();\\n                }\\n                int freq=stoi(number);\\n                \\n                while(freq--)\\n                    for(int j=0; j<str.length() ; j++)\\n                        st.push(str[j]);\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans = st.top() + ans;\\n            st.pop();\\n        }\\n                \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170142,
                "title": "cpp-solution-0ms-100-faster-recursive-solution",
                "content": "__Thank you for checking my Solution,\\nDo Upvote, if it helped :)__\\n\\n__Lets Take an example first and see its solution\\ns = 2[ab]2[d3[a2[c]]]__\\n![image](https://assets.leetcode.com/users/images/047f146c-1938-4bec-9ca2-795e705d245c_1655635970.822745.jpeg)\\n![image](https://assets.leetcode.com/users/images/2d37b4f9-30e5-4c8c-8548-45d066c69a6a_1655635982.9163513.jpeg)\\n![image](https://assets.leetcode.com/users/images/0b4c4ff3-82a1-4bd3-a616-3b37139c3199_1655635999.5368323.jpeg)\\n![image](https://assets.leetcode.com/users/images/a772021a-67a0-4fab-bf0c-b04d6fc16f7c_1655636006.9801486.jpeg)\\n\\n\\n__So as per the images, arrows represent returning a control, therefore we will recursion to solve this problem.\\nThe Idea is to add all the sets of independent brackets\\nFor every call, our current result is an empty string, we advance in the string and perform the following tasks__\\n>__If the current character is an opening bracket, we hold our current result and recursively check for any nested brackets__\\n>>__To solve the current pair of brackets, we have to ensure all the brackets inside it are solved!!\\n>>After A recursive call is finished, we set the multiplier (integer that tells us how many times our string will be repeated) to 0\\n>>We take the control to the next index which has to been traversed yet,__\\n>>>__Take an array and initialise all values to 0\\n>>>Whenever an index is encountered, set it to 1 in the array.\\n>>>0 ---> Untraversed, 1 ---> Traversed\\n>>>Therefore we take the control to the next index with value 0__\\n>>>\\n>__If current character is a letter, we add it to our current result and continue to advance  in the input string\\n>If the current character is an closing bracket,__\\n>> __We repeat our current result, multiplier times, and store it in a temporary string\\n>> We return the temporary string, this operation ends one set of brackets__\\n>> \\n>__Otherwise the current character is a digit,__ \\n>> __It will give us the multiplier, so we will store it in another variable\\n>> This will help us to pass on the multiplier to another recursive call, if needed, after converting it into integer__\\n>> \\n__Finally we will return the Current Result__\\n____\\n__Below is the C++ code for the above mentioned approach__\\n\\n\\n```\\nclass Solution\\n{ // Runtime: 0 ms, faster than 100.00% of C++ online submissions for Decode String.\\n  // Memory Usage: 6.4 MB, less than 78.36% of C++ online submissions for Decode String.\\npublic:\\n    int l, br = 0;\\n    // Since string length can at worst be 30, create an array of length 30 to track the indices that have been traversed\\n    int v[30]; \\n\\n    string get_it(string s, int index, int mul) //(Original String, index to start with, multiplier)\\n    {\\n        //Res to store immidiate results, \\n        //result_so_far to get the result so far, \\n        //num to get the multiplier\\n        string res = \"\", result_so_far = \"\", num = \"\";       \\n        int b = 0, i = index;\\n        while(i < l)\\n        {\\n            //Mark the index as traversed\\n            v[i] = 1;\\n            //If there is an opening\\n            if (s[i] == \\'[\\')                        \\n            {\\n                //For Every beginning, make a recursive call, as there might be nested Coded Strings like 3[a2[c]]\\n                //Store the result of the recursive call in result_so_far\\n                result_so_far += get_it(s, i + 1, stoi(num));\\n                //Set num as \"\", empty!\\n                num = \"\";\\n                //Take i to the next untraversed index\\n                while (v[i] != 0)\\n                    i++;\\n            }\\n            //If there is an alphabet, add it to result_so_far\\n            else if (isalpha(s[i]))\\n            {\\n                result_so_far += s[i++];\\n            }\\n            //If its a closing bracket\\n            else if (s[i] == \\']\\')\\n            {\\n                //Time to add the strings, m times,\\n                //This step is responsible for decoding(building up) the string\\n                for (int i = 1; i <= mul; i++)\\n                    res += result_so_far;       //Immediate immresult\\n                return res;\\n            }\\n            //Otherwise the current character is a part of multiplier, i.e. number\\n            else\\n                num += s[i++];\\n        }   \\n        return result_so_far;\\n    }\\n    string decodeString(string s)\\n    {\\n        l = s.size();\\n        //Set the l(size) places in the array v, as 0, stating all are untraversed\\n        for (int i = 0; i < l; i++)  \\n            v[i] = 0;\\n        \\n        return get_it(s, 0, 1);\\n    }\\n};\\n```\\n__Time Complexity : O(N), N = Length of the String\\nSpace Complexity : O(N), Since recursion uses a stack to process the info__",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{ // Runtime: 0 ms, faster than 100.00% of C++ online submissions for Decode String.\\n  // Memory Usage: 6.4 MB, less than 78.36% of C++ online submissions for Decode String.\\npublic:\\n    int l, br = 0;\\n    // Since string length can at worst be 30, create an array of length 30 to track the indices that have been traversed\\n    int v[30]; \\n\\n    string get_it(string s, int index, int mul) //(Original String, index to start with, multiplier)\\n    {\\n        //Res to store immidiate results, \\n        //result_so_far to get the result so far, \\n        //num to get the multiplier\\n        string res = \"\", result_so_far = \"\", num = \"\";       \\n        int b = 0, i = index;\\n        while(i < l)\\n        {\\n            //Mark the index as traversed\\n            v[i] = 1;\\n            //If there is an opening\\n            if (s[i] == \\'[\\')                        \\n            {\\n                //For Every beginning, make a recursive call, as there might be nested Coded Strings like 3[a2[c]]\\n                //Store the result of the recursive call in result_so_far\\n                result_so_far += get_it(s, i + 1, stoi(num));\\n                //Set num as \"\", empty!\\n                num = \"\";\\n                //Take i to the next untraversed index\\n                while (v[i] != 0)\\n                    i++;\\n            }\\n            //If there is an alphabet, add it to result_so_far\\n            else if (isalpha(s[i]))\\n            {\\n                result_so_far += s[i++];\\n            }\\n            //If its a closing bracket\\n            else if (s[i] == \\']\\')\\n            {\\n                //Time to add the strings, m times,\\n                //This step is responsible for decoding(building up) the string\\n                for (int i = 1; i <= mul; i++)\\n                    res += result_so_far;       //Immediate immresult\\n                return res;\\n            }\\n            //Otherwise the current character is a part of multiplier, i.e. number\\n            else\\n                num += s[i++];\\n        }   \\n        return result_so_far;\\n    }\\n    string decodeString(string s)\\n    {\\n        l = s.size();\\n        //Set the l(size) places in the array v, as 0, stating all are untraversed\\n        for (int i = 0; i < l; i++)  \\n            v[i] = 0;\\n        \\n        return get_it(s, 0, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155077,
                "title": "c-not-recursive-easy-runtime-0-ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        for(int i=s.length()-1; i>=0; i--){\\n            if(s[i]==\\']\\'){  st.push(\"]\");   }\\n            else if(s[i]==\\'[\\'){\\n                string tm=\"\";\\n                while(!st.empty() and st.top()!=\"]\"){\\n                    tm+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();i--;\\n                int g=1, x=0;\\n                while(i>=0){\\n                    if(!isdigit(s[i])){break;}\\n                    int xy = (s[i]-\\'0\\');\\n                    x+=(xy*g);\\n                    i--; g=g*10;\\n                }\\n                i++;\\n                string ans=\"\";\\n                while(x--){\\n                    ans+=tm;\\n                }\\n                st.push(ans);\\n            }\\n            else{\\n                string tm = \"\";\\n                tm+=s[i];\\n                st.push(tm);\\n            }\\n        }\\n        string as = \"\";\\n        while(!st.empty()){\\n            as+=st.top();\\n            st.pop();\\n        }\\n        return as;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/03bd9cbc-cc01-462f-a512-c1b2d0046eb7_1655300255.1603012.png)\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        for(int i=s.length()-1; i>=0; i--){\\n            if(s[i]==\\']\\'){  st.push(\"]\");   }\\n            else if(s[i]==\\'[\\'){\\n                string tm=\"\";\\n                while(!st.empty() and st.top()!=\"]\"){\\n                    tm+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();i--;\\n                int g=1, x=0;\\n                while(i>=0){\\n                    if(!isdigit(s[i])){break;}\\n                    int xy = (s[i]-\\'0\\');\\n                    x+=(xy*g);\\n                    i--; g=g*10;\\n                }\\n                i++;\\n                string ans=\"\";\\n                while(x--){\\n                    ans+=tm;\\n                }\\n                st.push(ans);\\n            }\\n            else{\\n                string tm = \"\";\\n                tm+=s[i];\\n                st.push(tm);\\n            }\\n        }\\n        string as = \"\";\\n        while(!st.empty()){\\n            as+=st.top();\\n            st.pop();\\n        }\\n        return as;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658532,
                "title": "naive-to-efficient-3-approaches-iterative-recursive-c",
                "content": "Implementation\\n\\n**1st\\nNaive Approach\\nUsing 2 stacks\\nTime Complexity = O(N), Space Complexity = O(N)**\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<int> intSt;   // int stack\\n        stack<string> strSt;    // string stack\\n        string res = \"\";\\n        int itr = 0;\\n        while(itr < s.size()){\\n            if(isdigit(s[itr])){\\n                int num = 0;\\n                while(isdigit(s[itr])){\\n                    num = num * 10 + s[itr++] - \\'0\\';\\n                }\\n                intSt.push(num);\\n            }\\n            else if(s[itr] == \\']\\'){\\n                int times = intSt.top();\\n                intSt.pop();\\n                \\n                string str = strSt.top();\\n                strSt.pop();\\n                \\n                for(int itr = 1; itr <= times; itr++){\\n                    str += res;\\n                }\\n                \\n                res = str;\\n                itr++;\\n            }\\n            else if(s[itr] == \\'[\\'){\\n                strSt.push(res);\\n                res = \"\";\\n                itr++;\\n            }\\n            else{\\n                res += s[itr];\\n                itr++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n\\n\\n**2nd\\nEfficient Approach\\nUsing 1 stack\\nTime Complexity = O(N), Space Complexity = O(N)**\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char> st;   // char stack        \\n        for(int itr = 0; itr < s.size(); itr++){\\n            if(s[itr] == \\']\\'){\\n                string str = \"\";\\n                while(st.top() != \\'[\\'){\\n                    str = st.top() + str;\\n                    st.pop();\\n                }                \\n                st.pop();\\n                \\n                string times = \"\";\\n                while(!st.empty() && isdigit(st.top())){\\n                    times = st.top() + times;\\n                    st.pop();\\n                }\\n                \\n                int count = stoi(times);\\n                \\n                while(count--){\\n                    for(int jtr = 0; jtr < str.size(); jtr++){\\n                        st.push(str[jtr]);\\n                    }\\n                }\\n            }\\n            else{\\n                st.push(s[itr]);\\n            }\\n        }\\n        \\n        string res = \"\";\\n        while(!st.empty()){\\n            res += st.top();\\n            st.pop();\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\\n\\n\\n\\n**3rd\\nEfficient\\nRecursive Approach\\nTime Complexity = O(N), Space Complexity = O(N), considering the resursion stack**\\n```\\nclass Solution {\\npublic:\\n    string decodeTheString(string s, int &itr){\\n        string res = \"\";\\n        \\n        while(itr < s.size() && s[itr] != \\']\\'){\\n            if(isdigit(s[itr])){\\n                int num = 0;\\n                while(itr < s.size() && isdigit(s[itr])){\\n                    num = num * 10 + (s[itr++] - \\'0\\');\\n                }\\n                // to escape the \\'[\\'\\n                itr++;\\n                \\n                // store the return result and repeat it num times\\n                string temp = decodeTheString(s, itr);\\n                \\n                // to escape the \\']\\'\\n                itr++;\\n                \\n                while(num--){\\n                    res += temp;\\n                }\\n            }\\n            else{\\n                res += s[itr++];\\n            }\\n        }\\n        \\n        return res;    \\n    }\\n    \\n    string decodeString(string s) {\\n        int itr = 0;\\n        return decodeTheString(s, itr);\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<int> intSt;   // int stack\\n        stack<string> strSt;    // string stack\\n        string res = \"\";\\n        int itr = 0;\\n        while(itr < s.size()){\\n            if(isdigit(s[itr])){\\n                int num = 0;\\n                while(isdigit(s[itr])){\\n                    num = num * 10 + s[itr++] - \\'0\\';\\n                }\\n                intSt.push(num);\\n            }\\n            else if(s[itr] == \\']\\'){\\n                int times = intSt.top();\\n                intSt.pop();\\n                \\n                string str = strSt.top();\\n                strSt.pop();\\n                \\n                for(int itr = 1; itr <= times; itr++){\\n                    str += res;\\n                }\\n                \\n                res = str;\\n                itr++;\\n            }\\n            else if(s[itr] == \\'[\\'){\\n                strSt.push(res);\\n                res = \"\";\\n                itr++;\\n            }\\n            else{\\n                res += s[itr];\\n                itr++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char> st;   // char stack        \\n        for(int itr = 0; itr < s.size(); itr++){\\n            if(s[itr] == \\']\\'){\\n                string str = \"\";\\n                while(st.top() != \\'[\\'){\\n                    str = st.top() + str;\\n                    st.pop();\\n                }                \\n                st.pop();\\n                \\n                string times = \"\";\\n                while(!st.empty() && isdigit(st.top())){\\n                    times = st.top() + times;\\n                    st.pop();\\n                }\\n                \\n                int count = stoi(times);\\n                \\n                while(count--){\\n                    for(int jtr = 0; jtr < str.size(); jtr++){\\n                        st.push(str[jtr]);\\n                    }\\n                }\\n            }\\n            else{\\n                st.push(s[itr]);\\n            }\\n        }\\n        \\n        string res = \"\";\\n        while(!st.empty()){\\n            res += st.top();\\n            st.pop();\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string decodeTheString(string s, int &itr){\\n        string res = \"\";\\n        \\n        while(itr < s.size() && s[itr] != \\']\\'){\\n            if(isdigit(s[itr])){\\n                int num = 0;\\n                while(itr < s.size() && isdigit(s[itr])){\\n                    num = num * 10 + (s[itr++] - \\'0\\');\\n                }\\n                // to escape the \\'[\\'\\n                itr++;\\n                \\n                // store the return result and repeat it num times\\n                string temp = decodeTheString(s, itr);\\n                \\n                // to escape the \\']\\'\\n                itr++;\\n                \\n                while(num--){\\n                    res += temp;\\n                }\\n            }\\n            else{\\n                res += s[itr++];\\n            }\\n        }\\n        \\n        return res;    \\n    }\\n    \\n    string decodeString(string s) {\\n        int itr = 0;\\n        return decodeTheString(s, itr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638379,
                "title": "very-easy-python-stack-o-n-96-faster",
                "content": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n                \\n        st = []\\n        \\n        for c in s:\\n\\n            if c != \\']\\':\\n                st.append(c)\\n            else:\\n\\t\\t\\t\\t# join the string inside the 1st balanced brackets\\n                tmp = \"\"\\n                while st and st[-1] != \\'[\\':                                        \\n                    tmp = st.pop() + tmp\\n                \\n\\t\\t\\t\\t# pop out the opening `[`\\n                st.pop()\\n                num = \"\"\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# calculate the multiplier\\n                while st and st[-1].isdigit():\\n                    num = st.pop() + num\\n                    \\n                # add the multiplied string back to the stack\\n                st.append(int(num)*tmp)\\n        \\n        return \\'\\'.join(st)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n                \\n        st = []\\n        \\n        for c in s:\\n\\n            if c != \\']\\':\\n                st.append(c)\\n            else:\\n\\t\\t\\t\\t# join the string inside the 1st balanced brackets\\n                tmp = \"\"\\n                while st and st[-1] != \\'[\\':                                        \\n                    tmp = st.pop() + tmp\\n                \\n\\t\\t\\t\\t# pop out the opening `[`\\n                st.pop()\\n                num = \"\"\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# calculate the multiplier\\n                while st and st[-1].isdigit():\\n                    num = st.pop() + num\\n                    \\n                # add the multiplied string back to the stack\\n                st.append(int(num)*tmp)\\n        \\n        return \\'\\'.join(st)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635795,
                "title": "iterative-stack-0ms-100-faster",
                "content": "**Idea?**\\n* Maintain a **stack of strings**.\\n* Whenever we encounter a closing square bracket, we will pick up the string in between this bracket and **duplicate it k time**s.\\n* How do we perform the operations efficiently using stack?\\n* **Hint:- Work on every character of the input string**.\\n* Check detailed commented code\\n\\n```\\nclass Solution {\\npublic: \\n    string decodeString(string s) {\\n        stack<string> st; // stack to maintain string of characters\\n        for(auto& c:s){\\n            if(c==\\']\\'){ //  we need to duplicate the strings between the brackets\\n                string temp = \"\",curr = \"\"; // temp finally stores all the strings between the brackets\\n                while(!st.empty() and st.top()!=\"[\"){\\n                    reverse(st.top().begin(),st.top().end());\\n                    temp += st.top(); // temp picks up each string from stack\\n                    st.pop();\\n                }\\n                st.pop(); // pop the opening bracket\\n                string times = \"\"; // stores the string representation of number of times we need to duplicate\\n                while(!st.empty() and st.top()>=\"0\" and st.top()<=\"9\"){\\n                    times += st.top();\\n                    st.pop();\\n                }\\n                reverse(times.begin(),times.end());\\n                reverse(temp.begin(),temp.end());\\n                int k = stoi(times); // k = number of times we need to duplicate\\n                while(k--)\\n                    curr += temp;\\n                // curr stores the duplicated string\\n                // push string back into stack\\n                if(!st.empty() and st.top()!=\"[\")\\n                    st.top() += curr;  \\n                else\\n                    st.push(curr);\\n            }\\n            else{\\n                string curr = \"\";\\n                curr.push_back(c);\\n                st.push(curr); // push the string representation of the character into the stack\\n            }\\n        }\\n        string ans = \"\"; // stores the final answer\\n        while(!st.empty()){\\n            reverse(st.top().begin(),st.top().end());\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    \\n    /* If you\\'re getting WA, try this test case:- \"3[z]2[2[y]pq4[2[jk]e1[f]]]ef\"\\n       Correct Output:- \"zzzyypqjkjkefjkjkefjkjkefjkjkefyypqjkjkefjkjkefjkjkefjkjkefef\" */\\n};\\n```\\n**Don\\'t Forget to Upvote!**\\n\\n![image](https://assets.leetcode.com/users/images/e5fbff28-d72c-4cb7-85ae-93793f21fe60_1639908248.8918557.png)\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    string decodeString(string s) {\\n        stack<string> st; // stack to maintain string of characters\\n        for(auto& c:s){\\n            if(c==\\']\\'){ //  we need to duplicate the strings between the brackets\\n                string temp = \"\",curr = \"\"; // temp finally stores all the strings between the brackets\\n                while(!st.empty() and st.top()!=\"[\"){\\n                    reverse(st.top().begin(),st.top().end());\\n                    temp += st.top(); // temp picks up each string from stack\\n                    st.pop();\\n                }\\n                st.pop(); // pop the opening bracket\\n                string times = \"\"; // stores the string representation of number of times we need to duplicate\\n                while(!st.empty() and st.top()>=\"0\" and st.top()<=\"9\"){\\n                    times += st.top();\\n                    st.pop();\\n                }\\n                reverse(times.begin(),times.end());\\n                reverse(temp.begin(),temp.end());\\n                int k = stoi(times); // k = number of times we need to duplicate\\n                while(k--)\\n                    curr += temp;\\n                // curr stores the duplicated string\\n                // push string back into stack\\n                if(!st.empty() and st.top()!=\"[\")\\n                    st.top() += curr;  \\n                else\\n                    st.push(curr);\\n            }\\n            else{\\n                string curr = \"\";\\n                curr.push_back(c);\\n                st.push(curr); // push the string representation of the character into the stack\\n            }\\n        }\\n        string ans = \"\"; // stores the final answer\\n        while(!st.empty()){\\n            reverse(st.top().begin(),st.top().end());\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    \\n    /* If you\\'re getting WA, try this test case:- \"3[z]2[2[y]pq4[2[jk]e1[f]]]ef\"\\n       Correct Output:- \"zzzyypqjkjkefjkjkefjkjkefjkjkefyypqjkjkefjkjkefjkjkefjkjkefef\" */\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442416,
                "title": "easy-python-stack-solution-runtime-99-91-memory-usage-99",
                "content": "**Using Stack.**\\n\\n```\\ndef decodeString(self, s: str) -> str:\\n        stack = []\\n        \\n        for ch in s:\\n\\t\\t\\n\\t\\t\\t# whenever a closing bracket arrives in s.\\n            if ch == \"]\":\\n                value  = \"\" # set value to default\\n\\t\\t\\t\\t\\n                #store each character from stack in reverse order.\\n                while stack and stack[-1] != \"[\":\\n                    value = stack.pop() + value\\n                # for example: If stack contains [3, [, c, 12, [, a, b]. Loop will continue till \"[\" and value will store \"ab\".\\n\\t\\t\\t\\t\\n                stack.pop() # Removing Opening Bracket \"[\" from stack.\\n                value *= int(stack.pop()) # Multiplying string to number stored after \"[\" that is 12.\\n                stack.append(value) # Now append the result again in stack for further brackets.\\n                \\n            else:\\n                if ch.isdigit() and stack and stack[-1].isdigit(): \\n\\t\\t\\t\\t\\t# If a number already inserted in stack[-1]. For eg. [3, [, c, 1]\\n                    stack[-1] += ch \\n\\t\\t\\t\\t\\t# now stack becomes [3, [, c, 12]. if ch is 2 this time.\\n                else:\\n\\t\\t\\t\\t\\t# for character other then a number\\n                    stack.append(ch)\\n        \\n        return \"\".join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\ndef decodeString(self, s: str) -> str:\\n        stack = []\\n        \\n        for ch in s:\\n\\t\\t\\n\\t\\t\\t# whenever a closing bracket arrives in s.\\n            if ch == \"]\":\\n                value  = \"\" # set value to default\\n\\t\\t\\t\\t\\n                #store each character from stack in reverse order.\\n                while stack and stack[-1] != \"[\":\\n                    value = stack.pop() + value\\n                # for example: If stack contains [3, [, c, 12, [, a, b]. Loop will continue till \"[\" and value will store \"ab\".\\n\\t\\t\\t\\t\\n                stack.pop() # Removing Opening Bracket \"[\" from stack.\\n                value *= int(stack.pop()) # Multiplying string to number stored after \"[\" that is 12.\\n                stack.append(value) # Now append the result again in stack for further brackets.\\n                \\n            else:\\n                if ch.isdigit() and stack and stack[-1].isdigit(): \\n\\t\\t\\t\\t\\t# If a number already inserted in stack[-1]. For eg. [3, [, c, 1]\\n                    stack[-1] += ch \\n\\t\\t\\t\\t\\t# now stack becomes [3, [, c, 12]. if ch is 2 this time.\\n                else:\\n\\t\\t\\t\\t\\t# for character other then a number\\n                    stack.append(ch)\\n        \\n        return \"\".join(stack)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1357323,
                "title": "c-100-faster-comments-full-explanation",
                "content": "// I am just going to follow what is written in the question, this is just an implementation question, let me explpain you how \\n// 5 Steps for smooth solution with use of stack\\n// 1 when input is other than \\']\\', it basically means we have to input, because till now we donot know what should be the substring that needed to be multiplied, so we just keep in inputing the characters \\n// 2 when we hit \\']\\' then we pop character untill we get \\'[\\' because it opening of the string naa so we get our required string(Implementation is shown below)\\n// 3 now pop for the number of time it needed to be added again \\n// 4 then just add string, the required number of time\\n// 5 At last just pop from it, reverse and return the string \\n\\n// Implementation with steps marked are given in the code \\n// Hope it helps \\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char>st;\\n        string ans = \"\";\\n        for(int i=0;i<s.size();i++){\\n            // Step1 \\n            if(s[i]!=\\']\\'){\\n                st.push(s[i]);\\n            }else{\\n                // Step2\\n                string temp = \"\";\\n                while(st.top()!=\\'[\\'){\\n                    temp += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                // Step3\\n                string num = \"\";\\n                while(!st.empty() && st.top()>=\\'0\\' && st.top()<=\\'9\\'){\\n                    num += st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                int n = stoi(num);\\n                // Step4\\n                for(int k=0;k<n;k++){\\n                    for(int j=temp.size()-1;j>=0;j--){\\n                        st.push(temp[j]);\\n                    }\\n                }\\n            }\\n        }\\n        // Step5 \\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char>st;\\n        string ans = \"\";\\n        for(int i=0;i<s.size();i++){\\n            // Step1 \\n            if(s[i]!=\\']\\'){\\n                st.push(s[i]);\\n            }else{\\n                // Step2\\n                string temp = \"\";\\n                while(st.top()!=\\'[\\'){\\n                    temp += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                // Step3\\n                string num = \"\";\\n                while(!st.empty() && st.top()>=\\'0\\' && st.top()<=\\'9\\'){\\n                    num += st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                int n = stoi(num);\\n                // Step4\\n                for(int k=0;k<n;k++){\\n                    for(int j=temp.size()-1;j>=0;j--){\\n                        st.push(temp[j]);\\n                    }\\n                }\\n            }\\n        }\\n        // Step5 \\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016302,
                "title": "using-queue-and-dfs",
                "content": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Queue<Character> queue = new ArrayDeque<>();\\n        \\n        for(char c : s.toCharArray()) {\\n            queue.offer(c);\\n        }\\n        \\n        return dfs(queue);\\n    }\\n    \\n    public String dfs(Queue<Character> queue) {\\n        int num = 0;\\n        StringBuilder builder = new StringBuilder();\\n        \\n        while(!queue.isEmpty()) {\\n            char c = queue.poll();\\n            \\n            if(\\'0\\' <= c && c <= \\'9\\') {\\n                num = num * 10 + (c-\\'0\\');\\n            } else if( c ==\\'[\\'){\\n                builder.append(dfs(queue).repeat(num));\\n                num = 0;\\n            } else {\\n                if( \\'a\\' <= c && c <= \\'z\\') {\\n                    builder.append(c);\\n                }\\n                \\n                if(c == \\']\\') {\\n                    break;\\n                }\\n            }\\n        }\\n        return builder.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Queue<Character> queue = new ArrayDeque<>();\\n        \\n        for(char c : s.toCharArray()) {\\n            queue.offer(c);\\n        }\\n        \\n        return dfs(queue);\\n    }\\n    \\n    public String dfs(Queue<Character> queue) {\\n        int num = 0;\\n        StringBuilder builder = new StringBuilder();\\n        \\n        while(!queue.isEmpty()) {\\n            char c = queue.poll();\\n            \\n            if(\\'0\\' <= c && c <= \\'9\\') {\\n                num = num * 10 + (c-\\'0\\');\\n            } else if( c ==\\'[\\'){\\n                builder.append(dfs(queue).repeat(num));\\n                num = 0;\\n            } else {\\n                if( \\'a\\' <= c && c <= \\'z\\') {\\n                    builder.append(c);\\n                }\\n                \\n                if(c == \\']\\') {\\n                    break;\\n                }\\n            }\\n        }\\n        return builder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 942487,
                "title": "c-o-n-two-pass-beats-98",
                "content": "### Idea overview\\n1. In the first pass ony create a map of opening - closing brackets (using simple stack method)\\n2. In the second pass use above information for each opening bracket index and call a helper method with respective indexes\\n\\nRuntime: 76 ms, faster than 98.03% of C# online submissions for Decode String.\\nMemory Usage: 23.4 MB, less than 34.83% of C# online submissions for Decode String.\\n```\\npublic class Solution\\n{\\n\\tint[] brackets = new int[30];\\n\\tpublic string DecodeString(string s)\\n\\t{\\n\\t\\tStack<int> stack = new Stack<int>();\\n\\t\\tfor(int i=0; i<s.Length; i++)\\n\\t\\t{\\n\\t\\t\\tvar c = s[i];\\n\\t\\t\\tif(c == \\'[\\')\\n\\t\\t\\t\\tstack.Push(i);\\n\\t\\t\\telse if (c == \\']\\')\\n\\t\\t\\t\\tbrackets[stack.Pop()] = i;\\n\\t\\t}\\n\\n\\t\\treturn Helper(s, 0, s.Length - 1);\\n\\t}\\n\\n\\tprivate string Helper(string s, int start, int end)\\n\\t{\\n\\t\\tstring res = \"\";\\n\\t\\twhile(start <= end)\\n\\t\\t{\\n\\t\\t\\tvar c = s[start++];\\n\\t\\t\\tif(Char.IsLetter(c))\\n\\t\\t\\t\\tres += c;\\n\\t\\t\\telse if(Char.IsDigit(c))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint num = int.Parse(c.ToString());\\n\\t\\t\\t\\twhile(s[start] != \\'[\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint n;\\n\\t\\t\\t\\t\\tif(int.TryParse(s[start++].ToString(), out n))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnum *= 10;\\n\\t\\t\\t\\t\\t\\tnum += n;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar inner = Helper(s, start + 1, brackets[start] - 1);\\n\\t\\t\\t\\tfor(int i=0; i<num; i++)\\n\\t\\t\\t\\t\\tres += inner;\\n\\t\\t\\t\\tstart = brackets[start] + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n\\tint[] brackets = new int[30];\\n\\tpublic string DecodeString(string s)\\n\\t{\\n\\t\\tStack<int> stack = new Stack<int>();\\n\\t\\tfor(int i=0; i<s.Length; i++)\\n\\t\\t{\\n\\t\\t\\tvar c = s[i];\\n\\t\\t\\tif(c == \\'[\\')\\n\\t\\t\\t\\tstack.Push(i);\\n\\t\\t\\telse if (c == \\']\\')\\n\\t\\t\\t\\tbrackets[stack.Pop()] = i;\\n\\t\\t}\\n\\n\\t\\treturn Helper(s, 0, s.Length - 1);\\n\\t}\\n\\n\\tprivate string Helper(string s, int start, int end)\\n\\t{\\n\\t\\tstring res = \"\";\\n\\t\\twhile(start <= end)\\n\\t\\t{\\n\\t\\t\\tvar c = s[start++];\\n\\t\\t\\tif(Char.IsLetter(c))\\n\\t\\t\\t\\tres += c;\\n\\t\\t\\telse if(Char.IsDigit(c))\\n\\t\\t\\t{\\n\\t\\t\\t\\tint num = int.Parse(c.ToString());\\n\\t\\t\\t\\twhile(s[start] != \\'[\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint n;\\n\\t\\t\\t\\t\\tif(int.TryParse(s[start++].ToString(), out n))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnum *= 10;\\n\\t\\t\\t\\t\\t\\tnum += n;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar inner = Helper(s, start + 1, brackets[start] - 1);\\n\\t\\t\\t\\tfor(int i=0; i<num; i++)\\n\\t\\t\\t\\t\\tres += inner;\\n\\t\\t\\t\\tstart = brackets[start] + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941590,
                "title": "python3-easy-solution-faster-than-90",
                "content": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        index=s.find(\"]\")\\n        char=\"\"\\n        digit=\"\"\\n        while index!=-1:\\n            print(index)\\n            for i in range(index-1,0,-1):\\n                if s[i]==\"[\":\\n                    for j in range(i-1,-1,-1):\\n                        if s[j].isdigit():\\n                            digit+=s[j]\\n                        else:\\n                            break  \\n                    s=s.replace(f\"{digit[::-1]}[{char[::-1]}]\",int(digit[::-1])*char[::-1],1)\\n                    break\\n                char+=s[i]\\n            char=\"\"\\n            digit=\"\"\\n            index=s.find(\"]\")\\n        return s\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        index=s.find(\"]\")\\n        char=\"\"\\n        digit=\"\"\\n        while index!=-1:\\n            print(index)\\n            for i in range(index-1,0,-1):\\n                if s[i]==\"[\":\\n                    for j in range(i-1,-1,-1):\\n                        if s[j].isdigit():\\n                            digit+=s[j]\\n                        else:\\n                            break  \\n                    s=s.replace(f\"{digit[::-1]}[{char[::-1]}]\",int(digit[::-1])*char[::-1],1)\\n                    break\\n                char+=s[i]\\n            char=\"\"\\n            digit=\"\"\\n            index=s.find(\"]\")\\n        return s\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 941467,
                "title": "pure-recursion-direct-translation-of-recurrence-relation",
                "content": "```\\n\"\"\"\\n## Base Cases\\nF(None) = \"\"\\nF(alpha_str) = alpha_str\\n\\n## Recurrence\\nF(alpha_str + d + [X] + Y) = alpha_str + sum_d(F(X)) + F(Y)\\n\\nNote: + = string concatenation; sum_d = sum over d\\n\"\"\"\\n\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        \\n        def F(s):\\n            ### Base Cases\\n            ## F(None) & F(alpha_str)\\n            if not s or s.isalpha(): return s             \\n            \\n            ### Recurrence \\n            ## F(alpha_str + d + [X] + Y) = alpha_str + sum_d(F(X)) + F(Y)\\n            \\n            ## alpha_str\\n            alpha_str = \"\"; i = 0\\n            while s[i].isalpha():\\n                alpha_str += s[i]\\n                i += 1\\n        \\n            ## d\\n            d = \"\"\\n            while s[i].isdigit():\\n                d += s[i]\\n                i += 1\\n            d = int(d)\\n            \\n            ## X\\n            j = i + 1; X = \"\"; open_brackets = 1\\n            while open_brackets != 0:\\n                if   s[j] == \"[\": open_brackets += 1\\n                elif s[j] == \"]\": open_brackets -= 1\\n                j += 1                \\n            X = s[i+1:j-1]\\n                    \\n            ## Y\\n            Y = s[j:]\\n    \\n            ## = \\n            return alpha_str + d * F(X) + F(Y)\\n \\n        return F(s)",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n\"\"\"\\n## Base Cases\\nF(None) = \"\"\\nF(alpha_str) = alpha_str\\n\\n## Recurrence\\nF(alpha_str + d + [X] + Y) = alpha_str + sum_d(F(X)) + F(Y)\\n\\nNote: + = string concatenation; sum_d = sum over d\\n\"\"\"\\n\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        \\n        def F(s):\\n            ### Base Cases\\n            ## F(None) & F(alpha_str)\\n            if not s or s.isalpha(): return s             \\n            \\n            ### Recurrence \\n            ## F(alpha_str + d + [X] + Y) = alpha_str + sum_d(F(X)) + F(Y)\\n            \\n            ## alpha_str\\n            alpha_str = \"\"; i = 0\\n            while s[i].isalpha():\\n                alpha_str += s[i]\\n                i += 1\\n        \\n            ## d\\n            d = \"\"\\n            while s[i].isdigit():\\n                d += s[i]\\n                i += 1\\n            d = int(d)\\n            \\n            ## X\\n            j = i + 1; X = \"\"; open_brackets = 1\\n            while open_brackets != 0:\\n                if   s[j] == \"[\": open_brackets += 1\\n                elif s[j] == \"]\": open_brackets -= 1\\n                j += 1                \\n            X = s[i+1:j-1]\\n                    \\n            ## Y\\n            Y = s[j:]\\n    \\n            ## = \\n            return alpha_str + d * F(X) + F(Y)\\n \\n        return F(s)",
                "codeTag": "Java"
            },
            {
                "id": 684345,
                "title": "short-java-solution",
                "content": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> timeSt = new Stack<>();\\n        Stack<StringBuilder> builderSt = new Stack<>();     \\n        int times = 0;\\n        builderSt.push(new StringBuilder());\\n        for(int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if(ch == \\'[\\') {\\n                builderSt.push(new StringBuilder());\\n                timeSt.push(times);\\n                times = 0;\\n            } else if(ch == \\']\\') {\\n                String str = builderSt.pop().toString(); \\n                int time = timeSt.pop();\\n                StringBuilder builder = builderSt.peek();\\n                for(int j = 0; j < time; j++) builder.append(str);\\n            } else if(ch - \\'0\\' >= 0 && ch - \\'0\\' <= 9) {\\n                times = times * 10 + (ch - \\'0\\');\\n            } else {\\n                builderSt.peek().append(ch);\\n            }\\n        }\\n        \\n        return builderSt.pop().toString(); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> timeSt = new Stack<>();\\n        Stack<StringBuilder> builderSt = new Stack<>();     \\n        int times = 0;\\n        builderSt.push(new StringBuilder());\\n        for(int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if(ch == \\'[\\') {\\n                builderSt.push(new StringBuilder());\\n                timeSt.push(times);\\n                times = 0;\\n            } else if(ch == \\']\\') {\\n                String str = builderSt.pop().toString(); \\n                int time = timeSt.pop();\\n                StringBuilder builder = builderSt.peek();\\n                for(int j = 0; j < time; j++) builder.append(str);\\n            } else if(ch - \\'0\\' >= 0 && ch - \\'0\\' <= 9) {\\n                times = times * 10 + (ch - \\'0\\');\\n            } else {\\n                builderSt.peek().append(ch);\\n            }\\n        }\\n        \\n        return builderSt.pop().toString(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 596048,
                "title": "python-easy-to-follow-solution-using-stack",
                "content": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = []\\n        \\n        for i in s:\\n            if i != \\']\\':\\n                stack.append(i)\\n                continue\\n            tmp = \\'\\'\\n            while stack and stack[-1] != \\'[\\':\\n                tmp = stack.pop() + tmp\\n            stack.pop()\\n            num = \\'\\'\\n            while stack and stack[-1].isnumeric():\\n                num = stack.pop() + num\\n            stack.append(int(num)*tmp)\\n            \\n        return \\'\\'.join(stack)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = []\\n        \\n        for i in s:\\n            if i != \\']\\':\\n                stack.append(i)\\n                continue\\n            tmp = \\'\\'\\n            while stack and stack[-1] != \\'[\\':\\n                tmp = stack.pop() + tmp\\n            stack.pop()\\n            num = \\'\\'\\n            while stack and stack[-1].isnumeric():\\n                num = stack.pop() + num\\n            stack.append(int(num)*tmp)\\n            \\n        return \\'\\'.join(stack)",
                "codeTag": "Java"
            },
            {
                "id": 511060,
                "title": "java-solution-beats-100-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> numStack = new Stack<>();\\n        Stack<String> strStack = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        int n=s.length();\\n        for (int i=0; i<n; ++i){\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c)){\\n                int num = c-\\'0\\';\\n                while (i+1 < n && Character.isDigit(s.charAt(i+1))){\\n                    num = num*10 + s.charAt(i+1)-\\'0\\';\\n                    i++;\\n                }\\n                numStack.push(num);\\n            }\\n            else if (c == \\'[\\'){\\n                strStack.push(sb.toString());\\n                sb = new StringBuilder();\\n            }\\n            else if (c == \\']\\'){\\n                int repeats = numStack.pop();\\n                StringBuilder temp = new StringBuilder(strStack.pop());\\n                for (int j=0; j<repeats; ++j){\\n                    temp.append(sb);\\n                }\\n                sb = temp;\\n            }\\n            else\\n                sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> numStack = new Stack<>();\\n        Stack<String> strStack = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        int n=s.length();\\n        for (int i=0; i<n; ++i){\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c)){\\n                int num = c-\\'0\\';\\n                while (i+1 < n && Character.isDigit(s.charAt(i+1))){\\n                    num = num*10 + s.charAt(i+1)-\\'0\\';\\n                    i++;\\n                }\\n                numStack.push(num);\\n            }\\n            else if (c == \\'[\\'){\\n                strStack.push(sb.toString());\\n                sb = new StringBuilder();\\n            }\\n            else if (c == \\']\\'){\\n                int repeats = numStack.pop();\\n                StringBuilder temp = new StringBuilder(strStack.pop());\\n                for (int j=0; j<repeats; ++j){\\n                    temp.append(sb);\\n                }\\n                sb = temp;\\n            }\\n            else\\n                sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478713,
                "title": "javascript-recursive",
                "content": "Recursive is like using a stack, Its just cleaner.\\nI have no idea why the execution is 60 ms for me.\\n\\n```\\nvar decodeString = function(s) {\\n    return helper(s, \"\")\\n    \\n    function helper(s, str){\\n        let num = 0;\\n        for(let i = 0; i < s.length; i++){\\n            let x = s.substr(i, 1);\\n            \\n            if(x == \\'[\\'){\\n                let result, n;\\n                [result, n] = helper(s.substr(i+1), \"\");\\n                while(num > 0){\\n                    str += result;\\n                    num--;\\n                }\\n                i += n;\\n            }\\n            else if(x == \\']\\') return [str, ++i]\\n            \\n            else if(!isNaN(x)) num = num*10 + parseInt(x);\\n            else str += x;\\n        }\\n        return str\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar decodeString = function(s) {\\n    return helper(s, \"\")\\n    \\n    function helper(s, str){\\n        let num = 0;\\n        for(let i = 0; i < s.length; i++){\\n            let x = s.substr(i, 1);\\n            \\n            if(x == \\'[\\'){\\n                let result, n;\\n                [result, n] = helper(s.substr(i+1), \"\");\\n                while(num > 0){\\n                    str += result;\\n                    num--;\\n                }\\n                i += n;\\n            }\\n            else if(x == \\']\\') return [str, ++i]\\n            \\n            else if(!isNaN(x)) num = num*10 + parseInt(x);\\n            else str += x;\\n        }\\n        return str\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 442387,
                "title": "swift-94-100-with-explanation",
                "content": "```\\nclass Solution {\\n    func decodeString(_ s: String) -> String {\\n        guard s.count > 0 else {\\n            return \"\"\\n        }\\n        \\n        //multiplier stack record k, the number of repeating times\\n        var multiplierStack = [Int]()\\n        \\n        //prefix stack record the substrings before the bracket\\n        var prefixStack = [String]()\\n        \\n        var numberString = \"\"\\n        var subString = \"\"\\n        \\n        //if the string start with charater, treat it as 1[...]\\n        if !s.first!.isNumber {\\n            multiplierStack.append(1)\\n        }\\n\\t\\t\\n        for char in s {\\n            if char.isNumber {\\n\\t\\t\\t\\t// -- In the case char is \"number\", save it by numberString, \\n\\t\\t\\t\\t// because number can be multiple digits\\n                numberString.append(char)\\n            } else if char == \"[\" {\\n\\t\\t\\t\\t// -- In the case char is \"[\", we know we finish recoding the last \\n\\t\\t\\t\\t// digit of the Int, so we push it to stack as type of Int value, \\n\\t\\t\\t\\t// also push the subString to another stack as prefix\\n                multiplierStack.append(Int(numberString)!)\\n                prefixStack.append(subString)\\n                numberString = \"\"\\n                subString = \"\"\\n            } else if char == \"]\" {\\n\\t\\t\\t\\t // -- In the case char is \"]\", we know this is the end of a repeating\\n\\t\\t\\t\\t// case, and there are prefix and mutiplier in the stack ready to use\\n\\t\\t\\t\\t// and form the repeating chars.\\n                let multiplier = multiplierStack.removeLast()\\n                var temp = \"\"\\n                for index in 0..<multiplier {\\n                    temp.append(subString)\\n                }\\n                let prefix = prefixStack.removeLast()\\n                subString = prefix + temp\\n            } else {\\n\\t\\t\\t\\t// -- In the case char is \"character\", save it by subString\\n                subString.append(char)\\n            }\\n        }\\n        \\n        return subString\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func decodeString(_ s: String) -> String {\\n        guard s.count > 0 else {\\n            return \"\"\\n        }\\n        \\n        //multiplier stack record k, the number of repeating times\\n        var multiplierStack = [Int]()\\n        \\n        //prefix stack record the substrings before the bracket\\n        var prefixStack = [String]()\\n        \\n        var numberString = \"\"\\n        var subString = \"\"\\n        \\n        //if the string start with charater, treat it as 1[...]\\n        if !s.first!.isNumber {\\n            multiplierStack.append(1)\\n        }\\n\\t\\t\\n        for char in s {\\n            if char.isNumber {\\n\\t\\t\\t\\t// -- In the case char is \"number\", save it by numberString, \\n\\t\\t\\t\\t// because number can be multiple digits\\n                numberString.append(char)\\n            } else if char == \"[\" {\\n\\t\\t\\t\\t// -- In the case char is \"[\", we know we finish recoding the last \\n\\t\\t\\t\\t// digit of the Int, so we push it to stack as type of Int value, \\n\\t\\t\\t\\t// also push the subString to another stack as prefix\\n                multiplierStack.append(Int(numberString)!)\\n                prefixStack.append(subString)\\n                numberString = \"\"\\n                subString = \"\"\\n            } else if char == \"]\" {\\n\\t\\t\\t\\t // -- In the case char is \"]\", we know this is the end of a repeating\\n\\t\\t\\t\\t// case, and there are prefix and mutiplier in the stack ready to use\\n\\t\\t\\t\\t// and form the repeating chars.\\n                let multiplier = multiplierStack.removeLast()\\n                var temp = \"\"\\n                for index in 0..<multiplier {\\n                    temp.append(subString)\\n                }\\n                let prefix = prefixStack.removeLast()\\n                subString = prefix + temp\\n            } else {\\n\\t\\t\\t\\t// -- In the case char is \"character\", save it by subString\\n                subString.append(char)\\n            }\\n        }\\n        \\n        return subString\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400101,
                "title": "python-o-n-100-faster-with-explanation",
                "content": "When we see pair matching, like parenthesis match / start-end / check-first-with-last etc. Stacks should be our go-to data structure.\\nThe code is quite intuitive. \\nIf needed, I can answer the questions in comment section.\\n```\\nclass Solution(object):\\n    def decodeString(self, s):\\n        stack = []\\n        result = \"\"\\n        i, n = 0, len(s)\\n        \\n        while i < n:\\n            if s[i].isdigit():\\n                num = \"\"\\n\\t\\t\\t\\t#Extract the number\\n                while i < n and s[i].isdigit():\\n                    num += s[i]\\n                    i += 1\\n\\t\\t\\t\\t#Skip \\'[\\'\\n                i += 1\\n                string = \"\"\\n\\t\\t\\t\\t#Extract the string after the number \\n                while i < n and s[i].isalpha():\\n                    string += s[i]\\n                    i += 1\\n                stack.append([int(num), string])\\n                continue\\n            if s[i] == \\']\\':\\n\\t\\t\\t\\t#If you see a closing bracket, pop the stack pop and multiply it num times.\\n                num, string = stack.pop()\\n                string = string * num\\n                i += 1\\n            else:\\n\\t\\t\\t\\t#This is the case when some part of the string are not enclosed within the []\\n                string = \"\"\\n                while i < n and s[i].isalpha():\\n                    string += s[i]\\n                    i += 1\\n            if stack:\\n\\t\\t\\t\\t#If the stack is not empty, the popped & multiplied string might have to be multiplied again.\\n                stack[-1][1] += string\\n            else:\\n\\t\\t\\t\\t#If the stack is empty, no parent, just add it to the result.\\n                result += string\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def decodeString(self, s):\\n        stack = []\\n        result = \"\"\\n        i, n = 0, len(s)\\n        \\n        while i < n:\\n            if s[i].isdigit():\\n                num = \"\"\\n\\t\\t\\t\\t#Extract the number\\n                while i < n and s[i].isdigit():\\n                    num += s[i]\\n                    i += 1\\n\\t\\t\\t\\t#Skip \\'[\\'\\n                i += 1\\n                string = \"\"\\n\\t\\t\\t\\t#Extract the string after the number \\n                while i < n and s[i].isalpha():\\n                    string += s[i]\\n                    i += 1\\n                stack.append([int(num), string])\\n                continue\\n            if s[i] == \\']\\':\\n\\t\\t\\t\\t#If you see a closing bracket, pop the stack pop and multiply it num times.\\n                num, string = stack.pop()\\n                string = string * num\\n                i += 1\\n            else:\\n\\t\\t\\t\\t#This is the case when some part of the string are not enclosed within the []\\n                string = \"\"\\n                while i < n and s[i].isalpha():\\n                    string += s[i]\\n                    i += 1\\n            if stack:\\n\\t\\t\\t\\t#If the stack is not empty, the popped & multiplied string might have to be multiplied again.\\n                stack[-1][1] += string\\n            else:\\n\\t\\t\\t\\t#If the stack is empty, no parent, just add it to the result.\\n                result += string\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377882,
                "title": "easy-understand-python-3-solution",
                "content": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        numstack = []\\n        resstack = []\\n        res = \\'\\'\\n        n = \\'\\'\\n        \\n        for i in s:\\n            if i.isdigit():\\n                n += i\\n            elif i.isalpha():\\n                res += i\\n            elif i == \"[\":\\n                numstack.append(int(n))\\n                resstack.append(res)\\n                n = \\'\\'\\n                res = \\'\\'\\n            else:\\n                newstr = resstack.pop()\\n                repeat = numstack.pop()\\n                res = newstr + res * repeat\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        numstack = []\\n        resstack = []\\n        res = \\'\\'\\n        n = \\'\\'\\n        \\n        for i in s:\\n            if i.isdigit():\\n                n += i\\n            elif i.isalpha():\\n                res += i\\n            elif i == \"[\":\\n                numstack.append(int(n))\\n                resstack.append(res)\\n                n = \\'\\'\\n                res = \\'\\'\\n            else:\\n                newstr = resstack.pop()\\n                repeat = numstack.pop()\\n                res = newstr + res * repeat\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354083,
                "title": "beats-100-cpp-solutions-very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n    \\n    int i=0; \\n    return decode(s, i);\\n    }\\n    \\n    string decode(string &s, int &i)\\n    {\\n        int count;\\n        string result;\\n        while(i<s.size())\\n        {\\n            if(isdigit(s[i]))\\n            {\\n                int beg = i;\\n                while(isdigit(s[i]))\\n                    i++;\\n                count = stoi(s.substr(beg, i-beg));\\n            }\\n            if(s[i] == \\'[\\')\\n            {\\n                string temp = decode(s, ++i);\\n                while(count--)\\n                    result = result + temp;\\n            }\\n            else\\n            if(isalpha(s[i]))\\n            {\\n                result = result + s[i];\\n            }\\n            else\\n            {\\n                return(result);\\n            }\\n            i++;\\n        }\\n        return(result);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n    \\n    int i=0; \\n    return decode(s, i);\\n    }\\n    \\n    string decode(string &s, int &i)\\n    {\\n        int count;\\n        string result;\\n        while(i<s.size())\\n        {\\n            if(isdigit(s[i]))\\n            {\\n                int beg = i;\\n                while(isdigit(s[i]))\\n                    i++;\\n                count = stoi(s.substr(beg, i-beg));\\n            }\\n            if(s[i] == \\'[\\')\\n            {\\n                string temp = decode(s, ++i);\\n                while(count--)\\n                    result = result + temp;\\n            }\\n            else\\n            if(isalpha(s[i]))\\n            {\\n                result = result + s[i];\\n            }\\n            else\\n            {\\n                return(result);\\n            }\\n            i++;\\n        }\\n        return(result);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 275221,
                "title": "recursion-python-solution-with-detailed-explanation",
                "content": "Multiple brackets within a bracket make this question more complicated. In order to make the solution almost O(n), whenever you encounter a bracket that encloses a complete bracket set, you call recursion on just the middle part, so that you get a clean alphabet solution of the middle operation. Once you receive the \"middle\", you can complete the answer by finding the k in front of the middle part and stitching everything else together. \\n\\nHow to find the middle part that is enclosed by the outer-most bracket:\\nYou interate through the string and store all the opening brackets\\' index numbers in the stack and and keep on popping it out when you encounter a closing bracket. You know that you encountered the outer-most bracket when the stack is empty after popping. then you call recursion on the middle part using the indices and then once you receive the \"middle\", then you multiply it by k. (k could be greater than 10, so i look for \"numstart\")\\n\\nIf stack is empty, and you encounter an alphabet, you know that it\\'s not part of the bracket operation and just add it to the \"res\" string. \\n\\neg)\\ndecodeString(\"3[a2[c]]\") -> call recursion decodeString(\"a2[c]\") -> call recursion decodeString(\"c\")\\n\\ndecodeString(\"c\") returns \"c\"\\ndecodeString(\"a2[c]\") returns \"acc\"\\ndecodeString(\"3[a2[c]]\") returns \"accaccacc\"\\n\\n```\\nclass Solution:\\n\\tdef decodeString(self, s:str) -> str:\\n\\t\\tstack = []\\n\\t\\tres = \"\"\\n\\t\\tfor i in range(len(s)):\\n\\t\\t\\tif s[i] == \"[\":\\n\\t\\t\\t\\tstack.append(i)\\n\\t\\t\\telif s[i] == \"]\":\\n\\t\\t\\t\\tstartIndex = stack.pop()\\n\\t\\t\\t\\tif stack == []:\\n\\t\\t\\t\\t\\tmiddle = self.decodeString(s[startIndex + 1: i])\\n\\t\\t\\t\\t\\tnumstart = startIndex\\n\\t\\t\\t\\t\\twhile numstart - 1 >= 0 and s[numstart - 1].isdigit():\\n\\t\\t\\t\\t\\t\\tnumstart -= 1\\n\\t\\t\\t\\t\\tadd_string = int(s[numstart:startIndex]) * middle\\n\\t\\t\\t\\t\\tres += add_string\\n\\t\\t\\telif stack == [] and s[i].isalpha():\\n\\t\\t\\t\\tres += s[i]\\n\\t\\t\\n\\t\\treturn res\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\tdef decodeString(self, s:str) -> str:\\n\\t\\tstack = []\\n\\t\\tres = \"\"\\n\\t\\tfor i in range(len(s)):\\n\\t\\t\\tif s[i] == \"[\":\\n\\t\\t\\t\\tstack.append(i)\\n\\t\\t\\telif s[i] == \"]\":\\n\\t\\t\\t\\tstartIndex = stack.pop()\\n\\t\\t\\t\\tif stack == []:\\n\\t\\t\\t\\t\\tmiddle = self.decodeString(s[startIndex + 1: i])\\n\\t\\t\\t\\t\\tnumstart = startIndex\\n\\t\\t\\t\\t\\twhile numstart - 1 >= 0 and s[numstart - 1].isdigit():\\n\\t\\t\\t\\t\\t\\tnumstart -= 1\\n\\t\\t\\t\\t\\tadd_string = int(s[numstart:startIndex]) * middle\\n\\t\\t\\t\\t\\tres += add_string\\n\\t\\t\\telif stack == [] and s[i].isalpha():\\n\\t\\t\\t\\tres += s[i]\\n\\t\\t\\n\\t\\treturn res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245538,
                "title": "javascript-using-regex",
                "content": "Simple Javascript version with Regex.\\n\\n``` Javascript\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nfunction decodeString1(s) {\\n    return s.replace(/(\\\\d+\\\\[\\\\w+\\\\])/gi, function(item) {\\n        var match = /(\\\\d+)\\\\[(\\\\w+)\\\\]/.exec(item);\\n        var repeat = parseInt(match[1]);\\n        var pattern = match[2];\\n        \\n        var result = \"\";\\n        while(repeat-- > 0) {\\n            result += pattern;\\n        }\\n        return result;\\n    });\\n};\\n\\nvar decodeString = function(s) {\\n    while(/\\\\d+\\\\[\\\\w+\\\\]/gi.test(s)) {\\n        s = decodeString1(s);\\n    }\\n    return s;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` Javascript\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nfunction decodeString1(s) {\\n    return s.replace(/(\\\\d+\\\\[\\\\w+\\\\])/gi, function(item) {\\n        var match = /(\\\\d+)\\\\[(\\\\w+)\\\\]/.exec(item);\\n        var repeat = parseInt(match[1]);\\n        var pattern = match[2];\\n        \\n        var result = \"\";\\n        while(repeat-- > 0) {\\n            result += pattern;\\n        }\\n        return result;\\n    });\\n};\\n\\nvar decodeString = function(s) {\\n    while(/\\\\d+\\\\[\\\\w+\\\\]/gi.test(s)) {\\n        s = decodeString1(s);\\n    }\\n    return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 190485,
                "title": "very-easy-dfs-solution-with-no-stack",
                "content": "```\\n    private int i = 0;\\n    public String decodeString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int num = 0;\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            \\n            if (c >= \\'0\\' && c <= \\'9\\') {\\n                num = num * 10 + c - \\'0\\';\\n            } else if (c == \\'[\\') {\\n                i++;\\n                String str = decodeString(s);\\n                for (int k = 0; k < num; k++) \\n                    sb.append(str);\\n                num = 0;\\n            } else if (c == \\']\\') {\\n                return sb.toString();\\n            } else {\\n                sb.append(c);\\n            }\\n            i++;\\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int i = 0;\\n    public String decodeString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int num = 0;\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            \\n            if (c >= \\'0\\' && c <= \\'9\\') {\\n                num = num * 10 + c - \\'0\\';\\n            } else if (c == \\'[\\') {\\n                i++;\\n                String str = decodeString(s);\\n                for (int k = 0; k < num; k++) \\n                    sb.append(str);\\n                num = 0;\\n            } else if (c == \\']\\') {\\n                return sb.toString();\\n            } else {\\n                sb.append(c);\\n            }\\n            i++;\\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 163114,
                "title": "python-solution",
                "content": "DFS recursive:\\n```\\nclass Solution(object):\\n    def decodeString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        res = \"\"\\n        for i in range(len(s)):\\n            if s[i].isalpha():\\n                res += s[i]\\n            elif s[i].isnumeric():\\n                a = s[i]\\n                j = i+1\\n                while s[j].isnumeric():\\n                    a += s[j]\\n                    j += 1\\n                num = int(a)\\n                j += 1\\n                l = j\\n                count = 1\\n                while count != 0:\\n                    if s[j] == \"[\":\\n                        count += 1\\n                    elif s[j] == \"]\":\\n                        count -= 1\\n                    j += 1\\n                return res + num*self.decodeString(s[l:j-1]) + self.decodeString(s[j:])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def decodeString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        res = \"\"\\n        for i in range(len(s)):\\n            if s[i].isalpha():\\n                res += s[i]\\n            elif s[i].isnumeric():\\n                a = s[i]\\n                j = i+1\\n                while s[j].isnumeric():\\n                    a += s[j]\\n                    j += 1\\n                num = int(a)\\n                j += 1\\n                l = j\\n                count = 1\\n                while count != 0:\\n                    if s[j] == \"[\":\\n                        count += 1\\n                    elif s[j] == \"]\":\\n                        count -= 1\\n                    j += 1\\n                return res + num*self.decodeString(s[l:j-1]) + self.decodeString(s[j:])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141504,
                "title": "c-easy-to-understand-solution-using-stacks",
                "content": "```\\npublic class Solution {\\n    public string DecodeString(string s) {\\n        String res = string.Empty;\\n        Stack<string> resStack = new Stack<string>();\\n        Stack<int> countStack = new Stack<int>();\\n        int currIndex = 0;\\n        while (currIndex < s.Length)\\n        {\\n            if (char.IsDigit(s[currIndex]))\\n            {\\n                int count = s[currIndex] - \\'0\\';\\n                currIndex++;\\n                while (char.IsDigit(s[currIndex]))\\n                {\\n                    count = 10 * count + (s[currIndex] - \\'0\\');\\n                    currIndex++;           \\n                }\\n                countStack.Push(count);\\n            }\\n            else if (s[currIndex] == \\'[\\')\\n            {\\n                resStack.Push(res);\\n                res = string.Empty;\\n                currIndex++; \\n            }\\n            else if (s[currIndex] == \\']\\')\\n            {                    \\n                StringBuilder repeatString = new StringBuilder();\\n                int repeatTimes = countStack.Pop();\\n                for (int i = 0; i < repeatTimes; i++)\\n                    repeatString.Append(res);\\n                res = resStack.Pop() + repeatString.ToString();                   \\n                currIndex++;\\n            }\\n            else\\n            {\\n                res += s[currIndex++];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string DecodeString(string s) {\\n        String res = string.Empty;\\n        Stack<string> resStack = new Stack<string>();\\n        Stack<int> countStack = new Stack<int>();\\n        int currIndex = 0;\\n        while (currIndex < s.Length)\\n        {\\n            if (char.IsDigit(s[currIndex]))\\n            {\\n                int count = s[currIndex] - \\'0\\';\\n                currIndex++;\\n                while (char.IsDigit(s[currIndex]))\\n                {\\n                    count = 10 * count + (s[currIndex] - \\'0\\');\\n                    currIndex++;           \\n                }\\n                countStack.Push(count);\\n            }\\n            else if (s[currIndex] == \\'[\\')\\n            {\\n                resStack.Push(res);\\n                res = string.Empty;\\n                currIndex++; \\n            }\\n            else if (s[currIndex] == \\']\\')\\n            {                    \\n                StringBuilder repeatString = new StringBuilder();\\n                int repeatTimes = countStack.Pop();\\n                for (int i = 0; i < repeatTimes; i++)\\n                    repeatString.Append(res);\\n                res = resStack.Pop() + repeatString.ToString();                   \\n                currIndex++;\\n            }\\n            else\\n            {\\n                res += s[currIndex++];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87634,
                "title": "python-with-stack",
                "content": "We need to pay attention to the digit processing. (10[a])\\n\\n    class Solution(object):\\n        def decodeString(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: str\\n            \"\"\"\\n            stack = []\\n            for chr in s:\\n                if chr != ']':\\n                    stack.append(chr)\\n                else:\\n                    temp_s = ''\\n                    while stack:\\n                        x = stack.pop()\\n                        if x == '[':\\n                            n = ''\\n                            while stack and stack[-1].isdigit():\\n                                n = stack.pop() + n\\n                            stack.append(temp_s*int(n))\\n                            break\\n                        else:\\n                            temp_s = x + temp_s\\n            return ''.join(stack)",
                "solutionTags": [],
                "code": "We need to pay attention to the digit processing. (10[a])\\n\\n    class Solution(object):\\n        def decodeString(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: str\\n            \"\"\"\\n            stack = []\\n            for chr in s:\\n                if chr != ']':\\n                    stack.append(chr)\\n                else:\\n                    temp_s = ''\\n                    while stack:\\n                        x = stack.pop()\\n                        if x == '[':\\n                            n = ''\\n                            while stack and stack[-1].isdigit():\\n                                n = stack.pop() + n\\n                            stack.append(temp_s*int(n))\\n                            break\\n                        else:\\n                            temp_s = x + temp_s\\n            return ''.join(stack)",
                "codeTag": "Java"
            },
            {
                "id": 3718878,
                "title": "easy-c-solution-using-stack-iterative-beats-100-of-the-submissions",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        string ans = \"\";\\n        stack<string> st;\\n        string number = \"\";\\n\\n        for (int i = 0; i < s.size(); i++) {\\n            string t = string(1, s[i]);\\n\\n            if (isdigit(s[i])) {\\n                number += s[i];\\n                continue;\\n            }\\n\\n            if (s[i] == \\'[\\') {\\n                st.push(number);\\n                number.clear();\\n            }\\n\\n            if (s[i] == \\']\\') {\\n                string tempString = \"\";\\n\\n                while (st.top() != \"[\") {\\n                    tempString += st.top();\\n                    st.pop();\\n                }\\n\\n                st.pop();\\n                int temp = stoi(st.top());\\n                st.pop();\\n\\n                for (int j = 0; j < temp; j++) {\\n                    ans += tempString;\\n                }\\n\\n                st.push(ans);\\n                ans.clear();\\n                continue;\\n            }\\n\\n            st.push(t);\\n        }\\n\\n        while (!st.empty()) {\\n            ans += st.top();\\n            st.pop();\\n        }\\n\\n        reverse(ans.begin(), ans.end());\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        string ans = \"\";\\n        stack<string> st;\\n        string number = \"\";\\n\\n        for (int i = 0; i < s.size(); i++) {\\n            string t = string(1, s[i]);\\n\\n            if (isdigit(s[i])) {\\n                number += s[i];\\n                continue;\\n            }\\n\\n            if (s[i] == \\'[\\') {\\n                st.push(number);\\n                number.clear();\\n            }\\n\\n            if (s[i] == \\']\\') {\\n                string tempString = \"\";\\n\\n                while (st.top() != \"[\") {\\n                    tempString += st.top();\\n                    st.pop();\\n                }\\n\\n                st.pop();\\n                int temp = stoi(st.top());\\n                st.pop();\\n\\n                for (int j = 0; j < temp; j++) {\\n                    ans += tempString;\\n                }\\n\\n                st.push(ans);\\n                ans.clear();\\n                continue;\\n            }\\n\\n            st.push(t);\\n        }\\n\\n        while (!st.empty()) {\\n            ans += st.top();\\n            st.pop();\\n        }\\n\\n        reverse(ans.begin(), ans.end());\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676504,
                "title": "beats-100-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncontinue to decode until a string has a number, store the number and the string in a vector.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore The number and corresponding string in the vector, copy the string in i+1 to i number of times and return the string, continue if the resulting string has a number. \\n\\n# Complexity\\n- Time complexity:O(depth of brackets)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nUpvote if you find it helpful vro ;)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decode(string s){\\n        int count = 0; string temp = \"\", n = \"\", res = \"\"; vector<string> ans; \\n\\n\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]>=48 && s[i]<58 && count == 0) {n+= s[i]; if(temp!= \"\"){ans.push_back(\"1\");  ans.push_back(temp); temp = \"\"; } }\\n            else if(s[i] == \\'[\\' && count == 0) count++; \\n            else if(s[i] == \\']\\' && count == 1) { ans.push_back(n); ans.push_back(temp); n = \"\"; temp = \"\"; count = 0; }\\n            else if(s[i] == \\'[\\') {count++; temp += s[i]; }\\n            else if(s[i] == \\']\\'){ count--; temp += s[i]; }\\n            else {temp += s[i]; } \\n        } \\n        \\n        if(temp != \"\"){ans.push_back(\"1\");  ans.push_back(temp); }\\n\\n        // for(int i=0; i<ans.size(); i++) cout << ans[i] << \" \";\\n\\n        for(int i=0; i<ans.size(); i+=2){\\n            int c = stoi(ans[i]);  string temp = ans[i+1]; \\n            while(c--) res += temp; \\n        }\\n\\n        return res; \\n    }\\n\\n    bool check(string s){\\n        for(int i=0; i<s.length(); i++) if(s[i]>=48 && s[i]<58) return true; \\n        return false; \\n    }\\n\\n    string decodeString(string s) {\\n     \\n    while(check(s)) s = decode(s); \\n\\n    return s; \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decode(string s){\\n        int count = 0; string temp = \"\", n = \"\", res = \"\"; vector<string> ans; \\n\\n\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]>=48 && s[i]<58 && count == 0) {n+= s[i]; if(temp!= \"\"){ans.push_back(\"1\");  ans.push_back(temp); temp = \"\"; } }\\n            else if(s[i] == \\'[\\' && count == 0) count++; \\n            else if(s[i] == \\']\\' && count == 1) { ans.push_back(n); ans.push_back(temp); n = \"\"; temp = \"\"; count = 0; }\\n            else if(s[i] == \\'[\\') {count++; temp += s[i]; }\\n            else if(s[i] == \\']\\'){ count--; temp += s[i]; }\\n            else {temp += s[i]; } \\n        } \\n        \\n        if(temp != \"\"){ans.push_back(\"1\");  ans.push_back(temp); }\\n\\n        // for(int i=0; i<ans.size(); i++) cout << ans[i] << \" \";\\n\\n        for(int i=0; i<ans.size(); i+=2){\\n            int c = stoi(ans[i]);  string temp = ans[i+1]; \\n            while(c--) res += temp; \\n        }\\n\\n        return res; \\n    }\\n\\n    bool check(string s){\\n        for(int i=0; i<s.length(); i++) if(s[i]>=48 && s[i]<58) return true; \\n        return false; \\n    }\\n\\n    string decodeString(string s) {\\n     \\n    while(check(s)) s = decode(s); \\n\\n    return s; \\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3291890,
                "title": "1-ms-java-using-2-stacks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-Traverse the string from start to finish and while doing so,\\n--Use charS stack To store all the characters except for \\']\\'\\n--Use numS stack To store all the numbers\\n--Once we hit a char == \\']\\' we pop from charS until we get \\'[\\', and then we pop once from numS to get the number of repetitions. \\n-- construct the new string and push it back on to the charS stack and continue the loop.\\n\\n(Let me know if you need any clarification)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> numS = new Stack();\\n        Stack<String> charS = new Stack();\\n\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) == \\']\\'){\\n                int k = numS.pop();\\n\\n                String ch = charS.pop();\\n                String toConcat = \"\";\\n                while(!ch.equals(\"[\")){\\n                    toConcat = ch+toConcat;\\n                    ch = charS.pop(); \\n                }\\n                String concat = \"\";\\n                while(k>0){\\n                    concat = concat + toConcat;\\n                    k--;\\n                }\\n                charS.push(concat);\\n                 \\n            }else if(Character.isDigit(s.charAt(i))){\\n                numS.push(Integer.valueOf(s.substring(i,s.indexOf(\\'[\\',i))));\\n                i = s.indexOf(\\'[\\',i)-1;\\n            }else{\\n                charS.push(Character.toString(s.charAt(i)));\\n            }\\n                            \\n        }\\n        \\n        String result=\"\";\\n         while(!charS.empty()){\\n            result = charS.pop() + result;\\n         }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> numS = new Stack();\\n        Stack<String> charS = new Stack();\\n\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) == \\']\\'){\\n                int k = numS.pop();\\n\\n                String ch = charS.pop();\\n                String toConcat = \"\";\\n                while(!ch.equals(\"[\")){\\n                    toConcat = ch+toConcat;\\n                    ch = charS.pop(); \\n                }\\n                String concat = \"\";\\n                while(k>0){\\n                    concat = concat + toConcat;\\n                    k--;\\n                }\\n                charS.push(concat);\\n                 \\n            }else if(Character.isDigit(s.charAt(i))){\\n                numS.push(Integer.valueOf(s.substring(i,s.indexOf(\\'[\\',i))));\\n                i = s.indexOf(\\'[\\',i)-1;\\n            }else{\\n                charS.push(Character.toString(s.charAt(i)));\\n            }\\n                            \\n        }\\n        \\n        String result=\"\";\\n         while(!charS.empty()){\\n            result = charS.pop() + result;\\n         }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164075,
                "title": "decose-string-easily-understandable-method-with-comments-100-beats",
                "content": "# Learning Point\\nHere we are just traversing string and applying some require operations,\\nOne learning point is that \"how to convert char to string\"\\nAns to that is, using string(length,character) inbuilt STL function.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack <string> st;\\n        for(char c : s){\\n            //pushing all characters other than \\']\\'\\n            if(c != \\']\\') st.push(string(1,c));\\n            else{\\n                //finding string part \\n                string str = \"\";\\n                while(st.top() != string(1,\\'[\\')){\\n                    str += st.top();\\n                    st.pop();\\n                }\\n                reverse(str.begin() , str.end());\\n                //finding number/integer part\\n                string temp = \"\";\\n                st.pop(); // poping \\'[\\'\\n                while(!st.empty() && st.top() >= string(1,\\'0\\') && st.top() <= string(1,\\'9\\')){\\n                    temp += st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                int num = 0;\\n                if(temp.size()==0) num = 1;\\n                else num = stoll(temp);\\n                //putting back resulting string in the stack !\\n                string toPush = \"\";\\n                while(num--) toPush += str;\\n                reverse(toPush.begin() , toPush.end()); // we are putting this again in the stack so reversing is needed !\\n                st.push(toPush);\\n            }\\n        }\\n        if(st.empty()) return \"\";\\n        string ans = \"\";\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin() , ans.end());\\n        return ans;\\n    }\\n};\\n// how to convert character to string ~ use string(1,c);\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack <string> st;\\n        for(char c : s){\\n            //pushing all characters other than \\']\\'\\n            if(c != \\']\\') st.push(string(1,c));\\n            else{\\n                //finding string part \\n                string str = \"\";\\n                while(st.top() != string(1,\\'[\\')){\\n                    str += st.top();\\n                    st.pop();\\n                }\\n                reverse(str.begin() , str.end());\\n                //finding number/integer part\\n                string temp = \"\";\\n                st.pop(); // poping \\'[\\'\\n                while(!st.empty() && st.top() >= string(1,\\'0\\') && st.top() <= string(1,\\'9\\')){\\n                    temp += st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                int num = 0;\\n                if(temp.size()==0) num = 1;\\n                else num = stoll(temp);\\n                //putting back resulting string in the stack !\\n                string toPush = \"\";\\n                while(num--) toPush += str;\\n                reverse(toPush.begin() , toPush.end()); // we are putting this again in the stack so reversing is needed !\\n                st.push(toPush);\\n            }\\n        }\\n        if(st.empty()) return \"\";\\n        string ans = \"\";\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin() , ans.end());\\n        return ans;\\n    }\\n};\\n// how to convert character to string ~ use string(1,c);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135858,
                "title": "using-of-stacks-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically the opening and closing brackets plays a crucial role in this problemm.. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly we should insert the possible elements inside of our stack till we encounter any closing brackets the moment we got that we traverse back and then delete the elements in the stack we will be having a number and a character...\\nBut they mentioned always a number comes after the character 3[a] \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\nLinear Time \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\nStack..\\n# Code\\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack=[]\\n        for i in s:\\n            if(i==\"]\"):\\n                #we have encountered a closing brackets..\\n                stri=\"\"\\n                while stack[0]!=\"[\":\\n                    stri=stack.pop(0)+stri\\n                stack.pop(0)\\n                #we are extracting the possible character from the elements which are included in the stack..\\n                k=\"\"\\n                while stack and stack[0].isdigit():\\n                    k=stack.pop(0)+k\\n                stack.insert(0,int(k)*stri)\\n            else:\\n                stack.insert(0,i)\\n        stack.reverse()\\n        return (\"\".join(stack))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack=[]\\n        for i in s:\\n            if(i==\"]\"):\\n                #we have encountered a closing brackets..\\n                stri=\"\"\\n                while stack[0]!=\"[\":\\n                    stri=stack.pop(0)+stri\\n                stack.pop(0)\\n                #we are extracting the possible character from the elements which are included in the stack..\\n                k=\"\"\\n                while stack and stack[0].isdigit():\\n                    k=stack.pop(0)+k\\n                stack.insert(0,int(k)*stri)\\n            else:\\n                stack.insert(0,i)\\n        stack.reverse()\\n        return (\"\".join(stack))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121220,
                "title": "0ms-ugly-but-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nno intuition \\nuse long and stupid variable names\\nwrite bad comments\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncomment out cout\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        // go through the string, push all [ onto the stack, once you en//couter a ], pop off the [, map the index to the right index\\n        stack<int> st;\\n        unordered_map<int, int> leftToRight;\\n\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (s[i] == \\'[\\')\\n            {\\n                st.push(i);\\n            }\\n            else if (s[i] == \\']\\')\\n            {\\n                int left = st.top();\\n                st.pop();\\n                int right = i;\\n                leftToRight[left] = right;\\n            }\\n        }\\n        //cout << \"calling decode on s: \" << s << endl;\\n        // if you see a nonnumber push on\\n        // if you see a digit, find the first [, slice out the digit\\n        // then find the ], slice out the internal substring\\n        // recursive call on the internal substring\\n        // push the internal substring on however that many times\\n        string res;\\n        int currIndex = 0;\\n        int n = s.size();\\n        while (currIndex < n) // still processing\\n        {\\n            //cout << \"   currIndex: \" << currIndex << endl;\\n            if (!isdigit(s[currIndex]))\\n            {\\n                res += s[currIndex];\\n                currIndex++;\\n                //cout << \"       safely pushed to res: \" << res << endl;\\n            }\\n            else\\n            {\\n                // find the last instance of the digit, find the left[ and right]\\n                int lastDigitIndex = currIndex;\\n                //cout << \"       found some digit, currIndex: \" << currIndex << endl;\\n                while(s[lastDigitIndex] != \\'[\\')\\n                {\\n                    lastDigitIndex++;\\n                } // now: s[lastDigitIndex] = \\'[\\'\\n                int leftBracketIndex = lastDigitIndex;\\n                lastDigitIndex--;\\n                int numRep = stoi(s.substr(currIndex, lastDigitIndex - currIndex + 1));\\n                int rightBracketIndex = leftToRight[leftBracketIndex];\\n                string innerString = s.substr(leftBracketIndex+1, (rightBracketIndex - 1 - (leftBracketIndex + 1) + 1));\\n                string innerDecoded = decodeString(innerString);\\n\\n                for (int i = 0; i < numRep; i++)\\n                {\\n                    res += innerDecoded;\\n                }\\n                currIndex = rightBracketIndex + 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        // go through the string, push all [ onto the stack, once you en//couter a ], pop off the [, map the index to the right index\\n        stack<int> st;\\n        unordered_map<int, int> leftToRight;\\n\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (s[i] == \\'[\\')\\n            {\\n                st.push(i);\\n            }\\n            else if (s[i] == \\']\\')\\n            {\\n                int left = st.top();\\n                st.pop();\\n                int right = i;\\n                leftToRight[left] = right;\\n            }\\n        }\\n        //cout << \"calling decode on s: \" << s << endl;\\n        // if you see a nonnumber push on\\n        // if you see a digit, find the first [, slice out the digit\\n        // then find the ], slice out the internal substring\\n        // recursive call on the internal substring\\n        // push the internal substring on however that many times\\n        string res;\\n        int currIndex = 0;\\n        int n = s.size();\\n        while (currIndex < n) // still processing\\n        {\\n            //cout << \"   currIndex: \" << currIndex << endl;\\n            if (!isdigit(s[currIndex]))\\n            {\\n                res += s[currIndex];\\n                currIndex++;\\n                //cout << \"       safely pushed to res: \" << res << endl;\\n            }\\n            else\\n            {\\n                // find the last instance of the digit, find the left[ and right]\\n                int lastDigitIndex = currIndex;\\n                //cout << \"       found some digit, currIndex: \" << currIndex << endl;\\n                while(s[lastDigitIndex] != \\'[\\')\\n                {\\n                    lastDigitIndex++;\\n                } // now: s[lastDigitIndex] = \\'[\\'\\n                int leftBracketIndex = lastDigitIndex;\\n                lastDigitIndex--;\\n                int numRep = stoi(s.substr(currIndex, lastDigitIndex - currIndex + 1));\\n                int rightBracketIndex = leftToRight[leftBracketIndex];\\n                string innerString = s.substr(leftBracketIndex+1, (rightBracketIndex - 1 - (leftBracketIndex + 1) + 1));\\n                string innerDecoded = decodeString(innerString);\\n\\n                for (int i = 0; i < numRep; i++)\\n                {\\n                    res += innerDecoded;\\n                }\\n                currIndex = rightBracketIndex + 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3112902,
                "title": "simple-and-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char> st;\\n        string ans=\"\";\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {   \\n            st.push(s[i]);\\n            if(s[i]==\\']\\')\\n            {\\n                st.pop();\\n                string temp=\"\";\\n                while(!st.empty() && st.top()!=\\'[\\')\\n                {\\n                    temp=st.top()+temp;\\n                    st.pop();\\n                }\\n                if(!st.empty())\\n                st.pop();\\n                string d=\"\";\\n                while(!st.empty() && isdigit(st.top()))\\n                {\\n                    d=st.top()+d;\\n                    st.pop();\\n                }\\n\\n                int num=stoi(d);\\n                string result=\"\";\\n                while(num--)\\n                {\\n                    result+=temp;\\n                }\\n\\n                for(auto c:result)\\n                {\\n                    st.push(c);\\n                }\\n            }\\n        }\\n        string temp=\"\";\\n        while(!st.empty())\\n        {\\n            temp=st.top()+temp;\\n            st.pop();\\n        }\\n\\n        ans+=temp;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<char> st;\\n        string ans=\"\";\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {   \\n            st.push(s[i]);\\n            if(s[i]==\\']\\')\\n            {\\n                st.pop();\\n                string temp=\"\";\\n                while(!st.empty() && st.top()!=\\'[\\')\\n                {\\n                    temp=st.top()+temp;\\n                    st.pop();\\n                }\\n                if(!st.empty())\\n                st.pop();\\n                string d=\"\";\\n                while(!st.empty() && isdigit(st.top()))\\n                {\\n                    d=st.top()+d;\\n                    st.pop();\\n                }\\n\\n                int num=stoi(d);\\n                string result=\"\";\\n                while(num--)\\n                {\\n                    result+=temp;\\n                }\\n\\n                for(auto c:result)\\n                {\\n                    st.push(c);\\n                }\\n            }\\n        }\\n        string temp=\"\";\\n        while(!st.empty())\\n        {\\n            temp=st.top()+temp;\\n            st.pop();\\n        }\\n\\n        ans+=temp;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040419,
                "title": "two-stacks-solution-on-swift",
                "content": "\\n# Code\\n```\\nfunc decodeString(_ s: String) -> String {\\n    var intStack = [Int](), strStack = [String](), currentNum = Int(), currentString = String()\\n    for char in s {\\n        if char == \"[\" {\\n            strStack.append(currentString)\\n            intStack.append(currentNum)\\n            currentString = \"\"\\n            currentNum = 0\\n        } else if char == \"]\" {\\n            let num = intStack.removeLast()\\n            let prevString = strStack.removeLast()\\n            currentString = prevString + String(repeating: currentString, count: num)\\n        } else if let charNum = Int(String(char)) {\\n            currentNum = currentNum * 10 + charNum\\n        } else {\\n            currentString.append(String(char))\\n        }\\n    }\\n    return currentString\\n}\\n```\\n### Please upvote if the solution was useful!",
                "solutionTags": [
                    "Swift",
                    "Stack"
                ],
                "code": "```\\nfunc decodeString(_ s: String) -> String {\\n    var intStack = [Int](), strStack = [String](), currentNum = Int(), currentString = String()\\n    for char in s {\\n        if char == \"[\" {\\n            strStack.append(currentString)\\n            intStack.append(currentNum)\\n            currentString = \"\"\\n            currentNum = 0\\n        } else if char == \"]\" {\\n            let num = intStack.removeLast()\\n            let prevString = strStack.removeLast()\\n            currentString = prevString + String(repeating: currentString, count: num)\\n        } else if let charNum = Int(String(char)) {\\n            currentNum = currentNum * 10 + charNum\\n        } else {\\n            currentString.append(String(char))\\n        }\\n    }\\n    return currentString\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3018366,
                "title": "c-dfs-beats-99",
                "content": "# Intuition\\nUse String Builders and DFS to obtain the decoded string. By the time of submission, this solution was 99% faster than existing solutions.\\n\\n# Approach\\nFind Multiplier:\\n```\\nint n = 0 ;\\nwhile (pointer < s.Length && Char.IsDigit(s[pointer]))\\n{\\n    sbNumber.Append(s[pointer]);\\n    pointer++;\\n}\\nif (sbNumber.Length > 0)\\n{\\n    n = Convert.ToInt32(sbNumber.ToString());\\n}\\n```\\nFind string that follows the multiplier and concatenate replicas:\\n```\\nif (n>0)\\n{\\n    if (s[pointer] == \\'[\\')\\n    {\\n        pointer++;\\n        sbWord = Dfs(s, ref pointer);\\n    }\\n    for(int i = 0; i< n; i++)\\n    {\\n        sbResult.Append(sbWord.ToString());\\n    }\\n}\\n```\\nIf we\\'re not done yet, keep running with updated pointer, concatenate results, then return:\\n```\\nif (pointer < s.Length -1)\\n{\\n    pointer++;\\n    sbResult.Append(Dfs(s, ref pointer));\\n}\\nreturn sbResult;\\n\\n```\\nIf we found a letter, keep aggregating to other letters until a closing bracket is found or the end of the string, then return:\\n```\\nwhile (pointer < s.Length && Char.IsLetter(s[pointer]))\\n{\\n    sbWord.Append(s[pointer]);\\n    pointer++;\\n}\\nif (pointer >= s.Length -1 ||s[pointer] == \\']\\')\\n{\\n    return sbWord;\\n}\\n```\\nif a digit was found, re-run Dfs, aggregate the result to sbWord, then return:\\n```\\n{\\n    sbWord.Append(Dfs(s, ref pointer));\\n    return sbWord;\\n}\\n```\\n\\n# Code\\n```\\npublic class Solution {\\n    public string DecodeString(string s) {\\n        int pointer = 0;\\n        var sb = Dfs(s, ref pointer );\\n        return sb.ToString();\\n    }\\n    StringBuilder Dfs(string s, ref int pointer )\\n    {\\n        StringBuilder sbNumber = new();\\n        StringBuilder sbWord = new();\\n        StringBuilder sbResult = new();\\n        if (pointer >= s.Length)\\n        {\\n            return sbResult;\\n        }\\n        int n = 0 ;\\n        while (pointer < s.Length && Char.IsDigit(s[pointer]))\\n        {\\n            sbNumber.Append(s[pointer]);\\n            pointer++;\\n        }\\n        if (sbNumber.Length > 0)\\n        {\\n            n = Convert.ToInt32(sbNumber.ToString());\\n        }\\n        if (n>0)\\n        {\\n            if (s[pointer] == \\'[\\')\\n            {\\n                pointer++;\\n                sbWord = Dfs(s, ref pointer);\\n            }\\n            for(int i = 0; i< n; i++)\\n            {\\n                sbResult.Append(sbWord.ToString());\\n            }\\n        }\\n        else\\n        {\\n            while (pointer < s.Length && Char.IsLetter(s[pointer]))\\n            {\\n                sbWord.Append(s[pointer]);\\n                pointer++;\\n            }\\n            if (pointer >= s.Length -1 ||s[pointer] == \\']\\')\\n            {\\n                return sbWord;\\n            }\\n            else if (Char.IsDigit(s[pointer]))\\n            {\\n                sbWord.Append(Dfs(s, ref pointer));\\n                return sbWord;\\n            }\\n        }\\n        if (pointer < s.Length -1)\\n        {\\n            pointer++;\\n            sbResult.Append(Dfs(s, ref pointer));\\n        }\\n        return sbResult;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search"
                ],
                "code": "```\\nint n = 0 ;\\nwhile (pointer < s.Length && Char.IsDigit(s[pointer]))\\n{\\n    sbNumber.Append(s[pointer]);\\n    pointer++;\\n}\\nif (sbNumber.Length > 0)\\n{\\n    n = Convert.ToInt32(sbNumber.ToString());\\n}\\n```\n```\\nif (n>0)\\n{\\n    if (s[pointer] == \\'[\\')\\n    {\\n        pointer++;\\n        sbWord = Dfs(s, ref pointer);\\n    }\\n    for(int i = 0; i< n; i++)\\n    {\\n        sbResult.Append(sbWord.ToString());\\n    }\\n}\\n```\n```\\nif (pointer < s.Length -1)\\n{\\n    pointer++;\\n    sbResult.Append(Dfs(s, ref pointer));\\n}\\nreturn sbResult;\\n\\n```\n```\\nwhile (pointer < s.Length && Char.IsLetter(s[pointer]))\\n{\\n    sbWord.Append(s[pointer]);\\n    pointer++;\\n}\\nif (pointer >= s.Length -1 ||s[pointer] == \\']\\')\\n{\\n    return sbWord;\\n}\\n```\n```\\n{\\n    sbWord.Append(Dfs(s, ref pointer));\\n    return sbWord;\\n}\\n```\n```\\npublic class Solution {\\n    public string DecodeString(string s) {\\n        int pointer = 0;\\n        var sb = Dfs(s, ref pointer );\\n        return sb.ToString();\\n    }\\n    StringBuilder Dfs(string s, ref int pointer )\\n    {\\n        StringBuilder sbNumber = new();\\n        StringBuilder sbWord = new();\\n        StringBuilder sbResult = new();\\n        if (pointer >= s.Length)\\n        {\\n            return sbResult;\\n        }\\n        int n = 0 ;\\n        while (pointer < s.Length && Char.IsDigit(s[pointer]))\\n        {\\n            sbNumber.Append(s[pointer]);\\n            pointer++;\\n        }\\n        if (sbNumber.Length > 0)\\n        {\\n            n = Convert.ToInt32(sbNumber.ToString());\\n        }\\n        if (n>0)\\n        {\\n            if (s[pointer] == \\'[\\')\\n            {\\n                pointer++;\\n                sbWord = Dfs(s, ref pointer);\\n            }\\n            for(int i = 0; i< n; i++)\\n            {\\n                sbResult.Append(sbWord.ToString());\\n            }\\n        }\\n        else\\n        {\\n            while (pointer < s.Length && Char.IsLetter(s[pointer]))\\n            {\\n                sbWord.Append(s[pointer]);\\n                pointer++;\\n            }\\n            if (pointer >= s.Length -1 ||s[pointer] == \\']\\')\\n            {\\n                return sbWord;\\n            }\\n            else if (Char.IsDigit(s[pointer]))\\n            {\\n                sbWord.Append(Dfs(s, ref pointer));\\n                return sbWord;\\n            }\\n        }\\n        if (pointer < s.Length -1)\\n        {\\n            pointer++;\\n            sbResult.Append(Dfs(s, ref pointer));\\n        }\\n        return sbResult;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940066,
                "title": "1-ms-simple-code",
                "content": "# Please upvote if you like my solution .\\n$$O(n)$$ \\n\\n# Code\\n```\\nvar decodeString = function(s) {\\n  var regex = /(\\\\d*)(?:\\\\[)([A-Za-z]*)(?:\\\\])/\\n\\n  while (regex.test(s)) {\\n    var matchStr = s.match(regex)\\n    var ind = matchStr.index\\n    var str = matchStr[0]\\n    var mLen = str.length\\n\\n    var strCount = parseInt(matchStr[1])\\n    var template = matchStr[2].repeat(strCount)\\n\\n    s = s.slice(0, ind) + template + s.slice(ind + mLen, s.length)\\n  } \\n  \\n  return s\\n};\\n```\\n# Please upvote if you like my solution .\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes.\\nLet me know in comment if i can do better.\\nLets connect on Linkedin https://www.linkedin.com/in/kailas-rathod/",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decodeString = function(s) {\\n  var regex = /(\\\\d*)(?:\\\\[)([A-Za-z]*)(?:\\\\])/\\n\\n  while (regex.test(s)) {\\n    var matchStr = s.match(regex)\\n    var ind = matchStr.index\\n    var str = matchStr[0]\\n    var mLen = str.length\\n\\n    var strCount = parseInt(matchStr[1])\\n    var template = matchStr[2].repeat(strCount)\\n\\n    s = s.slice(0, ind) + template + s.slice(ind + mLen, s.length)\\n  } \\n  \\n  return s\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2901887,
                "title": "codedominar-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        nums = \"0123456789\"\\n        stack = []\\n        for char in s:\\n            #print(stack)\\n            if char == \\']\\':\\n                temp_s = \\'\\'\\n                num=\\'\\'\\n                while stack[-1] != \\'[\\':\\n                    temp_s = stack.pop()+temp_s\\n                stack.pop()\\n                while stack and stack[-1] in nums:\\n                    num+= stack.pop()\\n                num = int(num[::-1])\\n                while num:\\n                    stack.append(temp_s)\\n                    num-=1\\n            else:\\n                stack.append(char)\\n        l = \"\".join(map(str,stack))\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        nums = \"0123456789\"\\n        stack = []\\n        for char in s:\\n            #print(stack)\\n            if char == \\']\\':\\n                temp_s = \\'\\'\\n                num=\\'\\'\\n                while stack[-1] != \\'[\\':\\n                    temp_s = stack.pop()+temp_s\\n                stack.pop()\\n                while stack and stack[-1] in nums:\\n                    num+= stack.pop()\\n                num = int(num[::-1])\\n                while num:\\n                    stack.append(temp_s)\\n                    num-=1\\n            else:\\n                stack.append(char)\\n        l = \"\".join(map(str,stack))\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890480,
                "title": "394-decode-string-solution-by-priyanka",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBy using Stacks for storing data and StringBuilder\\n# Complexity\\n- Time complexity:\\n- $$O(n*k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> numStack = new Stack();\\n        Stack<String> strStack = new Stack();\\n        StringBuilder sb = new StringBuilder();\\n        int len = s.length();\\n        for(int i=0;i< len ; i++){\\n            char ch = s.charAt(i);\\n            if(Character.isDigit(ch)){\\n                int num = ch -\\'0\\';\\n                while(i+1 <len && Character.isDigit(s.charAt(i+1))){\\n                    num = num*10 +s.charAt(i+1) - \\'0\\';\\n                    i++;\\n                }\\n                numStack.push(num);\\n            }else if(ch == \\'[\\'){\\n                strStack.push(sb.toString());\\n                sb = new StringBuilder();\\n            }else if(ch==\\']\\'){\\n                int k = numStack.pop();\\n                StringBuilder temp = new StringBuilder(strStack.pop());\\n                for(int j=0;j<k;j++){\\n                    temp.append(sb);\\n                }\\n                sb=temp;\\n            }else{\\n                sb.append(ch);\\n            }\\n        }    \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeString(String s) {\\n        Stack<Integer> numStack = new Stack();\\n        Stack<String> strStack = new Stack();\\n        StringBuilder sb = new StringBuilder();\\n        int len = s.length();\\n        for(int i=0;i< len ; i++){\\n            char ch = s.charAt(i);\\n            if(Character.isDigit(ch)){\\n                int num = ch -\\'0\\';\\n                while(i+1 <len && Character.isDigit(s.charAt(i+1))){\\n                    num = num*10 +s.charAt(i+1) - \\'0\\';\\n                    i++;\\n                }\\n                numStack.push(num);\\n            }else if(ch == \\'[\\'){\\n                strStack.push(sb.toString());\\n                sb = new StringBuilder();\\n            }else if(ch==\\']\\'){\\n                int k = numStack.pop();\\n                StringBuilder temp = new StringBuilder(strStack.pop());\\n                for(int j=0;j<k;j++){\\n                    temp.append(sb);\\n                }\\n                sb=temp;\\n            }else{\\n                sb.append(ch);\\n            }\\n        }    \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849363,
                "title": "decode-string-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeString(string str) {\\n      \\n      stack<string>st;\\n      string currstring=\"\",currnum=\"\";\\n\\n      for(auto i:str)\\n      {\\n        if(i==\\'[\\')\\n        {\\n          st.push(currstring);\\n          st.push(currnum);\\n\\n          currstring=\"\";\\n          currnum=\"\";\\n        }\\n        else if(i==\\']\\')\\n        {\\n           int num=stoi(st.top());\\n           st.pop();\\n           string prevstring =st.top();\\n           st.pop();\\n\\n           string temp=prevstring;\\n           for(int i=0;i<num;i++)\\n           {\\n             temp+=currstring;\\n           }\\n           currstring=temp;\\n        }\\n        else if(isdigit(i))\\n        {\\n          currnum+=i;\\n        }\\n        else\\n        {\\n          currstring+=i;\\n        }\\n      }\\n      return currstring;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeString(string str) {\\n      \\n      stack<string>st;\\n      string currstring=\"\",currnum=\"\";\\n\\n      for(auto i:str)\\n      {\\n        if(i==\\'[\\')\\n        {\\n          st.push(currstring);\\n          st.push(currnum);\\n\\n          currstring=\"\";\\n          currnum=\"\";\\n        }\\n        else if(i==\\']\\')\\n        {\\n           int num=stoi(st.top());\\n           st.pop();\\n           string prevstring =st.top();\\n           st.pop();\\n\\n           string temp=prevstring;\\n           for(int i=0;i<num;i++)\\n           {\\n             temp+=currstring;\\n           }\\n           currstring=temp;\\n        }\\n        else if(isdigit(i))\\n        {\\n          currnum+=i;\\n        }\\n        else\\n        {\\n          currstring+=i;\\n        }\\n      }\\n      return currstring;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1574402,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1567969,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1570173,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1576264,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1817605,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1566788,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1817631,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1566929,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1565722,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1819647,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1574402,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1567969,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1570173,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1576264,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1817605,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1566788,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1817631,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1566929,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1565722,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1819647,
                "content": [
                    {
                        "username": "daily_coder",
                        "content": "Many times I solve some problem and after few hours/days I find amazed of myself that how did I even solved/coded this complex problem earlier!! Had this feeling? Please tell me, so that I can feel no alien."
                    },
                    {
                        "username": "an5dy90",
                        "content": "many times I forgot how I solved complex problems like this days months later and I needed to solve it again  "
                    },
                    {
                        "username": "aruuu____",
                        "content": "yeah same :)\\n"
                    },
                    {
                        "username": "patel-vansh",
                        "content": "Yeah me too. Though I am beginner, I sometimes solve complex problems and after few days, I am amazed how did I solved."
                    },
                    {
                        "username": "Paleoanthropologist",
                        "content": "This is because you did not think through everything when you solved the problem initially. This happens a lot due to you have been band-aiding your code iteratively to achieve AC. "
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "at least you can solve it man"
                    },
                    {
                        "username": "Ranjan2002",
                        "content": "Ya  totally XD"
                    },
                    {
                        "username": "sahilbest999",
                        "content": "totally bro"
                    },
                    {
                        "username": "dengning1205",
                        "content": "Seems to be a lot harder than decode"
                    },
                    {
                        "username": "pbindal",
                        "content": "This is categorized under graph and trees. Looks like stacks and backtracking algo to me. Please correct if I am wrong"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1e9c82ea-4ff3-430b-a686-1be8a3e647f5_1642613017.35797.png)\\n\\n![image](https://assets.leetcode.com/users/images/5eee0955-2597-4439-8c87-8e0df45e461e_1642613023.443171.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d7645d9-4ef3-4875-810a-297d2f82a81a_1642613028.1248252.png)\\n\\n![image](https://assets.leetcode.com/users/images/5cec2dfd-2ec1-4ab6-9d9b-9a9b5f8e8d44_1642613031.8151512.png)\\n\\n![image](https://assets.leetcode.com/users/images/85c375af-7ac1-4006-b1f6-03da63b1d84a_1642613037.3188505.png)\\n\\n![image](https://assets.leetcode.com/users/images/42f7256e-f408-4c85-88f1-a029a32e7e4c_1642613048.1025255.png)\\n"
                    },
                    {
                        "username": "julyakovleva1107",
                        "content": "Hi! Could somebody please explain - how come we have s = \"3\" in the test cases if there are such constraints:\\n1) s consists of lowercase English letters, digits, AND square brackets \\'[]\\'.\\n2) s is guaranteed to be a valid input.\\n\\uD83E\\uDD14\\n"
                    },
                    {
                        "username": "Miryafa",
                        "content": "Well you're right - every number should be followed by brackets. The description specifically says \"there will not be input like 3a or 2[4]\", and '3' is an input like '2[4]', because if 3 is valid then 2[3] is too, so 2[4] must be too.\n\nAnd there's no input to the encoding function that can result in an encoded string of '3', so that's what I'd call an invalid test case that only avoids causing an error if you write your program the same way the author did."
                    },
                    {
                        "username": "cloudycandy",
                        "content": "Today I saw some people were asked the encoding as a follow up for leetcode #394 decode string. Most of the them only gave a brief direction during the interview and didn't write any code. But I would like to ask for more thoughts.\\n\\nI may think about using dynamic programming. For string s, the shortest encoding from the i<sup>th</sup> character to the j<sup>th</sup> character is denoted by dp[i][j], then we have:\\n* If i+2 > j, dp[i][j] = s[i-1:j ], i.e. just keep those characters.\\n* else If s[i-1:j ] can be represented as repeating patterns, then encode it as repeating_times[repeating_pattern], using the finest repeating pattern.\\n* otherwise dp[i][j] = min_length(dp[i][k] + dp[k+1][j]) where i < k < j\\n\\nIt runs in O(n<sup>3</sup>) time however, where n is the length of the string to be encoded.\\nDoes this work? What do you think about it?"
                    },
                    {
                        "username": "madfcat",
                        "content": "Does even the test case 34\\n\\ns = \"3\"\\n\\nmake sense?\\n\\nIt is said that \"s is guaranteed to be a valid input\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "Is \"3\" a testcase? My code passed all testcases but when I used \"3\" as a testcase directly, LeetCode came back with \"Invalid input\". Just as well. Had my code tried to run it, it would have pushed past the \"[\" (which in this case is actually the ASCII NULL character) and caused a segmentation fault;"
                    },
                    {
                        "username": "eLementarydew",
                        "content": "This was definitely a tricky test case . I think they were expecting what if there is nothing to decode . Any number followed by an empty string is still an empty string. Still a weird test case because of the question language."
                    },
                    {
                        "username": "ILoveBigBits",
                        "content": "Time complexity cannot depend only on the length of the input string.\\n**Time Complexity is also a function of the numbers that are represented inside the string**,\\n\\nSince **we are also appending characters to our final answer string**, consider this,\\n\\n\\n100[a101[b102[c]]]\\n\\n\\nHere the length of the string is 18, but in the final string we need to append approximately10^6 times.\\n\\n\\nGeneral Proof, \\n\\nLets consider an input of Length N\\nLet N\\' = N+1\\nconsider the string\\n**N[aN\\'[b]]**\\n\\n\\nHere we require atleast **N^2**, operations to append a and b to final string.\\n\\nA very bad upperbound is **O(N * ProductofAllNumbers * MaxDepthofRecursionTree)**\\n\\nIf someone has a better upper bound, or something is wrong with the above analysis please share!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Leetcode describes this as an invalid testcase - probably because the decoded string is longer than 10^5 characters."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/decode-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Using 2 Stack\n\n  \n**Approach 3:** Using Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "dlrudqhr7180",
                        "content": " I think test case 34 is invalid input (s = 3) while the problem indicates that \"s is guaranteed to be a valid input.\""
                    }
                ]
            },
            {
                "id": 1814231,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\n1.If the character is a closing square bracket ']', we pop characters off the stack until we find the corresponding opening square bracket '['. We then pop the opening bracket, the number before it (which specifies how many times the substring inside the brackets should be repeated), and the characters we just popped off the stack. We repeat this process until we have processed the entire string.\n\n2.Otherwise, if the character is not a closing square bracket ']', we push it onto the stack."
                    },
                    {
                        "username": "xaviesta",
                        "content": "Check the following test-case: `99[99[99[99[99[99[a]]]]]]`\\nIt follows the constraints but has a huge output that is not possible to execute. I guess the constraints in the question need to revisited or it should be mentioned that test cases are such that output won\\'t exceed a certain length like 10^6."
                    },
                    {
                        "username": "David_E_something",
                        "content": "Requirement states: The test cases are generated so that the length of the output will never exceed 10^5."
                    },
                    {
                        "username": "alexNotusDev",
                        "content": "Simple advise! We adding each char to stack till we get  `]`, in this case, we can start decoding by taking last values from stack, process them (crate string, and multiply to integer) and push back into stack, hope it will help you to find right direction."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Similar to Problem No 1190.\\nReverse Substrings Between Each Pair of Parentheses\\nDo this problem first ."
                    },
                    {
                        "username": "deleted_user",
                        "content": "https://github.com/saquib-ahsan/leetcode/blob/main/all-problems/394-Decode-String.cpp"
                    },
                    {
                        "username": "sha256pki",
                        "content": "Just wondering, a string processing plus so many corner cases to consider."
                    },
                    {
                        "username": "BristolJ",
                        "content": "If these are medium, I don\\'t want to see Hard"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "try this if you are having any issue \\nhttps://www.youtube.com/watch?v=qB0zZpBJlh8"
                    },
                    {
                        "username": "anvuong",
                        "content": "what is the constraint on k?"
                    },
                    {
                        "username": "subhamjaiswal_mnit",
                        "content": "stack<int>num;\\n      stack<char>str;\\n      string ans;\\n      int i=0;\\n      while(i<s.length()){\\n          if(s[i]-\\'0\\'>=0&&s[i]-\\'0\\'<=9){\\n              num.push(s[i]-\\'0\\');\\n          }\\n          else if(s[i]==\\'[\\'){// means we got the opening bracket\\n              int j=i;\\n              while(s[j]!=\\']\\'){// meanswe are not getting anyclose bracket\\n           if(s[j]-\\'0\\'>=0&&s[j]-\\'0\\'<=9){\\n              num.push(s[j]-\\'0\\');\\n              }\\n              else{\\n                 str.push(s[j]); \\n              }\\n              j++;\\n          }\\n             i=j;\\n          }\\n             else{\\n        if(s[i]==\\']\\'){\\n            while(str.top()!=\\'[\\'&&!str.empty()){\\n                ans.push_back(str.top());\\n                str.pop();\\n            }\\n            if(!num.empty()){\\n           int k =num.top();\\n           num.pop();\\n           int m=0;\\n           while(m<k){\\n               ans=ans+ans;\\n               m++;\\n           }\\n        }\\n        }\\n      }\\n      i++; \\n      }\\n      reverse(ans.begin(),ans.end());\\n      return ans; \\n    }\\n};\\n// can u please tell me the error\\n"
                    }
                ]
            },
            {
                "id": 1576447,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\n1.If the character is a closing square bracket ']', we pop characters off the stack until we find the corresponding opening square bracket '['. We then pop the opening bracket, the number before it (which specifies how many times the substring inside the brackets should be repeated), and the characters we just popped off the stack. We repeat this process until we have processed the entire string.\n\n2.Otherwise, if the character is not a closing square bracket ']', we push it onto the stack."
                    },
                    {
                        "username": "xaviesta",
                        "content": "Check the following test-case: `99[99[99[99[99[99[a]]]]]]`\\nIt follows the constraints but has a huge output that is not possible to execute. I guess the constraints in the question need to revisited or it should be mentioned that test cases are such that output won\\'t exceed a certain length like 10^6."
                    },
                    {
                        "username": "David_E_something",
                        "content": "Requirement states: The test cases are generated so that the length of the output will never exceed 10^5."
                    },
                    {
                        "username": "alexNotusDev",
                        "content": "Simple advise! We adding each char to stack till we get  `]`, in this case, we can start decoding by taking last values from stack, process them (crate string, and multiply to integer) and push back into stack, hope it will help you to find right direction."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Similar to Problem No 1190.\\nReverse Substrings Between Each Pair of Parentheses\\nDo this problem first ."
                    },
                    {
                        "username": "deleted_user",
                        "content": "https://github.com/saquib-ahsan/leetcode/blob/main/all-problems/394-Decode-String.cpp"
                    },
                    {
                        "username": "sha256pki",
                        "content": "Just wondering, a string processing plus so many corner cases to consider."
                    },
                    {
                        "username": "BristolJ",
                        "content": "If these are medium, I don\\'t want to see Hard"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "try this if you are having any issue \\nhttps://www.youtube.com/watch?v=qB0zZpBJlh8"
                    },
                    {
                        "username": "anvuong",
                        "content": "what is the constraint on k?"
                    },
                    {
                        "username": "subhamjaiswal_mnit",
                        "content": "stack<int>num;\\n      stack<char>str;\\n      string ans;\\n      int i=0;\\n      while(i<s.length()){\\n          if(s[i]-\\'0\\'>=0&&s[i]-\\'0\\'<=9){\\n              num.push(s[i]-\\'0\\');\\n          }\\n          else if(s[i]==\\'[\\'){// means we got the opening bracket\\n              int j=i;\\n              while(s[j]!=\\']\\'){// meanswe are not getting anyclose bracket\\n           if(s[j]-\\'0\\'>=0&&s[j]-\\'0\\'<=9){\\n              num.push(s[j]-\\'0\\');\\n              }\\n              else{\\n                 str.push(s[j]); \\n              }\\n              j++;\\n          }\\n             i=j;\\n          }\\n             else{\\n        if(s[i]==\\']\\'){\\n            while(str.top()!=\\'[\\'&&!str.empty()){\\n                ans.push_back(str.top());\\n                str.pop();\\n            }\\n            if(!num.empty()){\\n           int k =num.top();\\n           num.pop();\\n           int m=0;\\n           while(m<k){\\n               ans=ans+ans;\\n               m++;\\n           }\\n        }\\n        }\\n      }\\n      i++; \\n      }\\n      reverse(ans.begin(),ans.end());\\n      return ans; \\n    }\\n};\\n// can u please tell me the error\\n"
                    }
                ]
            },
            {
                "id": 2010793,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\n1.If the character is a closing square bracket ']', we pop characters off the stack until we find the corresponding opening square bracket '['. We then pop the opening bracket, the number before it (which specifies how many times the substring inside the brackets should be repeated), and the characters we just popped off the stack. We repeat this process until we have processed the entire string.\n\n2.Otherwise, if the character is not a closing square bracket ']', we push it onto the stack."
                    },
                    {
                        "username": "xaviesta",
                        "content": "Check the following test-case: `99[99[99[99[99[99[a]]]]]]`\\nIt follows the constraints but has a huge output that is not possible to execute. I guess the constraints in the question need to revisited or it should be mentioned that test cases are such that output won\\'t exceed a certain length like 10^6."
                    },
                    {
                        "username": "David_E_something",
                        "content": "Requirement states: The test cases are generated so that the length of the output will never exceed 10^5."
                    },
                    {
                        "username": "alexNotusDev",
                        "content": "Simple advise! We adding each char to stack till we get  `]`, in this case, we can start decoding by taking last values from stack, process them (crate string, and multiply to integer) and push back into stack, hope it will help you to find right direction."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Similar to Problem No 1190.\\nReverse Substrings Between Each Pair of Parentheses\\nDo this problem first ."
                    },
                    {
                        "username": "deleted_user",
                        "content": "https://github.com/saquib-ahsan/leetcode/blob/main/all-problems/394-Decode-String.cpp"
                    },
                    {
                        "username": "sha256pki",
                        "content": "Just wondering, a string processing plus so many corner cases to consider."
                    },
                    {
                        "username": "BristolJ",
                        "content": "If these are medium, I don\\'t want to see Hard"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "try this if you are having any issue \\nhttps://www.youtube.com/watch?v=qB0zZpBJlh8"
                    },
                    {
                        "username": "anvuong",
                        "content": "what is the constraint on k?"
                    },
                    {
                        "username": "subhamjaiswal_mnit",
                        "content": "stack<int>num;\\n      stack<char>str;\\n      string ans;\\n      int i=0;\\n      while(i<s.length()){\\n          if(s[i]-\\'0\\'>=0&&s[i]-\\'0\\'<=9){\\n              num.push(s[i]-\\'0\\');\\n          }\\n          else if(s[i]==\\'[\\'){// means we got the opening bracket\\n              int j=i;\\n              while(s[j]!=\\']\\'){// meanswe are not getting anyclose bracket\\n           if(s[j]-\\'0\\'>=0&&s[j]-\\'0\\'<=9){\\n              num.push(s[j]-\\'0\\');\\n              }\\n              else{\\n                 str.push(s[j]); \\n              }\\n              j++;\\n          }\\n             i=j;\\n          }\\n             else{\\n        if(s[i]==\\']\\'){\\n            while(str.top()!=\\'[\\'&&!str.empty()){\\n                ans.push_back(str.top());\\n                str.pop();\\n            }\\n            if(!num.empty()){\\n           int k =num.top();\\n           num.pop();\\n           int m=0;\\n           while(m<k){\\n               ans=ans+ans;\\n               m++;\\n           }\\n        }\\n        }\\n      }\\n      i++; \\n      }\\n      reverse(ans.begin(),ans.end());\\n      return ans; \\n    }\\n};\\n// can u please tell me the error\\n"
                    }
                ]
            },
            {
                "id": 1828835,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\n1.If the character is a closing square bracket ']', we pop characters off the stack until we find the corresponding opening square bracket '['. We then pop the opening bracket, the number before it (which specifies how many times the substring inside the brackets should be repeated), and the characters we just popped off the stack. We repeat this process until we have processed the entire string.\n\n2.Otherwise, if the character is not a closing square bracket ']', we push it onto the stack."
                    },
                    {
                        "username": "xaviesta",
                        "content": "Check the following test-case: `99[99[99[99[99[99[a]]]]]]`\\nIt follows the constraints but has a huge output that is not possible to execute. I guess the constraints in the question need to revisited or it should be mentioned that test cases are such that output won\\'t exceed a certain length like 10^6."
                    },
                    {
                        "username": "David_E_something",
                        "content": "Requirement states: The test cases are generated so that the length of the output will never exceed 10^5."
                    },
                    {
                        "username": "alexNotusDev",
                        "content": "Simple advise! We adding each char to stack till we get  `]`, in this case, we can start decoding by taking last values from stack, process them (crate string, and multiply to integer) and push back into stack, hope it will help you to find right direction."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Similar to Problem No 1190.\\nReverse Substrings Between Each Pair of Parentheses\\nDo this problem first ."
                    },
                    {
                        "username": "deleted_user",
                        "content": "https://github.com/saquib-ahsan/leetcode/blob/main/all-problems/394-Decode-String.cpp"
                    },
                    {
                        "username": "sha256pki",
                        "content": "Just wondering, a string processing plus so many corner cases to consider."
                    },
                    {
                        "username": "BristolJ",
                        "content": "If these are medium, I don\\'t want to see Hard"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "try this if you are having any issue \\nhttps://www.youtube.com/watch?v=qB0zZpBJlh8"
                    },
                    {
                        "username": "anvuong",
                        "content": "what is the constraint on k?"
                    },
                    {
                        "username": "subhamjaiswal_mnit",
                        "content": "stack<int>num;\\n      stack<char>str;\\n      string ans;\\n      int i=0;\\n      while(i<s.length()){\\n          if(s[i]-\\'0\\'>=0&&s[i]-\\'0\\'<=9){\\n              num.push(s[i]-\\'0\\');\\n          }\\n          else if(s[i]==\\'[\\'){// means we got the opening bracket\\n              int j=i;\\n              while(s[j]!=\\']\\'){// meanswe are not getting anyclose bracket\\n           if(s[j]-\\'0\\'>=0&&s[j]-\\'0\\'<=9){\\n              num.push(s[j]-\\'0\\');\\n              }\\n              else{\\n                 str.push(s[j]); \\n              }\\n              j++;\\n          }\\n             i=j;\\n          }\\n             else{\\n        if(s[i]==\\']\\'){\\n            while(str.top()!=\\'[\\'&&!str.empty()){\\n                ans.push_back(str.top());\\n                str.pop();\\n            }\\n            if(!num.empty()){\\n           int k =num.top();\\n           num.pop();\\n           int m=0;\\n           while(m<k){\\n               ans=ans+ans;\\n               m++;\\n           }\\n        }\\n        }\\n      }\\n      i++; \\n      }\\n      reverse(ans.begin(),ans.end());\\n      return ans; \\n    }\\n};\\n// can u please tell me the error\\n"
                    }
                ]
            },
            {
                "id": 1576720,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\n1.If the character is a closing square bracket ']', we pop characters off the stack until we find the corresponding opening square bracket '['. We then pop the opening bracket, the number before it (which specifies how many times the substring inside the brackets should be repeated), and the characters we just popped off the stack. We repeat this process until we have processed the entire string.\n\n2.Otherwise, if the character is not a closing square bracket ']', we push it onto the stack."
                    },
                    {
                        "username": "xaviesta",
                        "content": "Check the following test-case: `99[99[99[99[99[99[a]]]]]]`\\nIt follows the constraints but has a huge output that is not possible to execute. I guess the constraints in the question need to revisited or it should be mentioned that test cases are such that output won\\'t exceed a certain length like 10^6."
                    },
                    {
                        "username": "David_E_something",
                        "content": "Requirement states: The test cases are generated so that the length of the output will never exceed 10^5."
                    },
                    {
                        "username": "alexNotusDev",
                        "content": "Simple advise! We adding each char to stack till we get  `]`, in this case, we can start decoding by taking last values from stack, process them (crate string, and multiply to integer) and push back into stack, hope it will help you to find right direction."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Similar to Problem No 1190.\\nReverse Substrings Between Each Pair of Parentheses\\nDo this problem first ."
                    },
                    {
                        "username": "deleted_user",
                        "content": "https://github.com/saquib-ahsan/leetcode/blob/main/all-problems/394-Decode-String.cpp"
                    },
                    {
                        "username": "sha256pki",
                        "content": "Just wondering, a string processing plus so many corner cases to consider."
                    },
                    {
                        "username": "BristolJ",
                        "content": "If these are medium, I don\\'t want to see Hard"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "try this if you are having any issue \\nhttps://www.youtube.com/watch?v=qB0zZpBJlh8"
                    },
                    {
                        "username": "anvuong",
                        "content": "what is the constraint on k?"
                    },
                    {
                        "username": "subhamjaiswal_mnit",
                        "content": "stack<int>num;\\n      stack<char>str;\\n      string ans;\\n      int i=0;\\n      while(i<s.length()){\\n          if(s[i]-\\'0\\'>=0&&s[i]-\\'0\\'<=9){\\n              num.push(s[i]-\\'0\\');\\n          }\\n          else if(s[i]==\\'[\\'){// means we got the opening bracket\\n              int j=i;\\n              while(s[j]!=\\']\\'){// meanswe are not getting anyclose bracket\\n           if(s[j]-\\'0\\'>=0&&s[j]-\\'0\\'<=9){\\n              num.push(s[j]-\\'0\\');\\n              }\\n              else{\\n                 str.push(s[j]); \\n              }\\n              j++;\\n          }\\n             i=j;\\n          }\\n             else{\\n        if(s[i]==\\']\\'){\\n            while(str.top()!=\\'[\\'&&!str.empty()){\\n                ans.push_back(str.top());\\n                str.pop();\\n            }\\n            if(!num.empty()){\\n           int k =num.top();\\n           num.pop();\\n           int m=0;\\n           while(m<k){\\n               ans=ans+ans;\\n               m++;\\n           }\\n        }\\n        }\\n      }\\n      i++; \\n      }\\n      reverse(ans.begin(),ans.end());\\n      return ans; \\n    }\\n};\\n// can u please tell me the error\\n"
                    }
                ]
            },
            {
                "id": 1571667,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\n1.If the character is a closing square bracket ']', we pop characters off the stack until we find the corresponding opening square bracket '['. We then pop the opening bracket, the number before it (which specifies how many times the substring inside the brackets should be repeated), and the characters we just popped off the stack. We repeat this process until we have processed the entire string.\n\n2.Otherwise, if the character is not a closing square bracket ']', we push it onto the stack."
                    },
                    {
                        "username": "xaviesta",
                        "content": "Check the following test-case: `99[99[99[99[99[99[a]]]]]]`\\nIt follows the constraints but has a huge output that is not possible to execute. I guess the constraints in the question need to revisited or it should be mentioned that test cases are such that output won\\'t exceed a certain length like 10^6."
                    },
                    {
                        "username": "David_E_something",
                        "content": "Requirement states: The test cases are generated so that the length of the output will never exceed 10^5."
                    },
                    {
                        "username": "alexNotusDev",
                        "content": "Simple advise! We adding each char to stack till we get  `]`, in this case, we can start decoding by taking last values from stack, process them (crate string, and multiply to integer) and push back into stack, hope it will help you to find right direction."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Similar to Problem No 1190.\\nReverse Substrings Between Each Pair of Parentheses\\nDo this problem first ."
                    },
                    {
                        "username": "deleted_user",
                        "content": "https://github.com/saquib-ahsan/leetcode/blob/main/all-problems/394-Decode-String.cpp"
                    },
                    {
                        "username": "sha256pki",
                        "content": "Just wondering, a string processing plus so many corner cases to consider."
                    },
                    {
                        "username": "BristolJ",
                        "content": "If these are medium, I don\\'t want to see Hard"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "try this if you are having any issue \\nhttps://www.youtube.com/watch?v=qB0zZpBJlh8"
                    },
                    {
                        "username": "anvuong",
                        "content": "what is the constraint on k?"
                    },
                    {
                        "username": "subhamjaiswal_mnit",
                        "content": "stack<int>num;\\n      stack<char>str;\\n      string ans;\\n      int i=0;\\n      while(i<s.length()){\\n          if(s[i]-\\'0\\'>=0&&s[i]-\\'0\\'<=9){\\n              num.push(s[i]-\\'0\\');\\n          }\\n          else if(s[i]==\\'[\\'){// means we got the opening bracket\\n              int j=i;\\n              while(s[j]!=\\']\\'){// meanswe are not getting anyclose bracket\\n           if(s[j]-\\'0\\'>=0&&s[j]-\\'0\\'<=9){\\n              num.push(s[j]-\\'0\\');\\n              }\\n              else{\\n                 str.push(s[j]); \\n              }\\n              j++;\\n          }\\n             i=j;\\n          }\\n             else{\\n        if(s[i]==\\']\\'){\\n            while(str.top()!=\\'[\\'&&!str.empty()){\\n                ans.push_back(str.top());\\n                str.pop();\\n            }\\n            if(!num.empty()){\\n           int k =num.top();\\n           num.pop();\\n           int m=0;\\n           while(m<k){\\n               ans=ans+ans;\\n               m++;\\n           }\\n        }\\n        }\\n      }\\n      i++; \\n      }\\n      reverse(ans.begin(),ans.end());\\n      return ans; \\n    }\\n};\\n// can u please tell me the error\\n"
                    }
                ]
            },
            {
                "id": 2075834,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\n1.If the character is a closing square bracket ']', we pop characters off the stack until we find the corresponding opening square bracket '['. We then pop the opening bracket, the number before it (which specifies how many times the substring inside the brackets should be repeated), and the characters we just popped off the stack. We repeat this process until we have processed the entire string.\n\n2.Otherwise, if the character is not a closing square bracket ']', we push it onto the stack."
                    },
                    {
                        "username": "xaviesta",
                        "content": "Check the following test-case: `99[99[99[99[99[99[a]]]]]]`\\nIt follows the constraints but has a huge output that is not possible to execute. I guess the constraints in the question need to revisited or it should be mentioned that test cases are such that output won\\'t exceed a certain length like 10^6."
                    },
                    {
                        "username": "David_E_something",
                        "content": "Requirement states: The test cases are generated so that the length of the output will never exceed 10^5."
                    },
                    {
                        "username": "alexNotusDev",
                        "content": "Simple advise! We adding each char to stack till we get  `]`, in this case, we can start decoding by taking last values from stack, process them (crate string, and multiply to integer) and push back into stack, hope it will help you to find right direction."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Similar to Problem No 1190.\\nReverse Substrings Between Each Pair of Parentheses\\nDo this problem first ."
                    },
                    {
                        "username": "deleted_user",
                        "content": "https://github.com/saquib-ahsan/leetcode/blob/main/all-problems/394-Decode-String.cpp"
                    },
                    {
                        "username": "sha256pki",
                        "content": "Just wondering, a string processing plus so many corner cases to consider."
                    },
                    {
                        "username": "BristolJ",
                        "content": "If these are medium, I don\\'t want to see Hard"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "try this if you are having any issue \\nhttps://www.youtube.com/watch?v=qB0zZpBJlh8"
                    },
                    {
                        "username": "anvuong",
                        "content": "what is the constraint on k?"
                    },
                    {
                        "username": "subhamjaiswal_mnit",
                        "content": "stack<int>num;\\n      stack<char>str;\\n      string ans;\\n      int i=0;\\n      while(i<s.length()){\\n          if(s[i]-\\'0\\'>=0&&s[i]-\\'0\\'<=9){\\n              num.push(s[i]-\\'0\\');\\n          }\\n          else if(s[i]==\\'[\\'){// means we got the opening bracket\\n              int j=i;\\n              while(s[j]!=\\']\\'){// meanswe are not getting anyclose bracket\\n           if(s[j]-\\'0\\'>=0&&s[j]-\\'0\\'<=9){\\n              num.push(s[j]-\\'0\\');\\n              }\\n              else{\\n                 str.push(s[j]); \\n              }\\n              j++;\\n          }\\n             i=j;\\n          }\\n             else{\\n        if(s[i]==\\']\\'){\\n            while(str.top()!=\\'[\\'&&!str.empty()){\\n                ans.push_back(str.top());\\n                str.pop();\\n            }\\n            if(!num.empty()){\\n           int k =num.top();\\n           num.pop();\\n           int m=0;\\n           while(m<k){\\n               ans=ans+ans;\\n               m++;\\n           }\\n        }\\n        }\\n      }\\n      i++; \\n      }\\n      reverse(ans.begin(),ans.end());\\n      return ans; \\n    }\\n};\\n// can u please tell me the error\\n"
                    }
                ]
            },
            {
                "id": 2060537,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\n1.If the character is a closing square bracket ']', we pop characters off the stack until we find the corresponding opening square bracket '['. We then pop the opening bracket, the number before it (which specifies how many times the substring inside the brackets should be repeated), and the characters we just popped off the stack. We repeat this process until we have processed the entire string.\n\n2.Otherwise, if the character is not a closing square bracket ']', we push it onto the stack."
                    },
                    {
                        "username": "xaviesta",
                        "content": "Check the following test-case: `99[99[99[99[99[99[a]]]]]]`\\nIt follows the constraints but has a huge output that is not possible to execute. I guess the constraints in the question need to revisited or it should be mentioned that test cases are such that output won\\'t exceed a certain length like 10^6."
                    },
                    {
                        "username": "David_E_something",
                        "content": "Requirement states: The test cases are generated so that the length of the output will never exceed 10^5."
                    },
                    {
                        "username": "alexNotusDev",
                        "content": "Simple advise! We adding each char to stack till we get  `]`, in this case, we can start decoding by taking last values from stack, process them (crate string, and multiply to integer) and push back into stack, hope it will help you to find right direction."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Similar to Problem No 1190.\\nReverse Substrings Between Each Pair of Parentheses\\nDo this problem first ."
                    },
                    {
                        "username": "deleted_user",
                        "content": "https://github.com/saquib-ahsan/leetcode/blob/main/all-problems/394-Decode-String.cpp"
                    },
                    {
                        "username": "sha256pki",
                        "content": "Just wondering, a string processing plus so many corner cases to consider."
                    },
                    {
                        "username": "BristolJ",
                        "content": "If these are medium, I don\\'t want to see Hard"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "try this if you are having any issue \\nhttps://www.youtube.com/watch?v=qB0zZpBJlh8"
                    },
                    {
                        "username": "anvuong",
                        "content": "what is the constraint on k?"
                    },
                    {
                        "username": "subhamjaiswal_mnit",
                        "content": "stack<int>num;\\n      stack<char>str;\\n      string ans;\\n      int i=0;\\n      while(i<s.length()){\\n          if(s[i]-\\'0\\'>=0&&s[i]-\\'0\\'<=9){\\n              num.push(s[i]-\\'0\\');\\n          }\\n          else if(s[i]==\\'[\\'){// means we got the opening bracket\\n              int j=i;\\n              while(s[j]!=\\']\\'){// meanswe are not getting anyclose bracket\\n           if(s[j]-\\'0\\'>=0&&s[j]-\\'0\\'<=9){\\n              num.push(s[j]-\\'0\\');\\n              }\\n              else{\\n                 str.push(s[j]); \\n              }\\n              j++;\\n          }\\n             i=j;\\n          }\\n             else{\\n        if(s[i]==\\']\\'){\\n            while(str.top()!=\\'[\\'&&!str.empty()){\\n                ans.push_back(str.top());\\n                str.pop();\\n            }\\n            if(!num.empty()){\\n           int k =num.top();\\n           num.pop();\\n           int m=0;\\n           while(m<k){\\n               ans=ans+ans;\\n               m++;\\n           }\\n        }\\n        }\\n      }\\n      i++; \\n      }\\n      reverse(ans.begin(),ans.end());\\n      return ans; \\n    }\\n};\\n// can u please tell me the error\\n"
                    }
                ]
            },
            {
                "id": 2056746,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\n1.If the character is a closing square bracket ']', we pop characters off the stack until we find the corresponding opening square bracket '['. We then pop the opening bracket, the number before it (which specifies how many times the substring inside the brackets should be repeated), and the characters we just popped off the stack. We repeat this process until we have processed the entire string.\n\n2.Otherwise, if the character is not a closing square bracket ']', we push it onto the stack."
                    },
                    {
                        "username": "xaviesta",
                        "content": "Check the following test-case: `99[99[99[99[99[99[a]]]]]]`\\nIt follows the constraints but has a huge output that is not possible to execute. I guess the constraints in the question need to revisited or it should be mentioned that test cases are such that output won\\'t exceed a certain length like 10^6."
                    },
                    {
                        "username": "David_E_something",
                        "content": "Requirement states: The test cases are generated so that the length of the output will never exceed 10^5."
                    },
                    {
                        "username": "alexNotusDev",
                        "content": "Simple advise! We adding each char to stack till we get  `]`, in this case, we can start decoding by taking last values from stack, process them (crate string, and multiply to integer) and push back into stack, hope it will help you to find right direction."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Similar to Problem No 1190.\\nReverse Substrings Between Each Pair of Parentheses\\nDo this problem first ."
                    },
                    {
                        "username": "deleted_user",
                        "content": "https://github.com/saquib-ahsan/leetcode/blob/main/all-problems/394-Decode-String.cpp"
                    },
                    {
                        "username": "sha256pki",
                        "content": "Just wondering, a string processing plus so many corner cases to consider."
                    },
                    {
                        "username": "BristolJ",
                        "content": "If these are medium, I don\\'t want to see Hard"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "try this if you are having any issue \\nhttps://www.youtube.com/watch?v=qB0zZpBJlh8"
                    },
                    {
                        "username": "anvuong",
                        "content": "what is the constraint on k?"
                    },
                    {
                        "username": "subhamjaiswal_mnit",
                        "content": "stack<int>num;\\n      stack<char>str;\\n      string ans;\\n      int i=0;\\n      while(i<s.length()){\\n          if(s[i]-\\'0\\'>=0&&s[i]-\\'0\\'<=9){\\n              num.push(s[i]-\\'0\\');\\n          }\\n          else if(s[i]==\\'[\\'){// means we got the opening bracket\\n              int j=i;\\n              while(s[j]!=\\']\\'){// meanswe are not getting anyclose bracket\\n           if(s[j]-\\'0\\'>=0&&s[j]-\\'0\\'<=9){\\n              num.push(s[j]-\\'0\\');\\n              }\\n              else{\\n                 str.push(s[j]); \\n              }\\n              j++;\\n          }\\n             i=j;\\n          }\\n             else{\\n        if(s[i]==\\']\\'){\\n            while(str.top()!=\\'[\\'&&!str.empty()){\\n                ans.push_back(str.top());\\n                str.pop();\\n            }\\n            if(!num.empty()){\\n           int k =num.top();\\n           num.pop();\\n           int m=0;\\n           while(m<k){\\n               ans=ans+ans;\\n               m++;\\n           }\\n        }\\n        }\\n      }\\n      i++; \\n      }\\n      reverse(ans.begin(),ans.end());\\n      return ans; \\n    }\\n};\\n// can u please tell me the error\\n"
                    }
                ]
            },
            {
                "id": 2037271,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\n1.If the character is a closing square bracket ']', we pop characters off the stack until we find the corresponding opening square bracket '['. We then pop the opening bracket, the number before it (which specifies how many times the substring inside the brackets should be repeated), and the characters we just popped off the stack. We repeat this process until we have processed the entire string.\n\n2.Otherwise, if the character is not a closing square bracket ']', we push it onto the stack."
                    },
                    {
                        "username": "xaviesta",
                        "content": "Check the following test-case: `99[99[99[99[99[99[a]]]]]]`\\nIt follows the constraints but has a huge output that is not possible to execute. I guess the constraints in the question need to revisited or it should be mentioned that test cases are such that output won\\'t exceed a certain length like 10^6."
                    },
                    {
                        "username": "David_E_something",
                        "content": "Requirement states: The test cases are generated so that the length of the output will never exceed 10^5."
                    },
                    {
                        "username": "alexNotusDev",
                        "content": "Simple advise! We adding each char to stack till we get  `]`, in this case, we can start decoding by taking last values from stack, process them (crate string, and multiply to integer) and push back into stack, hope it will help you to find right direction."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Similar to Problem No 1190.\\nReverse Substrings Between Each Pair of Parentheses\\nDo this problem first ."
                    },
                    {
                        "username": "deleted_user",
                        "content": "https://github.com/saquib-ahsan/leetcode/blob/main/all-problems/394-Decode-String.cpp"
                    },
                    {
                        "username": "sha256pki",
                        "content": "Just wondering, a string processing plus so many corner cases to consider."
                    },
                    {
                        "username": "BristolJ",
                        "content": "If these are medium, I don\\'t want to see Hard"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "try this if you are having any issue \\nhttps://www.youtube.com/watch?v=qB0zZpBJlh8"
                    },
                    {
                        "username": "anvuong",
                        "content": "what is the constraint on k?"
                    },
                    {
                        "username": "subhamjaiswal_mnit",
                        "content": "stack<int>num;\\n      stack<char>str;\\n      string ans;\\n      int i=0;\\n      while(i<s.length()){\\n          if(s[i]-\\'0\\'>=0&&s[i]-\\'0\\'<=9){\\n              num.push(s[i]-\\'0\\');\\n          }\\n          else if(s[i]==\\'[\\'){// means we got the opening bracket\\n              int j=i;\\n              while(s[j]!=\\']\\'){// meanswe are not getting anyclose bracket\\n           if(s[j]-\\'0\\'>=0&&s[j]-\\'0\\'<=9){\\n              num.push(s[j]-\\'0\\');\\n              }\\n              else{\\n                 str.push(s[j]); \\n              }\\n              j++;\\n          }\\n             i=j;\\n          }\\n             else{\\n        if(s[i]==\\']\\'){\\n            while(str.top()!=\\'[\\'&&!str.empty()){\\n                ans.push_back(str.top());\\n                str.pop();\\n            }\\n            if(!num.empty()){\\n           int k =num.top();\\n           num.pop();\\n           int m=0;\\n           while(m<k){\\n               ans=ans+ans;\\n               m++;\\n           }\\n        }\\n        }\\n      }\\n      i++; \\n      }\\n      reverse(ans.begin(),ans.end());\\n      return ans; \\n    }\\n};\\n// can u please tell me the error\\n"
                    }
                ]
            },
            {
                "id": 2025578,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Here is the Hint\n1. push elements to the stack until meet ']'\n2. pop elements from the stack until meet '[' => contents\n3. pop elements digitals from the stack => number\n4. repeat \"contents\" by \"number\" times and push to the stack\nrepeat step 1 to 4"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "quite interesting problem"
                    },
                    {
                        "username": "puneet-yadav",
                        "content": "I am getting mle for this code,, can anyone tell why i am getting mle?\\n Stack<Character> encodedChar = new Stack<>();\\n        //Stack<Integer> times = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n      //  int n = s.length();\\n        for(char c: s.toCharArray()){\\n                if(c==\\']\\'){\\n                StringBuilder toDecode = new StringBuilder();\\n                while(encodedChar.peek()!=\\'[\\'){\\n                    char x = encodedChar.peek();\\n                    encodedChar.pop();\\n                    //toDecode = x + toDecode;\\n                    toDecode.append(x);\\n                }\\n                toDecode = toDecode.reverse();\\n                encodedChar.pop();\\n                if(Character.isDigit(encodedChar.peek())){\\n                    int time = (int)encodedChar.peek();\\n                    encodedChar.pop();\\n                    for(int i=0;i<time;i++){\\n                        toDecode.append(toDecode);\\n                    }\\n                }\\n                else{\\n                    ans.append(toDecode);\\n                    continue;\\n                }\\n                ans.append(toDecode);\\n            }\\n            else{\\n                encodedChar.push(c);\\n                continue;\\n            }\\n        }\\n        if(!encodedChar.isEmpty()){\\n            StringBuilder remaining = new StringBuilder();\\n            while(!encodedChar.isEmpty()){\\n               // remaining = encodedChar.peek() + remaining;\\n            \\tremaining.append(encodedChar.peek());\\n                encodedChar.pop();\\n            }\\n            ans.append(remaining.reverse());\\n        }\\n        return ans.toString();"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "class Solution {\\npublic:\\n\\n    string decodeString(string s) \\n    {\\n        if(s.length()==1 && isalpha(s[0])){return s;}\\n        stack<char> st;\\n        string temp=\"\",res=\"\";\\n        int i=0,k_time=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            temp=\"\";\\n            while(s[i]!=\\']\\' && i<s.length())\\n            {\\n                st.push(s[i]);\\n                i++;    \\n            }\\n            i++;\\n            temp=\"\";\\n            while(st.top()!=\\'[\\' && !st.empty())\\n            {\\n                temp+=st.top();\\n                st.pop();\\n            }\\n\\n            st.pop();\\n            if(temp.length()>1)\\n            {\\n                reverse(temp.begin(),temp.end());\\n            }\\n            \\n            \\n            string num=\"\";\\n\\n            if(!st.empty())\\n            {\\n                num=num+st.top();\\n                st.pop();\\n                k_time= stoi(num);\\n            }\\n            \\n\\n            while(k_time>0)\\n            {\\n                res = res + temp;\\n                k_time--;\\n            }    \\n        }\\n        reverse(res.begin(),res.end());\\n        return res;    \\n    }\\n};\\n\\ncan somebody please explain what\\'s wrong with this code, I am getting a Runtime error indicating DEADLYSIGNAL with an error of SEGV on unknown address."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "please dont post your solutions in here ..\\n"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "[@ritikthakur09](/ritikthakur09) It didn\\'t work, but thanks for a new concept. "
                    },
                    {
                        "username": "ritikthakur09",
                        "content": "while(st.top()!=\\'[\\' && !st.empty()) \\nwrite it as while( !st.empty() && st.top()!=\\'[\\') instead since you need to check if it is empty first and not opposite."
                    },
                    {
                        "username": "dimitars",
                        "content": "Giving an input \"300[300[300[300[300[99[a]]]]]]\" returns an error reading \"The length of the output should not exceed 10^5.\"\\n\\nMaybe it would improve the description if this is mentioned there, considering I\\'m not missing some site-wide constraint."
                    },
                    {
                        "username": "d_e_v_i_l_07",
                        "content": "class Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        int ln= s.size();\\n        if(s.size()==1 && (s>=string(1,\\'0\\') && s<=string(1,\\'9\\')))\\n        return \"\";\\n        int check=0;\\n        for(int i=0;i<ln;i++){\\n            if(s[i]!= \\']\\') st.push(string(1,s[i]));\\n            else{\\n                //finding nested problem,ie string inside []\\n                string temp=\"\";\\n                while(st.top()!= string(1,\\'[\\')){\\n                    temp+= st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n                \\n                //finding number\\n                string num=\"\";\\n                while(!st.empty() && (st.top()>=string(1,\\'0\\') && st.top()<=string(1,\\'9\\'))){\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                \\n                int n= num.size()!=0? stoi(num): 1;\\n                string toPush= \"\";\\n                for(int i=0;i<n;i++)toPush+= temp;\\n                reverse(toPush.begin(),toPush.end());\\n                st.push(toPush);\\n                check = 1;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        // if(!check)\\n        // return \"\";\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Kaivalya",
                        "content": "Is  this valid input as a test case ? if yes then how it can be handled using stack ? 8th index of below input will try to get value from stack which is 2.\\n\\n2[[12[a]]bc] "
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "this is an invalid input."
                    },
                    {
                        "username": "keratonjava",
                        "content": "This is probably the hardest exercice so far, tips use recursion"
                    },
                    {
                        "username": "abhayx2910",
                        "content": "this is a pseudocode for this problem  for beginners\\n\\nfirst make a stack st,\\nrun a loop from 0->string length\\n       When \\']\\' is encountered, we need to start decoding\\n              run a while loop till we encounter \\'[\\'\\n                st.top() + temp makes sure that the string won\\'t be in reverse order eg, if the stack contains 12[abc temp = c + \"\" =>temp = b + \"c\"=>  temp = a + \"bc\"\\n        remove the [ from stack\\n         remove the digits from the stack\\n        if s[i] is not \\']\\', simply push s[i] to the stack\\n return the resultant string"
                    }
                ]
            },
            {
                "id": 1980730,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Here is the Hint\n1. push elements to the stack until meet ']'\n2. pop elements from the stack until meet '[' => contents\n3. pop elements digitals from the stack => number\n4. repeat \"contents\" by \"number\" times and push to the stack\nrepeat step 1 to 4"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "quite interesting problem"
                    },
                    {
                        "username": "puneet-yadav",
                        "content": "I am getting mle for this code,, can anyone tell why i am getting mle?\\n Stack<Character> encodedChar = new Stack<>();\\n        //Stack<Integer> times = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n      //  int n = s.length();\\n        for(char c: s.toCharArray()){\\n                if(c==\\']\\'){\\n                StringBuilder toDecode = new StringBuilder();\\n                while(encodedChar.peek()!=\\'[\\'){\\n                    char x = encodedChar.peek();\\n                    encodedChar.pop();\\n                    //toDecode = x + toDecode;\\n                    toDecode.append(x);\\n                }\\n                toDecode = toDecode.reverse();\\n                encodedChar.pop();\\n                if(Character.isDigit(encodedChar.peek())){\\n                    int time = (int)encodedChar.peek();\\n                    encodedChar.pop();\\n                    for(int i=0;i<time;i++){\\n                        toDecode.append(toDecode);\\n                    }\\n                }\\n                else{\\n                    ans.append(toDecode);\\n                    continue;\\n                }\\n                ans.append(toDecode);\\n            }\\n            else{\\n                encodedChar.push(c);\\n                continue;\\n            }\\n        }\\n        if(!encodedChar.isEmpty()){\\n            StringBuilder remaining = new StringBuilder();\\n            while(!encodedChar.isEmpty()){\\n               // remaining = encodedChar.peek() + remaining;\\n            \\tremaining.append(encodedChar.peek());\\n                encodedChar.pop();\\n            }\\n            ans.append(remaining.reverse());\\n        }\\n        return ans.toString();"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "class Solution {\\npublic:\\n\\n    string decodeString(string s) \\n    {\\n        if(s.length()==1 && isalpha(s[0])){return s;}\\n        stack<char> st;\\n        string temp=\"\",res=\"\";\\n        int i=0,k_time=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            temp=\"\";\\n            while(s[i]!=\\']\\' && i<s.length())\\n            {\\n                st.push(s[i]);\\n                i++;    \\n            }\\n            i++;\\n            temp=\"\";\\n            while(st.top()!=\\'[\\' && !st.empty())\\n            {\\n                temp+=st.top();\\n                st.pop();\\n            }\\n\\n            st.pop();\\n            if(temp.length()>1)\\n            {\\n                reverse(temp.begin(),temp.end());\\n            }\\n            \\n            \\n            string num=\"\";\\n\\n            if(!st.empty())\\n            {\\n                num=num+st.top();\\n                st.pop();\\n                k_time= stoi(num);\\n            }\\n            \\n\\n            while(k_time>0)\\n            {\\n                res = res + temp;\\n                k_time--;\\n            }    \\n        }\\n        reverse(res.begin(),res.end());\\n        return res;    \\n    }\\n};\\n\\ncan somebody please explain what\\'s wrong with this code, I am getting a Runtime error indicating DEADLYSIGNAL with an error of SEGV on unknown address."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "please dont post your solutions in here ..\\n"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "[@ritikthakur09](/ritikthakur09) It didn\\'t work, but thanks for a new concept. "
                    },
                    {
                        "username": "ritikthakur09",
                        "content": "while(st.top()!=\\'[\\' && !st.empty()) \\nwrite it as while( !st.empty() && st.top()!=\\'[\\') instead since you need to check if it is empty first and not opposite."
                    },
                    {
                        "username": "dimitars",
                        "content": "Giving an input \"300[300[300[300[300[99[a]]]]]]\" returns an error reading \"The length of the output should not exceed 10^5.\"\\n\\nMaybe it would improve the description if this is mentioned there, considering I\\'m not missing some site-wide constraint."
                    },
                    {
                        "username": "d_e_v_i_l_07",
                        "content": "class Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        int ln= s.size();\\n        if(s.size()==1 && (s>=string(1,\\'0\\') && s<=string(1,\\'9\\')))\\n        return \"\";\\n        int check=0;\\n        for(int i=0;i<ln;i++){\\n            if(s[i]!= \\']\\') st.push(string(1,s[i]));\\n            else{\\n                //finding nested problem,ie string inside []\\n                string temp=\"\";\\n                while(st.top()!= string(1,\\'[\\')){\\n                    temp+= st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n                \\n                //finding number\\n                string num=\"\";\\n                while(!st.empty() && (st.top()>=string(1,\\'0\\') && st.top()<=string(1,\\'9\\'))){\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                \\n                int n= num.size()!=0? stoi(num): 1;\\n                string toPush= \"\";\\n                for(int i=0;i<n;i++)toPush+= temp;\\n                reverse(toPush.begin(),toPush.end());\\n                st.push(toPush);\\n                check = 1;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        // if(!check)\\n        // return \"\";\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Kaivalya",
                        "content": "Is  this valid input as a test case ? if yes then how it can be handled using stack ? 8th index of below input will try to get value from stack which is 2.\\n\\n2[[12[a]]bc] "
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "this is an invalid input."
                    },
                    {
                        "username": "keratonjava",
                        "content": "This is probably the hardest exercice so far, tips use recursion"
                    },
                    {
                        "username": "abhayx2910",
                        "content": "this is a pseudocode for this problem  for beginners\\n\\nfirst make a stack st,\\nrun a loop from 0->string length\\n       When \\']\\' is encountered, we need to start decoding\\n              run a while loop till we encounter \\'[\\'\\n                st.top() + temp makes sure that the string won\\'t be in reverse order eg, if the stack contains 12[abc temp = c + \"\" =>temp = b + \"c\"=>  temp = a + \"bc\"\\n        remove the [ from stack\\n         remove the digits from the stack\\n        if s[i] is not \\']\\', simply push s[i] to the stack\\n return the resultant string"
                    }
                ]
            },
            {
                "id": 1967252,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Here is the Hint\n1. push elements to the stack until meet ']'\n2. pop elements from the stack until meet '[' => contents\n3. pop elements digitals from the stack => number\n4. repeat \"contents\" by \"number\" times and push to the stack\nrepeat step 1 to 4"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "quite interesting problem"
                    },
                    {
                        "username": "puneet-yadav",
                        "content": "I am getting mle for this code,, can anyone tell why i am getting mle?\\n Stack<Character> encodedChar = new Stack<>();\\n        //Stack<Integer> times = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n      //  int n = s.length();\\n        for(char c: s.toCharArray()){\\n                if(c==\\']\\'){\\n                StringBuilder toDecode = new StringBuilder();\\n                while(encodedChar.peek()!=\\'[\\'){\\n                    char x = encodedChar.peek();\\n                    encodedChar.pop();\\n                    //toDecode = x + toDecode;\\n                    toDecode.append(x);\\n                }\\n                toDecode = toDecode.reverse();\\n                encodedChar.pop();\\n                if(Character.isDigit(encodedChar.peek())){\\n                    int time = (int)encodedChar.peek();\\n                    encodedChar.pop();\\n                    for(int i=0;i<time;i++){\\n                        toDecode.append(toDecode);\\n                    }\\n                }\\n                else{\\n                    ans.append(toDecode);\\n                    continue;\\n                }\\n                ans.append(toDecode);\\n            }\\n            else{\\n                encodedChar.push(c);\\n                continue;\\n            }\\n        }\\n        if(!encodedChar.isEmpty()){\\n            StringBuilder remaining = new StringBuilder();\\n            while(!encodedChar.isEmpty()){\\n               // remaining = encodedChar.peek() + remaining;\\n            \\tremaining.append(encodedChar.peek());\\n                encodedChar.pop();\\n            }\\n            ans.append(remaining.reverse());\\n        }\\n        return ans.toString();"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "class Solution {\\npublic:\\n\\n    string decodeString(string s) \\n    {\\n        if(s.length()==1 && isalpha(s[0])){return s;}\\n        stack<char> st;\\n        string temp=\"\",res=\"\";\\n        int i=0,k_time=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            temp=\"\";\\n            while(s[i]!=\\']\\' && i<s.length())\\n            {\\n                st.push(s[i]);\\n                i++;    \\n            }\\n            i++;\\n            temp=\"\";\\n            while(st.top()!=\\'[\\' && !st.empty())\\n            {\\n                temp+=st.top();\\n                st.pop();\\n            }\\n\\n            st.pop();\\n            if(temp.length()>1)\\n            {\\n                reverse(temp.begin(),temp.end());\\n            }\\n            \\n            \\n            string num=\"\";\\n\\n            if(!st.empty())\\n            {\\n                num=num+st.top();\\n                st.pop();\\n                k_time= stoi(num);\\n            }\\n            \\n\\n            while(k_time>0)\\n            {\\n                res = res + temp;\\n                k_time--;\\n            }    \\n        }\\n        reverse(res.begin(),res.end());\\n        return res;    \\n    }\\n};\\n\\ncan somebody please explain what\\'s wrong with this code, I am getting a Runtime error indicating DEADLYSIGNAL with an error of SEGV on unknown address."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "please dont post your solutions in here ..\\n"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "[@ritikthakur09](/ritikthakur09) It didn\\'t work, but thanks for a new concept. "
                    },
                    {
                        "username": "ritikthakur09",
                        "content": "while(st.top()!=\\'[\\' && !st.empty()) \\nwrite it as while( !st.empty() && st.top()!=\\'[\\') instead since you need to check if it is empty first and not opposite."
                    },
                    {
                        "username": "dimitars",
                        "content": "Giving an input \"300[300[300[300[300[99[a]]]]]]\" returns an error reading \"The length of the output should not exceed 10^5.\"\\n\\nMaybe it would improve the description if this is mentioned there, considering I\\'m not missing some site-wide constraint."
                    },
                    {
                        "username": "d_e_v_i_l_07",
                        "content": "class Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        int ln= s.size();\\n        if(s.size()==1 && (s>=string(1,\\'0\\') && s<=string(1,\\'9\\')))\\n        return \"\";\\n        int check=0;\\n        for(int i=0;i<ln;i++){\\n            if(s[i]!= \\']\\') st.push(string(1,s[i]));\\n            else{\\n                //finding nested problem,ie string inside []\\n                string temp=\"\";\\n                while(st.top()!= string(1,\\'[\\')){\\n                    temp+= st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n                \\n                //finding number\\n                string num=\"\";\\n                while(!st.empty() && (st.top()>=string(1,\\'0\\') && st.top()<=string(1,\\'9\\'))){\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                \\n                int n= num.size()!=0? stoi(num): 1;\\n                string toPush= \"\";\\n                for(int i=0;i<n;i++)toPush+= temp;\\n                reverse(toPush.begin(),toPush.end());\\n                st.push(toPush);\\n                check = 1;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        // if(!check)\\n        // return \"\";\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Kaivalya",
                        "content": "Is  this valid input as a test case ? if yes then how it can be handled using stack ? 8th index of below input will try to get value from stack which is 2.\\n\\n2[[12[a]]bc] "
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "this is an invalid input."
                    },
                    {
                        "username": "keratonjava",
                        "content": "This is probably the hardest exercice so far, tips use recursion"
                    },
                    {
                        "username": "abhayx2910",
                        "content": "this is a pseudocode for this problem  for beginners\\n\\nfirst make a stack st,\\nrun a loop from 0->string length\\n       When \\']\\' is encountered, we need to start decoding\\n              run a while loop till we encounter \\'[\\'\\n                st.top() + temp makes sure that the string won\\'t be in reverse order eg, if the stack contains 12[abc temp = c + \"\" =>temp = b + \"c\"=>  temp = a + \"bc\"\\n        remove the [ from stack\\n         remove the digits from the stack\\n        if s[i] is not \\']\\', simply push s[i] to the stack\\n return the resultant string"
                    }
                ]
            },
            {
                "id": 1959079,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Here is the Hint\n1. push elements to the stack until meet ']'\n2. pop elements from the stack until meet '[' => contents\n3. pop elements digitals from the stack => number\n4. repeat \"contents\" by \"number\" times and push to the stack\nrepeat step 1 to 4"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "quite interesting problem"
                    },
                    {
                        "username": "puneet-yadav",
                        "content": "I am getting mle for this code,, can anyone tell why i am getting mle?\\n Stack<Character> encodedChar = new Stack<>();\\n        //Stack<Integer> times = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n      //  int n = s.length();\\n        for(char c: s.toCharArray()){\\n                if(c==\\']\\'){\\n                StringBuilder toDecode = new StringBuilder();\\n                while(encodedChar.peek()!=\\'[\\'){\\n                    char x = encodedChar.peek();\\n                    encodedChar.pop();\\n                    //toDecode = x + toDecode;\\n                    toDecode.append(x);\\n                }\\n                toDecode = toDecode.reverse();\\n                encodedChar.pop();\\n                if(Character.isDigit(encodedChar.peek())){\\n                    int time = (int)encodedChar.peek();\\n                    encodedChar.pop();\\n                    for(int i=0;i<time;i++){\\n                        toDecode.append(toDecode);\\n                    }\\n                }\\n                else{\\n                    ans.append(toDecode);\\n                    continue;\\n                }\\n                ans.append(toDecode);\\n            }\\n            else{\\n                encodedChar.push(c);\\n                continue;\\n            }\\n        }\\n        if(!encodedChar.isEmpty()){\\n            StringBuilder remaining = new StringBuilder();\\n            while(!encodedChar.isEmpty()){\\n               // remaining = encodedChar.peek() + remaining;\\n            \\tremaining.append(encodedChar.peek());\\n                encodedChar.pop();\\n            }\\n            ans.append(remaining.reverse());\\n        }\\n        return ans.toString();"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "class Solution {\\npublic:\\n\\n    string decodeString(string s) \\n    {\\n        if(s.length()==1 && isalpha(s[0])){return s;}\\n        stack<char> st;\\n        string temp=\"\",res=\"\";\\n        int i=0,k_time=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            temp=\"\";\\n            while(s[i]!=\\']\\' && i<s.length())\\n            {\\n                st.push(s[i]);\\n                i++;    \\n            }\\n            i++;\\n            temp=\"\";\\n            while(st.top()!=\\'[\\' && !st.empty())\\n            {\\n                temp+=st.top();\\n                st.pop();\\n            }\\n\\n            st.pop();\\n            if(temp.length()>1)\\n            {\\n                reverse(temp.begin(),temp.end());\\n            }\\n            \\n            \\n            string num=\"\";\\n\\n            if(!st.empty())\\n            {\\n                num=num+st.top();\\n                st.pop();\\n                k_time= stoi(num);\\n            }\\n            \\n\\n            while(k_time>0)\\n            {\\n                res = res + temp;\\n                k_time--;\\n            }    \\n        }\\n        reverse(res.begin(),res.end());\\n        return res;    \\n    }\\n};\\n\\ncan somebody please explain what\\'s wrong with this code, I am getting a Runtime error indicating DEADLYSIGNAL with an error of SEGV on unknown address."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "please dont post your solutions in here ..\\n"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "[@ritikthakur09](/ritikthakur09) It didn\\'t work, but thanks for a new concept. "
                    },
                    {
                        "username": "ritikthakur09",
                        "content": "while(st.top()!=\\'[\\' && !st.empty()) \\nwrite it as while( !st.empty() && st.top()!=\\'[\\') instead since you need to check if it is empty first and not opposite."
                    },
                    {
                        "username": "dimitars",
                        "content": "Giving an input \"300[300[300[300[300[99[a]]]]]]\" returns an error reading \"The length of the output should not exceed 10^5.\"\\n\\nMaybe it would improve the description if this is mentioned there, considering I\\'m not missing some site-wide constraint."
                    },
                    {
                        "username": "d_e_v_i_l_07",
                        "content": "class Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        int ln= s.size();\\n        if(s.size()==1 && (s>=string(1,\\'0\\') && s<=string(1,\\'9\\')))\\n        return \"\";\\n        int check=0;\\n        for(int i=0;i<ln;i++){\\n            if(s[i]!= \\']\\') st.push(string(1,s[i]));\\n            else{\\n                //finding nested problem,ie string inside []\\n                string temp=\"\";\\n                while(st.top()!= string(1,\\'[\\')){\\n                    temp+= st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n                \\n                //finding number\\n                string num=\"\";\\n                while(!st.empty() && (st.top()>=string(1,\\'0\\') && st.top()<=string(1,\\'9\\'))){\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                \\n                int n= num.size()!=0? stoi(num): 1;\\n                string toPush= \"\";\\n                for(int i=0;i<n;i++)toPush+= temp;\\n                reverse(toPush.begin(),toPush.end());\\n                st.push(toPush);\\n                check = 1;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        // if(!check)\\n        // return \"\";\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Kaivalya",
                        "content": "Is  this valid input as a test case ? if yes then how it can be handled using stack ? 8th index of below input will try to get value from stack which is 2.\\n\\n2[[12[a]]bc] "
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "this is an invalid input."
                    },
                    {
                        "username": "keratonjava",
                        "content": "This is probably the hardest exercice so far, tips use recursion"
                    },
                    {
                        "username": "abhayx2910",
                        "content": "this is a pseudocode for this problem  for beginners\\n\\nfirst make a stack st,\\nrun a loop from 0->string length\\n       When \\']\\' is encountered, we need to start decoding\\n              run a while loop till we encounter \\'[\\'\\n                st.top() + temp makes sure that the string won\\'t be in reverse order eg, if the stack contains 12[abc temp = c + \"\" =>temp = b + \"c\"=>  temp = a + \"bc\"\\n        remove the [ from stack\\n         remove the digits from the stack\\n        if s[i] is not \\']\\', simply push s[i] to the stack\\n return the resultant string"
                    }
                ]
            },
            {
                "id": 1883559,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Here is the Hint\n1. push elements to the stack until meet ']'\n2. pop elements from the stack until meet '[' => contents\n3. pop elements digitals from the stack => number\n4. repeat \"contents\" by \"number\" times and push to the stack\nrepeat step 1 to 4"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "quite interesting problem"
                    },
                    {
                        "username": "puneet-yadav",
                        "content": "I am getting mle for this code,, can anyone tell why i am getting mle?\\n Stack<Character> encodedChar = new Stack<>();\\n        //Stack<Integer> times = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n      //  int n = s.length();\\n        for(char c: s.toCharArray()){\\n                if(c==\\']\\'){\\n                StringBuilder toDecode = new StringBuilder();\\n                while(encodedChar.peek()!=\\'[\\'){\\n                    char x = encodedChar.peek();\\n                    encodedChar.pop();\\n                    //toDecode = x + toDecode;\\n                    toDecode.append(x);\\n                }\\n                toDecode = toDecode.reverse();\\n                encodedChar.pop();\\n                if(Character.isDigit(encodedChar.peek())){\\n                    int time = (int)encodedChar.peek();\\n                    encodedChar.pop();\\n                    for(int i=0;i<time;i++){\\n                        toDecode.append(toDecode);\\n                    }\\n                }\\n                else{\\n                    ans.append(toDecode);\\n                    continue;\\n                }\\n                ans.append(toDecode);\\n            }\\n            else{\\n                encodedChar.push(c);\\n                continue;\\n            }\\n        }\\n        if(!encodedChar.isEmpty()){\\n            StringBuilder remaining = new StringBuilder();\\n            while(!encodedChar.isEmpty()){\\n               // remaining = encodedChar.peek() + remaining;\\n            \\tremaining.append(encodedChar.peek());\\n                encodedChar.pop();\\n            }\\n            ans.append(remaining.reverse());\\n        }\\n        return ans.toString();"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "class Solution {\\npublic:\\n\\n    string decodeString(string s) \\n    {\\n        if(s.length()==1 && isalpha(s[0])){return s;}\\n        stack<char> st;\\n        string temp=\"\",res=\"\";\\n        int i=0,k_time=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            temp=\"\";\\n            while(s[i]!=\\']\\' && i<s.length())\\n            {\\n                st.push(s[i]);\\n                i++;    \\n            }\\n            i++;\\n            temp=\"\";\\n            while(st.top()!=\\'[\\' && !st.empty())\\n            {\\n                temp+=st.top();\\n                st.pop();\\n            }\\n\\n            st.pop();\\n            if(temp.length()>1)\\n            {\\n                reverse(temp.begin(),temp.end());\\n            }\\n            \\n            \\n            string num=\"\";\\n\\n            if(!st.empty())\\n            {\\n                num=num+st.top();\\n                st.pop();\\n                k_time= stoi(num);\\n            }\\n            \\n\\n            while(k_time>0)\\n            {\\n                res = res + temp;\\n                k_time--;\\n            }    \\n        }\\n        reverse(res.begin(),res.end());\\n        return res;    \\n    }\\n};\\n\\ncan somebody please explain what\\'s wrong with this code, I am getting a Runtime error indicating DEADLYSIGNAL with an error of SEGV on unknown address."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "please dont post your solutions in here ..\\n"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "[@ritikthakur09](/ritikthakur09) It didn\\'t work, but thanks for a new concept. "
                    },
                    {
                        "username": "ritikthakur09",
                        "content": "while(st.top()!=\\'[\\' && !st.empty()) \\nwrite it as while( !st.empty() && st.top()!=\\'[\\') instead since you need to check if it is empty first and not opposite."
                    },
                    {
                        "username": "dimitars",
                        "content": "Giving an input \"300[300[300[300[300[99[a]]]]]]\" returns an error reading \"The length of the output should not exceed 10^5.\"\\n\\nMaybe it would improve the description if this is mentioned there, considering I\\'m not missing some site-wide constraint."
                    },
                    {
                        "username": "d_e_v_i_l_07",
                        "content": "class Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        int ln= s.size();\\n        if(s.size()==1 && (s>=string(1,\\'0\\') && s<=string(1,\\'9\\')))\\n        return \"\";\\n        int check=0;\\n        for(int i=0;i<ln;i++){\\n            if(s[i]!= \\']\\') st.push(string(1,s[i]));\\n            else{\\n                //finding nested problem,ie string inside []\\n                string temp=\"\";\\n                while(st.top()!= string(1,\\'[\\')){\\n                    temp+= st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n                \\n                //finding number\\n                string num=\"\";\\n                while(!st.empty() && (st.top()>=string(1,\\'0\\') && st.top()<=string(1,\\'9\\'))){\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                \\n                int n= num.size()!=0? stoi(num): 1;\\n                string toPush= \"\";\\n                for(int i=0;i<n;i++)toPush+= temp;\\n                reverse(toPush.begin(),toPush.end());\\n                st.push(toPush);\\n                check = 1;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        // if(!check)\\n        // return \"\";\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Kaivalya",
                        "content": "Is  this valid input as a test case ? if yes then how it can be handled using stack ? 8th index of below input will try to get value from stack which is 2.\\n\\n2[[12[a]]bc] "
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "this is an invalid input."
                    },
                    {
                        "username": "keratonjava",
                        "content": "This is probably the hardest exercice so far, tips use recursion"
                    },
                    {
                        "username": "abhayx2910",
                        "content": "this is a pseudocode for this problem  for beginners\\n\\nfirst make a stack st,\\nrun a loop from 0->string length\\n       When \\']\\' is encountered, we need to start decoding\\n              run a while loop till we encounter \\'[\\'\\n                st.top() + temp makes sure that the string won\\'t be in reverse order eg, if the stack contains 12[abc temp = c + \"\" =>temp = b + \"c\"=>  temp = a + \"bc\"\\n        remove the [ from stack\\n         remove the digits from the stack\\n        if s[i] is not \\']\\', simply push s[i] to the stack\\n return the resultant string"
                    }
                ]
            },
            {
                "id": 1881918,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Here is the Hint\n1. push elements to the stack until meet ']'\n2. pop elements from the stack until meet '[' => contents\n3. pop elements digitals from the stack => number\n4. repeat \"contents\" by \"number\" times and push to the stack\nrepeat step 1 to 4"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "quite interesting problem"
                    },
                    {
                        "username": "puneet-yadav",
                        "content": "I am getting mle for this code,, can anyone tell why i am getting mle?\\n Stack<Character> encodedChar = new Stack<>();\\n        //Stack<Integer> times = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n      //  int n = s.length();\\n        for(char c: s.toCharArray()){\\n                if(c==\\']\\'){\\n                StringBuilder toDecode = new StringBuilder();\\n                while(encodedChar.peek()!=\\'[\\'){\\n                    char x = encodedChar.peek();\\n                    encodedChar.pop();\\n                    //toDecode = x + toDecode;\\n                    toDecode.append(x);\\n                }\\n                toDecode = toDecode.reverse();\\n                encodedChar.pop();\\n                if(Character.isDigit(encodedChar.peek())){\\n                    int time = (int)encodedChar.peek();\\n                    encodedChar.pop();\\n                    for(int i=0;i<time;i++){\\n                        toDecode.append(toDecode);\\n                    }\\n                }\\n                else{\\n                    ans.append(toDecode);\\n                    continue;\\n                }\\n                ans.append(toDecode);\\n            }\\n            else{\\n                encodedChar.push(c);\\n                continue;\\n            }\\n        }\\n        if(!encodedChar.isEmpty()){\\n            StringBuilder remaining = new StringBuilder();\\n            while(!encodedChar.isEmpty()){\\n               // remaining = encodedChar.peek() + remaining;\\n            \\tremaining.append(encodedChar.peek());\\n                encodedChar.pop();\\n            }\\n            ans.append(remaining.reverse());\\n        }\\n        return ans.toString();"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "class Solution {\\npublic:\\n\\n    string decodeString(string s) \\n    {\\n        if(s.length()==1 && isalpha(s[0])){return s;}\\n        stack<char> st;\\n        string temp=\"\",res=\"\";\\n        int i=0,k_time=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            temp=\"\";\\n            while(s[i]!=\\']\\' && i<s.length())\\n            {\\n                st.push(s[i]);\\n                i++;    \\n            }\\n            i++;\\n            temp=\"\";\\n            while(st.top()!=\\'[\\' && !st.empty())\\n            {\\n                temp+=st.top();\\n                st.pop();\\n            }\\n\\n            st.pop();\\n            if(temp.length()>1)\\n            {\\n                reverse(temp.begin(),temp.end());\\n            }\\n            \\n            \\n            string num=\"\";\\n\\n            if(!st.empty())\\n            {\\n                num=num+st.top();\\n                st.pop();\\n                k_time= stoi(num);\\n            }\\n            \\n\\n            while(k_time>0)\\n            {\\n                res = res + temp;\\n                k_time--;\\n            }    \\n        }\\n        reverse(res.begin(),res.end());\\n        return res;    \\n    }\\n};\\n\\ncan somebody please explain what\\'s wrong with this code, I am getting a Runtime error indicating DEADLYSIGNAL with an error of SEGV on unknown address."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "please dont post your solutions in here ..\\n"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "[@ritikthakur09](/ritikthakur09) It didn\\'t work, but thanks for a new concept. "
                    },
                    {
                        "username": "ritikthakur09",
                        "content": "while(st.top()!=\\'[\\' && !st.empty()) \\nwrite it as while( !st.empty() && st.top()!=\\'[\\') instead since you need to check if it is empty first and not opposite."
                    },
                    {
                        "username": "dimitars",
                        "content": "Giving an input \"300[300[300[300[300[99[a]]]]]]\" returns an error reading \"The length of the output should not exceed 10^5.\"\\n\\nMaybe it would improve the description if this is mentioned there, considering I\\'m not missing some site-wide constraint."
                    },
                    {
                        "username": "d_e_v_i_l_07",
                        "content": "class Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        int ln= s.size();\\n        if(s.size()==1 && (s>=string(1,\\'0\\') && s<=string(1,\\'9\\')))\\n        return \"\";\\n        int check=0;\\n        for(int i=0;i<ln;i++){\\n            if(s[i]!= \\']\\') st.push(string(1,s[i]));\\n            else{\\n                //finding nested problem,ie string inside []\\n                string temp=\"\";\\n                while(st.top()!= string(1,\\'[\\')){\\n                    temp+= st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n                \\n                //finding number\\n                string num=\"\";\\n                while(!st.empty() && (st.top()>=string(1,\\'0\\') && st.top()<=string(1,\\'9\\'))){\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                \\n                int n= num.size()!=0? stoi(num): 1;\\n                string toPush= \"\";\\n                for(int i=0;i<n;i++)toPush+= temp;\\n                reverse(toPush.begin(),toPush.end());\\n                st.push(toPush);\\n                check = 1;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        // if(!check)\\n        // return \"\";\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Kaivalya",
                        "content": "Is  this valid input as a test case ? if yes then how it can be handled using stack ? 8th index of below input will try to get value from stack which is 2.\\n\\n2[[12[a]]bc] "
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "this is an invalid input."
                    },
                    {
                        "username": "keratonjava",
                        "content": "This is probably the hardest exercice so far, tips use recursion"
                    },
                    {
                        "username": "abhayx2910",
                        "content": "this is a pseudocode for this problem  for beginners\\n\\nfirst make a stack st,\\nrun a loop from 0->string length\\n       When \\']\\' is encountered, we need to start decoding\\n              run a while loop till we encounter \\'[\\'\\n                st.top() + temp makes sure that the string won\\'t be in reverse order eg, if the stack contains 12[abc temp = c + \"\" =>temp = b + \"c\"=>  temp = a + \"bc\"\\n        remove the [ from stack\\n         remove the digits from the stack\\n        if s[i] is not \\']\\', simply push s[i] to the stack\\n return the resultant string"
                    }
                ]
            },
            {
                "id": 1823961,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Here is the Hint\n1. push elements to the stack until meet ']'\n2. pop elements from the stack until meet '[' => contents\n3. pop elements digitals from the stack => number\n4. repeat \"contents\" by \"number\" times and push to the stack\nrepeat step 1 to 4"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "quite interesting problem"
                    },
                    {
                        "username": "puneet-yadav",
                        "content": "I am getting mle for this code,, can anyone tell why i am getting mle?\\n Stack<Character> encodedChar = new Stack<>();\\n        //Stack<Integer> times = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n      //  int n = s.length();\\n        for(char c: s.toCharArray()){\\n                if(c==\\']\\'){\\n                StringBuilder toDecode = new StringBuilder();\\n                while(encodedChar.peek()!=\\'[\\'){\\n                    char x = encodedChar.peek();\\n                    encodedChar.pop();\\n                    //toDecode = x + toDecode;\\n                    toDecode.append(x);\\n                }\\n                toDecode = toDecode.reverse();\\n                encodedChar.pop();\\n                if(Character.isDigit(encodedChar.peek())){\\n                    int time = (int)encodedChar.peek();\\n                    encodedChar.pop();\\n                    for(int i=0;i<time;i++){\\n                        toDecode.append(toDecode);\\n                    }\\n                }\\n                else{\\n                    ans.append(toDecode);\\n                    continue;\\n                }\\n                ans.append(toDecode);\\n            }\\n            else{\\n                encodedChar.push(c);\\n                continue;\\n            }\\n        }\\n        if(!encodedChar.isEmpty()){\\n            StringBuilder remaining = new StringBuilder();\\n            while(!encodedChar.isEmpty()){\\n               // remaining = encodedChar.peek() + remaining;\\n            \\tremaining.append(encodedChar.peek());\\n                encodedChar.pop();\\n            }\\n            ans.append(remaining.reverse());\\n        }\\n        return ans.toString();"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "class Solution {\\npublic:\\n\\n    string decodeString(string s) \\n    {\\n        if(s.length()==1 && isalpha(s[0])){return s;}\\n        stack<char> st;\\n        string temp=\"\",res=\"\";\\n        int i=0,k_time=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            temp=\"\";\\n            while(s[i]!=\\']\\' && i<s.length())\\n            {\\n                st.push(s[i]);\\n                i++;    \\n            }\\n            i++;\\n            temp=\"\";\\n            while(st.top()!=\\'[\\' && !st.empty())\\n            {\\n                temp+=st.top();\\n                st.pop();\\n            }\\n\\n            st.pop();\\n            if(temp.length()>1)\\n            {\\n                reverse(temp.begin(),temp.end());\\n            }\\n            \\n            \\n            string num=\"\";\\n\\n            if(!st.empty())\\n            {\\n                num=num+st.top();\\n                st.pop();\\n                k_time= stoi(num);\\n            }\\n            \\n\\n            while(k_time>0)\\n            {\\n                res = res + temp;\\n                k_time--;\\n            }    \\n        }\\n        reverse(res.begin(),res.end());\\n        return res;    \\n    }\\n};\\n\\ncan somebody please explain what\\'s wrong with this code, I am getting a Runtime error indicating DEADLYSIGNAL with an error of SEGV on unknown address."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "please dont post your solutions in here ..\\n"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "[@ritikthakur09](/ritikthakur09) It didn\\'t work, but thanks for a new concept. "
                    },
                    {
                        "username": "ritikthakur09",
                        "content": "while(st.top()!=\\'[\\' && !st.empty()) \\nwrite it as while( !st.empty() && st.top()!=\\'[\\') instead since you need to check if it is empty first and not opposite."
                    },
                    {
                        "username": "dimitars",
                        "content": "Giving an input \"300[300[300[300[300[99[a]]]]]]\" returns an error reading \"The length of the output should not exceed 10^5.\"\\n\\nMaybe it would improve the description if this is mentioned there, considering I\\'m not missing some site-wide constraint."
                    },
                    {
                        "username": "d_e_v_i_l_07",
                        "content": "class Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        int ln= s.size();\\n        if(s.size()==1 && (s>=string(1,\\'0\\') && s<=string(1,\\'9\\')))\\n        return \"\";\\n        int check=0;\\n        for(int i=0;i<ln;i++){\\n            if(s[i]!= \\']\\') st.push(string(1,s[i]));\\n            else{\\n                //finding nested problem,ie string inside []\\n                string temp=\"\";\\n                while(st.top()!= string(1,\\'[\\')){\\n                    temp+= st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n                \\n                //finding number\\n                string num=\"\";\\n                while(!st.empty() && (st.top()>=string(1,\\'0\\') && st.top()<=string(1,\\'9\\'))){\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                \\n                int n= num.size()!=0? stoi(num): 1;\\n                string toPush= \"\";\\n                for(int i=0;i<n;i++)toPush+= temp;\\n                reverse(toPush.begin(),toPush.end());\\n                st.push(toPush);\\n                check = 1;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        // if(!check)\\n        // return \"\";\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Kaivalya",
                        "content": "Is  this valid input as a test case ? if yes then how it can be handled using stack ? 8th index of below input will try to get value from stack which is 2.\\n\\n2[[12[a]]bc] "
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "this is an invalid input."
                    },
                    {
                        "username": "keratonjava",
                        "content": "This is probably the hardest exercice so far, tips use recursion"
                    },
                    {
                        "username": "abhayx2910",
                        "content": "this is a pseudocode for this problem  for beginners\\n\\nfirst make a stack st,\\nrun a loop from 0->string length\\n       When \\']\\' is encountered, we need to start decoding\\n              run a while loop till we encounter \\'[\\'\\n                st.top() + temp makes sure that the string won\\'t be in reverse order eg, if the stack contains 12[abc temp = c + \"\" =>temp = b + \"c\"=>  temp = a + \"bc\"\\n        remove the [ from stack\\n         remove the digits from the stack\\n        if s[i] is not \\']\\', simply push s[i] to the stack\\n return the resultant string"
                    }
                ]
            },
            {
                "id": 1812859,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Here is the Hint\n1. push elements to the stack until meet ']'\n2. pop elements from the stack until meet '[' => contents\n3. pop elements digitals from the stack => number\n4. repeat \"contents\" by \"number\" times and push to the stack\nrepeat step 1 to 4"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "quite interesting problem"
                    },
                    {
                        "username": "puneet-yadav",
                        "content": "I am getting mle for this code,, can anyone tell why i am getting mle?\\n Stack<Character> encodedChar = new Stack<>();\\n        //Stack<Integer> times = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n      //  int n = s.length();\\n        for(char c: s.toCharArray()){\\n                if(c==\\']\\'){\\n                StringBuilder toDecode = new StringBuilder();\\n                while(encodedChar.peek()!=\\'[\\'){\\n                    char x = encodedChar.peek();\\n                    encodedChar.pop();\\n                    //toDecode = x + toDecode;\\n                    toDecode.append(x);\\n                }\\n                toDecode = toDecode.reverse();\\n                encodedChar.pop();\\n                if(Character.isDigit(encodedChar.peek())){\\n                    int time = (int)encodedChar.peek();\\n                    encodedChar.pop();\\n                    for(int i=0;i<time;i++){\\n                        toDecode.append(toDecode);\\n                    }\\n                }\\n                else{\\n                    ans.append(toDecode);\\n                    continue;\\n                }\\n                ans.append(toDecode);\\n            }\\n            else{\\n                encodedChar.push(c);\\n                continue;\\n            }\\n        }\\n        if(!encodedChar.isEmpty()){\\n            StringBuilder remaining = new StringBuilder();\\n            while(!encodedChar.isEmpty()){\\n               // remaining = encodedChar.peek() + remaining;\\n            \\tremaining.append(encodedChar.peek());\\n                encodedChar.pop();\\n            }\\n            ans.append(remaining.reverse());\\n        }\\n        return ans.toString();"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "class Solution {\\npublic:\\n\\n    string decodeString(string s) \\n    {\\n        if(s.length()==1 && isalpha(s[0])){return s;}\\n        stack<char> st;\\n        string temp=\"\",res=\"\";\\n        int i=0,k_time=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            temp=\"\";\\n            while(s[i]!=\\']\\' && i<s.length())\\n            {\\n                st.push(s[i]);\\n                i++;    \\n            }\\n            i++;\\n            temp=\"\";\\n            while(st.top()!=\\'[\\' && !st.empty())\\n            {\\n                temp+=st.top();\\n                st.pop();\\n            }\\n\\n            st.pop();\\n            if(temp.length()>1)\\n            {\\n                reverse(temp.begin(),temp.end());\\n            }\\n            \\n            \\n            string num=\"\";\\n\\n            if(!st.empty())\\n            {\\n                num=num+st.top();\\n                st.pop();\\n                k_time= stoi(num);\\n            }\\n            \\n\\n            while(k_time>0)\\n            {\\n                res = res + temp;\\n                k_time--;\\n            }    \\n        }\\n        reverse(res.begin(),res.end());\\n        return res;    \\n    }\\n};\\n\\ncan somebody please explain what\\'s wrong with this code, I am getting a Runtime error indicating DEADLYSIGNAL with an error of SEGV on unknown address."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "please dont post your solutions in here ..\\n"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "[@ritikthakur09](/ritikthakur09) It didn\\'t work, but thanks for a new concept. "
                    },
                    {
                        "username": "ritikthakur09",
                        "content": "while(st.top()!=\\'[\\' && !st.empty()) \\nwrite it as while( !st.empty() && st.top()!=\\'[\\') instead since you need to check if it is empty first and not opposite."
                    },
                    {
                        "username": "dimitars",
                        "content": "Giving an input \"300[300[300[300[300[99[a]]]]]]\" returns an error reading \"The length of the output should not exceed 10^5.\"\\n\\nMaybe it would improve the description if this is mentioned there, considering I\\'m not missing some site-wide constraint."
                    },
                    {
                        "username": "d_e_v_i_l_07",
                        "content": "class Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        int ln= s.size();\\n        if(s.size()==1 && (s>=string(1,\\'0\\') && s<=string(1,\\'9\\')))\\n        return \"\";\\n        int check=0;\\n        for(int i=0;i<ln;i++){\\n            if(s[i]!= \\']\\') st.push(string(1,s[i]));\\n            else{\\n                //finding nested problem,ie string inside []\\n                string temp=\"\";\\n                while(st.top()!= string(1,\\'[\\')){\\n                    temp+= st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n                \\n                //finding number\\n                string num=\"\";\\n                while(!st.empty() && (st.top()>=string(1,\\'0\\') && st.top()<=string(1,\\'9\\'))){\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                \\n                int n= num.size()!=0? stoi(num): 1;\\n                string toPush= \"\";\\n                for(int i=0;i<n;i++)toPush+= temp;\\n                reverse(toPush.begin(),toPush.end());\\n                st.push(toPush);\\n                check = 1;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        // if(!check)\\n        // return \"\";\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Kaivalya",
                        "content": "Is  this valid input as a test case ? if yes then how it can be handled using stack ? 8th index of below input will try to get value from stack which is 2.\\n\\n2[[12[a]]bc] "
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "this is an invalid input."
                    },
                    {
                        "username": "keratonjava",
                        "content": "This is probably the hardest exercice so far, tips use recursion"
                    },
                    {
                        "username": "abhayx2910",
                        "content": "this is a pseudocode for this problem  for beginners\\n\\nfirst make a stack st,\\nrun a loop from 0->string length\\n       When \\']\\' is encountered, we need to start decoding\\n              run a while loop till we encounter \\'[\\'\\n                st.top() + temp makes sure that the string won\\'t be in reverse order eg, if the stack contains 12[abc temp = c + \"\" =>temp = b + \"c\"=>  temp = a + \"bc\"\\n        remove the [ from stack\\n         remove the digits from the stack\\n        if s[i] is not \\']\\', simply push s[i] to the stack\\n return the resultant string"
                    }
                ]
            },
            {
                "id": 1801343,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Here is the Hint\n1. push elements to the stack until meet ']'\n2. pop elements from the stack until meet '[' => contents\n3. pop elements digitals from the stack => number\n4. repeat \"contents\" by \"number\" times and push to the stack\nrepeat step 1 to 4"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "quite interesting problem"
                    },
                    {
                        "username": "puneet-yadav",
                        "content": "I am getting mle for this code,, can anyone tell why i am getting mle?\\n Stack<Character> encodedChar = new Stack<>();\\n        //Stack<Integer> times = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n      //  int n = s.length();\\n        for(char c: s.toCharArray()){\\n                if(c==\\']\\'){\\n                StringBuilder toDecode = new StringBuilder();\\n                while(encodedChar.peek()!=\\'[\\'){\\n                    char x = encodedChar.peek();\\n                    encodedChar.pop();\\n                    //toDecode = x + toDecode;\\n                    toDecode.append(x);\\n                }\\n                toDecode = toDecode.reverse();\\n                encodedChar.pop();\\n                if(Character.isDigit(encodedChar.peek())){\\n                    int time = (int)encodedChar.peek();\\n                    encodedChar.pop();\\n                    for(int i=0;i<time;i++){\\n                        toDecode.append(toDecode);\\n                    }\\n                }\\n                else{\\n                    ans.append(toDecode);\\n                    continue;\\n                }\\n                ans.append(toDecode);\\n            }\\n            else{\\n                encodedChar.push(c);\\n                continue;\\n            }\\n        }\\n        if(!encodedChar.isEmpty()){\\n            StringBuilder remaining = new StringBuilder();\\n            while(!encodedChar.isEmpty()){\\n               // remaining = encodedChar.peek() + remaining;\\n            \\tremaining.append(encodedChar.peek());\\n                encodedChar.pop();\\n            }\\n            ans.append(remaining.reverse());\\n        }\\n        return ans.toString();"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "class Solution {\\npublic:\\n\\n    string decodeString(string s) \\n    {\\n        if(s.length()==1 && isalpha(s[0])){return s;}\\n        stack<char> st;\\n        string temp=\"\",res=\"\";\\n        int i=0,k_time=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            temp=\"\";\\n            while(s[i]!=\\']\\' && i<s.length())\\n            {\\n                st.push(s[i]);\\n                i++;    \\n            }\\n            i++;\\n            temp=\"\";\\n            while(st.top()!=\\'[\\' && !st.empty())\\n            {\\n                temp+=st.top();\\n                st.pop();\\n            }\\n\\n            st.pop();\\n            if(temp.length()>1)\\n            {\\n                reverse(temp.begin(),temp.end());\\n            }\\n            \\n            \\n            string num=\"\";\\n\\n            if(!st.empty())\\n            {\\n                num=num+st.top();\\n                st.pop();\\n                k_time= stoi(num);\\n            }\\n            \\n\\n            while(k_time>0)\\n            {\\n                res = res + temp;\\n                k_time--;\\n            }    \\n        }\\n        reverse(res.begin(),res.end());\\n        return res;    \\n    }\\n};\\n\\ncan somebody please explain what\\'s wrong with this code, I am getting a Runtime error indicating DEADLYSIGNAL with an error of SEGV on unknown address."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "please dont post your solutions in here ..\\n"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "[@ritikthakur09](/ritikthakur09) It didn\\'t work, but thanks for a new concept. "
                    },
                    {
                        "username": "ritikthakur09",
                        "content": "while(st.top()!=\\'[\\' && !st.empty()) \\nwrite it as while( !st.empty() && st.top()!=\\'[\\') instead since you need to check if it is empty first and not opposite."
                    },
                    {
                        "username": "dimitars",
                        "content": "Giving an input \"300[300[300[300[300[99[a]]]]]]\" returns an error reading \"The length of the output should not exceed 10^5.\"\\n\\nMaybe it would improve the description if this is mentioned there, considering I\\'m not missing some site-wide constraint."
                    },
                    {
                        "username": "d_e_v_i_l_07",
                        "content": "class Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        int ln= s.size();\\n        if(s.size()==1 && (s>=string(1,\\'0\\') && s<=string(1,\\'9\\')))\\n        return \"\";\\n        int check=0;\\n        for(int i=0;i<ln;i++){\\n            if(s[i]!= \\']\\') st.push(string(1,s[i]));\\n            else{\\n                //finding nested problem,ie string inside []\\n                string temp=\"\";\\n                while(st.top()!= string(1,\\'[\\')){\\n                    temp+= st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n                \\n                //finding number\\n                string num=\"\";\\n                while(!st.empty() && (st.top()>=string(1,\\'0\\') && st.top()<=string(1,\\'9\\'))){\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                \\n                int n= num.size()!=0? stoi(num): 1;\\n                string toPush= \"\";\\n                for(int i=0;i<n;i++)toPush+= temp;\\n                reverse(toPush.begin(),toPush.end());\\n                st.push(toPush);\\n                check = 1;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        // if(!check)\\n        // return \"\";\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Kaivalya",
                        "content": "Is  this valid input as a test case ? if yes then how it can be handled using stack ? 8th index of below input will try to get value from stack which is 2.\\n\\n2[[12[a]]bc] "
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "this is an invalid input."
                    },
                    {
                        "username": "keratonjava",
                        "content": "This is probably the hardest exercice so far, tips use recursion"
                    },
                    {
                        "username": "abhayx2910",
                        "content": "this is a pseudocode for this problem  for beginners\\n\\nfirst make a stack st,\\nrun a loop from 0->string length\\n       When \\']\\' is encountered, we need to start decoding\\n              run a while loop till we encounter \\'[\\'\\n                st.top() + temp makes sure that the string won\\'t be in reverse order eg, if the stack contains 12[abc temp = c + \"\" =>temp = b + \"c\"=>  temp = a + \"bc\"\\n        remove the [ from stack\\n         remove the digits from the stack\\n        if s[i] is not \\']\\', simply push s[i] to the stack\\n return the resultant string"
                    }
                ]
            },
            {
                "id": 1796261,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Here is the Hint\n1. push elements to the stack until meet ']'\n2. pop elements from the stack until meet '[' => contents\n3. pop elements digitals from the stack => number\n4. repeat \"contents\" by \"number\" times and push to the stack\nrepeat step 1 to 4"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "quite interesting problem"
                    },
                    {
                        "username": "puneet-yadav",
                        "content": "I am getting mle for this code,, can anyone tell why i am getting mle?\\n Stack<Character> encodedChar = new Stack<>();\\n        //Stack<Integer> times = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n      //  int n = s.length();\\n        for(char c: s.toCharArray()){\\n                if(c==\\']\\'){\\n                StringBuilder toDecode = new StringBuilder();\\n                while(encodedChar.peek()!=\\'[\\'){\\n                    char x = encodedChar.peek();\\n                    encodedChar.pop();\\n                    //toDecode = x + toDecode;\\n                    toDecode.append(x);\\n                }\\n                toDecode = toDecode.reverse();\\n                encodedChar.pop();\\n                if(Character.isDigit(encodedChar.peek())){\\n                    int time = (int)encodedChar.peek();\\n                    encodedChar.pop();\\n                    for(int i=0;i<time;i++){\\n                        toDecode.append(toDecode);\\n                    }\\n                }\\n                else{\\n                    ans.append(toDecode);\\n                    continue;\\n                }\\n                ans.append(toDecode);\\n            }\\n            else{\\n                encodedChar.push(c);\\n                continue;\\n            }\\n        }\\n        if(!encodedChar.isEmpty()){\\n            StringBuilder remaining = new StringBuilder();\\n            while(!encodedChar.isEmpty()){\\n               // remaining = encodedChar.peek() + remaining;\\n            \\tremaining.append(encodedChar.peek());\\n                encodedChar.pop();\\n            }\\n            ans.append(remaining.reverse());\\n        }\\n        return ans.toString();"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "Now this is what you call a sexy problem"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "class Solution {\\npublic:\\n\\n    string decodeString(string s) \\n    {\\n        if(s.length()==1 && isalpha(s[0])){return s;}\\n        stack<char> st;\\n        string temp=\"\",res=\"\";\\n        int i=0,k_time=0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            temp=\"\";\\n            while(s[i]!=\\']\\' && i<s.length())\\n            {\\n                st.push(s[i]);\\n                i++;    \\n            }\\n            i++;\\n            temp=\"\";\\n            while(st.top()!=\\'[\\' && !st.empty())\\n            {\\n                temp+=st.top();\\n                st.pop();\\n            }\\n\\n            st.pop();\\n            if(temp.length()>1)\\n            {\\n                reverse(temp.begin(),temp.end());\\n            }\\n            \\n            \\n            string num=\"\";\\n\\n            if(!st.empty())\\n            {\\n                num=num+st.top();\\n                st.pop();\\n                k_time= stoi(num);\\n            }\\n            \\n\\n            while(k_time>0)\\n            {\\n                res = res + temp;\\n                k_time--;\\n            }    \\n        }\\n        reverse(res.begin(),res.end());\\n        return res;    \\n    }\\n};\\n\\ncan somebody please explain what\\'s wrong with this code, I am getting a Runtime error indicating DEADLYSIGNAL with an error of SEGV on unknown address."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "please dont post your solutions in here ..\\n"
                    },
                    {
                        "username": "_ishika_soni07",
                        "content": "[@ritikthakur09](/ritikthakur09) It didn\\'t work, but thanks for a new concept. "
                    },
                    {
                        "username": "ritikthakur09",
                        "content": "while(st.top()!=\\'[\\' && !st.empty()) \\nwrite it as while( !st.empty() && st.top()!=\\'[\\') instead since you need to check if it is empty first and not opposite."
                    },
                    {
                        "username": "dimitars",
                        "content": "Giving an input \"300[300[300[300[300[99[a]]]]]]\" returns an error reading \"The length of the output should not exceed 10^5.\"\\n\\nMaybe it would improve the description if this is mentioned there, considering I\\'m not missing some site-wide constraint."
                    },
                    {
                        "username": "d_e_v_i_l_07",
                        "content": "class Solution {\\npublic:\\n    string decodeString(string s) {\\n        stack<string> st;\\n        int ln= s.size();\\n        if(s.size()==1 && (s>=string(1,\\'0\\') && s<=string(1,\\'9\\')))\\n        return \"\";\\n        int check=0;\\n        for(int i=0;i<ln;i++){\\n            if(s[i]!= \\']\\') st.push(string(1,s[i]));\\n            else{\\n                //finding nested problem,ie string inside []\\n                string temp=\"\";\\n                while(st.top()!= string(1,\\'[\\')){\\n                    temp+= st.top();\\n                    st.pop();\\n                }\\n                reverse(temp.begin(),temp.end());\\n                st.pop();\\n                \\n                //finding number\\n                string num=\"\";\\n                while(!st.empty() && (st.top()>=string(1,\\'0\\') && st.top()<=string(1,\\'9\\'))){\\n                    num+=st.top();\\n                    st.pop();\\n                }\\n                reverse(num.begin(),num.end());\\n                \\n                int n= num.size()!=0? stoi(num): 1;\\n                string toPush= \"\";\\n                for(int i=0;i<n;i++)toPush+= temp;\\n                reverse(toPush.begin(),toPush.end());\\n                st.push(toPush);\\n                check = 1;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        // if(!check)\\n        // return \"\";\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Kaivalya",
                        "content": "Is  this valid input as a test case ? if yes then how it can be handled using stack ? 8th index of below input will try to get value from stack which is 2.\\n\\n2[[12[a]]bc] "
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "this is an invalid input."
                    },
                    {
                        "username": "keratonjava",
                        "content": "This is probably the hardest exercice so far, tips use recursion"
                    },
                    {
                        "username": "abhayx2910",
                        "content": "this is a pseudocode for this problem  for beginners\\n\\nfirst make a stack st,\\nrun a loop from 0->string length\\n       When \\']\\' is encountered, we need to start decoding\\n              run a while loop till we encounter \\'[\\'\\n                st.top() + temp makes sure that the string won\\'t be in reverse order eg, if the stack contains 12[abc temp = c + \"\" =>temp = b + \"c\"=>  temp = a + \"bc\"\\n        remove the [ from stack\\n         remove the digits from the stack\\n        if s[i] is not \\']\\', simply push s[i] to the stack\\n return the resultant string"
                    }
                ]
            }
        ]
    },
    {
        "title": "Target Sum",
        "question_content": "<p>You are given an integer array <code>nums</code> and an integer <code>target</code>.</p>\n\n<p>You want to build an <strong>expression</strong> out of nums by adding one of the symbols <code>&#39;+&#39;</code> and <code>&#39;-&#39;</code> before each integer in nums and then concatenate all the integers.</p>\n\n<ul>\n\t<li>For example, if <code>nums = [2, 1]</code>, you can add a <code>&#39;+&#39;</code> before <code>2</code> and a <code>&#39;-&#39;</code> before <code>1</code> and concatenate them to build the expression <code>&quot;+2-1&quot;</code>.</li>\n</ul>\n\n<p>Return the number of different <strong>expressions</strong> that you can build, which evaluates to <code>target</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,1,1,1], target = 3\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> There are 5 ways to assign symbols to make the sum of nums be target 3.\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1], target = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 20</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= target &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 455024,
                "title": "dp-is-easy-5-steps-to-think-through-dp-questions",
                "content": "**WARNING:** This will not be a tabulated, perfectly optimized DP solution. We have enough of those. \\n\\nThis post will walk you through the THINKING process behind Dynamic Programming so that you can solve these questions on your own. \\n\\n1. Category\\nMost dynamic programming questions can be boiled down to a few categories. It\\'s important to recognize the category because it allows us to FRAME a new question into something we already know. Frame means use the framework, not copy an approach from another problem into the current problem. You must understand that every DP problem is different. \\n\\n\\t**Question:** Identify this problem as one of the categories below before continuing.\\n\\n\\t* 0/1 Knapsack\\n\\t* Unbounded Knapsack\\n\\t* Shortest Path (eg: Unique Paths I/II)\\n\\t* Fibonacci Sequence (eg: House Thief, Jump Game)\\n\\t* Longest Common Substring/Subsequeunce \\n\\n\\t**Answer:** 0/1 Knapsack \\n\\t\\n\\t*Why 0/1 Knapsack?* Our \\'Capacity\\' is the target we want to reach \\'S\\'. Our \\'Items\\' are the numbers in the input subset and the \\'Weights\\' of the items are the values of the numbers itself. This question follows 0/1 and not unbounded knapsack because we can use each number ONCE. \\n\\t\\n\\t*What is the variation?* The twist on this problem from standard knapsack is that we must add ALL items in the subset to our knapsack. We can reframe the question into adding the positive or negative value of the current number to our knapsack in order to reach the target capacity \\'S\\'.\\n\\n2.  States\\nWhat variables we need to keep track of in order to reach our optimal result? This Quora post explains state beautifully, so please refer to this link if you are confused: www.quora.com/What-does-a-state-represent-in-terms-of-Dynamic-Programming\\n\\n\\t**Question:** Determine State variables.\\n\\t*Hint:* As a general rule, Knapsack problems will require 2 states at minimum. \\n\\t\\n\\t**Answer:** Index and Current Sum \\n\\t*Why Index?* Index represents the index of the input subset we are considering. This tells us what values we have considered, what values we haven\\'t considered, and what value we are currently considering. As a general rule, index is a required state in nearly all dynamic programming problems, except for shortest paths which is row and column instead of a single index but we\\'ll get into that in a seperate post. \\n\\t\\n\\t*Why Current Sum?* The question asks us if we can sum every item (either the positive or negative value of that item) in the subset to reach the target value. Current Sum gives us the sum of all the values we have processed so far. Our answer revolves around Current Sum being equal to Target. \\n\\t\\n3.  Decisions\\n\\tDynamic Programming is all about making the optimal decision. In order to make the optimal decision, we will have to try all decisions first. The MIT lecture on DP (highly recommended) refers to this as the guessing step. My brain works better calling this a decision instead of a guess. Decisions will have to bring us closer to the base case and lead us towards the question we want to answer. Base case is covered in Step 4 but really work in tandem with the decision step. \\n\\t\\n\\t**Question:** What decisions do we have to make at each recursive call?\\n\\t*Hint:* As a general rule, Knapsack problems will require 2 decisions. \\n\\t\\n\\t**Answer:** This problem requires we take ALL items in our input subset, so at every step we will be adding an item to our knapsack. Remember, we stated in Step 2 that *\"The question asks us if we can sum every item (either the positive or negative value of that item) in the subset to reach the target value.\"* The decision is: \\n\\t1. Should we add the current numbers positive value \\n\\t2. Should we add the current numbers negative value \\n\\n\\tAs a note,  knapsack problems usually don\\'t require us to take all items, thus a usual knapsack decision is to take the item or leave the item. \\n\\t\\n4. Base Case\\n\\tBase cases need to relate directly to the conditions required by the answer we are seeking. This is why it is important for our decisions to work towards our base cases, as it means our decisions are working towards our answer. \\n\\t\\n\\tLet\\'s revisit the conditions for our answers. \\n\\t1. We use all numbers in our input subset.\\n\\t2. The sum of all numbers is equal to our target \\'S\\'.\\n\\t\\n\\t**Question:** Identify the base cases.\\n\\t*Hint:* There are 2 base cases. \\n\\t\\n\\t**Answer:** We need 2 base cases. One for when the current state is valid and one for when the current state is invalid.\\n\\t1. Valid: Index is out of bounds AND current sum is equal to target \\'S\\'\\n\\t2. Invalid: Index is out of bounds \\n\\n\\t*Why Index is out of bounds?* A condition for our answer is that we use EVERY item in our input subset. When the index is out of bounds, we know we have considered every item in our input subset.\\n\\t\\n   *Why current sum is equal to target?* A condition for our answer is that the sum of using either the positive or negative values of items in our input subet equal to the target sum \\'S\\'.\\n   \\n   If we have considered all the items in our input subset and our current sum is equal to our target, we have successfully met both conditions required by our answer.\\n   \\n   On the other hand, if we have considered all the items in our input subset and our current sum is NOT equal to our target, we have only met condition required by our answer. No bueno.\\n   \\n5. Code it\\nIf you\\'ve thought through all the steps and understand the problem, it\\'s trivial to code the actual solution. \\n   ```\\n    def findTargetSumWays(self, nums, S):\\n        index = len(nums) - 1\\n        curr_sum = 0\\n        return self.dp(nums, S, index, curr_sum)\\n        \\n    def dp(self, nums, target, index, curr_sum):\\n\\t\\t# Base Cases\\n        if index < 0 and curr_sum == target:\\n            return 1\\n        if index < 0:\\n            return 0 \\n        \\n\\t\\t# Decisions\\n        positive = self.dp(nums, target, index-1, curr_sum + nums[index])\\n        negative = self.dp(nums, target, index-1, curr_sum + -nums[index])\\n        \\n        return positive + negative\\n   ```\\n   \\n6. Optimize\\n   Once we introduce memoization, we will only solve each subproblem ONCE. We can remove recursion altogether and avoid the overhead and potential of a stack overflow by introducing tabulation. It\\'s important to note that the top down recursive and bottom up tabulation methods perform the EXACT same amount of work. The only different is memory. If they peform the exact same amount of work, the conversion just requires us to specify the order in which problems should be solved. This post is really long now so I won\\'t cover these steps here, possibly in a future post.\\n \\nMemoization Solution for Reference\\n```\\nclass Solution:\\n    def findTargetSumWays(self, nums, S):\\n        index = len(nums) - 1\\n        curr_sum = 0\\n        self.memo = {}\\n        return self.dp(nums, S, index, curr_sum)\\n        \\n    def dp(self, nums, target, index, curr_sum):\\n        if (index, curr_sum) in self.memo:\\n            return self.memo[(index, curr_sum)]\\n        \\n        if index < 0 and curr_sum == target:\\n            return 1\\n        if index < 0:\\n            return 0 \\n        \\n        positive = self.dp(nums, target, index-1, curr_sum + nums[index])\\n        negative = self.dp(nums, target, index-1, curr_sum + -nums[index])\\n        \\n        self.memo[(index, curr_sum)] = positive + negative\\n        return self.memo[(index, curr_sum)]\\n```\\n\\nLeave a comment on what DP problems you would like this type of post for next and upvote this solution if you found it helpful. I\\'d like to get this to the top because I\\'m honestly tired of seeing straight optimized tabulated solutions with no THINKING process behind it. \\n\\nDP IS EASY!\\n\\nThanks.",
                "solutionTags": [],
                "code": "```\\n    def findTargetSumWays(self, nums, S):\\n        index = len(nums) - 1\\n        curr_sum = 0\\n        return self.dp(nums, S, index, curr_sum)\\n        \\n    def dp(self, nums, target, index, curr_sum):\\n\\t\\t# Base Cases\\n        if index < 0 and curr_sum == target:\\n            return 1\\n        if index < 0:\\n            return 0 \\n        \\n\\t\\t# Decisions\\n        positive = self.dp(nums, target, index-1, curr_sum + nums[index])\\n        negative = self.dp(nums, target, index-1, curr_sum + -nums[index])\\n        \\n        return positive + negative\\n   ```\n```\\nclass Solution:\\n    def findTargetSumWays(self, nums, S):\\n        index = len(nums) - 1\\n        curr_sum = 0\\n        self.memo = {}\\n        return self.dp(nums, S, index, curr_sum)\\n        \\n    def dp(self, nums, target, index, curr_sum):\\n        if (index, curr_sum) in self.memo:\\n            return self.memo[(index, curr_sum)]\\n        \\n        if index < 0 and curr_sum == target:\\n            return 1\\n        if index < 0:\\n            return 0 \\n        \\n        positive = self.dp(nums, target, index-1, curr_sum + nums[index])\\n        negative = self.dp(nums, target, index-1, curr_sum + -nums[index])\\n        \\n        self.memo[(index, curr_sum)] = positive + negative\\n        return self.memo[(index, curr_sum)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97334,
                "title": "java-15-ms-c-3-ms-o-ns-iterative-dp-solution-using-subset-sum-with-explanation",
                "content": "The recursive solution is very slow, because its runtime is exponential\\n\\nThe original problem statement is equivalent to:\\nFind a **subset** of ```nums``` that need to be positive, and the rest of them negative, such that the sum is equal to ```target```\\n\\nLet ```P``` be the positive subset and ```N``` be the negative subset\\nFor example:\\nGiven ```nums = [1, 2, 3, 4, 5]``` and ```target = 3``` then one possible solution is ```+1-2+3-4+5 = 3```\\nHere positive subset is ```P = [1, 3, 5]``` and negative subset is ```N = [2, 4]```\\n\\nThen let's see how this can be converted to a subset sum problem:\\n```\\n                  sum(P) - sum(N) = target\\nsum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)\\n                       2 * sum(P) = target + sum(nums)\\n``` \\nSo the original problem has been converted to a subset sum problem as follows:\\nFind a **subset** ```P``` of ```nums``` such that ```sum(P) = (target + sum(nums)) / 2```\\n\\nNote that the above formula has proved that ```target + sum(nums)``` must be even\\nWe can use that fact to quickly identify inputs that do not have a solution (Thanks to @BrunoDeNadaiSarnaglia for the suggestion)\\nFor detailed explanation on how to solve subset sum problem, you may refer to [Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)\\n\\nHere is Java solution (15 ms)\\n```\\n    public int findTargetSumWays(int[] nums, int s) {\\n        int sum = 0;\\n        for (int n : nums)\\n            sum += n;\\n        return sum < s || (s + sum) % 2 > 0 ? 0 : subsetSum(nums, (s + sum) >>> 1); \\n    }   \\n\\n    public int subsetSum(int[] nums, int s) {\\n        int[] dp = new int[s + 1]; \\n        dp[0] = 1;\\n        for (int n : nums)\\n            for (int i = s; i >= n; i--)\\n                dp[i] += dp[i - n]; \\n        return dp[s];\\n    } \\n```\\n\\nHere is C++ solution (3 ms)\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int s) {\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        return sum < s || (s + sum) & 1 ? 0 : subsetSum(nums, (s + sum) >> 1); \\n    }   \\n\\n    int subsetSum(vector<int>& nums, int s) {\\n        int dp[s + 1] = { 0 };\\n        dp[0] = 1;\\n        for (int n : nums)\\n            for (int i = s; i >= n; i--)\\n                dp[i] += dp[i - n];\\n        return dp[s];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```nums```\n```target```\n```P```\n```N```\n```nums = [1, 2, 3, 4, 5]```\n```target = 3```\n```+1-2+3-4+5 = 3```\n```P = [1, 3, 5]```\n```N = [2, 4]```\n```\\n                  sum(P) - sum(N) = target\\nsum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)\\n                       2 * sum(P) = target + sum(nums)\\n```\n```P```\n```nums```\n```sum(P) = (target + sum(nums)) / 2```\n```target + sum(nums)```\n```\\n    public int findTargetSumWays(int[] nums, int s) {\\n        int sum = 0;\\n        for (int n : nums)\\n            sum += n;\\n        return sum < s || (s + sum) % 2 > 0 ? 0 : subsetSum(nums, (s + sum) >>> 1); \\n    }   \\n\\n    public int subsetSum(int[] nums, int s) {\\n        int[] dp = new int[s + 1]; \\n        dp[0] = 1;\\n        for (int n : nums)\\n            for (int i = s; i >= n; i--)\\n                dp[i] += dp[i - n]; \\n        return dp[s];\\n    } \\n```\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int s) {\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        return sum < s || (s + sum) & 1 ? 0 : subsetSum(nums, (s + sum) >> 1); \\n    }   \\n\\n    int subsetSum(vector<int>& nums, int s) {\\n        int dp[s + 1] = { 0 };\\n        dp[0] = 1;\\n        for (int n : nums)\\n            for (int i = s; i >= n; i--)\\n                dp[i] += dp[i - n];\\n        return dp[s];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97335,
                "title": "short-java-dp-solution-with-explanation",
                "content": "```\\npublic class Solution {\\n    public int findTargetSumWays(int[] nums, int s) {\\n        int sum = 0; \\n        for(int i: nums) sum+=i;\\n        if(s>sum || s<-sum) return 0;\\n        int[] dp = new int[2*sum+1];\\n        dp[0+sum] = 1;\\n        for(int i = 0; i<nums.length; i++){\\n            int[] next = new int[2*sum+1];\\n            for(int k = 0; k<2*sum+1; k++){\\n                if(dp[k]!=0){\\n                    next[k + nums[i]] += dp[k];\\n                    next[k - nums[i]] += dp[k];\\n                }\\n            }\\n            dp = next;\\n        }\\n        return dp[sum+s];\\n    }\\n}\\n```\\n\\n![0_1485048724190_Screen Shot 2017-01-21 at 8.31.48 PM.jpg](/uploads/files/1485048726667-screen-shot-2017-01-21-at-8.31.48-pm.jpg)",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findTargetSumWays(int[] nums, int s) {\\n        int sum = 0; \\n        for(int i: nums) sum+=i;\\n        if(s>sum || s<-sum) return 0;\\n        int[] dp = new int[2*sum+1];\\n        dp[0+sum] = 1;\\n        for(int i = 0; i<nums.length; i++){\\n            int[] next = new int[2*sum+1];\\n            for(int k = 0; k<2*sum+1; k++){\\n                if(dp[k]!=0){\\n                    next[k + nums[i]] += dp[k];\\n                    next[k - nums[i]] += dp[k];\\n                }\\n            }\\n            dp = next;\\n        }\\n        return dp[sum+s];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97369,
                "title": "evolve-from-brute-force-to-dp",
                "content": "This is similar to [Partition Equal Subset Sum](https://discuss.leetcode.com/topic/80074/evolve-from-brute-force-to-dp).\\n1. O(2^n) brute force \\n```\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        return find(0,nums,S);    \\n    }\\n    int find(int p, vector<int>& nums, int sum) {\\n        if(p==nums.size()) return sum==0;\\n        return find(p+1,nums,sum+nums[p])+find(p+1,nums,sum-nums[p]);\\n    }\\n```\\n2. O(ns) Memoization. There is redundancy in brute force. A call to find() with the same start index and target sum can be made multiple times. We can use a 2d table to cache the result to avoid duplicate calls with the same state.\\n```\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        vector<unordered_map<int,int>> mem(nums.size());\\n        return find(0,nums,S,mem);    \\n    }\\n    int find(int p, vector<int>& nums, int sum, vector<unordered_map<int,int>>& mem) {\\n        if(p==nums.size()) return sum==0;\\n        auto it = mem[p].find(sum);\\n        if(it != mem[p].end()) return it->second;\\n        return mem[p][sum]=find(p+1,nums,sum+nums[p],mem)+find(p+1,nums,sum-nums[p],mem);\\n    }\\n```\\n3. O(ns) pseudo polynomial dp, s is the target sum. Most dp problems visits continuous states and this is a great example to use hashtable to visit valid states only.\\n```\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        int n = nums.size();\\n        vector<unordered_map<int,int>> dp(n+1);\\n        dp[0][0]=1;\\n        for(int i=0;i<n;i++)\\n            for(auto &p:dp[i]) {\\n                dp[i+1][p.first+nums[i]] += p.second; \\n                dp[i+1][p.first-nums[i]] += p.second;\\n            }\\n        return dp[n][S];\\n    }\\n```\\n4. O(ns) time, linear space dp.\\n```\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        unordered_map<int,int> cur({{0,1}}), nxt, *p_cur=&cur, *p_nxt=&nxt;\\n        for(int i=0;i<nums.size();i++) {\\n            for(auto &p:*p_cur) {\\n                (*p_nxt)[p.first+nums[i]] += p.second; \\n                (*p_nxt)[p.first-nums[i]] += p.second;\\n            }\\n            swap(p_cur,p_nxt);\\n            p_nxt->clear();\\n        }\\n        return (*p_cur)[S];\\n    }\\n```\\n5. O(ns) dp with continuous states. When hashtable is replaced by vector, test cases show significant runtime improvement. #4 is theoretically better because it does not visit invalid states.\\n```\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        int sum = accumulate(nums.begin(),nums.end(),0);\\n        if(S>sum || S<-sum) return 0;\\n        vector<int> cur(2*sum+1), nxt(2*sum+1), *p_cur = &cur, *p_nxt = &nxt;\\n        cur[sum] = 1;\\n        for(int i=0;i<nums.size();i++) {\\n            for(int j=0;j<=2*sum;j++) \\n                if(p_cur->at(j)) {\\n                    p_nxt->at(j+nums[i]) += p_cur->at(j);\\n                    p_nxt->at(j-nums[i]) += p_cur->at(j);\\n                }\\n            swap(p_cur,p_nxt);\\n            p_nxt->assign(2*sum+1,0);\\n        }\\n        return p_cur->at(S+sum);\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        return find(0,nums,S);    \\n    }\\n    int find(int p, vector<int>& nums, int sum) {\\n        if(p==nums.size()) return sum==0;\\n        return find(p+1,nums,sum+nums[p])+find(p+1,nums,sum-nums[p]);\\n    }\\n```\n```\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        vector<unordered_map<int,int>> mem(nums.size());\\n        return find(0,nums,S,mem);    \\n    }\\n    int find(int p, vector<int>& nums, int sum, vector<unordered_map<int,int>>& mem) {\\n        if(p==nums.size()) return sum==0;\\n        auto it = mem[p].find(sum);\\n        if(it != mem[p].end()) return it->second;\\n        return mem[p][sum]=find(p+1,nums,sum+nums[p],mem)+find(p+1,nums,sum-nums[p],mem);\\n    }\\n```\n```\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        int n = nums.size();\\n        vector<unordered_map<int,int>> dp(n+1);\\n        dp[0][0]=1;\\n        for(int i=0;i<n;i++)\\n            for(auto &p:dp[i]) {\\n                dp[i+1][p.first+nums[i]] += p.second; \\n                dp[i+1][p.first-nums[i]] += p.second;\\n            }\\n        return dp[n][S];\\n    }\\n```\n```\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        unordered_map<int,int> cur({{0,1}}), nxt, *p_cur=&cur, *p_nxt=&nxt;\\n        for(int i=0;i<nums.size();i++) {\\n            for(auto &p:*p_cur) {\\n                (*p_nxt)[p.first+nums[i]] += p.second; \\n                (*p_nxt)[p.first-nums[i]] += p.second;\\n            }\\n            swap(p_cur,p_nxt);\\n            p_nxt->clear();\\n        }\\n        return (*p_cur)[S];\\n    }\\n```\n```\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        int sum = accumulate(nums.begin(),nums.end(),0);\\n        if(S>sum || S<-sum) return 0;\\n        vector<int> cur(2*sum+1), nxt(2*sum+1), *p_cur = &cur, *p_nxt = &nxt;\\n        cur[sum] = 1;\\n        for(int i=0;i<nums.size();i++) {\\n            for(int j=0;j<=2*sum;j++) \\n                if(p_cur->at(j)) {\\n                    p_nxt->at(j+nums[i]) += p_cur->at(j);\\n                    p_nxt->at(j-nums[i]) += p_cur->at(j);\\n                }\\n            swap(p_cur,p_nxt);\\n            p_nxt->assign(2*sum+1,0);\\n        }\\n        return p_cur->at(S+sum);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 97439,
                "title": "java-python-easily-understood",
                "content": "## **Explanation**:\\n\\nPython solution, but it\\'s really easy to understand.\\nTo make it clear for everyone, find following the syntax for get() method of dictionary(hase map)\\n````\\ndict.get(key, default)\\n````\\nThe method get() returns a value for the given key. If key is not available then returns default value.\\n<br>\\n\\n**Java**\\nFrom @mkn1921\\n```java\\n    public int findTargetSumWays(int[] nums, int s) {\\n        Map<Integer, Integer> dp = new HashMap();\\n        dp.put(0, 1);\\n        for (int num : nums) {\\n            Map<Integer, Integer> dp2 = new HashMap();\\n            for (int tempSum : dp.keySet()) {\\n                int key1 = tempSum + num;\\n                dp2.put(key1, dp2.getOrDefault(key1, 0) + dp.get(tempSum));\\n                int key2 = tempSum - num;\\n                dp2.put(key2, dp2.getOrDefault(key2, 0) + dp.get(tempSum));\\n            }\\n            dp = dp2;\\n        }\\n        return dp.getOrDefault(s, 0);\\n    }\\n```\\n\\n**Python**\\n````py\\n    def findTargetSumWays(self, A, S):\\n        count = collections.Counter({0: 1})\\n        for x in A:\\n            step = collections.Counter()\\n            for y in count:\\n                step[y + x] += count[y]\\n                step[y - x] += count[y]\\n            count = step\\n        return count[S]\\n````",
                "solutionTags": [],
                "code": "````\\ndict.get(key, default)\\n```\n```java\\n    public int findTargetSumWays(int[] nums, int s) {\\n        Map<Integer, Integer> dp = new HashMap();\\n        dp.put(0, 1);\\n        for (int num : nums) {\\n            Map<Integer, Integer> dp2 = new HashMap();\\n            for (int tempSum : dp.keySet()) {\\n                int key1 = tempSum + num;\\n                dp2.put(key1, dp2.getOrDefault(key1, 0) + dp.get(tempSum));\\n                int key2 = tempSum - num;\\n                dp2.put(key2, dp2.getOrDefault(key2, 0) + dp.get(tempSum));\\n            }\\n            dp = dp2;\\n        }\\n        return dp.getOrDefault(s, 0);\\n    }\\n```\n````py\\n    def findTargetSumWays(self, A, S):\\n        count = collections.Counter({0: 1})\\n        for x in A:\\n            step = collections.Counter()\\n            for y in count:\\n                step[y + x] += count[y]\\n                step[y - x] += count[y]\\n            count = step\\n        return count[S]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 97333,
                "title": "java-simple-dfs-with-memorization",
                "content": "I'm quite surprised that simple DFS could pass the test since for DFS solution there are obvious a lot of overlap subproblems. So I used a map to record the intermediate result while we are walking along the recursion tree.\\n```\\npublic class Solution {\\n    public int findTargetSumWays(int[] nums, int S) {\\n        if (nums == null || nums.length == 0){\\n            return 0;\\n        }\\n        return helper(nums, 0, 0, S, new HashMap<>());\\n    }\\n    private int helper(int[] nums, int index, int sum, int S, Map<String, Integer> map){\\n        String encodeString = index + \"->\" + sum;\\n        if (map.containsKey(encodeString)){\\n            return map.get(encodeString);\\n        }\\n        if (index == nums.length){\\n            if (sum == S){\\n                return 1;\\n            }else {\\n                return 0;\\n            }\\n        }\\n        int curNum = nums[index];\\n        int add = helper(nums, index + 1, sum - curNum, S, map);\\n        int minus = helper(nums, index + 1, sum + curNum, S, map);\\n        map.put(encodeString, add + minus);\\n        return add + minus;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findTargetSumWays(int[] nums, int S) {\\n        if (nums == null || nums.length == 0){\\n            return 0;\\n        }\\n        return helper(nums, 0, 0, S, new HashMap<>());\\n    }\\n    private int helper(int[] nums, int index, int sum, int S, Map<String, Integer> map){\\n        String encodeString = index + \"->\" + sum;\\n        if (map.containsKey(encodeString)){\\n            return map.get(encodeString);\\n        }\\n        if (index == nums.length){\\n            if (sum == S){\\n                return 1;\\n            }else {\\n                return 0;\\n            }\\n        }\\n        int curNum = nums[index];\\n        int add = helper(nums, index + 1, sum - curNum, S, map);\\n        int minus = helper(nums, index + 1, sum + curNum, S, map);\\n        map.put(encodeString, add + minus);\\n        return add + minus;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 169648,
                "title": "java-dfs-memorization-with-explanations",
                "content": "**Thought**\\nTake `nums = [1, 1, 1]` for example, part of potential search tree is as below:\\n```\\n       start\\n    /         \\\\\\n    +1(11)     ...\\n  /        \\\\\\n +1+1(1)    +1-1(1)\\n   /  \\\\        /   \\\\\\n+1+1+1 +1+1-1 +1-1+1 +1-1-1\\n```\\n\\n\\nMy **understanding of Backtracking** is attached for your reference:\\n**Backtracking** is an optimized Exhaustive Search for it abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be completed to a valid solution.\\nPeople usually use **Recursion** to implement Backtracking. Thus, there should be base cases to terminate recursion, which means that you reach the leaves of the **potential searching tree**. Moreover, there are always **tuning cases** to terminate the recursion earlier - that\\'s so-called optimization. After termination, the procedure goes back to its previous stack frame automatically. So we take advantage of the recursion execution order to make our procedure backtrack.\\n\\n\\n**Code**\\n```\\n    private static Map<String, Integer> memo; // key: serialized curIndex and targetSum, value: its corresponding number of ways\\n    \\n    public int findTargetSumWays(int[] nums, int S) {\\n        memo = new HashMap<>();        \\n        return findTargetSumWaysRecur(nums, S, 0, S);\\n    }\\n    \\n    private static int findTargetSumWaysRecur(int[] nums, int S, int curIndex, int targetSum) {\\n        \\n        String curSerial= serialize(curIndex, targetSum);\\n        if (memo.containsKey(curSerial)) {\\n            return memo.get(curSerial);\\n        }\\n        \\n        if (curIndex == nums.length) {\\n            if (targetSum == 0) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        int numWaysIfMinus = findTargetSumWaysRecur(nums, S, curIndex + 1, targetSum + nums[curIndex]); // -nums[curIndex]\\n        int numWaysIfAdd = findTargetSumWaysRecur(nums, S, curIndex + 1, targetSum - nums[curIndex]); // +nums[curIndex]\\n        \\n        int numWays =  numWaysIfMinus + numWaysIfAdd; \\n        memo.put(curSerial, numWays);\\n        return numWays;\\n    }\\n    \\n    private static String serialize(int curIndex, int targetSum) {\\n        return curIndex + \",\" + targetSum;\\n    }\\n```\\n**I appreciate your VOTE UP (\\u25B0\\u2579\\u25E1\\u2579\\u25B0)**",
                "solutionTags": [],
                "code": "```\\n       start\\n    /         \\\\\\n    +1(11)     ...\\n  /        \\\\\\n +1+1(1)    +1-1(1)\\n   /  \\\\        /   \\\\\\n+1+1+1 +1+1-1 +1-1+1 +1-1-1\\n```\n```\\n    private static Map<String, Integer> memo; // key: serialized curIndex and targetSum, value: its corresponding number of ways\\n    \\n    public int findTargetSumWays(int[] nums, int S) {\\n        memo = new HashMap<>();        \\n        return findTargetSumWaysRecur(nums, S, 0, S);\\n    }\\n    \\n    private static int findTargetSumWaysRecur(int[] nums, int S, int curIndex, int targetSum) {\\n        \\n        String curSerial= serialize(curIndex, targetSum);\\n        if (memo.containsKey(curSerial)) {\\n            return memo.get(curSerial);\\n        }\\n        \\n        if (curIndex == nums.length) {\\n            if (targetSum == 0) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        int numWaysIfMinus = findTargetSumWaysRecur(nums, S, curIndex + 1, targetSum + nums[curIndex]); // -nums[curIndex]\\n        int numWaysIfAdd = findTargetSumWaysRecur(nums, S, curIndex + 1, targetSum - nums[curIndex]); // +nums[curIndex]\\n        \\n        int numWays =  numWaysIfMinus + numWaysIfAdd; \\n        memo.put(curSerial, numWays);\\n        return numWays;\\n    }\\n    \\n    private static String serialize(int curIndex, int targetSum) {\\n        return curIndex + \",\" + targetSum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1247293,
                "title": "c-bottom-up-dp",
                "content": "```\\n //This question is same as number of subsets with given difference \\n    int countSubsets(vector<int>& nums, int n, int M)\\n    {\\n        int t[n+1][M+1];\\n\\n        for(int i=0; i<=n; i++)\\n        {\\n            for(int j=0; j<=M; j++)\\n            {\\n                if(i==0)\\n                    t[i][j]=0;\\n                if(j==0)\\n                    t[i][j]=1;\\n            }\\n        }\\n\\n        //t[0][0] = 1;\\n\\n        for(int i=1; i<=n; i++)\\n        {\\n            for(int j=0; j<=M; j++)\\n            {\\n                if(nums[i-1]<=j)\\n                    t[i][j]=t[i-1][j-nums[i-1]]+t[i-1][j];\\n                else\\n                    t[i][j]=t[i-1][j];\\n            }\\n        }\\n\\n        return t[n][M];  \\n    }\\n\\n    int findTargetSumWays(vector<int>& nums, int target)\\n    {\\n         target=abs(target);\\n         int n=nums.size();\\n         int sum=0;\\n\\n         for(int i=0; i<n; i++)\\n             sum+=nums[i];\\n\\n        int M=(sum+target)/2;\\n        if(sum<target||(sum+target)%2!=0)\\n            return 0;\\n        \\n         return countSubsets(nums, n, M);\\n    }  \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n //This question is same as number of subsets with given difference \\n    int countSubsets(vector<int>& nums, int n, int M)\\n    {\\n        int t[n+1][M+1];\\n\\n        for(int i=0; i<=n; i++)\\n        {\\n            for(int j=0; j<=M; j++)\\n            {\\n                if(i==0)\\n                    t[i][j]=0;\\n                if(j==0)\\n                    t[i][j]=1;\\n            }\\n        }\\n\\n        //t[0][0] = 1;\\n\\n        for(int i=1; i<=n; i++)\\n        {\\n            for(int j=0; j<=M; j++)\\n            {\\n                if(nums[i-1]<=j)\\n                    t[i][j]=t[i-1][j-nums[i-1]]+t[i-1][j];\\n                else\\n                    t[i][j]=t[i-1][j];\\n            }\\n        }\\n\\n        return t[n][M];  \\n    }\\n\\n    int findTargetSumWays(vector<int>& nums, int target)\\n    {\\n         target=abs(target);\\n         int n=nums.size();\\n         int sum=0;\\n\\n         for(int i=0; i<n; i++)\\n             sum+=nums[i];\\n\\n        int M=(sum+target)/2;\\n        if(sum<target||(sum+target)%2!=0)\\n            return 0;\\n        \\n         return countSubsets(nums, n, M);\\n    }  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 97343,
                "title": "python-dp",
                "content": "```\\nclass Solution(object):\\n    def findTargetSumWays(self, nums, S):\\n        if not nums:\\n            return 0\\n        dic = {nums[0]: 1, -nums[0]: 1} if nums[0] != 0 else {0: 2}\\n        for i in range(1, len(nums)):\\n            tdic = {}\\n            for d in dic:\\n                tdic[d + nums[i]] = tdic.get(d + nums[i], 0) + dic.get(d, 0)\\n                tdic[d - nums[i]] = tdic.get(d - nums[i], 0) + dic.get(d, 0)\\n            dic = tdic\\n        return dic.get(S, 0)\\n```\\n\\nFYI: pomodoro timer helps to obtain higher time ROI:  [e-tomato.online](http://e-tomato.online)",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findTargetSumWays(self, nums, S):\\n        if not nums:\\n            return 0\\n        dic = {nums[0]: 1, -nums[0]: 1} if nums[0] != 0 else {0: 2}\\n        for i in range(1, len(nums)):\\n            tdic = {}\\n            for d in dic:\\n                tdic[d + nums[i]] = tdic.get(d + nums[i], 0) + dic.get(d, 0)\\n                tdic[d - nums[i]] = tdic.get(d - nums[i], 0) + dic.get(d, 0)\\n            dic = tdic\\n        return dic.get(S, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97371,
                "title": "java-short-dfs-solution",
                "content": "This is a pretty easy problem. Just do DFS and try both \"+\" and \"-\" at every position. Easy version of ```Expression Add Operators``` https://leetcode.com/problems/expression-add-operators/\\n\\n```\\npublic class Solution {\\n    int result = 0;\\n\\t\\n    public int findTargetSumWays(int[] nums, int S) {\\n        if (nums == null || nums.length == 0) return result;\\n        helper(nums, S, 0, 0);\\n        return result;\\n    }\\n    \\n    public void helper(int[] nums, int target, int pos, long eval){\\n        if (pos == nums.length) {\\n            if (target == eval) result++;\\n            return;\\n        }\\n        helper(nums, target, pos + 1, eval + nums[pos]);\\n        helper(nums, target, pos + 1, eval - nums[pos]);\\n    }\\n}\\n```\\n\\nOptimization: The idea is ```If the sum of all elements left is smaller than absolute value of target, there will be no answer following the current path. Thus we can return.```\\n```\\npublic class Solution {\\n    int result = 0;\\n\\t\\n    public int findTargetSumWays(int[] nums, int S) {\\n        if(nums == null || nums.length == 0) return result;\\n        \\n        int n = nums.length;\\n        int[] sums = new int[n];\\n        sums[n - 1] = nums[n - 1];\\n        for (int i = n - 2; i >= 0; i--)\\n            sums[i] = sums[i + 1] + nums[i];\\n        \\n        helper(nums, sums, S, 0);\\n        return result;\\n    }\\n    public void helper(int[] nums, int[] sums, int target, int pos){\\n        if(pos == nums.length){\\n            if(target == 0) result++;\\n            return;\\n        }\\n        \\n        if (sums[pos] < Math.abs(target)) return;\\n        \\n        helper(nums, sums, target + nums[pos], pos + 1);\\n        helper(nums, sums, target - nums[pos], pos + 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Expression Add Operators```\n```\\npublic class Solution {\\n    int result = 0;\\n\\t\\n    public int findTargetSumWays(int[] nums, int S) {\\n        if (nums == null || nums.length == 0) return result;\\n        helper(nums, S, 0, 0);\\n        return result;\\n    }\\n    \\n    public void helper(int[] nums, int target, int pos, long eval){\\n        if (pos == nums.length) {\\n            if (target == eval) result++;\\n            return;\\n        }\\n        helper(nums, target, pos + 1, eval + nums[pos]);\\n        helper(nums, target, pos + 1, eval - nums[pos]);\\n    }\\n}\\n```\n```If the sum of all elements left is smaller than absolute value of target, there will be no answer following the current path. Thus we can return.```\n```\\npublic class Solution {\\n    int result = 0;\\n\\t\\n    public int findTargetSumWays(int[] nums, int S) {\\n        if(nums == null || nums.length == 0) return result;\\n        \\n        int n = nums.length;\\n        int[] sums = new int[n];\\n        sums[n - 1] = nums[n - 1];\\n        for (int i = n - 2; i >= 0; i--)\\n            sums[i] = sums[i + 1] + nums[i];\\n        \\n        helper(nums, sums, S, 0);\\n        return result;\\n    }\\n    public void helper(int[] nums, int[] sums, int target, int pos){\\n        if(pos == nums.length){\\n            if(target == 0) result++;\\n            return;\\n        }\\n        \\n        if (sums[pos] < Math.abs(target)) return;\\n        \\n        helper(nums, sums, target + nums[pos], pos + 1);\\n        helper(nums, sums, target - nums[pos], pos + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371814,
                "title": "aditya-verma-solution",
                "content": "```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n        //Solution 1\\n        int sum = 0;\\n        for(int x : nums)\\n            sum += x;\\n        if(((sum - target) % 2 == 1) || (target > sum))\\n            return 0;\\n        \\n        int n = nums.length;\\n        int s2 = (sum - target)/2;\\n        int[][] t = new int[n + 1][s2 + 1];\\n        t[0][0] = 1;\\n        \\n        for(int i = 1; i < n + 1; i++) {\\n            for(int j = 0; j < s2 + 1; j++) {\\n                if(nums[i - 1] <= j)\\n                    t[i][j] = t[i-1][j] + t[i - 1][j - nums[i - 1]];\\n                else\\n                    t[i][j] = t[i - 1][j];\\n            }\\n        }\\n        return t[n][s2];\\n        \\n           //Solution 2\\n//         int sum = 0;\\n//         for(int x : nums)\\n//             sum += x;\\n//         if(((sum - target) % 2 != 0) || (target > sum))\\n//             return 0;\\n        \\n//         int n = nums.length;\\n//         int s2 = (sum - target)/2;\\n        \\n//         int[][] t = new int[n + 1][s2 + 1];\\n//         for(int i = 0; i < n + 1; i++) {\\n//             for(int j = 0; j < s2 + 1; j++) {\\n//                 if(i == 0)\\n//                     t[i][j] = 0;\\n//                 if(j == 0)\\n//                     t[i][j] = 1;\\n//             }\\n//         }\\n        \\n//         for(int i = 1; i < n + 1; i++) {\\n//             for(int j = 1; j < s2 + 1; j++) {\\n//                 if((nums[i - 1] > j) || (nums[i - 1] == 0))\\n//                     t[i][j] = t[i - 1][j];\\n//                 else\\n//                     t[i][j] = t[i - 1][j] + t[i - 1][j - nums[i - 1]];\\n//             }\\n//         }\\n        \\n//         int count = 0;\\n//         for(int x : nums)\\n//             if(x == 0)\\n//                 count++;\\n        \\n//         return (int)(Math.pow(2,count)) * t[n][s2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n        //Solution 1\\n        int sum = 0;\\n        for(int x : nums)\\n            sum += x;\\n        if(((sum - target) % 2 == 1) || (target > sum))\\n            return 0;\\n        \\n        int n = nums.length;\\n        int s2 = (sum - target)/2;\\n        int[][] t = new int[n + 1][s2 + 1];\\n        t[0][0] = 1;\\n        \\n        for(int i = 1; i < n + 1; i++) {\\n            for(int j = 0; j < s2 + 1; j++) {\\n                if(nums[i - 1] <= j)\\n                    t[i][j] = t[i-1][j] + t[i - 1][j - nums[i - 1]];\\n                else\\n                    t[i][j] = t[i - 1][j];\\n            }\\n        }\\n        return t[n][s2];\\n        \\n           //Solution 2\\n//         int sum = 0;\\n//         for(int x : nums)\\n//             sum += x;\\n//         if(((sum - target) % 2 != 0) || (target > sum))\\n//             return 0;\\n        \\n//         int n = nums.length;\\n//         int s2 = (sum - target)/2;\\n        \\n//         int[][] t = new int[n + 1][s2 + 1];\\n//         for(int i = 0; i < n + 1; i++) {\\n//             for(int j = 0; j < s2 + 1; j++) {\\n//                 if(i == 0)\\n//                     t[i][j] = 0;\\n//                 if(j == 0)\\n//                     t[i][j] = 1;\\n//             }\\n//         }\\n        \\n//         for(int i = 1; i < n + 1; i++) {\\n//             for(int j = 1; j < s2 + 1; j++) {\\n//                 if((nums[i - 1] > j) || (nums[i - 1] == 0))\\n//                     t[i][j] = t[i - 1][j];\\n//                 else\\n//                     t[i][j] = t[i - 1][j] + t[i - 1][j - nums[i - 1]];\\n//             }\\n//         }\\n        \\n//         int count = 0;\\n//         for(int x : nums)\\n//             if(x == 0)\\n//                 count++;\\n        \\n//         return (int)(Math.pow(2,count)) * t[n][s2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174595,
                "title": "99-faster-using-dp-formula-explain",
                "content": "**Explanation**\\nlet S1 be the first subarray and S2 be the second subarray \\nS1 + S2 = sum\\n S1 - S2 = target\\n => 2*S1 = sum + target\\n => S1 = (sum + target)/2\\n  \\n  example -> [1,1,1,1,1], target = 3\\n  +1 + 1 + 1 + 1 - 1 = 3\\n  here we can see that we are having two subarray \\n  S1 =[1,1,1,1]\\n  S2 =[1]\\n  S1 - S2 = target              // [1,1,1,1] - [1]    -----------------equation(1)\\n  S1 + S2 = sum              // [1,1,1,1] + [1]     -----------------equation(2)\\n  by solving above two equation \\n  => S1 = (target+sum)/2                   //new_target\\n \\n ![image](https://assets.leetcode.com/users/images/0646712c-1d9f-4fab-8761-8c9ea5129ae8_1620903712.2822595.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        int new_target = (sum + target)/2;\\n        //if sum is less than target or numerator of new_target is odd then there will be no ways hence we will return 0\\n        if(sum < target || (sum + target)%2 != 0)\\n            return 0;\\n        \\n        vector<int>dp(new_target+1, 0);\\n        dp[0] = 1;\\n        for(int i = 0; i < n; i++)\\n            for(int j = new_target; j >= nums[i]; j--)\\n                dp[j] += dp[j-nums[i]];\\n        return dp[new_target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        int new_target = (sum + target)/2;\\n        //if sum is less than target or numerator of new_target is odd then there will be no ways hence we will return 0\\n        if(sum < target || (sum + target)%2 != 0)\\n            return 0;\\n        \\n        vector<int>dp(new_target+1, 0);\\n        dp[0] = 1;\\n        for(int i = 0; i < n; i++)\\n            for(int j = new_target; j >= nums[i]; j--)\\n                dp[j] += dp[j-nums[i]];\\n        return dp[new_target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470377,
                "title": "c-dp-similar-to-count-of-subset-with-given-sum-inspired-by-aditya-verma",
                "content": "First let me give you the solution for `count of subset sum problem` (which is a variation of our standard Knapsack problem) then we will see the changes needed to solve this problem:\\n\\n### **Count of subset sum problem**\\n**Question**: Given an array arr[] of integers and an integer sum, the task is to count all subsets of the given array with a sum equal to a given sum.\\n\\n```c++\\nInput: N = 6, arr[] = {2, 3, 5, 6, 8, 10}, sum = 10\\nOutput: 3\\nExplanation: {2, 3, 5}, {2, 8}, {10}\\n```\\n**Solution**:  \\n```c++\\nclass Solution{\\n\\n\\tpublic:\\n\\tint subsetCount(int arr[], int n, int sum)\\n\\t{\\n       int t[n+1][sum+1];\\n       for(int i=1;i<sum+1;i++)\\n            t[0][i] = 0;\\n       \\n       for(int i=0;i<n+1;i++)\\n            t[i][0] = 1;\\n        \\n        for(int i=1;i<n+1;i++)\\n            for(int j=1;j<sum+1;j++){\\n                if(arr[i-1] <= j)\\n                    t[i][j] = (t[i-1][j] + t[i-1][j-arr[i-1]]);\\n                else\\n                    t[i][j] = t[i-1][j];\\n            }\\n            \\n        return t[n][sum];\\n\\t}\\n\\t  \\n};\\n```\\n\\n\\n### **Target Sum**\\n\\nlet us say we have the array as [1,1,1,1,1] and the target = 3;\\nWe just need to add (+ or -) signs in front of the integers.\\n\\ne.g +1 +1 +1 -1 -1 = 3\\n\\nEssentially, what we are doing is that we are just splitting the numbers into two subsets, one with positive signs and the other with negative signs\\n\\n(1 , 1 , 1) => with positive signs\\n(1 , 1) => with negative signs\\n\\nand we are calculating the difference of the sum of these two sets\\n(1 , 1 , 1) => with positive signs , sum = 3\\n(1 , 1) => with negative signs , sum = 2\\n\\ndiff = target = (3-2) = 1\\n\\nSo we just need to find all such pairs of subsets whose sum difference is equal to our given target.\\n\\nConsider S1 and S2 to be one such pair then the following equations holds\\n\\nS1 - S2 = target \\nS1 + S2 = sum of all the elements\\n\\nBy simplifing the above 2 equations we get,  2* S1 = target + Sum of all the elements\\n\\n=> S1 = (target + Sum of all the elements) / 2\\n\\nSo, this problem now reduces to just `finding count of subsets which are having sum equal to S1`.\\n\\nThe solution for this is given below.\\n```c++\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        for(int x: nums)\\n            sum += x;\\n        if (abs(target) > sum || (sum + target) % 2 != 0){ \\n            return 0;\\n        }\\n        int s1 = (sum + target)/2;\\n        int ans = subsetCount(nums,s1);\\n        return ans;\\n    }\\n    \\n    int subsetCount(vector<int>& nums, int s1){\\n        int n = nums.size();\\n        int t[n+1][s1+1];\\n        t[0][0] = 1;\\n        for(int i=1;i<s1+1;i++)\\n            t[0][i] = 0;\\n        for(int i=1;i<n+1;i++)\\n            for(int j=0;j<s1+1;j++){\\n                if(nums[i-1] > j)\\n                    t[i][j] = t[i-1][j];\\n                else\\n                    t[i][j] = t[i-1][j] + t[i-1][j-nums[i-1]];\\n            }\\n        \\n        return t[n][s1];\\n    }\\n};\\n```\\n\\nChanges:\\n1. If the absolute value of target is greater than sum then there exists no solutions `abs(target) > sum `\\nand one more condition needs to be checked i.e. `if ((sum + target)%2 != 0)`  then we would never get the difference target by partitioning the array into two subsets.\\n2. Why are we not initializing entire first col to 1 ? like we did in the previous problem it\\'s because here in this problem, we may get 0 as input. Now when we get 0 as input, we have to consider two choices : include this 0 to form subset with sum 0, or exclude this 0 to form subset with sum 0. We initialize entire first col with 1 when we are sure that in the input we will be given numbers >=1 .\\n\\n\\n",
                "solutionTags": [],
                "code": "```c++\\nInput: N = 6, arr[] = {2, 3, 5, 6, 8, 10}, sum = 10\\nOutput: 3\\nExplanation: {2, 3, 5}, {2, 8}, {10}\\n```\n```c++\\nclass Solution{\\n\\n\\tpublic:\\n\\tint subsetCount(int arr[], int n, int sum)\\n\\t{\\n       int t[n+1][sum+1];\\n       for(int i=1;i<sum+1;i++)\\n            t[0][i] = 0;\\n       \\n       for(int i=0;i<n+1;i++)\\n            t[i][0] = 1;\\n        \\n        for(int i=1;i<n+1;i++)\\n            for(int j=1;j<sum+1;j++){\\n                if(arr[i-1] <= j)\\n                    t[i][j] = (t[i-1][j] + t[i-1][j-arr[i-1]]);\\n                else\\n                    t[i][j] = t[i-1][j];\\n            }\\n            \\n        return t[n][sum];\\n\\t}\\n\\t  \\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        for(int x: nums)\\n            sum += x;\\n        if (abs(target) > sum || (sum + target) % 2 != 0){ \\n            return 0;\\n        }\\n        int s1 = (sum + target)/2;\\n        int ans = subsetCount(nums,s1);\\n        return ans;\\n    }\\n    \\n    int subsetCount(vector<int>& nums, int s1){\\n        int n = nums.size();\\n        int t[n+1][s1+1];\\n        t[0][0] = 1;\\n        for(int i=1;i<s1+1;i++)\\n            t[0][i] = 0;\\n        for(int i=1;i<n+1;i++)\\n            for(int j=0;j<s1+1;j++){\\n                if(nums[i-1] > j)\\n                    t[i][j] = t[i-1][j];\\n                else\\n                    t[i][j] = t[i-1][j] + t[i-1][j-nums[i-1]];\\n            }\\n        \\n        return t[n][s1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97340,
                "title": "c-python-short-dp-solution",
                "content": "**C++**\\n```\\nint findTargetSumWays(vector<int>& nums, int S) {\\n\\tint sum = 0;\\n\\tfor (auto n : nums) sum += n;\\n\\tif ((sum + S) % 2 == 1 || S > sum || S < -sum) return 0;\\n\\tint newS = (sum + S) / 2;\\n\\tvector<int> dp(newS + 1, 0);\\n\\tdp[0] = 1;\\n\\tfor (int i = 0; i < nums.size(); ++i) {\\n\\t\\tfor (int j = newS; j >= nums[i]; --j) {\\n\\t\\t\\tdp[j] += dp[j - nums[i]];\\n\\t\\t}\\n\\t}\\n\\treturn dp[newS];\\n}\\n```\\n**Python**\\n```\\ndef findTargetSumWays(self, nums, S):\\n\\t\"\"\"\\n\\t:type nums: List[int]\\n\\t:type S: int\\n\\t:rtype: int\\n\\t\"\"\"\\n\\tnums_sum = sum(nums)\\n\\tif (nums_sum + S) % 2 == 1 or abs(S) > nums_sum:\\n\\t\\treturn 0\\n\\ttarget_sum = (nums_sum + S) / 2\\n\\tdp = [1] + [0] * target_sum\\n\\tfor num in nums:\\n\\t\\tfor s in range(target_sum, num - 1, -1):\\n\\t\\t\\tdp[s] += dp[s - num]\\n\\treturn dp[target_sum]\\n```\\n**Explanation:**\\nWe have nums=[1,2,3,4,5] and S=3 for example. There is a solution 1-2+3-4+5=3. After moving nums in negative to the right side, it becomes 1+3+5=3+2+4. Each side is half of sum(nums)+S. This means we can turn this into a knapsack problem with sacks=nums and target_sum=(sum(nums)+S)/2. In this example sacks=[1,2,3,4,5] and target_sum=9. [1,3,5] is one of the solutions.",
                "solutionTags": [],
                "code": "```\\nint findTargetSumWays(vector<int>& nums, int S) {\\n\\tint sum = 0;\\n\\tfor (auto n : nums) sum += n;\\n\\tif ((sum + S) % 2 == 1 || S > sum || S < -sum) return 0;\\n\\tint newS = (sum + S) / 2;\\n\\tvector<int> dp(newS + 1, 0);\\n\\tdp[0] = 1;\\n\\tfor (int i = 0; i < nums.size(); ++i) {\\n\\t\\tfor (int j = newS; j >= nums[i]; --j) {\\n\\t\\t\\tdp[j] += dp[j - nums[i]];\\n\\t\\t}\\n\\t}\\n\\treturn dp[newS];\\n}\\n```\n```\\ndef findTargetSumWays(self, nums, S):\\n\\t\"\"\"\\n\\t:type nums: List[int]\\n\\t:type S: int\\n\\t:rtype: int\\n\\t\"\"\"\\n\\tnums_sum = sum(nums)\\n\\tif (nums_sum + S) % 2 == 1 or abs(S) > nums_sum:\\n\\t\\treturn 0\\n\\ttarget_sum = (nums_sum + S) / 2\\n\\tdp = [1] + [0] * target_sum\\n\\tfor num in nums:\\n\\t\\tfor s in range(target_sum, num - 1, -1):\\n\\t\\t\\tdp[s] += dp[s - num]\\n\\treturn dp[target_sum]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 97424,
                "title": "python-intuitive-dfs-solution-with-memorization",
                "content": "At first I just remember the current index and current target, and for each index, either subtract the nums[i] from S or add it to S. But this got TLE, them I came up with this solution. Just store the intermediate result with (index, s) and this got accepted.\\n```\\nclass Solution(object):\\n    def findTargetSumWays(self, nums, S):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type S: int\\n        :rtype: int\\n        \"\"\"\\n        def findTarget(i, s):\\n            if (i, s) not in cache:\\n                r = 0\\n                if i == len(nums):\\n                    if s == 0:\\n                        r = 1\\n                else:\\n                    r = findTarget(i+1, s-nums[i]) + findTarget(i+1, s+nums[i])\\n                cache[(i, s)] = r\\n            return cache[(i, s)]\\n        \\n        cache = {}\\n        return findTarget(0, S)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findTargetSumWays(self, nums, S):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type S: int\\n        :rtype: int\\n        \"\"\"\\n        def findTarget(i, s):\\n            if (i, s) not in cache:\\n                r = 0\\n                if i == len(nums):\\n                    if s == 0:\\n                        r = 1\\n                else:\\n                    r = findTarget(i+1, s-nums[i]) + findTarget(i+1, s+nums[i])\\n                cache[(i, s)] = r\\n            return cache[(i, s)]\\n        \\n        cache = {}\\n        return findTarget(0, S)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325250,
                "title": "python-different-soluctions-dfs-bfs-dp",
                "content": "DFS: TLE\\n ```python\\n\\t#DFS:TLE\\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\\n        self.res = 0\\n        def DFS(nums,i,summary):\\n            if i >= len(nums):\\n                if summary == S:\\n                    self.res += 1 \\n                return\\n            DFS(nums,i+1,summary+nums[i])\\n            DFS(nums,i+1,summary-nums[i])\\n        DFS(nums,0,0)\\n        return self.res\\n```\\n DFS + memo\\n ```python\\n    #DFS + memo\\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\\n        memo = {}\\n        def DFS(nums,i,summary):\\n            if i == len(nums):\\n                if summary == S:\\n                    memo[(i,summary)] = 1\\n                else:\\n                    memo[(i,summary)] = 0\\n            if (i,summary) not in memo:   \\n                memo[(i,summary)] = DFS(nums,i+1,summary+nums[i]) + DFS(nums,i+1,summary-nums[i])\\n            return memo[(i,summary)]\\n        DFS(nums,0,0)\\n        return memo[(0,0)]\\n```\\nBFS: using summary,cnt in queue(level traversal)\\n ```python\\n    # BFS:summary,cnt in queue\\n    def findTargetSumWays(self, nums: List[int], S: int) -> int: \\n        import collections\\n        queue = {0:1}\\n        for n in nums:\\n            tmp = collections.defaultdict(int)\\n            for summary,cnt in queue.items():\\n                tmp[summary+n]+=cnt\\n                tmp[summary-n]+=cnt\\n            queue = tmp\\n            # print(queue)\\n        return queue[S]\\n```\\nDP: dp[k][i] = dp[k-1][i+nums[k]] + dp[k-1][i-nums[k]] \\ndp[k][i] which means the number of ways for first k-th element to reach a sum i\\nbottom-to-up\\uFF1Ause Scrolling array \\n ```python\\n    # DP:dp[k][i] = dp[k-1][i+nums[k]] + dp[k-1][i-nums[k]] \\n    # dp[k][i] which means the number of ways for first k-th element to reach a sum i\\n    # bottom-to-up\\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\\n        summary = 0\\n        for n in nums:\\n            summary += abs(n)\\n        if summary < S:\\n            return 0\\n\\t\\t\\t\\n        dp_k0 = [0]*(2*summary+1)\\n        dp_k0[summary] = 1\\n        for n in nums:\\n            dp_k1 = [0]*(2*summary+1)\\n            for i in range(2*summary+1):\\n                a = dp_k0[i-n] if i-n >=0 else 0\\n                b = dp_k0[i+n] if i+n <(2*summary+1) else 0\\n                dp_k1[i] = a + b        \\n            dp_k0 = dp_k1\\n        return dp_k0[S+summary]\\n```\\nDP: dp[k][i] = dp[k-1][i+nums[k]] + dp[k-1][i-nums[k]] \\ndp[k][i] which means the number of ways for first k-th element to reach a sum i\\ntop-to-down\\uFF1Arecurisive \\uFF0Cdp_Ksize[k][sum] == -1 means not visited \\n ```python\\n    # DP:dp[k][i] = dp[k-1][i+nums[k]] + dp[k-1][i-nums[k]] \\n    # dp[k][i] which means the number of ways for first k-th element to reach a sum i\\n    # top-to-down\\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\\n        summary = 0\\n        for n in nums:\\n            summary += abs(n)\\n        if summary < S:\\n            return 0\\n\\n        dp_Ksize = [[-1]*(2*summary+1) for k in range(len(nums)+1)]\\n        for i in range(2*summary+1):\\n            dp_Ksize[0][i] = 0\\n        dp_Ksize[0][summary] = 1\\n        \\n        def recurisive(k,sum):\\n            if sum < 0 or sum>=(2*summary+1):\\n                return 0\\n            if dp_Ksize[k][sum] == -1:\\n                dp_Ksize[k][sum] = recurisive(k-1,sum+nums[k-1]) + recurisive(k-1,sum-nums[k-1])\\n            return dp_Ksize[k][sum]\\n        \\n        recurisive(len(nums),S+summary)\\n        return dp_Ksize[len(nums)][S+summary]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```python\\n\\t#DFS:TLE\\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\\n        self.res = 0\\n        def DFS(nums,i,summary):\\n            if i >= len(nums):\\n                if summary == S:\\n                    self.res += 1 \\n                return\\n            DFS(nums,i+1,summary+nums[i])\\n            DFS(nums,i+1,summary-nums[i])\\n        DFS(nums,0,0)\\n        return self.res\\n```\n```python\\n    #DFS + memo\\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\\n        memo = {}\\n        def DFS(nums,i,summary):\\n            if i == len(nums):\\n                if summary == S:\\n                    memo[(i,summary)] = 1\\n                else:\\n                    memo[(i,summary)] = 0\\n            if (i,summary) not in memo:   \\n                memo[(i,summary)] = DFS(nums,i+1,summary+nums[i]) + DFS(nums,i+1,summary-nums[i])\\n            return memo[(i,summary)]\\n        DFS(nums,0,0)\\n        return memo[(0,0)]\\n```\n```python\\n    # BFS:summary,cnt in queue\\n    def findTargetSumWays(self, nums: List[int], S: int) -> int: \\n        import collections\\n        queue = {0:1}\\n        for n in nums:\\n            tmp = collections.defaultdict(int)\\n            for summary,cnt in queue.items():\\n                tmp[summary+n]+=cnt\\n                tmp[summary-n]+=cnt\\n            queue = tmp\\n            # print(queue)\\n        return queue[S]\\n```\n```python\\n    # DP:dp[k][i] = dp[k-1][i+nums[k]] + dp[k-1][i-nums[k]] \\n    # dp[k][i] which means the number of ways for first k-th element to reach a sum i\\n    # bottom-to-up\\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\\n        summary = 0\\n        for n in nums:\\n            summary += abs(n)\\n        if summary < S:\\n            return 0\\n\\t\\t\\t\\n        dp_k0 = [0]*(2*summary+1)\\n        dp_k0[summary] = 1\\n        for n in nums:\\n            dp_k1 = [0]*(2*summary+1)\\n            for i in range(2*summary+1):\\n                a = dp_k0[i-n] if i-n >=0 else 0\\n                b = dp_k0[i+n] if i+n <(2*summary+1) else 0\\n                dp_k1[i] = a + b        \\n            dp_k0 = dp_k1\\n        return dp_k0[S+summary]\\n```\n```python\\n    # DP:dp[k][i] = dp[k-1][i+nums[k]] + dp[k-1][i-nums[k]] \\n    # dp[k][i] which means the number of ways for first k-th element to reach a sum i\\n    # top-to-down\\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\\n        summary = 0\\n        for n in nums:\\n            summary += abs(n)\\n        if summary < S:\\n            return 0\\n\\n        dp_Ksize = [[-1]*(2*summary+1) for k in range(len(nums)+1)]\\n        for i in range(2*summary+1):\\n            dp_Ksize[0][i] = 0\\n        dp_Ksize[0][summary] = 1\\n        \\n        def recurisive(k,sum):\\n            if sum < 0 or sum>=(2*summary+1):\\n                return 0\\n            if dp_Ksize[k][sum] == -1:\\n                dp_Ksize[k][sum] = recurisive(k-1,sum+nums[k-1]) + recurisive(k-1,sum-nums[k-1])\\n            return dp_Ksize[k][sum]\\n        \\n        recurisive(len(nums),S+summary)\\n        return dp_Ksize[len(nums)][S+summary]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 520175,
                "title": "python-2-solutions-dp-recursion-similar-to-subset-sum-problem",
                "content": "```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\\n        \\n        ## RC ##\\n        ## APPROACH : DP ##\\n        ## INTUITION : THINK LIKE SUBSET SUM PROBLEM (tushor roy DP solution) Leetcode 416. Partition equal subset sum ##\\n        # but here  1. our target can range from -totalSum to +totalSum\\n        #           2. and we dont include True directly from above sequence, coz it is not subsequence we are looking for. so here consider if and only if previous value exists\\n        # [1,1,1,1,1]\\n        # 3\\n        # [\\n        #   [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], \\n        #   [0, 0, 0, 1, 0, 2, 0, 1, 0, 0, 0], \\n        #   [0, 0, 1, 0, 3, 0, 3, 0, 1, 0, 0], \\n        #   [0, 1, 0, 4, 0, 6, 0, 4, 0, 1, 0], \\n        #   [1, 0, 5, 0, 10, 0, 10, 0, 5, 0, 1]\\n        # ]\\n        \\n\\t\\t## TIME COMPLEXITY : O(N^2) ##\\n\\t\\t## SPACE COMPLEXITY : O(N^2) ##\\n\\n        totalSum = sum(nums)\\n        if(S not in range(-1 * totalSum, totalSum + 1) ): return 0\\n        dp = [ [ 0 for j in range( totalSum*2 + 1 ) ] for i in range(len(nums))]\\n        \\n        ## BASE CASE ## FIRST ROW ##\\n        dp[0][totalSum + nums[0]] += 1\\n        dp[0][totalSum - nums[0]] += 1\\n        \\n        for i in range(1, len(nums)):\\n            for j in range( totalSum*2 + 1 ):\\n                \\n                if( j - nums[i] >= 0 and dp[i-1][j-nums[i]] > 0 ):          # left side\\n                    dp[i][j] += dp[i-1][j-nums[i]]\\n                \\n                if( j + nums[i] <= totalSum*2 and dp[i-1][j+nums[i]] > 0 ): # right side\\n                    dp[i][j] += dp[i-1][j+nums[i]]\\n        \\n        return dp[-1][totalSum + S]\\n        \\n        ## APPROACH : BACKTRACKING + MEMOIZATION ##\\n        def dfs(curr, nums):\\n            key = (curr, tuple(nums))\\n            if key in cache: return cache[key]\\n            if not nums: return 1 if curr == S else 0            \\n            res = dfs(curr - nums[0], nums[1:]) + dfs(curr + nums[0], nums[1:])\\n            cache[key] = res\\n            return res\\n        cache = {}        \\n        return dfs(0, nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\\n        \\n        ## RC ##\\n        ## APPROACH : DP ##\\n        ## INTUITION : THINK LIKE SUBSET SUM PROBLEM (tushor roy DP solution) Leetcode 416. Partition equal subset sum ##\\n        # but here  1. our target can range from -totalSum to +totalSum\\n        #           2. and we dont include True directly from above sequence, coz it is not subsequence we are looking for. so here consider if and only if previous value exists\\n        # [1,1,1,1,1]\\n        # 3\\n        # [\\n        #   [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], \\n        #   [0, 0, 0, 1, 0, 2, 0, 1, 0, 0, 0], \\n        #   [0, 0, 1, 0, 3, 0, 3, 0, 1, 0, 0], \\n        #   [0, 1, 0, 4, 0, 6, 0, 4, 0, 1, 0], \\n        #   [1, 0, 5, 0, 10, 0, 10, 0, 5, 0, 1]\\n        # ]\\n        \\n\\t\\t## TIME COMPLEXITY : O(N^2) ##\\n\\t\\t## SPACE COMPLEXITY : O(N^2) ##\\n\\n        totalSum = sum(nums)\\n        if(S not in range(-1 * totalSum, totalSum + 1) ): return 0\\n        dp = [ [ 0 for j in range( totalSum*2 + 1 ) ] for i in range(len(nums))]\\n        \\n        ## BASE CASE ## FIRST ROW ##\\n        dp[0][totalSum + nums[0]] += 1\\n        dp[0][totalSum - nums[0]] += 1\\n        \\n        for i in range(1, len(nums)):\\n            for j in range( totalSum*2 + 1 ):\\n                \\n                if( j - nums[i] >= 0 and dp[i-1][j-nums[i]] > 0 ):          # left side\\n                    dp[i][j] += dp[i-1][j-nums[i]]\\n                \\n                if( j + nums[i] <= totalSum*2 and dp[i-1][j+nums[i]] > 0 ): # right side\\n                    dp[i][j] += dp[i-1][j+nums[i]]\\n        \\n        return dp[-1][totalSum + S]\\n        \\n        ## APPROACH : BACKTRACKING + MEMOIZATION ##\\n        def dfs(curr, nums):\\n            key = (curr, tuple(nums))\\n            if key in cache: return cache[key]\\n            if not nums: return 1 if curr == S else 0            \\n            res = dfs(curr - nums[0], nums[1:]) + dfs(curr + nums[0], nums[1:])\\n            cache[key] = res\\n            return res\\n        cache = {}        \\n        return dfs(0, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 829416,
                "title": "java-memoization-using-map-explained",
                "content": "* ***Please upvote if helpful!!***\\n```\\nclass Solution {\\n    Map<String, Integer> map = new HashMap<>();\\n    \\n    public int findTargetSumWays(int[] nums, int S) {\\n        \\n        return helper(nums, S, 0, 0);\\n        \\n    }\\n    \\n    private int helper(int []nums, int targetSum, int index, int sum){\\n        \\n        //Base condition when sum == targetSum. we return 1 \\n        //as we need to find the number of ways we can reach targetSum\\n        if(index == nums.length && sum == targetSum){\\n            return 1;\\n        }\\n        //Base condition when sum != targetSum . we return 0 from here\\n        //as we do not want this case in final answer\\n        if(index == nums.length && sum != targetSum){\\n            return 0;\\n        }\\n        \\n        //memoization using map.\\n        //used immutabality property of String for unique key in map.\\n        String key = sum + \"()\" + index;\\n        if(map.containsKey(key)){\\n            return map.get(key);\\n        }\\n        \\n        int count = 0;\\n        //first case we take negative value of current index\\n        count += helper(nums, targetSum, index + 1, sum - nums[index]);\\n        //second case we take positive value of current index\\n        count += helper(nums, targetSum , index + 1, sum + nums[index]);\\n        \\n        //add to map for future use.\\n        map.put(key, count);\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, Integer> map = new HashMap<>();\\n    \\n    public int findTargetSumWays(int[] nums, int S) {\\n        \\n        return helper(nums, S, 0, 0);\\n        \\n    }\\n    \\n    private int helper(int []nums, int targetSum, int index, int sum){\\n        \\n        //Base condition when sum == targetSum. we return 1 \\n        //as we need to find the number of ways we can reach targetSum\\n        if(index == nums.length && sum == targetSum){\\n            return 1;\\n        }\\n        //Base condition when sum != targetSum . we return 0 from here\\n        //as we do not want this case in final answer\\n        if(index == nums.length && sum != targetSum){\\n            return 0;\\n        }\\n        \\n        //memoization using map.\\n        //used immutabality property of String for unique key in map.\\n        String key = sum + \"()\" + index;\\n        if(map.containsKey(key)){\\n            return map.get(key);\\n        }\\n        \\n        int count = 0;\\n        //first case we take negative value of current index\\n        count += helper(nums, targetSum, index + 1, sum - nums[index]);\\n        //second case we take positive value of current index\\n        count += helper(nums, targetSum , index + 1, sum + nums[index]);\\n        \\n        //add to map for future use.\\n        map.put(key, count);\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198338,
                "title": "python-recursive-solution-with-memoization-dfs",
                "content": "This is a simple DFS implementation with pruning. The dfs without memoization times out since we\\'re calculating the same tree over and over again. Hence, at each level (tracked via index) for each current total (tracked via total) we memoize number of possible paths below which would lead to target. To illustrate, if at 2nd level, our tree nodes are as following:\\n\\n(2,2)   (2,0)  (2,-2)  (2,0)\\n\\nOnce we calculate the number of paths for the first node with values (2,0), we memoize it. Later, when we come across it again, we don\\'t have to calculate again, we just retrieve from the map. \\n\\n```\\nclass Solution:    \\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:     \\n        dic = defaultdict(int)\\n        \\n        def dfs(index=0, total=0):          \\n            key = (index, total)\\n            \\n            if key not in dic:\\n                if index == len(nums):                    \\n                    return 1 if total == target else 0\\n                else:\\n                    dic[key] = dfs(index+1, total + nums[index]) + dfs(index+1, total - nums[index])                    \\n                        \\n            return dic[key]                                                             \\n                \\n        return dfs()\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:    \\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:     \\n        dic = defaultdict(int)\\n        \\n        def dfs(index=0, total=0):          \\n            key = (index, total)\\n            \\n            if key not in dic:\\n                if index == len(nums):                    \\n                    return 1 if total == target else 0\\n                else:\\n                    dic[key] = dfs(index+1, total + nums[index]) + dfs(index+1, total - nums[index])                    \\n                        \\n            return dic[key]                                                             \\n                \\n        return dfs()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916262,
                "title": "java-naive-recursion-memoization-0-1-knapsack-problem-clean-code",
                "content": "***Naive Recursive Solution ***\\n```\\nclass Solution {\\n    \\n    \\n            int aux(int[] nums, int i, int sum, int S){\\n                if(i==nums.length){\\n                    if(S == sum)return 1;\\n                    return 0;\\n                }\\n                //Positive\\n                int pos=aux(nums,i+1,sum+nums[i],S);\\n                //Negative\\n                int neg=aux(nums,i+1,sum-nums[i],S);\\n                \\n                return pos + neg;\\n            }\\n    public int findTargetSumWays(int[] nums, int S) {\\n            return aux(nums,0,0,S);\\n    }\\n}\\n```\\n\\n***Optimizing with dp memoization table***\\n\\n```\\nclass Solution {\\n            int aux(int[] nums, int i, int sum, int S, int[][] dp){\\n                if(i==nums.length){\\n                    if(S == sum)return 1;\\n                    return 0;\\n                }\\n                if(dp[i][sum+1001]!=Integer.MAX_VALUE)return dp[i][sum+1001];\\n                //Positive\\n                int pos=aux(nums,i+1,sum+nums[i],S,dp);\\n                //Negative\\n                int neg=aux(nums,i+1,sum-nums[i],S,dp);\\n                \\n                dp[i][sum+1001]=pos + neg;\\n                return dp[i][sum+1001];\\n            }\\n    public int findTargetSumWays(int[] nums, int S){\\n            int[][] dp=new int[nums.length+1][2009];\\n            for(int i=0;i<nums.length+1;i++){\\n                for(int j=0;j<2009;j++){\\n                    dp[i][j]=Integer.MAX_VALUE;\\n                }\\n            }\\n            return aux(nums,0,0,S,dp);\\n    }\\n}\\n```\\n\\n***Please upvote this solution, if you liked the code or it helped in better understanding of the problem***\\nThank you in advance :)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    \\n            int aux(int[] nums, int i, int sum, int S){\\n                if(i==nums.length){\\n                    if(S == sum)return 1;\\n                    return 0;\\n                }\\n                //Positive\\n                int pos=aux(nums,i+1,sum+nums[i],S);\\n                //Negative\\n                int neg=aux(nums,i+1,sum-nums[i],S);\\n                \\n                return pos + neg;\\n            }\\n    public int findTargetSumWays(int[] nums, int S) {\\n            return aux(nums,0,0,S);\\n    }\\n}\\n```\n```\\nclass Solution {\\n            int aux(int[] nums, int i, int sum, int S, int[][] dp){\\n                if(i==nums.length){\\n                    if(S == sum)return 1;\\n                    return 0;\\n                }\\n                if(dp[i][sum+1001]!=Integer.MAX_VALUE)return dp[i][sum+1001];\\n                //Positive\\n                int pos=aux(nums,i+1,sum+nums[i],S,dp);\\n                //Negative\\n                int neg=aux(nums,i+1,sum-nums[i],S,dp);\\n                \\n                dp[i][sum+1001]=pos + neg;\\n                return dp[i][sum+1001];\\n            }\\n    public int findTargetSumWays(int[] nums, int S){\\n            int[][] dp=new int[nums.length+1][2009];\\n            for(int i=0;i<nums.length+1;i++){\\n                for(int j=0;j<2009;j++){\\n                    dp[i][j]=Integer.MAX_VALUE;\\n                }\\n            }\\n            return aux(nums,0,0,S,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004307,
                "title": "recursion-and-memoization-c-aditya-verma-approach",
                "content": "Refer - https://www.youtube.com/watch?v=Hw6Ygp3JBYw&list=PL_z_8CaSLPWekqhdCPmFohncHwz8TY2Go&index=12&ab_channel=AdityaVerma\\n\\nDo upvote, if found helpful.\\n\\nRecursive\\n```\\nclass Solution {\\npublic:\\n    \\n    int cnt;\\n    \\n    void fun(int total,vector<int> v,int tar,int i)\\n    {\\n       \\n        if(i<0)\\n        {\\n            if(total==tar)\\n                cnt++;\\n            \\n            return;       \\n        }\\n        \\n        if(total-(2*v[i])>=tar)\\n        {\\n            fun(total-(2*v[i]),v,tar,i-1);\\n            fun(total,v,tar,i-1);\\n        }\\n        else\\n            fun(total,v,tar,i-1);\\n        \\n        return;\\n    }\\n    \\n    int findTargetSumWays(vector<int>& v, int tar) \\n    {\\n        int total = 0;\\n        int n = v.size();\\n        \\n        for(int i=0;i<v.size();i++)\\n            total+=v[i];\\n        \\n        cnt=0;\\n        \\n        fun(total,v,tar,n-1);\\n        \\n        return cnt;\\n    }\\n};\\n```\\n\\nMemoization - \\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n    int sum;\\n    \\n    int fun(int total,vector<int> v,int tar,int i)\\n    {\\n        if(i<0)\\n        {\\n            if(total-(sum-total)==tar)\\n                return 1;\\n            \\n            return 0;\\n        }\\n        \\n        if(dp[i][total]!=-1)\\n            return dp[i][total];\\n        \\n        if(total-v[i]>=0)\\n        return dp[i][total] = fun(total-v[i],v,tar,i-1) + fun(total,v,tar,i-1);\\n        \\n        else\\n            return dp[i][total] = fun(total,v,tar,i-1);\\n    }\\n    \\n    int findTargetSumWays(vector<int>& v, int tar) \\n    {\\n        int total = 0;\\n        int n = v.size();\\n        \\n        for(int i=0;i<v.size();i++)\\n            total+=v[i];\\n        \\n        sum = total;\\n        \\n        dp.clear();\\n        dp.resize(n+1,vector<int> (total+1,-1));\\n        \\n        return fun(total,v,tar,n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int cnt;\\n    \\n    void fun(int total,vector<int> v,int tar,int i)\\n    {\\n       \\n        if(i<0)\\n        {\\n            if(total==tar)\\n                cnt++;\\n            \\n            return;       \\n        }\\n        \\n        if(total-(2*v[i])>=tar)\\n        {\\n            fun(total-(2*v[i]),v,tar,i-1);\\n            fun(total,v,tar,i-1);\\n        }\\n        else\\n            fun(total,v,tar,i-1);\\n        \\n        return;\\n    }\\n    \\n    int findTargetSumWays(vector<int>& v, int tar) \\n    {\\n        int total = 0;\\n        int n = v.size();\\n        \\n        for(int i=0;i<v.size();i++)\\n            total+=v[i];\\n        \\n        cnt=0;\\n        \\n        fun(total,v,tar,n-1);\\n        \\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n    int sum;\\n    \\n    int fun(int total,vector<int> v,int tar,int i)\\n    {\\n        if(i<0)\\n        {\\n            if(total-(sum-total)==tar)\\n                return 1;\\n            \\n            return 0;\\n        }\\n        \\n        if(dp[i][total]!=-1)\\n            return dp[i][total];\\n        \\n        if(total-v[i]>=0)\\n        return dp[i][total] = fun(total-v[i],v,tar,i-1) + fun(total,v,tar,i-1);\\n        \\n        else\\n            return dp[i][total] = fun(total,v,tar,i-1);\\n    }\\n    \\n    int findTargetSumWays(vector<int>& v, int tar) \\n    {\\n        int total = 0;\\n        int n = v.size();\\n        \\n        for(int i=0;i<v.size();i++)\\n            total+=v[i];\\n        \\n        sum = total;\\n        \\n        dp.clear();\\n        dp.resize(n+1,vector<int> (total+1,-1));\\n        \\n        return fun(total,v,tar,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915865,
                "title": "c-recursive-dp-memorization-solution",
                "content": "Runtime: 12 ms, faster than 76.50% of C++ online submissions for Target Sum.\\nMemory Usage: 9.5 MB, less than 5.15% of C++ online submissions for Target Sum.\\n\\n```\\nStart from 0 to end of nums array we can count sum by taking nums[i] and -nums[i] and call\\nrecursion. At the end of array if sum==S then return 1 otherwise 0.\\n\\nAs same result is calculated multiple times in recursion we can store the result of <index,sum> state\\nin DP vector. Max array size 20 and Max element sum 1000 and Min element sum 1000 which\\nmakes sum range 0 to 2000. To avoid negative index we add 1000 with sum while storing and\\nretriving value in DP vector.\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // dp vector store precalculated result of <index,sum>\\n    // max array size 20 and max element sum 1000 and so min element sum 1000\\n    // makes sum range 0 to  1000+1000 = 2000\\n    int dp[21][2001];\\n    \\n    // recursion from 0 to end of nums array taking +nums[i] and -nums[i] value\\n    int dfs(int index, vector<int>& nums, int &S, int sum)\\n    {\\n        // reached to the end of array \\n        // return 1 if S==sum, otherwise return 0\\n        if(index==nums.size())\\n            return sum==S?1:0;\\n\\n        // return precalculted result\\n        // to avoid negative index we add 1000 with sum\\n        if(dp[index][sum+1000]!=-1) return dp[index][sum+1000];\\n        \\n        int count = 0;\\n        \\n        // call recursion for taking both +nums[i] and -nums[i] values\\n        // and updated running sum as sum+nums[i] and sum-nums[i]\\n        \\n        count+= dfs(index+1,nums,S,sum+nums[index]);\\n        count+= dfs(index+1,nums,S,sum-nums[index]);\\n        \\n        return dp[index][sum+1000] = count;\\n    }\\n    \\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        \\n        // set -1 to all dp values\\n        memset(dp,-1,sizeof(dp));\\n        \\n        // all possible ways to reach target \\n        return dfs(0,nums,S,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nStart from 0 to end of nums array we can count sum by taking nums[i] and -nums[i] and call\\nrecursion. At the end of array if sum==S then return 1 otherwise 0.\\n\\nAs same result is calculated multiple times in recursion we can store the result of <index,sum> state\\nin DP vector. Max array size 20 and Max element sum 1000 and Min element sum 1000 which\\nmakes sum range 0 to 2000. To avoid negative index we add 1000 with sum while storing and\\nretriving value in DP vector.\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // dp vector store precalculated result of <index,sum>\\n    // max array size 20 and max element sum 1000 and so min element sum 1000\\n    // makes sum range 0 to  1000+1000 = 2000\\n    int dp[21][2001];\\n    \\n    // recursion from 0 to end of nums array taking +nums[i] and -nums[i] value\\n    int dfs(int index, vector<int>& nums, int &S, int sum)\\n    {\\n        // reached to the end of array \\n        // return 1 if S==sum, otherwise return 0\\n        if(index==nums.size())\\n            return sum==S?1:0;\\n\\n        // return precalculted result\\n        // to avoid negative index we add 1000 with sum\\n        if(dp[index][sum+1000]!=-1) return dp[index][sum+1000];\\n        \\n        int count = 0;\\n        \\n        // call recursion for taking both +nums[i] and -nums[i] values\\n        // and updated running sum as sum+nums[i] and sum-nums[i]\\n        \\n        count+= dfs(index+1,nums,S,sum+nums[index]);\\n        count+= dfs(index+1,nums,S,sum-nums[index]);\\n        \\n        return dp[index][sum+1000] = count;\\n    }\\n    \\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        \\n        // set -1 to all dp values\\n        memset(dp,-1,sizeof(dp));\\n        \\n        // all possible ways to reach target \\n        return dfs(0,nums,S,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593318,
                "title": "python-dp-using-subset-sum-count-0-1-knapsack",
                "content": "This is a variation of the standard subset sum count problem. \\n\\nGiven problem statement can be changed to find two subsets whose difference is equal to S. For example given arr = [1,1,1,1,1] and S  =4 , we need to find count of  subsets S1 and S2 whose difference is 3\\nIt can be the following\\n1. S1 = [arr[0],arr[1],arr[2],arr[3]], S2 = [arr[4]]\\n2. S1 = [arr[0],arr[1],arr[2],arr[4]], S2 = [arr[3]]\\n3. S1 = [arr[0],arr[1],arr[3],arr[4]], S2 = [arr[2]]\\n4. S1 = [arr[0],arr[2],arr[3],arr[4]], S2 = [arr[1]]\\n5. S1 = [arr[1],arr[2],arr[3],arr[4]], S2 = [arr[0]]\\n\\nIt can be converted to mathematical equation. S1 is the sum of elements in S1\\nS1 - S2 = S and we know S1 + S2 = sum(arr)\\nSo 2 * S1 = S + sum(arr) which will mean S1 = (S + sum(arr)) /2\\nSo we need to find subset sum count for sum - (S + sum(arr)) /2\\n\\n```\\nclass Solution(object):\\n    def findTargetSumWays(self, nums, S):\\n        \\n        def subset_sum_count(nums, n, w):\\n            dp = [[0] * (w+1) for _ in range(n+1)]\\n            \\n            dp[0][0] = 1\\n            \\n            for i in range(1, n+1):\\n                for j in range(0, w+1):\\n                    if nums[i-1] <= j:\\n                        dp[i][j] = dp[i-1][j-nums[i-1]] + dp[i-1][j]\\n                    else:\\n                        dp[i][j] = dp[i-1][j]\\n            return dp\\n        \\n        total = sum(nums)\\n        if S > total:\\n            return 0\\n        if (S + total) % 2 != 0:\\n            return 0\\n        \\n        w = (S + total) / 2\\n        n = len(nums)\\n        dp = subset_sum_count(nums, n, w)\\n        return dp[n][w]\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "This is a variation of the standard subset sum count problem. \\n\\nGiven problem statement can be changed to find two subsets whose difference is equal to S. For example given arr = [1,1,1,1,1] and S  =4 , we need to find count of  subsets S1 and S2 whose difference is 3\\nIt can be the following\\n1. S1 = [arr[0],arr[1],arr[2],arr[3]], S2 = [arr[4]]\\n2. S1 = [arr[0],arr[1],arr[2],arr[4]], S2 = [arr[3]]\\n3. S1 = [arr[0],arr[1],arr[3],arr[4]], S2 = [arr[2]]\\n4. S1 = [arr[0],arr[2],arr[3],arr[4]], S2 = [arr[1]]\\n5. S1 = [arr[1],arr[2],arr[3],arr[4]], S2 = [arr[0]]\\n\\nIt can be converted to mathematical equation. S1 is the sum of elements in S1\\nS1 - S2 = S and we know S1 + S2 = sum(arr)\\nSo 2 * S1 = S + sum(arr) which will mean S1 = (S + sum(arr)) /2\\nSo we need to find subset sum count for sum - (S + sum(arr)) /2\\n\\n```\\nclass Solution(object):\\n    def findTargetSumWays(self, nums, S):\\n        \\n        def subset_sum_count(nums, n, w):\\n            dp = [[0] * (w+1) for _ in range(n+1)]\\n            \\n            dp[0][0] = 1\\n            \\n            for i in range(1, n+1):\\n                for j in range(0, w+1):\\n                    if nums[i-1] <= j:\\n                        dp[i][j] = dp[i-1][j-nums[i-1]] + dp[i-1][j]\\n                    else:\\n                        dp[i][j] = dp[i-1][j]\\n            return dp\\n        \\n        total = sum(nums)\\n        if S > total:\\n            return 0\\n        if (S + total) % 2 != 0:\\n            return 0\\n        \\n        w = (S + total) / 2\\n        n = len(nums)\\n        dp = subset_sum_count(nums, n, w)\\n        return dp[n][w]\\n",
                "codeTag": "Java"
            },
            {
                "id": 97363,
                "title": "c-iterative-with-unordered-map",
                "content": "```\\n// OJ: https://leetcode.com/problems/target-sum\\n// Author: github.com/lzl124631x\\n// Time: O(2^N)\\n// Space: O(2^N)\\nclass Solution {\\npublic:\\n  int findTargetSumWays(vector<int>& nums, int S) {\\n    unordered_map<int, int> ans;\\n    ans[0] = 1;\\n    for (int n : nums) {\\n      unordered_map<int, int> newAns;\\n      for (auto p : ans) {\\n        int sum = p.first, cnt = p.second;\\n        newAns[sum + n] += cnt;\\n        newAns[sum - n] += cnt;\\n      }\\n      ans = newAns;\\n    }\\n    return ans[S];\\n  }\\n};\\n```\\n\\n---\\n\\nUpdated with other solutions\\n```\\n// OJ: https://leetcode.com/problems/target-sum\\n// Author: github.com/lzl124631x\\n// Time: O(2^N)\\n// Space: O(N)\\nclass Solution {\\nprivate:\\n  int cnt = 0;\\n  void dfs(vector<int>& nums, int S, int start) {\\n    if (start == nums.size()) {\\n      cnt += !S;\\n      return;\\n    }\\n    dfs(nums, S + nums[start], start + 1);\\n    dfs(nums, S - nums[start], start + 1);\\n  }\\npublic:\\n  int findTargetSumWays(vector<int>& nums, int S) {\\n    dfs(nums, S, 0);\\n    return cnt;\\n  }\\n};\\n```\\n\\n```\\n// OJ: https://leetcode.com/problems/target-sum\\n// Author: github.com/lzl124631x\\n// Time: O(2^N)\\n// Space: O(2^N)\\nclass Solution {\\nprivate:\\n  vector<unordered_map<int, int>> memo;\\n  int dfs(vector<int>& nums, int S, int start) {\\n    if (start == nums.size()) return !S ? 1 : 0;\\n    if (memo[start].count(S)) return memo[start][S];\\n    return memo[start][S] = dfs(nums, S + nums[start], start + 1)\\n                            + dfs(nums, S - nums[start], start + 1);\\n  }\\npublic:\\n  int findTargetSumWays(vector<int>& nums, int S) {\\n    memo = vector<unordered_map<int, int>>(nums.size());\\n    return dfs(nums, S, 0);\\n  }\\n};\\n```\\n\\n```\\n// OJ: https://leetcode.com/problems/target-sum\\n// Author: github.com/lzl124631x\\n// Time: O(NS)\\n// Space: O(S)\\n// Ref: https://discuss.leetcode.com/topic/76243/java-15-ms-c-3-ms-o-ns-iterative-dp-solution-using-subset-sum-with-explanation\\nclass Solution {\\nprivate:\\n  int subsetSum(vector<int> &nums, int S) {\\n    vector<int> dp(S + 1, 0);\\n    dp[0] = 1;\\n    for (int n : nums)\\n      for (int i = S; i >= n; --i) dp[i] += dp[i - n];\\n    return dp[S];\\n  }\\npublic:\\n  int findTargetSumWays(vector<int>& nums, int S) {\\n    int sum = accumulate(nums.begin(), nums.end(), 0);\\n    return sum < S || (sum + S) % 2 ? 0 : subsetSum(nums, (sum + S) / 2);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// OJ: https://leetcode.com/problems/target-sum\\n// Author: github.com/lzl124631x\\n// Time: O(2^N)\\n// Space: O(2^N)\\nclass Solution {\\npublic:\\n  int findTargetSumWays(vector<int>& nums, int S) {\\n    unordered_map<int, int> ans;\\n    ans[0] = 1;\\n    for (int n : nums) {\\n      unordered_map<int, int> newAns;\\n      for (auto p : ans) {\\n        int sum = p.first, cnt = p.second;\\n        newAns[sum + n] += cnt;\\n        newAns[sum - n] += cnt;\\n      }\\n      ans = newAns;\\n    }\\n    return ans[S];\\n  }\\n};\\n```\n```\\n// OJ: https://leetcode.com/problems/target-sum\\n// Author: github.com/lzl124631x\\n// Time: O(2^N)\\n// Space: O(N)\\nclass Solution {\\nprivate:\\n  int cnt = 0;\\n  void dfs(vector<int>& nums, int S, int start) {\\n    if (start == nums.size()) {\\n      cnt += !S;\\n      return;\\n    }\\n    dfs(nums, S + nums[start], start + 1);\\n    dfs(nums, S - nums[start], start + 1);\\n  }\\npublic:\\n  int findTargetSumWays(vector<int>& nums, int S) {\\n    dfs(nums, S, 0);\\n    return cnt;\\n  }\\n};\\n```\n```\\n// OJ: https://leetcode.com/problems/target-sum\\n// Author: github.com/lzl124631x\\n// Time: O(2^N)\\n// Space: O(2^N)\\nclass Solution {\\nprivate:\\n  vector<unordered_map<int, int>> memo;\\n  int dfs(vector<int>& nums, int S, int start) {\\n    if (start == nums.size()) return !S ? 1 : 0;\\n    if (memo[start].count(S)) return memo[start][S];\\n    return memo[start][S] = dfs(nums, S + nums[start], start + 1)\\n                            + dfs(nums, S - nums[start], start + 1);\\n  }\\npublic:\\n  int findTargetSumWays(vector<int>& nums, int S) {\\n    memo = vector<unordered_map<int, int>>(nums.size());\\n    return dfs(nums, S, 0);\\n  }\\n};\\n```\n```\\n// OJ: https://leetcode.com/problems/target-sum\\n// Author: github.com/lzl124631x\\n// Time: O(NS)\\n// Space: O(S)\\n// Ref: https://discuss.leetcode.com/topic/76243/java-15-ms-c-3-ms-o-ns-iterative-dp-solution-using-subset-sum-with-explanation\\nclass Solution {\\nprivate:\\n  int subsetSum(vector<int> &nums, int S) {\\n    vector<int> dp(S + 1, 0);\\n    dp[0] = 1;\\n    for (int n : nums)\\n      for (int i = S; i >= n; --i) dp[i] += dp[i - n];\\n    return dp[S];\\n  }\\npublic:\\n  int findTargetSumWays(vector<int>& nums, int S) {\\n    int sum = accumulate(nums.begin(), nums.end(), 0);\\n    return sum < S || (sum + S) % 2 ? 0 : subsetSum(nums, (sum + S) / 2);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 356585,
                "title": "python-dp",
                "content": "class Solution:\\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\\n\\n\\n        if not nums or sum(nums)<S: return 0\\n        dic = {0:1}\\n        for i in range(len(nums)):\\n            temp_dic = collections.defaultdict(int)\\n            for k in dic:\\n                temp_dic[k+nums[i]] += dic[k]\\n                temp_dic[k-nums[i]] += dic[k]\\n            dic = temp_dic\\n        return dic[S]\\n            \\n                \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\\n\\n\\n        if not nums or sum(nums)<S: return 0\\n        dic = {0:1}",
                "codeTag": "Java"
            },
            {
                "id": 3457689,
                "title": "java-easiest-solution-ever-using-simple-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(2^N) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/0ed3f33b-46df-40fd-b21c-5f55d04c0e75_1682519066.1350014.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n        return helper(nums, 0, 0, target);\\n    }\\n\\n    private int helper(int[] nums, int index, int curSum, int target) {\\n        // Base case: when we reach the end of the array\\n        if (index == nums.length) {\\n            // Check if we have reached the target sum\\n            if (curSum == target) {\\n                return 1; // Return 1 to indicate that we have found a valid combination\\n            } else {\\n                return 0; // Return 0 to indicate that we have not found a valid combination\\n            }\\n        }\\n        \\n        // Recursive case: we can either add or subtract the current number to the current sum\\n        int left = helper(nums, index + 1, curSum + nums[index], target); // Add the current number to the current sum\\n        int right = helper(nums, index + 1, curSum - nums[index], target); // Subtract the current number from the current sum\\n        return left + right; // Return the sum of the results obtained from the left and right subproblems\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n        return helper(nums, 0, 0, target);\\n    }\\n\\n    private int helper(int[] nums, int index, int curSum, int target) {\\n        // Base case: when we reach the end of the array\\n        if (index == nums.length) {\\n            // Check if we have reached the target sum\\n            if (curSum == target) {\\n                return 1; // Return 1 to indicate that we have found a valid combination\\n            } else {\\n                return 0; // Return 0 to indicate that we have not found a valid combination\\n            }\\n        }\\n        \\n        // Recursive case: we can either add or subtract the current number to the current sum\\n        int left = helper(nums, index + 1, curSum + nums[index], target); // Add the current number to the current sum\\n        int right = helper(nums, index + 1, curSum - nums[index], target); // Subtract the current number from the current sum\\n        return left + right; // Return the sum of the results obtained from the left and right subproblems\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295929,
                "title": "java-2ms-easy-to-understand-dp-solution-with-explanation",
                "content": "This problem is equal to \"find all ways to partition the array into two groups so that the difference of the sum of the two groups is Math.abs(S)\". Assume the sum of the two subsets is ```s1``` and ```s2``` (```s1 >= s2```), the sum of the array is ```sum```:\\n1. ```s1 + s2 = sum```;\\n2. ```s1 - s2 = Math.abs(S)```\\n\\nSo, ```s1 = (sum + Math.abs(S)) / 2```. Now what we need to do is finding all subsets whose sum is ```s1```, which is a typical 0-1 knapsack problem.\\nWe use ```dp[i][j]``` to denote the number of subsets whose sum is ```i``` for the first ```j``` elements in the array. \\nNote that there could be **zero** in the array, ```dp[0][i]``` is no longer 0 as the normal knapsack problem, which means we need to process empty knapsack specially.\\n\\n```\\npublic int findTargetSumWays(int[] nums, int S) {\\n    int sum = 0;\\n    S = Math.abs(S);\\n    for(int i = 0; i < nums.length; i++)\\n        sum += nums[i];\\n\\t// Invalid S, just return 0\\n    if( S > sum || (sum + S) % 2 != 0 )\\n        return 0;\\n\\n    int dp[][] = new int[(sum + S) / 2 + 1][nums.length + 1];\\n    dp[0][0] = 1;\\n    for(int i = 0; i < nums.length; i++) { // empty knapsack must be processed specially\\n        if( nums[i] == 0 )\\n            dp[0][i + 1] = dp[0][i] * 2;\\n        else\\n            dp[0][i + 1] = dp[0][i];\\n    }\\n    for(int i = 1; i < dp.length; i++) {\\n        for(int j = 0; j < nums.length; j++) {\\n            dp[i][j + 1] += dp[i][j];\\n            if( nums[j] <= i )\\n                dp[i][j + 1] += dp[i - nums[j]][j];\\n        }\\n    }\\n    return dp[(sum + S) / 2][nums.length];\\n}\\n```\\nThe time of the solution above is 4ms, after optimizing the space by using one dimension dp array we can improve it to 2ms:\\n```\\nint dp[] = new int[(sum + S) / 2 + 1];\\ndp[0] = 1;\\nfor(int i = 0; i < nums.length; i++) {\\n\\tfor(int j = dp.length - 1; j >= nums[i]; j--) {\\n\\t\\tdp[j] += dp[j - nums[i]];\\n\\t}\\n}\\nreturn dp[dp.length - 1];\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```s1```\n```s2```\n```s1 >= s2```\n```sum```\n```s1 + s2 = sum```\n```s1 - s2 = Math.abs(S)```\n```s1 = (sum + Math.abs(S)) / 2```\n```s1```\n```dp[i][j]```\n```i```\n```j```\n```dp[0][i]```\n```\\npublic int findTargetSumWays(int[] nums, int S) {\\n    int sum = 0;\\n    S = Math.abs(S);\\n    for(int i = 0; i < nums.length; i++)\\n        sum += nums[i];\\n\\t// Invalid S, just return 0\\n    if( S > sum || (sum + S) % 2 != 0 )\\n        return 0;\\n\\n    int dp[][] = new int[(sum + S) / 2 + 1][nums.length + 1];\\n    dp[0][0] = 1;\\n    for(int i = 0; i < nums.length; i++) { // empty knapsack must be processed specially\\n        if( nums[i] == 0 )\\n            dp[0][i + 1] = dp[0][i] * 2;\\n        else\\n            dp[0][i + 1] = dp[0][i];\\n    }\\n    for(int i = 1; i < dp.length; i++) {\\n        for(int j = 0; j < nums.length; j++) {\\n            dp[i][j + 1] += dp[i][j];\\n            if( nums[j] <= i )\\n                dp[i][j + 1] += dp[i - nums[j]][j];\\n        }\\n    }\\n    return dp[(sum + S) / 2][nums.length];\\n}\\n```\n```\\nint dp[] = new int[(sum + S) / 2 + 1];\\ndp[0] = 1;\\nfor(int i = 0; i < nums.length; i++) {\\n\\tfor(int j = dp.length - 1; j >= nums[i]; j--) {\\n\\t\\tdp[j] += dp[j - nums[i]];\\n\\t}\\n}\\nreturn dp[dp.length - 1];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1738404,
                "title": "recursive-tree-drawing",
                "content": "```\\nclass Solution { // YAA\\npublic:\\n    \\n    int solve(vector<int>& nums, int target, int idx, unordered_map<string, int> &dp) {\\n        if(idx == nums.size()) {\\n            if(target == 0) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        string key = to_string(idx) + \" \" + to_string(target);\\n        if(dp.find(key) != dp.end()) {\\n            return dp[key];\\n        }\\n        // +\\n        int x = solve(nums, target - nums[idx], idx+1, dp);\\n        // -\\n        int y = solve(nums, target + nums[idx], idx+1, dp);\\n        // sum\\n        return dp[key] = x+y;\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        unordered_map<string, int> dp;\\n        return solve(nums, target, 0, dp);\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c2d5f548-5e1a-4aa5-9276-8173780d12db_1643781262.8660357.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution { // YAA\\npublic:\\n    \\n    int solve(vector<int>& nums, int target, int idx, unordered_map<string, int> &dp) {\\n        if(idx == nums.size()) {\\n            if(target == 0) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        string key = to_string(idx) + \" \" + to_string(target);\\n        if(dp.find(key) != dp.end()) {\\n            return dp[key];\\n        }\\n        // +\\n        int x = solve(nums, target - nums[idx], idx+1, dp);\\n        // -\\n        int y = solve(nums, target + nums[idx], idx+1, dp);\\n        // sum\\n        return dp[key] = x+y;\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        unordered_map<string, int> dp;\\n        return solve(nums, target, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668743,
                "title": "easy-c-solution-array-with-value-0-cases-covered",
                "content": "0/1 knapsack solution using dynamic programming\\n**nums[i]=0 cases covered**\\n\\nHere we **dont have to set t[i][0]=1 for all i** because for j=0 (i.e sum=0) subset with value zeros [0,0,0] can be formed and that is get counted here;\\nonly **initialize t/dp[0][0]=1;** \\neg. 0 0 2\\n  if sum=2\\n```\\n    j->\\n    0 1 2\\ni 0 1 0 0\\n  1 2 0 0\\n  2 4 0 0\\n  3 4 0 4\\n```\\n Here we can see that for j=0 there is change like 1,2,4,4 thats why we dont have to set t/dp[i][0]=0\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        for(int x: nums)\\n            sum += x;\\n        if (abs(target) > sum || (sum + target) % 2 != 0){ \\n            return 0;\\n        }\\n        int s1 = (sum + target)/2;\\n        int ans = subsetCount(nums,s1);\\n        return ans;\\n    }\\n    \\n    int subsetCount(vector<int>& nums, int s1){\\n        int n = nums.size();\\n        int t[n+1][s1+1];\\n        t[0][0] = 1;\\n        for(int i=1;i<s1+1;i++)\\n            t[0][i] = 0;\\n        for(int i=1;i<n+1;i++)\\n            for(int j=0;j<s1+1;j++){\\n                if(nums[i-1] > j)\\n                    t[i][j] = t[i-1][j];\\n                else\\n                    t[i][j] = t[i-1][j] + t[i-1][j-nums[i-1]];\\n            }\\n        \\n        return t[n][s1];\\n    }\\n};\\n```\\n**Please upvote if you like it !!!!!**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n    j->\\n    0 1 2\\ni 0 1 0 0\\n  1 2 0 0\\n  2 4 0 0\\n  3 4 0 4\\n```\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        for(int x: nums)\\n            sum += x;\\n        if (abs(target) > sum || (sum + target) % 2 != 0){ \\n            return 0;\\n        }\\n        int s1 = (sum + target)/2;\\n        int ans = subsetCount(nums,s1);\\n        return ans;\\n    }\\n    \\n    int subsetCount(vector<int>& nums, int s1){\\n        int n = nums.size();\\n        int t[n+1][s1+1];\\n        t[0][0] = 1;\\n        for(int i=1;i<s1+1;i++)\\n            t[0][i] = 0;\\n        for(int i=1;i<n+1;i++)\\n            for(int j=0;j<s1+1;j++){\\n                if(nums[i-1] > j)\\n                    t[i][j] = t[i-1][j];\\n                else\\n                    t[i][j] = t[i-1][j] + t[i-1][j-nums[i-1]];\\n            }\\n        \\n        return t[n][s1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804311,
                "title": "python-dp-with-comments",
                "content": "```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        \\n        if not nums: \\n            return 0\\n        \\n        s = sum(nums)\\n        if target > s: # impossible to get\\n            return 0\\n        \\n        \\n        # Let dp[i][j] represent the number of possible ways to get sum j using the first i numbers.\\n        # Note there are (s * 2 + 1) possible sums (hence the nubmer of columns)\\n        dp = [[0 for _ in range(s*2+1)] for _ in range(len(nums))]\\n        \\n        # Base Case: using only the first number.\\n        # Note this number locates at index s+nums[0] because the first s entries correspond to negative numbers.\\n        dp[0][s+nums[0]] += 1\\n        dp[0][s-nums[0]] += 1\\n        \\n        # General Case\\n        \\n        # Subproblem: use the first i numbers\\n        for i in range(1, len(nums)):\\n            \\n            # Loop for each number in range [-s, s]\\n            for j in range(s*2 + 1):\\n                \\n                # (j - nums[i] >= 0) is to make sure we don\\'t get negative indices\\n                if (j - nums[i] >= 0 and dp[i-1][j-nums[i]] > 0):\\n                    \\n                    # We force ourselves to use num[i]. Then the complement is (j - nums[i]).\\n                    # There are dp[i-1][j-nums[i]] ways to get a sum of (j-nums[i]) using the first (i-1) numbers.  \\n                    # Hence, we increment the count dp[i][j] by this amount.\\n                    dp[i][j] += dp[i-1][j-nums[i]]\\n                    \\n                # (j + nums[i] <= s ** 2) is to make sure we don\\'t get index out of range\\n                if (j + nums[i] <= s * 2 and dp[i-1][j+nums[i]] > 0):\\n                    \\n                    # We force ourselves to use -num[i] (NOTE THE MINUS SIGN HERE!). Then the complement is (j + nums[i]).\\n                    # There are dp[i-1][j+nums[i]] ways to get a sum of (j+nums[i]) using the first (i-1) numbers.  \\n                    # Hence, we increment the count dp[i][j] by this amount.\\n                    dp[i][j] += dp[i-1][j+nums[i]]\\n        \\n        # Note our target locates at index s+target because the first s entries correspond to negative numbers\\n        return dp[-1][target+s]\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        \\n        if not nums: \\n            return 0\\n        \\n        s = sum(nums)\\n        if target > s: # impossible to get\\n            return 0\\n        \\n        \\n        # Let dp[i][j] represent the number of possible ways to get sum j using the first i numbers.\\n        # Note there are (s * 2 + 1) possible sums (hence the nubmer of columns)\\n        dp = [[0 for _ in range(s*2+1)] for _ in range(len(nums))]\\n        \\n        # Base Case: using only the first number.\\n        # Note this number locates at index s+nums[0] because the first s entries correspond to negative numbers.\\n        dp[0][s+nums[0]] += 1\\n        dp[0][s-nums[0]] += 1\\n        \\n        # General Case\\n        \\n        # Subproblem: use the first i numbers\\n        for i in range(1, len(nums)):\\n            \\n            # Loop for each number in range [-s, s]\\n            for j in range(s*2 + 1):\\n                \\n                # (j - nums[i] >= 0) is to make sure we don\\'t get negative indices\\n                if (j - nums[i] >= 0 and dp[i-1][j-nums[i]] > 0):\\n                    \\n                    # We force ourselves to use num[i]. Then the complement is (j - nums[i]).\\n                    # There are dp[i-1][j-nums[i]] ways to get a sum of (j-nums[i]) using the first (i-1) numbers.  \\n                    # Hence, we increment the count dp[i][j] by this amount.\\n                    dp[i][j] += dp[i-1][j-nums[i]]\\n                    \\n                # (j + nums[i] <= s ** 2) is to make sure we don\\'t get index out of range\\n                if (j + nums[i] <= s * 2 and dp[i-1][j+nums[i]] > 0):\\n                    \\n                    # We force ourselves to use -num[i] (NOTE THE MINUS SIGN HERE!). Then the complement is (j + nums[i]).\\n                    # There are dp[i-1][j+nums[i]] ways to get a sum of (j+nums[i]) using the first (i-1) numbers.  \\n                    # Hence, we increment the count dp[i][j] by this amount.\\n                    dp[i][j] += dp[i-1][j+nums[i]]\\n        \\n        # Note our target locates at index s+target because the first s entries correspond to negative numbers\\n        return dp[-1][target+s]\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 733276,
                "title": "javascript-solution-topdown",
                "content": "```\\nvar findTargetSumWays = function(nums, S) {\\n    const memo = new Map();\\n    const n = nums.length;\\n    \\n    return countWaysToSum(n - 1, S);\\n    \\n    function countWaysToSum(index, rem) {\\n        const key = `${index}#${rem}`;\\n        \\n        // base case         \\n        if (index < 0) {\\n\\t\\t\\tif (rem === 0) return 1;\\n\\t\\t\\treturn 0;\\n        }\\n        if (memo.has(key)) return memo.get(key);\\n        \\n        const plus = countWaysToSum(index - 1, rem + nums[index]) \\n\\t\\tconst minus = countWaysToSum(index - 1, rem - nums[index]);\\n\\t    const count = plus + minus;\\n\\t\\n        memo.set(key, count);\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nvar findTargetSumWays = function(nums, S) {\\n    const memo = new Map();\\n    const n = nums.length;\\n    \\n    return countWaysToSum(n - 1, S);\\n    \\n    function countWaysToSum(index, rem) {\\n        const key = `${index}#${rem}`;\\n        \\n        // base case         \\n        if (index < 0) {\\n\\t\\t\\tif (rem === 0) return 1;\\n\\t\\t\\treturn 0;\\n        }\\n        if (memo.has(key)) return memo.get(key);\\n        \\n        const plus = countWaysToSum(index - 1, rem + nums[index]) \\n\\t\\tconst minus = countWaysToSum(index - 1, rem - nums[index]);\\n\\t    const count = plus + minus;\\n\\t\\n        memo.set(key, count);\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 486288,
                "title": "explanation-of-thinking-from-brute-force-to-optimized-dp",
                "content": "**Analysis**\\n1: Analyze the question. `\"choose one from\"` and `\"how many ways\"` gives us the hint that we will have to make choice at each number, which gives us the hint of using DP. Don\\'t worry about the DP solution for now - don\\'t even worry if you didn\\'t get this hint to use DP.\\n\\nI will be using nums= `[1,1,1]` and target = `3` for my examples.\\n# Brute force\\nAt each index, we need to decide if we want + or - . Don\\'t even optimize for now, just try all possibilities, which means at each index, we try both positive and negative versions. \\n\\nAlso, think of your base case. How do you know when you\\'re done? (When index is == length of nums).\\n\\n```\\n\\t// return bruteForce(0, 0, nums, S);\\n    public int bruteForce(int idx, int cur, int[] nums, int target) {\\n        if (idx == nums.length){\\n            if (cur == target) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        return help(idx+1, cur + nums[idx], nums, target) + help(idx+1, cur - nums[idx], nums, target);\\n    }\\n```\\n\\nThe **MOST** important thing is you need to draw this out with a small input. Then, you can easily see how to optmize.\\n\\n```\\nf(idx, curSum)\\n                                            f(0,0)                \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  /               \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\tf(1,1)                   f(1,-1)\\n\\t\\t\\t\\t\\t\\t\\t\\t/     \\\\                  /      \\\\\\n\\t\\t\\t\\t\\t    f(2,2)    f(2,0)              f(2,0)      f(2,-2)\\n\\t\\t\\t\\t\\t  /     \\\\    /     \\\\            /      \\\\       /     \\\\\\n\\t\\t\\t\\tf(3,3)  f(3, 1)  f(3,1) f(3,-1)  f(3,1) f(3,-1) f(3,-1) f(3,-3)\\n```\\n\\nWhat do you see from this picture? (calls are being made with the same arguments again and again) From this we know we can cache the results so we don\\'t have to calculate again.\\n\\n# Memoization\\nSo now we know we want to cache input values in some object and get the result from it. We have 2 input values, so we can use a 2D as we have a standard range of inputs. What is the range exactly? What is the max and min value for each of our variables? For `idx` we know min=0 and max=nums.length-1. For curSum, if we give every number a + sign or every number a - sign, we know max = sum(nums) and min = -sum(num). \\n\\nFor our example, we know our range is -3 to 3, so the total range is 6. We can just create an array of length==total range to make sure we can hold all valid values of curSum with `-sum` represented by 0, `sum` represented by 6 (sum\\\\*2) . For the rows and cols, we need to do `+1` to prevent out of bound exceptions. (Note we call f(3,6) in the brute force) We can add an early exit condition ` if (sum < S || -sum > -S) return 0;` now too.\\n\\n`int[][] dp = new int[ nums.length+1 ][ (2*sum) + 1 ]`\\n\\nNow, write down exactly what your 2D matrix represents. Be **very** careful in this step. You might think each row represents the index, but that wouldn\\'t really make sense since we call our function with index 3 even though there is no index 3. What the row really represents is everything to the left of that index NOT including itself. dp[2][1] will represent how many ways there are to **get to `target` given the sum at `col`** and indexes before `row`. This will be important in the optimized solution.\\n\\n```\\n\\tint sum;\\n    public int findTargetSumWays(int[] nums, int S) {\\n        if (nums.length == 0 && S != 0) {\\n            return 0;\\n        }\\n        \\n        this.sum = Arrays.stream(nums).sum();\\n        if (sum < S || -sum > -S) return 0;\\n        int fullRange = (2 * sum)+1;\\n        int[][] dp = new int[nums.length+1][fullRange];\\n        for (int[] row: dp){\\n            Arrays.fill(row,-1);\\n        }\\n\\n        return help2(0, sum, nums, S+sum, dp);\\n    }\\n    \\n    public int help2(int idx, int cur, int[] nums, int target, int[][] dp){\\n        if (dp[idx][cur] != -1)  return dp[idx][cur];\\n\\t\\t\\n        if (idx == nums.length){\\n            int val = 0;\\n            if (cur == target) {\\n                val = 1;\\n            }\\n            dp[idx][cur] = val;\\n            return val;\\n        }\\n        dp[idx][cur] = help2(idx+1, cur + nums[idx], nums, target, dp) + help2(idx+1, cur - nums[idx], nums, target, dp);\\n        \\n        return dp[idx][cur];\\n    }\\n```\\n\\nNow, if you draw out your 2D array, it should look like this:\\n```\\nrow = idx, col = sum\\n\\n        0   1   2   3   4   5   6 \\n 0    [ x   x   x   1   x   x   x  ]\\n 1    [ x   x   0   x   1   x   x  ]\\n 2    [ x   0   x   0   x   1   x  ]\\n 3    [ 0   x   0   x   0   x   1  ]\\n```\\n\\nNote the order in which you\\'re filling out the matrix, the later row gets filled in first and the row before it is simply using the later row\\'s values to calculate its values.\\n# Optimized DP\\n\\nSo now we have a pretty good solution, but you might have noticed you only really 2 rows to calculate everything. (When filling out the 2D array, we fill one row at a time) Once we have the last row, we can calculate everything else. If we can somehow set the last row, we can solve the rest of the problem easily. So, let\\'s try to save on space in the matrix by using 2 rows at a time and not using recursion.\\n\\nThis next step is the hardest. Notice in our matrix that we set dp[nums.length][target+sum] = dp(3,6) = 1. In our last row, we will only have 0\\'s or a single 1. Note that if any sum at idx 3 does not equal `target` then a `1` is never set in the dp. So, now we know we have to set `target+sum` in our array.\\n\\nTo do this iteratively, we probably need some loop(s). What are the limits of these loops? We can just look at the ranges we calculated from before or the ranges from our 2D matrix. *This can probably be optimized, feel free to comment*\\n\\n```\\n    public int findTargetSumWays(int[] nums, int S) {\\n        if (nums.length == 0 && S != 0) {\\n            return 0;\\n        }\\n        \\n        int sum = Arrays.stream(nums).sum();\\n        if (sum < S || -sum > -S ) return 0;\\n        int totalRange = (2 * sum)+1;\\n        \\n        int[] row = new int[totalRange];\\n        row[sum+S] = 1;\\n\\n        for (int i=0;i<nums.length;i++){ //not <= because we already calculated the first row\\n            int[] next = new int[totalRange];\\n            for (int k=0;k < totalRange;k++){\\n                if (row[k] != 0){\\n                    if (k-nums[i] >= 0) next[k-nums[i]] += row[k];\\n                    if (k+nums[i] < totalRange) next[k+nums[i]] += row[k];\\n                }\\n            }\\n            \\n            row = next;\\n        }\\n        return row[sum]; // just like we returned f(0,sum) in previous solution\\n    }\\n```\\n\\nThe rows are calculated like this:\\n```\\n//  0 1 2 3 4 5 6\\n\\t0 0 0 0 0 0 1 \\n\\t0 0 0 0 0 1 0 \\n\\t0 0 0 0 1 0 1 \\n\\t0 0 0 1 0 2 0 \\n```\\n\\nMy example inputs aren\\'t the best so I\\'ll also put what it would look like for `[1,1,1,1,1]` and target=3.\\n\\n```\\n0 [x,x,x,x,x,5,x,x,x,x,x]\\n1 [x,x,x,x,1,x,4,x,x,x,x]\\n2 [x,x,x,0,x,1,x,3,x,x,x]\\n3 [x,x,0,x,0,x,1,x,2,x,x]\\n4 [x,0,x,0,x,0,x,1,x,1,x]\\n5 [0,x,0,x,0,x,0,x,1,x,0]\\n\\n// with x\\'s for 0\\'s so it\\'s easier to see\\n//  0 1 2 3 4 5 6 7  8 9 10\\n\\tx x x x x x x x  1 x x \\n\\tx x x x x x x 1  x 1 x \\n\\tx x x x x x 1 x  2 x 1 \\n\\tx x x x x 1 x 3  x 3 x \\n\\tx x x x 1 x 4 x  6 x 3 \\n\\tx x x 1 x 5 x 10 x 9 x \\n```\\n\\n\\nHere\\'s a [slightly different version here with more explanation](https://leetcode.com/problems/target-sum/discuss/97335/Short-Java-DP-Solution-with-Explanation). \\n\\nThanks for reading!",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\t// return bruteForce(0, 0, nums, S);\\n    public int bruteForce(int idx, int cur, int[] nums, int target) {\\n        if (idx == nums.length){\\n            if (cur == target) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        return help(idx+1, cur + nums[idx], nums, target) + help(idx+1, cur - nums[idx], nums, target);\\n    }\\n```\n```\\nf(idx, curSum)\\n                                            f(0,0)                \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  /               \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\tf(1,1)                   f(1,-1)\\n\\t\\t\\t\\t\\t\\t\\t\\t/     \\\\                  /      \\\\\\n\\t\\t\\t\\t\\t    f(2,2)    f(2,0)              f(2,0)      f(2,-2)\\n\\t\\t\\t\\t\\t  /     \\\\    /     \\\\            /      \\\\       /     \\\\\\n\\t\\t\\t\\tf(3,3)  f(3, 1)  f(3,1) f(3,-1)  f(3,1) f(3,-1) f(3,-1) f(3,-3)\\n```\n```\\n\\tint sum;\\n    public int findTargetSumWays(int[] nums, int S) {\\n        if (nums.length == 0 && S != 0) {\\n            return 0;\\n        }\\n        \\n        this.sum = Arrays.stream(nums).sum();\\n        if (sum < S || -sum > -S) return 0;\\n        int fullRange = (2 * sum)+1;\\n        int[][] dp = new int[nums.length+1][fullRange];\\n        for (int[] row: dp){\\n            Arrays.fill(row,-1);\\n        }\\n\\n        return help2(0, sum, nums, S+sum, dp);\\n    }\\n    \\n    public int help2(int idx, int cur, int[] nums, int target, int[][] dp){\\n        if (dp[idx][cur] != -1)  return dp[idx][cur];\\n\\t\\t\\n        if (idx == nums.length){\\n            int val = 0;\\n            if (cur == target) {\\n                val = 1;\\n            }\\n            dp[idx][cur] = val;\\n            return val;\\n        }\\n        dp[idx][cur] = help2(idx+1, cur + nums[idx], nums, target, dp) + help2(idx+1, cur - nums[idx], nums, target, dp);\\n        \\n        return dp[idx][cur];\\n    }\\n```\n```\\nrow = idx, col = sum\\n\\n        0   1   2   3   4   5   6 \\n 0    [ x   x   x   1   x   x   x  ]\\n 1    [ x   x   0   x   1   x   x  ]\\n 2    [ x   0   x   0   x   1   x  ]\\n 3    [ 0   x   0   x   0   x   1  ]\\n```\n```\\n    public int findTargetSumWays(int[] nums, int S) {\\n        if (nums.length == 0 && S != 0) {\\n            return 0;\\n        }\\n        \\n        int sum = Arrays.stream(nums).sum();\\n        if (sum < S || -sum > -S ) return 0;\\n        int totalRange = (2 * sum)+1;\\n        \\n        int[] row = new int[totalRange];\\n        row[sum+S] = 1;\\n\\n        for (int i=0;i<nums.length;i++){ //not <= because we already calculated the first row\\n            int[] next = new int[totalRange];\\n            for (int k=0;k < totalRange;k++){\\n                if (row[k] != 0){\\n                    if (k-nums[i] >= 0) next[k-nums[i]] += row[k];\\n                    if (k+nums[i] < totalRange) next[k+nums[i]] += row[k];\\n                }\\n            }\\n            \\n            row = next;\\n        }\\n        return row[sum]; // just like we returned f(0,sum) in previous solution\\n    }\\n```\n```\\n//  0 1 2 3 4 5 6\\n\\t0 0 0 0 0 0 1 \\n\\t0 0 0 0 0 1 0 \\n\\t0 0 0 0 1 0 1 \\n\\t0 0 0 1 0 2 0 \\n```\n```\\n0 [x,x,x,x,x,5,x,x,x,x,x]\\n1 [x,x,x,x,1,x,4,x,x,x,x]\\n2 [x,x,x,0,x,1,x,3,x,x,x]\\n3 [x,x,0,x,0,x,1,x,2,x,x]\\n4 [x,0,x,0,x,0,x,1,x,1,x]\\n5 [0,x,0,x,0,x,0,x,1,x,0]\\n\\n// with x\\'s for 0\\'s so it\\'s easier to see\\n//  0 1 2 3 4 5 6 7  8 9 10\\n\\tx x x x x x x x  1 x x \\n\\tx x x x x x x 1  x 1 x \\n\\tx x x x x x 1 x  2 x 1 \\n\\tx x x x x 1 x 3  x 3 x \\n\\tx x x x 1 x 4 x  6 x 3 \\n\\tx x x 1 x 5 x 10 x 9 x \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1157060,
                "title": "0-1-knapsack",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    \\n    int countofSubsetSum(vector<int>& nums, int sum)\\n    {\\n        int n=nums.size(); \\n        int dp[n+1][sum+1];\\n        \\n        for(int j=0; j<sum+1; j++)\\n        {\\n            dp[0][j]=0;\\n        }\\n        \\n        for(int i=0; i<n+1; i++)\\n        {\\n            dp[i][0]= 1;   \\n        }\\n        \\n        for(int i=1; i<n+1; i++)\\n        {\\n            for(int j=0; j<sum+1; j++)\\n            {\\n               if(nums[i-1] <= j)\\n                   dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];\\n                else dp[i][j]= dp[i-1][j];\\n            }\\n        }\\n        \\n        return dp[n][sum];\\n        \\n    }\\n    \\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum_arr=0; \\n        for(int x: nums)\\n        {\\n            sum_arr+= x;\\n        }\\n        \\n        \\n        int sum= (target+ sum_arr)/2;\\n        \\n        if( (target+ sum_arr) % 2 != 0 || sum_arr < target) return 0; \\n        \\n        \\n        return countofSubsetSum(nums, sum); \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int countofSubsetSum(vector<int>& nums, int sum)\\n    {\\n        int n=nums.size(); \\n        int dp[n+1][sum+1];\\n        \\n        for(int j=0; j<sum+1; j++)\\n        {\\n            dp[0][j]=0;\\n        }\\n        \\n        for(int i=0; i<n+1; i++)\\n        {\\n            dp[i][0]= 1;   \\n        }\\n        \\n        for(int i=1; i<n+1; i++)\\n        {\\n            for(int j=0; j<sum+1; j++)\\n            {\\n               if(nums[i-1] <= j)\\n                   dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];\\n                else dp[i][j]= dp[i-1][j];\\n            }\\n        }\\n        \\n        return dp[n][sum];\\n        \\n    }\\n    \\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum_arr=0; \\n        for(int x: nums)\\n        {\\n            sum_arr+= x;\\n        }\\n        \\n        \\n        int sum= (target+ sum_arr)/2;\\n        \\n        if( (target+ sum_arr) % 2 != 0 || sum_arr < target) return 0; \\n        \\n        \\n        return countofSubsetSum(nums, sum); \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245044,
                "title": "simple-dp-solution-variation-of-knapsack-problem",
                "content": "```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        sumOfNums = sum(nums)\\n        n = len(nums)\\n        \\n        if target > sumOfNums:\\n            return 0\\n\\n        if (target + sumOfNums) % 2 != 0:\\n            return 0\\n        \\n        s1 = (sumOfNums + target) // 2\\n        \\n        # DP Table\\n        t = [[0] * (s1 + 1) for i in range(n + 1)]\\n\\t\\t\\n        t[0][0] = 1\\n        \\n        for i in range(1, n + 1):\\n            for j in range(s1 + 1):\\n                \\n                if nums[i - 1] <= j:\\n                    t[i][j] = t[i - 1][j] + t[i - 1][j - nums[i - 1]]\\n                \\n                else:\\n                    t[i][j] = t[i-1][j]\\n            \\n        return t[n][s1]\\n```\\nIf you like my approach please consider upvoting. Also, if you have any doubts feel free to ask. \\nThank you.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        sumOfNums = sum(nums)\\n        n = len(nums)\\n        \\n        if target > sumOfNums:\\n            return 0\\n\\n        if (target + sumOfNums) % 2 != 0:\\n            return 0\\n        \\n        s1 = (sumOfNums + target) // 2\\n        \\n        # DP Table\\n        t = [[0] * (s1 + 1) for i in range(n + 1)]\\n\\t\\t\\n        t[0][0] = 1\\n        \\n        for i in range(1, n + 1):\\n            for j in range(s1 + 1):\\n                \\n                if nums[i - 1] <= j:\\n                    t[i][j] = t[i - 1][j] + t[i - 1][j - nums[i - 1]]\\n                \\n                else:\\n                    t[i][j] = t[i-1][j]\\n            \\n        return t[n][s1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 410294,
                "title": "javascript-dynamic-programming-solution",
                "content": "Set initial sum to `zero` and its count to `one`. Go through each number in the array and pre-calculate the next sums based on prevous sums/amounts.\\n\\nAs an simple example, for the following array: `[1, 1]` we would have the following sums on each step:\\n\\n0. { 0: 1 } // initial\\n1. { 1: 1, -1: 1 }\\n2. { 2: 1, 0: 2, -2: 1 }\\n\\n```js\\nvar findTargetSumWays = function(nums, S) {\\n  let sums = new Map([[0, 1]]);\\n  \\n  for (let num of nums) {\\n    const next = new Map();\\n    \\n    for (let [sum, amount] of sums) {\\n      const plus = sum + num;\\n      const minus = sum - num;\\n\\n      next.set(plus, next.has(plus) ? next.get(plus) + amount : amount);\\n      next.set(minus, next.has(minus) ? next.get(minus) + amount : amount);\\n    }\\n    \\n    sums = next;\\n  }\\n  \\n  return sums.has(S) ? sums.get(S) : 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```js\\nvar findTargetSumWays = function(nums, S) {\\n  let sums = new Map([[0, 1]]);\\n  \\n  for (let num of nums) {\\n    const next = new Map();\\n    \\n    for (let [sum, amount] of sums) {\\n      const plus = sum + num;\\n      const minus = sum - num;\\n\\n      next.set(plus, next.has(plus) ? next.get(plus) + amount : amount);\\n      next.set(minus, next.has(minus) ? next.get(minus) + amount : amount);\\n    }\\n    \\n    sums = next;\\n  }\\n  \\n  return sums.has(S) ? sums.get(S) : 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2377590,
                "title": "4-solutions-recursion-memoization-tabulation-c",
                "content": "### ***1. Recursive Solution* - Simple Intuition as written in the problem statement**\\n**Time Complexity - O(2 ^ n)**\\n**Space Complexity - Auxiliary Stack Space**\\n```\\nclass Solution {\\npublic:\\n    int target;\\n    int knapsack(vector<int>& nums, int n, int curSum) {\\n        if(n == 0) {\\n            if(curSum == target) \\n                return 1;\\n            return 0;\\n        }\\n        return knapsack(nums, n - 1, curSum + nums[n - 1]) + knapsack(nums, n - 1, curSum - nums[n - 1]);\\n        \\n    }\\n    \\n    int findTargetSumWays(vector<int>& nums, int sum) {\\n        target = sum;\\n        return knapsack(nums, nums.size(), 0);\\n    }\\n};\\n```\\n### ***2. Recursive Solution* - Used Some Mathematics** \\n**subset(1) + subset(2) = total   --- (1)**\\n**subset(1) - subset(2) = target     --- (2)**\\n*[Adding equations (1) and (2)]*\\n**2 * subset(1) = total - target**\\n**subset(1) = ( total - target) / 2**\\n**now subset(1)  = newSum**\\n*Now find the count of newSum in the given vector, return the count.*\\n**Time Complexity - O(n * target)**\\n**Space Complexity - Auxiliary Stack Space**\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& nums, int sum, int i) {\\n        if(i < 0) {\\n            if(sum == 0)\\n                return 1;\\n            return 0;\\n        }\\n        \\n        int nt = f(nums, sum, i - 1);\\n        int t = 0;\\n        \\n        if(sum >= nums[i])\\n            t = f(nums, sum - nums[i], i - 1);\\n        return t + nt;\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size();   \\n        int sum = 0;\\n        \\n        for(auto &it : nums)\\n            sum += it;\\n        \\n        if((sum - target) % 2 != 0 || (sum - target) < 0)\\n            return 0;\\n        \\n        int newSum = (sum - target) / 2;\\n        return f(nums, newSum, n - 1);\\n    }\\n};\\n```\\n### ***3. Recursive Memoized Solution* - Similar as 2nd solution** \\n**Time Complexity - O(n)**\\n**Space Complexity - O(n * target) + Auxiliary Stack Space**\\n```\\nclass Solution {\\npublic:\\n    int knapsack(vector<int>& nums, int n, int sum, vector<vector<int>>& dp) {\\n        \\n        // base conditions\\n        if(n == 0) {\\n            if(sum == 0) \\n                return 1;\\n            return 0;\\n        }\\n        \\n        // checking cache if result is already present\\n        if(dp[n - 1][sum] != -1) return dp[n - 1][sum];\\n        \\n        // if current element is greater than the sum\\n        if(nums[n - 1] > sum)\\n            return dp[n - 1][sum] = knapsack(nums, n - 1, sum, dp);\\n        \\n        // if current element is lesser than or equal to the sum\\n        return dp[n - 1][sum] = knapsack(nums, n - 1, sum - nums[n - 1], dp) + knapsack(nums, n - 1, sum, dp);\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(), sum = 0;\\n        for(auto &it : nums) \\n            sum += it;\\n        \\n        // corner case if sum - target is odd or negative\\n        if((sum - target) % 2 != 0 || (sum - target) < 0)\\n            return 0;\\n        \\n        target = sum - target;\\n        vector<vector<int>>dp(n, vector<int>(target + 1, -1));\\n        \\n        return knapsack(nums, n, target / 2, dp);\\n    }\\n};\\n```\\n### ***4. Tabulation Solution* - Just converted Memoized Solution into Tabulation**\\n**Time Complexity - O(n * target)**\\n**Space Complexity - O(n * target)**\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(), sum = 0;\\n        for(auto &it : nums) \\n            sum += it;\\n        \\n        // corner case if sum - target is odd or negative\\n        if((sum - target) % 2 != 0 || (sum - target) < 0)\\n            return 0;\\n        \\n        target = (sum - target) / 2;\\n        \\n        int dp[n + 1][target + 1];\\n        \\n        // initializing first column by 1\\n        for(int i = 0; i <= n; i++) \\n            dp[i][0] = 1;\\n        \\n        // initializing first row by 0 (from second elemnt i.e index = 1)\\n        for(int i = 1; i <= target; i++) \\n            dp[0][i] = 0;\\n\\n        for(int i = 1; i <= n; i++)\\n            for(int j = 0; j <= target; j++)\\n                if(nums[i - 1] <= j)\\n                    dp[i][j] = dp[i - 1][j - nums[i - 1]] + dp[i - 1][j];\\n                else\\n                    dp[i][j] = dp[i - 1][j];\\n        return dp[n][target];\\n    }\\n};\\n```\\n**Reference Link - https://www.youtube.com/watch?v=ot_XBHyqpFc&list=PL_z_8CaSLPWekqhdCPmFohncHwz8TY2Go&index=11&ab_channel=AdityaVerma**",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int target;\\n    int knapsack(vector<int>& nums, int n, int curSum) {\\n        if(n == 0) {\\n            if(curSum == target) \\n                return 1;\\n            return 0;\\n        }\\n        return knapsack(nums, n - 1, curSum + nums[n - 1]) + knapsack(nums, n - 1, curSum - nums[n - 1]);\\n        \\n    }\\n    \\n    int findTargetSumWays(vector<int>& nums, int sum) {\\n        target = sum;\\n        return knapsack(nums, nums.size(), 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& nums, int sum, int i) {\\n        if(i < 0) {\\n            if(sum == 0)\\n                return 1;\\n            return 0;\\n        }\\n        \\n        int nt = f(nums, sum, i - 1);\\n        int t = 0;\\n        \\n        if(sum >= nums[i])\\n            t = f(nums, sum - nums[i], i - 1);\\n        return t + nt;\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size();   \\n        int sum = 0;\\n        \\n        for(auto &it : nums)\\n            sum += it;\\n        \\n        if((sum - target) % 2 != 0 || (sum - target) < 0)\\n            return 0;\\n        \\n        int newSum = (sum - target) / 2;\\n        return f(nums, newSum, n - 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int knapsack(vector<int>& nums, int n, int sum, vector<vector<int>>& dp) {\\n        \\n        // base conditions\\n        if(n == 0) {\\n            if(sum == 0) \\n                return 1;\\n            return 0;\\n        }\\n        \\n        // checking cache if result is already present\\n        if(dp[n - 1][sum] != -1) return dp[n - 1][sum];\\n        \\n        // if current element is greater than the sum\\n        if(nums[n - 1] > sum)\\n            return dp[n - 1][sum] = knapsack(nums, n - 1, sum, dp);\\n        \\n        // if current element is lesser than or equal to the sum\\n        return dp[n - 1][sum] = knapsack(nums, n - 1, sum - nums[n - 1], dp) + knapsack(nums, n - 1, sum, dp);\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(), sum = 0;\\n        for(auto &it : nums) \\n            sum += it;\\n        \\n        // corner case if sum - target is odd or negative\\n        if((sum - target) % 2 != 0 || (sum - target) < 0)\\n            return 0;\\n        \\n        target = sum - target;\\n        vector<vector<int>>dp(n, vector<int>(target + 1, -1));\\n        \\n        return knapsack(nums, n, target / 2, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(), sum = 0;\\n        for(auto &it : nums) \\n            sum += it;\\n        \\n        // corner case if sum - target is odd or negative\\n        if((sum - target) % 2 != 0 || (sum - target) < 0)\\n            return 0;\\n        \\n        target = (sum - target) / 2;\\n        \\n        int dp[n + 1][target + 1];\\n        \\n        // initializing first column by 1\\n        for(int i = 0; i <= n; i++) \\n            dp[i][0] = 1;\\n        \\n        // initializing first row by 0 (from second elemnt i.e index = 1)\\n        for(int i = 1; i <= target; i++) \\n            dp[0][i] = 0;\\n\\n        for(int i = 1; i <= n; i++)\\n            for(int j = 0; j <= target; j++)\\n                if(nums[i - 1] <= j)\\n                    dp[i][j] = dp[i - 1][j - nums[i - 1]] + dp[i - 1][j];\\n                else\\n                    dp[i][j] = dp[i - 1][j];\\n        return dp[n][target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247296,
                "title": "c-recursion",
                "content": "```\\n int targetSum(vector<int>& nums, int i, int target)\\n    {\\n        if(target == 0 && i == nums.size())\\n            return 1;\\n        \\n        if(i >= nums.size())\\n            return 0;\\n        \\n        return targetSum(nums, i + 1, target - nums[i]) +\\n               targetSum(nums, i + 1, target + nums[i]);\\n    }\\n    \\n    int findTargetSumWays(vector<int>& nums, int target) \\n    {\\n        return targetSum(nums, 0, target);\\n    } \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n int targetSum(vector<int>& nums, int i, int target)\\n    {\\n        if(target == 0 && i == nums.size())\\n            return 1;\\n        \\n        if(i >= nums.size())\\n            return 0;\\n        \\n        return targetSum(nums, i + 1, target - nums[i]) +\\n               targetSum(nums, i + 1, target + nums[i]);\\n    }\\n    \\n    int findTargetSumWays(vector<int>& nums, int target) \\n    {\\n        return targetSum(nums, 0, target);\\n    } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 297754,
                "title": "5-lines-python",
                "content": "```python\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\\n        \\n        def dfs(cur, i, d = {}):\\n            if i < len(nums) and (i, cur) not in d: \\n                d[(i, cur)] = dfs(cur + nums[i], i + 1) + dfs(cur - nums[i], i + 1)\\n            return d.get((i, cur), int(cur == S))\\n        \\n        return dfs(0, 0)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\\n        \\n        def dfs(cur, i, d = {}):\\n            if i < len(nums) and (i, cur) not in d: \\n                d[(i, cur)] = dfs(cur + nums[i], i + 1) + dfs(cur - nums[i], i + 1)\\n            return d.get((i, cur), int(cur == S))\\n        \\n        return dfs(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564097,
                "title": "c-knapsack-0-1-dp-logic-explained",
                "content": "**Logic:** This problem is finding S1-S2 = target, consider S1 a subset that is taken with positive sign (+), and S2 the subset with negative sign (-).\\nSum being the net sum of all elements, we need to find S1 such that \\nS1 = (sum - target)/2\\nIf S1 exists, the remaining subset has sum S2 inevitably. \\nThe number of subsets that can be found with sum S1, is the answer for this problem.\\n\\n**If you understand the logic that why we are  counting subsets with sum S1, writing code is the easiest thing, logic is most important. Also, more is explained in comments as and when needed.**\\n\\n```\\nint findTargetSumWays(vector<int>& nums, int target) {\\n\\tint sum = accumulate(nums.begin(), nums.end(), 0);\\n\\t\\n\\t//For below if condition, \\n\\t//sum<abs(target), consider test case - nums: [100], target: -200\\n\\t//(target+sum) % 2 != 0, consider test case - nums: [7,9,3,8,0,2,4,8,3,9], its sum = 53 and target: 0, there could not be any 26.5 in integer array.\\n\\t\\n\\tif(sum < abs(target) || (target+sum) %2 != 0) return 0;\\n\\t\\n\\t//S1 is newTarget\\n\\tint newTarget = (sum - target)/2;\\n\\treturn countSubsetsWithSumTarget(nums, newTarget);\\n}\\n\\n//Count subsets with sum S1\\nint countSubsetsWithSumTarget(vector<int>& a, int target){\\n\\tint n= a.size(), w = target;\\n\\tint t[n+1][w+1];\\n\\n\\t//Initialization\\n\\tfor(int i=0; i<w+1; i++) t[0][i] = 0;\\n\\tfor(int j=0; j<n+1; j++) t[j][0] = 1;\\n\\n\\t//Knapsack 01\\n\\tfor(int i=1; i<n+1; i++){\\n\\t\\n\\t//j starts from 0, becuase 0s are considered valid in this problem, e.g - nums: [0,0,0,0], target: 0, ans = 16\\n\\t\\tfor(int j=0; j<w+1; j++){\\n\\t\\t\\tif(a[i-1] <= j){\\n\\t\\t\\t\\tt[i][j] = t[i-1][j-a[i-1]] + t[i-1][j];\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tt[i][j] = t[i-1][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn t[n][w];\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint findTargetSumWays(vector<int>& nums, int target) {\\n\\tint sum = accumulate(nums.begin(), nums.end(), 0);\\n\\t\\n\\t//For below if condition, \\n\\t//sum<abs(target), consider test case - nums: [100], target: -200\\n\\t//(target+sum) % 2 != 0, consider test case - nums: [7,9,3,8,0,2,4,8,3,9], its sum = 53 and target: 0, there could not be any 26.5 in integer array.\\n\\t\\n\\tif(sum < abs(target) || (target+sum) %2 != 0) return 0;\\n\\t\\n\\t//S1 is newTarget\\n\\tint newTarget = (sum - target)/2;\\n\\treturn countSubsetsWithSumTarget(nums, newTarget);\\n}\\n\\n//Count subsets with sum S1\\nint countSubsetsWithSumTarget(vector<int>& a, int target){\\n\\tint n= a.size(), w = target;\\n\\tint t[n+1][w+1];\\n\\n\\t//Initialization\\n\\tfor(int i=0; i<w+1; i++) t[0][i] = 0;\\n\\tfor(int j=0; j<n+1; j++) t[j][0] = 1;\\n\\n\\t//Knapsack 01\\n\\tfor(int i=1; i<n+1; i++){\\n\\t\\n\\t//j starts from 0, becuase 0s are considered valid in this problem, e.g - nums: [0,0,0,0], target: 0, ans = 16\\n\\t\\tfor(int j=0; j<w+1; j++){\\n\\t\\t\\tif(a[i-1] <= j){\\n\\t\\t\\t\\tt[i][j] = t[i-1][j-a[i-1]] + t[i-1][j];\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tt[i][j] = t[i-1][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn t[n][w];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1455055,
                "title": "dp-approach-similar-to-subset-sum-problem",
                "content": "**Understanding how can we convert the problem into a simpler one.**\\n\\nlet us say we have the array as [1,1,1,1,1] and the target = 3;\\nWe just need to add (+ or -) signs in front of the integers.\\n\\ne.g +1 +1 +1 -1 -1 = 3\\n\\n**essentially, what we are doing is that we are just splitting the numbers into two subsets, one with positive signs and the other with negative signs\\n**\\n(1 , 1 , 1) => with positive signs\\n(1 , 1) => with negative signs\\n\\n# **and we only are calcualting the difference of the sum of these sets**\\n\\n(1 , 1 , 1) => with positive signs , sum = 3\\n(1 , 1) => with negative signs , sum = 2\\n\\n# **diff = target = (3-2) = 1**\\n\\nso, this problem now reduces to just finding count of subsets which are having sum difference as target.\\n\\nThe solution for this is given below.\\n\\n```\\n \\n        int totalsum = 0;\\n        \\n        for(auto x : nums)\\n            totalsum += x;\\n             \\n        //count number of subsets with sum as their summation\\n       if(totalsum < target || (target + totalsum)&1 )\\n           return 0;\\n            \\n        int n = nums.size();\\n        int sum = (abs(target) + totalsum)/2;\\n        int dp[n+1][sum+1];\\n        \\n        for(int i=0;i<=n;i++)\\n            for(int j=0;j<=sum;j++)\\n            {\\n                if(i == 0 && j == 0)\\n                    dp[i][j] = 1;\\n                \\n                else if(i == 0)\\n                    dp[i][j] = 0;\\n                \\n                else if(j < nums[i-1])\\n                    dp[i][j] = dp[i-1][j];\\n                \\n                else\\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];\\n            }\\n        \\n        return dp[n][sum];\\n```\\n\\n**Hope you understood the solution. Please upvote if you liked it.**",
                "solutionTags": [],
                "code": "```\\n \\n        int totalsum = 0;\\n        \\n        for(auto x : nums)\\n            totalsum += x;\\n             \\n        //count number of subsets with sum as their summation\\n       if(totalsum < target || (target + totalsum)&1 )\\n           return 0;\\n            \\n        int n = nums.size();\\n        int sum = (abs(target) + totalsum)/2;\\n        int dp[n+1][sum+1];\\n        \\n        for(int i=0;i<=n;i++)\\n            for(int j=0;j<=sum;j++)\\n            {\\n                if(i == 0 && j == 0)\\n                    dp[i][j] = 1;\\n                \\n                else if(i == 0)\\n                    dp[i][j] = 0;\\n                \\n                else if(j < nums[i-1])\\n                    dp[i][j] = dp[i-1][j];\\n                \\n                else\\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];\\n            }\\n        \\n        return dp[n][sum];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 818871,
                "title": "swift-6-solutions-from-recursive-to-dp-to-optimized-100-with-complexity-analysis",
                "content": "**Recursive** Brute-force\\n*Time: O(2^n), Space:O(m) where n is nums.count and m is the range of sum*\\n```\\nfunc findTargetSumWays(_ nums: [Int], _ S: Int) -> Int {\\n\\treturn helper(nums, 0, nums.count, S)\\n}\\n\\nfunc helper(_ nums: [Int], _ index: Int, _ count: Int, _ target: Int) -> Int {\\n\\tif index == count {\\n\\t\\treturn target == 0 ? 1 : 0\\n\\t} else {\\n\\t\\tlet plus = helper(nums, index + 1, count, target - nums[index])\\n\\t\\tlet minus = helper(nums, index + 1, count, target + nums[index])\\n\\t\\treturn plus + minus\\n\\t}\\n}\\n```\\nLet\\'s improve the recursion with memoization\\n**Recursive with memo (top-down)**\\n*Time: O(n * m), Space:O(n * m) where n is nums.count and m is the range of sum*\\n```\\nfunc findTargetSumWays(_ nums: [Int], _ S: Int) -> Int {\\n\\tvar memo = [[Int]: Int]()\\n\\treturn helper(nums, 0, nums.count, S, &memo)\\n}\\n\\nfunc helper(_ nums: [Int], _ index: Int, _ count: Int, _ target: Int, _ memo: inout [[Int]: Int]) -> Int {\\n\\tif let solved = memo[[index, target]] { return solved }\\n\\n\\tif index == count {\\n\\t\\treturn target == 0 ? 1 : 0\\n\\t} else {\\n\\t\\tlet plus = helper(nums, index + 1, count, target - nums[index], &memo)\\n\\t\\tlet minus = helper(nums, index + 1, count, target + nums[index], &memo)\\n\\t\\tmemo[[index, target]] = plus + minus\\n\\t\\treturn memo[[index, target]]!\\n\\t}\\n}\\n```\\n---\\nLet\\'s try to do it iteratively\\n**Iterative with 2D memo**\\n*Time: O(n * m), Space:O(n * m) where n is nums.count and m is the range of sum*\\n```\\nfunc findTargetSumWays(_ nums: [Int], _ S: Int) -> Int {\\n\\tlet count = nums.count\\n\\tlet sum = nums.reduce(0, +)\\n\\tif (S < -sum || S > sum) { return 0 } // impossible\\n\\n\\tvar memo = Array(repeating: Array(repeating: 0, count: sum * 2 + 1), count: count) \\n\\tmemo[0][sum + nums[0]] = 1\\n\\tmemo[0][sum - nums[0]] += 1 // nums[0] could be 0\\n\\n\\tfor i in 1..<count {\\n\\t\\tlet num = nums[i]\\n\\t\\tfor j in 0...2*sum {\\n\\t\\t\\tif memo[i - 1][j] > 0 { // if there\\'s valid sum of j up to index i - 1\\n\\t\\t\\t\\tmemo[i][j + num] += memo[i - 1][j]\\n\\t\\t\\t\\tmemo[i][j - num] += memo[i - 1][j]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn memo[count - 1][sum + S]\\n}\\n```\\nImprove the solution above by using only 1D array\\n**Iterative with 1D memo**\\n*Time: O(n * m), Space:O(m) where n is nums.count and m is the range of sum*\\n```\\nfunc findTargetSumWays(_ nums: [Int], _ S: Int) -> Int {\\n\\tlet count = nums.count\\n\\tlet sum = nums.reduce(0, +)\\n\\tif (S < -sum || S > sum) { return 0 } // impossible\\n\\n\\tvar memo = Array(repeating: 0, count: sum * 2 + 1) \\n\\tmemo[sum + nums[0]] = 1\\n\\tmemo[sum - nums[0]] += 1 // nums[0] could be 0\\n\\n\\tfor i in 1..<count {\\n\\t\\tlet num = nums[i]\\n\\t\\tvar nextMemo = Array(repeating: 0, count: sum * 2 + 1) \\n\\t\\tfor j in 0...2*sum {\\n\\t\\t\\tif memo[j] > 0 { // if there\\'s valid sum of j in the past\\n\\t\\t\\t\\tnextMemo[j + num] += memo[j]\\n\\t\\t\\t\\tnextMemo[j - num] += memo[j]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tmemo = nextMemo\\n\\t}\\n\\n\\treturn memo[sum + S]\\n}\\n```\\n\\n---\\nHere is a solution after some advanced thought process.\\nLet\\'s say we have the total sum of all numbers and call it \"sum\". We know that to subtract and add numbers in \"nums\" to get to \"S\" we need some numbers that can add up to (\"S\" - \"sum\") / 2, and **SUBTRACT those out**.\\n\\nFor example: if our \"nums\" is 1 2 2 3 4 and S is 4.\\nThe total \"sum\" of \"nums\" is 12 as you can easily calculate. How do we get from 12 to 4? We need numbers that can add up to (12 - 4) / 2 = 4, and **SUBTRACT those out**. From observing, those numbers can be 1, 3 or 2, 2.\\n\\nThereforre, if we do -1 +2 +2 -3 + 4, or +1 -2 -2 +3 +4, we both will get 4 which is what we wanted for \"S\"\\n\\nHere is the implementation.\\n*Time: O(n * t), Space:O(n * t) where n is nums.count and t is the target which = (sum - S) / 2*\\n```\\nfunc findTargetSumWays(_ nums: [Int], _ S: Int) -> Int {\\n\\tlet count = nums.count\\n\\tlet sum = nums.reduce(0, +)\\n\\tif (S < -sum || S > sum) { return 0 } // impossible\\n\\tif (sum - S) % 2 == 1 { return 0 } // impossible\\n\\n\\tlet target = (sum - S) / 2 // we only need to find numbers that add up to this target\\n\\n\\tvar memo = Array(repeating: Array(repeating: 0, count: target + 1), count: count + 1)\\n\\tmemo[0][0] = 1; \\n\\n\\tfor i in 1...count {\\n\\t\\tlet num = nums[i - 1]\\n\\t\\tfor curTarget in 0...target {\\n\\t\\t\\tmemo[i][curTarget] += memo[i - 1][curTarget]\\n\\t\\t\\tif curTarget >= num { // num is a possible candidate\\n\\t\\t\\t\\tmemo[i][curTarget] += memo[i - 1][curTarget - num]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn memo[count][target]\\n}\\n```\\n\\nUse the idea above and optimize it as 1D Array, we will have\\n**MOST OPTIMIZED solution**\\n*Time: O(n * t), Space:O(t) where n is nums.count and t is the target which = (sum - S) / 2*\\n```\\nfunc findTargetSumWays(_ nums: [Int], _ S: Int) -> Int {\\n\\tlet count = nums.count\\n\\tlet sum = nums.reduce(0, +)\\n\\tif (S < -sum || S > sum) { return 0 } // impossible\\n\\tif (sum - S) % 2 == 1 { return 0 } // impossible\\n\\n\\tlet target = (sum - S) / 2 // we only need to find numbers that add up to this target\\n\\n\\tvar memo = Array(repeating: 0, count: target + 1)\\n\\tmemo[0] = 1; \\n\\n\\tfor num in nums {\\n\\t\\tfor curTarget in stride(from: target, through: 0, by: -1) {\\n\\t\\t\\tif curTarget >= num { // num is a possible candidate\\n\\t\\t\\t\\tmemo[curTarget] += memo[curTarget - num]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn memo[target]\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc findTargetSumWays(_ nums: [Int], _ S: Int) -> Int {\\n\\treturn helper(nums, 0, nums.count, S)\\n}\\n\\nfunc helper(_ nums: [Int], _ index: Int, _ count: Int, _ target: Int) -> Int {\\n\\tif index == count {\\n\\t\\treturn target == 0 ? 1 : 0\\n\\t} else {\\n\\t\\tlet plus = helper(nums, index + 1, count, target - nums[index])\\n\\t\\tlet minus = helper(nums, index + 1, count, target + nums[index])\\n\\t\\treturn plus + minus\\n\\t}\\n}\\n```\n```\\nfunc findTargetSumWays(_ nums: [Int], _ S: Int) -> Int {\\n\\tvar memo = [[Int]: Int]()\\n\\treturn helper(nums, 0, nums.count, S, &memo)\\n}\\n\\nfunc helper(_ nums: [Int], _ index: Int, _ count: Int, _ target: Int, _ memo: inout [[Int]: Int]) -> Int {\\n\\tif let solved = memo[[index, target]] { return solved }\\n\\n\\tif index == count {\\n\\t\\treturn target == 0 ? 1 : 0\\n\\t} else {\\n\\t\\tlet plus = helper(nums, index + 1, count, target - nums[index], &memo)\\n\\t\\tlet minus = helper(nums, index + 1, count, target + nums[index], &memo)\\n\\t\\tmemo[[index, target]] = plus + minus\\n\\t\\treturn memo[[index, target]]!\\n\\t}\\n}\\n```\n```\\nfunc findTargetSumWays(_ nums: [Int], _ S: Int) -> Int {\\n\\tlet count = nums.count\\n\\tlet sum = nums.reduce(0, +)\\n\\tif (S < -sum || S > sum) { return 0 } // impossible\\n\\n\\tvar memo = Array(repeating: Array(repeating: 0, count: sum * 2 + 1), count: count) \\n\\tmemo[0][sum + nums[0]] = 1\\n\\tmemo[0][sum - nums[0]] += 1 // nums[0] could be 0\\n\\n\\tfor i in 1..<count {\\n\\t\\tlet num = nums[i]\\n\\t\\tfor j in 0...2*sum {\\n\\t\\t\\tif memo[i - 1][j] > 0 { // if there\\'s valid sum of j up to index i - 1\\n\\t\\t\\t\\tmemo[i][j + num] += memo[i - 1][j]\\n\\t\\t\\t\\tmemo[i][j - num] += memo[i - 1][j]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn memo[count - 1][sum + S]\\n}\\n```\n```\\nfunc findTargetSumWays(_ nums: [Int], _ S: Int) -> Int {\\n\\tlet count = nums.count\\n\\tlet sum = nums.reduce(0, +)\\n\\tif (S < -sum || S > sum) { return 0 } // impossible\\n\\n\\tvar memo = Array(repeating: 0, count: sum * 2 + 1) \\n\\tmemo[sum + nums[0]] = 1\\n\\tmemo[sum - nums[0]] += 1 // nums[0] could be 0\\n\\n\\tfor i in 1..<count {\\n\\t\\tlet num = nums[i]\\n\\t\\tvar nextMemo = Array(repeating: 0, count: sum * 2 + 1) \\n\\t\\tfor j in 0...2*sum {\\n\\t\\t\\tif memo[j] > 0 { // if there\\'s valid sum of j in the past\\n\\t\\t\\t\\tnextMemo[j + num] += memo[j]\\n\\t\\t\\t\\tnextMemo[j - num] += memo[j]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tmemo = nextMemo\\n\\t}\\n\\n\\treturn memo[sum + S]\\n}\\n```\n```\\nfunc findTargetSumWays(_ nums: [Int], _ S: Int) -> Int {\\n\\tlet count = nums.count\\n\\tlet sum = nums.reduce(0, +)\\n\\tif (S < -sum || S > sum) { return 0 } // impossible\\n\\tif (sum - S) % 2 == 1 { return 0 } // impossible\\n\\n\\tlet target = (sum - S) / 2 // we only need to find numbers that add up to this target\\n\\n\\tvar memo = Array(repeating: Array(repeating: 0, count: target + 1), count: count + 1)\\n\\tmemo[0][0] = 1; \\n\\n\\tfor i in 1...count {\\n\\t\\tlet num = nums[i - 1]\\n\\t\\tfor curTarget in 0...target {\\n\\t\\t\\tmemo[i][curTarget] += memo[i - 1][curTarget]\\n\\t\\t\\tif curTarget >= num { // num is a possible candidate\\n\\t\\t\\t\\tmemo[i][curTarget] += memo[i - 1][curTarget - num]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn memo[count][target]\\n}\\n```\n```\\nfunc findTargetSumWays(_ nums: [Int], _ S: Int) -> Int {\\n\\tlet count = nums.count\\n\\tlet sum = nums.reduce(0, +)\\n\\tif (S < -sum || S > sum) { return 0 } // impossible\\n\\tif (sum - S) % 2 == 1 { return 0 } // impossible\\n\\n\\tlet target = (sum - S) / 2 // we only need to find numbers that add up to this target\\n\\n\\tvar memo = Array(repeating: 0, count: target + 1)\\n\\tmemo[0] = 1; \\n\\n\\tfor num in nums {\\n\\t\\tfor curTarget in stride(from: target, through: 0, by: -1) {\\n\\t\\t\\tif curTarget >= num { // num is a possible candidate\\n\\t\\t\\t\\tmemo[curTarget] += memo[curTarget - num]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn memo[target]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794750,
                "title": "c-dfs-based-approach-with-extra-optimisation-explained-25-time-95-space",
                "content": "In this problem I thought we had an ideal case for using a DFS-based approach outside the usual, canonical tree traversal challenge, going from node to node: I mean, we still do more or less that, but we need to somehow create the tree itself.\\n\\nAnd before doing that, we need to of course visualise it: for each number in `nums`, I can move in 2 directions - either adding or subtracting it to some cumulative `sum` that I will have to check in the end if it matches our `target` value and if so, we increasse our `res` variable counter. I put all of them as class variables, in order to avoid having to pass them down all the time as the recursive calls go wild.\\n\\nAnd, well: now I can see the tree! And it is going to be a rather complex one, more less equal to the `2` raised to the power of the lenght of `nums` plus `1`.\\n\\nI thought I could still pass that way. And I was wrong.\\n\\nBut more later about that and how I fixed it: when my implementation of `findTargetSumWays`  is first called, I assign the value of `s` to target and I go calling `dfs` on `nums`.\\n\\nIn `dfs`, the heart of my logic, first of all I check if we are at the last step (ie: we are done checking elements in `nums`), when the optional parameter `poss` (defaulted to `0`, the beginning) is equal to `nums.size()`; if so, I check if the cumulative value of `sum` matches our `target` to decide whether or we increase `res` and in any case I exit with a laconic `return` statement.\\n\\nIf that is not the case, it means we have still work to do: I update the running value of `sum` removing the `pos`th element of `nums` from it and then I call `dfs` again, still with `nums` and with an increased value of `pos`.\\n\\nAfter that, I backtrack and consider instead adding  the `pos`th element of `nums`, which equates to adding its value twice to `sum` (one to backtrack the previous subtraction, another to properly consider it) and again I call recursively `dfs` with an increased value of `pos`.\\n\\nAfter that, one final backtrack, removing the `pos`th element of `nums`, and we are done with the logic for this function.\\n\\nWhen all the recursive calls are concluded, we can just return `res` :)\\n\\nMy initial code, sadly timing out:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int res = 0;\\n    int target;\\n    int sum = 0;\\n    void dfs(vector<int>& nums, int pos = 0) {\\n        if (pos == nums.size()) {\\n            if (sum == target) res++;\\n            return;\\n        }\\n        // trying with minus first\\n        sum -= nums[pos];\\n        dfs(nums, pos + 1);\\n        // backtracking and trying with plus\\n        sum += nums[pos] * 2;\\n        dfs(nums, pos + 1);\\n        // backtracking - resetting sum to the initial value\\n        sum -= nums[pos];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int s) {\\n        target = s;\\n        dfs(nums);\\n        return res;\\n    }\\n};\\n```\\n\\nI then realised that at some point we might have branches that go up to the end, pretty expensively, despite the mathematical impossibility of them conducting to any viable result.\\n\\nI decided to sleep over it and ultimately woke up with the solution in my mind - it is really sweet when you fall in love with a problem and think about it all the time \\u2764\\uFE0F - you cannot do that in an interview, of course, but I would highly recommend it, since it means your mind is training even when you do not realise it.\\n\\nThat happens when the distance between the intended `target` and the current cumulative `sum` is greater than what we might achieve summing (or subtracting) all the remaining numbers.\\n\\nIn order to prevent this waste of resources, I built a `limits` array that tells me what is the maximum I can still add/subtract at any given point from `sum`; to populate it, I started from the rightmost value and I increased the sum going left, so, for example, if we stated with `nums == [3,4,5,2,1,3,2,3,4,50,3,13,8,7]`, `limits` would be populated to be `[108,105,101,96,94,93,90,88,85,81,31,28,15,7]`.\\n\\nHow does it help?\\n\\nWell, suppose our target is `100`: there are `7` ways to sum up to that value, but considering `nums` has length `14`, we probably would not want to do about `2 ** 15` operations here.\\n\\nWhat happens is that when for example subtracted the first 2 numbers and got `-7`, we know we can stop already, because we know that at in order to reach the target we would need `100 - -7 == 107`, but most we can get proceeding is just `101`, the value we stored in `limits[2]`: now that saves up A LOT of computation.\\n\\nSimilarly we might have reached position `3` with `sum == 2` (`3 + 4 - 5`): at that position the maximum we can still get even summing all numbers is `96`, so we fall short of what we should have and again we quit here.\\n\\nYou can try the same logic with negative numbers and see it works just fine :)\\n\\nMy updated and passing code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int res = 0;\\n    int target;\\n    int sum = 0;\\n    int limits[21] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\\n    void dfs(vector<int>& nums, int pos = 0) {\\n        // checking if we finished using all numbers on this branch\\n        if (pos == nums.size()) {\\n            // and in case incrementing res\\n            if (sum == target) res++;\\n            return;\\n        }\\n        // dropping the DFS when it makes no sense to continue\\n        if (abs(target - sum) > limits[pos]) return;\\n        // trying with minus first\\n        sum -= nums[pos];\\n        dfs(nums, pos + 1);\\n        // backtracking and trying with plus\\n        sum += nums[pos] * 2;\\n        dfs(nums, pos + 1);\\n        // backtracking - resetting sum to the initial value\\n        sum -= nums[pos];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int s) {\\n        for (int i = nums.size() - 1; i >= 0; i--) limits[i] = limits[i + 1] + nums[i];\\n        target = s;\\n        dfs(nums);\\n        return res;\\n    }\\n};\\n```\\nCould I consider myself satisfied?\\n\\nOf course no: [further optimised version](https://leetcode.com/problems/target-sum/discuss/801164/), more conveniently read in a separate topic.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int res = 0;\\n    int target;\\n    int sum = 0;\\n    void dfs(vector<int>& nums, int pos = 0) {\\n        if (pos == nums.size()) {\\n            if (sum == target) res++;\\n            return;\\n        }\\n        // trying with minus first\\n        sum -= nums[pos];\\n        dfs(nums, pos + 1);\\n        // backtracking and trying with plus\\n        sum += nums[pos] * 2;\\n        dfs(nums, pos + 1);\\n        // backtracking - resetting sum to the initial value\\n        sum -= nums[pos];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int s) {\\n        target = s;\\n        dfs(nums);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int res = 0;\\n    int target;\\n    int sum = 0;\\n    int limits[21] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\\n    void dfs(vector<int>& nums, int pos = 0) {\\n        // checking if we finished using all numbers on this branch\\n        if (pos == nums.size()) {\\n            // and in case incrementing res\\n            if (sum == target) res++;\\n            return;\\n        }\\n        // dropping the DFS when it makes no sense to continue\\n        if (abs(target - sum) > limits[pos]) return;\\n        // trying with minus first\\n        sum -= nums[pos];\\n        dfs(nums, pos + 1);\\n        // backtracking and trying with plus\\n        sum += nums[pos] * 2;\\n        dfs(nums, pos + 1);\\n        // backtracking - resetting sum to the initial value\\n        sum -= nums[pos];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int s) {\\n        for (int i = nums.size() - 1; i >= 0; i--) limits[i] = limits[i + 1] + nums[i];\\n        target = s;\\n        dfs(nums);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283014,
                "title": "494-time-92-20-and-space-96-14-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Calculate the sum of all elements in the input list.\\n2. Check if the target sum is greater than the sum of all elements in the input list or if the absolute difference between the target sum and the sum of all elements is odd. If either of these conditions is true, return 0, as there is no way to form the target sum by adding or subtracting elements from the input list.\\n3. Define a function called knapsack that takes an integer target as its argument and returns an integer.\\n4. Create a list called dp with a length equal to the sum of all elements in the input list plus one, where the first element is initialized to 1 and the rest are initialized to 0. This list will be used to keep track of the number of ways to sum up to each possible target.\\n5. For each element in the input list, iterate backwards through the dp list from the end to the current element (inclusive), so that the dp values for the current element are only based on the previous elements in the list, and not the current element or any elements after it.\\n6. Add the dp value for the previous element at the current index, j - num, to the dp value for the current index, j. This is because there are dp[j - num] ways to sum up to the target using all elements up to and including the current element, and we\\'re adding those ways to the existing ways to sum up to the target using all elements up to but not including the current element.\\n7. Return the dp value for the target sum.\\n8. Call the knapsack function with the target sum divided by 2, because we\\'re counting the number of ways to form the target sum using addition and subtraction, and the two operations can cancel each other out, meaning that the target sum can only be achieved if it\\'s an even number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n    # Calculate the sum of all elements in the input list\\n    summ = sum(nums)\\n    # If the target is greater than the sum of all elements or their absolute difference is odd,\\n    # there\\'s no way to form the target sum by adding or subtracting elements from the input list.\\n    if summ < abs(target) or (summ + target) & 1:\\n      return 0\\n\\n    def knapsack(target: int) -> int:\\n      # Create a list with a length equal to the sum of all elements in the input list plus one,\\n      # where the first element is initialized to 1 and the rest are initialized to 0.\\n      # This list will be used to keep track of the number of ways to sum up to each possible target.\\n      dp = [1] + [0] * summ\\n\\n      # For each element in the input list,\\n      for num in nums:\\n        # Iterate backwards through the dp list from the end to the current element (inclusive),\\n        # so that the dp values for the current element are only based on the previous elements\\n        # in the list, and not the current element or any elements after it.\\n        for j in range(summ, num - 1, -1):\\n          # Add the dp value for the previous element at the current index, j - num,\\n          # to the dp value for the current index, j.\\n          # This is because there are dp[j - num] ways to sum up to the target using all elements\\n          # up to and including the current element, and we\\'re adding those ways to the existing ways\\n          # to sum up to the target using all elements up to but not including the current element.\\n          dp[j] += dp[j - num]\\n\\n      # Return the dp value for the target sum.\\n      return dp[target]\\n\\n    # Call the knapsack function with the target sum divided by 2, because we\\'re counting the number\\n    # of ways to form the target sum using addition and subtraction, and the two operations can cancel\\n    # each other out, meaning that the target sum can only be achieved if it\\'s an even number.\\n    return knapsack((summ + target) // 2)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n  def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n    # Calculate the sum of all elements in the input list\\n    summ = sum(nums)\\n    # If the target is greater than the sum of all elements or their absolute difference is odd,\\n    # there\\'s no way to form the target sum by adding or subtracting elements from the input list.\\n    if summ < abs(target) or (summ + target) & 1:\\n      return 0\\n\\n    def knapsack(target: int) -> int:\\n      # Create a list with a length equal to the sum of all elements in the input list plus one,\\n      # where the first element is initialized to 1 and the rest are initialized to 0.\\n      # This list will be used to keep track of the number of ways to sum up to each possible target.\\n      dp = [1] + [0] * summ\\n\\n      # For each element in the input list,\\n      for num in nums:\\n        # Iterate backwards through the dp list from the end to the current element (inclusive),\\n        # so that the dp values for the current element are only based on the previous elements\\n        # in the list, and not the current element or any elements after it.\\n        for j in range(summ, num - 1, -1):\\n          # Add the dp value for the previous element at the current index, j - num,\\n          # to the dp value for the current index, j.\\n          # This is because there are dp[j - num] ways to sum up to the target using all elements\\n          # up to and including the current element, and we\\'re adding those ways to the existing ways\\n          # to sum up to the target using all elements up to but not including the current element.\\n          dp[j] += dp[j - num]\\n\\n      # Return the dp value for the target sum.\\n      return dp[target]\\n\\n    # Call the knapsack function with the target sum divided by 2, because we\\'re counting the number\\n    # of ways to form the target sum using addition and subtraction, and the two operations can cancel\\n    # each other out, meaning that the target sum can only be achieved if it\\'s an even number.\\n    return knapsack((summ + target) // 2)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606387,
                "title": "easy-recursion-and-memoization-c",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int n;\\n    int target;\\n    map<pair<int, int>, int> dp;\\n    int HelperFun(vector<int> &nums, int sum, int i)\\n    {\\n        if (i == n)\\n        {\\n            if (sum == target)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        if (dp.find({sum, i}) != dp.end())\\n            return dp[{sum, i}];\\n        int takePlus = HelperFun(nums, sum + nums[i], i + 1);\\n        int takeNeg = HelperFun(nums, sum - nums[i], i + 1);\\n        return dp[{sum, i}] = takePlus + takeNeg;\\n    }\\n    int findTargetSumWays(vector<int> &nums, int t)\\n    {\\n        n = nums.size();\\n        target = t;\\n        int ans = HelperFun(nums, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int n;\\n    int target;\\n    map<pair<int, int>, int> dp;\\n    int HelperFun(vector<int> &nums, int sum, int i)\\n    {\\n        if (i == n)\\n        {\\n            if (sum == target)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        if (dp.find({sum, i}) != dp.end())\\n            return dp[{sum, i}];\\n        int takePlus = HelperFun(nums, sum + nums[i], i + 1);\\n        int takeNeg = HelperFun(nums, sum - nums[i], i + 1);\\n        return dp[{sum, i}] = takePlus + takeNeg;\\n    }\\n    int findTargetSumWays(vector<int> &nums, int t)\\n    {\\n        n = nums.size();\\n        target = t;\\n        int ans = HelperFun(nums, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444144,
                "title": "python-dfs-explanation-with-figure",
                "content": "- The core is to find the sub-problem and the base case.\\n    - The initial problem is: at index `0`, for target sum = `target`, how many possible ways can we find? In the beginning, for an array `nums`, we can generate 2 cases: either multiply `nums[0]` by `1` or `-1`.\\n    - Then, we come to a sub-problem:  at index `1`, for target sum = `target-nums[0]` (if `1` is the multiplier) or `target+nums[0]` (if `-1` is the multiplier), how many possible ways can we find?\\n    - So, the recursive DFS should return the number of different expressions that can be built at a certain index with a certain target.\\n- The base case is when the index comes to the end of the array. If the current target is `0`, that means we find a valid expression, so `count = 1`; otherwise, this outcome is not valid, `count = 0`. Before coming to the base case, the count of valid expressions for the current problem is the sum of the results of its two sub-problems.\\n- We use a hashmap to store the current answers at each index, whose keys store `(index, target)` and values store the count of feasible solutions for `nums[index+1:]` with target sum = `target`.\\n- In the `dfs` function, to avoid duplicates, we take actions only when the current `index` and `target` have not been added to our hashmap, otherwise, we simply return `hashmap[(index, target)]`. If `(index, target)` is not in the hashmap, we get the value of `count` and update the hashmap by `hashmap[(index, target)] = count`.\\n\\n![image](https://assets.leetcode.com/users/images/9b20c825-5fdd-480b-aa2b-d2722773a0ff_1660821737.7231226.png)\\n\\n```\\nclass Solution(object):\\n    def findTargetSumWays(self, nums, target):\\n        res = {}  # key = (index, target), value = count of feasible solutions for nums[index+1:] with target sum = target\\n        \\n        def dfs(index, target):\\n            if (index, target) not in res:\\n                if index == len(nums):\\n                    count = 1 if target == 0 else 0\\n                else:\\n                    count = dfs(index+1, target-nums[index]) + dfs(index+1, target+nums[index])\\n                res[(index, target)] = count\\n            return res[(index, target)]          \\n          \\n        return dfs(0, target)\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findTargetSumWays(self, nums, target):\\n        res = {}  # key = (index, target), value = count of feasible solutions for nums[index+1:] with target sum = target\\n        \\n        def dfs(index, target):\\n            if (index, target) not in res:\\n                if index == len(nums):\\n                    count = 1 if target == 0 else 0\\n                else:\\n                    count = dfs(index+1, target-nums[index]) + dfs(index+1, target+nums[index])\\n                res[(index, target)] = count\\n            return res[(index, target)]          \\n          \\n        return dfs(0, target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105465,
                "title": "dp-explanation-code-easy-to-understand-python",
                "content": "\\n* **We\\'ll traverse at every index of array**\\n\\t* **At every index will maintain the all possible sum and their frequency using dictionary or map.**\\n\\n\\n\\n```\\nPython code:\\nclass Solution:\\n    \\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        count={0:1} \\n        for num in nums:\\n            tempcount={}\\n            for key in count:\\n                tempcount[key-num]=tempcount.get(key-num,0)+count[key]\\n                tempcount[key+num]=tempcount.get(key+num,0)+count[key]\\n            count=tempcount\\n        return count.get(target,0)\\n```\\n\\n\\n\\n**Please Upvote, if you find it helpful :)**\\nDo comment if you have any query or suggestion.",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nPython code:\\nclass Solution:\\n    \\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        count={0:1} \\n        for num in nums:\\n            tempcount={}\\n            for key in count:\\n                tempcount[key-num]=tempcount.get(key-num,0)+count[key]\\n                tempcount[key+num]=tempcount.get(key+num,0)+count[key]\\n            count=tempcount\\n        return count.get(target,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682759,
                "title": "java-solution-dp-count-subset-with-given-difference-problem-of-0-1-knapsack-problem",
                "content": "```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n        int sum = 0;\\n        for(int x : nums)\\n            sum += x;\\n        if(((sum - target) % 2 == 1) || (target > sum))\\n            return 0;\\n        \\n        int n = nums.length;\\n        int val= (sum - target)/2;\\n        int[][] t = new int[n + 1][val + 1];\\n        t[0][0] = 1;\\n        \\n        for(int i = 1; i < n + 1; i++) {\\n            for(int j = 0; j < val + 1; j++) {\\n                if(nums[i - 1] <= j)\\n                    t[i][j] = t[i-1][j] + t[i - 1][j - nums[i - 1]];\\n                else\\n                    t[i][j] = t[i - 1][j];\\n            }\\n        }\\n        return t[n][val];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n        int sum = 0;\\n        for(int x : nums)\\n            sum += x;\\n        if(((sum - target) % 2 == 1) || (target > sum))\\n            return 0;\\n        \\n        int n = nums.length;\\n        int val= (sum - target)/2;\\n        int[][] t = new int[n + 1][val + 1];\\n        t[0][0] = 1;\\n        \\n        for(int i = 1; i < n + 1; i++) {\\n            for(int j = 0; j < val + 1; j++) {\\n                if(nums[i - 1] <= j)\\n                    t[i][j] = t[i-1][j] + t[i - 1][j - nums[i - 1]];\\n                else\\n                    t[i][j] = t[i - 1][j];\\n            }\\n        }\\n        return t[n][val];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1436923,
                "title": "dp-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int subset(vector<int>nums,int sum){\\n        int n=nums.size();\\n        int dp[n+1][sum+1];\\n        for(int i=0;i<=n;i++)\\n            dp[i][0]=1;\\n        for(int j=1;j<=sum;j++)\\n            dp[0][j]=0;\\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<=sum;j++){\\n                dp[i][j]=dp[i-1][j];\\n                if(nums[i-1]<=j)\\n                    dp[i][j]=dp[i][j]+dp[i-1][j-nums[i-1]];\\n            }\\n        }\\n        return dp[n][sum];        \\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int s=0;\\n        s=accumulate(nums.begin(),nums.end(),s);\\n        int p=(target+s)/2;\\n        if(s < target || (s + target) % 2 != 0)\\n            return 0;\\n        return subset(nums,abs(p));   \\n    }\\n};\\n```\\n**please consider upvote if you understand this solution**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subset(vector<int>nums,int sum){\\n        int n=nums.size();\\n        int dp[n+1][sum+1];\\n        for(int i=0;i<=n;i++)\\n            dp[i][0]=1;\\n        for(int j=1;j<=sum;j++)\\n            dp[0][j]=0;\\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<=sum;j++){\\n                dp[i][j]=dp[i-1][j];\\n                if(nums[i-1]<=j)\\n                    dp[i][j]=dp[i][j]+dp[i-1][j-nums[i-1]];\\n            }\\n        }\\n        return dp[n][sum];        \\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int s=0;\\n        s=accumulate(nums.begin(),nums.end(),s);\\n        int p=(target+s)/2;\\n        if(s < target || (s + target) % 2 != 0)\\n            return 0;\\n        return subset(nums,abs(p));   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 837782,
                "title": "java-similar-to-subset-sum-problem-brute-force-recursion-with-memoization-2d-dynamic-programming",
                "content": "Method 1 : Brute Force\\n\\nTime    Complexity : O(2^n)\\nSpace  Complexity : O(n)\\n\\n```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int S) {\\n        int totalSum = 0;\\n        for(int i=0;i<nums.length;i++) {\\n            totalSum = totalSum + nums[i];\\n        }\\n        if(totalSum < S || (totalSum + S)%2 != 0)\\n            return 0;\\n        int sum = (totalSum + S)/2;\\n        int count = subsetSum(nums, nums.length, sum, 0);\\n        return count;\\n    }\\n    public int subsetSum(int [] nums, int n, int sum, int count) {\\n        if(n==0)\\n            if(sum ==0)\\n                return 1;\\n            else \\n                return 0;\\n        if(sum < nums[n-1])\\n            count = subsetSum(nums, n-1, sum, count);\\n        else\\n            count = subsetSum(nums, n-1, sum-nums[n-1], count) + \\n                subsetSum(nums, n-1, sum, count);\\n        return count;\\n    }\\n}\\n```\\n\\nMethod 2 : Recursion With Memoization\\nTime    Complexity : O(n * sum)\\nSpace  Complexity : O(n sum)\\n\\n```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int S) {\\n        int totalSum = 0;\\n        for(int i=0;i<nums.length;i++) {\\n            totalSum = totalSum + nums[i];\\n        }\\n        if(totalSum < S || (totalSum + S)%2 != 0)\\n            return 0;\\n        int sum = (totalSum + S)/2;\\n        int [][] dp = new int [nums.length + 1][sum + 1];\\n        int count = subsetSum(nums, nums.length, sum, dp);\\n        return count;\\n    }\\n    public int subsetSum(int [] nums, int n, int sum, int [][] dp) {\\n        if(n==0)\\n            if(sum ==0)\\n                return 1;\\n            else \\n                return 0;\\n        if(sum < nums[n-1])\\n            dp[n][sum] = subsetSum(nums, n-1, sum, dp);\\n        else\\n            dp[n][sum]= subsetSum(nums, n-1, sum-nums[n-1], dp) + \\n                subsetSum(nums, n-1, sum, dp);\\n        return dp[n][sum];\\n    }   \\n}\\n```\\n\\nMethod 3 : 2D Dynamic Programming\\nTime   Complexity : O(n * sum)\\nSpace Complexity : O(n * sum)\\n```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int S) {\\n        int totalSum = 0;\\n        for(int i=0;i<nums.length;i++) {\\n            totalSum = totalSum + nums[i];\\n        }\\n        if(totalSum < S || (totalSum + S)%2 != 0)\\n            return 0;\\n        int sum = (totalSum + S)/2;\\n        int [][] dp = new int [nums.length + 1][sum +1];  \\n        for(int j=0;j<dp[0].length;j++)\\n            dp[0][j] = 0;\\n        dp[0][0] = 1;\\n        for(int i=1;i < dp.length;i++) {\\n            for(int j=0;j < dp[0].length;j++) {\\n                if(j< nums[i-1])\\n                    dp[i][j] = dp[i-1][j];\\n                else \\n                    dp[i][j] = dp[i-1][j-nums[i-1]] + dp[i-1][j];\\n            }\\n        }\\n        return dp[nums.length][sum];\\n    }    \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int S) {\\n        int totalSum = 0;\\n        for(int i=0;i<nums.length;i++) {\\n            totalSum = totalSum + nums[i];\\n        }\\n        if(totalSum < S || (totalSum + S)%2 != 0)\\n            return 0;\\n        int sum = (totalSum + S)/2;\\n        int count = subsetSum(nums, nums.length, sum, 0);\\n        return count;\\n    }\\n    public int subsetSum(int [] nums, int n, int sum, int count) {\\n        if(n==0)\\n            if(sum ==0)\\n                return 1;\\n            else \\n                return 0;\\n        if(sum < nums[n-1])\\n            count = subsetSum(nums, n-1, sum, count);\\n        else\\n            count = subsetSum(nums, n-1, sum-nums[n-1], count) + \\n                subsetSum(nums, n-1, sum, count);\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int S) {\\n        int totalSum = 0;\\n        for(int i=0;i<nums.length;i++) {\\n            totalSum = totalSum + nums[i];\\n        }\\n        if(totalSum < S || (totalSum + S)%2 != 0)\\n            return 0;\\n        int sum = (totalSum + S)/2;\\n        int [][] dp = new int [nums.length + 1][sum + 1];\\n        int count = subsetSum(nums, nums.length, sum, dp);\\n        return count;\\n    }\\n    public int subsetSum(int [] nums, int n, int sum, int [][] dp) {\\n        if(n==0)\\n            if(sum ==0)\\n                return 1;\\n            else \\n                return 0;\\n        if(sum < nums[n-1])\\n            dp[n][sum] = subsetSum(nums, n-1, sum, dp);\\n        else\\n            dp[n][sum]= subsetSum(nums, n-1, sum-nums[n-1], dp) + \\n                subsetSum(nums, n-1, sum, dp);\\n        return dp[n][sum];\\n    }   \\n}\\n```\n```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int S) {\\n        int totalSum = 0;\\n        for(int i=0;i<nums.length;i++) {\\n            totalSum = totalSum + nums[i];\\n        }\\n        if(totalSum < S || (totalSum + S)%2 != 0)\\n            return 0;\\n        int sum = (totalSum + S)/2;\\n        int [][] dp = new int [nums.length + 1][sum +1];  \\n        for(int j=0;j<dp[0].length;j++)\\n            dp[0][j] = 0;\\n        dp[0][0] = 1;\\n        for(int i=1;i < dp.length;i++) {\\n            for(int j=0;j < dp[0].length;j++) {\\n                if(j< nums[i-1])\\n                    dp[i][j] = dp[i-1][j];\\n                else \\n                    dp[i][j] = dp[i-1][j-nums[i-1]] + dp[i-1][j];\\n            }\\n        }\\n        return dp[nums.length][sum];\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 528590,
                "title": "c-simple-bottom-up-beats-100-memory-wise-dp-solution-detailed-explanantion",
                "content": "```\\n/*\\n    https://leetcode.com/problems/target-sum/\\n\\t\\n\\tThe given sets can be considered as P and N. where N contains the numbers of other set which are\\n\\tsubtracted.\\n\\tP - N = Target(T)\\n    P + N = S\\n\\t2P = T + S\\n\\tP = (T + S) / 2\\n\\t\\n\\t=> (T + S) should be even and P = (T + S)/2\\n*/\\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        int total = accumulate(nums.begin(), nums.end(), 0);\\n        // the sum of S and negative set should be even\\n        if(S > total || (S + total) % 2 != 0)\\n            return 0;\\n        \\n        int positive_set_sum = (S + total) / 2;\\n        \\n        // each entry i: num of ways in which sum i is possible using the given arrays elements \\n        vector<int> dp(positive_set_sum + 1, 0);\\n        // sum zero is always possible\\n        dp[0] = 1;\\n        \\n        for(const int& num: nums) {\\n            // starting from back to avoid addition of redundant terms with the \\n            // lower values when doing dp[i - num]\\n            for(int i = positive_set_sum; i >= num; i--) {\\n                dp[i] += dp[i - num];\\n            }\\n        }\\n        \\n        return dp[positive_set_sum];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/target-sum/\\n\\t\\n\\tThe given sets can be considered as P and N. where N contains the numbers of other set which are\\n\\tsubtracted.\\n\\tP - N = Target(T)\\n    P + N = S\\n\\t2P = T + S\\n\\tP = (T + S) / 2\\n\\t\\n\\t=> (T + S) should be even and P = (T + S)/2\\n*/\\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        int total = accumulate(nums.begin(), nums.end(), 0);\\n        // the sum of S and negative set should be even\\n        if(S > total || (S + total) % 2 != 0)\\n            return 0;\\n        \\n        int positive_set_sum = (S + total) / 2;\\n        \\n        // each entry i: num of ways in which sum i is possible using the given arrays elements \\n        vector<int> dp(positive_set_sum + 1, 0);\\n        // sum zero is always possible\\n        dp[0] = 1;\\n        \\n        for(const int& num: nums) {\\n            // starting from back to avoid addition of redundant terms with the \\n            // lower values when doing dp[i - num]\\n            for(int i = positive_set_sum; i >= num; i--) {\\n                dp[i] += dp[i - num];\\n            }\\n        }\\n        \\n        return dp[positive_set_sum];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 178696,
                "title": "c-99-knapsack-dp-easy-to-explain-and-impl-in-10mins-cheers",
                "content": "```\\n#include <vector>\\n#include <numeric>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        if (S > sum || S < -sum || S + sum < 0 || (S + sum) % 2 == 1) {\\n            return 0;\\n        }\\n\\n        int target = (S + sum) / 2;\\n        int n = nums.size();\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(target + 1, 0));\\n        dp[0][0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 0; j <= target; ++j) {\\n                dp[i][j] = dp[i - 1][j];\\n                if (nums[i - 1] <= j) {\\n                    dp[i][j] += dp[i - 1][j - nums[i - 1]];\\n                }\\n            }\\n        }\\n\\n        return dp[n][target];\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <vector>\\n#include <numeric>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        if (S > sum || S < -sum || S + sum < 0 || (S + sum) % 2 == 1) {\\n            return 0;\\n        }\\n\\n        int target = (S + sum) / 2;\\n        int n = nums.size();\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(target + 1, 0));\\n        dp[0][0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 0; j <= target; ++j) {\\n                dp[i][j] = dp[i - 1][j];\\n                if (nums[i - 1] <= j) {\\n                    dp[i][j] += dp[i - 1][j - nums[i - 1]];\\n                }\\n            }\\n        }\\n\\n        return dp[n][target];\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3115382,
                "title": "short-c-explained-solution-beginner-friendly-by-mr-coder",
                "content": "\\n# Approach\\n**Watch this video(in Hindi) for the better explanation of the code.**\\nhttps://youtu.be/znDh6ThMTpM\\n # SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the leetcode daily challange solution.\\n# If you find my solution helpful please upvote it.\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n     //s1-s2=target\\n     // s1+s2= total\\n     // count of target total+target/2\\n    int n, total=0,sum=0;\\n    n= nums.size();\\n    for(int i=0; i<n; i++)\\n    total+= nums[i];\\n\\nif(abs(target) > total ||(total+target)%2!=0)return 0;\\nsum= (total+target)/2;\\nint t[n+1][sum+1];\\nfor(int i=0; i<n+1; i++){\\n    for(int j=0; j<sum+1;j++){\\n       t[0][j]=0;\\n    }\\n}\\n\\nt[0][0]=1;\\n\\nfor(int i=1; i<n+1; i++){\\n    for(int j=0; j<sum+1;j++){\\n       if(nums[i-1]<=j) t[i][j]= t[i-1][j-nums[i-1]]+ t[i-1][j];\\n       else t[i][j]= t[i-1][j];\\n    }\\n}\\n\\nreturn t[n][sum];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n     //s1-s2=target\\n     // s1+s2= total\\n     // count of target total+target/2\\n    int n, total=0,sum=0;\\n    n= nums.size();\\n    for(int i=0; i<n; i++)\\n    total+= nums[i];\\n\\nif(abs(target) > total ||(total+target)%2!=0)return 0;\\nsum= (total+target)/2;\\nint t[n+1][sum+1];\\nfor(int i=0; i<n+1; i++){\\n    for(int j=0; j<sum+1;j++){\\n       t[0][j]=0;\\n    }\\n}\\n\\nt[0][0]=1;\\n\\nfor(int i=1; i<n+1; i++){\\n    for(int j=0; j<sum+1;j++){\\n       if(nums[i-1]<=j) t[i][j]= t[i-1][j-nums[i-1]]+ t[i-1][j];\\n       else t[i][j]= t[i-1][j];\\n    }\\n}\\n\\nreturn t[n][sum];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419132,
                "title": "easy-dp-memoization-tabulation-space-optimization-c",
                "content": "**Memoization (Accepted)**\\n```\\nint solve(int n,int target,vector<vector<int>>&dp,vector<int>&nums){\\n        if(n==0){\\n            if(target==0 and nums[0]==0) return 2;\\n            if(target==0 or target==nums[0]) return 1;\\n            return 0;\\n        }\\n        if(dp[n][target]!=-1) return dp[n][target];\\n        int np = solve(n-1,target,dp,nums);\\n        int p =0;\\n        if(target>=nums[n]) p = solve(n-1,target-nums[n],dp,nums);\\n        return dp[n][target] = p+np;\\n    }\\n    \\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n= nums.size();\\n        int sum=0;\\n        for(auto i:nums) sum+=i;\\n        if(sum-target < 0 or (sum-target)%2) return 0;\\n        vector<vector<int>>dp(n,vector<int>((sum-target)/2 +1, -1));\\n        return solve(n-1,(sum-target)/2,dp,nums);\\n    }\\n```\\n\\n**Tabulation (Accepted)**\\n```\\nint findTargetSumWays(vector<int>& nums, int target) {\\n        int n= nums.size();\\n        int sum=0;\\n        for(auto i:nums) sum+=i;\\n        if(sum-target < 0 or (sum-target)%2) return 0;\\n        int tar = (sum-target)/2;\\n        vector<vector<int>>dp(n,vector<int>(tar+1, 0));\\n        if(nums[0]==0) dp[0][0] = 2;\\n        else dp[0][0]=1;\\n        if(nums[0]!=0 and tar>=nums[0]) dp[0][nums[0]] =1;\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<=tar;j++){\\n                int np = dp[i-1][j];\\n                int p = 0;\\n                if(j>=nums[i]) p = dp[i-1][j-nums[i]];\\n                dp[i][j] = p+np;\\n            }\\n        }\\n        return dp[n-1][tar];\\n    }\\n```\\n\\n**Space Optimization**\\n```\\nint findTargetSumWays(vector<int>& nums, int target) {\\n        int n= nums.size();\\n        int sum=0;\\n        for(auto i:nums) sum+=i;\\n        if(sum-target < 0 or (sum-target)%2) return 0;\\n        int tar = (sum-target)/2;\\n        \\n        vector<int> dp(tar+1, 0) , curr(tar+1,0);\\n        if(nums[0]==0) dp[0] = 2;\\n        else dp[0]=1;\\n        if(nums[0]!=0 and tar>=nums[0]) dp[nums[0]] =1;\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<=tar;j++){\\n                int np = dp[j];\\n                int p = 0;\\n                if(j>=nums[i]) p = dp[j-nums[i]];\\n                curr[j] = p+np;\\n            }\\n            dp = curr;\\n        }\\n        return dp[tar];\\n    }\\n```\\n\\n**Do upvote if you like the solution from Memoization --> Tabulation --> Space Optimization.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint solve(int n,int target,vector<vector<int>>&dp,vector<int>&nums){\\n        if(n==0){\\n            if(target==0 and nums[0]==0) return 2;\\n            if(target==0 or target==nums[0]) return 1;\\n            return 0;\\n        }\\n        if(dp[n][target]!=-1) return dp[n][target];\\n        int np = solve(n-1,target,dp,nums);\\n        int p =0;\\n        if(target>=nums[n]) p = solve(n-1,target-nums[n],dp,nums);\\n        return dp[n][target] = p+np;\\n    }\\n    \\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n= nums.size();\\n        int sum=0;\\n        for(auto i:nums) sum+=i;\\n        if(sum-target < 0 or (sum-target)%2) return 0;\\n        vector<vector<int>>dp(n,vector<int>((sum-target)/2 +1, -1));\\n        return solve(n-1,(sum-target)/2,dp,nums);\\n    }\\n```\n```\\nint findTargetSumWays(vector<int>& nums, int target) {\\n        int n= nums.size();\\n        int sum=0;\\n        for(auto i:nums) sum+=i;\\n        if(sum-target < 0 or (sum-target)%2) return 0;\\n        int tar = (sum-target)/2;\\n        vector<vector<int>>dp(n,vector<int>(tar+1, 0));\\n        if(nums[0]==0) dp[0][0] = 2;\\n        else dp[0][0]=1;\\n        if(nums[0]!=0 and tar>=nums[0]) dp[0][nums[0]] =1;\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<=tar;j++){\\n                int np = dp[i-1][j];\\n                int p = 0;\\n                if(j>=nums[i]) p = dp[i-1][j-nums[i]];\\n                dp[i][j] = p+np;\\n            }\\n        }\\n        return dp[n-1][tar];\\n    }\\n```\n```\\nint findTargetSumWays(vector<int>& nums, int target) {\\n        int n= nums.size();\\n        int sum=0;\\n        for(auto i:nums) sum+=i;\\n        if(sum-target < 0 or (sum-target)%2) return 0;\\n        int tar = (sum-target)/2;\\n        \\n        vector<int> dp(tar+1, 0) , curr(tar+1,0);\\n        if(nums[0]==0) dp[0] = 2;\\n        else dp[0]=1;\\n        if(nums[0]!=0 and tar>=nums[0]) dp[nums[0]] =1;\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<=tar;j++){\\n                int np = dp[j];\\n                int p = 0;\\n                if(j>=nums[i]) p = dp[j-nums[i]];\\n                curr[j] = p+np;\\n            }\\n            dp = curr;\\n        }\\n        return dp[tar];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935115,
                "title": "c-easy-just-leave-everything-on-recursion",
                "content": "In this question we used dp beacuse of two intuitions :\\n1.Constraints are of very small size and sum of nums[i] is <=1000 means we can accomodate it in array\\n2.We have to check all the possible solutions means we have to use recursion for sure and as we can see there are repeated cases as we have limited options just + and - .\\n\\nSO We just talk to our friend Recursion that hey rec. listen jsut start from 0th index and tell me the number possible solutions if we would have target t and array starting from ith index ,and then tell the recursion where to stop (eg: at i==nums.length) and then we make an map who checks that if we have solved it before or not if not then we just asks recursion that tell the answer for t-nums[i] and t+nums[i] and add them and return .\\n**Isn\\'t recursion  a good friend just simply do all work on his own ?** **ain?**\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> m;\\n    int rec(vector<int> & nums,int t,int i)\\n    {\\n        if(i>=nums.size())\\n        {\\n            if(t==0)\\n            return 1;\\n            else\\n                return 0;\\n        }\\n        \\n        if(m.find({i,t})!=m.end())\\n        {\\n            return m[{i,t}];\\n        }\\n        return m[{i,t}]=rec(nums,t-nums[i],i+1)+rec(nums,t+nums[i],i+1);\\n        \\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        return rec(nums,target,0);\\n    }\\n};\\n```\\nUpvote is good thing to do xo:)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> m;\\n    int rec(vector<int> & nums,int t,int i)\\n    {\\n        if(i>=nums.size())\\n        {\\n            if(t==0)\\n            return 1;\\n            else\\n                return 0;\\n        }\\n        \\n        if(m.find({i,t})!=m.end())\\n        {\\n            return m[{i,t}];\\n        }\\n        return m[{i,t}]=rec(nums,t-nums[i],i+1)+rec(nums,t+nums[i],i+1);\\n        \\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        return rec(nums,target,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575605,
                "title": "knapsack-why-j-loop-starts-from-0",
                "content": "```\\n int number_subsets(vector<int>& nums, int sum){\\n        int n = nums.size();\\n        int dp[n+1][sum+1];\\n        \\n        for(int i = 0; i<=n; i++){\\n            for(int j = 0; j<=sum; j++){\\n                if(i == 0) dp[i][j] = 0;\\n                if(j == 0) dp[i][j] = 1;\\n            }\\n        }\\n        \\n        for(int i = 1; i<=n; i++){\\n            for(int j = 0; j<=sum; j++){  \\n                if(nums[i-1]<=j ) dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];\\n                else if(nums[i-1]>j) dp[i][j]  = dp[i-1][j];\\n            }\\n        }\\n        \\n        return dp[n][sum];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n     \\n        int range = 0; \\n        for(auto x : nums) range += x;\\n        target = abs(target);\\n        if(target>range or (target+range)%2 != 0) return 0;\\n        \\n        return number_subsets(nums,(target+range)/2);\\n        \\n    }\\n```\\n\\nj loop starts from 0 because, 0 can be used to form subsets too.\\nLet us take an example to understand:\\narr : [0,0] target: 0 => (target+range)/2 = 0\\nWe can have 4 subsets here {0}(1st),{0}(2nd),{0,0},{}\\nBut if we start the jth loop from 1 instead of 0 we would just get 1 subset, ie, the empty subset {} (based on our initialization)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n int number_subsets(vector<int>& nums, int sum){\\n        int n = nums.size();\\n        int dp[n+1][sum+1];\\n        \\n        for(int i = 0; i<=n; i++){\\n            for(int j = 0; j<=sum; j++){\\n                if(i == 0) dp[i][j] = 0;\\n                if(j == 0) dp[i][j] = 1;\\n            }\\n        }\\n        \\n        for(int i = 1; i<=n; i++){\\n            for(int j = 0; j<=sum; j++){  \\n                if(nums[i-1]<=j ) dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];\\n                else if(nums[i-1]>j) dp[i][j]  = dp[i-1][j];\\n            }\\n        }\\n        \\n        return dp[n][sum];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n     \\n        int range = 0; \\n        for(auto x : nums) range += x;\\n        target = abs(target);\\n        if(target>range or (target+range)%2 != 0) return 0;\\n        \\n        return number_subsets(nums,(target+range)/2);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 986790,
                "title": "c-dynamic-programming-solutions-top-down-bottom-up",
                "content": "### Top-down Solution\\n- The main idea is to iterate through each number in the array, and assign it either a \\'+\\' or a \\'-\\' sign.\\n- We also maintain a 2d table `memo` to avoid duplicate calculation. Each row of the table represents the current index of the number in the array, while the column represents the current sum so far. \\n- An `unordered_map` is used because it is possible the current sum so far is negative.\\n\\n```c++\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        vector<unordered_map<int, int>> memo(nums.size());\\n        return findTargetSumWaysRecursive(nums, memo, 0, 0, S);\\n    }\\nprivate:\\n    int findTargetSumWaysRecursive(const vector<int> &nums, vector<unordered_map<int, int>> &memo, int currIndex, int currSum, int targetSum) {\\n        if (currIndex == static_cast<int>(nums.size())) {\\n            return currSum == targetSum ? 1 : 0;\\n        }\\n\\n        if (!memo[currIndex].count(currSum)) {\\n            int pos = findTargetSumWaysRecursive(nums, memo, currIndex + 1, currSum + nums[currIndex], targetSum);\\n            int neg = findTargetSumWaysRecursive(nums, memo, currIndex + 1, currSum - nums[currIndex], targetSum);\\n            memo[currIndex][currSum] = pos + neg;\\n        }\\n        return memo[currIndex][currSum];\\n    }\\n};\\n```\\n\\n#### Bottom-up Solution\\n##### Algorithm\\n- This solution is hard to come up with on spot and requires a bit imagination. We can actually turn this problem into counting how many subsets equal to a specific sum.\\n- We are actually asked find two subsets of the given numbers, and their difference is equal to `S`. Therefore, we have `s1 - s2 = S`. Since `s1` and `s2` adds up to the original array, we also have `s1 + s2 = sum`.\\n- After adding up these two equations, we get `2s1 = S + sum`, so we know that `s1 = (S + sum) / 2`.\\n- Therefore, we\\'ve now successfully converted this problem to find how many subsets are there in the array whose sum is `(S + sum) / 2`. We can see that if `(S + sum) / 2` is an odd number, there will be no qualified subsets.\\n##### Notes\\n- We use a 2d array here to build our bottom-up solution, and `dp[i][s]` means how many subsets are there can add up to `s`, given the first `i` numbers.\\n- We need to be very careful with the base cases. When the sum is equal to 0 and the number at index 0 is not equal to 0, then we can simply just exclude this number, and there will only be 1 qualified subset(empty set). However, when the number at index 0\\'s value is 0, there will be actually 2 subsets that meet the requirement. You either exclude this number like we did before, or include it. \\n```c++\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        int sum = 0;\\n        for (int num : nums) {\\n            sum += num;\\n        }\\n        if (sum < S || (sum + S) % 2 != 0) {\\n            return 0;\\n        }\\n        int target = (sum + S) / 2;\\n        vector<vector<int>> dp(nums.size(), vector<int>(target + 1, 0));\\n        dp[0][0] = nums[0] == 0 ? 2 : 1;\\n        for (int s = 1; s <= target; ++s) {\\n            dp[0][s] = nums[0] == s ? 1 : 0;\\n        }\\n        for (int i = 1; i < nums.size(); ++i) {\\n            for (int s = 0; s <= target; ++s) {\\n                dp[i][s] = dp[i - 1][s];\\n                if (nums[i] <= s) {\\n                    dp[i][s] += dp[i - 1][s - nums[i]];\\n                }\\n            }\\n        }\\n        return dp[nums.size() - 1][target];\\n    }\\n};\\n```\\n##### Space Optimization\\n- Notice that we only need previous row\\'s information when calculate for a new row. Therefore, we can compress the 2d array into 1d array.\\n- We need to change the inner loop to make it traverse in the reverse direction. Otherwise, when we\\'re updating the array, the value that we override might be needed for the calculation later.\\n```c++\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        int sum = 0;\\n        for (int num : nums) {\\n            sum += num;\\n        }\\n        if (sum < S || (sum + S) % 2 != 0) {\\n            return 0;\\n        }\\n        int target = (sum + S) / 2;\\n        vector<int> dp(target + 1, 0);\\n        dp[0] = nums[0] == 0 ? 2 : 1;\\n        for (int s = 1; s <= target; ++s) {\\n            dp[s] = nums[0] == s ? 1 : 0;\\n        }\\n        for (int i = 1; i < nums.size(); ++i) {\\n            for (int s = target; s >= 0; --s) {\\n                if (nums[i] <= s) {\\n                    dp[s] += dp[s - nums[i]];\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        vector<unordered_map<int, int>> memo(nums.size());\\n        return findTargetSumWaysRecursive(nums, memo, 0, 0, S);\\n    }\\nprivate:\\n    int findTargetSumWaysRecursive(const vector<int> &nums, vector<unordered_map<int, int>> &memo, int currIndex, int currSum, int targetSum) {\\n        if (currIndex == static_cast<int>(nums.size())) {\\n            return currSum == targetSum ? 1 : 0;\\n        }\\n\\n        if (!memo[currIndex].count(currSum)) {\\n            int pos = findTargetSumWaysRecursive(nums, memo, currIndex + 1, currSum + nums[currIndex], targetSum);\\n            int neg = findTargetSumWaysRecursive(nums, memo, currIndex + 1, currSum - nums[currIndex], targetSum);\\n            memo[currIndex][currSum] = pos + neg;\\n        }\\n        return memo[currIndex][currSum];\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        int sum = 0;\\n        for (int num : nums) {\\n            sum += num;\\n        }\\n        if (sum < S || (sum + S) % 2 != 0) {\\n            return 0;\\n        }\\n        int target = (sum + S) / 2;\\n        vector<vector<int>> dp(nums.size(), vector<int>(target + 1, 0));\\n        dp[0][0] = nums[0] == 0 ? 2 : 1;\\n        for (int s = 1; s <= target; ++s) {\\n            dp[0][s] = nums[0] == s ? 1 : 0;\\n        }\\n        for (int i = 1; i < nums.size(); ++i) {\\n            for (int s = 0; s <= target; ++s) {\\n                dp[i][s] = dp[i - 1][s];\\n                if (nums[i] <= s) {\\n                    dp[i][s] += dp[i - 1][s - nums[i]];\\n                }\\n            }\\n        }\\n        return dp[nums.size() - 1][target];\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        int sum = 0;\\n        for (int num : nums) {\\n            sum += num;\\n        }\\n        if (sum < S || (sum + S) % 2 != 0) {\\n            return 0;\\n        }\\n        int target = (sum + S) / 2;\\n        vector<int> dp(target + 1, 0);\\n        dp[0] = nums[0] == 0 ? 2 : 1;\\n        for (int s = 1; s <= target; ++s) {\\n            dp[s] = nums[0] == s ? 1 : 0;\\n        }\\n        for (int i = 1; i < nums.size(); ++i) {\\n            for (int s = target; s >= 0; --s) {\\n                if (nums[i] <= s) {\\n                    dp[s] += dp[s - nums[i]];\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801164,
                "title": "c-double-dfs-approach-explained-60-time-50-space",
                "content": "For most of the logic of this solution, please refern to [my original topic](https://leetcode.com/problems/target-sum/discuss/794750/).\\n\\nThe one change I implemented here is **to start DFSing from both the beginning and the end of the graph**. I woke up 1-2 days after solving this problem remembering how LinkedIn provides you info on your connection: getting info up to the 3rd degree connection would be crazy expensive.\\n\\nTo solve this problem, they cache (or used to cache, last time I read about it) all your direct connections, then when you open a profile they check: if it is one of them, it is a first degree; if that person\\'s network and yours have at least one third profile in common, then he is a second degree. All the rest appears as \"3rd+\", with little surprise.\\n\\nAnd I took the same approach here: I do half of the range of possible combinations starting from the bottom and then storing the results in a `unordered_map` of values and relative frequence (a good amount of values can appear more than once). Then I still do the first half of the numbers as I did in my previous solution (see link above).\\n\\nAt the end of each run for the first half, I check if I have a value equal to `target - sum`, which is of course exactly what I am missing in order to go up to `target` and, if I have such a result stored, I increase `res` by its frequence (ie: how many times I could come up with that partial sum).\\n\\nDoes it seems like a needless complication?\\n\\nWell, think about it: our longest series of number can be `20`, which means my single DFS approach might (ignoring the other optimisations I did, like using `limits` to avoid wasted computation) run up to about `pow(2, 20)` times; that is more than a million operations.\\n\\nNow, with my newer approach, I can run at worst `pow(2, 10) + pow(2, 10)` times. That\\'s about `2000` operations.\\n\\nOf course, my logic might add some overhead and not all the tests will run with the maximum of 20 numbers to check.\\n\\nStill I move from over 700ms to consistently less than 50ms: not too shabby, even considering I am well aware I am trading some space for extra speed :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int res = 0, target, sum = 0, half;\\n    int limits[21] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\\n    unordered_map<int, int> possibleOutcomes;\\n    void dfs(vector<int>& nums, int pos = 0) {\\n        // checking if we finished using all numbers on this branch\\n        if (pos == half) {\\n            // and in case we might arrive there, we increment res\\n            if (possibleOutcomes.find(target - sum) != end(possibleOutcomes)) res += possibleOutcomes[target - sum];\\n            return;\\n        }\\n        // dropping the DFS when it makes no sense to continue\\n        if (abs(target - sum) > limits[pos]) return;\\n        // trying with minus first\\n        sum -= nums[pos];\\n        dfs(nums, pos + 1);\\n        // backtracking and trying with plus\\n        sum += nums[pos] * 2;\\n        dfs(nums, pos + 1);\\n        // backtracking - resetting sum to the initial value\\n        sum -= nums[pos];\\n    }\\n    void dfsOutcomes(vector<int>& nums, int pos) {\\n        if (pos < half) {\\n            possibleOutcomes[sum]++;\\n            return;\\n        }\\n        // similar logic to the main dfs call\\n        sum -= nums[pos];\\n        dfsOutcomes(nums, pos - 1);\\n        // backtracking and trying with plus\\n        sum += nums[pos] * 2;\\n        dfsOutcomes(nums, pos - 1);\\n        sum -= nums[pos];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int s) {\\n        half = (nums.size() + 1) / 2;\\n        target = s;\\n        for (int i = nums.size() - 1; i >= 0; i--) limits[i] = limits[i + 1] + nums[i];\\n        dfsOutcomes(nums, nums.size() - 1);\\n        dfs(nums);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int res = 0, target, sum = 0, half;\\n    int limits[21] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\\n    unordered_map<int, int> possibleOutcomes;\\n    void dfs(vector<int>& nums, int pos = 0) {\\n        // checking if we finished using all numbers on this branch\\n        if (pos == half) {\\n            // and in case we might arrive there, we increment res\\n            if (possibleOutcomes.find(target - sum) != end(possibleOutcomes)) res += possibleOutcomes[target - sum];\\n            return;\\n        }\\n        // dropping the DFS when it makes no sense to continue\\n        if (abs(target - sum) > limits[pos]) return;\\n        // trying with minus first\\n        sum -= nums[pos];\\n        dfs(nums, pos + 1);\\n        // backtracking and trying with plus\\n        sum += nums[pos] * 2;\\n        dfs(nums, pos + 1);\\n        // backtracking - resetting sum to the initial value\\n        sum -= nums[pos];\\n    }\\n    void dfsOutcomes(vector<int>& nums, int pos) {\\n        if (pos < half) {\\n            possibleOutcomes[sum]++;\\n            return;\\n        }\\n        // similar logic to the main dfs call\\n        sum -= nums[pos];\\n        dfsOutcomes(nums, pos - 1);\\n        // backtracking and trying with plus\\n        sum += nums[pos] * 2;\\n        dfsOutcomes(nums, pos - 1);\\n        sum -= nums[pos];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int s) {\\n        half = (nums.size() + 1) / 2;\\n        target = s;\\n        for (int i = nums.size() - 1; i >= 0; i--) limits[i] = limits[i + 1] + nums[i];\\n        dfsOutcomes(nums, nums.size() - 1);\\n        dfs(nums);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762108,
                "title": "java-dp-memoization-map-array-for-noobs-whiteboarding",
                "content": "Posting it here my Java version from the explanatory post of @teampark \\nhttps://leetcode.com/problems/target-sum/discuss/455024/DP-IS-EASY!-5-Steps-to-Think-Through-DP-Questions.\\n\\n![image](https://assets.leetcode.com/users/images/adc0b33f-96ab-4a99-8308-de2eebb74fa5_1596029761.0678904.png)\\n\\nWith 2D Array Implementation \\n``` \\npublic int findTargetSumWays(int[] nums, int S) {\\n        if(nums==null || nums.length==0)\\n            return 0;\\n        int[][] dp=new int[nums.length][2001];\\n        for(int[] fill:dp)\\n            Arrays.fill(fill,Integer.MIN_VALUE);\\n        return dfs(nums,S,0,0,dp);\\n    }\\n    public int dfs(int[] nums,int S,int index,int sum,int[][] dp){\\n        if(index==nums.length){\\n            if(sum==S){\\n                return 1;\\n            }else\\n                return 0;\\n        } \\n        if(dp[index][sum+1000]!=Integer.MIN_VALUE)\\n            return dp[index][sum+1000];\\n        int pos=dfs(nums,S,index+1,sum+nums[index],dp);\\n        int neg=dfs(nums,S,index+1,sum-nums[index],dp);\\n        dp[index][sum+1000]=pos+neg;\\n        return pos+neg;\\n                \\n    }\\n````\\nWith Map Implementation (Takes more time because of String manipulation/concatenation/search)\\n```\\npublic int findTargetSumWays(int[] nums, int S) {\\n        if(nums==null || nums.length==0)\\n            return 0;\\n        return dfs(nums,S,0,0,new HashMap<>());\\n    }\\n    public int dfs(int[] nums,int S,int index,int sum,Map<String,Integer> map){\\n        if(index==nums.length){\\n            if(sum==S){\\n                return 1;\\n            }else\\n                return 0;\\n        } \\n        String key=index+\"->\"+sum;\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        int pos=dfs(nums,S,index+1,sum+nums[index],map);\\n        int neg=dfs(nums,S,index+1,sum-nums[index],map);\\n        map.put(key,pos+neg);\\n        return pos+neg;\\n                \\n    }\\t",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "``` \\npublic int findTargetSumWays(int[] nums, int S) {\\n        if(nums==null || nums.length==0)\\n            return 0;\\n        int[][] dp=new int[nums.length][2001];\\n        for(int[] fill:dp)\\n            Arrays.fill(fill,Integer.MIN_VALUE);\\n        return dfs(nums,S,0,0,dp);\\n    }\\n    public int dfs(int[] nums,int S,int index,int sum,int[][] dp){\\n        if(index==nums.length){\\n            if(sum==S){\\n                return 1;\\n            }else\\n                return 0;\\n        } \\n        if(dp[index][sum+1000]!=Integer.MIN_VALUE)\\n            return dp[index][sum+1000];\\n        int pos=dfs(nums,S,index+1,sum+nums[index],dp);\\n        int neg=dfs(nums,S,index+1,sum-nums[index],dp);\\n        dp[index][sum+1000]=pos+neg;\\n        return pos+neg;\\n                \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 97365,
                "title": "simple-dfs-solution",
                "content": "Simple dfs solution.\\nbranch to plus and minus, when index hits the end of array return 1 when the target is zero (found), otherwise 0 (not found).\\n```\\npublic int findTargetSumWays(int[] nums, int S) {\\n        return helper(nums, 0, S);\\n    }\\n    \\n    private int helper(int[] nums, int idx, int S) {\\n        if (idx == nums.length) {\\n            return S == 0 ? 1 : 0;\\n        }\\n        \\n        int plus = helper(nums, idx+1, S+nums[idx]);\\n        int minus = helper(nums, idx+1, S-nums[idx]);\\n        \\n        return plus + minus;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findTargetSumWays(int[] nums, int S) {\\n        return helper(nums, 0, S);\\n    }\\n    \\n    private int helper(int[] nums, int idx, int S) {\\n        if (idx == nums.length) {\\n            return S == 0 ? 1 : 0;\\n        }\\n        \\n        int plus = helper(nums, idx+1, S+nums[idx]);\\n        int minus = helper(nums, idx+1, S-nums[idx]);\\n        \\n        return plus + minus;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 97423,
                "title": "python-time-limit-exceed",
                "content": "\\n    def findTargetSumWays(self, nums, S):\\n        if not nums:\\n            return 0\\n        return helper(nums,0,0,S,len(nums))\\n\\n    def helper(nums,now,p,t,l):\\n        print(now,t)\\n        if p == l:\\n            if now == t:\\n                return 1\\n            return 0\\n\\n        return helper(nums,now + int(nums[p]),p+1,t,l) + helper(nums,now - int(nums[p]),p+1,t,l)\\n\\nCan admin change time limit for python in these question. the alg works in other languages but shows time limit exceed.",
                "solutionTags": [],
                "code": "\\n    def findTargetSumWays(self, nums, S):\\n        if not nums:\\n            return 0\\n        return helper(nums,0,0,S,len(nums))\\n\\n    def helper(nums,now,p,t,l):\\n        print(now,t)\\n        if p == l:\\n            if now == t:\\n                return 1\\n            return 0\\n\\n        return helper(nums,now + int(nums[p]),p+1,t,l) + helper(nums,now - int(nums[p]),p+1,t,l)\\n\\nCan admin change time limit for python in these question. the alg works in other languages but shows time limit exceed.",
                "codeTag": "Python3"
            },
            {
                "id": 3218461,
                "title": "most-easiest-way-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int> &nums,int target,int ans,int index)\\n    {\\n        if(index==nums.size()&&ans==target)\\n          return 1;\\n        if(index>=nums.size())\\n          return 0;\\n\\n        return solve(nums,target,ans+nums[index],index+1)+solve(nums,target,ans-nums[index],index+1);\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int ans=0,i=0;\\n        return solve(nums,target,ans,i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int> &nums,int target,int ans,int index)\\n    {\\n        if(index==nums.size()&&ans==target)\\n          return 1;\\n        if(index>=nums.size())\\n          return 0;\\n\\n        return solve(nums,target,ans+nums[index],index+1)+solve(nums,target,ans-nums[index],index+1);\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int ans=0,i=0;\\n        return solve(nums,target,ans,i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799317,
                "title": "c-dp-memoize-negative-indexes-with-an-offset",
                "content": "In memoization, we have only one **problem**, that we *can\\'t use -ve sum as indexes* of DP array\\n\\nso, as given in the constraints, max sum value is 1000, so after, 1000, we can use dp array for negative indexes, by **adding an offset** of 2001 (1000 + 1001) to it.\\n```\\nclass Solution {\\nprivate:\\n    int dp[21][2001];\\n    int ways(vector<int>& arr, int target, int i, int sum) {\\n        if(i == arr.size())\\n            return (target == sum) ? 1 : 0;\\n        \\n        if(sum < 0) // -ve index offset as, 0 <= sum(nums[i]) <= 1000, so, at max -1 + 2001 = 2000\\n            if(dp[i][sum + 2001] != -1)\\n                return dp[i][sum + 2001];\\n\\n        else if(sum >= 0)\\n            if(dp[i][sum] != -1)\\n                return dp[i][sum];\\n        \\n        int addIt = ways(arr, target, i + 1, sum + arr[i]);\\n        int subtractIt = ways(arr, target, i + 1, sum - arr[i]);\\n \\n        return (sum < 0) ?\\n            dp[i][sum + 2001] = addIt + subtractIt :\\n            dp[i][sum] = addIt + subtractIt;\\n    }\\n\\npublic:\\n    int findTargetSumWays(vector<int>& arr, int target) {\\n        memset(dp, -1, sizeof(dp));\\n        return ways(arr, target, 0, 0);\\n    }\\n};\\n```\\nIf you have any doubts, please *feel free to ask in the comments* :) \\uD83D\\uDE00\\n**Please UpVote, if it\\'s Helpful :)** \\uD83D\\uDE07",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dp[21][2001];\\n    int ways(vector<int>& arr, int target, int i, int sum) {\\n        if(i == arr.size())\\n            return (target == sum) ? 1 : 0;\\n        \\n        if(sum < 0) // -ve index offset as, 0 <= sum(nums[i]) <= 1000, so, at max -1 + 2001 = 2000\\n            if(dp[i][sum + 2001] != -1)\\n                return dp[i][sum + 2001];\\n\\n        else if(sum >= 0)\\n            if(dp[i][sum] != -1)\\n                return dp[i][sum];\\n        \\n        int addIt = ways(arr, target, i + 1, sum + arr[i]);\\n        int subtractIt = ways(arr, target, i + 1, sum - arr[i]);\\n \\n        return (sum < 0) ?\\n            dp[i][sum + 2001] = addIt + subtractIt :\\n            dp[i][sum] = addIt + subtractIt;\\n    }\\n\\npublic:\\n    int findTargetSumWays(vector<int>& arr, int target) {\\n        memset(dp, -1, sizeof(dp));\\n        return ways(arr, target, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628944,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\n---\\n\\n**Top-Down**\\n\\nThere are 2 possibilites for each `A[i]`<sup>th</sup> value:\\n\\n1. `+A[i]`\\n2. `-A[i]`\\n\\nKeep track of the current `i`<sup>th</sup> element and the total `t` accumulated thus far.\\n\\n**Base case:** Upon exhausting the input array `A` elements from `i = 0..N-1` we return `1` if and only if the total `t` accumulated is equal to the target `T` sum.\\n\\n**Recurrence relation:** with each current `i`<sup>th</sup> element of `A` we consider the 2 possibilities of adding `A[i]` or subtracting `A[i]` from the total `t`.\\n\\n---\\n\\n**Bottom-Up**\\n\\nSince we want to track negative totals from the bottom-up, we could offset all values by `1000`, so we store the total `-1000` at index `0` and we store the total `1000` at index `2000`, etc.  However, it is more simple to use a map to store the previous `pre` and current `cur` reachable totals along with those totals\\' associated counts, ie. how many times can we reach each total.\\n\\n**Base case:** initially there exists `1` way to reach the total `0`, ie. that\\'s where we start\\n\\n**Recurrence relation:** for each previous `pre` reachable total `t` and count `cnt`, accumulate current `cur` reachable total\\'s `t` counts by adding onto each previous count the 2 possibilities for each `i`<sup>th</sup> element `x` of the input array `A`:\\n\\n1. the previous total `t` **plus** `x`, ie. current total `t + x`\\n2. the previous total `t` **minus** `x`, ie. current total `t - x`\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun findTargetSumWays(A: IntArray, T: Int): Int {\\n        var N = A.size\\n        fun go(i: Int = 0, t: Int = 0): Int {\\n            if (i == N)\\n                return if (t == T) 1 else 0\\n            return go(i + 1, t + A[i]) + go(i + 1, t - A[i])\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun findTargetSumWays(A: IntArray, T: Int): Int {\\n        var N = A.size\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, t: Int = 0): Int {\\n            if (i == N)\\n                return if (t == T) 1 else 0\\n            var k = \"$i,$t\"\\n            if (!m.contains(k))\\n                m[k] = go(i + 1, t + A[i]) + go(i + 1, t - A[i])\\n            return m[k]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun findTargetSumWays(A: IntArray, T: Int): Int {\\n        var pre = mutableMapOf<Int, Int>()\\n        pre[0] = 1\\n        for (x in A) {\\n            var cur = mutableMapOf<Int, Int>()\\n            for ((t, cnt) in pre) {\\n                cur[t + x] = cnt + (cur[t + x] ?: 0)!!\\n                cur[t - x] = cnt + (cur[t - x] ?: 0)!!\\n            }\\n            pre = cur\\n        }\\n        return (pre[T] ?: 0)!!\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet findTargetSumWays = (A, T) => {\\n    let N = A.length;\\n    let go = (i = 0, t = 0) => {\\n        if (i == N)\\n            return Number(t == T);\\n        return go(i + 1, t + A[i]) + go(i + 1, t - A[i]);\\n    };\\n    return go()\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet findTargetSumWays = (A, T, m = new Map()) => {\\n    let N = A.length;\\n    let go = (i = 0, t = 0) => {\\n        if (i == N)\\n            return Number(t == T);\\n        let k = `${i},${t}`;\\n        if (!m.has(k))\\n            m.set(k, go(i + 1, t + A[i]) + go(i + 1, t - A[i]));\\n        return m.get(k);\\n    };\\n    return go()\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet findTargetSumWays = (A, T) => {\\n    let pre = new Map([[0, 1]]);\\n    for (let x of A) {\\n        let cur = new Map();\\n        for (let [t, cnt] of pre) {\\n            cur.set(t + x, cnt + (cur.get(t + x) || 0));\\n            cur.set(t - x, cnt + (cur.get(t - x) || 0));\\n        }\\n        pre = cur;\\n    }\\n    return pre.get(T) || 0;\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def findTargetSumWays(self, A: List[int], T: int) -> int:\\n        N = len(A)\\n        def go(i = 0, t = 0):\\n            if i == N:\\n                return int(t == T)\\n            return go(i + 1, t + A[i]) + go(i + 1, t - A[i])\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def findTargetSumWays(self, A: List[int], T: int) -> int:\\n        N = len(A)\\n        @cache\\n        def go(i = 0, t = 0):\\n            if i == N:\\n                return int(t == T)\\n            return go(i + 1, t + A[i]) + go(i + 1, t - A[i])\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def findTargetSumWays(self, A: List[int], T: int) -> int:\\n        pre = {}\\n        pre[0] = 1\\n        for x in A:\\n            cur = {}\\n            for t, cnt in pre.items():\\n                cur[t + x] = cnt + (cur[t + x] if t + x in cur else 0)\\n                cur[t - x] = cnt + (cur[t - x] if t - x in cur else 0)\\n            pre = cur\\n        return pre[T] if T in pre else 0\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int findTargetSumWays(VI& A, int T) {\\n        int N = A.size();\\n        fun go = [&](auto i, auto t) {\\n            if (i == N)\\n                return int(t == T);\\n            return go(i + 1, t + A[i])\\n                 + go(i + 1, t - A[i]);\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int findTargetSumWays(VI& A, int T, Map m = {}) {\\n        int N = A.size();\\n        auto key = [](auto i, auto t) {\\n            stringstream ss; ss << i << \",\" << t;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto t) {\\n            if (i == N)\\n                return int(t == T);\\n            auto k = key(i, t);\\n            if (m.find(k) == m.end()) {\\n                m[k] = go(i + 1, t + A[i])\\n                     + go(i + 1, t - A[i]);\\n            }\\n            return m[k];\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    int findTargetSumWays(VI& A, int T) {\\n        Map pre;\\n        pre[0] = 1;  // 1 way to start with total 0\\n        for (auto x: A) {\\n            Map cur;\\n            for (auto [t, cnt]: pre)\\n                cur[t + x] += cnt,\\n                cur[t - x] += cnt;\\n            swap(pre, cur);\\n        }\\n        return pre[T];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun findTargetSumWays(A: IntArray, T: Int): Int {\\n        var N = A.size\\n        fun go(i: Int = 0, t: Int = 0): Int {\\n            if (i == N)\\n                return if (t == T) 1 else 0\\n            return go(i + 1, t + A[i]) + go(i + 1, t - A[i])\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun findTargetSumWays(A: IntArray, T: Int): Int {\\n        var N = A.size\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, t: Int = 0): Int {\\n            if (i == N)\\n                return if (t == T) 1 else 0\\n            var k = \"$i,$t\"\\n            if (!m.contains(k))\\n                m[k] = go(i + 1, t + A[i]) + go(i + 1, t - A[i])\\n            return m[k]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun findTargetSumWays(A: IntArray, T: Int): Int {\\n        var pre = mutableMapOf<Int, Int>()\\n        pre[0] = 1\\n        for (x in A) {\\n            var cur = mutableMapOf<Int, Int>()\\n            for ((t, cnt) in pre) {\\n                cur[t + x] = cnt + (cur[t + x] ?: 0)!!\\n                cur[t - x] = cnt + (cur[t - x] ?: 0)!!\\n            }\\n            pre = cur\\n        }\\n        return (pre[T] ?: 0)!!\\n    }\\n}\\n```\n```\\nlet findTargetSumWays = (A, T) => {\\n    let N = A.length;\\n    let go = (i = 0, t = 0) => {\\n        if (i == N)\\n            return Number(t == T);\\n        return go(i + 1, t + A[i]) + go(i + 1, t - A[i]);\\n    };\\n    return go()\\n};\\n```\n```\\nlet findTargetSumWays = (A, T, m = new Map()) => {\\n    let N = A.length;\\n    let go = (i = 0, t = 0) => {\\n        if (i == N)\\n            return Number(t == T);\\n        let k = `${i},${t}`;\\n        if (!m.has(k))\\n            m.set(k, go(i + 1, t + A[i]) + go(i + 1, t - A[i]));\\n        return m.get(k);\\n    };\\n    return go()\\n};\\n```\n```\\nlet findTargetSumWays = (A, T) => {\\n    let pre = new Map([[0, 1]]);\\n    for (let x of A) {\\n        let cur = new Map();\\n        for (let [t, cnt] of pre) {\\n            cur.set(t + x, cnt + (cur.get(t + x) || 0));\\n            cur.set(t - x, cnt + (cur.get(t - x) || 0));\\n        }\\n        pre = cur;\\n    }\\n    return pre.get(T) || 0;\\n};\\n```\n```\\nclass Solution:\\n    def findTargetSumWays(self, A: List[int], T: int) -> int:\\n        N = len(A)\\n        def go(i = 0, t = 0):\\n            if i == N:\\n                return int(t == T)\\n            return go(i + 1, t + A[i]) + go(i + 1, t - A[i])\\n        return go()\\n```\n```\\nclass Solution:\\n    def findTargetSumWays(self, A: List[int], T: int) -> int:\\n        N = len(A)\\n        @cache\\n        def go(i = 0, t = 0):\\n            if i == N:\\n                return int(t == T)\\n            return go(i + 1, t + A[i]) + go(i + 1, t - A[i])\\n        return go()\\n```\n```\\nclass Solution:\\n    def findTargetSumWays(self, A: List[int], T: int) -> int:\\n        pre = {}\\n        pre[0] = 1\\n        for x in A:\\n            cur = {}\\n            for t, cnt in pre.items():\\n                cur[t + x] = cnt + (cur[t + x] if t + x in cur else 0)\\n                cur[t - x] = cnt + (cur[t - x] if t - x in cur else 0)\\n            pre = cur\\n        return pre[T] if T in pre else 0\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int findTargetSumWays(VI& A, int T) {\\n        int N = A.size();\\n        fun go = [&](auto i, auto t) {\\n            if (i == N)\\n                return int(t == T);\\n            return go(i + 1, t + A[i])\\n                 + go(i + 1, t - A[i]);\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int findTargetSumWays(VI& A, int T, Map m = {}) {\\n        int N = A.size();\\n        auto key = [](auto i, auto t) {\\n            stringstream ss; ss << i << \",\" << t;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto t) {\\n            if (i == N)\\n                return int(t == T);\\n            auto k = key(i, t);\\n            if (m.find(k) == m.end()) {\\n                m[k] = go(i + 1, t + A[i])\\n                     + go(i + 1, t - A[i]);\\n            }\\n            return m[k];\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    int findTargetSumWays(VI& A, int T) {\\n        Map pre;\\n        pre[0] = 1;  // 1 way to start with total 0\\n        for (auto x: A) {\\n            Map cur;\\n            for (auto [t, cnt]: pre)\\n                cur[t + x] += cnt,\\n                cur[t - x] += cnt;\\n            swap(pre, cur);\\n        }\\n        return pre[T];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541895,
                "title": "python-short-and-elegant-recursion-memoization",
                "content": "```curr``` holds the number our pattern has yielded so far. \\nAt every ```idx``` we add ```nums[idx]``` to ```curr``` as well as subtract ```nums[idx]``` from ```curr``` \\n\\n```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n\\t\\n        @lru_cache(None)\\n        def recurse(curr, idx):\\n            # reached the end of array. Moment of truth. Has the pattern yielded the target?\\n            if idx == len(nums):\\n                return 1 if curr == target else 0\\n            \\n            return recurse(curr - nums[idx], idx + 1) + recurse(curr + nums[idx], idx + 1)\\n        \\n        return recurse(0, 0)\\n```",
                "solutionTags": [],
                "code": "```curr```\n```idx```\n```nums[idx]```\n```curr```\n```nums[idx]```\n```curr```\n```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n\\t\\n        @lru_cache(None)\\n        def recurse(curr, idx):\\n            # reached the end of array. Moment of truth. Has the pattern yielded the target?\\n            if idx == len(nums):\\n                return 1 if curr == target else 0\\n            \\n            return recurse(curr - nums[idx], idx + 1) + recurse(curr + nums[idx], idx + 1)\\n        \\n        return recurse(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341398,
                "title": "variation-of-count-subsets-with-given-sum-type-of-count-subsets-with-given-diff-dp",
                "content": "```\\n// Approach: Try to divide the given set of integers into two subsets, one with all the\\n// postive integers[S1] and the other one with all the negative numbers[S2].\\n// s1--> Sum of all the numbers considered to be positive and -s2--> Sum of all\\n// the numbers considered to be negative..\\n// Now, their sum must be equal to Traget. (S1-S2=target)\\n// Now determine the number of ways in which S1-S2=target\\n// Variation of Subset sum problem where we have to determine the number of ways to get S1.\\n// S1+S2=Sum, S1-S2=target\\n// From the above 2 equations  S1 must be equal to (sum+target)/2\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n        \\n        int n=nums.length;\\n        int sum=0;\\n        for(int elem : nums){\\n            sum+=elem;\\n        }\\n        // Now, determine the number of subsets where S1=(sum+diff)/2\\n        int s1=sum+target;\\n        if(s1%2!=0){\\n            return 0;\\n        }\\n        s1=s1/2;\\n        return bottomUp(nums,s1);\\n    }\\n    public int bottomUp(int[] nums,int sum){\\n         // SubsetSum\\n\\n        int n=nums.length;\\n        int[][] dp=new int[n+1][sum+1];\\n\\n        // Base Cases...\\n        for(int i=1;i<n+1;i++){\\n            dp[i][0]=1;\\n        }\\n        for(int i=1;i<sum+1;i++){\\n            dp[0][i]=0;\\n        }\\n        dp[0][0]=1;\\n\\n        // Fill the DP Matrix...\\n        for(int i=1;i<n+1;i++){\\n            for(int j=0;j<sum+1;j++){\\n                if(nums[i-1]>j){\\n                    dp[i][j]=dp[i-1][j];\\n                }else{\\n                    dp[i][j]=dp[i-1][j]+dp[i-1][j-nums[i-1]];\\n                }\\n            }\\n        }\\n        return dp[n][sum];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n// Approach: Try to divide the given set of integers into two subsets, one with all the\\n// postive integers[S1] and the other one with all the negative numbers[S2].\\n// s1--> Sum of all the numbers considered to be positive and -s2--> Sum of all\\n// the numbers considered to be negative..\\n// Now, their sum must be equal to Traget. (S1-S2=target)\\n// Now determine the number of ways in which S1-S2=target\\n// Variation of Subset sum problem where we have to determine the number of ways to get S1.\\n// S1+S2=Sum, S1-S2=target\\n// From the above 2 equations  S1 must be equal to (sum+target)/2\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n        \\n        int n=nums.length;\\n        int sum=0;\\n        for(int elem : nums){\\n            sum+=elem;\\n        }\\n        // Now, determine the number of subsets where S1=(sum+diff)/2\\n        int s1=sum+target;\\n        if(s1%2!=0){\\n            return 0;\\n        }\\n        s1=s1/2;\\n        return bottomUp(nums,s1);\\n    }\\n    public int bottomUp(int[] nums,int sum){\\n         // SubsetSum\\n\\n        int n=nums.length;\\n        int[][] dp=new int[n+1][sum+1];\\n\\n        // Base Cases...\\n        for(int i=1;i<n+1;i++){\\n            dp[i][0]=1;\\n        }\\n        for(int i=1;i<sum+1;i++){\\n            dp[0][i]=0;\\n        }\\n        dp[0][0]=1;\\n\\n        // Fill the DP Matrix...\\n        for(int i=1;i<n+1;i++){\\n            for(int j=0;j<sum+1;j++){\\n                if(nums[i-1]>j){\\n                    dp[i][j]=dp[i-1][j];\\n                }else{\\n                    dp[i][j]=dp[i-1][j]+dp[i-1][j-nums[i-1]];\\n                }\\n            }\\n        }\\n        return dp[n][sum];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271200,
                "title": "target-sum-reduced-to-subset-with-given-sum",
                "content": "**Let sum of subset 1 be s1 and subset 2 with s2\\ns1 - s2 = diff (given)\\ns1 + s2=sum of array (logical)\\nTherefore adding both eq we get :\\n2s1= diff + sum of array\\ns1= (diff + sum of array)/2;\\nProblem reduces to find no of subsets with given sum**\\n\\n***however since this question allows 0 in the array we need to make just 1 change in the subset problem :\\nTraverse 2nd loop from j=0 to j<=sum to include 0 elements too instead of j=1 to j<=sum***\\n\\n```\\n    int subsetSum(vector<int> a, int n, int sum)\\n{\\n   // Initializing the matrix\\n    int dp[n + 1][sum + 1];\\n  // Initializing the first value of matrix\\n    dp[0][0] = 1;\\n    for (int i = 1; i <= sum; i++)\\n        dp[0][i] = 0;\\n    for (int i = 1; i <= n; i++)\\n        dp[i][0] = 1;\\n \\n    for (int i = 1; i <= n; i++)\\n    {\\n        for (int j = 0; j <= sum; j++)  // this 1 change in subset sum problem\\n        {\\n            if (a[i - 1] <= j)\\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - a[i - 1]]; \\n            else\\n           dp[i][j] = dp[i - 1][j];\\n        }\\n    }\\n\\n    return dp[n][sum];\\n}\\n    \\n    int findTargetSumWays(vector<int>& nums, int target) {        \\n       \\n     int sum=0,countzero=0;       // hint : Eg +1 +1 -1 +1 +1 = 3 = +(1+1+1+1) - (1) = given differnce       int n=nums.size();                // we need to find no of subsets with given differnce\\n     \\n     for(int i=0;i<n;i++)\\n         sum+=nums[i];\\n \\n     if((target+sum)%2==1)return 0;\\n\\t \\n\\t int reqSum=(target+sum)/2;\\n\\t return subsetSum(nums,n,reqSum);\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int subsetSum(vector<int> a, int n, int sum)\\n{\\n   // Initializing the matrix\\n    int dp[n + 1][sum + 1];\\n  // Initializing the first value of matrix\\n    dp[0][0] = 1;\\n    for (int i = 1; i <= sum; i++)\\n        dp[0][i] = 0;\\n    for (int i = 1; i <= n; i++)\\n        dp[i][0] = 1;\\n \\n    for (int i = 1; i <= n; i++)\\n    {\\n        for (int j = 0; j <= sum; j++)  // this 1 change in subset sum problem\\n        {\\n            if (a[i - 1] <= j)\\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - a[i - 1]]; \\n            else\\n           dp[i][j] = dp[i - 1][j];\\n        }\\n    }\\n\\n    return dp[n][sum];\\n}\\n    \\n    int findTargetSumWays(vector<int>& nums, int target) {        \\n       \\n     int sum=0,countzero=0;       // hint : Eg +1 +1 -1 +1 +1 = 3 = +(1+1+1+1) - (1) = given differnce       int n=nums.size();                // we need to find no of subsets with given differnce\\n     \\n     for(int i=0;i<n;i++)\\n         sum+=nums[i];\\n \\n     if((target+sum)%2==1)return 0;\\n\\t \\n\\t int reqSum=(target+sum)/2;\\n\\t return subsetSum(nums,n,reqSum);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 858142,
                "title": "c-dynamic-programming-16-ms-subset-sum-solution-well-commented",
                "content": "```\\nclass Solution {\\n    \\n    int countSubsets(vector<int> &nums, int sum){\\n        int n = nums.size();\\n        vector<vector<int> > dp(n+1,vector<int>(sum+1));\\n        \\n        // set base cases\\n        for(int i=0;i<=n;i++) dp[i][0] = 1;\\n        for(int s=1;s<=sum;s++) dp[0][s] = 0;\\n        \\n        // count for remaining subarrays of nums\\n        for(int i=1;i<=n;i++){\\n            for(int s=0;s<=sum;s++){ // important : iterate from s = 0, numbers are non-negative\\n                // excluding ith element\\n                dp[i][s] = dp[i-1][s];\\n                \\n                // including ith element in subset, if doesn\\'t exceed sum\\n                if(nums[i-1] <= s) \\n                    dp[i][s] += dp[i-1][s-nums[i-1]];\\n            }\\n        }\\n        return dp[n][sum];\\n    }\\n    \\npublic:\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        // Classic 0/1 Knapsack DP problem\\n        \\n        // 2 subsets : positive ones (s1) , negative ones (s2)\\n        // sum(s1) - sum(s2) = S\\n        // sum(s1) + sum(s2) = totalSum\\n        // sum(s1) = (S + totalSum)/2 -> therefore reduces to SUBSET SUM problem\\n        \\n        int n = nums.size();\\n        int totalSum = 0;\\n        for(int i=0;i<n;i++){\\n            totalSum += nums[i];\\n        }\\n        \\n        if((totalSum + (long)S) % 2 == 1 || totalSum < S) return 0;\\n        \\n        return countSubsets(nums, (totalSum + S)/2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int countSubsets(vector<int> &nums, int sum){\\n        int n = nums.size();\\n        vector<vector<int> > dp(n+1,vector<int>(sum+1));\\n        \\n        // set base cases\\n        for(int i=0;i<=n;i++) dp[i][0] = 1;\\n        for(int s=1;s<=sum;s++) dp[0][s] = 0;\\n        \\n        // count for remaining subarrays of nums\\n        for(int i=1;i<=n;i++){\\n            for(int s=0;s<=sum;s++){ // important : iterate from s = 0, numbers are non-negative\\n                // excluding ith element\\n                dp[i][s] = dp[i-1][s];\\n                \\n                // including ith element in subset, if doesn\\'t exceed sum\\n                if(nums[i-1] <= s) \\n                    dp[i][s] += dp[i-1][s-nums[i-1]];\\n            }\\n        }\\n        return dp[n][sum];\\n    }\\n    \\npublic:\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        // Classic 0/1 Knapsack DP problem\\n        \\n        // 2 subsets : positive ones (s1) , negative ones (s2)\\n        // sum(s1) - sum(s2) = S\\n        // sum(s1) + sum(s2) = totalSum\\n        // sum(s1) = (S + totalSum)/2 -> therefore reduces to SUBSET SUM problem\\n        \\n        int n = nums.size();\\n        int totalSum = 0;\\n        for(int i=0;i<n;i++){\\n            totalSum += nums[i];\\n        }\\n        \\n        if((totalSum + (long)S) % 2 == 1 || totalSum < S) return 0;\\n        \\n        return countSubsets(nums, (totalSum + S)/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 637056,
                "title": "java-dfs-solution",
                "content": "```\\nclass Solution {\\n    int result = 0;\\n    public int findTargetSumWays(int[] nums, int S) {\\n        if (nums == null || nums.length == 0) return 0;\\n        dfs (nums, S, 0, 0);        \\n        return result;       \\n    }\\n    \\n    public void dfs (int[] nums, int S, int current, int index) {\\n        if (index == nums.length && current == S) {\\n            result += 1;\\n            return;\\n        }\\n        \\n        if (index < nums.length) {\\n            dfs (nums, S, current + nums[index], index + 1);\\n            dfs (nums, S, current - nums[index], index + 1);\\n        }   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int result = 0;\\n    public int findTargetSumWays(int[] nums, int S) {\\n        if (nums == null || nums.length == 0) return 0;\\n        dfs (nums, S, 0, 0);        \\n        return result;       \\n    }\\n    \\n    public void dfs (int[] nums, int S, int current, int index) {\\n        if (index == nums.length && current == S) {\\n            result += 1;\\n            return;\\n        }\\n        \\n        if (index < nums.length) {\\n            dfs (nums, S, current + nums[index], index + 1);\\n            dfs (nums, S, current - nums[index], index + 1);\\n        }   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330082,
                "title": "multiple-solutions-leading-up-to-optimal-in-the-end",
                "content": "Being able to derive the thought process is important in an interview.  So I thought I might share multiple solutions, each optimizing a previous solution until arriving at the final optimal one.\\n\\nLike all DP problems, the most important and the most challenging part is recognizing the recurrence.  For this particular problem, we can build a recurrence either from the front to the end or from the end to the front.  I\\'ve chosen to do it from the end to the front (for reasons that will hopefully become clear later).\\n\\n```\\nfunc TargetSumWaysRecursive(nums []int, S int) int {\\n    return helper(nums, len(nums)-1, S)\\n}\\n\\nfunc helper(nums []int, i, sum int) int {\\n    if i == -1 {\\n\\t    if sum == 0 {\\n\\t\\t    return 1\\n\\t\\t}\\n\\t\\treturn 0\\n\\t}\\n\\tcount := 0\\n\\tfor sign := -1; sign <= 1; sign += 2 {\\n\\t    count += helper(nums, i-1, sum+sign*nums[i])\\n\\t}\\n\\treturn count\\n}\\n```\\n\\nThe time complexity for this top-down recursive solution is O(2^n), which is extremely inefficient.  Aux space complexity is O(n) due to the recursion call stack.\\n\\nNaturally we can see that this solution can be optimized by using backtracking to prune subtrees that are not promising.  So below is a trivial backtracking optimization.\\n\\n```\\nfunc TargetSumWaysBacktracking(nums []int, S int) int {\\n    n := len(nums)\\n\\tprefixSums := make([]int, n)\\n\\tprefixSums[0] = nums[0]\\n\\tfor i := 1; i < n; i++ {\\n\\t    prefixSums[i] = prefixSums[i-1] + nums[i]\\n\\t}\\n\\treturn helper(nums, n-1, S, prefixSums)\\n}\\n\\nfunc helper(nums []int, i, sum int, prefixSums []int) int {\\n    if i == -1 {\\n\\t    if sum == 0 {\\n\\t\\t    return 1\\n\\t\\t}\\n\\t\\treturn 0\\n\\t}\\n\\t\\n\\t// prune subtrees that are not promising in O(1) with the help of the precomputed prefixSums.\\n\\tif sum + prefixSums[i] < 0 || sum - prefixSums[i] > 0 {\\n\\t    return 0\\n\\t}\\n\\t\\n\\tcount := 0\\n\\tfor sign := -1; sign <= 1; sign += 2 {\\n\\t    count += helper(nums, i-1, sum+sign*nums[i], prefixSums)\\n\\t}\\n\\treturn count\\n}\\n```\\n\\nThe time complexity for the backtracking solution is still O(2^n), but should run much faster since not the entire search space will be explored.  The aux. space complexity is still O(n), mostly due to the recursion and the prefixSums array.\\n\\nNow looking back at the recursive solution, it is clear that many of the 2^n recursive calls are repetitive.  The number of subproblems should only be n * total, where `total` is the sum of all the values of the `nums` array.  So we could easily optimize by using memoization.\\n\\n```\\nfunc TargetSumWaysMemoization(nums []int, S int) int {\\n    n := len(nums)\\n\\ttotal := 0\\n\\tfor _, v := range nums {\\n\\t    total += v\\n\\t}\\n\\tmemo := make([][]int, n+1)\\n\\tfor i := range memo {\\n\\t    memo[i] = make([]int, 2*total+1)\\n\\t\\tfor j := range memo[i] {\\n\\t\\t    memo[i][j] = math.MinInt64\\n\\t\\t}\\n\\t}\\n\\treturn helper(nums, total, n, S, memo)\\n}\\n\\nfunc helper(nums []int, total, i, sum int, memo [][]int) int {\\n    j := sum + total\\n\\tif j < 0 || j >= len(memo[i]) {\\n\\t    return 0 // for cases where the target sum is way off and definitely unreachable\\n\\t}\\n\\tif memo[i][j] != math.MinInt64 {\\n\\t    return memo[i][j]\\n\\t}\\n\\tif i == 0 {\\n\\t    if sum == 0 {\\n\\t\\t    memo[i][j] = 1\\n\\t\\t} else {\\n\\t\\t    memo[i][j] = 0\\n\\t\\t}\\n\\t} else {\\n\\t    memo[i][j] = 0\\n\\t\\tfor sign := -1; sign <= 1; sign += 2 {\\n\\t\\t    memo[i][j] += helper(nums, total, i-1, sum+sign*nums[i-1], memo)\\n\\t\\t}\\n\\t}\\n\\treturn memo[i][j]\\n}\\n```\\n\\nThe time complexity is now reduced to O(n * total).  Aux space complexity is the same O(n * total).  The time complexity is pretty good already, but this solution runs the risk of stack overflow when n is large.  So we could perhaps optimize this further by transforming it into an iterative bottom-up two-dimensional DP solution.\\n\\n```\\nfunc TargetSumWays2DDP(nums []int, S int) int {\\n    n := len(nums)\\n\\ttotal := 0\\n\\tfor _, v := range nums {\\n\\t    total += v\\n\\t}\\n\\tm := 2*total + 1\\n\\t\\n\\t// terminate early if target sum is definitely unreachable\\n\\tif j := S + total; j < 0 || j >= m {\\n\\t    return 0\\n\\t}\\n\\t\\n\\tdp := make([][]int, n+1)\\n\\tfor i := range dp {\\n\\t    dp[i] = make([]int, m)\\n\\t}\\n\\tdp[0][0+total] = 1\\n\\tfor i := 0; i < n; i++ {\\n\\t    for j := 0; j < m; j++ {\\n\\t\\t    if dp[i][j] > 0 {\\n\\t\\t\\t    for sign := -1; sign <= 1; sign += 2 {\\n\\t\\t\\t\\t    if nextSum := j + sign*nums[i]; nextSum >= 0 && nextSum < m {\\n\\t\\t\\t\\t\\t    dp[i+1][nextSum] += dp[i][j]\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[n][S+total]\\n}\\n```\\n\\nTime complexity for this two-dimensional DP solution is O(n * total).  Aux. space complexity is the same.\\n\\nLooking closely it is apparent that we only need two rows of the `dp` array.  So we optimize further to come up with a linear space solution.\\n\\n```\\nfunc TargetSumWaysDPLinearSpace(nums []int, S int) int {\\n    n := len(nums)\\n\\ttotal := 0\\n\\tfor _, v := range nums {\\n\\t    total += v\\n\\t}\\n\\tm := 2*total + 1\\n\\t\\n\\tif j := S + total; j < 0 || j >= m {\\n\\t    return 0\\n\\t}\\n\\t\\n\\tdp := make([][]int, 2)\\n\\tfor i := range dp {\\n\\t    dp[i] = make([]int, m)\\n\\t}\\n\\tdp[0][0+total] = 1\\n\\tfor i := 0; i < n; i++ {\\n\\t    for j := 0; j < m ; j++ {\\n\\t\\t    if dp[0][j] > 0 {\\n\\t\\t\\t    for sign := -1; sign <= 1; sign += 2 {\\n\\t\\t\\t\\t    if nextSum := j + sign*nums[i]; nextSum >= 0 && nextSum < m {\\n\\t\\t\\t\\t\\t    dp[1][nextSum] += dp[0][j]\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[0], dp[1] = dp[1], dp[0] // swap the two rows\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t    dp[1][j] = 0 // clear the new second row for the next iteration\\n\\t\\t}\\n\\t}\\n\\treturn dp[0][S+total]\\n}\\n```\\n\\nThis solution is probably as good as it gets.  It has the optimal compleixty of O(n * total) and linear aux space complexity O(total).  However the code is long.  We can make it shorter by using a hashmap for each row.  This will actually be slower in practice because hashmaps are slower than arrays, but the time complexity remains the same.\\n\\n```\\nfunc TargetSumWaysDPWithMaps(nums []int, S int) int {\\n    n := len(nums)\\n\\tdp := map[int]int{0: 1}\\n\\tfor i := 0; i < n; i++ {\\n\\t    dp2 := make(map[int]int)\\n\\t\\tfor currSum, currCount := range dp {\\n\\t\\t    for sign := -1; sign <= 1; sign += 2 {\\n\\t\\t\\t    dp2[currSum+sign*nums[i]] += currCount\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp = dp2\\n\\t}\\n\\treturn dp[S]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nfunc TargetSumWaysRecursive(nums []int, S int) int {\\n    return helper(nums, len(nums)-1, S)\\n}\\n\\nfunc helper(nums []int, i, sum int) int {\\n    if i == -1 {\\n\\t    if sum == 0 {\\n\\t\\t    return 1\\n\\t\\t}\\n\\t\\treturn 0\\n\\t}\\n\\tcount := 0\\n\\tfor sign := -1; sign <= 1; sign += 2 {\\n\\t    count += helper(nums, i-1, sum+sign*nums[i])\\n\\t}\\n\\treturn count\\n}\\n```\n```\\nfunc TargetSumWaysBacktracking(nums []int, S int) int {\\n    n := len(nums)\\n\\tprefixSums := make([]int, n)\\n\\tprefixSums[0] = nums[0]\\n\\tfor i := 1; i < n; i++ {\\n\\t    prefixSums[i] = prefixSums[i-1] + nums[i]\\n\\t}\\n\\treturn helper(nums, n-1, S, prefixSums)\\n}\\n\\nfunc helper(nums []int, i, sum int, prefixSums []int) int {\\n    if i == -1 {\\n\\t    if sum == 0 {\\n\\t\\t    return 1\\n\\t\\t}\\n\\t\\treturn 0\\n\\t}\\n\\t\\n\\t// prune subtrees that are not promising in O(1) with the help of the precomputed prefixSums.\\n\\tif sum + prefixSums[i] < 0 || sum - prefixSums[i] > 0 {\\n\\t    return 0\\n\\t}\\n\\t\\n\\tcount := 0\\n\\tfor sign := -1; sign <= 1; sign += 2 {\\n\\t    count += helper(nums, i-1, sum+sign*nums[i], prefixSums)\\n\\t}\\n\\treturn count\\n}\\n```\n```\\nfunc TargetSumWaysMemoization(nums []int, S int) int {\\n    n := len(nums)\\n\\ttotal := 0\\n\\tfor _, v := range nums {\\n\\t    total += v\\n\\t}\\n\\tmemo := make([][]int, n+1)\\n\\tfor i := range memo {\\n\\t    memo[i] = make([]int, 2*total+1)\\n\\t\\tfor j := range memo[i] {\\n\\t\\t    memo[i][j] = math.MinInt64\\n\\t\\t}\\n\\t}\\n\\treturn helper(nums, total, n, S, memo)\\n}\\n\\nfunc helper(nums []int, total, i, sum int, memo [][]int) int {\\n    j := sum + total\\n\\tif j < 0 || j >= len(memo[i]) {\\n\\t    return 0 // for cases where the target sum is way off and definitely unreachable\\n\\t}\\n\\tif memo[i][j] != math.MinInt64 {\\n\\t    return memo[i][j]\\n\\t}\\n\\tif i == 0 {\\n\\t    if sum == 0 {\\n\\t\\t    memo[i][j] = 1\\n\\t\\t} else {\\n\\t\\t    memo[i][j] = 0\\n\\t\\t}\\n\\t} else {\\n\\t    memo[i][j] = 0\\n\\t\\tfor sign := -1; sign <= 1; sign += 2 {\\n\\t\\t    memo[i][j] += helper(nums, total, i-1, sum+sign*nums[i-1], memo)\\n\\t\\t}\\n\\t}\\n\\treturn memo[i][j]\\n}\\n```\n```\\nfunc TargetSumWays2DDP(nums []int, S int) int {\\n    n := len(nums)\\n\\ttotal := 0\\n\\tfor _, v := range nums {\\n\\t    total += v\\n\\t}\\n\\tm := 2*total + 1\\n\\t\\n\\t// terminate early if target sum is definitely unreachable\\n\\tif j := S + total; j < 0 || j >= m {\\n\\t    return 0\\n\\t}\\n\\t\\n\\tdp := make([][]int, n+1)\\n\\tfor i := range dp {\\n\\t    dp[i] = make([]int, m)\\n\\t}\\n\\tdp[0][0+total] = 1\\n\\tfor i := 0; i < n; i++ {\\n\\t    for j := 0; j < m; j++ {\\n\\t\\t    if dp[i][j] > 0 {\\n\\t\\t\\t    for sign := -1; sign <= 1; sign += 2 {\\n\\t\\t\\t\\t    if nextSum := j + sign*nums[i]; nextSum >= 0 && nextSum < m {\\n\\t\\t\\t\\t\\t    dp[i+1][nextSum] += dp[i][j]\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[n][S+total]\\n}\\n```\n```\\nfunc TargetSumWaysDPLinearSpace(nums []int, S int) int {\\n    n := len(nums)\\n\\ttotal := 0\\n\\tfor _, v := range nums {\\n\\t    total += v\\n\\t}\\n\\tm := 2*total + 1\\n\\t\\n\\tif j := S + total; j < 0 || j >= m {\\n\\t    return 0\\n\\t}\\n\\t\\n\\tdp := make([][]int, 2)\\n\\tfor i := range dp {\\n\\t    dp[i] = make([]int, m)\\n\\t}\\n\\tdp[0][0+total] = 1\\n\\tfor i := 0; i < n; i++ {\\n\\t    for j := 0; j < m ; j++ {\\n\\t\\t    if dp[0][j] > 0 {\\n\\t\\t\\t    for sign := -1; sign <= 1; sign += 2 {\\n\\t\\t\\t\\t    if nextSum := j + sign*nums[i]; nextSum >= 0 && nextSum < m {\\n\\t\\t\\t\\t\\t    dp[1][nextSum] += dp[0][j]\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp[0], dp[1] = dp[1], dp[0] // swap the two rows\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t    dp[1][j] = 0 // clear the new second row for the next iteration\\n\\t\\t}\\n\\t}\\n\\treturn dp[0][S+total]\\n}\\n```\n```\\nfunc TargetSumWaysDPWithMaps(nums []int, S int) int {\\n    n := len(nums)\\n\\tdp := map[int]int{0: 1}\\n\\tfor i := 0; i < n; i++ {\\n\\t    dp2 := make(map[int]int)\\n\\t\\tfor currSum, currCount := range dp {\\n\\t\\t    for sign := -1; sign <= 1; sign += 2 {\\n\\t\\t\\t    dp2[currSum+sign*nums[i]] += currCount\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp = dp2\\n\\t}\\n\\treturn dp[S]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 97448,
                "title": "my-java-solution",
                "content": "```\\n    public int findTargetSumWays(int[] nums, int S) {\\n        if (nums == null || nums.length == 0){\\n            return 0;\\n        }\\n        return helper(nums, S, 0, 0, 0);\\n    }\\n    \\n    public int helper(int[] nums, int S, int sum, int index, int count){\\n        if (index == nums.length){\\n            if (sum == S){\\n                count ++;\\n            }\\n            return count;\\n        }\\n        return helper(nums, S, sum + nums[index], index + 1, count) + helper(nums, S, sum - nums[index], index + 1, count);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findTargetSumWays(int[] nums, int S) {\\n        if (nums == null || nums.length == 0){\\n            return 0;\\n        }\\n        return helper(nums, S, 0, 0, 0);\\n    }\\n    \\n    public int helper(int[] nums, int S, int sum, int index, int count){\\n        if (index == nums.length){\\n            if (sum == S){\\n                count ++;\\n            }\\n            return count;\\n        }\\n        return helper(nums, S, sum + nums[index], index + 1, count) + helper(nums, S, sum - nums[index], index + 1, count);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3666656,
                "title": "dp-solution-recursion-memoization-bottom-up-dp",
                "content": "# Logic\\nIt\\'s kind of a 0/1 knapsack problem.\\n\\nWe see that we HAVE to pick all the numbers from nums to make up our target. And to pick that we either take it as positive or negative signed.\\n\\nStarting from the first index, at every index we will be having two choices, and based on the previous choices we made our sum can have any value at that index ranging between [Max_Sum, Min_Sum] ( formed using nums values) both inclusive, some of which will eventually end up making up the target value by the time we reach the last index.\\n\\nClearly it\\'s a 2D dp problem. \\n\\n# Recursion + Memoization\\n\\nWe proceed the same way like we do in every take/not-take 2D dp problems and further explanations have been commented out in the code. Rest are self-explanatory.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        //Finding the range of maximum sum and minimum sum that can be formed with nums\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n\\n        //dp table with all the possible combinationof index and sum\\n        vector<vector<int>> dp(n, vector<int> (2*sum+1, -1));\\n        \\n        //edge cases\\n        if(target>sum||target<-sum){\\n            return 0;\\n        }\\n        return helper(sum,0,0,nums,target,dp);\\n    }\\n    int helper(int sum, int cursum, int index, vector<int>& nums, int target, vector<vector<int>>& dp){\\n\\n        //base case\\n        if(index==nums.size()){\\n            if(cursum==target) return 1;\\n            else return 0;\\n        }\\n        //adjustment with offset to cover up -ve sum as index cant be negative\\n        if(dp[index][cursum+sum]!=-1) return dp[index][cursum+sum];\\n\\n        //no. of ways if we chose +nums[index]\\n        int take1 = helper(sum,cursum+nums[index],index+1,nums,target,dp);\\n        //no. of ways if we chose -nums[index]\\n        int take2 = helper(sum,cursum-nums[index],index+1,nums,target,dp);\\n\\n        //store and return total number of ways\\n        return dp[index][cursum+sum]=take1+take2;\\n    }\\n};\\n```\\n# Making it Bottom-Up\\n\\nJust looking at the above code, we can easily code it up in the bottom-up approach. The objective here is to covert recursion into for loops.\\n\\nNow think, we traversed all the index position of nums (This will be our first for loop) and based on our choice we updated our currSum in the recursive calls, and what was the range of this currSum?(This will be our second for loop).\\n\\nIn the recursion we called the helper function with index 0 uptil the last, but since RECURSION the updation of the answer starts when we reach our base-case (after the last index), which means we have to traverse reversely in our first for loop.\\n\\nNow comes the base-case which will be the first case to start with in our bottom-up solution. The logic is, as it is the first case, it has to be the first way we make up our currSum using nums[last_index] so we update our table dp at that index for that currSum to 1 for both +ve and -ve cases.\\n\\nCheck out the code to understand better.\\n(Notice how edge cases are being handled)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        vector<vector<int>> dp(n, vector<int>(2 * sum + 1, 0));\\n        \\n        if (target > sum || target < -sum) {\\n            return 0;\\n        }\\n        \\n        dp[n - 1][nums[n - 1] + sum] = 1;      \\n        dp[n - 1][-nums[n - 1] + sum] += 1;\\n        //Why did we increment rather than just assigning?\\\\\\n          Think of the cases where we may have 0 (+0 = -0)--> 2 ways at the same index.\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = 0; j <= 2 * sum; j++) {\\n                if (j + nums[i] <= 2 * sum) {\\n                    dp[i][j] += dp[i + 1][j + nums[i]];\\n                }\\n                if (j - nums[i] >= 0) {\\n                    dp[i][j] += dp[i + 1][j - nums[i]];\\n                }\\n            }\\n        }\\n        \\n        return dp[0][target + sum];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        //Finding the range of maximum sum and minimum sum that can be formed with nums\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n\\n        //dp table with all the possible combinationof index and sum\\n        vector<vector<int>> dp(n, vector<int> (2*sum+1, -1));\\n        \\n        //edge cases\\n        if(target>sum||target<-sum){\\n            return 0;\\n        }\\n        return helper(sum,0,0,nums,target,dp);\\n    }\\n    int helper(int sum, int cursum, int index, vector<int>& nums, int target, vector<vector<int>>& dp){\\n\\n        //base case\\n        if(index==nums.size()){\\n            if(cursum==target) return 1;\\n            else return 0;\\n        }\\n        //adjustment with offset to cover up -ve sum as index cant be negative\\n        if(dp[index][cursum+sum]!=-1) return dp[index][cursum+sum];\\n\\n        //no. of ways if we chose +nums[index]\\n        int take1 = helper(sum,cursum+nums[index],index+1,nums,target,dp);\\n        //no. of ways if we chose -nums[index]\\n        int take2 = helper(sum,cursum-nums[index],index+1,nums,target,dp);\\n\\n        //store and return total number of ways\\n        return dp[index][cursum+sum]=take1+take2;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        vector<vector<int>> dp(n, vector<int>(2 * sum + 1, 0));\\n        \\n        if (target > sum || target < -sum) {\\n            return 0;\\n        }\\n        \\n        dp[n - 1][nums[n - 1] + sum] = 1;      \\n        dp[n - 1][-nums[n - 1] + sum] += 1;\\n        //Why did we increment rather than just assigning?\\\\\\n          Think of the cases where we may have 0 (+0 = -0)--> 2 ways at the same index.\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = 0; j <= 2 * sum; j++) {\\n                if (j + nums[i] <= 2 * sum) {\\n                    dp[i][j] += dp[i + 1][j + nums[i]];\\n                }\\n                if (j - nums[i] >= 0) {\\n                    dp[i][j] += dp[i + 1][j - nums[i]];\\n                }\\n            }\\n        }\\n        \\n        return dp[0][target + sum];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952311,
                "title": "c-memoization-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint fun(int i,int n,int target,vector<int>& nums,int sum,vector<vector<int>> &dp){\\n    if(i==n){\\n      if (target==sum)\\n      return 1;\\n      else return 0;\\n      }\\n      if(dp[i][sum+1000]!=-1) return dp[i][sum+1000];\\n    int left=fun(i+1,n,target,nums,sum+nums[i],dp);\\n    int right=fun(i+1,n,target,nums,sum-nums[i],dp);\\n    return dp[i][sum+1000]=right+left;\\n}\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum=0;\\n        vector<vector<int>> dp(nums.size()+1,vector<int>(2005,-1));\\n        return fun(0,nums.size(),target,nums,sum,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint fun(int i,int n,int target,vector<int>& nums,int sum,vector<vector<int>> &dp){\\n    if(i==n){\\n      if (target==sum)\\n      return 1;\\n      else return 0;\\n      }\\n      if(dp[i][sum+1000]!=-1) return dp[i][sum+1000];\\n    int left=fun(i+1,n,target,nums,sum+nums[i],dp);\\n    int right=fun(i+1,n,target,nums,sum-nums[i],dp);\\n    return dp[i][sum+1000]=right+left;\\n}\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum=0;\\n        vector<vector<int>> dp(nums.size()+1,vector<int>(2005,-1));\\n        return fun(0,nums.size(),target,nums,sum,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320506,
                "title": "aditya-verma-solution-with-edge-cases-explained",
                "content": "```\\n public int findTargetSumWays(int[] nums, int target) {\\n        int n = nums.length;\\n        int arrsum = 0;\\n        for(int i=0;i<n;i++){\\n            arrsum+=nums[i];\\n        }\\n//arrsum + target<0, consider test case - nums: [100], target: -200\\n//(arrsum  + target) % 2 != 0, consider test case - nums: [7,9,3,8,0,2,4,8,3,9], its sum = 53 and target: 0, there could not be any 26.5 in integer array.\\n        if( arrsum < target || arrsum + target < 0 ||  (arrsum  + target) %2 != 0 )\\n         return 0;\\n        \\n        int sum = (target+arrsum)/2;\\n        \\n        int[][] dp = new int[n+1][sum+1];\\n        \\n        for(int i=0;i<n+1;i++){\\n\\t       for(int j=0;j<sum+1;j++){\\n\\t           if(i==0)\\n\\t           dp[i][j] = 0;\\n\\t           if(j==0)\\n\\t           dp[i][j] = 1;\\n\\t       }\\n\\t   }\\n        \\n        for(int i=1;i<n+1;i++){\\n            for(int j=0;j<sum+1;j++){ // usually we start j=1 but here to counter zero we initialize it with j=0\\n                if(nums[i-1]<=j){\\n                    dp[i][j] = (dp[i-1][j-nums[i-1]]) + (dp[i-1][j]);\\n                }else{\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        return dp[n][sum];\\n    }\\n```\\n***Starting the second loop with j=0, instead of j=1, will do the trick.\\nAs,\\nIf(arr[i-1] > 0) => dp[i][0] = dp[i-1][0]\\nelse If(arr[i-1] <= 0) => dp[i][0] = dp[i-1][0] + dp[i-1][0]; and this extra term will lead to extra +1. And this extra +1 will exist whenever arr[i-1] == 0. Thus increasing our answers by \\nno. of zeroes whenever required.***\\n\\n[Video Link](https://www.youtube.com/watch?v=Hw6Ygp3JBYw&list=PL_z_8CaSLPWekqhdCPmFohncHwz8TY2Go&index=12)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n public int findTargetSumWays(int[] nums, int target) {\\n        int n = nums.length;\\n        int arrsum = 0;\\n        for(int i=0;i<n;i++){\\n            arrsum+=nums[i];\\n        }\\n//arrsum + target<0, consider test case - nums: [100], target: -200\\n//(arrsum  + target) % 2 != 0, consider test case - nums: [7,9,3,8,0,2,4,8,3,9], its sum = 53 and target: 0, there could not be any 26.5 in integer array.\\n        if( arrsum < target || arrsum + target < 0 ||  (arrsum  + target) %2 != 0 )\\n         return 0;\\n        \\n        int sum = (target+arrsum)/2;\\n        \\n        int[][] dp = new int[n+1][sum+1];\\n        \\n        for(int i=0;i<n+1;i++){\\n\\t       for(int j=0;j<sum+1;j++){\\n\\t           if(i==0)\\n\\t           dp[i][j] = 0;\\n\\t           if(j==0)\\n\\t           dp[i][j] = 1;\\n\\t       }\\n\\t   }\\n        \\n        for(int i=1;i<n+1;i++){\\n            for(int j=0;j<sum+1;j++){ // usually we start j=1 but here to counter zero we initialize it with j=0\\n                if(nums[i-1]<=j){\\n                    dp[i][j] = (dp[i-1][j-nums[i-1]]) + (dp[i-1][j]);\\n                }else{\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        return dp[n][sum];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2200578,
                "title": "easy-to-understand-dp-recursion-memoization-solution",
                "content": "```\\n//recursion\\nclass Solution {\\n    int getSum(vector<int>&nums,int target,int idx){\\n        if(target == 0 && idx == nums.size())return 1;\\n        if(idx == nums.size())return 0;\\n        int take = getSum(nums,target-nums[idx],idx+1);\\n        int ignore = getSum(nums,target+nums[idx],idx+ 1);\\n        return take + ignore;\\n    }\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        return getSum(nums,target,0);\\n    }\\n};\\n\\n//memoization\\nclass Solution {\\n    vector<vector<int>>dp;\\n    int Nsum;\\n    int getSum(vector<int>&nums,int sum,int idx,int &target){\\n        if(sum == target && idx == nums.size()) return 1;\\n        if(idx == nums.size()) return 0;\\n        \\n        if(dp[idx][sum + Nsum] != -1 )return dp[idx][sum + Nsum];\\n        \\n        int add      = getSum(nums, sum + nums[idx], idx + 1, target);\\n        int subtract = getSum(nums, sum - nums[idx], idx + 1, target);\\n        \\n        return  dp[idx][sum + Nsum] = add + subtract;\\n    }\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        for(int i=0; i<nums.size(); i++)sum += nums[i];\\n        if(sum > target && -1*sum > target)return 0;\\n        \\n        Nsum = sum;\\n        dp.resize(nums.size(),vector<int>(2 * sum + 2,-1));\\n        return getSum(nums,0,0,target);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n//recursion\\nclass Solution {\\n    int getSum(vector<int>&nums,int target,int idx){\\n        if(target == 0 && idx == nums.size())return 1;\\n        if(idx == nums.size())return 0;\\n        int take = getSum(nums,target-nums[idx],idx+1);\\n        int ignore = getSum(nums,target+nums[idx],idx+ 1);\\n        return take + ignore;\\n    }\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        return getSum(nums,target,0);\\n    }\\n};\\n\\n//memoization\\nclass Solution {\\n    vector<vector<int>>dp;\\n    int Nsum;\\n    int getSum(vector<int>&nums,int sum,int idx,int &target){\\n        if(sum == target && idx == nums.size()) return 1;\\n        if(idx == nums.size()) return 0;\\n        \\n        if(dp[idx][sum + Nsum] != -1 )return dp[idx][sum + Nsum];\\n        \\n        int add      = getSum(nums, sum + nums[idx], idx + 1, target);\\n        int subtract = getSum(nums, sum - nums[idx], idx + 1, target);\\n        \\n        return  dp[idx][sum + Nsum] = add + subtract;\\n    }\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        for(int i=0; i<nums.size(); i++)sum += nums[i];\\n        if(sum > target && -1*sum > target)return 0;\\n        \\n        Nsum = sum;\\n        dp.resize(nums.size(),vector<int>(2 * sum + 2,-1));\\n        return getSum(nums,0,0,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2134207,
                "title": "aditya-verma-solution-java",
                "content": "Explanation:\\n\\nhere also you need to find two subsets as **count subset sum** or **Count the number of subset with a given difference**\\n\\n   s1 - s2 = target\\n   s1 + s2 = sum[arr]\\n   // subtract both equation\\n   \\n   -2s2 = target-sum[arr]\\n   s2 = (sum[arr] - target)/2;\\n\\nSolution:\\n``` \\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n         int sum = 0;\\n        for(int x : nums)\\n            sum += x;\\n        if(((sum - target) % 2 == 1) || (target > sum))\\n            return 0;\\n        \\n        int n = nums.length;\\n        int s2 = (sum - target)/2;\\n        int[][] t = new int[n + 1][s2 + 1];\\n        t[0][0] = 1;\\n        \\n        for(int i = 1; i < n + 1; i++) {\\n            for(int j = 0; j < s2 + 1; j++) {\\n                if(nums[i - 1] <= j)\\n                    t[i][j] = t[i-1][j] + t[i - 1][j - nums[i - 1]];\\n                else\\n                    t[i][j] = t[i - 1][j];\\n            }\\n        }\\n        return t[n][s2];\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "``` \\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n         int sum = 0;\\n        for(int x : nums)\\n            sum += x;\\n        if(((sum - target) % 2 == 1) || (target > sum))\\n            return 0;\\n        \\n        int n = nums.length;\\n        int s2 = (sum - target)/2;\\n        int[][] t = new int[n + 1][s2 + 1];\\n        t[0][0] = 1;\\n        \\n        for(int i = 1; i < n + 1; i++) {\\n            for(int j = 0; j < s2 + 1; j++) {\\n                if(nums[i - 1] <= j)\\n                    t[i][j] = t[i-1][j] + t[i - 1][j - nums[i - 1]];\\n                else\\n                    t[i][j] = t[i - 1][j];\\n            }\\n        }\\n        return t[n][s2];\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832350,
                "title": "simple-easy-cpp-solution",
                "content": "\\n**Dynamic Programming (top down) solution**\\nfirst reduce the problem to ->\\n\\tcount number of subset with given diffrence and then reduce the problem to count the number of subset with given sum\\nlet sum of subset 1 be s1 and subset 2 with s2\\ns1 - s2 = target\\ns1 + s2=sum all elemnt in array (tmp)\\nTherefore adding both eq we get :\\n2s1= target + tmp\\ns1= (target+tmp)/2;\\nProblem reduce to find the number of subset with given sum\\nsum=(target+tmp)/2;\\n\\t\\n\\t\\n\\t int solve(vector<int> &nums,int n, int sum)\\n    {\\n        int dp[n+1][sum+1];\\n        for(int i=0;i<sum+1;i++) dp[0][i]=0;\\n        for(int i=0;i<n+1;i++) dp[i][0]=1;\\n        \\n        for(int i=1;i<n+1;i++)\\n        {\\n            for(int j=0;j<sum+1;j++)\\n            {\\n                if(nums[i-1]<=j)\\n                {\\n                    dp[i][j]=(dp[i-1][j] + dp[i-1][j-nums[i-1]]);\\n                }\\n                else\\n                {\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n            }\\n        }\\n        return dp[n][sum];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) \\n    {\\n        int tmp=0;\\n        target=abs(target);\\n        int n=nums.size();\\n        for(int i=0;i<n;i++) tmp+=nums[i];\\n        if(target > tmp || (tmp+target)%2)    return 0;\\n        int sum=(tmp+target)/2;\\n        return solve(nums,n,sum);\\n    }\\n\\t",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "\\n**Dynamic Programming (top down) solution**\\nfirst reduce the problem to ->\\n\\tcount number of subset with given diffrence and then reduce the problem to count the number of subset with given sum\\nlet sum of subset 1 be s1 and subset 2 with s2\\ns1 - s2 = target\\ns1 + s2=sum all elemnt in array (tmp)\\nTherefore adding both eq we get :\\n2s1= target + tmp\\ns1= (target+tmp)/2;\\nProblem reduce to find the number of subset with given sum\\nsum=(target+tmp)/2;\\n\\t\\n\\t\\n\\t int solve(vector<int> &nums,int n, int sum)\\n    {\\n        int dp[n+1][sum+1];\\n        for(int i=0;i<sum+1;i++) dp[0][i]=0;\\n        for(int i=0;i<n+1;i++) dp[i][0]=1;\\n        \\n        for(int i=1;i<n+1;i++)\\n        {\\n            for(int j=0;j<sum+1;j++)\\n            {\\n                if(nums[i-1]<=j)\\n                {\\n                    dp[i][j]=(dp[i-1][j] + dp[i-1][j-nums[i-1]]);\\n                }\\n                else\\n                {\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n            }\\n        }\\n        return dp[n][sum];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) \\n    {\\n        int tmp=0;\\n        target=abs(target);\\n        int n=nums.size();\\n        for(int i=0;i<n;i++) tmp+=nums[i];\\n        if(target > tmp || (tmp+target)%2)    return 0;\\n        int sum=(tmp+target)/2;\\n        return solve(nums,n,sum);\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1490009,
                "title": "target-sum-c-similar-to-subset-sum",
                "content": "On first seeing this problem, it may seem very difficult and not at all intuitive but if one identifies that its actually a variation of subset sum problem, then task becomes straightforward. So lets dive into the approach:\\nIf you observe carefully , then we actually need to find 2 subsets such that the difference of sum of the subsets yields us the target. Now lets assume array is a=[1,1,1,1,1] and target=3. \\nLets assume the sum of first subset is **partsum** and the sum of the whole array is **sum**. So the sum of the second subset will be (**sum** - **partsum**). Now we know that :\\nSum of subset2 - sum of subset1 is target(difference of two subsets is what I talked about in the starting of the article) (Considering (sum of subset1 - sum of subset2 = target) is also correct)  . Which means \\n\\n((**sum** - **partsum**) - **partsum**) = target, which implies\\n**partsum** = (**sum** - target)/2   \\n\\nSo see that the problem actually reduces to that we only need to find the subset sum which is equal to partsum which will now become our new target. (In short we need to find the subset with target equals to partsum because the second subset sum gets automatically fixed).\\n\\n**Just a small note, if (sum-target) is not divisible by 2, then there are no 2 possible subset combinations whose difference of sums yield the target. So just directly return 0.**\\n\\nI hope anyone who read the post understood my approach. Do upvote if u like.\\nCheers Coding!!!\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // int dp[22][2010];\\n    vector<vector<int>> dp;\\n    \\n    int helper(vector<int>& nums,int target,int n,int index,int sum){\\n        if(index==n){\\n            if(sum==target){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(dp[index][sum+1000]!=-1){\\n            return dp[index][sum+1000];\\n        }\\n        return dp[index][sum+1000]= helper(nums,target,n,index+1,sum+nums[index]) + helper(nums,target,n,index+1,sum);\\n    }\\n    \\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n        if((sum-target)%2!=0){\\n            return 0;\\n        }\\n        int newTarget = (sum-target)/2;\\n        dp.resize(22,vector<int>(2010,-1));\\n        return helper(nums,newTarget,n,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // int dp[22][2010];\\n    vector<vector<int>> dp;\\n    \\n    int helper(vector<int>& nums,int target,int n,int index,int sum){\\n        if(index==n){\\n            if(sum==target){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(dp[index][sum+1000]!=-1){\\n            return dp[index][sum+1000];\\n        }\\n        return dp[index][sum+1000]= helper(nums,target,n,index+1,sum+nums[index]) + helper(nums,target,n,index+1,sum);\\n    }\\n    \\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n        if((sum-target)%2!=0){\\n            return 0;\\n        }\\n        int newTarget = (sum-target)/2;\\n        dp.resize(22,vector<int>(2010,-1));\\n        return helper(nums,newTarget,n,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414225,
                "title": "python-2d-bottom-up-dynamic-programming-solution",
                "content": "Let dp[i][j] denote the number of ways to make j using nums[0]...nums[i]. Since the sums can be negative, we map [-1000, 1000] to [0, 2000] by adding 1000 to each j.\\nThen, similar to the classic stair climbing problem, we can reach dp[i][j] in one step from either dp[i-1][j-nums[i]] or dp[i-1][j+nums[i]]. Therefore, the total number of ways is the sum of these two terms.\\n```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n\\t\\t# initialize dp table\\n        dp = [[0]*(2001) for _ in range(len(nums))]\\n        dp[0][1000+nums[0]] += 1\\n        dp[0][1000-nums[0]] += 1\\n        \\n\\t\\t# state transition function\\n        for i in range(1, len(nums)):\\n            for j in range(2001):\\n                t1 = dp[i-1][j-nums[i]] if j-nums[i] >= 0 else 0\\n                t2 = dp[i-1][j+nums[i]] if j+nums[i] <= 2000 else 0\\n                dp[i][j] = t1+t2\\n\\t\\t\\t\\t\\n\\t\\t# result\\n        return dp[-1][1000+target]\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n\\t\\t# initialize dp table\\n        dp = [[0]*(2001) for _ in range(len(nums))]\\n        dp[0][1000+nums[0]] += 1\\n        dp[0][1000-nums[0]] += 1\\n        \\n\\t\\t# state transition function\\n        for i in range(1, len(nums)):\\n            for j in range(2001):\\n                t1 = dp[i-1][j-nums[i]] if j-nums[i] >= 0 else 0\\n                t2 = dp[i-1][j+nums[i]] if j+nums[i] <= 2000 else 0\\n                dp[i][j] = t1+t2\\n\\t\\t\\t\\t\\n\\t\\t# result\\n        return dp[-1][1000+target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345145,
                "title": "0-1-knapsack-faster-than-89-23-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        \\n        // let\\'s seperate this into two subset of positive and negative numbers according to sign.\\n        // Also the sum of S1 subset and S2 subset will be Sum, (regardless of sign)\\n        // so we can write S2 = sum - s1\\n        // according to question, there difference, S1 - S2 = target\\n        // so S1 - (Sum - S1) = target\\n        // S1 = (target + sum)/2\\n        \\n        int s = 0, sum =0,n = nums.size();\\n        for(int i=0;i<n;i++){\\n            sum+= nums[i];\\n        }\\n        s = target + sum;\\n        if(s % 2 != 0)\\n            return 0;\\n        s = s / 2;    \\n        \\n        // now this is simple 0/1 knapsack problem.\\n        \\n        vector<vector<int>> dp(n+1,vector<int>(s+1,0));\\n        for(int i =0;i<=n;i++){\\n            dp[i][0] = 1;\\n        }\\n        for(int i =1; i<=n;i++){\\n            for(int j =0; j<=s;j++){\\n                if(nums[i-1]<=j){\\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];\\n                }else{\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n            }\\n        }\\n        return dp[n][s];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        \\n        // let\\'s seperate this into two subset of positive and negative numbers according to sign.\\n        // Also the sum of S1 subset and S2 subset will be Sum, (regardless of sign)\\n        // so we can write S2 = sum - s1\\n        // according to question, there difference, S1 - S2 = target\\n        // so S1 - (Sum - S1) = target\\n        // S1 = (target + sum)/2\\n        \\n        int s = 0, sum =0,n = nums.size();\\n        for(int i=0;i<n;i++){\\n            sum+= nums[i];\\n        }\\n        s = target + sum;\\n        if(s % 2 != 0)\\n            return 0;\\n        s = s / 2;    \\n        \\n        // now this is simple 0/1 knapsack problem.\\n        \\n        vector<vector<int>> dp(n+1,vector<int>(s+1,0));\\n        for(int i =0;i<=n;i++){\\n            dp[i][0] = 1;\\n        }\\n        for(int i =1; i<=n;i++){\\n            for(int j =0; j<=s;j++){\\n                if(nums[i-1]<=j){\\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];\\n                }else{\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n            }\\n        }\\n        return dp[n][s];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322662,
                "title": "c-easy-fully-commented-solution-using-dp-approach",
                "content": "Hi,\\nFirst I tried this using backtracking but that gives TLE.\\n\\nApproach - at every index we have 2 choices either add that to  sum or substract that from sum and move to next index.\\nAfter reaching end of array if this sum equals target ```sum==target```  return 1 else return 0.\\n\\n\\n**If this helps please do UPVOTE or if you have any query or doubt COMMENT it below.**\\n\\nThis is recusion code and Memoization code is written after this.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>& nums,int sum,int t,int ind){\\n        int n=nums.size();\\n        if(n==ind){\\n            if(sum==t) return 1;\\n            return 0;\\n        }\\n        int res=0;\\n\\t\\t// if choose plus add that to sum\\n        res+=solve(nums,sum+nums[ind],t,ind+1);\\n\\t\\t// if choose plus add that to sum\\n        res+=solve(nums,sum-nums[ind],t,ind+1);\\n        return res;\\n    }\\n    \\n    \\n    int findTargetSumWays(vector<int>& nums, int t) {\\n        return solve(nums,0,t,0);\\n    }\\n};\\n\\n```\\n\\nMemoization - in this as target can be negative so we can use map or use vector with doing +1000 so minimum value(i.e. -1000) can be 0 and it will not give error.\\n```\\nclass Solution {\\npublic:\\n    int dp[31][2002];\\n    int solve(vector<int>& nums,int sum,int t,int ind){\\n        int n=nums.size();\\n        if(n==ind){\\n            if(sum==t) return 1;\\n            return 0;\\n        }\\n        if(dp[ind][1000+sum]!=-1) return dp[ind][1000+sum];\\n        int res=0;\\n        res+=solve(nums,sum+nums[ind],t,ind+1);\\n        res+=solve(nums,sum-nums[ind],t,ind+1);\\n        return dp[ind][1000+sum] = res;\\n    }\\n    \\n    \\n    int findTargetSumWays(vector<int>& nums, int t) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(nums,0,t,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```sum==target```\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>& nums,int sum,int t,int ind){\\n        int n=nums.size();\\n        if(n==ind){\\n            if(sum==t) return 1;\\n            return 0;\\n        }\\n        int res=0;\\n\\t\\t// if choose plus add that to sum\\n        res+=solve(nums,sum+nums[ind],t,ind+1);\\n\\t\\t// if choose plus add that to sum\\n        res+=solve(nums,sum-nums[ind],t,ind+1);\\n        return res;\\n    }\\n    \\n    \\n    int findTargetSumWays(vector<int>& nums, int t) {\\n        return solve(nums,0,t,0);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[31][2002];\\n    int solve(vector<int>& nums,int sum,int t,int ind){\\n        int n=nums.size();\\n        if(n==ind){\\n            if(sum==t) return 1;\\n            return 0;\\n        }\\n        if(dp[ind][1000+sum]!=-1) return dp[ind][1000+sum];\\n        int res=0;\\n        res+=solve(nums,sum+nums[ind],t,ind+1);\\n        res+=solve(nums,sum-nums[ind],t,ind+1);\\n        return dp[ind][1000+sum] = res;\\n    }\\n    \\n    \\n    int findTargetSumWays(vector<int>& nums, int t) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(nums,0,t,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955210,
                "title": "recursion-to-dp-detailed-explanation-with-code-video-and-diagrams-python",
                "content": "I haven\\'t found anyone with a satisfying explanation on how to convert the recursion approach to the standard bottom up DP approach, so I thought I should share my explanation.\\n**Video explanation as well**: https://www.youtube.com/watch?v=XP2Y2md89h0&ab_channel=ygongcode\\nI also have this explanation in my blog, https://ygongdev.github.io/blog/categories/leetcode/leetcode-494-target-sum\\n# Brute force recursion\\nFor every symbol in `nums`, we can make 2 choices, `+` or `-`. This naturally falls into a tree structure with 2 childrens per parent.\\nIn my approach, I deducted the choice from the `target` at each level of the tree. You can also introduce an extra variable to accumulate the running sum instead of deducting.\\nIf the path from the root of the tree to the leaf gives me a `target` of 0, I know I have successfully found a valid arrangement of choices to reach the `target`, so I can return 1. Else, it is invalid, so I return 0. \\n\\n## Base Case\\nAt the end of `nums` if my remaining `target` is 0, `return` 1 for indicating a good path, 0 otherwise.\\n\\n## Recursion\\nSum of paths from my negative choice and my positive choice at the current index.\\n\\n![image](https://assets.leetcode.com/users/images/5da224a5-f233-4292-97f2-7f147497ccd4_1606775282.710477.png)\\n\\n## Code\\n```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\\n      return self.recursive(nums, 0, S)\\n    \\n    def recursive(self, nums, index, target):\\n      # base case\\n      if index >= len(nums):\\n        return 1 if target == 0 else 0\\n      \\n      # binary decisions\\n      # first choice = positive symbol, deduct from target\\n      # second choice = negative symbol, deduct from target\\n      return self.recursive(nums, index+1, target - nums[index]) + self.recursive(nums, index+1, target + nums[index])\\n```\\n\\n# 2D Dynamic Programming\\nNow I will show you how you can directly convert the above recursive approac into an iterative DP solution.\\nIf you noticed, the above recursion approach has 2 variables that keeps on changing, `index` and `target`\\nThe goal of the DP is to precompute a table of `index` and `target`, so that you can avoid keep branching on sub-problems that you have already solved in the decision tree. Refer to the red color nodes in the diagram above, those sub-problems are being solved more than once, so the table allows to fill in the answer for that sub-problem once and then we can access the solution as many times as we need to without having to re-solve it.\\n\\nTo do this, we need a 2D table consist `index` and `target` values. \\n`index` should be straightforward as it comes straight from the `nums` array, so we only need up to its length.\\n`target` is a bit tricky. Using the given constraints of the problem, we can use `1000` since the sum of `nums` can not exceed `1000`, a target > `1000` will never be possible. However, following the same logic, we can achieve the same constraint by just using `sum` of `nums`. So our `target` is limited from `-sum(nums)` -> `sum(nums)`, `-sum(nums)` is for in case all symbols are negative. In code, I called this `sum(nums)`, `max_limit`\\n\\n![image](https://assets.leetcode.com/users/images/31ba2cbe-8717-4119-80e2-5f0899d184ff_1606776823.143108.png)\\n\\n## Initializing DP table\\nWhen we generate our 2D DP table, we can initialize everything to 0 at first to indicate that there is currently 0 paths from `index` -> `target`.\\nFinally, we need to initialize the table with our base case. If we stay consistent with our recursive approach, we want to fill the equivalent of \\n```\\n if index >= len(nums):\\n        return 1 if target == 0 else 0\\n```\\nin our table.\\nWe can do so by `dp[n][0] = 1`  because if we reached the end of `nums` and `target` is 0, it is a valid path.\\n**BUT WAIT**\\nBecause our table represents negative values as well, e.g `[-3,-2,-1, 0, 1, 2, 3]`, we need to shift our indices, so our indices don\\'t go out of bounds. We\\'ll map it by shifting it by `max_limit`, so it becomes within range of  `[0,1,2,3,4,5,6]`. So we end up with `dp[n][0+max_limit] = 1`\\n\\n## Filling the DP table\\nWhen we fill the table, we want to utilize our initialized values and gradually fill the rest of the table from there.\\nSince we have filled `dp[n][max_limit]` with a useful value, we want to start filling starting from there.\\n```\\n      # iterate from n-1 -> 0\\n      for i in reversed(range(n)):\\n        for j in range(-max_limit, max_limit+1): # e.g, -3 -> 3, if max_limit was 3\\n\\t\\t  # TODO: recursion replacement here\\n```\\nInside the `TODO`, we want to do the exact equivalent of \\n```\\nreturn self.recursive(nums, index+1, target - nums[index]) + self.recursive(nums, index+1, target + nums[index])\\n```\\nso then we have:\\n```\\ndp[i][j] = dp[i+1][j-nums[i] + dp[i+1][j+nums[i]], # j = target, i = index\\n```\\nSee the similarity here? It is a direct translation.\\n**BUT WAIT, WE ARE NOT DONE** \\n\\nRemember how we needed to shift `dp[n][0]`? We need to do the same here.\\n```\\n  centered_j = j + max_limit\\n  # replace j with centered_j\\n  dp[i][centered_j] = dp[i+1][centered_j-nums[i] + dp[i+1][centered_j+nums[i]], # j = target, i = index\\n```\\n\\nAlso because we are iterate throguh the entire `-max_limit` -> `max_limit` of our table, `centered_j + nums[i]` and `centered_j - nums[i]` can easily go out of bounds. However, we can ignore those cases because there is no way for us to reach a `target` that is outside of our limits. So we guard out of bounds access by ` if centered_j + nums[i] >= 0 and centered_j + nums[i] <= 2*max_limit:`  and vice versa for `centered_j - nums[i]` since our table indices for `target` runs from 0 to `2*max_limit+1`.\\n\\nFinally our answer will reside in the equivalent of  \\n```\\nreturn self.recursive(nums, 0, target)\\n```\\n, which is `dp[0][target+max_limit]`, shifted by `max_limit`.\\n\\nWe also need to add a guard for this in case, the `target` exceeds our limits again, so \\n```\\nreturn 0 if target < -max_limit or target > max_limit else dp[0][target + max_limit]\\n```\\n\\n## Code\\n```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\\n      return self.dp(nums, S)\\n    \\n    def dp(self, nums, target):\\n      n = len(nums)\\n      max_limit = sum(nums)\\n      \\n      dp = [[ 0 for i in range(max_limit*2+1) ] for j in range(n+1)]\\n      \\n      # Remember to shift by max_limit to move negative indices to correct indices\\n      dp[n][max_limit] = 1\\n      \\n      # iterate from n-1 -> 0\\n      for i in reversed(range(n)):\\n        for j in range(-max_limit, max_limit+1): # -3 -> 3, if limit was 3\\n          # Remember to shift :D\\n          centered_j = j + max_limit\\n          # Choosing a positive and deducting\\n          negative = centered_j - nums[i]\\n          # Choosing a negative and deducting\\n          positive = centered_j + nums[i]\\n          \\n          # it is possible for out of bounds, but we don\\'t care because we know it is impossible to achieve a target that is outside of our limit\\n          if negative >= 0 and negative <= 2*max_limit:\\n            dp[i][centered_j] += dp[i+1][negative]\\n          if positive >= 0 and positive <= 2*max_limit:\\n            dp[i][centered_j] += dp[i+1][positive]\\n      \\n      # Remember to shift again :D\\n      return 0 if target < -max_limit or target > max_limit else dp[0][target + max_limit]\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\\n      return self.recursive(nums, 0, S)\\n    \\n    def recursive(self, nums, index, target):\\n      # base case\\n      if index >= len(nums):\\n        return 1 if target == 0 else 0\\n      \\n      # binary decisions\\n      # first choice = positive symbol, deduct from target\\n      # second choice = negative symbol, deduct from target\\n      return self.recursive(nums, index+1, target - nums[index]) + self.recursive(nums, index+1, target + nums[index])\\n```\n```\\n if index >= len(nums):\\n        return 1 if target == 0 else 0\\n```\n```\\n      # iterate from n-1 -> 0\\n      for i in reversed(range(n)):\\n        for j in range(-max_limit, max_limit+1): # e.g, -3 -> 3, if max_limit was 3\\n\\t\\t  # TODO: recursion replacement here\\n```\n```\\nreturn self.recursive(nums, index+1, target - nums[index]) + self.recursive(nums, index+1, target + nums[index])\\n```\n```\\ndp[i][j] = dp[i+1][j-nums[i] + dp[i+1][j+nums[i]], # j = target, i = index\\n```\n```\\n  centered_j = j + max_limit\\n  # replace j with centered_j\\n  dp[i][centered_j] = dp[i+1][centered_j-nums[i] + dp[i+1][centered_j+nums[i]], # j = target, i = index\\n```\n```\\nreturn self.recursive(nums, 0, target)\\n```\n```\\nreturn 0 if target < -max_limit or target > max_limit else dp[0][target + max_limit]\\n```\n```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\\n      return self.dp(nums, S)\\n    \\n    def dp(self, nums, target):\\n      n = len(nums)\\n      max_limit = sum(nums)\\n      \\n      dp = [[ 0 for i in range(max_limit*2+1) ] for j in range(n+1)]\\n      \\n      # Remember to shift by max_limit to move negative indices to correct indices\\n      dp[n][max_limit] = 1\\n      \\n      # iterate from n-1 -> 0\\n      for i in reversed(range(n)):\\n        for j in range(-max_limit, max_limit+1): # -3 -> 3, if limit was 3\\n          # Remember to shift :D\\n          centered_j = j + max_limit\\n          # Choosing a positive and deducting\\n          negative = centered_j - nums[i]\\n          # Choosing a negative and deducting\\n          positive = centered_j + nums[i]\\n          \\n          # it is possible for out of bounds, but we don\\'t care because we know it is impossible to achieve a target that is outside of our limit\\n          if negative >= 0 and negative <= 2*max_limit:\\n            dp[i][centered_j] += dp[i+1][negative]\\n          if positive >= 0 and positive <= 2*max_limit:\\n            dp[i][centered_j] += dp[i+1][positive]\\n      \\n      # Remember to shift again :D\\n      return 0 if target < -max_limit or target > max_limit else dp[0][target + max_limit]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832275,
                "title": "java-simple-accepted-solution-2ms-faster-than-96-78-top-down-dp-using-subsetsum",
                "content": "```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int S) {\\n        /// can be divided into  two subsets of negative and potive  that adds upto S\\n        //sum(P) - sum(N) = target\\n//sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)\\n                     //  2 * sum(P) = target + sum(nums)\\n        // so postive sum=(S+ totalsum)/2 must be even \\n        //and we will find total no of ways to get this positive sum\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n        }\\n        // if netsum<target or if newS is not even since all nums are integer return 0\\n        if(sum<S || (S+sum)%2 !=0){\\n            return 0;\\n        }\\n        int newS=(S+sum)/2;\\n        // finding subsets which have sum=newS\\n        int dp[]=new int[newS+1];\\n       // for sum ==0 we have 1 way dont take any element\\n        dp[0]=1;\\n        // rest all 0 prefellid\\n        // top down dp\\n        for(int i=0;i<nums.length;i++){\\n            // j reprents target sum\\n            for(int j=newS;j>=nums[i];j--){\\n                // adding already present ways to the ways if we take that nums[i]\\n                dp[j]=dp[j]+dp[j-nums[i]];\\n            }\\n        }\\n        return dp[newS];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int S) {\\n        /// can be divided into  two subsets of negative and potive  that adds upto S\\n        //sum(P) - sum(N) = target\\n//sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)\\n                     //  2 * sum(P) = target + sum(nums)\\n        // so postive sum=(S+ totalsum)/2 must be even \\n        //and we will find total no of ways to get this positive sum\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n        }\\n        // if netsum<target or if newS is not even since all nums are integer return 0\\n        if(sum<S || (S+sum)%2 !=0){\\n            return 0;\\n        }\\n        int newS=(S+sum)/2;\\n        // finding subsets which have sum=newS\\n        int dp[]=new int[newS+1];\\n       // for sum ==0 we have 1 way dont take any element\\n        dp[0]=1;\\n        // rest all 0 prefellid\\n        // top down dp\\n        for(int i=0;i<nums.length;i++){\\n            // j reprents target sum\\n            for(int j=newS;j>=nums[i];j--){\\n                // adding already present ways to the ways if we take that nums[i]\\n                dp[j]=dp[j]+dp[j-nums[i]];\\n            }\\n        }\\n        return dp[newS];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 829508,
                "title": "simple-c-solution-dynamic-programming-variation-of-0-1-knapsack",
                "content": "```\\n// This problem is just a variation of Count the number of Subsets with a given difference\\n// Points to be considered:-\\n// Sum(S1) - Sum(S2) = diff --------------> 1\\n// Sum(S1) + Sum(S2) = Sum(arr) ----------> 2\\n\\n// Adding 1 & 2\\n\\n// Sum(S1) = ( diff + Sum(arr) ) / 2\\n\\n// Now the problem got reduced to count the number of subsets with given sum i.e. Sum(S1)\\n// Just a variation of 0/1 Knapsack\\n\\n// Important Note for initialisation Part:-\\n\\n/* \\nHere zeros are involved in the array, therefore INITIALISATION part of the code changes a bit. For Example:\\nWhen the given input is arr=[0,0,0,0,1] the 0th column in the t[n+1][Sum+1] matrix will no longer be filled with 1\\'s. The reason is that whenever a particular element in the array arr[i] is encountered to be 0, the number of subsets in that array(till length i) which would give sum =0 would no longer be 1, now in addition to the empty subset we also have a subset {0} which would give subset sum=0. \\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    // Count Subsets with given sum\\n    int CountSubsets(vector<int> &arr,int Sum,int n)\\n    {\\n       int t[n+1][Sum+1]; // 2D array for storing subproblems result\\n\\n       // Base Case initialization\\n       for(int j=0;j<Sum+1;++j)\\n        t[0][j] = 0; // subset sum is not possible for empty array\\n\\n       // for(int i=0;i<n+1;++i)\\n       //  t[i][0] = 1; // Zero sum possible for empty subset\\n       \\n       t[0][0] = 1; // Zero sum possible for empty subset\\n        \\n       for(int i=1;i<n+1;++i)\\n        if(arr[i-1]==0)\\n        {\\n            // For sum 0, Empty subset + subset made by 0 element\\n            // By multiplying pow(2,cnt), it will consider all the subsets of 0 which was               \\n\\t\\t\\t// not considered earlier.\\n            t[i][0]=2*t[i-1][0]; \\n        }\\n                \\n        else\\n        {\\n             t[i][0]=t[i-1][0];\\n        }\\n\\n       for(int i=1;i<n+1;++i)\\n        for(int j=1;j<Sum+1;++j)\\n        {\\n            if(arr[i-1] <= j)\\n                t[i][j] = t[i-1][j-arr[i-1]] + t[i-1][j];\\n            else if(arr[i-1] > j)\\n                t[i][j] = t[i-1][j];\\n        }\\n\\n       return t[n][Sum];\\n    } \\n    \\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        \\n        int SumOfNums = 0;\\n        \\n        for(int i=0;i<nums.size();++i)\\n            SumOfNums = SumOfNums + nums[i];\\n        \\n        // Here S is actually difference\\n        \\n        // We would never get the difference S by partitioning the array into two subsets. \\n        if(SumOfNums < S || (SumOfNums + S)%2 != 0 ) \\n            return 0;\\n        \\n        int SumOfS1 = (SumOfNums + S) / 2; //Derived from formula described at start of code\\n        \\n        int n = nums.size();\\n        \\n        return CountSubsets(nums,SumOfS1,n); \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// This problem is just a variation of Count the number of Subsets with a given difference\\n// Points to be considered:-\\n// Sum(S1) - Sum(S2) = diff --------------> 1\\n// Sum(S1) + Sum(S2) = Sum(arr) ----------> 2\\n\\n// Adding 1 & 2\\n\\n// Sum(S1) = ( diff + Sum(arr) ) / 2\\n\\n// Now the problem got reduced to count the number of subsets with given sum i.e. Sum(S1)\\n// Just a variation of 0/1 Knapsack\\n\\n// Important Note for initialisation Part:-\\n\\n/* \\nHere zeros are involved in the array, therefore INITIALISATION part of the code changes a bit. For Example:\\nWhen the given input is arr=[0,0,0,0,1] the 0th column in the t[n+1][Sum+1] matrix will no longer be filled with 1\\'s. The reason is that whenever a particular element in the array arr[i] is encountered to be 0, the number of subsets in that array(till length i) which would give sum =0 would no longer be 1, now in addition to the empty subset we also have a subset {0} which would give subset sum=0. \\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    // Count Subsets with given sum\\n    int CountSubsets(vector<int> &arr,int Sum,int n)\\n    {\\n       int t[n+1][Sum+1]; // 2D array for storing subproblems result\\n\\n       // Base Case initialization\\n       for(int j=0;j<Sum+1;++j)\\n        t[0][j] = 0; // subset sum is not possible for empty array\\n\\n       // for(int i=0;i<n+1;++i)\\n       //  t[i][0] = 1; // Zero sum possible for empty subset\\n       \\n       t[0][0] = 1; // Zero sum possible for empty subset\\n        \\n       for(int i=1;i<n+1;++i)\\n        if(arr[i-1]==0)\\n        {\\n            // For sum 0, Empty subset + subset made by 0 element\\n            // By multiplying pow(2,cnt), it will consider all the subsets of 0 which was               \\n\\t\\t\\t// not considered earlier.\\n            t[i][0]=2*t[i-1][0]; \\n        }\\n                \\n        else\\n        {\\n             t[i][0]=t[i-1][0];\\n        }\\n\\n       for(int i=1;i<n+1;++i)\\n        for(int j=1;j<Sum+1;++j)\\n        {\\n            if(arr[i-1] <= j)\\n                t[i][j] = t[i-1][j-arr[i-1]] + t[i-1][j];\\n            else if(arr[i-1] > j)\\n                t[i][j] = t[i-1][j];\\n        }\\n\\n       return t[n][Sum];\\n    } \\n    \\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        \\n        int SumOfNums = 0;\\n        \\n        for(int i=0;i<nums.size();++i)\\n            SumOfNums = SumOfNums + nums[i];\\n        \\n        // Here S is actually difference\\n        \\n        // We would never get the difference S by partitioning the array into two subsets. \\n        if(SumOfNums < S || (SumOfNums + S)%2 != 0 ) \\n            return 0;\\n        \\n        int SumOfS1 = (SumOfNums + S) / 2; //Derived from formula described at start of code\\n        \\n        int n = nums.size();\\n        \\n        return CountSubsets(nums,SumOfS1,n); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 624837,
                "title": "python-3-top-down-approach-dp-memoization",
                "content": "```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\\n        memo = {}\\n        def findSum(nums , s):\\n            if (len(nums) , s) in memo:\\n                return memo[(len(nums) , s)]\\n            if not nums:\\n                return 1 if not s else 0\\n            result = findSum(nums[1 : ] , s + nums[0]) + findSum(nums[1 : ] , s - nums[0])\\n            memo[(len(nums) , s)] = result\\n            return result\\n        return findSum(nums , S)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\\n        memo = {}\\n        def findSum(nums , s):\\n            if (len(nums) , s) in memo:\\n                return memo[(len(nums) , s)]\\n            if not nums:\\n                return 1 if not s else 0\\n            result = findSum(nums[1 : ] , s + nums[0]) + findSum(nums[1 : ] , s - nums[0])\\n            memo[(len(nums) , s)] = result\\n            return result\\n        return findSum(nums , S)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350723,
                "title": "python-recursive-using-lru-cache",
                "content": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def findTargetSumWays(self, a: List[int], S: int) -> int:\\n        \\n        L = len(a)\\n        \\n        @lru_cache(None)\\n        def helper(i,S):\\n            if i == L:\\n                if S == 0:\\n                    return 1\\n                else:\\n                    return 0\\n            return helper(i+1,S + a[i]) + helper(i+1,S - a[i])\\n        \\n        return helper(0,S)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def findTargetSumWays(self, a: List[int], S: int) -> int:\\n        \\n        L = len(a)\\n        \\n        @lru_cache(None)\\n        def helper(i,S):\\n            if i == L:\\n                if S == 0:\\n                    return 1\\n                else:\\n                    return 0\\n            return helper(i+1,S + a[i]) + helper(i+1,S - a[i])\\n        \\n        return helper(0,S)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346222,
                "title": "lc494-targetsum-c-dp-top-down-recursive-solution",
                "content": "For a bottom up, space optimized solution please refer to this post - [Java (15 ms) C++ (3 ms) O(ns) iterative DP solution using subset sum with explanation](https://leetcode.com/problems/target-sum/discuss/97334/Java-(15-ms)-C%2B%2B-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanation)\\n\\n```\\nclass Solution {\\n    unordered_map<string, int> lookup;\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        // could be reduced to a subset sum problem\\n        if(nums.size() == 0)\\n            return 0;\\n        \\n        long sum = 0; //to handle a target INT_MAX\\n        for(int n : nums)\\n            sum += n;\\n        \\n        if((S + sum)&1)\\n            return 0;\\n        \\n        return subsetsum(nums, nums.size()-1, (S + sum)/2);\\n    }\\n    \\n    int subsetsum(vector<int> nums, int n, int S){\\n        if(S == 0 && n<0) //to handle cases such as [0,0,0,0,0,1]\\n            return 1;\\n        if(S < 0 || n < 0)\\n            return 0;\\n        \\n        string key = to_string(n)+\"|\"+to_string(S);\\n        if(lookup.find(key) == lookup.end()){\\n            int include = subsetsum(nums, n-1, S - nums[n]);\\n            int exclude = subsetsum(nums, n-1, S);\\n            \\n            lookup[key] = include + exclude;\\n        }\\n        return lookup[key];\\n    }\\n};\\n```\\n\\n\\nThere is a much better solution which looks something like this -\\n\\n```\\n int subsetsum(vector<int> nums, int n, int S){\\n        int dp[S+1] = {0};\\n        dp[0] = 1;\\n        for(int num : nums){\\n            for(int s =S; s >=num; s--)\\n                dp[s] += dp[s - num];\\n        }\\n        return dp[S];\\n    }\\n\\n```\\n\\nThis is a very poweful DP pattern and has following two patterns -\\n\\n*  **If repetition is not allowed, an item could be used only once**\\n\\t```\\n\\tfor (int items : item_list)\\n         for (int i = bag_size; i >= items; i--)\\n             lookup[i] += lookup[i - items];             \\n\\t\\n\\treturn lookup[bag_size]\\n    \\n*    **If repetitions are allowed, an item could be used multiple times**\\n```\\n\\tfor (int items : item_list)\\n         for (int i = items; i <= bag_size; i++)\\n             lookup[i] += lookup[i - items];             \\n\\t\\n\\treturn lookup[bag_size]\\n```\\n\\nFollowing problems could be used for practicing this DP pattern-\\n\\t1. https://leetcode.com/problems/coin-change-2/\\n\\t2. https://leetcode.com/problems/partition-equal-subset-sum/\\n\\t3. https://leetcode.com/problems/target-sum/ (this problem)\\n\\t4. https://leetcode.com/problems/coin-change/ \\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_map<string, int> lookup;\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        // could be reduced to a subset sum problem\\n        if(nums.size() == 0)\\n            return 0;\\n        \\n        long sum = 0; //to handle a target INT_MAX\\n        for(int n : nums)\\n            sum += n;\\n        \\n        if((S + sum)&1)\\n            return 0;\\n        \\n        return subsetsum(nums, nums.size()-1, (S + sum)/2);\\n    }\\n    \\n    int subsetsum(vector<int> nums, int n, int S){\\n        if(S == 0 && n<0) //to handle cases such as [0,0,0,0,0,1]\\n            return 1;\\n        if(S < 0 || n < 0)\\n            return 0;\\n        \\n        string key = to_string(n)+\"|\"+to_string(S);\\n        if(lookup.find(key) == lookup.end()){\\n            int include = subsetsum(nums, n-1, S - nums[n]);\\n            int exclude = subsetsum(nums, n-1, S);\\n            \\n            lookup[key] = include + exclude;\\n        }\\n        return lookup[key];\\n    }\\n};\\n```\n```\\n int subsetsum(vector<int> nums, int n, int S){\\n        int dp[S+1] = {0};\\n        dp[0] = 1;\\n        for(int num : nums){\\n            for(int s =S; s >=num; s--)\\n                dp[s] += dp[s - num];\\n        }\\n        return dp[S];\\n    }\\n\\n```\n```\\n\\tfor (int items : item_list)\\n         for (int i = bag_size; i >= items; i--)\\n             lookup[i] += lookup[i - items];             \\n\\t\\n\\treturn lookup[bag_size]\\n    \\n*    **If repetitions are allowed, an item could be used multiple times**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97411,
                "title": "c-recursive-dfs-with-memorization",
                "content": "Here is use an array of Hash Tables where the index corresponds to the index within your search and each Hash Table uses the target as the key and count as the value.\\n\\nFYI - initially I did not use memorization and it was still AC although with a slow time - bottom 10%.  I added the memorization and the time sped up into the top 25%.\\n\\n```\\n    public int FindTargetSumWays(int[] nums, int S) \\n    {\\n        Dictionary<int,int>[] map = new Dictionary<int,int>[nums.Length];\\n        for (int i = 0; i < nums.Length; i++) map[i] = new Dictionary<int,int>();\\n        \\n        return Find(nums, 0, S, map);\\n    }\\n    \\n    public int Find(int[] nums, int index, int target, Dictionary<int,int>[] map)\\n    {\\n        if (index == nums.Length) return (target == 0) ? 1 : 0;\\n        \\n        if (map[index].ContainsKey(target)) return map[index][target];\\n        \\n        int cnt = Find(nums, index + 1, target - nums[index], map) \\n                    + Find(nums, index + 1, target + nums[index], map);\\n        \\n        map[index][target] = cnt;\\n        return cnt;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int FindTargetSumWays(int[] nums, int S) \\n    {\\n        Dictionary<int,int>[] map = new Dictionary<int,int>[nums.Length];\\n        for (int i = 0; i < nums.Length; i++) map[i] = new Dictionary<int,int>();\\n        \\n        return Find(nums, 0, S, map);\\n    }\\n    \\n    public int Find(int[] nums, int index, int target, Dictionary<int,int>[] map)\\n    {\\n        if (index == nums.Length) return (target == 0) ? 1 : 0;\\n        \\n        if (map[index].ContainsKey(target)) return map[index][target];\\n        \\n        int cnt = Find(nums, index + 1, target - nums[index], map) \\n                    + Find(nums, index + 1, target + nums[index], map);\\n        \\n        map[index][target] = cnt;\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3801663,
                "title": "c-memoization-dp-solution-83-38-beats-12ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& dp,vector<int>& nums, int target, int idx) {\\n        if(idx==nums.size()){   \\n            if(target==0) return 1;\\n            return 0;\\n        }\\n        if(dp[idx][target]!=-1){\\n            return dp[idx][target];\\n        }\\n        int take = 0;\\n        if(target>=nums[idx])\\n            take = solve(dp,nums,target-nums[idx],idx+1);\\n        int nottake = solve(dp,nums,target,idx+1);\\n        return dp[idx][target] = take+nottake;\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum_total = 0;\\n        for(int i=0;i<n;i++){\\n            sum_total += nums[i];\\n        }\\n        int new_target = (target + sum_total);\\n        if(new_target%2!=0 || new_target<0){\\n            return 0;\\n        }\\n        new_target/=2;\\n        vector<vector<int>> dp(n+1,vector<int>(new_target+1,-1));\\n        if(target>sum_total){\\n            return 0;\\n        }\\n        if(n==1){\\n            if(target==nums[0] || target== (-1*nums[0])){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        return solve(dp,nums,new_target,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& dp,vector<int>& nums, int target, int idx) {\\n        if(idx==nums.size()){   \\n            if(target==0) return 1;\\n            return 0;\\n        }\\n        if(dp[idx][target]!=-1){\\n            return dp[idx][target];\\n        }\\n        int take = 0;\\n        if(target>=nums[idx])\\n            take = solve(dp,nums,target-nums[idx],idx+1);\\n        int nottake = solve(dp,nums,target,idx+1);\\n        return dp[idx][target] = take+nottake;\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum_total = 0;\\n        for(int i=0;i<n;i++){\\n            sum_total += nums[i];\\n        }\\n        int new_target = (target + sum_total);\\n        if(new_target%2!=0 || new_target<0){\\n            return 0;\\n        }\\n        new_target/=2;\\n        vector<vector<int>> dp(n+1,vector<int>(new_target+1,-1));\\n        if(target>sum_total){\\n            return 0;\\n        }\\n        if(n==1){\\n            if(target==nums[0] || target== (-1*nums[0])){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        return solve(dp,nums,new_target,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354293,
                "title": "best-c-solution",
                "content": "# Approach\\nDP (Bottom Up Approach) + Space Optimization\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * d)$$\\n\\n- Space complexity:\\n$$O(d)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& arr, int d) {\\n        int n = arr.size();\\n        int totalSum = 0;\\n        for (int i = 0; i < n; i++)\\n            totalSum += arr[i];\\n        if (totalSum - d < 0)\\n            return 0;    \\n        if ((totalSum - d) % 2)\\n            return 0;\\n        int sum = (totalSum - d) / 2; \\n        vector <int> prev(sum+1, 0), cur(sum+1, 0);\\n        if (arr[0] == 0)\\n            prev[0] = 2;\\n        else  \\n            prev[0] = 1;\\n        if (arr[0] != 0 && arr[0] <= sum)    \\n            prev[arr[0]] = 1;\\n        for (int idx = 1; idx < n; idx++) {\\n            for (int target = 0; target <= sum; target++) {\\n                int notTaken = prev[target];\\n                int taken = 0;\\n                if (arr[idx] <= target)\\n                    taken = prev[target-arr[idx]];\\n                cur[target] = (notTaken + taken);\\n            }\\n            prev = cur;\\n        }\\n        return prev[sum];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& arr, int d) {\\n        int n = arr.size();\\n        int totalSum = 0;\\n        for (int i = 0; i < n; i++)\\n            totalSum += arr[i];\\n        if (totalSum - d < 0)\\n            return 0;    \\n        if ((totalSum - d) % 2)\\n            return 0;\\n        int sum = (totalSum - d) / 2; \\n        vector <int> prev(sum+1, 0), cur(sum+1, 0);\\n        if (arr[0] == 0)\\n            prev[0] = 2;\\n        else  \\n            prev[0] = 1;\\n        if (arr[0] != 0 && arr[0] <= sum)    \\n            prev[arr[0]] = 1;\\n        for (int idx = 1; idx < n; idx++) {\\n            for (int target = 0; target <= sum; target++) {\\n                int notTaken = prev[target];\\n                int taken = 0;\\n                if (arr[idx] <= target)\\n                    taken = prev[target-arr[idx]];\\n                cur[target] = (notTaken + taken);\\n            }\\n            prev = cur;\\n        }\\n        return prev[sum];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171862,
                "title": "recursion-to-memoization-in-single-line-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        @lru_cache(None)\\n        def rec(index, cur):\\n            if index == len(nums):\\n                if cur == target:\\n                    return 1\\n                return 0\\n            return rec(index + 1, cur + nums[index]) + rec(index + 1, cur - nums[index])\\n        \\n        return rec(0, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        @lru_cache(None)\\n        def rec(index, cur):\\n            if index == len(nums):\\n                if cur == target:\\n                    return 1\\n                return 0\\n            return rec(index + 1, cur + nums[index]) + rec(index + 1, cur - nums[index])\\n        \\n        return rec(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158716,
                "title": "java-convert-to-a-backpack-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA is adding plus, b is adding minus.\\n  sum(A) - sum(B) = target\\n  sum(A) = target + sum(B)\\n  sum(A) + sum(A) = target + sum(B) + sum(A)\\n  2 * sum(A) = target + sum(nums)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nconverting to a backpack problem\\ndp[i][j] stands for count of ways by picking from i objects to form a j capacity backpack.\\n\\n# Complexity\\n- Time complexity: $$O(nk)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n        int sum = 0;\\n        for (int num : nums) {\\n            sum += num;\\n        }\\n\\n        if (sum < Math.abs(target) || (sum + target) % 2 == 1) {\\n            return 0;\\n        }\\n\\n        // sum(A) - sum(B) = target\\n        // sum(A) = target + sum(B)\\n        // sum(A) + sum(A) = target + sum(B) + sum(A)\\n        // 2 * sum(A) = target + sum(nums)\\n        return subsets(nums, (sum + target) / 2);\\n    }\\n\\n    private int subsets(int[] nums, int sum) {\\n        int n = nums.length;\\n        // int[][] dp = new int[n + 1][sum + 1];\\n        // dp[0][0] = 1;\\n\\n        // for (int i = 1; i <= n; i++) {\\n        //     for (int j = 0; j <= sum; j++) {\\n        //             if (j >= nums[i - 1]) {\\n        //                 dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];\\n        //             } else {\\n        //                 dp[i][j] = dp[i - 1][j];\\n        //             }\\n                    \\n        //     }\\n        // }\\n\\n        // return dp[n][sum];\\n\\n        int[] dp = new int[sum + 1];\\n\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = sum; j >= 0; j--) {\\n                if (j >= nums[i - 1]) {\\n                    dp[j] = dp[j] + dp[j - nums[i - 1]];\\n                } else {\\n                    dp[j] = dp[j];\\n                }\\n            }\\n        }\\n        return dp[sum];\\n    }\\n}\\n\\n\\n// class Solution {\\n//     int result = 0;\\n//     public int findTargetSumWays(int[] nums, int target) {\\n//         backtracking(nums, 0, target, 0);\\n//         return result;\\n//     }\\n\\n//     private void backtracking(int[] nums, int index, int target, int currentSum) {\\n//         if (index == nums.length) {\\n//             if (currentSum == target) {\\n//                 result++;\\n//             }\\n//             return;\\n//         }\\n//         backtracking(nums, index + 1, target, currentSum + nums[index]);\\n//         backtracking(nums, index + 1, target, currentSum - nums[index]);\\n//     }\\n// }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n        int sum = 0;\\n        for (int num : nums) {\\n            sum += num;\\n        }\\n\\n        if (sum < Math.abs(target) || (sum + target) % 2 == 1) {\\n            return 0;\\n        }\\n\\n        // sum(A) - sum(B) = target\\n        // sum(A) = target + sum(B)\\n        // sum(A) + sum(A) = target + sum(B) + sum(A)\\n        // 2 * sum(A) = target + sum(nums)\\n        return subsets(nums, (sum + target) / 2);\\n    }\\n\\n    private int subsets(int[] nums, int sum) {\\n        int n = nums.length;\\n        // int[][] dp = new int[n + 1][sum + 1];\\n        // dp[0][0] = 1;\\n\\n        // for (int i = 1; i <= n; i++) {\\n        //     for (int j = 0; j <= sum; j++) {\\n        //             if (j >= nums[i - 1]) {\\n        //                 dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];\\n        //             } else {\\n        //                 dp[i][j] = dp[i - 1][j];\\n        //             }\\n                    \\n        //     }\\n        // }\\n\\n        // return dp[n][sum];\\n\\n        int[] dp = new int[sum + 1];\\n\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = sum; j >= 0; j--) {\\n                if (j >= nums[i - 1]) {\\n                    dp[j] = dp[j] + dp[j - nums[i - 1]];\\n                } else {\\n                    dp[j] = dp[j];\\n                }\\n            }\\n        }\\n        return dp[sum];\\n    }\\n}\\n\\n\\n// class Solution {\\n//     int result = 0;\\n//     public int findTargetSumWays(int[] nums, int target) {\\n//         backtracking(nums, 0, target, 0);\\n//         return result;\\n//     }\\n\\n//     private void backtracking(int[] nums, int index, int target, int currentSum) {\\n//         if (index == nums.length) {\\n//             if (currentSum == target) {\\n//                 result++;\\n//             }\\n//             return;\\n//         }\\n//         backtracking(nums, index + 1, target, currentSum + nums[index]);\\n//         backtracking(nums, index + 1, target, currentSum - nums[index]);\\n//     }\\n// }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716832,
                "title": "easy-tabulation-with-comments-c-dp",
                "content": "Here we have used the approach of *Subset sum with given target* \\nFor finding the target we have to find out the sum.\\nNow two cases will be there  :-\\n1. If sum is not even then it is never possible to break so *return 0*\\n2. If target is greater than sum then *return 0*\\n\\nMy code is here\\n\\n///\\nclass Solution {\\npublic:\\n\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        target = abs(target);  // make sure to make it positive \\n\\t\\t\\n        int val = accumulate(nums.begin(),nums.end(),0); //To find sum \\n\\t\\t\\n        int sum = (target + val)/2;   //This will be our target sum \\n        \\n        if(((val + target) % 2 != 0) || (target > val)) // if sum is not even and taget > sum\\n            return 0;\\n        \\n        vector<vector<int>> dp(nums.size()+1,vector<int>(sum+1,-1));  // 2D dp matrix\\n        //Intialization\\n        \\n        for(int i = 0 ; i < sum + 1 ; i++)  // Row will be 0 (i.e first row )\\n            dp[0][i] = 0;\\n        for(int i = 0 ; i < nums.size() + 1 ; i++)   // making first col 1 \\n            dp[i][0] = 1;\\n        \\n        //choice dig\\n\\t\\t\\n        for(int i = 1 ; i < nums.size()+1 ; i++)  \\n        {\\n            for(int j = 0 ; j < sum + 1 ; j++)  // Here we\\'ll run the loop from 0 since it will be considered as \\n            {                                                  // potential answer\\n                if(nums[i-1] <= j)\\n                    dp[i][j] = dp[i-1][j-nums[i-1]] + dp[i-1][j];\\n                else\\n                    dp[i][j] = dp[i-1][j];\\n            }\\n        }\\n        \\n        return dp[nums.size()][sum];   // Return the answer\\n    }\\n\\t// UPVOTE BOYS AND BEAUTIFUL GURLSSSSS  ;)\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        target = abs(target);  // make sure to make it positive \\n\\t\\t\\n        int val = accumulate(nums.begin(),nums.end(),0); //To find sum \\n\\t\\t\\n        int sum = (target + val)/2;   //This will be our target sum \\n        \\n        if(((val + target) % 2 != 0) || (target > val)) // if sum is not even and taget > sum\\n            return 0;\\n        \\n        vector<vector<int>> dp(nums.size()+1,vector<int>(sum+1,-1));  // 2D dp matrix\\n        //Intialization\\n        \\n        for(int i = 0 ; i < sum + 1 ; i++)  // Row will be 0 (i.e first row )\\n            dp[0][i] = 0;\\n        for(int i = 0 ; i < nums.size() + 1 ; i++)   // making first col 1 \\n            dp[i][0] = 1;\\n        \\n        //choice dig\\n\\t\\t\\n        for(int i = 1 ; i < nums.size()+1 ; i++)  \\n        {\\n            for(int j = 0 ; j < sum + 1 ; j++)  // Here we\\'ll run the loop from 0 since it will be considered as \\n            {                                                  // potential answer\\n                if(nums[i-1] <= j)\\n                    dp[i][j] = dp[i-1][j-nums[i-1]] + dp[i-1][j];\\n                else\\n                    dp[i][j] = dp[i-1][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2583484,
                "title": "python-easy-to-understand-solution-o-n-t",
                "content": "****# Dp Tabulation (Space Optimization)\\nIf we are given the array as [a,b,c,d,e], we want to place \\u2018+\\u2019 or \\u2018-\\u2019 signs in front of every array element and then add it. One example is :\\n\\n**+a-b-c+d+e which can be written as (+a+d+e) + (-b-c).\\nor +a-b-c+d+e = (a+d+e) - (b+c)\\n\\nIf we say that P=(+a+d+e) and N=(b+c) for this example.\\n+a-b-c+d+e = P - N   ------(i)****\\n\\ntarget= P-N        -------(ii)\\n\\n**totalSum=a+b+c+d+e\\ntotalSum= (+a+d+e)+ (b+c)\\ntotalSum= P+N    -------------(iii)**\\n\\nNow solving for equations (i) and (iii), we can say that \\n\\nN= (totalSum - target)/2\\n\\n**Edge Cases:\\n\\nThe following edge cases need to be handled:\\n\\n1.  As the array elements are positive integers including zero, we don\\u2019t want to find the case when N is negative or we can say    that totSum is lesser than taret, therefore if totSum<target, we simply return 0.\\n2.  N can\\u2019t be a fraction, as all elements are integers, therefore if totSum \\u2013 target is odd, we can return 0. \\n**\\n```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        def new_fun(nums,target):\\n            # Whenever there is case of countin, In base case we return 0 / 1 and after execution we return sum of take and not_take\\n            n=len(nums)\\n            total_sum=sum(nums)\\n            sub_set=total_sum-target\\n            #Edge Case 1\\n            if sub_set<0:\\n                return 0\\n            #Edge Case 2\\n            elif sub_set%2!=0:\\n                return 0\\n            else:\\n                t=sub_set//2 # t represent N\\n                prev=[0]*(t+1)\\n                \\n\\n                for new_target in range(t+1):\\n                    if new_target==0 and nums[0]==0:\\n                        prev[new_target]=2\\n\\n                    elif new_target==0 or new_target==nums[0]:\\n                        prev[new_target]=1\\n\\n                    else:\\n                        prev[new_target]=0\\n                for ind in range(1,n):\\n                    temp=[0]*(t+1)\\n                    for new_target in range (t+1):\\n\\n                        not_take=prev[new_target]\\n                        take=0\\n                        if nums[ind]<=new_target:\\n                            take=prev[new_target-nums[ind]]\\n                        temp[new_target]=(take+not_take)%1000000007  #Very lare may possible\\n                    prev=temp\\n\\n\\n            return prev[t]\\n\\n        return(new_fun(nums,target))\\n```\\n**If you like the solution please upvote it**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        def new_fun(nums,target):\\n            # Whenever there is case of countin, In base case we return 0 / 1 and after execution we return sum of take and not_take\\n            n=len(nums)\\n            total_sum=sum(nums)\\n            sub_set=total_sum-target\\n            #Edge Case 1\\n            if sub_set<0:\\n                return 0\\n            #Edge Case 2\\n            elif sub_set%2!=0:\\n                return 0\\n            else:\\n                t=sub_set//2 # t represent N\\n                prev=[0]*(t+1)\\n                \\n\\n                for new_target in range(t+1):\\n                    if new_target==0 and nums[0]==0:\\n                        prev[new_target]=2\\n\\n                    elif new_target==0 or new_target==nums[0]:\\n                        prev[new_target]=1\\n\\n                    else:\\n                        prev[new_target]=0\\n                for ind in range(1,n):\\n                    temp=[0]*(t+1)\\n                    for new_target in range (t+1):\\n\\n                        not_take=prev[new_target]\\n                        take=0\\n                        if nums[ind]<=new_target:\\n                            take=prev[new_target-nums[ind]]\\n                        temp[new_target]=(take+not_take)%1000000007  #Very lare may possible\\n                    prev=temp\\n\\n\\n            return prev[t]\\n\\n        return(new_fun(nums,target))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777568,
                "title": "easy-dp-memoization-approach-hashmaps",
                "content": "```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n        HashMap<String,Integer> map = new HashMap<String,Integer>();\\n        return helper(nums,target,nums.length-1,map);\\n    }\\n    \\n    public int helper(int[] nums , int target, int index, HashMap<String,Integer> map)\\n    {\\n        if(index==-1)\\n        {\\n            if(target==0) // this is needed as if the target is met before the last Index it should \\n\\t\\t\\t//return length with less that nums.length. Therefore the entire array needs to traversed.\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        if(map.containsKey(index+\"/\"+target)) // DP + Memoization. As many paths would overlap this checks reduces runtime. \\n            return map.get(index+\"/\"+target);\\n        \\n\\t\\t//below we are following a recursive solution to traverse all ways. \\n\\t\\t//Each nums[index] would be either subtracted or added to the target.\\n        int add = helper(nums,target+nums[index],index-1,map);        \\n        int subtract = helper(nums,target-nums[index],index-1,map);\\n        \\n        map.put(index+\"/\"+target,add+subtract);\\n        return add+subtract;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n        HashMap<String,Integer> map = new HashMap<String,Integer>();\\n        return helper(nums,target,nums.length-1,map);\\n    }\\n    \\n    public int helper(int[] nums , int target, int index, HashMap<String,Integer> map)\\n    {\\n        if(index==-1)\\n        {\\n            if(target==0) // this is needed as if the target is met before the last Index it should \\n\\t\\t\\t//return length with less that nums.length. Therefore the entire array needs to traversed.\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        if(map.containsKey(index+\"/\"+target)) // DP + Memoization. As many paths would overlap this checks reduces runtime. \\n            return map.get(index+\"/\"+target);\\n        \\n\\t\\t//below we are following a recursive solution to traverse all ways. \\n\\t\\t//Each nums[index] would be either subtracted or added to the target.\\n        int add = helper(nums,target+nums[index],index-1,map);        \\n        int subtract = helper(nums,target-nums[index],index-1,map);\\n        \\n        map.put(index+\"/\"+target,add+subtract);\\n        return add+subtract;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756098,
                "title": "c-aditya-verma-dp-code-subset-sum-difference-given",
                "content": "Aditya Verma \\n\\n```\\n#define rep(i,n) for(int i=0;i<(n);++i)\\nclass Solution {\\npublic:\\n    \\nint findTargetSumWaysArray(vector<int>& nums, int N , int D )\\n{\\n\\tint sum = 0;\\n    \\n    int zero = 0;\\n    rep(i,N)\\n    {\\n        if(nums[i] == 0) zero++;\\n    }\\n\\n\\tif (D < 0) {D = D * (-1); }\\n\\n\\trep(i, N) sum = sum + nums[i];\\n\\n\\tif ((sum + D) % 2 == 0)\\n\\t{\\n\\t\\tsum = (sum + D) / 2;\\n\\t\\tint t[N + 1][sum + 1];\\n\\n\\t\\trep(i, N + 1)\\n\\t\\t{\\n\\t\\t\\tt[i][0] = 1;\\n\\t\\t}\\n\\n\\t\\tfor (int j = 1 ; j < sum + 1 ; j++)\\n\\t\\t{\\n\\t\\t\\tt[0][j] = 0;\\n\\t\\t}\\n\\n\\n\\t\\tfor (int i = 1; i < N + 1 ; i++)\\n\\t\\t{\\n\\t\\t\\tfor (int j = 1 ; j < sum + 1 ; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (nums[i - 1] <= j && nums[i-1]!=0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tt[i][j] = t[i - 1][j - nums[i - 1]] + t[i - 1][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tt[i][j] = t[i - 1][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\n\\t\\treturn pow(2,zero)*t[N][sum];\\n\\n\\n\\t}\\n\\telse\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\n}\\n\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int N = nums.size();\\n\\treturn findTargetSumWaysArray(nums , N , target);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define rep(i,n) for(int i=0;i<(n);++i)\\nclass Solution {\\npublic:\\n    \\nint findTargetSumWaysArray(vector<int>& nums, int N , int D )\\n{\\n\\tint sum = 0;\\n    \\n    int zero = 0;\\n    rep(i,N)\\n    {\\n        if(nums[i] == 0) zero++;\\n    }\\n\\n\\tif (D < 0) {D = D * (-1); }\\n\\n\\trep(i, N) sum = sum + nums[i];\\n\\n\\tif ((sum + D) % 2 == 0)\\n\\t{\\n\\t\\tsum = (sum + D) / 2;\\n\\t\\tint t[N + 1][sum + 1];\\n\\n\\t\\trep(i, N + 1)\\n\\t\\t{\\n\\t\\t\\tt[i][0] = 1;\\n\\t\\t}\\n\\n\\t\\tfor (int j = 1 ; j < sum + 1 ; j++)\\n\\t\\t{\\n\\t\\t\\tt[0][j] = 0;\\n\\t\\t}\\n\\n\\n\\t\\tfor (int i = 1; i < N + 1 ; i++)\\n\\t\\t{\\n\\t\\t\\tfor (int j = 1 ; j < sum + 1 ; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (nums[i - 1] <= j && nums[i-1]!=0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tt[i][j] = t[i - 1][j - nums[i - 1]] + t[i - 1][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tt[i][j] = t[i - 1][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\n\\t\\treturn pow(2,zero)*t[N][sum];\\n\\n\\n\\t}\\n\\telse\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\n}\\n\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int N = nums.size();\\n\\treturn findTargetSumWaysArray(nums , N , target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697895,
                "title": "simple-dp-with-backtrack-clean-code",
                "content": "```\\nclass Solution {\\n    \\n    int solve(vector<int> &arr,int sum,int id,vector<vector<int>>& dp){\\n        int n=arr.size();\\n        if(id==n) return (sum==0 ? 1:0);\\n        \\n        if(dp[id][sum]!=-1) return dp[id][sum];\\n        \\n        dp[id][sum]=(solve(arr,sum+arr[id],id+1,dp) + solve(arr,abs(sum-arr[id]),id+1,dp));\\n        \\n        return dp[id][sum];\\n    }\\n    \\npublic:\\n    int findTargetSumWays(vector<int>& arr, int sum) {\\n        int n=arr.size();\\n        sum=abs(sum);\\n        \\n        vector<vector<int>> dp(n+1,vector<int>(10001,-1));\\n        \\n        int res=solve(arr,sum,0,dp);\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int solve(vector<int> &arr,int sum,int id,vector<vector<int>>& dp){\\n        int n=arr.size();\\n        if(id==n) return (sum==0 ? 1:0);\\n        \\n        if(dp[id][sum]!=-1) return dp[id][sum];\\n        \\n        dp[id][sum]=(solve(arr,sum+arr[id],id+1,dp) + solve(arr,abs(sum-arr[id]),id+1,dp));\\n        \\n        return dp[id][sum];\\n    }\\n    \\npublic:\\n    int findTargetSumWays(vector<int>& arr, int sum) {\\n        int n=arr.size();\\n        sum=abs(sum);\\n        \\n        vector<vector<int>> dp(n+1,vector<int>(10001,-1));\\n        \\n        int res=solve(arr,sum,0,dp);\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578157,
                "title": "python-clean-simple-dynamic-programming",
                "content": "```\\ndef findTargetSumWays(self, nums: List[int], target: int) -> int:\\n\\tn = len(nums)\\n\\tdp = {}\\n\\tdef dfs(i,target):\\n\\t\\tif (i,target) in dp:\\n\\t\\t\\treturn dp[(i,target)]\\n\\t\\tif i >= n:\\n\\t\\t\\tif target == 0:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 0\\n\\t\\t# sum of 2 ways \\n\\t\\t# 1st way => consider i th index as + nums[i] => ask dfs() to move to next index and reduce the target\\n\\t\\t# 2nd way => consider i th index as - nums[i] => ask dfs() to move to next index and increase the target\\n\\t\\tdp[(i,target)] = dfs(i+1,target - nums[i]) + dfs(i+1,target + nums[i]) \\n\\t\\treturn dp[(i,target)]\\n\\treturn dfs(0,target)\\n\\t# like if you find it useful\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\ndef findTargetSumWays(self, nums: List[int], target: int) -> int:\\n\\tn = len(nums)\\n\\tdp = {}\\n\\tdef dfs(i,target):\\n\\t\\tif (i,target) in dp:\\n\\t\\t\\treturn dp[(i,target)]\\n\\t\\tif i >= n:\\n\\t\\t\\tif target == 0:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 0\\n\\t\\t# sum of 2 ways \\n\\t\\t# 1st way => consider i th index as + nums[i] => ask dfs() to move to next index and reduce the target\\n\\t\\t# 2nd way => consider i th index as - nums[i] => ask dfs() to move to next index and increase the target\\n\\t\\tdp[(i,target)] = dfs(i+1,target - nums[i]) + dfs(i+1,target + nums[i]) \\n\\t\\treturn dp[(i,target)]\\n\\treturn dfs(0,target)\\n\\t# like if you find it useful\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1408795,
                "title": "c-short-and-easy-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> num;\\n    int tar;\\n    int sz;\\n    map<pair<int,int>,int> mp;\\n    int fun(int l,int sum)\\n    {\\n        if(l==sz) return sum==tar;\\n        if(mp.find({l,sum})!=mp.end()) return mp[{l,sum}];\\n        return mp[{l,sum}]=fun(l+1,sum-num[l])+fun(l+1,sum+num[l]);  \\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        num=nums;\\n        tar=target;\\n        sz=num.size();\\n        return fun(0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> num;\\n    int tar;\\n    int sz;\\n    map<pair<int,int>,int> mp;\\n    int fun(int l,int sum)\\n    {\\n        if(l==sz) return sum==tar;\\n        if(mp.find({l,sum})!=mp.end()) return mp[{l,sum}];\\n        return mp[{l,sum}]=fun(l+1,sum-num[l])+fun(l+1,sum+num[l]);  \\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        num=nums;\\n        tar=target;\\n        sz=num.size();\\n        return fun(0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302524,
                "title": "0-1-knapsack-solution-in-c-full-explanation-and-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target)\\n    {\\n        int count = 0,sum = 0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum+nums[i];\\n            if(nums[i]==0) count++;\\n        }\\n        if(target>sum or (target+sum)%2 ) return 0;\\n        int s1 = (target+sum)/2;\\n        int dp[n+1][s1+1];\\n        for(int i=0;i<=n;i++) dp[i][0] = 1;\\n        for(int j=1;j<=s1;j++) dp[0][j] = 0;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=s1;j++){\\n    if(nums[i-1] and  nums[i-1]<=j )dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];\\n             else dp[i][j] = dp[i-1][j];\\n            }\\n        }\\n        return pow(2,count)*dp[n][s1];\\n    }\\n    \\n                   \\n};\\n```\\n\\n* We are given an array, and we are asked to assign + and - signs to the numbers such that the sum is given target.\\n* This question is extension of Count the number of subsets with given difference.\\n* We know the target, and we know the sum of the whole array.\\n* Let me take example, let array nums = [1,1,2,3] and target= 1\\n\\t* How many ways we can divide this array so that the difference of those partitions results 1?\\n\\t* There are three ways namely {1,1,2}-{3} , {1,3}-{1,2} and {1,3}-{1,2} as we have two ones, so one repeats, but it will be counted differently. \\n\\t* Thing is we have to assign +ve sign to the LHS and -ve sign to RHS\\n\\n1. We will get two equations S1-S2 = target-------(1)\\n2. S1+S2 = sum of whole array say sum------(2)\\n3. Adding equation (1) and (2) we will get 2S1 = sum + target \\n4. Solving further, we get S1 = (sum+target)/2\\n5. Now this problem of target sum reduces to finding all such subsets whose subset sum is S1.\\n6. Haha, nice na\\n7. One thing is, Leetcode wants us to also look for edge cases like if we have 0 in our array, then you know that 0 is a very special number in addition, it is the identity element as per group theory on group under addition. so 2^count times we will multiply our final answer, if 0 doesnt occur, 2^count = 1 as count=0.\\n8. Rest is the solution for subset sum which is further variation of 0-1 knapsack problem.\\n9. The edge cases here is if we have sum=0, then in that case, we have solution 1 as not to chose, so fill 1\\'s coloumn by 1. and if we have n=0 in this case, we have no choice,, so we will fill first row as 0 as we cant assign sign to anyone.\\n10. Rest knapsack code is easy to visualise.\\n\\nThanks \\nDo upvote, if you like the solution. :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target)\\n    {\\n        int count = 0,sum = 0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum+nums[i];\\n            if(nums[i]==0) count++;\\n        }\\n        if(target>sum or (target+sum)%2 ) return 0;\\n        int s1 = (target+sum)/2;\\n        int dp[n+1][s1+1];\\n        for(int i=0;i<=n;i++) dp[i][0] = 1;\\n        for(int j=1;j<=s1;j++) dp[0][j] = 0;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=s1;j++){\\n    if(nums[i-1] and  nums[i-1]<=j )dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];\\n             else dp[i][j] = dp[i-1][j];\\n            }\\n        }\\n        return pow(2,count)*dp[n][s1];\\n    }\\n    \\n                   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272226,
                "title": "c-solution-manipulated-into-subset-sum",
                "content": "```\\nint findTargetSumWays(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        \\n        // CORNER CASES\\n        if( sum < target or (sum + target) % 2 != 0)\\n            return 0;\\n        \\n        // MANIPULATION into subset sum\\n        // s1 + s2 = sum\\n        // s1 - s2 = target\\n        // => s1 = (sum+target) / 2\\n        \\n        sum = (sum+target)/2;\\n        \\n        //SUBSET SUM...count instead of TRUE/FALSE...use ADD instead of OR\\n        vector<vector<int>> dp(n+1, vector<int> (sum+1, 0));\\n        \\n        for(int i=0; i<=n; i++)\\n            dp[i][0] = 1;\\n        \\n        for(int i=1; i<=n; i++){\\n            //start j from 0...as nums[] has zeroes in it\\n            for(int j=0; j<=sum; j++){\\n                dp[i][j] = dp[i-1][j];\\n                if(nums[i-1] <= j)\\n                    dp[i][j] += dp[i-1][j-nums[i-1]];\\n            }\\n        }\\n        \\n        return dp[n][sum];\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint findTargetSumWays(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        \\n        // CORNER CASES\\n        if( sum < target or (sum + target) % 2 != 0)\\n            return 0;\\n        \\n        // MANIPULATION into subset sum\\n        // s1 + s2 = sum\\n        // s1 - s2 = target\\n        // => s1 = (sum+target) / 2\\n        \\n        sum = (sum+target)/2;\\n        \\n        //SUBSET SUM...count instead of TRUE/FALSE...use ADD instead of OR\\n        vector<vector<int>> dp(n+1, vector<int> (sum+1, 0));\\n        \\n        for(int i=0; i<=n; i++)\\n            dp[i][0] = 1;\\n        \\n        for(int i=1; i<=n; i++){\\n            //start j from 0...as nums[] has zeroes in it\\n            for(int j=0; j<=sum; j++){\\n                dp[i][j] = dp[i-1][j];\\n                if(nums[i-1] <= j)\\n                    dp[i][j] += dp[i-1][j-nums[i-1]];\\n            }\\n        }\\n        \\n        return dp[n][sum];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1220207,
                "title": "understanding-the-formula-and-logic-in-depth",
                "content": "Hmm, how is everyone in discuss section writing and coming up with solutions and formulas when I am stuck here not able to think?. Upon digging up some internet resources, I found few clues. Sharing them with you today:\\nPre-requisite- https://leetcode.com/problems/partition-equal-subset-sum/\\n\\nAfter you have done the above stated question, now let us understand how this question boils down to that logic and how is it related to 0-1 knapsack logic?\\n\\nlet us say we have n=5 integers and we assign -ve sign to 3 integers and +ve sign to 2 integers for getting the final answer as target. The total sum = S and now it is safe to say that S = a1+a2+a3+a4+a5 (5 array elements). Suppose, the 3 numbers with negative signs are a1,a2 and a3. Also, suppose I have assigned +ve sign to a4 and a5. Now, the equation would be something like : target = -a1-a2-a3+a4+a5. Makes sense? So, we now agree that we can take -ve sign common and the equation would become something like:\\n```\\nTarget = a4+a5-(a1+a2+a3)\\n```\\nHmm, sounds fair enough, we are just dividing our sum into 2 parts, one part contains numbers with positive signs and the other contains numbers with negative signs. \\n\\nNow, let us call a4+a5 as S1 and a1+a2+a3 as S2 for the sake of simplicity,\\n```\\ntarget = S1-S2\\n```\\nthis equation makes sense. Let it be equation 1.\\nNow, is it also true that S was the sum of all the elements of array? Yes, it is!. So, I can write it as :\\n```\\nS = a1+a2+a3+a4+a5\\n```\\nor\\n```\\nS = S1 + S2\\n```\\nlet us call this eqn2. Now, it all boils down to simple math, i.e. when we add eqn1 and eqn2 the final answer left is:\\n```\\ntarget + S = 2S1\\n```\\nI am given target in the question itself and S can be found out, hence I can easily find out S1. Solving for the test case given in leetcode:\\nnums = [1,1,1,1,1], target = 3\\nS = 5\\ntarget+S = 2S1\\n3+5 = 2S1\\nS1 = 4.\\nputting this in eqn 1 we have, S2 = 5.\\n\\nVoila, we have our 2 sums. But what should we do now with them? look carefully, the question now becomes \"find the number of subsets having sum = 4 i.e. S1\". If we find such subsets, S2 will automatically be 5!.\\n\\nThis question now boiled down to \"equal sum partition problem\" which is based on 0-1 knapsack. \\nPhew!. It was a long way till here. Dp is not always about thinking hard and studying hard, it is based on recognizing common patterns and I hope this explanation makes it clear how 0-1 knapsack can be used here. \\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nTarget = a4+a5-(a1+a2+a3)\\n```\n```\\ntarget = S1-S2\\n```\n```\\nS = a1+a2+a3+a4+a5\\n```\n```\\nS = S1 + S2\\n```\n```\\ntarget + S = 2S1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1212967,
                "title": "java-backtrack-dp-solution-easy-short-solutions",
                "content": "**DFS/Backtrack:**\\n```\\nclass Solution {\\n    int count=0;\\n    public int findTargetSumWays(int[] nums, int target) {\\n        if(nums==null || nums.length==0) return 0;\\n        dfs(nums,target,0,0);\\n        return count;\\n    }\\n    \\n    public void dfs(int nums[],int target,int index,int currSum){\\n        if(index==nums.length){\\n            if(currSum==target) count++;\\n            return;\\n        }\\n        \\n        dfs(nums,target,index+1,currSum+nums[index]);\\n        dfs(nums,target,index+1,currSum-nums[index]);\\n    }\\n}\\n```\\n\\n\\n\\n**DP:**\\n```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n        //Since we will have negative values & Indexes can\\'t be negative. Therefore, using shifting!\\n        \\n        int origin=1000;\\n        int dp[][]=new int [nums.length+1][2001];\\n        dp[0][origin+0]=1;\\n        \\n        for(int i=1;i<dp.length;i++){\\n            for(int j=0;j<dp[0].length;j++){\\n                if(dp[i-1][j]>0){\\n                    dp[i][j+nums[i-1]]+=dp[i-1][j];\\n                    dp[i][j-nums[i-1]]+=dp[i-1][j];\\n                }\\n            }\\n        }\\n        return dp[nums.length][origin+target];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int count=0;\\n    public int findTargetSumWays(int[] nums, int target) {\\n        if(nums==null || nums.length==0) return 0;\\n        dfs(nums,target,0,0);\\n        return count;\\n    }\\n    \\n    public void dfs(int nums[],int target,int index,int currSum){\\n        if(index==nums.length){\\n            if(currSum==target) count++;\\n            return;\\n        }\\n        \\n        dfs(nums,target,index+1,currSum+nums[index]);\\n        dfs(nums,target,index+1,currSum-nums[index]);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n        //Since we will have negative values & Indexes can\\'t be negative. Therefore, using shifting!\\n        \\n        int origin=1000;\\n        int dp[][]=new int [nums.length+1][2001];\\n        dp[0][origin+0]=1;\\n        \\n        for(int i=1;i<dp.length;i++){\\n            for(int j=0;j<dp[0].length;j++){\\n                if(dp[i-1][j]>0){\\n                    dp[i][j+nums[i-1]]+=dp[i-1][j];\\n                    dp[i][j-nums[i-1]]+=dp[i-1][j];\\n                }\\n            }\\n        }\\n        return dp[nums.length][origin+target];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966126,
                "title": "simple-easy-dp-top-down-soln-exact-same-problem-like-count-no-of-subsets-with-a-given-diff",
                "content": "int findTargetSumWays(vector<int>& arr, int s) {\\n        \\n        int sum=0;\\n        int n=arr.size();\\n        int count_zero=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=arr[i];\\n            if(arr[i]==0)\\n                count_zero++;\\n        }\\n        if(s>sum)\\n        {\\n            return 0;\\n        }\\n        if((s+sum)%2!=0)\\n            return 0;\\n        int subset1_sum=(s+sum)/2;\\n        int dp[n+1][subset1_sum+1];\\n        for(int i=0;i<n+1;i++)\\n        {\\n            for(int j=0;j<subset1_sum+1;j++)\\n            {\\n                if(i==0)\\n                    dp[i][j]=0;\\n                if(j==0)\\n                    dp[i][j]=1;\\n            }\\n        }\\n        for(int i=1;i<n+1;i++)\\n        {\\n            for(int j=1;j<subset1_sum+1;j++)\\n            {\\n                if(arr[i-1]==0)\\n                {\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n               else if(arr[i-1]<=j)\\n                {\\n                    dp[i][j]=dp[i-1][j-arr[i-1]] + dp[i-1][j];\\n                }\\n                \\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        return (int)pow(2,count_zero)*dp[n][subset1_sum];\\n        \\n        \\n        \\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "int findTargetSumWays(vector<int>& arr, int s) {\\n        \\n        int sum=0;\\n        int n=arr.size();\\n        int count_zero=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=arr[i];\\n            if(arr[i]==0)\\n                count_zero++;\\n        }\\n        if(s>sum)\\n        {\\n            return 0;\\n        }\\n        if((s+sum)%2!=0)\\n            return 0;\\n        int subset1_sum=(s+sum)/2;\\n        int dp[n+1][subset1_sum+1];\\n        for(int i=0;i<n+1;i++)\\n        {\\n            for(int j=0;j<subset1_sum+1;j++)\\n            {\\n                if(i==0)\\n                    dp[i][j]=0;\\n                if(j==0)\\n                    dp[i][j]=1;\\n            }\\n        }\\n        for(int i=1;i<n+1;i++)\\n        {\\n            for(int j=1;j<subset1_sum+1;j++)\\n            {\\n                if(arr[i-1]==0)\\n                {\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n               else if(arr[i-1]<=j)\\n                {\\n                    dp[i][j]=dp[i-1][j-arr[i-1]] + dp[i-1][j];\\n                }\\n                \\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        return (int)pow(2,count_zero)*dp[n][subset1_sum];\\n        \\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 936652,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<int>& nums, int idx, int& num, double target) {\\n        if (idx == nums.size() && target == 0)  num++;\\n        if (idx == nums.size()) return;\\n        dfs(nums, idx + 1, num, target - nums[idx]);\\n        dfs(nums, idx + 1, num, target + nums[idx]);   \\n        \\n        return;\\n    }\\n    \\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        int num = 0;\\n        dfs(nums, 0, num, S);\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<int>& nums, int idx, int& num, double target) {\\n        if (idx == nums.size() && target == 0)  num++;\\n        if (idx == nums.size()) return;\\n        dfs(nums, idx + 1, num, target - nums[idx]);\\n        dfs(nums, idx + 1, num, target + nums[idx]);   \\n        \\n        return;\\n    }\\n    \\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        int num = 0;\\n        dfs(nums, 0, num, S);\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865315,
                "title": "intutive-c-sol-with-explanation-dp",
                "content": "```\\n\\n/*\\n    It is a very simple problem and it has a simple dp condition which is\\n\\tdp[i][sum] = dp[i+1][sum-nums[i]] + dp[i+1][sum+nums[i]].\\n    Now the only issue is that sum - nums[i] may become less than 0 at some point.\\n\\tSo the minimum possible value is -1000 (as sum of all elements is less than 1000).\\n\\tSo we will add a buffer of 1000 to our sum so that even if the worst case is encountered,\\n\\tstill our index doesn\\'t become negative. So  0 <= sum +1000 <= 2000 (our updated range).\\n    Now we have to create our new target, which will be, Target = 1000 + Target. So the simple base condtion would be\\n    if sum == Target and i == nums.size() return 1. And the we will use dp to reduce the time complexity. Also initally we can \\n    have a check whether the target > 1000 || target < -1000 and can directly return 0.  \\n\\t\\n                                                Upvote if you like the solution. \\n\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    int target;\\n    int dp[20][2001];\\n    \\n    int findTarget(vector<int>& nums, int i, int sum)\\n    {\\n        if(sum == target && i == nums.size())\\n            return 1;\\n        \\n        if(i >= nums.size()) return 0;\\n        \\n        if(dp[i][sum] != -1)\\n            return dp[i][sum];\\n\\n        dp[i][sum] = findTarget(nums, i+1, (sum - nums[i])) + findTarget(nums, i+1, (sum + nums[i]));\\n        return dp[i][sum];\\n    }\\n    \\n    \\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        \\n        if(S > 1000 || S < -1000)\\n            return 0;\\n        \\n        target = 1000 + S;\\n        \\n        for(int i = 0; i<nums.size(); i++)\\n            for(int j = 0; j<=2000; j++)\\n                dp[i][j] = -1;\\n        \\n        return findTarget(nums, 0, 1000);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n/*\\n    It is a very simple problem and it has a simple dp condition which is\\n\\tdp[i][sum] = dp[i+1][sum-nums[i]] + dp[i+1][sum+nums[i]].\\n    Now the only issue is that sum - nums[i] may become less than 0 at some point.\\n\\tSo the minimum possible value is -1000 (as sum of all elements is less than 1000).\\n\\tSo we will add a buffer of 1000 to our sum so that even if the worst case is encountered,\\n\\tstill our index doesn\\'t become negative. So  0 <= sum +1000 <= 2000 (our updated range).\\n    Now we have to create our new target, which will be, Target = 1000 + Target. So the simple base condtion would be\\n    if sum == Target and i == nums.size() return 1. And the we will use dp to reduce the time complexity. Also initally we can \\n    have a check whether the target > 1000 || target < -1000 and can directly return 0.  \\n\\t\\n                                                Upvote if you like the solution. \\n\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    int target;\\n    int dp[20][2001];\\n    \\n    int findTarget(vector<int>& nums, int i, int sum)\\n    {\\n        if(sum == target && i == nums.size())\\n            return 1;\\n        \\n        if(i >= nums.size()) return 0;\\n        \\n        if(dp[i][sum] != -1)\\n            return dp[i][sum];\\n\\n        dp[i][sum] = findTarget(nums, i+1, (sum - nums[i])) + findTarget(nums, i+1, (sum + nums[i]));\\n        return dp[i][sum];\\n    }\\n    \\n    \\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        \\n        if(S > 1000 || S < -1000)\\n            return 0;\\n        \\n        target = 1000 + S;\\n        \\n        for(int i = 0; i<nums.size(); i++)\\n            for(int j = 0; j<=2000; j++)\\n                dp[i][j] = -1;\\n        \\n        return findTarget(nums, 0, 1000);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757205,
                "title": "must-read-how-to-approach-it-detailed-explanation-step-by-step-cpp",
                "content": "**BASIC INTUITION :**\\nIf we first see this problem, only thing that strikes our brain if try all possible combinations like:\\n\\n1-1-1+1+1.... \\nBut, if you observe if we have N number then for each Number we have 2 signs to consider ie + and -, which gives total combinations of 2^n and then  you will check if we computation result == target do count++ else Not.\\n\\nNow, we observe carefully and if we have done enough backtracking problem we would observe that it is just asking the number of ways not like to print all the ways and all, \\n\\nSo, Only thing the strikes our mind is to USE DP. :P   [ Atleast it striked mine ].\\nThen,\\nI thought okay if we could group all numbers into 2 sets :\\n\\n1.  Positive [ which will be positive ].\\n2.  Negative [ which will be negative ].\\n\\nThen we can say                set1 - ( set2 ) ==target.\\n          But we Also Know:  set1 + ( set2 ) == sum of all elements of given array.\\n\\t\\t  Add both equations above:\\n\\t\\t                   2*(set1)= target + sum.\\n\\t\\t\\t\\t\\t\\t   set1      = (target + sum)/2; \\n\\t\\t\\t\\t\\t\\t   \\nwhich instantly tells me if i can know how many subsets are there whose sum is == \\t\\t\\t\\t\\t\\t    (target + sum)/2; \\n\\t\\t\\nI am Literally Done. right.\\nThen question comes to my How do I find the Number of Subsets given a particular array and a target Sum.\\n\\t\\t\\nFor that I wrote the Code First. [ I told you, in previous post too, go in a systematic Manner ].\\n\\t\\t\\t\\t\\t\\t\\t\\t   set1      = (target + sum)/2; \\n\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\n![image](https://assets.leetcode.com/users/images/53f346f1-859b-48ad-b659-f3f09c7627a4_1595782149.815725.png)\\n\\n\\n\\nThen, only thing left to solve the given question was to find the Number of subsets with sum == (target + total sum )/2;\\n\\n\\n\\nLook at my Code : \\n\\n```\\n int findTargetSumWays(vector<int>& nums, int s) {\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        return sum < s || (s + sum) & 1 ? 0 : subsetSum(nums, (s + sum) >> 1); \\n    }   \\n\\n    int subsetSum(vector<int>& nums, int s) {\\n        int dp[s + 1] = { 0 };\\n        dp[0] = 1;\\n        for (int n : nums)\\n            for (int i = s; i >= n; i--)\\n                dp[i] += dp[i - n];\\n        return dp[s];\\n    }\\n\\t\\n\\t\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "**BASIC INTUITION :**\\nIf we first see this problem, only thing that strikes our brain if try all possible combinations like:\\n\\n1-1-1+1+1.... \\nBut, if you observe if we have N number then for each Number we have 2 signs to consider ie + and -, which gives total combinations of 2^n and then  you will check if we computation result == target do count++ else Not.\\n\\nNow, we observe carefully and if we have done enough backtracking problem we would observe that it is just asking the number of ways not like to print all the ways and all, \\n\\nSo, Only thing the strikes our mind is to USE DP. :P   [ Atleast it striked mine ].\\nThen,\\nI thought okay if we could group all numbers into 2 sets :\\n\\n1.  Positive [ which will be positive ].\\n2.  Negative [ which will be negative ].\\n\\nThen we can say                set1 - ( set2 ) ==target.\\n          But we Also Know:  set1 + ( set2 ) == sum of all elements of given array.\\n\\t\\t  Add both equations above:\\n\\t\\t                   2*(set1)= target + sum.\\n\\t\\t\\t\\t\\t\\t   set1      = (target + sum)/2; \\n\\t\\t\\t\\t\\t\\t   \\nwhich instantly tells me if i can know how many subsets are there whose sum is == \\t\\t\\t\\t\\t\\t    (target + sum)/2; \\n\\t\\t\\nI am Literally Done. right.\\nThen question comes to my How do I find the Number of Subsets given a particular array and a target Sum.\\n\\t\\t\\nFor that I wrote the Code First. [ I told you, in previous post too, go in a systematic Manner ].\\n\\t\\t\\t\\t\\t\\t\\t\\t   set1      = (target + sum)/2; \\n\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\n![image](https://assets.leetcode.com/users/images/53f346f1-859b-48ad-b659-f3f09c7627a4_1595782149.815725.png)\\n\\n\\n\\nThen, only thing left to solve the given question was to find the Number of subsets with sum == (target + total sum )/2;\\n\\n\\n\\nLook at my Code : \\n\\n```\\n int findTargetSumWays(vector<int>& nums, int s) {\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        return sum < s || (s + sum) & 1 ? 0 : subsetSum(nums, (s + sum) >> 1); \\n    }   \\n\\n    int subsetSum(vector<int>& nums, int s) {\\n        int dp[s + 1] = { 0 };\\n        dp[0] = 1;\\n        for (int n : nums)\\n            for (int i = s; i >= n; i--)\\n                dp[i] += dp[i - n];\\n        return dp[s];\\n    }\\n\\t\\n\\t\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 734697,
                "title": "c-dp-subset-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n    int l=nums.size();\\n        long sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum=sum+nums[i];\\n        }\\n    \\n        long int  val=sum+S;\\n        long int copy=val;\\n        val=val/2;\\n    \\n       if(val>sum)\\n            return 0;\\n        if(copy!=val*2)// equal parition [s1,s2 in term of sum ] not possible \\n            return 0;\\n        vector<vector<int>>t(l+1,vector<int>(val+1,0));\\n        for(int j=0;j<=val;j++)\\n            t[0][j]=0;\\n        int count=0;\\n        t[0][0]=1;;\\n        for(int i=1;i<=l;i++)\\n        {\\n            if(nums[i-1]==0)\\n                count++;\\n             t[i][0]=pow(2,count);\\n        }\\n           \\n        \\n     for(int i=1;i<=l;i++)\\n     {\\n         for(int j=1;j<=val;j++)\\n         {\\n              if(nums[i-1]<=j)\\n    {\\n        t[i][j]=t[i-1][j]+t[i-1][j-nums[i-1]];\\n    }\\n        else\\n            t[i][j]=t[i-1][j];\\n        \\n        \\n         }\\n     }\\n        \\n        return t[l][val];\\n       \\n    }\\n};\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n    int l=nums.size();\\n        long sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum=sum+nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 600188,
                "title": "java-dp-solution-using-subset-sum",
                "content": "```\\nclass Solution {\\n    \\n    private int count_subset_sum(int weight[], int W, int n){\\n        int dp[][] = new int[n+1][W+1];\\n\\n        dp[0][0] = 1;\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<=W;j++){\\n                \\n                if(weight[i-1] > j) dp[i][j] = dp[i-1][j];\\n                else dp[i][j] = dp[i-1][j] + dp[i-1][j-weight[i-1]];\\n            }\\n        }\\n        return dp[n][W];\\n    }\\n    \\n    public int findTargetSumWays(int[] nums, int S) {\\n        int n = nums.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n            sum+=nums[i];\\n        int w = (sum+S)/2;\\n        if (S > sum) return 0;\\n        if ((S + sum) % 2 != 0) return 0;\\n        return count_subset_sum(nums,w,n);        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private int count_subset_sum(int weight[], int W, int n){\\n        int dp[][] = new int[n+1][W+1];\\n\\n        dp[0][0] = 1;\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<=W;j++){\\n                \\n                if(weight[i-1] > j) dp[i][j] = dp[i-1][j];\\n                else dp[i][j] = dp[i-1][j] + dp[i-1][j-weight[i-1]];\\n            }\\n        }\\n        return dp[n][W];\\n    }\\n    \\n    public int findTargetSumWays(int[] nums, int S) {\\n        int n = nums.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n            sum+=nums[i];\\n        int w = (sum+S)/2;\\n        if (S > sum) return 0;\\n        if ((S + sum) % 2 != 0) return 0;\\n        return count_subset_sum(nums,w,n);        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 591661,
                "title": "java-dp-memoization-solution-plane-recursion-simple-dfs",
                "content": "# Plane Recursion AC (670 ms)\\n```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int s) {\\n        return  find(nums.length-1, s, nums);\\n    }\\n    static int find(int n, int s, int ar[]){\\n        \\n        if( n == -1 && s == 0)   return 1;\\n\\n        if( n <= -1 )   return 0;\\n    \\n        return find(n-1, s-ar[n], ar) + find(n-1, s+ar[n], ar);\\n    }\\n}\\n```\\n\\n\\n# Recursion with Memoization 155 ms\\n```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int s) {\\n        Map<String, Integer> map = new HashMap();\\n        \\n        return  find(nums.length-1, s, nums, map);\\n    }\\n    static int find( int n, int s, int ar[], Map<String, Integer> map ){\\n        \\n        if( n == -1 && s == 0)   return 1;\\n\\n        if( n <= -1 )   return 0;\\n    \\n        if(  map.containsKey(n +\" \"+ s) )\\n            return map.get(n +\" \"+ s);\\n        \\n        int ans1 = find(n-1, s-ar[n], ar, map);\\n        int ans2 = find(n-1, s+ar[n], ar, map);\\n        \\n        map.put(n+\" \"+s, (ans1 + ans2)  ); \\n        \\n        return (ans1 + ans2);\\n        \\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int s) {\\n        return  find(nums.length-1, s, nums);\\n    }\\n    static int find(int n, int s, int ar[]){\\n        \\n        if( n == -1 && s == 0)   return 1;\\n\\n        if( n <= -1 )   return 0;\\n    \\n        return find(n-1, s-ar[n], ar) + find(n-1, s+ar[n], ar);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int s) {\\n        Map<String, Integer> map = new HashMap();\\n        \\n        return  find(nums.length-1, s, nums, map);\\n    }\\n    static int find( int n, int s, int ar[], Map<String, Integer> map ){\\n        \\n        if( n == -1 && s == 0)   return 1;\\n\\n        if( n <= -1 )   return 0;\\n    \\n        if(  map.containsKey(n +\" \"+ s) )\\n            return map.get(n +\" \"+ s);\\n        \\n        int ans1 = find(n-1, s-ar[n], ar, map);\\n        int ans2 = find(n-1, s+ar[n], ar, map);\\n        \\n        map.put(n+\" \"+s, (ans1 + ans2)  ); \\n        \\n        return (ans1 + ans2);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583934,
                "title": "top-down-dp",
                "content": "```\\nAssuming S = +a-b-c+d = (a + d) - (b + c),\\n\\nwe define sum1 = a + d, sum2 = b + c, then sum1 - sum2 = S\\n\\nSince sum1 + sum2 = sum(a + b + c + d), sum1 = (S + sum) / 2\\n```\\n\\nThen the problem becomes count the subset sum, which adapts to 0/1 knapsack pattern.\\n****\\n```\\n    public int findTargetSumWays(int[] nums, int S) {\\n        int sum = 0;\\n        for (int num : nums)\\n            sum += num;\\n        \\n        if ((S + sum) % 2 != 0)\\n            return 0;\\n        \\n        Map<String, Integer> memo = new HashMap<>();\\n        return countSubsetSumWays(nums, 0, (S + sum) / 2, memo);\\n    }\\n    \\n    \\n    private int countSubsetSumWays(int[] nums, int i, int s, Map<String, Integer> memo) {\\n        if (i == nums.length)\\n            return s == 0 ? 1 : 0;\\n        \\n        String key = i + \" \" + s;\\n        \\n        if (memo.containsKey(key))\\n            return memo.get(key);\\n        \\n        memo.put(\\n            key,\\n            countSubsetSumWays(nums, i + 1, s - nums[i], memo) \\n            + countSubsetSumWays(nums, i + 1, s, memo)\\n        );\\n        \\n        return memo.get(key);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nAssuming S = +a-b-c+d = (a + d) - (b + c),\\n\\nwe define sum1 = a + d, sum2 = b + c, then sum1 - sum2 = S\\n\\nSince sum1 + sum2 = sum(a + b + c + d), sum1 = (S + sum) / 2\\n```\n```\\n    public int findTargetSumWays(int[] nums, int S) {\\n        int sum = 0;\\n        for (int num : nums)\\n            sum += num;\\n        \\n        if ((S + sum) % 2 != 0)\\n            return 0;\\n        \\n        Map<String, Integer> memo = new HashMap<>();\\n        return countSubsetSumWays(nums, 0, (S + sum) / 2, memo);\\n    }\\n    \\n    \\n    private int countSubsetSumWays(int[] nums, int i, int s, Map<String, Integer> memo) {\\n        if (i == nums.length)\\n            return s == 0 ? 1 : 0;\\n        \\n        String key = i + \" \" + s;\\n        \\n        if (memo.containsKey(key))\\n            return memo.get(key);\\n        \\n        memo.put(\\n            key,\\n            countSubsetSumWays(nums, i + 1, s - nums[i], memo) \\n            + countSubsetSumWays(nums, i + 1, s, memo)\\n        );\\n        \\n        return memo.get(key);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 557008,
                "title": "c-o-n-2-2-n-2-brutforce-with-bit-manipulation-meet-in-the-middle",
                "content": "Brutforce all possible combinations of expression using bit-represenation of array like 0 - minus, 1 - plus. So there are ```2^n``` combinations.\\n\\nEx: ```[1,1,1,1,1]``` one of the possible combination 4 = 00100 in a binary, which means => ```-1-1+1-1-1```\\n\\nHere I am trying to divide array for two subarrays. \\n\\nThen find all possbile sums from first half of array and put it in a map. \\nKey - possible sum, Value - how many times it occures in first half of array.\\n\\nAfter that, I itterate throw all possible combination of second part of array and find all possible ```sum```. \\nIf ```target-sum``` is exist in a map. We add value of that key to the answer. \\n\\nTime complexity ```O(n/2*2^(n/2))```, n - the number of elements in array.\\nSpace complexity ```O(m)```, m - the number of different sums.\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        map<ll,int> m;\\n        ll n = nums.size(), ans=0, sum, k;\\n        \\n        for (int i=0; i<(1<<(n-n/2)); i++){\\n            sum=0;\\n            for (int j=0; j<n-n/2; j++){\\n                if (((i>>j)&1)==1) sum+=nums[j];\\n                else sum-=nums[j];\\n            }\\n            m[sum]++;\\n        }\\n        \\n        for (int i=0; i<(1<<n/2); i++){\\n            sum=0;\\n            for (int j=0; j<n/2; j++){\\n                if (((i>>j)&1)==1) sum+=nums[n-1-j];\\n                else sum-=nums[n-1-j];\\n            }\\n            k = S-sum;\\n            ans+=m[k];\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```2^n```\n```[1,1,1,1,1]```\n```-1-1+1-1-1```\n```sum```\n```target-sum```\n```O(n/2*2^(n/2))```\n```O(m)```\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        map<ll,int> m;\\n        ll n = nums.size(), ans=0, sum, k;\\n        \\n        for (int i=0; i<(1<<(n-n/2)); i++){\\n            sum=0;\\n            for (int j=0; j<n-n/2; j++){\\n                if (((i>>j)&1)==1) sum+=nums[j];\\n                else sum-=nums[j];\\n            }\\n            m[sum]++;\\n        }\\n        \\n        for (int i=0; i<(1<<n/2); i++){\\n            sum=0;\\n            for (int j=0; j<n/2; j++){\\n                if (((i>>j)&1)==1) sum+=nums[n-1-j];\\n                else sum-=nums[n-1-j];\\n            }\\n            k = S-sum;\\n            ans+=m[k];\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491220,
                "title": "javascript-simple-dfs",
                "content": "This isn\\'t the best solution out there but I found this problem under the **Stack** exploration and so this is my callstack solution.\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} S\\n * @return {number}\\n */\\nvar findTargetSumWays = function(nums, S) {\\n    let currSum = 0;\\n    let ways = dfs(currSum, nums, S, 0);\\n    return ways;\\n};\\n\\nfunction dfs(currSum, nums, S, currIdx) {\\n\\t// check to see that we have gone through the entire array\\n    if(currIdx === nums.length) {\\n        return currSum === S ? 1 : 0;\\n    } else if (currIdx < nums.length) {\\n\\t\\t// calculate the values of \\'+\\' and \\'-\\'\\n        let left = currSum + nums[currIdx];\\n        let right = currSum - nums[currIdx];\\n        return dfs(left, nums, S, currIdx + 1) + dfs(right, nums, S, currIdx + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} S\\n * @return {number}\\n */\\nvar findTargetSumWays = function(nums, S) {\\n    let currSum = 0;\\n    let ways = dfs(currSum, nums, S, 0);\\n    return ways;\\n};\\n\\nfunction dfs(currSum, nums, S, currIdx) {\\n\\t// check to see that we have gone through the entire array\\n    if(currIdx === nums.length) {\\n        return currSum === S ? 1 : 0;\\n    } else if (currIdx < nums.length) {\\n\\t\\t// calculate the values of \\'+\\' and \\'-\\'\\n        let left = currSum + nums[currIdx];\\n        let right = currSum - nums[currIdx];\\n        return dfs(left, nums, S, currIdx + 1) + dfs(right, nums, S, currIdx + 1);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 338393,
                "title": "c-0ms-100-solution-w-dp",
                "content": "The idea is to use the fact that sum(P) - sum(N) = S, so sum(P) + sum(P) + sum(N) - sum(N) = S + sum(nums), so sum(P) = (S + sum(nums))/2.\\n\\nOnce we reduce this problem to finding a subset with target sum, we can then apply the DP solution. To apply DP, we define ```m[i][j]``` to mean the maximum number of ways to get target ```j``` from ```nums[0 ... i]```. The update equation is very straight forward, which is the sum of ways of including ```nums[i]```, or not including ```nums[i]```. To include ```nums[i]```, we need ways to get the remainder sum, which is ```m[i-1][j - nums[i]]```. For example target is 5, and we have a 3, the number of ways to include 3 is the number of ways we can get 2 from the other numbers in the working array. Thus, the update equation is ```m[i][j] = m[i-1][j] + m[i-1][j - nums[i]]```.\\n\\nOnce we get the update equation, we can see that ```m[i][j]``` depends on ```i-1``` and ```j - nums[i]```. We can apply the standard space optimization technique to reduce ```m[i][j]``` to ```m[j]```, by updating ```j``` backwards. The new update equation becomes ```m[j] = m[j] + m[j - nums[i]]```.\\n\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        const int sum = accumulate(nums.begin(), nums.end(), 0);\\n        if(sum < S || (S + sum) % 2) return false; // Check if sum is actually possible\\n\\t\\t\\n\\t\\t// Sort the vector to cut off numbers that are greater than the desired target sum.\\n\\t\\tsort(nums.begin(), nums.end());\\n        const int sizeS = (S + sum)/2, sizeN = upper_bound(nums.begin(), nums.end(), sizeS) - nums.begin();\\n                                                           \\n        vector<int> dp(sizeS+1, 0);\\n        dp[0] = 1;\\n        for(int i = 0; i < sizeN; ++i) {\\n\\t\\t\\tconst int tmp = nums[i];\\n            for(int j = sizeS; j >= tmp; --j)  dp[j] += dp[j - tmp];\\n\\t\\t}\\n        return dp[sizeS];\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```m[i][j]```\n```j```\n```nums[0 ... i]```\n```nums[i]```\n```nums[i]```\n```nums[i]```\n```m[i-1][j - nums[i]]```\n```m[i][j] = m[i-1][j] + m[i-1][j - nums[i]]```\n```m[i][j]```\n```i-1```\n```j - nums[i]```\n```m[i][j]```\n```m[j]```\n```j```\n```m[j] = m[j] + m[j - nums[i]]```\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int S) {\\n        const int sum = accumulate(nums.begin(), nums.end(), 0);\\n        if(sum < S || (S + sum) % 2) return false; // Check if sum is actually possible\\n\\t\\t\\n\\t\\t// Sort the vector to cut off numbers that are greater than the desired target sum.\\n\\t\\tsort(nums.begin(), nums.end());\\n        const int sizeS = (S + sum)/2, sizeN = upper_bound(nums.begin(), nums.end(), sizeS) - nums.begin();\\n                                                           \\n        vector<int> dp(sizeS+1, 0);\\n        dp[0] = 1;\\n        for(int i = 0; i < sizeN; ++i) {\\n\\t\\t\\tconst int tmp = nums[i];\\n            for(int j = sizeS; j >= tmp; --j)  dp[j] += dp[j - tmp];\\n\\t\\t}\\n        return dp[sizeS];\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 329606,
                "title": "python-solution-bottom-up-dp-using-dictionary",
                "content": "The approach is to do a bottom up dynamic programming. This is similar to 2-D DP in the solution. However, we don\\'t use a 2-D array. We use a 1-D hash table. This way, we\\'re not traversing each of the 1000 possible sums - we\\'re only traversing the actual possible sums that we could get to so far.\\n\\nThe core loop logic is something like this\\n* in iteration i, consider the ith number in the input array (call it n)\\n* the range of possible sums using n equals\\n\\t* the range of possible sums using all numbers to the left of n PLUS n PLUS the range of possible sums using all numbers to the left of n MINUS n\\n\\n```\\nif not nums or S > 1000:\\n            return 0\\n        \\n        #This hash represents the number of ways we can get to a particular sum\\n        #It\\'s more memory efficient as it only stores the possible sums\\n        currhash = {0:1} #base case: can get to zero by using no elements\\n        \\n        #In this loop, we build up the hash based on the previous one\\n        for n in nums:\\n            newh = collections.defaultdict(int)\\n            \\n            for k,v in currhash.items():\\n                newh[k+n] += v  #Add the current number to every possible pre-existing sum\\n                newh[k-n] += v  #Subtract the current number from every possible pre-existing sum\\n            currhash = newh       #For the next iteration, curr = prev\\n        \\n        return currhash[S]\\n                    ```",
                "solutionTags": [],
                "code": "```\\nif not nums or S > 1000:\\n            return 0\\n        \\n        #This hash represents the number of ways we can get to a particular sum\\n        #It\\'s more memory efficient as it only stores the possible sums\\n        currhash = {0:1} #base case: can get to zero by using no elements\\n        \\n        #In this loop, we build up the hash based on the previous one\\n        for n in nums:\\n            newh = collections.defaultdict(int)\\n            \\n            for k,v in currhash.items():\\n                newh[k+n] += v  #Add the current number to every possible pre-existing sum\\n                newh[k-n] += v  #Subtract the current number from every possible pre-existing sum\\n            currhash = newh       #For the next iteration, curr = prev\\n        \\n        return currhash[S]\\n                    ```",
                "codeTag": "Unknown"
            },
            {
                "id": 245073,
                "title": "java-solution-in-chinese",
                "content": "S1:\\u76F4\\u63A5\\u9012\\u5F52\\n\\n\\u9898\\u76EE\\u4E2D\\u6307\\u51FA\\uFF0C\\u5C06\\u6570\\u7EC4\\u4E2D\\u7684\\u6BCF\\u4E2A\\u6570\\u524D\\u9762\\u52A0\\u4E0A\\u4E00\\u4E2A\\u7B26\\u53F7\\uFF08+ \\u6216 -\\uFF09\\uFF0C\\u4F7F\\u5F97\\u5B83\\u4EEC\\u6784\\u6210\\u4E00\\u4E2A\\u8FD0\\u7B97\\u5F0F\\uFF0C\\u5E76\\u4E14\\u5176\\u8BA1\\u7B97\\u7ED3\\u679C\\u7B49\\u4E8E\\u7ED9\\u5B9A\\u7684 S \\uFF0C\\u6C42\\u7B26\\u53F7\\u7684\\u6DFB\\u52A0\\u79CD\\u7C7B\\u3002\\n\\n\\u90A3\\u4E48\\u4E5F\\u5C31\\u662F\\u8BF4\\uFF0C\\u5BF9\\u4E8E\\u6BCF\\u4E00\\u4E2A\\u6570\\u5B57\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u9009\\u62E9\\u52A0\\u4E0A\\u5B83\\u6216\\u8005\\u51CF\\u53BB\\u5B83\\uFF0C\\u4E8E\\u662F\\uFF0C\\u53EF\\u4EE5\\u76F4\\u63A5\\u4F7F\\u7528\\u9012\\u5F52\\uFF0C\\u8FDB\\u884C2^n\\u6B21\\u8FD0\\u7B97\\uFF0C\\u6C42\\u51FA\\u6240\\u6709\\u7684\\u7B26\\u53F7\\u6DFB\\u52A0\\u65B9\\u5F0F\\uFF0C\\u7136\\u540E\\u518D\\u6C42\\u5176\\u4E2D\\u7ED3\\u679C\\u4E3A S \\u7684\\u5373\\u53EF\\uFF1A\\n\\n    public static int findTargetSumWays(int[] nums, int S) {\\n        return ways(nums, S, 0, 0);\\n    }\\n    private static int ways(int[] nums, int S, int pos, int cur) {\\n        if (pos == nums.length) {\\n            return cur == S ? 1 : 0;\\n        } else {\\n            return ways(nums, S, pos+1, cur+nums[pos])\\n                    + ways(nums, S, pos+1, cur-nums[pos]);\\n        }\\n    }\\n\\nS2:\\u7F13\\u5B58\\u9012\\u5F52\\n\\n\\u4E0A\\u8FF0\\u9012\\u5F52\\u5F88\\u6709\\u53EF\\u80FD\\u4F1A\\u589E\\u52A0\\u5F88\\u591A\\u4E0D\\u5FC5\\u8981\\u7684\\u8BA1\\u7B97\\uFF0C\\u5982\\u5BF9\\u4E8E\\u4E00\\u4E2A\\u6570\\u7EC4[1,1,1,1,1,1]\\uFF0C\\u5982\\u679C\\u524D\\u4E24\\u4E2A\\u6570\\u5B57\\u7684\\u7B26\\u53F7\\u5206\\u522B\\u662F[-,+]\\u548C[+,-]\\uFF0C\\u90A3\\u4E48\\u8BA1\\u7B97\\u5230\\u7B2C\\u4E09\\u4E2A\\u6570\\u5B57\\u7684\\u65F6\\u5019\\uFF0C\\u8FD9\\u4E24\\u79CD\\u7B26\\u53F7\\u6DFB\\u52A0\\u65B9\\u5F0F\\u6307\\u5411\\u4E86\\u540C\\u4E00\\u79CD\\u60C5\\u51B5\\uFF0C\\u5982\\u679C\\u4E0D\\u52A0\\u5904\\u7406\\uFF0C\\u80AF\\u5B9A\\u8981\\u9020\\u6210\\u540E\\u9762\\u7684[1,1,1,1]\\u7684\\u91CD\\u590D\\u8BA1\\u7B97\\uFF0C\\u6B64\\u65F6\\u53EF\\u4EE5\\u8003\\u8651\\u7ED9\\u9012\\u5F52\\u51FD\\u6570\\u52A0\\u4E00\\u4E2A\\u7F13\\u5B58\\u3002\\n\\n\\u6BCF\\u4E2A\\u9012\\u5F52\\u51FD\\u6570\\u6709\\u4E24\\u4E2A\\u53D8\\u91CF\\uFF1A\\n\\n1.  \\u5F53\\u524D\\u4F4D\\u7F6E\\n2.  \\u5F53\\u524D\\u7684\\u8FD0\\u7B97\\u7ED3\\u679C\\n\\n\\u6240\\u4EE5\\u521D\\u6B65\\u8003\\u8651\\u7F13\\u5B58\\u5E94\\u8BE5\\u662F\\u4E00\\u4E2A\\u4E8C\\u7EF4\\u6570\\u7EC4\\uFF0C\\u6B64\\u65F6\\u5C31\\u8981\\u5224\\u65AD\\u8FD9\\u4E24\\u4E2A\\u53D8\\u91CF\\u5404\\u81EA\\u7684\\u53D6\\u503C\\u8303\\u56F4\\uFF1A\\n\\n1.  \\u5BF9\\u4E8E\\u5F53\\u524D\\u7684\\u4F4D\\u7F6E\\uFF0C\\u80AF\\u5B9A\\u662F\\u8981\\u5728 nums \\u91CC\\u9762\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\uFF0C\\u5B83\\u7684\\u8303\\u56F4\\u662F 0\\uFF5En-1\\n2.  \\u7531\\u4E8E\\u6570\\u7EC4\\u4E2D\\u6240\\u6709\\u7684\\u6570\\u5B57\\u90FD\\u662F\\u6B63\\u6570\\uFF0C\\u90A3\\u4E48\\u5FC5\\u7136\\u6240\\u6709\\u7B26\\u53F7\\u53D6 + \\u7ED3\\u679C\\u6700\\u5927\\uFF0C\\u6240\\u6709\\u7B26\\u53F7\\u53D6 - \\u7ED3\\u679C\\u6700\\u5C0F\\uFF0C\\u9898\\u76EE\\u91CC\\u9762\\u4E5F\\u6307\\u51FA\\uFF0C\\u6240\\u6709\\u7684\\u6570\\u5B57\\u548C\\u662F\\u4E0D\\u5927\\u4E8E 1000 \\u7684\\uFF0C\\u6240\\u4EE5\\uFF0C\\u8303\\u56F4\\u53D6\\u4E0A\\u4E0B 1000 \\u5373\\u53EF\\uFF0C\\u4E5F\\u5C31\\u662F 2001\\n\\n\\u90A3\\u4E48\\uFF0C\\u6DFB\\u52A0\\u4E86\\u7F13\\u5B58\\u4E4B\\u540E\\u5C31\\u662F\\uFF1A\\n\\n    public static int findTargetSumWays(int[] nums, int S) {\\n        int[][] saved = new int[nums.length][2001];\\n        for (int[] row : saved) {\\n            Arrays.fill(row, -1);\\n        }\\n        return ways2(nums, S, 0, 0, saved);\\n    }\\n    private static int ways2(int[] nums, int S, int pos, int cur, int[][] saved) {\\n        if (pos == nums.length) {\\n            return cur == S ? 1 : 0;\\n        } else {\\n            if (saved[pos][cur+1000] >= 0) return saved[pos][cur+1000];\\n            int ways = ways2(nums, S, pos+1, cur+nums[pos], saved)\\n                    + ways2(nums, S, pos+1, cur-nums[pos], saved);\\n            saved[pos][cur+1000] = ways;\\n            return ways;\\n        }\\n    }\\n\\n1000 \\u662F\\u6570\\u7EC4\\u4E2D\\u6570\\u5B57\\u548C\\u7684\\u4E0A\\u9650\\uFF0C\\u5982\\u679C\\u60F3\\u8981\\u7F29\\u51CF\\u4E00\\u4E0B\\u5185\\u5B58\\u4F7F\\u7528\\u91CF\\uFF0C\\u4E5F\\u53EF\\u4EE5\\u76F4\\u63A5\\u8BA1\\u7B97\\u51FA\\u6570\\u5B57\\u548C\\u3002\\n\\nS3:\\u52A8\\u6001\\u89C4\\u5212\\n\\n\\u52A8\\u6001\\u89C4\\u5212\\u4E5F\\u9700\\u8981\\u4E00\\u4E2A\\u6570\\u7EC4\\u4FDD\\u5B58\\u8BB0\\u5F55\\u503C\\uFF0C\\u4E0E\\u9012\\u5F52\\u4E2D\\u4F7F\\u7528\\u7684\\u7F13\\u5B58\\u6570\\u7EC4\\u7C7B\\u4F3C\\u3002\\u5BF9\\u4E8E\\u4E00\\u4E2A\\u6570\\u7EC4[1,...,n]\\u6765\\u8BF4\\uFF0C\\u5982\\u679C\\u5F53\\u524D\\u5F85\\u5224\\u65AD\\u4F4D\\u7F6E\\u662F i \\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u5DF2\\u7ECF\\u8BA1\\u7B97\\u51FA\\u4E86\\u524D\\u9762[1,...,i-1]\\u8FD9\\u90E8\\u5206\\u5B50\\u6570\\u7EC4\\u7684\\u7ED3\\u679C\\uFF0C\\u6BCF\\u4E2A\\u6570\\u5B57\\u6709\\u4E24\\u79CD\\u7B26\\u53F7\\u6DFB\\u52A0\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u603B\\u7684\\u5E94\\u8BE5\\u67092^{i-1}\\u79CD\\u7ED3\\u679C\\uFF08\\u53EF\\u80FD\\u4F1A\\u6709\\u91CD\\u5408\\u7684\\uFF09\\uFF0C\\u90A3\\u4E48\\u5728\\u8FD92^{i-1}\\u79CD\\u7ED3\\u679C\\u52A0\\u4E0A\\uFF08\\u6216\\u8005\\u51CF\\u53BB\\uFF09nums[i] \\u4E4B\\u540E\\uFF0C\\u5C31\\u4F1A\\u5F97\\u52302^i\\u79CD\\u65B0\\u7684\\u7ED3\\u679C\\uFF08\\u5F53\\u7136\\uFF0C\\u6709\\u53EF\\u80FD\\u5728\\u524D\\u9762\\u76842^{i-1}\\u79CD\\u7ED3\\u679C\\u4E2D\\uFF0C\\u5B58\\u5728 x y \\uFF0C\\u4F7F\\u5F97 x-nums[i] == y+nums[i] == cur\\uFF09\\uFF0C\\u6B64\\u65F6 cur \\u5BF9\\u5E94\\u7684\\u89E3\\u5E94\\u8BE5\\u662F x y \\u4E24\\u4E2A\\u6570\\u5BF9\\u5E94\\u7684\\u89E3\\u7684\\u548C\\u3002\\u90A3\\u4E48\\u5F53\\u6574\\u4E2A\\u6570\\u7EC4\\u8BA1\\u7B97\\u5B8C\\u6210\\u4E4B\\u540E\\uFF0C\\u5C31\\u53EF\\u4EE5\\u6C42\\u51FA\\u6570\\u5B57 S \\u5BF9\\u5E94\\u7684\\u89E3\\u3002\\n\\n    public static int findTargetSumWays(int[] nums, int S) {\\n        int sum = 0;\\n        for (int num : nums) sum += num;\\n        if (sum < S || ((S + sum) & 1) == 1) return 0;\\n        \\n        int[] dp = new int[(sum<<1) + 1];\\n        dp[nums[0] + sum] = 1;\\n        dp[-nums[0] + sum] += 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            int[] next = new int[(sum<<1) + 1];\\n            for (int j = -sum; j <= sum; j++) {\\n                if (dp[j + sum] > 0) {\\n                    next[j + sum + nums[i]] += dp[j + sum];\\n                    next[j + sum - nums[i]] += dp[j + sum];\\n                }\\n            }\\n            dp = next;\\n        }\\n        return dp[S + sum];\\n    }\\n\\n\\u5982\\u4E0A\\uFF0C\\u7B2C\\u4E00\\u4E2A\\u5FAA\\u73AF\\u662F\\u904D\\u5386\\u6570\\u7EC4\\uFF0C\\u7B2C\\u4E8C\\u4E2A\\u5FAA\\u73AF\\u5219\\u662F\\u904D\\u5386\\u4EE5\\u6C42\\u51FA\\u76842^{i-1}\\u79CD\\u7ED3\\u679C\\uFF0C\\u5E76\\u5C06\\u5176\\u5206\\u522B\\u52A0\\u4E0A\\uFF08\\u51CF\\u53BB\\uFF09nums[i] \\u4EE5\\u6C42\\u51FA\\u4E0B\\u4E00\\u4E2A\\u4F4D\\u7F6E\\u76842^i\\u79CD\\u7ED3\\u679C\\uFF0C\\u5F53\\u7136\\uFF0C\\u4E0A\\u8FF0\\u7ED3\\u679C\\u80AF\\u5B9A\\u662F\\u5B58\\u5728\\u91CD\\u5408\\u7684\\uFF0C\\u56E0\\u4E3A\\u6240\\u6709\\u7684\\u8FD0\\u7B97\\u7ED3\\u679C\\u90FD\\u662F\\u5728 -sum\\uFF5Esum \\u7684\\u8303\\u56F4\\u5185\\uFF0C\\u6240\\u4EE5\\u5F53\\u6211\\u4EEC\\u9700\\u8981\\u904D\\u5386\\u5DF2\\u6C42\\u51FA\\u76842^{i-1}\\u79CD\\u7ED3\\u679C\\u65F6\\uFF0C\\u7531\\u4E8E\\u4F1A\\u6709\\u91CD\\u5408\\uFF0C\\u6211\\u4EEC\\u5E76\\u4E0D\\u77E5\\u9053\\u5230\\u5E95\\u6709\\u591A\\u5C11\\u79CD\\u7ED3\\u679C\\uFF0C\\u8FD9\\u65F6\\u7684\\u5904\\u7406\\u529E\\u6CD5\\u5C31\\u662F\\u904D\\u5386\\u6574\\u4E2A\\u53EF\\u80FD\\u7684\\u7ED3\\u679C\\uFF08\\u4ECE -sum \\u5230 sum\\uFF09\\uFF0C\\u5F53\\u8FD9\\u4E2A\\u7ED3\\u679C\\u5BF9\\u5E94\\u7684\\u89E3\\u4E0D\\u4E3A 0 \\u65F6\\uFF0C\\u5C31\\u610F\\u5473\\u7740\\u8FD9\\u662F\\u4E00\\u4E2A2^{i-1}\\u4E2A\\u7ED3\\u679C\\u4E2D\\u7684\\u4E00\\u4E2A\\u3002\\n\\n\\u6240\\u4EE5\\uFF0C\\u672C\\u9898\\u4E2D\\u9996\\u5148\\u7ED9\\u6267\\u884C\\u4E86dp[nums[0] + sum] = 1;\\u548Cdp[-nums[0] + sum] += 1;\\u8FD9\\u4E24\\u4E2A\\u4EE3\\u7801\\uFF0C\\u5C31\\u662F\\u4E3A\\u4E86\\u5148\\u6C42\\u51FA2^1\\u7684\\u7ED3\\u679C\\uFF0C\\u7136\\u540E\\u4E4B\\u540E\\u6C42\\u7B2C\\u4E8C\\u4E2A\\u4F4D\\u7F6E\\u76842^2\\u7684\\u7ED3\\u679C\\u7684\\u65F6\\u5019\\uFF0C\\u624D\\u80FD\\u5229\\u7528\\u5DF2\\u6C42\\u51FA\\u7684\\u7ED3\\u679C\\u3002\\n\\n\\u53E6\\u5916\\uFF0C\\u8BA1\\u7B97\\u4E0B\\u4E00\\u4E2A\\u4F4D\\u7F6E\\u7684\\u7ED3\\u679C\\u7684\\u65F6\\u5019\\u7684\\u4EE3\\u7801next[j + sum + nums[i]] += dp[j + sum];\\u4E2D\\u4F7F\\u7528\\u7684\\u662F+=\\u7B26\\u53F7\\uFF0C\\u5C31\\u662F\\u5C06\\u6240\\u6709\\u5BFC\\u5411\\u7EDF\\u4E00\\u7ED3\\u679C\\u7684\\u89E3\\u76F8\\u52A0\\n\\n\\u8FD8\\u6709\\uFF0CS \\u4E0E sum \\u662F\\u5426\\u6709\\u4EC0\\u4E48\\u5173\\u7CFB\\uFF1F\\u4E3A\\u4EC0\\u4E48\\u8981\\u5224\\u65AD((S + sum) & 1) == 1\\uFF1F\\n\\n\\u672C\\u9898\\u4E2D\\u6BCF\\u4E2A\\u6570\\u5B57\\u524D\\u90FD\\u6709\\u4E00\\u4E2A\\u7B26\\u53F7\\uFF0C+ \\u6216 - \\uFF0C\\u5982\\u679C\\u5C06\\u6574\\u4E2A\\u6570\\u7EC4\\u6309\\u7167\\u6570\\u5B57\\u4E4B\\u524D\\u7684\\u7B26\\u53F7\\u5206\\u6210\\u4E24\\u90E8\\u5206\\uFF0C\\u4E00\\u90E8\\u5206\\u7684\\u7B26\\u53F7\\u5168\\u662F + \\uFF0C\\u53E6\\u4E00\\u90E8\\u5206\\u7684\\u7B26\\u53F7\\u5168\\u662F - \\uFF0C\\u7136\\u540E\\u8BA9\\u4E24\\u90E8\\u5206\\u7684\\u548C\\u5206\\u522B\\u662F x y \\uFF0C\\u90A3\\u4E48\\u6709\\u5173\\u7CFB\\u5F0F\\uFF1A\\n\\n    x + y = sum\\n    x - y = S\\n\\n\\u4E8E\\u662F\\u6709x + x = S + sum = 2 * x\\uFF0C\\u4E8E\\u662F\\u5F97\\u51FA\\u7ED3\\u8BBA\\uFF1AS + sum \\u5FC5\\u7136\\u662F\\u5076\\u6570\\uFF0C\\u6240\\u4EE5\\u624D\\u6709\\u4E86\\u672C\\u9898\\u5F00\\u59CB\\u7684\\u5224\\u65AD\\u3002\\n\\nS4:\\u5212\\u5206\\u6570\\u7EC4 & \\u52A8\\u6001\\u89C4\\u5212\\n\\n\\u4E0A\\u9762\\u7684\\u8FD9\\u4E2A\\u5173\\u7CFB\\u5F0FS + sum = 2 * x\\u4E5F\\u53EF\\u4EE5\\u52A0\\u4EE5\\u5229\\u7528\\uFF0C\\u5F97\\u51FA(S + sum) / 2 = x\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u672C\\u9898\\u53EF\\u4EE5\\u53D8\\u4E3A\\uFF0C\\u4F7F nums \\u6570\\u7EC4\\u7684\\u5B50\\u6570\\u7EC4\\u7684\\u548C\\u7B49\\u4E8E S+sum \\u7684\\u4E00\\u534A\\uFF0C\\u6C42\\u51FA\\u7B26\\u5408\\u6761\\u4EF6\\u7684\\u5B50\\u6570\\u7EC4\\u7684\\u4E2A\\u6570\\u3002\\n\\n\\u4E8E\\u662F\\u6709\\uFF1A\\n\\n    public static int findTargetSumWays(int[] nums, int S) {\\n        int sum = 0;\\n        for (int num : nums) sum += num;\\n        if (sum < S || ((sum + S) & 1) == 1) return 0;\\n        sum = (sum + S) >> 1;\\n        int[] dp = new int[sum+1];\\n        dp[0] = 1;\\n        for (int num : nums) {\\n            for (int i = sum; i >= num; i--) {\\n                dp[i] += dp[i-num];\\n            }\\n        }\\n        return dp[sum];\\n    }\\n\\n\\u6B64\\u65F6\\uFF0C\\u5916\\u5C42\\u662F\\u5BF9\\u6570\\u7EC4\\u7684\\u5FAA\\u73AF\\uFF0C\\u5185\\u5C42\\u901A\\u8FC7\\u4E00\\u4E2A i=num\\uFF5Esum \\u7684\\u5FAA\\u73AF\\uFF0C\\u6C42\\u51FA\\u6240\\u6709\\u52A0\\u4E0A\\u5F53\\u524D\\u4F4D\\u7F6E\\u7684 num \\u80FD\\u5230\\u5F97\\u5230 i \\u7684\\u89E3\\u3002\\u5916\\u5C42\\u5BF9\\u6570\\u7EC4\\u7684\\u5FAA\\u73AF\\uFF0C\\u6BCF\\u5230\\u4E00\\u4E2A\\u6570\\u5B57 num \\uFF0C\\u5C31\\u662F\\u6307\\u5BF9\\u4E8E\\u5B50\\u6570\\u7EC4[0,...,num]\\u6765\\u8BF4\\uFF0Cdp[i] \\u5B58\\u653E\\u7740\\u6570\\u7EC4[0,...,num]\\u4E2D\\u548C\\u4E3A i \\u7684\\u5B50\\u6570\\u7EC4\\u7684\\u4E2A\\u6570\\uFF0C\\u90A3\\u4E48\\u5916\\u5C42\\u5BF9\\u6570\\u7EC4\\u7684\\u5FAA\\u73AF\\u5B8C\\u4E86\\u4E4B\\u540E\\uFF0Cdp[i] \\u5B58\\u653E\\u7684\\u5C31\\u662F\\u6570\\u7EC4 nums \\u7684\\u548C\\u4E3A i \\u7684\\u5B50\\u6570\\u7EC4\\u7684\\u4E2A\\u6570\\uFF0C\\u6240\\u4EE5\\uFF0C\\u6B64\\u65F6 dp[sum] \\u5C31\\u662F\\u672C\\u9898\\u7684\\u89E3\\u3002\\n\\n\\u5176\\u4E2D\\uFF0C\\u8D77\\u59CB\\u4F4D\\u7F6E\\u7684dp[0] = 1\\uFF0C\\u662F\\u6574\\u4E2A\\u8BA1\\u7B97\\u7684\\u5F00\\u7AEF\\uFF0C\\u7531 0+num=num \\uFF0C\\u5F97\\u5230dp[num] = 1\\uFF0C\\u7136\\u540E\\u4EE5\\u6B64\\u7C7B\\u63A8\\u3002\\n",
                "solutionTags": [],
                "code": "S1:\\u76F4\\u63A5\\u9012\\u5F52\\n\\n\\u9898\\u76EE\\u4E2D\\u6307\\u51FA\\uFF0C\\u5C06\\u6570\\u7EC4\\u4E2D\\u7684\\u6BCF\\u4E2A\\u6570\\u524D\\u9762\\u52A0\\u4E0A\\u4E00\\u4E2A\\u7B26\\u53F7\\uFF08+ \\u6216 -\\uFF09\\uFF0C\\u4F7F\\u5F97\\u5B83\\u4EEC\\u6784\\u6210\\u4E00\\u4E2A\\u8FD0\\u7B97\\u5F0F\\uFF0C\\u5E76\\u4E14\\u5176\\u8BA1\\u7B97\\u7ED3\\u679C\\u7B49\\u4E8E\\u7ED9\\u5B9A\\u7684 S \\uFF0C\\u6C42\\u7B26\\u53F7\\u7684\\u6DFB\\u52A0\\u79CD\\u7C7B\\u3002\\n\\n\\u90A3\\u4E48\\u4E5F\\u5C31\\u662F\\u8BF4\\uFF0C\\u5BF9\\u4E8E\\u6BCF\\u4E00\\u4E2A\\u6570\\u5B57\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u9009\\u62E9\\u52A0\\u4E0A\\u5B83\\u6216\\u8005\\u51CF\\u53BB\\u5B83\\uFF0C\\u4E8E\\u662F\\uFF0C\\u53EF\\u4EE5\\u76F4\\u63A5\\u4F7F\\u7528\\u9012\\u5F52\\uFF0C\\u8FDB\\u884C2^n\\u6B21\\u8FD0\\u7B97\\uFF0C\\u6C42\\u51FA\\u6240\\u6709\\u7684\\u7B26\\u53F7\\u6DFB\\u52A0\\u65B9\\u5F0F\\uFF0C\\u7136\\u540E\\u518D\\u6C42\\u5176\\u4E2D\\u7ED3\\u679C\\u4E3A S \\u7684\\u5373\\u53EF\\uFF1A\\n\\n    public static int findTargetSumWays(int[] nums, int S) {\\n        return ways(nums, S, 0, 0);\\n    }\\n    private static int ways(int[] nums, int S, int pos, int cur) {\\n        if (pos == nums.length) {\\n            return cur == S ? 1 : 0;\\n        } else {\\n            return ways(nums, S, pos+1, cur+nums[pos])\\n                    + ways(nums, S, pos+1, cur-nums[pos]);\\n        }\\n    }\\n\\nS2:\\u7F13\\u5B58\\u9012\\u5F52\\n\\n\\u4E0A\\u8FF0\\u9012\\u5F52\\u5F88\\u6709\\u53EF\\u80FD\\u4F1A\\u589E\\u52A0\\u5F88\\u591A\\u4E0D\\u5FC5\\u8981\\u7684\\u8BA1\\u7B97\\uFF0C\\u5982\\u5BF9\\u4E8E\\u4E00\\u4E2A\\u6570\\u7EC4[1,1,1,1,1,1]\\uFF0C\\u5982\\u679C\\u524D\\u4E24\\u4E2A\\u6570\\u5B57\\u7684\\u7B26\\u53F7\\u5206\\u522B\\u662F[-,+]\\u548C[+,-]\\uFF0C\\u90A3\\u4E48\\u8BA1\\u7B97\\u5230\\u7B2C\\u4E09\\u4E2A\\u6570\\u5B57\\u7684\\u65F6\\u5019\\uFF0C\\u8FD9\\u4E24\\u79CD\\u7B26\\u53F7\\u6DFB\\u52A0\\u65B9\\u5F0F\\u6307\\u5411\\u4E86\\u540C\\u4E00\\u79CD\\u60C5\\u51B5\\uFF0C\\u5982\\u679C\\u4E0D\\u52A0\\u5904\\u7406\\uFF0C\\u80AF\\u5B9A\\u8981\\u9020\\u6210\\u540E\\u9762\\u7684[1,1,1,1]\\u7684\\u91CD\\u590D\\u8BA1\\u7B97\\uFF0C\\u6B64\\u65F6\\u53EF\\u4EE5\\u8003\\u8651\\u7ED9\\u9012\\u5F52\\u51FD\\u6570\\u52A0\\u4E00\\u4E2A\\u7F13\\u5B58\\u3002\\n\\n\\u6BCF\\u4E2A\\u9012\\u5F52\\u51FD\\u6570\\u6709\\u4E24\\u4E2A\\u53D8\\u91CF\\uFF1A\\n\\n1.  \\u5F53\\u524D\\u4F4D\\u7F6E\\n2.  \\u5F53\\u524D\\u7684\\u8FD0\\u7B97\\u7ED3\\u679C\\n\\n\\u6240\\u4EE5\\u521D\\u6B65\\u8003\\u8651\\u7F13\\u5B58\\u5E94\\u8BE5\\u662F\\u4E00\\u4E2A\\u4E8C\\u7EF4\\u6570\\u7EC4\\uFF0C\\u6B64\\u65F6\\u5C31\\u8981\\u5224\\u65AD\\u8FD9\\u4E24\\u4E2A\\u53D8\\u91CF\\u5404\\u81EA\\u7684\\u53D6\\u503C\\u8303\\u56F4\\uFF1A\\n\\n1.  \\u5BF9\\u4E8E\\u5F53\\u524D\\u7684\\u4F4D\\u7F6E\\uFF0C\\u80AF\\u5B9A\\u662F\\u8981\\u5728 nums \\u91CC\\u9762\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\uFF0C\\u5B83\\u7684\\u8303\\u56F4\\u662F 0\\uFF5En-1\\n2.  \\u7531\\u4E8E\\u6570\\u7EC4\\u4E2D\\u6240\\u6709\\u7684\\u6570\\u5B57\\u90FD\\u662F\\u6B63\\u6570\\uFF0C\\u90A3\\u4E48\\u5FC5\\u7136\\u6240\\u6709\\u7B26\\u53F7\\u53D6 + \\u7ED3\\u679C\\u6700\\u5927\\uFF0C\\u6240\\u6709\\u7B26\\u53F7\\u53D6 - \\u7ED3\\u679C\\u6700\\u5C0F\\uFF0C\\u9898\\u76EE\\u91CC\\u9762\\u4E5F\\u6307\\u51FA\\uFF0C\\u6240\\u6709\\u7684\\u6570\\u5B57\\u548C\\u662F\\u4E0D\\u5927\\u4E8E 1000 \\u7684\\uFF0C\\u6240\\u4EE5\\uFF0C\\u8303\\u56F4\\u53D6\\u4E0A\\u4E0B 1000 \\u5373\\u53EF\\uFF0C\\u4E5F\\u5C31\\u662F 2001\\n\\n\\u90A3\\u4E48\\uFF0C\\u6DFB\\u52A0\\u4E86\\u7F13\\u5B58\\u4E4B\\u540E\\u5C31\\u662F\\uFF1A\\n\\n    public static int findTargetSumWays(int[] nums, int S) {\\n        int[][] saved = new int[nums.length][2001];\\n        for (int[] row : saved) {\\n            Arrays.fill(row, -1);\\n        }\\n        return ways2(nums, S, 0, 0, saved);\\n    }\\n    private static int ways2(int[] nums, int S, int pos, int cur, int[][] saved) {\\n        if (pos == nums.length) {\\n            return cur == S ? 1 : 0;\\n        } else {\\n            if (saved[pos][cur+1000] >= 0) return saved[pos][cur+1000];\\n            int ways = ways2(nums, S, pos+1, cur+nums[pos], saved)\\n                    + ways2(nums, S, pos+1, cur-nums[pos], saved);\\n            saved[pos][cur+1000] = ways;\\n            return ways;\\n        }\\n    }\\n\\n1000 \\u662F\\u6570\\u7EC4\\u4E2D\\u6570\\u5B57\\u548C\\u7684\\u4E0A\\u9650\\uFF0C\\u5982\\u679C\\u60F3\\u8981\\u7F29\\u51CF\\u4E00\\u4E0B\\u5185\\u5B58\\u4F7F\\u7528\\u91CF\\uFF0C\\u4E5F\\u53EF\\u4EE5\\u76F4\\u63A5\\u8BA1\\u7B97\\u51FA\\u6570\\u5B57\\u548C\\u3002\\n\\nS3:\\u52A8\\u6001\\u89C4\\u5212\\n\\n\\u52A8\\u6001\\u89C4\\u5212\\u4E5F\\u9700\\u8981\\u4E00\\u4E2A\\u6570\\u7EC4\\u4FDD\\u5B58\\u8BB0\\u5F55\\u503C\\uFF0C\\u4E0E\\u9012\\u5F52\\u4E2D\\u4F7F\\u7528\\u7684\\u7F13\\u5B58\\u6570\\u7EC4\\u7C7B\\u4F3C\\u3002\\u5BF9\\u4E8E\\u4E00\\u4E2A\\u6570\\u7EC4[1,...,n]\\u6765\\u8BF4\\uFF0C\\u5982\\u679C\\u5F53\\u524D\\u5F85\\u5224\\u65AD\\u4F4D\\u7F6E\\u662F i \\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u5DF2\\u7ECF\\u8BA1\\u7B97\\u51FA\\u4E86\\u524D\\u9762[1,...,i-1]\\u8FD9\\u90E8\\u5206\\u5B50\\u6570\\u7EC4\\u7684\\u7ED3\\u679C\\uFF0C\\u6BCF\\u4E2A\\u6570\\u5B57\\u6709\\u4E24\\u79CD\\u7B26\\u53F7\\u6DFB\\u52A0\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u603B\\u7684\\u5E94\\u8BE5\\u67092^{i-1}\\u79CD\\u7ED3\\u679C\\uFF08\\u53EF\\u80FD\\u4F1A\\u6709\\u91CD\\u5408\\u7684\\uFF09\\uFF0C\\u90A3\\u4E48\\u5728\\u8FD92^{i-1}\\u79CD\\u7ED3\\u679C\\u52A0\\u4E0A\\uFF08\\u6216\\u8005\\u51CF\\u53BB\\uFF09nums[i] \\u4E4B\\u540E\\uFF0C\\u5C31\\u4F1A\\u5F97\\u52302^i\\u79CD\\u65B0\\u7684\\u7ED3\\u679C\\uFF08\\u5F53\\u7136\\uFF0C\\u6709\\u53EF\\u80FD\\u5728\\u524D\\u9762\\u76842^{i-1}\\u79CD\\u7ED3\\u679C\\u4E2D\\uFF0C\\u5B58\\u5728 x y \\uFF0C\\u4F7F\\u5F97 x-nums[i] == y+nums[i] == cur\\uFF09\\uFF0C\\u6B64\\u65F6 cur \\u5BF9\\u5E94\\u7684\\u89E3\\u5E94\\u8BE5\\u662F x y \\u4E24\\u4E2A\\u6570\\u5BF9\\u5E94\\u7684\\u89E3\\u7684\\u548C\\u3002\\u90A3\\u4E48\\u5F53\\u6574\\u4E2A\\u6570\\u7EC4\\u8BA1\\u7B97\\u5B8C\\u6210\\u4E4B\\u540E\\uFF0C\\u5C31\\u53EF\\u4EE5\\u6C42\\u51FA\\u6570\\u5B57 S \\u5BF9\\u5E94\\u7684\\u89E3\\u3002\\n\\n    public static int findTargetSumWays(int[] nums, int S) {\\n        int sum = 0;\\n        for (int num : nums) sum += num;\\n        if (sum < S || ((S + sum) & 1) == 1) return 0;\\n        \\n        int[] dp = new int[(sum<<1) + 1];\\n        dp[nums[0] + sum] = 1;\\n        dp[-nums[0] + sum] += 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            int[] next = new int[(sum<<1) + 1];\\n            for (int j = -sum; j <= sum; j++) {\\n                if (dp[j + sum] > 0) {\\n                    next[j + sum + nums[i]] += dp[j + sum];\\n                    next[j + sum - nums[i]] += dp[j + sum];\\n                }\\n            }\\n            dp = next;\\n        }\\n        return dp[S + sum];\\n    }\\n\\n\\u5982\\u4E0A\\uFF0C\\u7B2C\\u4E00\\u4E2A\\u5FAA\\u73AF\\u662F\\u904D\\u5386\\u6570\\u7EC4\\uFF0C\\u7B2C\\u4E8C\\u4E2A\\u5FAA\\u73AF\\u5219\\u662F\\u904D\\u5386\\u4EE5\\u6C42\\u51FA\\u76842^{i-1}\\u79CD\\u7ED3\\u679C\\uFF0C\\u5E76\\u5C06\\u5176\\u5206\\u522B\\u52A0\\u4E0A\\uFF08\\u51CF\\u53BB\\uFF09nums[i] \\u4EE5\\u6C42\\u51FA\\u4E0B\\u4E00\\u4E2A\\u4F4D\\u7F6E\\u76842^i\\u79CD\\u7ED3\\u679C\\uFF0C\\u5F53\\u7136\\uFF0C\\u4E0A\\u8FF0\\u7ED3\\u679C\\u80AF\\u5B9A\\u662F\\u5B58\\u5728\\u91CD\\u5408\\u7684\\uFF0C\\u56E0\\u4E3A\\u6240\\u6709\\u7684\\u8FD0\\u7B97\\u7ED3\\u679C\\u90FD\\u662F\\u5728 -sum\\uFF5Esum \\u7684\\u8303\\u56F4\\u5185\\uFF0C\\u6240\\u4EE5\\u5F53\\u6211\\u4EEC\\u9700\\u8981\\u904D\\u5386\\u5DF2\\u6C42\\u51FA\\u76842^{i-1}\\u79CD\\u7ED3\\u679C\\u65F6\\uFF0C\\u7531\\u4E8E\\u4F1A\\u6709\\u91CD\\u5408\\uFF0C\\u6211\\u4EEC\\u5E76\\u4E0D\\u77E5\\u9053\\u5230\\u5E95\\u6709\\u591A\\u5C11\\u79CD\\u7ED3\\u679C\\uFF0C\\u8FD9\\u65F6\\u7684\\u5904\\u7406\\u529E\\u6CD5\\u5C31\\u662F\\u904D\\u5386\\u6574\\u4E2A\\u53EF\\u80FD\\u7684\\u7ED3\\u679C\\uFF08\\u4ECE -sum \\u5230 sum\\uFF09\\uFF0C\\u5F53\\u8FD9\\u4E2A\\u7ED3\\u679C\\u5BF9\\u5E94\\u7684\\u89E3\\u4E0D\\u4E3A 0 \\u65F6\\uFF0C\\u5C31\\u610F\\u5473\\u7740\\u8FD9\\u662F\\u4E00\\u4E2A2^{i-1}\\u4E2A\\u7ED3\\u679C\\u4E2D\\u7684\\u4E00\\u4E2A\\u3002\\n\\n\\u6240\\u4EE5\\uFF0C\\u672C\\u9898\\u4E2D\\u9996\\u5148\\u7ED9\\u6267\\u884C\\u4E86dp[nums[0] + sum] = 1;\\u548Cdp[-nums[0] + sum] += 1;\\u8FD9\\u4E24\\u4E2A\\u4EE3\\u7801\\uFF0C\\u5C31\\u662F\\u4E3A\\u4E86\\u5148\\u6C42\\u51FA2^1\\u7684\\u7ED3\\u679C\\uFF0C\\u7136\\u540E\\u4E4B\\u540E\\u6C42\\u7B2C\\u4E8C\\u4E2A\\u4F4D\\u7F6E\\u76842^2\\u7684\\u7ED3\\u679C\\u7684\\u65F6\\u5019\\uFF0C\\u624D\\u80FD\\u5229\\u7528\\u5DF2\\u6C42\\u51FA\\u7684\\u7ED3\\u679C\\u3002\\n\\n\\u53E6\\u5916\\uFF0C\\u8BA1\\u7B97\\u4E0B\\u4E00\\u4E2A\\u4F4D\\u7F6E\\u7684\\u7ED3\\u679C\\u7684\\u65F6\\u5019\\u7684\\u4EE3\\u7801next[j + sum + nums[i]] += dp[j + sum];\\u4E2D\\u4F7F\\u7528\\u7684\\u662F+=\\u7B26\\u53F7\\uFF0C\\u5C31\\u662F\\u5C06\\u6240\\u6709\\u5BFC\\u5411\\u7EDF\\u4E00\\u7ED3\\u679C\\u7684\\u89E3\\u76F8\\u52A0\\n\\n\\u8FD8\\u6709\\uFF0CS \\u4E0E sum \\u662F\\u5426\\u6709\\u4EC0\\u4E48\\u5173\\u7CFB\\uFF1F\\u4E3A\\u4EC0\\u4E48\\u8981\\u5224\\u65AD((S + sum) & 1) == 1\\uFF1F\\n\\n\\u672C\\u9898\\u4E2D\\u6BCF\\u4E2A\\u6570\\u5B57\\u524D\\u90FD\\u6709\\u4E00\\u4E2A\\u7B26\\u53F7\\uFF0C+ \\u6216 - \\uFF0C\\u5982\\u679C\\u5C06\\u6574\\u4E2A\\u6570\\u7EC4\\u6309\\u7167\\u6570\\u5B57\\u4E4B\\u524D\\u7684\\u7B26\\u53F7\\u5206\\u6210\\u4E24\\u90E8\\u5206\\uFF0C\\u4E00\\u90E8\\u5206\\u7684\\u7B26\\u53F7\\u5168\\u662F + \\uFF0C\\u53E6\\u4E00\\u90E8\\u5206\\u7684\\u7B26\\u53F7\\u5168\\u662F - \\uFF0C\\u7136\\u540E\\u8BA9\\u4E24\\u90E8\\u5206\\u7684\\u548C\\u5206\\u522B\\u662F x y \\uFF0C\\u90A3\\u4E48\\u6709\\u5173\\u7CFB\\u5F0F\\uFF1A\\n\\n    x + y = sum\\n    x - y = S\\n\\n\\u4E8E\\u662F\\u6709x + x = S + sum = 2 * x\\uFF0C\\u4E8E\\u662F\\u5F97\\u51FA\\u7ED3\\u8BBA\\uFF1AS + sum \\u5FC5\\u7136\\u662F\\u5076\\u6570\\uFF0C\\u6240\\u4EE5\\u624D\\u6709\\u4E86\\u672C\\u9898\\u5F00\\u59CB\\u7684\\u5224\\u65AD\\u3002\\n\\nS4:\\u5212\\u5206\\u6570\\u7EC4 & \\u52A8\\u6001\\u89C4\\u5212\\n\\n\\u4E0A\\u9762\\u7684\\u8FD9\\u4E2A\\u5173\\u7CFB\\u5F0FS + sum = 2 * x\\u4E5F\\u53EF\\u4EE5\\u52A0\\u4EE5\\u5229\\u7528\\uFF0C\\u5F97\\u51FA(S + sum) / 2 = x\\uFF0C\\u4E5F\\u5C31\\u662F\\u8BF4\\u672C\\u9898\\u53EF\\u4EE5\\u53D8\\u4E3A\\uFF0C\\u4F7F nums \\u6570\\u7EC4\\u7684\\u5B50\\u6570\\u7EC4\\u7684\\u548C\\u7B49\\u4E8E S+sum \\u7684\\u4E00\\u534A\\uFF0C\\u6C42\\u51FA\\u7B26\\u5408\\u6761\\u4EF6\\u7684\\u5B50\\u6570\\u7EC4\\u7684\\u4E2A\\u6570\\u3002\\n\\n\\u4E8E\\u662F\\u6709\\uFF1A\\n\\n    public static int findTargetSumWays(int[] nums, int S) {\\n        int sum = 0;\\n        for (int num : nums) sum += num;\\n        if (sum < S || ((sum + S) & 1) == 1) return 0;\\n        sum = (sum + S) >> 1;\\n        int[] dp = new int[sum+1];\\n        dp[0] = 1;\\n        for (int num : nums) {\\n            for (int i = sum; i >= num; i--) {\\n                dp[i] += dp[i-num];\\n            }\\n        }\\n        return dp[sum];\\n    }\\n\\n\\u6B64\\u65F6\\uFF0C\\u5916\\u5C42\\u662F\\u5BF9\\u6570\\u7EC4\\u7684\\u5FAA\\u73AF\\uFF0C\\u5185\\u5C42\\u901A\\u8FC7\\u4E00\\u4E2A i=num\\uFF5Esum \\u7684\\u5FAA\\u73AF\\uFF0C\\u6C42\\u51FA\\u6240\\u6709\\u52A0\\u4E0A\\u5F53\\u524D\\u4F4D\\u7F6E\\u7684 num \\u80FD\\u5230\\u5F97\\u5230 i \\u7684\\u89E3\\u3002\\u5916\\u5C42\\u5BF9\\u6570\\u7EC4\\u7684\\u5FAA\\u73AF\\uFF0C\\u6BCF\\u5230\\u4E00\\u4E2A\\u6570\\u5B57 num \\uFF0C\\u5C31\\u662F\\u6307\\u5BF9\\u4E8E\\u5B50\\u6570\\u7EC4[0,...,num]\\u6765\\u8BF4\\uFF0Cdp[i] \\u5B58\\u653E\\u7740\\u6570\\u7EC4[0,...,num]\\u4E2D\\u548C\\u4E3A i \\u7684\\u5B50\\u6570\\u7EC4\\u7684\\u4E2A\\u6570\\uFF0C\\u90A3\\u4E48\\u5916\\u5C42\\u5BF9\\u6570\\u7EC4\\u7684\\u5FAA\\u73AF\\u5B8C\\u4E86\\u4E4B\\u540E\\uFF0Cdp[i] \\u5B58\\u653E\\u7684\\u5C31\\u662F\\u6570\\u7EC4 nums \\u7684\\u548C\\u4E3A i \\u7684\\u5B50\\u6570\\u7EC4\\u7684\\u4E2A\\u6570\\uFF0C\\u6240\\u4EE5\\uFF0C\\u6B64\\u65F6 dp[sum] \\u5C31\\u662F\\u672C\\u9898\\u7684\\u89E3\\u3002\\n\\n\\u5176\\u4E2D\\uFF0C\\u8D77\\u59CB\\u4F4D\\u7F6E\\u7684dp[0] = 1\\uFF0C\\u662F\\u6574\\u4E2A\\u8BA1\\u7B97\\u7684\\u5F00\\u7AEF\\uFF0C\\u7531 0+num=num \\uFF0C\\u5F97\\u5230dp[num] = 1\\uFF0C\\u7136\\u540E\\u4EE5\\u6B64\\u7C7B\\u63A8\\u3002\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 165216,
                "title": "java-dynamic-programming-an-intuitive-approach-explained",
                "content": "We define dp[i][j] as the number of ways to make a sum of j from top i number in nums. The initial state is that there is one way to form top 0 number in nums to get a sum of 0, so, dp[0][0] = 0. Intuitively dp[i][j] = dp[i-1][j-nums[i]]+dp[i-1][j+nums[i]], which means current number of ways to get sum j at top i should be from ways of getting sum j - nums[i] at top i-1 or j+nums[i] at top i-1, since we can both add and subtract nums[i] to get next sum. Please note that, when dynamically calculate the transitions, the range of sum will vary between -sum and sum(sum is the sum of nums). so, I use a 2d array with a width of 2*sum to log all possible intermediate results.\\n```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int S) {\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum += nums[i];\\n        }\\n        if(S>sum||S<-sum){\\n            return 0;\\n        }\\n        int[][] dp = new int[nums.length+1][sum*2+1];\\n        dp[0][0+sum] = 1;\\n        for(int i=1;i<=nums.length;i++){\\n            for(int j=0;j<=sum*2;j++){\\n                int n = 0;\\n                if (j-nums[i-1]>=0){\\n                    n+=dp[i-1][j-nums[i-1]];\\n                }\\n                if (j+nums[i-1]<=2*sum){\\n                    n+=dp[i-1][j+nums[i-1]];\\n                }\\n                dp[i][j] = n;\\n            }\\n        }\\n        return dp[nums.length][S+sum];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int S) {\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum += nums[i];\\n        }\\n        if(S>sum||S<-sum){\\n            return 0;\\n        }\\n        int[][] dp = new int[nums.length+1][sum*2+1];\\n        dp[0][0+sum] = 1;\\n        for(int i=1;i<=nums.length;i++){\\n            for(int j=0;j<=sum*2;j++){\\n                int n = 0;\\n                if (j-nums[i-1]>=0){\\n                    n+=dp[i-1][j-nums[i-1]];\\n                }\\n                if (j+nums[i-1]<=2*sum){\\n                    n+=dp[i-1][j+nums[i-1]];\\n                }\\n                dp[i][j] = n;\\n            }\\n        }\\n        return dp[nums.length][S+sum];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97419,
                "title": "java-and-python-dp-solution-o-nk",
                "content": "The idea is to keep all possible sums for nums[i] and generate all possible sums for nums[i+1] using + and -.\\n\\nPython\\n\\n```\\ndef findTargetSumWays(self, nums, S):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type S: int\\n        :rtype: int\\n        \"\"\"\\n        if len(nums)==0:\\n            return 0\\n        from collections import defaultdict\\n        prev = defaultdict(int)\\n        prev[nums[0]] += 1\\n        prev[-nums[0]] += 1\\n        \\n        for i in range(1, len(nums)):\\n            temp = defaultdict(int)\\n            for k,v in prev.items():\\n                temp[k-nums[i]]+=v\\n                temp[k+nums[i]]+=v\\n            prev = temp\\n        return prev[S]\\n```\\n\\n\\nJAVA \\n```\\npublic int findTargetSumWays(int[] nums, int S) {\\n        if(nums.length==0) return 0;\\n        Map<Integer, Integer> prev = new HashMap<Integer, Integer>();;\\n        Map<Integer, Integer> cur;\\n        for(int i = 0; i< nums.length; i++){\\n            //for nums[0]\\n            if(i==0){\\n                prev.put(nums[0], 1);\\n                if(!prev.containsKey(-nums[0])){\\n                    prev.put(-nums[0], 1);\\n                }else{\\n                    prev.put(-nums[0], 2); // if nums[0] is 0.\\n                }\\n            }else{\\n                cur = new HashMap<Integer, Integer>();\\n                for(Map.Entry<Integer, Integer> entry: prev.entrySet()){\\n                    int sumSoFar = entry.getKey();\\n                    int count = entry.getValue();\\n                    // add num[i]\\n                     if(!cur.containsKey(sumSoFar+nums[i])){\\n                         cur.put(sumSoFar+nums[i], count);\\n                     }else{\\n                         cur.put(sumSoFar+nums[i], cur.get(sumSoFar+nums[i])+count);\\n                     }\\n                     // subtract num[i]\\n                     if(!cur.containsKey(sumSoFar-nums[i])){\\n                         cur.put(sumSoFar-nums[i], count);\\n                     }else{\\n                         cur.put(sumSoFar-nums[i], cur.get(sumSoFar-nums[i])+count);\\n                     }\\n                }\\n                prev = cur;\\n            }\\n        }\\n        return prev.containsKey(S)? prev.get(S) : 0;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef findTargetSumWays(self, nums, S):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type S: int\\n        :rtype: int\\n        \"\"\"\\n        if len(nums)==0:\\n            return 0\\n        from collections import defaultdict\\n        prev = defaultdict(int)\\n        prev[nums[0]] += 1\\n        prev[-nums[0]] += 1\\n        \\n        for i in range(1, len(nums)):\\n            temp = defaultdict(int)\\n            for k,v in prev.items():\\n                temp[k-nums[i]]+=v\\n                temp[k+nums[i]]+=v\\n            prev = temp\\n        return prev[S]\\n```\n```\\npublic int findTargetSumWays(int[] nums, int S) {\\n        if(nums.length==0) return 0;\\n        Map<Integer, Integer> prev = new HashMap<Integer, Integer>();;\\n        Map<Integer, Integer> cur;\\n        for(int i = 0; i< nums.length; i++){\\n            //for nums[0]\\n            if(i==0){\\n                prev.put(nums[0], 1);\\n                if(!prev.containsKey(-nums[0])){\\n                    prev.put(-nums[0], 1);\\n                }else{\\n                    prev.put(-nums[0], 2); // if nums[0] is 0.\\n                }\\n            }else{\\n                cur = new HashMap<Integer, Integer>();\\n                for(Map.Entry<Integer, Integer> entry: prev.entrySet()){\\n                    int sumSoFar = entry.getKey();\\n                    int count = entry.getValue();\\n                    // add num[i]\\n                     if(!cur.containsKey(sumSoFar+nums[i])){\\n                         cur.put(sumSoFar+nums[i], count);\\n                     }else{\\n                         cur.put(sumSoFar+nums[i], cur.get(sumSoFar+nums[i])+count);\\n                     }\\n                     // subtract num[i]\\n                     if(!cur.containsKey(sumSoFar-nums[i])){\\n                         cur.put(sumSoFar-nums[i], count);\\n                     }else{\\n                         cur.put(sumSoFar-nums[i], cur.get(sumSoFar-nums[i])+count);\\n                     }\\n                }\\n                prev = cur;\\n            }\\n        }\\n        return prev.containsKey(S)? prev.get(S) : 0;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3870319,
                "title": "space-optimisation-in-python-tabulation-striver-trick",
                "content": "### Approach:-\\nThe input is an integer list nums and a target integer target.\\nThe function calculates the total sum of all elements in the nums list and checks if the sum plus the target is even and non-negative. If not, it returns 0 because there is no way to achieve the target sum in such cases.\\nIf the sum plus the target is even and non-negative, it proceeds to find the required sum to achieve, which is (sum(nums) + target) // 2.\\nThe function initializes two lists, prev and curr, both with length target + 1, to store the results of subproblems. The prev list will represent the number of ways to achieve each target sum up to target using the first i elements of the nums list, where i ranges from 0 to len(nums).\\nThe base case is set as prev[0] = 1, indicating that there is one way to achieve the target sum 0, which is an empty subset (not picking any elements).\\nThe function then iterates through the elements of nums (from the 1st to the last) and the target sums (from 0 to target) to fill in the curr list using the dynamic programming approach.\\nFor each element nums[i - 1], it checks if the current target sum k is greater than or equal to nums[i - 1]. If it is, there are two choices:\\na. Exclude the current element: The number of ways to achieve the target sum k using the first i elements is prev[k].\\nb. Include the current element: The number of ways to achieve the target sum k - nums[i - 1] using the first i elements is prev[k - nums[i - 1]].\\nThe total number of ways is the sum of these two choices, which is stored in curr[k].\\nAfter processing all the elements, the prev list is updated to be equal to the curr list for the next iteration.\\nFinally, the function returns prev[target], which represents the number of ways to achieve the target sum using all elements of the nums list.\\n\\n\\n### Code below :)\\n```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        if (sum(nums)+target)%2!=0 or sum(nums)+target<0:\\n            return 0\\n        target=(sum(nums)+target)//2\\n        prev=[0 for _ in range(target + 1)]\\n        curr=[0 for _ in range(target + 1)]\\n        \\n        prev[0] = 1\\n        \\n\\n       \\n        for i in range(1, len(nums)+ 1):\\n            for k in range(target + 1):\\n                \\n                if nums[i - 1] > k:\\n                    curr[k] = prev[k]\\n                else:\\n                    \\n                    curr[k] = prev[k] + prev[k -nums[i - 1]]\\n            prev=curr[:]\\n\\n        return prev[target]\\n```\\n\\n### Please upvote it :)\\n![image](https://assets.leetcode.com/users/images/45fe3b19-7357-4f09-8675-7060e3141ef0_1691299242.9026108.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        if (sum(nums)+target)%2!=0 or sum(nums)+target<0:\\n            return 0\\n        target=(sum(nums)+target)//2\\n        prev=[0 for _ in range(target + 1)]\\n        curr=[0 for _ in range(target + 1)]\\n        \\n        prev[0] = 1\\n        \\n\\n       \\n        for i in range(1, len(nums)+ 1):\\n            for k in range(target + 1):\\n                \\n                if nums[i - 1] > k:\\n                    curr[k] = prev[k]\\n                else:\\n                    \\n                    curr[k] = prev[k] + prev[k -nums[i - 1]]\\n            prev=curr[:]\\n\\n        return prev[target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727192,
                "title": "c-only-recursion-from-n-to-0",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n-You can find the optimal approach from other Posts.\\n-This is for People who just want to see the Recursion.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int check(int index, int target, vector<int> &nums)\\n    {\\n        if(index==-1 &&  target==0) return 1;\\n        if(index==-1) return 0;\\n        int add=check(index-1,target-nums[index],nums);\\n        int sub=check(index-1,target+nums[index],nums);\\n\\n        return add+sub;\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        \\n        int n=nums.size();\\n        return check (n-1,target,nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(int index, int target, vector<int> &nums)\\n    {\\n        if(index==-1 &&  target==0) return 1;\\n        if(index==-1) return 0;\\n        int add=check(index-1,target-nums[index],nums);\\n        int sub=check(index-1,target+nums[index],nums);\\n\\n        return add+sub;\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        \\n        int n=nums.size();\\n        return check (n-1,target,nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703975,
                "title": "java-recursive-memoization-tabulation-and-space-optimized-solution-with-explanation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    // int ans = 0;\\n    int total = 0;\\n    public int findTargetSumWays(int[] nums, int target) {\\n        // helper(nums, 0, 0, target);\\n        // return ans;\\n\\n        for(int a : nums){\\n            total += a;\\n        }\\n        int[][] dp = new int[nums.length][2 * total + 1];\\n        for(int[] row : dp){\\n            Arrays.fill(row, Integer.MIN_VALUE);\\n        }\\n        return helperMem(nums, 0, 0, target, dp);\\n\\n        // return helperTab(nums, target);\\n\\n        // return helperSO(nums, target);\\n    }\\n\\n    // Recursive Method\\n     public void helper(int[] nums, int i, int sum, int target){\\n         if(i == nums.length){\\n             if(sum == target) ans++;\\n         }else{\\n             helper(nums, i + 1, sum + nums[i], target);\\n             helper(nums, i + 1, sum - nums[i], target);\\n         }\\n     }\\n\\n    // Memoization Method\\n    public int helperMem(int[] nums, int i, int sum, int target, int[][] dp){\\n        if(i == nums.length){\\n            if(sum == target) return 1;\\n            else return 0;\\n        }else{\\n            if(dp[i][sum + total] != Integer.MIN_VALUE) return dp[i][sum + total];\\n            int pos = helperMem(nums, i + 1, sum + nums[i], target, dp);\\n            int neg = helperMem(nums, i + 1, sum - nums[i], target, dp);\\n            return dp[i][sum + total] = pos + neg;\\n        }\\n    }\\n\\n    // Tabulation Method\\n    public int helperTab(int[] nums, int target){\\n        int total = Arrays.stream(nums).sum(); // sum of the array, so that we don\\'t go out of array anytime\\n        int[][] dp = new int[nums.length][2 * total + 1]; // 2 * total because we have both positive and negative vals\\n\\n        // Base Values\\n        dp[0][nums[0] + total] = 1;\\n        dp[0][-nums[0] + total] += 1;\\n\\n        // first loop to iterate over remaining value of the nums array\\n        for(int i = 1; i < nums.length; i++){\\n            // second loop that iterates over the possible sums (sum) from -total to total. This loop considers \\n            // all possible sums that can be formed by adding or subtracting the previous elements.\\n            for(int sum = -total; sum <= total; sum++){\\n                // an if condition to check if there are any ways to reach the current sum at index i-1 in the dp\\n                // array. If the value at dp[i - 1][sum + total] is greater than 0, it means that there are ways \\n                // to reach the current sum.\\n                if(dp[i - 1][sum + total] > 0){\\n                    dp[i][sum + nums[i] + total] += dp[i - 1][sum + total];\\n                    dp[i][sum - nums[i] + total] += dp[i - 1][sum + total];\\n                }\\n            }\\n        }\\n        // if absolute value of target is greater than total of nums, means the target is not acheivable by the\\n        // value of nums array so return 0 \\n        return Math.abs(target) > total ? 0 : dp[nums.length - 1][target + total];\\n    }\\n\\n    //Space Optimization\\n    // Looking at the tabulation solution we can say that current row of dp only requires the last row of dp. so we\\n    // can save some space here by creating new array in every loop call and just updating the value of array at the\\n    // last of nested loop everytime.\\n    public int helperSO(int[] nums, int target){\\n        int total = Arrays.stream(nums).sum();\\n        int[] dp = new int[2 * total + 1];\\n        dp[nums[0] + total] = 1;\\n        dp[-nums[0] + total] += 1;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            int[] next = new int[2 * total + 1];\\n            for (int sum = -total; sum <= total; sum++) {\\n                if (dp[sum + total] > 0) {\\n                    next[sum + nums[i] + total] += dp[sum + total];\\n                    next[sum - nums[i] + total] += dp[sum + total];\\n                }\\n            }\\n            dp = next;\\n        }\\n        return Math.abs(target) > total ? 0 : dp[target + total];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    // int ans = 0;\\n    int total = 0;\\n    public int findTargetSumWays(int[] nums, int target) {\\n        // helper(nums, 0, 0, target);\\n        // return ans;\\n\\n        for(int a : nums){\\n            total += a;\\n        }\\n        int[][] dp = new int[nums.length][2 * total + 1];\\n        for(int[] row : dp){\\n            Arrays.fill(row, Integer.MIN_VALUE);\\n        }\\n        return helperMem(nums, 0, 0, target, dp);\\n\\n        // return helperTab(nums, target);\\n\\n        // return helperSO(nums, target);\\n    }\\n\\n    // Recursive Method\\n     public void helper(int[] nums, int i, int sum, int target){\\n         if(i == nums.length){\\n             if(sum == target) ans++;\\n         }else{\\n             helper(nums, i + 1, sum + nums[i], target);\\n             helper(nums, i + 1, sum - nums[i], target);\\n         }\\n     }\\n\\n    // Memoization Method\\n    public int helperMem(int[] nums, int i, int sum, int target, int[][] dp){\\n        if(i == nums.length){\\n            if(sum == target) return 1;\\n            else return 0;\\n        }else{\\n            if(dp[i][sum + total] != Integer.MIN_VALUE) return dp[i][sum + total];\\n            int pos = helperMem(nums, i + 1, sum + nums[i], target, dp);\\n            int neg = helperMem(nums, i + 1, sum - nums[i], target, dp);\\n            return dp[i][sum + total] = pos + neg;\\n        }\\n    }\\n\\n    // Tabulation Method\\n    public int helperTab(int[] nums, int target){\\n        int total = Arrays.stream(nums).sum(); // sum of the array, so that we don\\'t go out of array anytime\\n        int[][] dp = new int[nums.length][2 * total + 1]; // 2 * total because we have both positive and negative vals\\n\\n        // Base Values\\n        dp[0][nums[0] + total] = 1;\\n        dp[0][-nums[0] + total] += 1;\\n\\n        // first loop to iterate over remaining value of the nums array\\n        for(int i = 1; i < nums.length; i++){\\n            // second loop that iterates over the possible sums (sum) from -total to total. This loop considers \\n            // all possible sums that can be formed by adding or subtracting the previous elements.\\n            for(int sum = -total; sum <= total; sum++){\\n                // an if condition to check if there are any ways to reach the current sum at index i-1 in the dp\\n                // array. If the value at dp[i - 1][sum + total] is greater than 0, it means that there are ways \\n                // to reach the current sum.\\n                if(dp[i - 1][sum + total] > 0){\\n                    dp[i][sum + nums[i] + total] += dp[i - 1][sum + total];\\n                    dp[i][sum - nums[i] + total] += dp[i - 1][sum + total];\\n                }\\n            }\\n        }\\n        // if absolute value of target is greater than total of nums, means the target is not acheivable by the\\n        // value of nums array so return 0 \\n        return Math.abs(target) > total ? 0 : dp[nums.length - 1][target + total];\\n    }\\n\\n    //Space Optimization\\n    // Looking at the tabulation solution we can say that current row of dp only requires the last row of dp. so we\\n    // can save some space here by creating new array in every loop call and just updating the value of array at the\\n    // last of nested loop everytime.\\n    public int helperSO(int[] nums, int target){\\n        int total = Arrays.stream(nums).sum();\\n        int[] dp = new int[2 * total + 1];\\n        dp[nums[0] + total] = 1;\\n        dp[-nums[0] + total] += 1;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            int[] next = new int[2 * total + 1];\\n            for (int sum = -total; sum <= total; sum++) {\\n                if (dp[sum + total] > 0) {\\n                    next[sum + nums[i] + total] += dp[sum + total];\\n                    next[sum - nums[i] + total] += dp[sum + total];\\n                }\\n            }\\n            dp = next;\\n        }\\n        return Math.abs(target) > total ? 0 : dp[target + total];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647601,
                "title": "2-solutions-using-top-down-easiest-problem-of-dp-self-explanatory-comments",
                "content": "~ \\uD835\\uDE52\\uD835\\uDE5E\\uD835\\uDE69\\uD835\\uDE5D \\u2764\\uFE0F \\uD835\\uDE57\\uD835\\uDE6E \\uD835\\uDE43\\uD835\\uDE5E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE63 \\uD83D\\uDE0A\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHey There! Its Easy Just Take A Look At The  Code And Comments Within It, You\\'ll Get It.\\n\\n- NOTE : Start Reading From Main Method\\n- Still Got Doubts! Feel Free To Comment, I Will Definately Reply.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Both Accepted :- \\n1. Recursion\\n2. Recursion + Memoization\\n\\n# Complexity\\n- Time complexity: Mentioned in the code\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Mentioned in the code\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` \\n// Program to find the number of different expressions that can build, which evaluates to target ~ coded by Hiren\\n#include <iostream>\\n#include <vector>\\n#include <unordered_map>\\nusing namespace std;\\n\\n// #1 Method to find the number of different expressions using recursion only - O(2^N) & O(N)\\nint findTargetSumWays(vector<int>& nums, int target, int sum = 0, int index = 0) {\\n    // If reached the end of the array\\n    if(index == nums.size()) {\\n        // If sum equals target than we got 1 valid way\\n        if(sum == target)\\n            return 1;\\n        // Else we got no valid way\\n        else\\n            return 0;\\n    }\\n\\n    // There are always two possibilities at each value\\n    int takePos = findTargetSumWays(nums, target, sum + nums[index], index + 1); // Is to add the current value to sum\\n    int takeNeg = findTargetSumWays(nums, target, sum - nums[index], index + 1); // Is to subtract the current value to sum\\n\\n    // Return the number of total ways\\n    return takePos + takeNeg;\\n}\\n\\n// #2 Method helper\\nint solveWithMemo(vector<int>& nums, int target, int sum, int index, unordered_map<string, int>& memo) {\\n    // If reached the end of the array\\n    if(index == nums.size()) {\\n        // If sum equals target than we got 1 valid way\\n        if(sum == target)\\n            return 1;\\n        // Else we got no valid way\\n        else\\n            return 0;\\n    }\\n\\n    string key = to_string(index) + \"-\" + to_string(sum);\\n\\n    if(memo.count(key))\\n        return memo[key];\\n\\n    // There are always two possibilities at each value\\n    int takePos = solveWithMemo(nums, target, sum + nums[index], index + 1, memo); // Is to add the current value to sum\\n    int takeNeg = solveWithMemo(nums, target, sum - nums[index], index + 1, memo); // Is to subtract the current value to sum\\n\\n    // Store and return the number of total ways\\n    return memo[key] = takePos + takeNeg;\\n}\\n\\n// #2 Method to find the number of different expressions using memoization - O(N*S) & O(N*S) : Where S is the possible combinations of sum \\nint findTargetSumWays_(vector<int>& nums, int target) {\\n    unordered_map<string, int> memo;\\n    return solveWithMemo(nums, target, 0, 0, memo);\\n}\\n\\n// Driver code\\nint main() {\\n    vector<int> nums = {1, 1, 1, 1, 1}; \\n\\n    // Print values\\n    for(int num : nums)\\n        cout<<num<<\\' \\';\\n\\n    // Method call\\n    int sumWays = findTargetSumWays_(nums, 3);\\n    cout<<\"\\\\nThe number of different expressions which evaluates to target is : \"<<sumWays;\\n\\n    return 0;\\n}\\n// Link: https://leetcode.com/problems/target-sum/\\n```\\n\\uD835\\uDDE8\\uD835\\uDDE3\\uD835\\uDDE9\\uD835\\uDDE2\\uD835\\uDDE7\\uD835\\uDDD8 \\uD835\\uDDDC\\uD835\\uDDD9 \\uD835\\uDDEC\\uD835\\uDDE2\\uD835\\uDDE8 \\uD835\\uDDDF\\uD835\\uDDDC\\uD835\\uDDDE\\uD835\\uDDD8 \\uD835\\uDDE7\\uD835\\uDDDB\\uD835\\uDDD8 \\uD835\\uDDE6\\uD835\\uDDE2\\uD835\\uDDDF\\uD835\\uDDE8\\uD835\\uDDE7\\uD835\\uDDDC\\uD835\\uDDE2\\uD835\\uDDE1 \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "``` \\n// Program to find the number of different expressions that can build, which evaluates to target ~ coded by Hiren\\n#include <iostream>\\n#include <vector>\\n#include <unordered_map>\\nusing namespace std;\\n\\n// #1 Method to find the number of different expressions using recursion only - O(2^N) & O(N)\\nint findTargetSumWays(vector<int>& nums, int target, int sum = 0, int index = 0) {\\n    // If reached the end of the array\\n    if(index == nums.size()) {\\n        // If sum equals target than we got 1 valid way\\n        if(sum == target)\\n            return 1;\\n        // Else we got no valid way\\n        else\\n            return 0;\\n    }\\n\\n    // There are always two possibilities at each value\\n    int takePos = findTargetSumWays(nums, target, sum + nums[index], index + 1); // Is to add the current value to sum\\n    int takeNeg = findTargetSumWays(nums, target, sum - nums[index], index + 1); // Is to subtract the current value to sum\\n\\n    // Return the number of total ways\\n    return takePos + takeNeg;\\n}\\n\\n// #2 Method helper\\nint solveWithMemo(vector<int>& nums, int target, int sum, int index, unordered_map<string, int>& memo) {\\n    // If reached the end of the array\\n    if(index == nums.size()) {\\n        // If sum equals target than we got 1 valid way\\n        if(sum == target)\\n            return 1;\\n        // Else we got no valid way\\n        else\\n            return 0;\\n    }\\n\\n    string key = to_string(index) + \"-\" + to_string(sum);\\n\\n    if(memo.count(key))\\n        return memo[key];\\n\\n    // There are always two possibilities at each value\\n    int takePos = solveWithMemo(nums, target, sum + nums[index], index + 1, memo); // Is to add the current value to sum\\n    int takeNeg = solveWithMemo(nums, target, sum - nums[index], index + 1, memo); // Is to subtract the current value to sum\\n\\n    // Store and return the number of total ways\\n    return memo[key] = takePos + takeNeg;\\n}\\n\\n// #2 Method to find the number of different expressions using memoization - O(N*S) & O(N*S) : Where S is the possible combinations of sum \\nint findTargetSumWays_(vector<int>& nums, int target) {\\n    unordered_map<string, int> memo;\\n    return solveWithMemo(nums, target, 0, 0, memo);\\n}\\n\\n// Driver code\\nint main() {\\n    vector<int> nums = {1, 1, 1, 1, 1}; \\n\\n    // Print values\\n    for(int num : nums)\\n        cout<<num<<\\' \\';\\n\\n    // Method call\\n    int sumWays = findTargetSumWays_(nums, 3);\\n    cout<<\"\\\\nThe number of different expressions which evaluates to target is : \"<<sumWays;\\n\\n    return 0;\\n}\\n// Link: https://leetcode.com/problems/target-sum/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3345532,
                "title": "top-down-approach-c-solution-that-makes-sense-clearly-explained-countsubsetsmakesum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLets assume,\\nArray {1,2,1,3}, Target = 3\\n\\nWe have to count sets whose sum is equal to given target when adding +/- to each element.\\n\\nThere are two such sets:\\n{+1,+1,+3, -2}, {+2,+3, -1,-1}\\n\\nWe can expresss as subsets(SS):\\n{+1,+1,+3, -2}: PositiveSumSS {1,1,3}; NegativeSumSS {2}\\n{+2,+3, -1,-1}: PositiveSumSS {2,3}; NegativeSumSS {1,1}\\n\\n\\nNow, \\nlet, sum of PositiveSumSS = sum(p) \\nand sum of NegativeSumSS = sum(N)\\n\\nsum(P) - sum(N) = target\\nsum(P) + sum(N) = sum(nums)\\nso, sum(P) = (target + sum(nums))/2 = sumToCheck\\n\\nAt this point, the problem is deduced into a problem- count of subsets that make a given sum ( i.e sum(p) )\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*M)\\nwhere,\\nN= Number of elements in item array\\nM= The total amount\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int findTargetSumWays(vector<int>& nums, int targetSum) {\\n        \\n        if(nums.size() ==0 ) return 0;\\n        \\n        int allSum = 0;\\n        for(auto elem: nums)\\n        {\\n            allSum+= elem;\\n        }\\n\\n        int target = abs(targetSum);\\n\\n        //corner cases\\n        if(target > allSum) return 0;\\n\\n        // both even or both odd. Or sumToCheck will become franctional. Then Count or ways = 0\\n        if((target + allSum)%2 != 0) return 0;\\n\\n        int sumToCheck = (target + allSum)/2;\\n\\n        return countSubsetsMakeSum(nums, sumToCheck);\\n\\n    }\\n\\n    int countSubsetsMakeSum (vector<int>& items, int amount){\\n\\n        int n = items.size();\\n\\n        vector<vector<int>> dp (n+1, vector<int>(amount+1)); // dp signifies countWays or count Subset\\n        \\n        dp[0][0] = items[0] == 0 ? 2:1; // if item array first elemment is zero, we can make the amount zero in 2 ways: {}, {0}\\n\\n        //first column\\n        for(int i =1 ; i < n ; i++)\\n        {    \\n            if(items[i] == 0) dp[i][0] = 2*dp[i-1][0]; // if item array current elemment is zero, we can make the amount 0 in twice ways of prev elemment\\n            else dp[i][0] = dp[i-1][0]; // if item array current elemment is not zero, we can make the amount 0 in same ways of prev elemment\\n        //Explained below:\\n        #if 0\\n        example: items = {0,0,2,3}, amount = 0\\n        items   subsetsMakeSum0     count\\n        {0}       {},{0}              2\\n        {0,0}     {},{0},{0},{0,0}    4\\n        {0,0,2}   {},{0},{0},{0,0}    4\\n        {0,0,2,3} {},{0},{0},{0,0}    4\\n        #endif\\n\\n        }\\n        //first row\\n        for(int j =1; j <= amount ; j++)\\n        { \\n            if(items[0] == j) \\n                dp[0][j] = 1;\\n        }\\n\\n        for(int i =1; i < n; i++){\\n            for(int j =1; j <= amount ; j++){\\n                int include =0;\\n                int exclude =0;\\n\\n                if(i>0)\\n                    exclude = dp[i-1][j];\\n                if(items[i] <= j)\\n                    include = dp[i-1][j-items[i]];\\n\\n                dp[i][j] = include + exclude;\\n            }\\n        }\\n\\n        return dp[n-1][amount];\\n    }\\n\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int findTargetSumWays(vector<int>& nums, int targetSum) {\\n        \\n        if(nums.size() ==0 ) return 0;\\n        \\n        int allSum = 0;\\n        for(auto elem: nums)\\n        {\\n            allSum+= elem;\\n        }\\n\\n        int target = abs(targetSum);\\n\\n        //corner cases\\n        if(target > allSum) return 0;\\n\\n        // both even or both odd. Or sumToCheck will become franctional. Then Count or ways = 0\\n        if((target + allSum)%2 != 0) return 0;\\n\\n        int sumToCheck = (target + allSum)/2;\\n\\n        return countSubsetsMakeSum(nums, sumToCheck);\\n\\n    }\\n\\n    int countSubsetsMakeSum (vector<int>& items, int amount){\\n\\n        int n = items.size();\\n\\n        vector<vector<int>> dp (n+1, vector<int>(amount+1)); // dp signifies countWays or count Subset\\n        \\n        dp[0][0] = items[0] == 0 ? 2:1; // if item array first elemment is zero, we can make the amount zero in 2 ways: {}, {0}\\n\\n        //first column\\n        for(int i =1 ; i < n ; i++)\\n        {    \\n            if(items[i] == 0) dp[i][0] = 2*dp[i-1][0]; // if item array current elemment is zero, we can make the amount 0 in twice ways of prev elemment\\n            else dp[i][0] = dp[i-1][0]; // if item array current elemment is not zero, we can make the amount 0 in same ways of prev elemment\\n        //Explained below:\\n        #if 0\\n        example: items = {0,0,2,3}, amount = 0\\n        items   subsetsMakeSum0     count\\n        {0}       {},{0}              2\\n        {0,0}     {},{0},{0},{0,0}    4\\n        {0,0,2}   {},{0},{0},{0,0}    4\\n        {0,0,2,3} {},{0},{0},{0,0}    4\\n        #endif\\n\\n        }\\n        //first row\\n        for(int j =1; j <= amount ; j++)\\n        { \\n            if(items[0] == j) \\n                dp[0][j] = 1;\\n        }\\n\\n        for(int i =1; i < n; i++){\\n            for(int j =1; j <= amount ; j++){\\n                int include =0;\\n                int exclude =0;\\n\\n                if(i>0)\\n                    exclude = dp[i-1][j];\\n                if(items[i] <= j)\\n                    include = dp[i-1][j-items[i]];\\n\\n                dp[i][j] = include + exclude;\\n            }\\n        }\\n\\n        return dp[n-1][amount];\\n    }\\n\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247236,
                "title": "recursive-explained-python",
                "content": "# Intuition\\nFrom last Index go till involving first index(0-indexed) and check if by following certain combinations you reached the currSum as your target then return 1 (as 1 possible combination).\\n`Why i < 0 and not i == 0 condition?`\\n`Because we are supposed to  consider all elements of the given nums array so iterate till i < 0 which makes sure to include 0-index element`\\nYou can either add to currSum(+1) or you can subtract from currSum(-1) and then return the all possible combinations.\\nIt is very similar to pick and no-pick DP questions\\n\\n# Code\\n```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        @cache\\n        def recur(i, summ):\\n            if i < 0:\\n                if summ == target:\\n                    return 1\\n                return 0\\n            negative = recur(i-1, summ-nums[i])\\n            positive = recur(i-1, summ+nums[i])\\n            return negative + positive\\n        return recur(len(nums)-1, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        @cache\\n        def recur(i, summ):\\n            if i < 0:\\n                if summ == target:\\n                    return 1\\n                return 0\\n            negative = recur(i-1, summ-nums[i])\\n            positive = recur(i-1, summ+nums[i])\\n            return negative + positive\\n        return recur(len(nums)-1, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153385,
                "title": "java-recursive-approach-using-dfs-brute-force-solution-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We need to create a global count variable for number of different expressions that you can build.\\n2. We call up a DFS method, passing in the input array, current index, current sum, and the target. \\n3. Once the DFS method is created, we will check if the current index is equal to the input array length. If it is, then we will check if the current sum is equal to the target. If it is, then we will increment the count, otherwise we return. \\n4. If the current index doesn\\'t equal the input array length, then we will make two recursive calls:\\na) Pass in the input array, current index plus 1, the sum being added to the number of the current index, and the target.\\nb) Pass in the input array, current index plus 1, the sum being subtracted to the number of the current index, and the target.\\n5. Finally, return the count;\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^n) - where n is the number of numbers in the input array, since each number can be either positive or negative.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) - where as the max depth of the call stack is equal to the number of numbers in the input array.\\n# Code\\n```\\nclass Solution {\\n    //step 1\\n    int cnt = 0;\\n    public int findTargetSumWays(int[] nums, int target) {\\n        //step 2\\n        DFS(nums, 0, 0, target);\\n        //step 5\\n        return cnt;\\n    }\\n\\n    private void DFS(int[] nums, int index, int sum, int target) {\\n        //step 3\\n        if (index == nums.length) {\\n            if (sum == target) cnt++;\\n            return;\\n        }\\n        //step 4\\n        DFS(nums, index + 1, sum + nums[index], target);\\n        DFS(nums, index + 1, sum - nums[index], target);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    //step 1\\n    int cnt = 0;\\n    public int findTargetSumWays(int[] nums, int target) {\\n        //step 2\\n        DFS(nums, 0, 0, target);\\n        //step 5\\n        return cnt;\\n    }\\n\\n    private void DFS(int[] nums, int index, int sum, int target) {\\n        //step 3\\n        if (index == nums.length) {\\n            if (sum == target) cnt++;\\n            return;\\n        }\\n        //step 4\\n        DFS(nums, index + 1, sum + nums[index], target);\\n        DFS(nums, index + 1, sum - nums[index], target);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097334,
                "title": "c-easy-solution-similar-approach-as-count-partition-with-given-difference",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countPartitions(int n, int d, vector<int>& arr) {\\n        // Code here\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n        }\\n        int tar=(sum-d)/2;\\n        if((sum-d)%2!=0 || (sum-d)<0) return 0;\\n        // int mod=1e9+7;\\n        vector<vector<int>>dp(n,vector<int>(tar+1,0));\\n        if(arr[0]==0)\\n            dp[0][0]=2;\\n        else\\n            dp[0][0]=1;\\n        if(arr[0]!=0 && arr[0]<=tar){\\n            dp[0][arr[0]]=1;\\n        }\\n        // for(int i=0;i<n;i++){\\n        //     dp[i][0]=1;\\n        //     if(arr[0]<=sum)\\n        //     dp[0][arr[0]]=1;\\n            for(int i=1;i<n;i++){\\n                for(int k=0;k<=tar;k++){\\n                    int np=dp[i-1][k];\\n            \\t    int p=0;\\n            \\t    if(arr[i]<=k)\\n            \\t     p=dp[i-1][k-arr[i]];\\n            \\t    \\n            \\t    dp[i][k]=(p+np);\\n                }\\n            }\\n        \\n        return dp[n-1][tar];\\n        \\n    }\\n    int findTargetSumWays(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        return countPartitions(n,target,arr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPartitions(int n, int d, vector<int>& arr) {\\n        // Code here\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n        }\\n        int tar=(sum-d)/2;\\n        if((sum-d)%2!=0 || (sum-d)<0) return 0;\\n        // int mod=1e9+7;\\n        vector<vector<int>>dp(n,vector<int>(tar+1,0));\\n        if(arr[0]==0)\\n            dp[0][0]=2;\\n        else\\n            dp[0][0]=1;\\n        if(arr[0]!=0 && arr[0]<=tar){\\n            dp[0][arr[0]]=1;\\n        }\\n        // for(int i=0;i<n;i++){\\n        //     dp[i][0]=1;\\n        //     if(arr[0]<=sum)\\n        //     dp[0][arr[0]]=1;\\n            for(int i=1;i<n;i++){\\n                for(int k=0;k<=tar;k++){\\n                    int np=dp[i-1][k];\\n            \\t    int p=0;\\n            \\t    if(arr[i]<=k)\\n            \\t     p=dp[i-1][k-arr[i]];\\n            \\t    \\n            \\t    dp[i][k]=(p+np);\\n                }\\n            }\\n        \\n        return dp[n-1][tar];\\n        \\n    }\\n    int findTargetSumWays(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        return countPartitions(n,target,arr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044434,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n//         sum(P) - sum(N) = target\\n// sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)\\n//                        2 * sum(P) = target + sum(nums)\\n        int sum=0;\\n        for(int i:nums)\\n        sum+=i;\\n        if((target+sum)&1 || abs(target)>sum)\\n        return 0;\\n        int t=(target+sum)/2;\\n        int n=nums.size();\\n        vector<int> dp(t+1);\\n        dp[0]=1;\\n        for(int i:nums)\\n        {\\n            for(int j=t;j>=i;j--)\\n            {\\n                if(dp[j-i])\\n                dp[j]+=dp[j-i];\\n            }\\n        }\\n        return dp[t];\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n//         sum(P) - sum(N) = target\\n// sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)\\n//                        2 * sum(P) = target + sum(nums)\\n        int sum=0;\\n        for(int i:nums)\\n        sum+=i;\\n        if((target+sum)&1 || abs(target)>sum)\\n        return 0;\\n        int t=(target+sum)/2;\\n        int n=nums.size();\\n        vector<int> dp(t+1);\\n        dp[0]=1;\\n        for(int i:nums)\\n        {\\n            for(int j=t;j>=i;j--)\\n            {\\n                if(dp[j-i])\\n                dp[j]+=dp[j-i];\\n            }\\n        }\\n        return dp[t];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928450,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n//         sum(P) - sum(N) = target\\n// sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)\\n//                        2 * sum(P) = target + sum(nums)\\n        int sum=0;\\n        for(int i:nums)\\n        sum+=i;\\n        if((target+sum)&1 || abs(target)>sum)\\n        return 0;\\n        int t=(target+sum)/2;\\n        int n=nums.size();\\n        vector<int> dp(t+1);\\n        dp[0]=1;\\n        for(int i:nums)\\n        {\\n            for(int j=t;j>=i;j--)\\n            {\\n                if(dp[j-i])\\n                dp[j]+=dp[j-i];\\n            }\\n        }\\n        return dp[t];\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n//         sum(P) - sum(N) = target\\n// sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)\\n//                        2 * sum(P) = target + sum(nums)\\n        int sum=0;\\n        for(int i:nums)\\n        sum+=i;\\n        if((target+sum)&1 || abs(target)>sum)\\n        return 0;\\n        int t=(target+sum)/2;\\n        int n=nums.size();\\n        vector<int> dp(t+1);\\n        dp[0]=1;\\n        for(int i:nums)\\n        {\\n            for(int j=t;j>=i;j--)\\n            {\\n                if(dp[j-i])\\n                dp[j]+=dp[j-i];\\n            }\\n        }\\n        return dp[t];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2582797,
                "title": "target-sum-dp-approach",
                "content": "\\n       int sum = 0;\\n       int n = nums.length;  \\n        for(int i : nums) sum+=i;\\n        if((sum + target)%2 != 0) return 0;\\n        int val = (sum+target)/2;\\n        if(val < 0) return 0;\\n        int[][] dp = new int[n+1][val+1];\\n        \\n        for(int i = 0; i <n+1; i++){\\n            for(int j = 0; j<val+1;j++){\\n                if(i == 0) dp[i][j] = 0;\\n                if(j == 0) dp[i][j] = 1;\\n            }\\n        }\\n        dp[0][0] = 1;\\n        for(int i = 1; i<n+1; i++){\\n            for(int j = 0; j<val+1; j++){\\n                if(nums[i-1] <= j) dp[i][j] = dp[i-1][j-nums[i-1]] + dp[i-1][j];\\n                else dp[i][j] = dp[i-1][j];\\n            }\\n        }\\n        \\n        return dp[n][val];",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "\\n       int sum = 0;\\n       int n = nums.length;  \\n        for(int i : nums) sum+=i;\\n        if((sum + target)%2 != 0) return 0;\\n        int val = (sum+target)/2;\\n        if(val < 0) return 0;\\n        int[][] dp = new int[n+1][val+1];\\n        \\n        for(int i = 0; i <n+1; i++){\\n            for(int j = 0; j<val+1;j++){\\n                if(i == 0) dp[i][j] = 0;\\n                if(j == 0) dp[i][j] = 1;\\n            }\\n        }\\n        dp[0][0] = 1;\\n        for(int i = 1; i<n+1; i++){\\n            for(int j = 0; j<val+1; j++){\\n                if(nums[i-1] <= j) dp[i][j] = dp[i-1][j-nums[i-1]] + dp[i-1][j];\\n                else dp[i][j] = dp[i-1][j];\\n            }\\n        }\\n        \\n        return dp[n][val];",
                "codeTag": "Unknown"
            },
            {
                "id": 2273618,
                "title": "python-backtrack-with-memoization",
                "content": "```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        memo = {}\\n        \\n        def backtrack(i, curr):\\n            if i == len(nums):\\n                return int(curr == target)\\n            \\n            if (i, curr) in memo:\\n                return memo[(i, curr)]\\n            \\n            sub = backtrack(i + 1, curr - nums[i])\\n            add = backtrack(i + 1, curr + nums[i])\\n            memo[(i, curr)] = add + sub\\n            return memo[(i, curr)]\\n            \\n        return backtrack(0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        memo = {}\\n        \\n        def backtrack(i, curr):\\n            if i == len(nums):\\n                return int(curr == target)\\n            \\n            if (i, curr) in memo:\\n                return memo[(i, curr)]\\n            \\n            sub = backtrack(i + 1, curr - nums[i])\\n            add = backtrack(i + 1, curr + nums[i])\\n            memo[(i, curr)] = add + sub\\n            return memo[(i, curr)]\\n            \\n        return backtrack(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213833,
                "title": "target-sum-easy-understanding-0-1-knapsack-c",
                "content": "**Prerequsites : Count the number of pair of subsets whose difference is equal to given target. Which is 0 - 1 Knapsack Problem**\\n\\n\\nclass Solution {\\npublic:\\n\\n    int findTargetSumWays(vector<int>& num, int target) {\\n        vector<int> nums;\\n        for(int i=0;i<num.size();i++)\\n            if(num[i]!=0)\\n                nums.push_back(num[i]);\\n        int n=nums.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n            sum+=nums[i];\\n        int total_sum=sum;\\n        int ans=0;\\n        sum++;\\n        while(sum--)\\n        {\\n            if((total_sum-2*sum)==target)\\n            {\\n                vector<vector<int>> dp(n+1,vector<int>(sum+1,0));\\n                for(int i=0;i<=n;i++)\\n                    dp[i][0]=1;\\n                for(int i=1;i<=n;i++)\\n                    for(int j=1;j<=sum;j++)\\n                    {\\n                        dp[i][j]+=dp[i-1][j];\\n                        if(j>=nums[i-1])\\n                            dp[i][j]+=(dp[i-1][j-nums[i-1]]);\\n                    }\\n                ans+=dp[n][sum];  // This ans is the number of ways without counting the zeroes in the array.              \\n\\t\\t\\t}\\n        }\\n        int p=num.size()-n;          // Finally the ans would be ans*pow(2,number_of_zeroes).\\n        return (ans*pow(2,p));\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int findTargetSumWays(vector<int>& num, int target) {\\n        vector<int> nums;\\n        for(int i=0;i<num.size();i++)\\n            if(num[i]!=0)\\n                nums.push_back(num[i]);\\n        int n=nums.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n            sum+=nums[i];\\n        int total_sum=sum;\\n        int ans=0;\\n        sum++;\\n        while(sum--)\\n        {\\n            if((total_sum-2*sum)==target)\\n            {\\n                vector<vector<int>> dp(n+1,vector<int>(sum+1,0));\\n                for(int i=0;i<=n;i++)\\n                    dp[i][0]=1;\\n                for(int i=1;i<=n;i++)\\n                    for(int j=1;j<=sum;j++)\\n                    {\\n                        dp[i][j]+=dp[i-1][j];\\n                        if(j>=nums[i-1])\\n                            dp[i][j]+=(dp[i-1][j-nums[i-1]]);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2021857,
                "title": "c-easy",
                "content": "**Recursive Solution :**\\n```\\nclass Solution {\\npublic:\\n    int f(int i,int target,vector<int>& nums){\\n        if(i==0) return target==0;\\n        if(i<0) return 0;\\n        int p=f(i-1,target+nums[i-1],nums);\\n        int m=f(i-1,target-nums[i-1],nums);\\n        return p+m; \\n    }\\n    \\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        return f(nums.size(),target,nums);\\n    }\\n};\\n```\\n\\n**Please Upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i,int target,vector<int>& nums){\\n        if(i==0) return target==0;\\n        if(i<0) return 0;\\n        int p=f(i-1,target+nums[i-1],nums);\\n        int m=f(i-1,target-nums[i-1],nums);\\n        return p+m; \\n    }\\n    \\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        return f(nums.size(),target,nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004435,
                "title": "c-simple-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int res=0;\\n    \\n    void solve(int n, vector<int> &nums, int sum, int target, int i){\\n        \\n        if(i==n){\\n            if(target==sum)\\n                res++;\\n            return;\\n        }\\n        \\n        int cur = nums[i];\\n        \\n        solve(n, nums, sum+cur, target, i+1);\\n        solve(n, nums, sum-cur, target, i+1);\\n    }\\n    \\n    \\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        \\n        if(nums.size()==1 and nums[0]==target)\\n            return 1;\\n        \\n        solve(nums.size(), nums, 0, target, 0);\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int res=0;\\n    \\n    void solve(int n, vector<int> &nums, int sum, int target, int i){\\n        \\n        if(i==n){\\n            if(target==sum)\\n                res++;\\n            return;\\n        }\\n        \\n        int cur = nums[i];\\n        \\n        solve(n, nums, sum+cur, target, i+1);\\n        solve(n, nums, sum-cur, target, i+1);\\n    }\\n    \\n    \\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        \\n        if(nums.size()==1 and nums[0]==target)\\n            return 1;\\n        \\n        solve(nums.size(), nums, 0, target, 0);\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986319,
                "title": "c-dfs-with-memoization-code-simple-easy-to-understand",
                "content": "**Please do upvote if you like my efforts :)**\\n\\n```\\nclass Solution {\\npublic:\\n        \\n    int helper(vector<int> &nums, int target, int index, vector<vector<int>> &mem, int currSum, int sum)\\n    {   \\n        if(target == currSum and index == nums.size()) return 1;\\n        if(index == nums.size()) return 0;\\n        \\n        if(mem[currSum+sum][index] == -1)\\n        {\\n            int subt = helper(nums, target, index+1, mem, currSum-nums[index], sum);\\n            int add = helper(nums, target, index+1, mem, currSum+nums[index], sum);\\n            mem[currSum+sum][index] = subt + add;\\n            return mem[currSum+sum][index];\\n        }\\n        else\\n            return mem[currSum+sum][index];\\n            \\n    }\\n    \\n    int findTargetSumWays(vector<int>& nums, int target) \\n    {\\n        int sum = 0;\\n        for(int num: nums) sum += num;\\n        \\n        vector<vector<int>> mem(2*sum+1, vector<int>(nums.size()+1, -1));\\n        return helper(nums, target, 0, mem, 0, sum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        \\n    int helper(vector<int> &nums, int target, int index, vector<vector<int>> &mem, int currSum, int sum)\\n    {   \\n        if(target == currSum and index == nums.size()) return 1;\\n        if(index == nums.size()) return 0;\\n        \\n        if(mem[currSum+sum][index] == -1)\\n        {\\n            int subt = helper(nums, target, index+1, mem, currSum-nums[index], sum);\\n            int add = helper(nums, target, index+1, mem, currSum+nums[index], sum);\\n            mem[currSum+sum][index] = subt + add;\\n            return mem[currSum+sum][index];\\n        }\\n        else\\n            return mem[currSum+sum][index];\\n            \\n    }\\n    \\n    int findTargetSumWays(vector<int>& nums, int target) \\n    {\\n        int sum = 0;\\n        for(int num: nums) sum += num;\\n        \\n        vector<vector<int>> mem(2*sum+1, vector<int>(nums.size()+1, -1));\\n        return helper(nums, target, 0, mem, 0, sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979719,
                "title": "easy-understanding-python-o-n-target",
                "content": "At each position we can either pick element as poitive or negative and by doing so if any path leads to target then that is considered as one of the paths. \\n\\nWe can divide the problem in smaller chunks by calling the recursive function for `i+1` position and setting target as `target + nums[i]` and `target- nums[i]`.\\n\\n```python\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n\\t\\n        @lru_cache(None)\\n        def dfs(i, target):\\n            if i == len(nums):\\n                return 1 if target == 0 else 0\\n            return dfs(i + 1, target + nums[i]) + dfs(i+1, target - nums[i])\\n        \\n        return dfs(0, target)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```python\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n\\t\\n        @lru_cache(None)\\n        def dfs(i, target):\\n            if i == len(nums):\\n                return 1 if target == 0 else 0\\n            return dfs(i + 1, target + nums[i]) + dfs(i+1, target - nums[i])\\n        \\n        return dfs(0, target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975372,
                "title": "target-sum-dynamic-programming-inspired-from-aditya-verma",
                "content": "```\\n int subSetsum(vector<int>& nums, int sum){\\n        int n = nums.size();\\n        int t[n+1][sum+1];\\n        \\n        // initialization\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<sum+1;j++){\\n                if(i==0){\\n                    t[i][j] =0;\\n                }\\n                if(j==0){\\n                    t[i][j] =1;\\n                }\\n            }\\n        }\\n        \\n        //Choice diagram\\n        // i->n , j->sum\\n        \\n        for(int i=1;i<n+1;i++){\\n            // Starting j from 0 because 0\\'s are considered as valid for this problem.\\n            for(int j=0;j<sum+1;j++){\\n                if(nums[i-1]<=j){\\n                    t[i][j] = t[i-1][j] + t[i-1][j-nums[i-1]];\\n                }\\n                else{\\n                    t[i][j] = t[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        return t[n][sum];\\n    }\\n    \\n    int findTargetSumWays(vector<int>& nums, int target) {\\n  /*\\n  1.\\n         s1 + s2 = sum(nums)\\n       + s1 - s2 = target\\n        -----------------------\\n         s1 = (sum + target) /2\\n         \\n   2.    retrun subsetSum(s1)\\n   \\n   */    \\n        int sum =0;\\n        int s1=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        s1= (sum+target)/2;\\n        \\n        if(s1<0 || (sum+target)%2!=0){\\n            return 0;\\n        }\\n        \\n        return subSetsum(nums,s1);\\n    }\\n```\\t",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n int subSetsum(vector<int>& nums, int sum){\\n        int n = nums.size();\\n        int t[n+1][sum+1];\\n        \\n        // initialization\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<sum+1;j++){\\n                if(i==0){\\n                    t[i][j] =0;\\n                }\\n                if(j==0){\\n                    t[i][j] =1;\\n                }\\n            }\\n        }\\n        \\n        //Choice diagram\\n        // i->n , j->sum\\n        \\n        for(int i=1;i<n+1;i++){\\n            // Starting j from 0 because 0\\'s are considered as valid for this problem.\\n            for(int j=0;j<sum+1;j++){\\n                if(nums[i-1]<=j){\\n                    t[i][j] = t[i-1][j] + t[i-1][j-nums[i-1]];\\n                }\\n                else{\\n                    t[i][j] = t[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        return t[n][sum];\\n    }\\n    \\n    int findTargetSumWays(vector<int>& nums, int target) {\\n  /*\\n  1.\\n         s1 + s2 = sum(nums)\\n       + s1 - s2 = target\\n        -----------------------\\n         s1 = (sum + target) /2\\n         \\n   2.    retrun subsetSum(s1)\\n   \\n   */    \\n        int sum =0;\\n        int s1=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        s1= (sum+target)/2;\\n        \\n        if(s1<0 || (sum+target)%2!=0){\\n            return 0;\\n        }\\n        \\n        return subSetsum(nums,s1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1948414,
                "title": "recursion-memoization-tabulation-space-optimization",
                "content": "**Recursion:**\\nTC: O(2^n)\\nSC:O(n)\\n```\\nclass Solution {\\n    public int findTargetSumWays(int[] a, int target) {\\n        \\n        int totalSum = 0;\\n        for(int i: a) totalSum += i;\\n        \\n        if (target + totalSum < 0) return 0;\\n        if((target + totalSum)%2 == 1)  return 0;\\n        int n =a.length;\\n        int sum = (target + totalSum)/2;      \\n        return f(n-1,sum,a,dp);\\n        \\n    }\\n    public int f(int i, int s, int[] a){\\n        \\n        if(i == 0){\\n            if(s == 0 && a[i] == 0) return 2;\\n            if(s == 0 || a[i] == s) return 1;\\n            return 0;\\n        }\\n        int notPick = f(i-1,s,a,dp);\\n        int pick = 0;\\n        if(s>=a[i]){\\n            pick = f(i-1,s-a[i],a,dp);\\n        }\\n        return  pick + notPick;\\n    }\\n}\\n```\\n\\n**Memoization:**\\nTC : O(n x target)\\nSC : O(n) +  O(n x target)\\n\\n```\\nclass Solution {\\n    public int findTargetSumWays(int[] a, int target) {\\n        \\n        int totalSum = 0;\\n        for(int i: a) totalSum += i;\\n        \\n        if (target + totalSum < 0) return 0;\\n        if((target + totalSum)%2 == 1)  return 0;\\n        int n =a.length;\\n        int sum = (target + totalSum)/2;\\n        int[][] dp=new int[n][sum+1];\\n        for(int[] row:dp) Arrays.fill(row,-1);\\n        \\n        return f(n-1,sum,a,dp);\\n        \\n    }\\n    public int f(int i, int s, int[] a, int[][] dp){\\n        \\n        if(i == 0){\\n            if(s == 0 && a[i] == 0) return 2;\\n            if(s == 0 || a[i] == s) return 1;\\n            return 0;\\n        }\\n        if(dp[i][s] != -1) return dp[i][s];\\n        int notPick = f(i-1,s,a,dp);\\n        int pick = 0;\\n        if(s>=a[i]){\\n            pick = f(i-1,s-a[i],a,dp);\\n        }\\n        return dp[i][s] = pick + notPick;\\n    }\\n}\\n```\\n\\n**Tabulation:**\\nTC : O(n x target);\\nSC : O(n x target);\\n\\n```\\nclass Solution {\\n    public int findTargetSumWays(int[] a, int target) {        \\n        int totalSum = 0;\\n        for(int i: a) totalSum += i;\\n        \\n        if (target + totalSum < 0) return 0;\\n        if((target + totalSum)%2 == 1)  return 0;\\n        int n =a.length;\\n        int sum = (target + totalSum)/2;\\n        \\n        int[][] dp=new int[n][sum+1];\\n        \\n        if(a[0] == 0) dp[0][0] = 2;\\n        else dp[0][0] = 1;\\n        if(a[0] !=0 && a[0] <= sum ) dp[0][a[0]] = 1;\\n        \\n        for(int i = 1; i<n; i++){\\n            for(target=0;target<=sum;target++){\\n                int notPick = dp[i-1][target];\\n                int pick = 0;\\n                if(target >= a[i])\\n                    pick = dp[i-1][target-a[i]];\\n                dp[i][target] = pick+notPick;\\n            }\\n        }       \\n        return dp[n-1][sum];  \\n    }\\n}\\n```\\n\\n**Space Optimization :**\\nTC : O(n x target);\\nSC : O(target);\\n\\n```\\nclass Solution {\\n    public int findTargetSumWays(int[] a, int target) {        \\n        int totalSum = 0;\\n        for(int i: a) totalSum += i;\\n        \\n        if (target + totalSum < 0) return 0;\\n        if((target + totalSum)%2 == 1)  return 0;\\n        int n =a.length;\\n        int sum = (target + totalSum)/2;\\n        \\n        int[] dp=new int[sum+1];\\n        \\n        if(a[0] == 0) dp[0] = 2;\\n        else dp[0] = 1;\\n        if(a[0] !=0 && a[0] <= sum ) dp[a[0]] = 1;\\n        \\n        for(int i = 1; i<n; i++){\\n            int[] curr=new int[sum+1];\\n            for(target=0;target<=sum;target++){\\n                int notPick = dp[target];\\n                int pick = 0;\\n                if(target >= a[i])\\n                    pick = dp[target-a[i]];\\n                curr[target] = pick+notPick;\\n            }\\n            dp=curr;\\n        }       \\n        return dp[sum];        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int findTargetSumWays(int[] a, int target) {\\n        \\n        int totalSum = 0;\\n        for(int i: a) totalSum += i;\\n        \\n        if (target + totalSum < 0) return 0;\\n        if((target + totalSum)%2 == 1)  return 0;\\n        int n =a.length;\\n        int sum = (target + totalSum)/2;      \\n        return f(n-1,sum,a,dp);\\n        \\n    }\\n    public int f(int i, int s, int[] a){\\n        \\n        if(i == 0){\\n            if(s == 0 && a[i] == 0) return 2;\\n            if(s == 0 || a[i] == s) return 1;\\n            return 0;\\n        }\\n        int notPick = f(i-1,s,a,dp);\\n        int pick = 0;\\n        if(s>=a[i]){\\n            pick = f(i-1,s-a[i],a,dp);\\n        }\\n        return  pick + notPick;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findTargetSumWays(int[] a, int target) {\\n        \\n        int totalSum = 0;\\n        for(int i: a) totalSum += i;\\n        \\n        if (target + totalSum < 0) return 0;\\n        if((target + totalSum)%2 == 1)  return 0;\\n        int n =a.length;\\n        int sum = (target + totalSum)/2;\\n        int[][] dp=new int[n][sum+1];\\n        for(int[] row:dp) Arrays.fill(row,-1);\\n        \\n        return f(n-1,sum,a,dp);\\n        \\n    }\\n    public int f(int i, int s, int[] a, int[][] dp){\\n        \\n        if(i == 0){\\n            if(s == 0 && a[i] == 0) return 2;\\n            if(s == 0 || a[i] == s) return 1;\\n            return 0;\\n        }\\n        if(dp[i][s] != -1) return dp[i][s];\\n        int notPick = f(i-1,s,a,dp);\\n        int pick = 0;\\n        if(s>=a[i]){\\n            pick = f(i-1,s-a[i],a,dp);\\n        }\\n        return dp[i][s] = pick + notPick;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findTargetSumWays(int[] a, int target) {        \\n        int totalSum = 0;\\n        for(int i: a) totalSum += i;\\n        \\n        if (target + totalSum < 0) return 0;\\n        if((target + totalSum)%2 == 1)  return 0;\\n        int n =a.length;\\n        int sum = (target + totalSum)/2;\\n        \\n        int[][] dp=new int[n][sum+1];\\n        \\n        if(a[0] == 0) dp[0][0] = 2;\\n        else dp[0][0] = 1;\\n        if(a[0] !=0 && a[0] <= sum ) dp[0][a[0]] = 1;\\n        \\n        for(int i = 1; i<n; i++){\\n            for(target=0;target<=sum;target++){\\n                int notPick = dp[i-1][target];\\n                int pick = 0;\\n                if(target >= a[i])\\n                    pick = dp[i-1][target-a[i]];\\n                dp[i][target] = pick+notPick;\\n            }\\n        }       \\n        return dp[n-1][sum];  \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findTargetSumWays(int[] a, int target) {        \\n        int totalSum = 0;\\n        for(int i: a) totalSum += i;\\n        \\n        if (target + totalSum < 0) return 0;\\n        if((target + totalSum)%2 == 1)  return 0;\\n        int n =a.length;\\n        int sum = (target + totalSum)/2;\\n        \\n        int[] dp=new int[sum+1];\\n        \\n        if(a[0] == 0) dp[0] = 2;\\n        else dp[0] = 1;\\n        if(a[0] !=0 && a[0] <= sum ) dp[a[0]] = 1;\\n        \\n        for(int i = 1; i<n; i++){\\n            int[] curr=new int[sum+1];\\n            for(target=0;target<=sum;target++){\\n                int notPick = dp[target];\\n                int pick = 0;\\n                if(target >= a[i])\\n                    pick = dp[target-a[i]];\\n                curr[target] = pick+notPick;\\n            }\\n            dp=curr;\\n        }       \\n        return dp[sum];        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1819675,
                "title": "c-intuition-easy-understanding",
                "content": "**EXPLANATION**\\n\\nlet S1 and S2 be 2 subarrays\\n\\nwe can say that S1+S2 = Sum of all array elements(SUM) -------i\\n\\nwe can also say that S1-S2  = K----------ii\\n\\nwhere,\\nS1 contains all the elements with **+** sign and,\\nS2 contains all the elements with **-** sign\\n\\nadding both equation 1 and 2 we get\\n\\nS1+S2 = SUM\\nS1-S2  = K\\n---------\\n2*S1 = K+SUM\\n**S1=(K+SUM)/2**\\n\\nnow we can proceed like the problem **COUNT OF SUBSET SUM EQUALS K**\\n\\n\\n```\\nint recursive(int index,int k,vector<int>&nums)\\n    {\\n        if(index==0)\\n        {\\n            if(k==0 && nums[0]==0) return 2;\\n            if(k==nums[0] || k==0) return 1;\\n            return 0;\\n        }\\n        int pick =0;\\n        if(k-nums[index]>=0)\\n            pick = recursive(index-1,k-nums[index],nums);\\n        int notPick = recursive(index-1,k,nums);\\n        \\n        return pick + notPick;\\n    }\\n\\t\\n\\tint findTargetSumWays(vector<int>& nums, int target) {\\n        \\n        int n = nums.size();\\n        \\n        int sum=0;\\n        for(auto i:nums) sum+=i; \\n        int k = (sum+target)/2;\\n        \\n        if(sum<target || (sum+target)&1 || k<0) return 0;\\n\\t\\t\\n\\t\\t  return recursive(n-1,k,nums);\\n               \\n    }\\n```\\n\\nnow we can optimize this code using DP ,which you guys can do yourself!!!",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint recursive(int index,int k,vector<int>&nums)\\n    {\\n        if(index==0)\\n        {\\n            if(k==0 && nums[0]==0) return 2;\\n            if(k==nums[0] || k==0) return 1;\\n            return 0;\\n        }\\n        int pick =0;\\n        if(k-nums[index]>=0)\\n            pick = recursive(index-1,k-nums[index],nums);\\n        int notPick = recursive(index-1,k,nums);\\n        \\n        return pick + notPick;\\n    }\\n\\t\\n\\tint findTargetSumWays(vector<int>& nums, int target) {\\n        \\n        int n = nums.size();\\n        \\n        int sum=0;\\n        for(auto i:nums) sum+=i; \\n        int k = (sum+target)/2;\\n        \\n        if(sum<target || (sum+target)&1 || k<0) return 0;\\n\\t\\t\\n\\t\\t  return recursive(n-1,k,nums);\\n               \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1791353,
                "title": "simple-recursion-java",
                "content": "class Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n        return helper( nums, target, 0, 0 );\\n    }\\n    int helper( int[] arr, int target, int index, int sum ) {\\n        if ( index == arr.length ) {\\n            if ( sum == target )\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        int add = helper( arr, target, index+1, sum+arr[index] );\\n        int sub = helper( arr, target, index+1, sum-arr[index] );\\n        return add+sub;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n        return helper( nums, target, 0, 0 );\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1744600,
                "title": "c-dp-bottom-up-easy-to-understand",
                "content": "**knockcat**\\n```\\n\\u2705 Link To  My Github Profile Contains All My LeetCode Solution on A Repository Named LeetCode...\\n```\\n[LeetCode](https://github.com/knockcat)\\n\\t\\n```\\n\\u2705 Target Sum\\n\\u2705 Please Try a similar probelem like this (416.\\u2705 Partition Equal Subset Sum) for Practice\\n```\\n[Partition Equal Subset Sum](leetcode.com/problems/partition-equal-subset-sum/)\\n```\\n\\u2705 Dynamic Programming\\n\\u2705 Please Upvote if it Helps\\n```\\n```\\nclass Solution {\\n    int CountsubsetSum(vector<int>& nums, int sum)\\n    {\\n        int n = nums.size();\\n        \\n        int t[n+1][sum+1];\\n        \\n        for(int i = 0; i<n + 1; ++i)\\n        {\\n            for(int j = 0; j<sum + 1; ++j)\\n            {\\n                if(i == 0)\\n                    t[i][j] = 0;\\n                if(j == 0)\\n                    t[i][j] = 1;\\n            }\\n        }\\n        \\n        for(int i = 1; i<n + 1; ++i)\\n        {\\n            for(int j = 0 ;  j<sum + 1; ++j)\\n            {\\n                if(nums[i-1] <= j)\\n                    t[i][j] = t[i-1][j] + t[i-1][j-nums[i-1]];\\n                else\\n                    t[i][j] = t[i-1][j];\\n            }\\n        }\\n        return t[n][sum];\\n    }\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        for(int i = 0; i<nums.size(); ++i)\\n            sum += nums[i];\\n     \\n        if (abs(target) > sum || (sum + target) % 2 != 0){ \\n            return 0;\\n        }\\n        \\n        target = abs (target);\\n        \\n        sum = (sum + target)/2;\\n        \\n        int cnt = CountsubsetSum(nums,sum);\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\u2705 Link To  My Github Profile Contains All My LeetCode Solution on A Repository Named LeetCode...\\n```\n```\\n\\u2705 Target Sum\\n\\u2705 Please Try a similar probelem like this (416.\\u2705 Partition Equal Subset Sum) for Practice\\n```\n```\\n\\u2705 Dynamic Programming\\n\\u2705 Please Upvote if it Helps\\n```\n```\\nclass Solution {\\n    int CountsubsetSum(vector<int>& nums, int sum)\\n    {\\n        int n = nums.size();\\n        \\n        int t[n+1][sum+1];\\n        \\n        for(int i = 0; i<n + 1; ++i)\\n        {\\n            for(int j = 0; j<sum + 1; ++j)\\n            {\\n                if(i == 0)\\n                    t[i][j] = 0;\\n                if(j == 0)\\n                    t[i][j] = 1;\\n            }\\n        }\\n        \\n        for(int i = 1; i<n + 1; ++i)\\n        {\\n            for(int j = 0 ;  j<sum + 1; ++j)\\n            {\\n                if(nums[i-1] <= j)\\n                    t[i][j] = t[i-1][j] + t[i-1][j-nums[i-1]];\\n                else\\n                    t[i][j] = t[i-1][j];\\n            }\\n        }\\n        return t[n][sum];\\n    }\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        for(int i = 0; i<nums.size(); ++i)\\n            sum += nums[i];\\n     \\n        if (abs(target) > sum || (sum + target) % 2 != 0){ \\n            return 0;\\n        }\\n        \\n        target = abs (target);\\n        \\n        sum = (sum + target)/2;\\n        \\n        int cnt = CountsubsetSum(nums,sum);\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629253,
                "title": "java-0-1-knapsack-with-explanation",
                "content": "```\\n/**\\nseperate nums into two sets:\\nsum of plus number: p\\nsum of minus number: n\\nsum of nums: sum\\nwe want: p + n == target\\nwe know: p - n == sum\\n=>p == (target + sum) / 2\\nproblem converted to finding how many combinations of num from nums, whose sum == (target + sum) / 2\\nTherefore, this is a 0/1 knapsack combination problem\\n*/\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n        int sum = 0;\\n        for (int num: nums) {\\n            sum += num;\\n        }\\n        if (Math.abs(target) > sum) {\\n            return 0;\\n        }\\n        if ((target + sum) % 2 != 0) {\\n            return 0;\\n        }\\n        int bag = (target + sum) / 2;\\n        int[] dp = new int[bag + 1]; // how many different combinations of num sum up to bag\\n        dp[0] = 1;\\n        for (int num: nums) {\\n            for (int i = bag; i >= num; i--) {\\n                dp[i] += dp[i - num]; // dp[i] = dp[i] (not take num) + dp[i - num] (take num)\\n            }\\n        }\\n        return dp[bag];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\nseperate nums into two sets:\\nsum of plus number: p\\nsum of minus number: n\\nsum of nums: sum\\nwe want: p + n == target\\nwe know: p - n == sum\\n=>p == (target + sum) / 2\\nproblem converted to finding how many combinations of num from nums, whose sum == (target + sum) / 2\\nTherefore, this is a 0/1 knapsack combination problem\\n*/\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n        int sum = 0;\\n        for (int num: nums) {\\n            sum += num;\\n        }\\n        if (Math.abs(target) > sum) {\\n            return 0;\\n        }\\n        if ((target + sum) % 2 != 0) {\\n            return 0;\\n        }\\n        int bag = (target + sum) / 2;\\n        int[] dp = new int[bag + 1]; // how many different combinations of num sum up to bag\\n        dp[0] = 1;\\n        for (int num: nums) {\\n            for (int i = bag; i >= num; i--) {\\n                dp[i] += dp[i - num]; // dp[i] = dp[i] (not take num) + dp[i - num] (take num)\\n            }\\n        }\\n        return dp[bag];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584015,
                "title": "aditya-verma-solution-java-faster-than-94-java-submissions",
                "content": "```\\nclass Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n       \\n        int arr_sum = 0;\\n        int arr_diff = target;\\n        \\n        for(int x: nums){\\n            arr_sum += x;\\n        }\\n        \\n         if(((arr_sum - target) % 2 == 1) || (target > arr_sum) || (target < -arr_sum)){\\n            return 0;\\n         }\\n        \\n        int s1 = (arr_diff + arr_sum)/2;\\n        return countSubsetSum(nums, s1);\\n        \\n    }\\n    \\n    public int countSubsetSum(int[] arr, int sum){\\n        int n = arr.length;\\n        int[][] dp = new int[n+1][sum+1];\\n        dp[0][0] = 1;\\n        \\n\\t    // for(int i=0; i<n+1; i++){\\n\\t    //     for(int j=0; j<sum+1; j++){\\n\\t    //         if(i==0){\\n\\t    //             dp[i][j] = 0;\\n\\t    //         }\\n\\t    //         if(j==0){\\n\\t    //             dp[i][j] = 1;\\n\\t    //         }\\n\\t    //     }\\n\\t    // }\\n        \\n        for(int i=1; i<n+1; i++){\\n            for(int j=0; j<sum+1; j++){\\n                if(arr[i-1]<=j){\\n                    dp[i][j] = dp[i-1][j-arr[i-1]] + dp[i-1][j];\\n                }else{\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n                \\n            }\\n            \\n        }\\n        return dp[n][sum];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findTargetSumWays(int[] nums, int target) {\\n       \\n        int arr_sum = 0;\\n        int arr_diff = target;\\n        \\n        for(int x: nums){\\n            arr_sum += x;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1523229,
                "title": "python-backtracking-with-memorization",
                "content": "```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        count, N = 0, len(nums)\\n        memo = {}\\n    \\n        def dfs(i, currentSum):\\n            if (i, currentSum) in memo: return memo[(i, currentSum)]\\n            if i == N:\\n                if currentSum == target: return 1\\n                return 0\\n            result = dfs(i + 1, currentSum + nums[i]) + dfs( i + 1, currentSum - nums[i])\\n            memo[(i , currentSum)] = result\\n            return result\\n        return  dfs(0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        count, N = 0, len(nums)\\n        memo = {}\\n    \\n        def dfs(i, currentSum):\\n            if (i, currentSum) in memo: return memo[(i, currentSum)]\\n            if i == N:\\n                if currentSum == target: return 1\\n                return 0\\n            result = dfs(i + 1, currentSum + nums[i]) + dfs( i + 1, currentSum - nums[i])\\n            memo[(i , currentSum)] = result\\n            return result\\n        return  dfs(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1484430,
                "title": "variation-of-0-1-knapsack-c-bottom-up-dp",
                "content": "```cpp\\nint countSubsetSum(vector<int>&arr, int sum,int n)\\n    {\\n        int t[n + 1][sum + 1];\\n\\n        //Initialization : \\n        for(int i = 0; i <= n; i++)\\n        {\\n            for(int j = 0; j <= sum; j++)\\n            {\\n                if(i == 0)\\n                    t[i][j] = 0;\\n                if(j == 0)\\n                    t[i][j] = 1;\\n            }\\n        }        \\n\\t\\t\\n        for (int i = 1; i <= n; i++)\\n        {\\n            for (int j = 0; j <= sum; j++)\\n            {\\n                if (arr[i - 1] <= j)\\n                {\\n                    t[i][j] = t[i - 1][j - arr[i - 1]] + t[i - 1][j];\\n                }\\n                else\\n                    t[i][j] = t[i - 1][j];\\n            }\\n        }\\n\\n        return t[n][sum];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int arr_sum=accumulate(nums.begin(),nums.end(),0);    \\n        int sum=(target+arr_sum)/2;\\n        //hidden case :\\n        if (abs(target) > arr_sum || (arr_sum + target) % 2 != 0){ \\n            return 0;\\n        }\\n        return countSubsetSum(nums,sum,nums.size());\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nint countSubsetSum(vector<int>&arr, int sum,int n)\\n    {\\n        int t[n + 1][sum + 1];\\n\\n        //Initialization : \\n        for(int i = 0; i <= n; i++)\\n        {\\n            for(int j = 0; j <= sum; j++)\\n            {\\n                if(i == 0)\\n                    t[i][j] = 0;\\n                if(j == 0)\\n                    t[i][j] = 1;\\n            }\\n        }        \\n\\t\\t\\n        for (int i = 1; i <= n; i++)\\n        {\\n            for (int j = 0; j <= sum; j++)\\n            {\\n                if (arr[i - 1] <= j)\\n                {\\n                    t[i][j] = t[i - 1][j - arr[i - 1]] + t[i - 1][j];\\n                }\\n                else\\n                    t[i][j] = t[i - 1][j];\\n            }\\n        }\\n\\n        return t[n][sum];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int arr_sum=accumulate(nums.begin(),nums.end(),0);    \\n        int sum=(target+arr_sum)/2;\\n        //hidden case :\\n        if (abs(target) > arr_sum || (arr_sum + target) % 2 != 0){ \\n            return 0;\\n        }\\n        return countSubsetSum(nums,sum,nums.size());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1434276,
                "title": "target-sum-dp-recursion-memoization-easy-c",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    int dp[1001][1001];\\n    int solve(vector<int>nums,int target,int sum,int n)\\n    {\\n        \\n        if(n==0)\\n        {\\n            if(sum==target || sum==-target)\\n            {\\n                dp[n][abs(sum)]=1;\\n                return dp[n][abs(sum)];\\n            }\\n            else\\n            {\\n                dp[n][abs(sum)]=0;\\n                return dp[n][abs(sum)];\\n            }\\n        }\\n        if(dp[n][abs(sum)]!=-1)\\n        return dp[n][abs(sum)];\\n        \\n        dp[n][abs(sum)]=solve(nums,target,sum+nums[n-1],n-1)+solve(nums,target,sum-nums[n-1],n-1);\\n        \\n        return dp[n][abs(sum)];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=solve(nums,target,0,nums.size());\\n        return target==0 ? ans : ans/2;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int dp[1001][1001];\\n    int solve(vector<int>nums,int target,int sum,int n)\\n    {\\n        \\n        if(n==0)\\n        {\\n            if(sum==target || sum==-target)\\n            {\\n                dp[n][abs(sum)]=1;\\n                return dp[n][abs(sum)];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1427997,
                "title": "c-85-faster-dp-top-down-approach",
                "content": "**Please UpVote if U like solution\\n**\\nclass Solution {\\npublic:\\n    \\n    \\n    int subsetSum(vector<int> arr,int sum,int n){\\n        \\n        int t[n+1][sum+1];\\n        \\n        for(int i = 0 ;i<=n;i++){\\n            t[i][0] = 1;\\n        }\\n        for(int j =1 ;j<=sum;j++){\\n            t[0][j] = 0;\\n        }\\n        \\n        for(int i = 1;i<=n;i++){\\n            for(int j = 0;j<=sum;j++){\\n                \\n                if(arr[i-1]>j){\\n                    t[i][j] = t[i-1][j];\\n                }else{\\n                    \\n                    t[i][j] = t[i-1][j] + t[i-1][j-arr[i-1]];\\n                    \\n                }\\n            }\\n        }\\n        return t[n][sum];\\n        \\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        \\n        if(nums.size()==1){\\n            if(nums[0]<target)\\n            return 0;\\n        }\\n        \\n        int sum = 0 ;\\n        for(int i = 0 ;i<nums.size();i++){\\n            \\n            sum+=nums[i];\\n            \\n        }\\n        \\n        int s1 = (target+sum)/2;\\n        \\n        if((target+sum)%2 !=0 ) return 0;\\n        \\n        return subsetSum(nums,abs(s1),nums.size());\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    int subsetSum(vector<int> arr,int sum,int n){\\n        \\n        int t[n+1][sum+1];\\n        \\n        for(int i = 0 ;i<=n;i++){\\n            t[i][0] = 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1383512,
                "title": "using-dynamic-programming",
                "content": "```\\nint findTargetSumWays(vector<int>& nums, int target) {\\n         int sum=accumulate(nums.begin(),nums.end(),0);\\n        if(sum<target || (sum+target)%2==1)\\n                return 0;\\n        if(sum==0 && target==0)\\n            return pow(2,nums.size());\\n        int count0=0;\\n        for(int i=0;i<nums.size();i++)\\n            if(nums[i]==0)\\n                count0++;\\n        int m=(sum+target)/2;\\n        int n=nums.size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        for(int i=0;i<n+1;i++)\\n            dp[i][0]=1;\\n        for(int i=1;i<n+1;i++)\\n        {\\n            for(int j=1;j<m+1;j++)\\n            {\\n                if(nums[i-1]<=j && nums[i-1]!=0)\\n                    dp[i][j]=dp[i-1][j] + dp[i-1][j-nums[i-1]];\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        return dp[n][m]*pow(2,count0);\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint findTargetSumWays(vector<int>& nums, int target) {\\n         int sum=accumulate(nums.begin(),nums.end(),0);\\n        if(sum<target || (sum+target)%2==1)\\n                return 0;\\n        if(sum==0 && target==0)\\n            return pow(2,nums.size());\\n        int count0=0;\\n        for(int i=0;i<nums.size();i++)\\n            if(nums[i]==0)\\n                count0++;\\n        int m=(sum+target)/2;\\n        int n=nums.size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        for(int i=0;i<n+1;i++)\\n            dp[i][0]=1;\\n        for(int i=1;i<n+1;i++)\\n        {\\n            for(int j=1;j<m+1;j++)\\n            {\\n                if(nums[i-1]<=j && nums[i-1]!=0)\\n                    dp[i][j]=dp[i-1][j] + dp[i-1][j-nums[i-1]];\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        return dp[n][m]*pow(2,count0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1382120,
                "title": "dp-c-top-down-approach",
                "content": "Hint: Go, for standard solution, just consider the cases for number of zeroes. \\n\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int s = 0;\\n        int num_zero = 0;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            s = s + nums[i];\\n            if(nums[i] == 0){\\n                num_zero++;\\n            }\\n        }\\n         \\n        if(s < target || (s + target)%2 == 1){\\n            return 0;\\n        }\\n        \\n        int diff = (target + s)/2;\\n        int ans = count_of_subset_sum(nums, diff);\\n        \\n        return pow(2, num_zero) * ans;\\n    }\\n    \\n    int count_of_subset_sum(vector<int>& nums, int sum){\\n        int n = nums.size();\\n        int t[n+1][sum+1];\\n        \\n        for(int i = 0; i<n+1; i++){\\n            for(int j = 0; j<sum+1; j++){\\n                if(i==0){\\n                    t[i][j] = 0;\\n                }\\n                if(j==0){\\n                    t[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 1; i<n+1; i++){\\n            for(int j = 1; j<sum+1; j++){\\n                if(nums[i-1] == 0){\\n                    t[i][j] = t[i-1][j];\\n                }\\n                else if(nums[i-1] <= j){\\n                    t[i][j] = t[i-1][j] + t[i-1][j-nums[i-1]];\\n                }\\n                else{\\n                    t[i][j] = t[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        return t[n][sum];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int s = 0;\\n        int num_zero = 0;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            s = s + nums[i];\\n            if(nums[i] == 0){\\n                num_zero++;\\n            }\\n        }\\n         \\n        if(s < target || (s + target)%2 == 1){\\n            return 0;\\n        }\\n        \\n        int diff = (target + s)/2;\\n        int ans = count_of_subset_sum(nums, diff);\\n        \\n        return pow(2, num_zero) * ans;\\n    }\\n    \\n    int count_of_subset_sum(vector<int>& nums, int sum){\\n        int n = nums.size();\\n        int t[n+1][sum+1];\\n        \\n        for(int i = 0; i<n+1; i++){\\n            for(int j = 0; j<sum+1; j++){\\n                if(i==0){\\n                    t[i][j] = 0;\\n                }\\n                if(j==0){\\n                    t[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 1; i<n+1; i++){\\n            for(int j = 1; j<sum+1; j++){\\n                if(nums[i-1] == 0){\\n                    t[i][j] = t[i-1][j];\\n                }\\n                else if(nums[i-1] <= j){\\n                    t[i][j] = t[i-1][j] + t[i-1][j-nums[i-1]];\\n                }\\n                else{\\n                    t[i][j] = t[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        return t[n][sum];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355599,
                "title": "c-dp-bottom-up-4ms",
                "content": "```\\nint subset_sum(vector<int> nums, int s1){\\n        int dp[nums.size()+1][s1+1];\\n        for(int i = 0; i < s1+1; ++i){\\n            dp[0][i] = 0;\\n        }\\n        for(int i = 0; i < nums.size()+1; ++i){\\n            dp[i][0] = 1;\\n        }\\n        for(int i = 1; i < nums.size()+1; ++i){\\n            for(int j = 1; j < s1+1; ++j){\\n                if(nums[i-1] == 0)\\n                    dp[i][j] = dp[i-1][j];\\n                else if(nums[i-1] <= j){\\n                    dp[i][j] = dp[i-1][j-nums[i-1]] + dp[i-1][j];\\n                }\\n                else\\n                    dp[i][j] = dp[i-1][j];\\n            }\\n        }\\n        return dp[nums.size()][s1];\\n    } \\n    \\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        int count_zero = 0;\\n        for(int i = 0; i < nums.size(); ++i){\\n            sum += nums[i];\\n            if(nums[i] == 0)\\n                ++count_zero;\\n        }\\n        int s1 = (sum + target)/2;\\n        if((sum + target)%2 != 0)\\n            return 0;\\n        else\\n            return pow(2, count_zero)*subset_sum(nums, s1);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint subset_sum(vector<int> nums, int s1){\\n        int dp[nums.size()+1][s1+1];\\n        for(int i = 0; i < s1+1; ++i){\\n            dp[0][i] = 0;\\n        }\\n        for(int i = 0; i < nums.size()+1; ++i){\\n            dp[i][0] = 1;\\n        }\\n        for(int i = 1; i < nums.size()+1; ++i){\\n            for(int j = 1; j < s1+1; ++j){\\n                if(nums[i-1] == 0)\\n                    dp[i][j] = dp[i-1][j];\\n                else if(nums[i-1] <= j){\\n                    dp[i][j] = dp[i-1][j-nums[i-1]] + dp[i-1][j];\\n                }\\n                else\\n                    dp[i][j] = dp[i-1][j];\\n            }\\n        }\\n        return dp[nums.size()][s1];\\n    } \\n    \\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        int count_zero = 0;\\n        for(int i = 0; i < nums.size(); ++i){\\n            sum += nums[i];\\n            if(nums[i] == 0)\\n                ++count_zero;\\n        }\\n        int s1 = (sum + target)/2;\\n        if((sum + target)%2 != 0)\\n            return 0;\\n        else\\n            return pow(2, count_zero)*subset_sum(nums, s1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1339484,
                "title": "dp-0-1-knapsack-similar-as-count-subset-with-given-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSubsetSum(vector<int>& nums, int sum, int n)\\n    {\\n        int t[n + 1][sum + 1];\\n        for(int i = 0; i < n + 1; i++)\\n        {\\n            for(int j = 0; j < sum + 1; j++)\\n            {\\n                if(j == 0)\\n                    t[i][j] = 1;\\n                else\\n                    t[i][j] = 0;\\n            }\\n        }\\n        for(int i = 1; i < n + 1; i++)\\n        {\\n            for(int j = 0; j < sum + 1; j++)\\n            {\\n                if(nums[i - 1] <= j)\\n                    t[i][j] = t[i - 1][j] + t[i - 1][j - nums[i - 1]];\\n                else\\n                    t[i][j] = t[i - 1][j];\\n            }\\n        }\\n        return t[n][sum];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int sum = 0;\\n        for(int i = 0; i < n; i++)\\n            sum = sum + nums[i];\\n        int s = target + sum;\\n        if(s % 2 != 0)\\n            return 0;\\n        s = s / 2;\\n        return countSubsetSum(nums, s, n);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int countSubsetSum(vector<int>& nums, int sum, int n)\\n    {\\n        int t[n + 1][sum + 1];\\n        for(int i = 0; i < n + 1; i++)\\n        {\\n            for(int j = 0; j < sum + 1; j++)\\n            {\\n                if(j == 0)\\n                    t[i][j] = 1;\\n                else\\n                    t[i][j] = 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1335980,
                "title": "javascript-easy-to-understand-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar findTargetSumWays = function(nums, target) {\\n    const numsLength = nums.length;\\n    let result = 0;\\n    \\n    const travel = (sum, depth) => {\\n        if (depth === numsLength) {        \\n            if (sum === target) {\\n                result += 1;\\n            }\\n            return;\\n        }\\n        \\n        travel(sum + nums[depth], depth + 1);\\n        travel(sum - nums[depth], depth + 1);\\n    }\\n    \\n    travel(0, 0);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar findTargetSumWays = function(nums, target) {\\n    const numsLength = nums.length;\\n    let result = 0;\\n    \\n    const travel = (sum, depth) => {\\n        if (depth === numsLength) {        \\n            if (sum === target) {\\n                result += 1;\\n            }\\n            return;\\n        }\\n        \\n        travel(sum + nums[depth], depth + 1);\\n        travel(sum - nums[depth], depth + 1);\\n    }\\n    \\n    travel(0, 0);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570050,
                "content": [
                    {
                        "username": "lingarajbal",
                        "content": "/**\\n *  Lets first see the concept here.\\n *  The question asked to assign symbols to each interger.In other words we have to \\n *  divide the whole array into two sub sets having sum S1 and S2. S1-S2=S. Lets draw some\\n *  relation here.\\n *  S1 + S2 = TotalSum(sum of all array elements) [ Equation 1]\\n *  S1 - S2 = S (asked in the question)           [Equation  2]\\n *  if we add Equation 1 and 2 we will have. S1 = (TotalSum + S)/2\\n *  Now the number of sub set of having sum S1 should be the answer to the question.\\n * \\n **/"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "anyone has coded this up? please share! Thanks"
                    },
                    {
                        "username": "aman3091",
                        "content": "i have used same approach still getting error kindly help \\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int s1=(target+sum)/2;\\n        int n=nums.size();\\n        if(n==1){\\n            if(target!=nums[0]&&target!=-1*nums[0]){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n      int t[n+1][s1+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<s1+1;j++){\\n                if(i==0){\\n                    t[i][j]=0;\\n                }\\n                if(j==0){\\n                    t[i][j]=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s1+1;j++){\\n                if(nums[i-1]<=j){\\n                    t[i][j]=t[i-1][j-nums[i-1]] + t[i-1][j];\\n                }\\n                else{\\n                    t[i][j]=t[i-1][j];\\n                }\\n            }\\n        }\\n        return t[n][s1];\\n    }\\n};"
                    },
                    {
                        "username": "kaiyikang",
                        "content": "The idea comes from [this post](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/discuss/97334/Java-(15-ms)-C++-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanation) and this graph shows my personal understanding of the DP solution.\\n![image](https://assets.leetcode.com/users/kaiyikang/image_1569211092.png)\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "from where did you get this dp pic can you please share that book or post"
                    },
                    {
                        "username": "ruokay",
                        "content": "even recursion got accepted :)"
                    },
                    {
                        "username": "ElayMarco",
                        "content": "No explanation as to why something works, or even what you are doing. It's not helpful to most people."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "For those friends who are worrying about negative target, here\\'s a Hint: That the number of ways to get -x is same as number of ways to get +x (just switch every sign in array). I cant believe even the editorial solution doesn\\'t get this right and solves unnecessarily for `[-x , x]` whereas `[0, x]` is sufficient!!"
                    },
                    {
                        "username": "r0hitm",
                        "content": "I think question should have been mentioned that we have to use all the elements of array. if i am wrong please correct me."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Is it only me who did get the recurrence relation but unable to implement DP? "
                    },
                    {
                        "username": "yogeshpractice",
                        "content": "I\\'m not able to convert my meoization to tabulation, can someone help me\\n```class Solution {\\npublic:\\n    int sumT;\\n    int solve(int idx, int sum, int target, vector<int> &arr, int n, map<pair<int,int>, int> &dp)\\n    {\\n        if(idx==n){\\n            if(sum == target) return 1;\\n            return 0;\\n        }\\n\\n        if(dp.count({idx, sum}) > 0)\\n        return dp[{idx, sum}];\\n\\n        int pos = solve(idx+1, sum+arr[idx], target, arr,n,dp);\\n        int neg = solve(idx+1, sum-arr[idx], target, arr,n, dp);\\n        dp[{idx, sum}] = (pos + neg); \\n        return dp[{idx, sum}];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(),sum=0;\\n        sumT=accumulate(nums.begin(), nums.end(), 0);\\n        map<pair<int, int>, int> dp;\\n        return solve(0,sum,target,nums,n, dp);\\n    }\\n};```"
                    },
                    {
                        "username": "Seemon2000",
                        "content": "check if the value is greater than -1 a 0 can be valid case for that option\\nif(dp.count({idx, sum}) > 0)"
                    },
                    {
                        "username": "SG-C",
                        "content": "They should write it Clearly that \" You have to use all element in nums array\" "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n\\n    int s1(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans -nums[i];\\n        return ans;\\n    }\\n    int s2(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans + nums[i];\\n        return ans;\\n    }\\n\\n    public:\\n\\nint findTargetSumWays(vector<int>&nums,int S){ \\n\\n    int minsum = s1(nums);\\n    int maxsum= s2(nums);\\n\\n    if(S>maxsum || S<minsum) return 0;\\n\\n    int r = nums.size();\\n    int c = maxsum - minsum+1;\\n\\n    int** dp = new int*[r];\\n\\n    for(int i=0;i<r;i++){\\n        dp[i] = new int[c];\\n    }\\n\\n    for(int i=0;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            dp[i][j]=0;\\n        }\\n    }\\n    //initlize first row\\n\\n    for(int i=0;i<c;i++){\\n        \\n        bool op1 = (i+minsum) == nums[0];\\n        bool op2 = (i+minsum) == (-1)*nums[0];\\n\\n        if(op1) dp[0][i]+=1;\\n        if(op2) dp[0][i]+=1;\\n    }\\n\\n    //build rest of matrix\\n\\n    for(int i=1;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            int a1 = (j-nums[i]>=0)?dp[i-1][j-nums[i]]:0;\\n            int a2 = (j+nums[i]< c)?dp[i-1][j+nums[i]]:0;\\n\\n            dp[i][j] = a1+a2;\\n        }\\n    }\\n\\n    return dp[r-1][S-minsum];\\n}\\n};"
                    },
                    {
                        "username": "VivekAbstract",
                        "content": "Dont post solution in discussion bro"
                    }
                ]
            },
            {
                "id": 1565294,
                "content": [
                    {
                        "username": "lingarajbal",
                        "content": "/**\\n *  Lets first see the concept here.\\n *  The question asked to assign symbols to each interger.In other words we have to \\n *  divide the whole array into two sub sets having sum S1 and S2. S1-S2=S. Lets draw some\\n *  relation here.\\n *  S1 + S2 = TotalSum(sum of all array elements) [ Equation 1]\\n *  S1 - S2 = S (asked in the question)           [Equation  2]\\n *  if we add Equation 1 and 2 we will have. S1 = (TotalSum + S)/2\\n *  Now the number of sub set of having sum S1 should be the answer to the question.\\n * \\n **/"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "anyone has coded this up? please share! Thanks"
                    },
                    {
                        "username": "aman3091",
                        "content": "i have used same approach still getting error kindly help \\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int s1=(target+sum)/2;\\n        int n=nums.size();\\n        if(n==1){\\n            if(target!=nums[0]&&target!=-1*nums[0]){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n      int t[n+1][s1+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<s1+1;j++){\\n                if(i==0){\\n                    t[i][j]=0;\\n                }\\n                if(j==0){\\n                    t[i][j]=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s1+1;j++){\\n                if(nums[i-1]<=j){\\n                    t[i][j]=t[i-1][j-nums[i-1]] + t[i-1][j];\\n                }\\n                else{\\n                    t[i][j]=t[i-1][j];\\n                }\\n            }\\n        }\\n        return t[n][s1];\\n    }\\n};"
                    },
                    {
                        "username": "kaiyikang",
                        "content": "The idea comes from [this post](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/discuss/97334/Java-(15-ms)-C++-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanation) and this graph shows my personal understanding of the DP solution.\\n![image](https://assets.leetcode.com/users/kaiyikang/image_1569211092.png)\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "from where did you get this dp pic can you please share that book or post"
                    },
                    {
                        "username": "ruokay",
                        "content": "even recursion got accepted :)"
                    },
                    {
                        "username": "ElayMarco",
                        "content": "No explanation as to why something works, or even what you are doing. It's not helpful to most people."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "For those friends who are worrying about negative target, here\\'s a Hint: That the number of ways to get -x is same as number of ways to get +x (just switch every sign in array). I cant believe even the editorial solution doesn\\'t get this right and solves unnecessarily for `[-x , x]` whereas `[0, x]` is sufficient!!"
                    },
                    {
                        "username": "r0hitm",
                        "content": "I think question should have been mentioned that we have to use all the elements of array. if i am wrong please correct me."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Is it only me who did get the recurrence relation but unable to implement DP? "
                    },
                    {
                        "username": "yogeshpractice",
                        "content": "I\\'m not able to convert my meoization to tabulation, can someone help me\\n```class Solution {\\npublic:\\n    int sumT;\\n    int solve(int idx, int sum, int target, vector<int> &arr, int n, map<pair<int,int>, int> &dp)\\n    {\\n        if(idx==n){\\n            if(sum == target) return 1;\\n            return 0;\\n        }\\n\\n        if(dp.count({idx, sum}) > 0)\\n        return dp[{idx, sum}];\\n\\n        int pos = solve(idx+1, sum+arr[idx], target, arr,n,dp);\\n        int neg = solve(idx+1, sum-arr[idx], target, arr,n, dp);\\n        dp[{idx, sum}] = (pos + neg); \\n        return dp[{idx, sum}];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(),sum=0;\\n        sumT=accumulate(nums.begin(), nums.end(), 0);\\n        map<pair<int, int>, int> dp;\\n        return solve(0,sum,target,nums,n, dp);\\n    }\\n};```"
                    },
                    {
                        "username": "Seemon2000",
                        "content": "check if the value is greater than -1 a 0 can be valid case for that option\\nif(dp.count({idx, sum}) > 0)"
                    },
                    {
                        "username": "SG-C",
                        "content": "They should write it Clearly that \" You have to use all element in nums array\" "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n\\n    int s1(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans -nums[i];\\n        return ans;\\n    }\\n    int s2(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans + nums[i];\\n        return ans;\\n    }\\n\\n    public:\\n\\nint findTargetSumWays(vector<int>&nums,int S){ \\n\\n    int minsum = s1(nums);\\n    int maxsum= s2(nums);\\n\\n    if(S>maxsum || S<minsum) return 0;\\n\\n    int r = nums.size();\\n    int c = maxsum - minsum+1;\\n\\n    int** dp = new int*[r];\\n\\n    for(int i=0;i<r;i++){\\n        dp[i] = new int[c];\\n    }\\n\\n    for(int i=0;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            dp[i][j]=0;\\n        }\\n    }\\n    //initlize first row\\n\\n    for(int i=0;i<c;i++){\\n        \\n        bool op1 = (i+minsum) == nums[0];\\n        bool op2 = (i+minsum) == (-1)*nums[0];\\n\\n        if(op1) dp[0][i]+=1;\\n        if(op2) dp[0][i]+=1;\\n    }\\n\\n    //build rest of matrix\\n\\n    for(int i=1;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            int a1 = (j-nums[i]>=0)?dp[i-1][j-nums[i]]:0;\\n            int a2 = (j+nums[i]< c)?dp[i-1][j+nums[i]]:0;\\n\\n            dp[i][j] = a1+a2;\\n        }\\n    }\\n\\n    return dp[r-1][S-minsum];\\n}\\n};"
                    },
                    {
                        "username": "VivekAbstract",
                        "content": "Dont post solution in discussion bro"
                    }
                ]
            },
            {
                "id": 1909781,
                "content": [
                    {
                        "username": "lingarajbal",
                        "content": "/**\\n *  Lets first see the concept here.\\n *  The question asked to assign symbols to each interger.In other words we have to \\n *  divide the whole array into two sub sets having sum S1 and S2. S1-S2=S. Lets draw some\\n *  relation here.\\n *  S1 + S2 = TotalSum(sum of all array elements) [ Equation 1]\\n *  S1 - S2 = S (asked in the question)           [Equation  2]\\n *  if we add Equation 1 and 2 we will have. S1 = (TotalSum + S)/2\\n *  Now the number of sub set of having sum S1 should be the answer to the question.\\n * \\n **/"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "anyone has coded this up? please share! Thanks"
                    },
                    {
                        "username": "aman3091",
                        "content": "i have used same approach still getting error kindly help \\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int s1=(target+sum)/2;\\n        int n=nums.size();\\n        if(n==1){\\n            if(target!=nums[0]&&target!=-1*nums[0]){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n      int t[n+1][s1+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<s1+1;j++){\\n                if(i==0){\\n                    t[i][j]=0;\\n                }\\n                if(j==0){\\n                    t[i][j]=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s1+1;j++){\\n                if(nums[i-1]<=j){\\n                    t[i][j]=t[i-1][j-nums[i-1]] + t[i-1][j];\\n                }\\n                else{\\n                    t[i][j]=t[i-1][j];\\n                }\\n            }\\n        }\\n        return t[n][s1];\\n    }\\n};"
                    },
                    {
                        "username": "kaiyikang",
                        "content": "The idea comes from [this post](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/discuss/97334/Java-(15-ms)-C++-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanation) and this graph shows my personal understanding of the DP solution.\\n![image](https://assets.leetcode.com/users/kaiyikang/image_1569211092.png)\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "from where did you get this dp pic can you please share that book or post"
                    },
                    {
                        "username": "ruokay",
                        "content": "even recursion got accepted :)"
                    },
                    {
                        "username": "ElayMarco",
                        "content": "No explanation as to why something works, or even what you are doing. It's not helpful to most people."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "For those friends who are worrying about negative target, here\\'s a Hint: That the number of ways to get -x is same as number of ways to get +x (just switch every sign in array). I cant believe even the editorial solution doesn\\'t get this right and solves unnecessarily for `[-x , x]` whereas `[0, x]` is sufficient!!"
                    },
                    {
                        "username": "r0hitm",
                        "content": "I think question should have been mentioned that we have to use all the elements of array. if i am wrong please correct me."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Is it only me who did get the recurrence relation but unable to implement DP? "
                    },
                    {
                        "username": "yogeshpractice",
                        "content": "I\\'m not able to convert my meoization to tabulation, can someone help me\\n```class Solution {\\npublic:\\n    int sumT;\\n    int solve(int idx, int sum, int target, vector<int> &arr, int n, map<pair<int,int>, int> &dp)\\n    {\\n        if(idx==n){\\n            if(sum == target) return 1;\\n            return 0;\\n        }\\n\\n        if(dp.count({idx, sum}) > 0)\\n        return dp[{idx, sum}];\\n\\n        int pos = solve(idx+1, sum+arr[idx], target, arr,n,dp);\\n        int neg = solve(idx+1, sum-arr[idx], target, arr,n, dp);\\n        dp[{idx, sum}] = (pos + neg); \\n        return dp[{idx, sum}];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(),sum=0;\\n        sumT=accumulate(nums.begin(), nums.end(), 0);\\n        map<pair<int, int>, int> dp;\\n        return solve(0,sum,target,nums,n, dp);\\n    }\\n};```"
                    },
                    {
                        "username": "Seemon2000",
                        "content": "check if the value is greater than -1 a 0 can be valid case for that option\\nif(dp.count({idx, sum}) > 0)"
                    },
                    {
                        "username": "SG-C",
                        "content": "They should write it Clearly that \" You have to use all element in nums array\" "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n\\n    int s1(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans -nums[i];\\n        return ans;\\n    }\\n    int s2(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans + nums[i];\\n        return ans;\\n    }\\n\\n    public:\\n\\nint findTargetSumWays(vector<int>&nums,int S){ \\n\\n    int minsum = s1(nums);\\n    int maxsum= s2(nums);\\n\\n    if(S>maxsum || S<minsum) return 0;\\n\\n    int r = nums.size();\\n    int c = maxsum - minsum+1;\\n\\n    int** dp = new int*[r];\\n\\n    for(int i=0;i<r;i++){\\n        dp[i] = new int[c];\\n    }\\n\\n    for(int i=0;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            dp[i][j]=0;\\n        }\\n    }\\n    //initlize first row\\n\\n    for(int i=0;i<c;i++){\\n        \\n        bool op1 = (i+minsum) == nums[0];\\n        bool op2 = (i+minsum) == (-1)*nums[0];\\n\\n        if(op1) dp[0][i]+=1;\\n        if(op2) dp[0][i]+=1;\\n    }\\n\\n    //build rest of matrix\\n\\n    for(int i=1;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            int a1 = (j-nums[i]>=0)?dp[i-1][j-nums[i]]:0;\\n            int a2 = (j+nums[i]< c)?dp[i-1][j+nums[i]]:0;\\n\\n            dp[i][j] = a1+a2;\\n        }\\n    }\\n\\n    return dp[r-1][S-minsum];\\n}\\n};"
                    },
                    {
                        "username": "VivekAbstract",
                        "content": "Dont post solution in discussion bro"
                    }
                ]
            },
            {
                "id": 1567979,
                "content": [
                    {
                        "username": "lingarajbal",
                        "content": "/**\\n *  Lets first see the concept here.\\n *  The question asked to assign symbols to each interger.In other words we have to \\n *  divide the whole array into two sub sets having sum S1 and S2. S1-S2=S. Lets draw some\\n *  relation here.\\n *  S1 + S2 = TotalSum(sum of all array elements) [ Equation 1]\\n *  S1 - S2 = S (asked in the question)           [Equation  2]\\n *  if we add Equation 1 and 2 we will have. S1 = (TotalSum + S)/2\\n *  Now the number of sub set of having sum S1 should be the answer to the question.\\n * \\n **/"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "anyone has coded this up? please share! Thanks"
                    },
                    {
                        "username": "aman3091",
                        "content": "i have used same approach still getting error kindly help \\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int s1=(target+sum)/2;\\n        int n=nums.size();\\n        if(n==1){\\n            if(target!=nums[0]&&target!=-1*nums[0]){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n      int t[n+1][s1+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<s1+1;j++){\\n                if(i==0){\\n                    t[i][j]=0;\\n                }\\n                if(j==0){\\n                    t[i][j]=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s1+1;j++){\\n                if(nums[i-1]<=j){\\n                    t[i][j]=t[i-1][j-nums[i-1]] + t[i-1][j];\\n                }\\n                else{\\n                    t[i][j]=t[i-1][j];\\n                }\\n            }\\n        }\\n        return t[n][s1];\\n    }\\n};"
                    },
                    {
                        "username": "kaiyikang",
                        "content": "The idea comes from [this post](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/discuss/97334/Java-(15-ms)-C++-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanation) and this graph shows my personal understanding of the DP solution.\\n![image](https://assets.leetcode.com/users/kaiyikang/image_1569211092.png)\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "from where did you get this dp pic can you please share that book or post"
                    },
                    {
                        "username": "ruokay",
                        "content": "even recursion got accepted :)"
                    },
                    {
                        "username": "ElayMarco",
                        "content": "No explanation as to why something works, or even what you are doing. It's not helpful to most people."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "For those friends who are worrying about negative target, here\\'s a Hint: That the number of ways to get -x is same as number of ways to get +x (just switch every sign in array). I cant believe even the editorial solution doesn\\'t get this right and solves unnecessarily for `[-x , x]` whereas `[0, x]` is sufficient!!"
                    },
                    {
                        "username": "r0hitm",
                        "content": "I think question should have been mentioned that we have to use all the elements of array. if i am wrong please correct me."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Is it only me who did get the recurrence relation but unable to implement DP? "
                    },
                    {
                        "username": "yogeshpractice",
                        "content": "I\\'m not able to convert my meoization to tabulation, can someone help me\\n```class Solution {\\npublic:\\n    int sumT;\\n    int solve(int idx, int sum, int target, vector<int> &arr, int n, map<pair<int,int>, int> &dp)\\n    {\\n        if(idx==n){\\n            if(sum == target) return 1;\\n            return 0;\\n        }\\n\\n        if(dp.count({idx, sum}) > 0)\\n        return dp[{idx, sum}];\\n\\n        int pos = solve(idx+1, sum+arr[idx], target, arr,n,dp);\\n        int neg = solve(idx+1, sum-arr[idx], target, arr,n, dp);\\n        dp[{idx, sum}] = (pos + neg); \\n        return dp[{idx, sum}];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(),sum=0;\\n        sumT=accumulate(nums.begin(), nums.end(), 0);\\n        map<pair<int, int>, int> dp;\\n        return solve(0,sum,target,nums,n, dp);\\n    }\\n};```"
                    },
                    {
                        "username": "Seemon2000",
                        "content": "check if the value is greater than -1 a 0 can be valid case for that option\\nif(dp.count({idx, sum}) > 0)"
                    },
                    {
                        "username": "SG-C",
                        "content": "They should write it Clearly that \" You have to use all element in nums array\" "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n\\n    int s1(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans -nums[i];\\n        return ans;\\n    }\\n    int s2(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans + nums[i];\\n        return ans;\\n    }\\n\\n    public:\\n\\nint findTargetSumWays(vector<int>&nums,int S){ \\n\\n    int minsum = s1(nums);\\n    int maxsum= s2(nums);\\n\\n    if(S>maxsum || S<minsum) return 0;\\n\\n    int r = nums.size();\\n    int c = maxsum - minsum+1;\\n\\n    int** dp = new int*[r];\\n\\n    for(int i=0;i<r;i++){\\n        dp[i] = new int[c];\\n    }\\n\\n    for(int i=0;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            dp[i][j]=0;\\n        }\\n    }\\n    //initlize first row\\n\\n    for(int i=0;i<c;i++){\\n        \\n        bool op1 = (i+minsum) == nums[0];\\n        bool op2 = (i+minsum) == (-1)*nums[0];\\n\\n        if(op1) dp[0][i]+=1;\\n        if(op2) dp[0][i]+=1;\\n    }\\n\\n    //build rest of matrix\\n\\n    for(int i=1;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            int a1 = (j-nums[i]>=0)?dp[i-1][j-nums[i]]:0;\\n            int a2 = (j+nums[i]< c)?dp[i-1][j+nums[i]]:0;\\n\\n            dp[i][j] = a1+a2;\\n        }\\n    }\\n\\n    return dp[r-1][S-minsum];\\n}\\n};"
                    },
                    {
                        "username": "VivekAbstract",
                        "content": "Dont post solution in discussion bro"
                    }
                ]
            },
            {
                "id": 1936179,
                "content": [
                    {
                        "username": "lingarajbal",
                        "content": "/**\\n *  Lets first see the concept here.\\n *  The question asked to assign symbols to each interger.In other words we have to \\n *  divide the whole array into two sub sets having sum S1 and S2. S1-S2=S. Lets draw some\\n *  relation here.\\n *  S1 + S2 = TotalSum(sum of all array elements) [ Equation 1]\\n *  S1 - S2 = S (asked in the question)           [Equation  2]\\n *  if we add Equation 1 and 2 we will have. S1 = (TotalSum + S)/2\\n *  Now the number of sub set of having sum S1 should be the answer to the question.\\n * \\n **/"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "anyone has coded this up? please share! Thanks"
                    },
                    {
                        "username": "aman3091",
                        "content": "i have used same approach still getting error kindly help \\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int s1=(target+sum)/2;\\n        int n=nums.size();\\n        if(n==1){\\n            if(target!=nums[0]&&target!=-1*nums[0]){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n      int t[n+1][s1+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<s1+1;j++){\\n                if(i==0){\\n                    t[i][j]=0;\\n                }\\n                if(j==0){\\n                    t[i][j]=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s1+1;j++){\\n                if(nums[i-1]<=j){\\n                    t[i][j]=t[i-1][j-nums[i-1]] + t[i-1][j];\\n                }\\n                else{\\n                    t[i][j]=t[i-1][j];\\n                }\\n            }\\n        }\\n        return t[n][s1];\\n    }\\n};"
                    },
                    {
                        "username": "kaiyikang",
                        "content": "The idea comes from [this post](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/discuss/97334/Java-(15-ms)-C++-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanation) and this graph shows my personal understanding of the DP solution.\\n![image](https://assets.leetcode.com/users/kaiyikang/image_1569211092.png)\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "from where did you get this dp pic can you please share that book or post"
                    },
                    {
                        "username": "ruokay",
                        "content": "even recursion got accepted :)"
                    },
                    {
                        "username": "ElayMarco",
                        "content": "No explanation as to why something works, or even what you are doing. It's not helpful to most people."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "For those friends who are worrying about negative target, here\\'s a Hint: That the number of ways to get -x is same as number of ways to get +x (just switch every sign in array). I cant believe even the editorial solution doesn\\'t get this right and solves unnecessarily for `[-x , x]` whereas `[0, x]` is sufficient!!"
                    },
                    {
                        "username": "r0hitm",
                        "content": "I think question should have been mentioned that we have to use all the elements of array. if i am wrong please correct me."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Is it only me who did get the recurrence relation but unable to implement DP? "
                    },
                    {
                        "username": "yogeshpractice",
                        "content": "I\\'m not able to convert my meoization to tabulation, can someone help me\\n```class Solution {\\npublic:\\n    int sumT;\\n    int solve(int idx, int sum, int target, vector<int> &arr, int n, map<pair<int,int>, int> &dp)\\n    {\\n        if(idx==n){\\n            if(sum == target) return 1;\\n            return 0;\\n        }\\n\\n        if(dp.count({idx, sum}) > 0)\\n        return dp[{idx, sum}];\\n\\n        int pos = solve(idx+1, sum+arr[idx], target, arr,n,dp);\\n        int neg = solve(idx+1, sum-arr[idx], target, arr,n, dp);\\n        dp[{idx, sum}] = (pos + neg); \\n        return dp[{idx, sum}];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(),sum=0;\\n        sumT=accumulate(nums.begin(), nums.end(), 0);\\n        map<pair<int, int>, int> dp;\\n        return solve(0,sum,target,nums,n, dp);\\n    }\\n};```"
                    },
                    {
                        "username": "Seemon2000",
                        "content": "check if the value is greater than -1 a 0 can be valid case for that option\\nif(dp.count({idx, sum}) > 0)"
                    },
                    {
                        "username": "SG-C",
                        "content": "They should write it Clearly that \" You have to use all element in nums array\" "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n\\n    int s1(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans -nums[i];\\n        return ans;\\n    }\\n    int s2(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans + nums[i];\\n        return ans;\\n    }\\n\\n    public:\\n\\nint findTargetSumWays(vector<int>&nums,int S){ \\n\\n    int minsum = s1(nums);\\n    int maxsum= s2(nums);\\n\\n    if(S>maxsum || S<minsum) return 0;\\n\\n    int r = nums.size();\\n    int c = maxsum - minsum+1;\\n\\n    int** dp = new int*[r];\\n\\n    for(int i=0;i<r;i++){\\n        dp[i] = new int[c];\\n    }\\n\\n    for(int i=0;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            dp[i][j]=0;\\n        }\\n    }\\n    //initlize first row\\n\\n    for(int i=0;i<c;i++){\\n        \\n        bool op1 = (i+minsum) == nums[0];\\n        bool op2 = (i+minsum) == (-1)*nums[0];\\n\\n        if(op1) dp[0][i]+=1;\\n        if(op2) dp[0][i]+=1;\\n    }\\n\\n    //build rest of matrix\\n\\n    for(int i=1;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            int a1 = (j-nums[i]>=0)?dp[i-1][j-nums[i]]:0;\\n            int a2 = (j+nums[i]< c)?dp[i-1][j+nums[i]]:0;\\n\\n            dp[i][j] = a1+a2;\\n        }\\n    }\\n\\n    return dp[r-1][S-minsum];\\n}\\n};"
                    },
                    {
                        "username": "VivekAbstract",
                        "content": "Dont post solution in discussion bro"
                    }
                ]
            },
            {
                "id": 1998685,
                "content": [
                    {
                        "username": "lingarajbal",
                        "content": "/**\\n *  Lets first see the concept here.\\n *  The question asked to assign symbols to each interger.In other words we have to \\n *  divide the whole array into two sub sets having sum S1 and S2. S1-S2=S. Lets draw some\\n *  relation here.\\n *  S1 + S2 = TotalSum(sum of all array elements) [ Equation 1]\\n *  S1 - S2 = S (asked in the question)           [Equation  2]\\n *  if we add Equation 1 and 2 we will have. S1 = (TotalSum + S)/2\\n *  Now the number of sub set of having sum S1 should be the answer to the question.\\n * \\n **/"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "anyone has coded this up? please share! Thanks"
                    },
                    {
                        "username": "aman3091",
                        "content": "i have used same approach still getting error kindly help \\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int s1=(target+sum)/2;\\n        int n=nums.size();\\n        if(n==1){\\n            if(target!=nums[0]&&target!=-1*nums[0]){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n      int t[n+1][s1+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<s1+1;j++){\\n                if(i==0){\\n                    t[i][j]=0;\\n                }\\n                if(j==0){\\n                    t[i][j]=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s1+1;j++){\\n                if(nums[i-1]<=j){\\n                    t[i][j]=t[i-1][j-nums[i-1]] + t[i-1][j];\\n                }\\n                else{\\n                    t[i][j]=t[i-1][j];\\n                }\\n            }\\n        }\\n        return t[n][s1];\\n    }\\n};"
                    },
                    {
                        "username": "kaiyikang",
                        "content": "The idea comes from [this post](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/discuss/97334/Java-(15-ms)-C++-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanation) and this graph shows my personal understanding of the DP solution.\\n![image](https://assets.leetcode.com/users/kaiyikang/image_1569211092.png)\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "from where did you get this dp pic can you please share that book or post"
                    },
                    {
                        "username": "ruokay",
                        "content": "even recursion got accepted :)"
                    },
                    {
                        "username": "ElayMarco",
                        "content": "No explanation as to why something works, or even what you are doing. It's not helpful to most people."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "For those friends who are worrying about negative target, here\\'s a Hint: That the number of ways to get -x is same as number of ways to get +x (just switch every sign in array). I cant believe even the editorial solution doesn\\'t get this right and solves unnecessarily for `[-x , x]` whereas `[0, x]` is sufficient!!"
                    },
                    {
                        "username": "r0hitm",
                        "content": "I think question should have been mentioned that we have to use all the elements of array. if i am wrong please correct me."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Is it only me who did get the recurrence relation but unable to implement DP? "
                    },
                    {
                        "username": "yogeshpractice",
                        "content": "I\\'m not able to convert my meoization to tabulation, can someone help me\\n```class Solution {\\npublic:\\n    int sumT;\\n    int solve(int idx, int sum, int target, vector<int> &arr, int n, map<pair<int,int>, int> &dp)\\n    {\\n        if(idx==n){\\n            if(sum == target) return 1;\\n            return 0;\\n        }\\n\\n        if(dp.count({idx, sum}) > 0)\\n        return dp[{idx, sum}];\\n\\n        int pos = solve(idx+1, sum+arr[idx], target, arr,n,dp);\\n        int neg = solve(idx+1, sum-arr[idx], target, arr,n, dp);\\n        dp[{idx, sum}] = (pos + neg); \\n        return dp[{idx, sum}];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(),sum=0;\\n        sumT=accumulate(nums.begin(), nums.end(), 0);\\n        map<pair<int, int>, int> dp;\\n        return solve(0,sum,target,nums,n, dp);\\n    }\\n};```"
                    },
                    {
                        "username": "Seemon2000",
                        "content": "check if the value is greater than -1 a 0 can be valid case for that option\\nif(dp.count({idx, sum}) > 0)"
                    },
                    {
                        "username": "SG-C",
                        "content": "They should write it Clearly that \" You have to use all element in nums array\" "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n\\n    int s1(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans -nums[i];\\n        return ans;\\n    }\\n    int s2(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans + nums[i];\\n        return ans;\\n    }\\n\\n    public:\\n\\nint findTargetSumWays(vector<int>&nums,int S){ \\n\\n    int minsum = s1(nums);\\n    int maxsum= s2(nums);\\n\\n    if(S>maxsum || S<minsum) return 0;\\n\\n    int r = nums.size();\\n    int c = maxsum - minsum+1;\\n\\n    int** dp = new int*[r];\\n\\n    for(int i=0;i<r;i++){\\n        dp[i] = new int[c];\\n    }\\n\\n    for(int i=0;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            dp[i][j]=0;\\n        }\\n    }\\n    //initlize first row\\n\\n    for(int i=0;i<c;i++){\\n        \\n        bool op1 = (i+minsum) == nums[0];\\n        bool op2 = (i+minsum) == (-1)*nums[0];\\n\\n        if(op1) dp[0][i]+=1;\\n        if(op2) dp[0][i]+=1;\\n    }\\n\\n    //build rest of matrix\\n\\n    for(int i=1;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            int a1 = (j-nums[i]>=0)?dp[i-1][j-nums[i]]:0;\\n            int a2 = (j+nums[i]< c)?dp[i-1][j+nums[i]]:0;\\n\\n            dp[i][j] = a1+a2;\\n        }\\n    }\\n\\n    return dp[r-1][S-minsum];\\n}\\n};"
                    },
                    {
                        "username": "VivekAbstract",
                        "content": "Dont post solution in discussion bro"
                    }
                ]
            },
            {
                "id": 1985106,
                "content": [
                    {
                        "username": "lingarajbal",
                        "content": "/**\\n *  Lets first see the concept here.\\n *  The question asked to assign symbols to each interger.In other words we have to \\n *  divide the whole array into two sub sets having sum S1 and S2. S1-S2=S. Lets draw some\\n *  relation here.\\n *  S1 + S2 = TotalSum(sum of all array elements) [ Equation 1]\\n *  S1 - S2 = S (asked in the question)           [Equation  2]\\n *  if we add Equation 1 and 2 we will have. S1 = (TotalSum + S)/2\\n *  Now the number of sub set of having sum S1 should be the answer to the question.\\n * \\n **/"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "anyone has coded this up? please share! Thanks"
                    },
                    {
                        "username": "aman3091",
                        "content": "i have used same approach still getting error kindly help \\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int s1=(target+sum)/2;\\n        int n=nums.size();\\n        if(n==1){\\n            if(target!=nums[0]&&target!=-1*nums[0]){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n      int t[n+1][s1+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<s1+1;j++){\\n                if(i==0){\\n                    t[i][j]=0;\\n                }\\n                if(j==0){\\n                    t[i][j]=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s1+1;j++){\\n                if(nums[i-1]<=j){\\n                    t[i][j]=t[i-1][j-nums[i-1]] + t[i-1][j];\\n                }\\n                else{\\n                    t[i][j]=t[i-1][j];\\n                }\\n            }\\n        }\\n        return t[n][s1];\\n    }\\n};"
                    },
                    {
                        "username": "kaiyikang",
                        "content": "The idea comes from [this post](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/discuss/97334/Java-(15-ms)-C++-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanation) and this graph shows my personal understanding of the DP solution.\\n![image](https://assets.leetcode.com/users/kaiyikang/image_1569211092.png)\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "from where did you get this dp pic can you please share that book or post"
                    },
                    {
                        "username": "ruokay",
                        "content": "even recursion got accepted :)"
                    },
                    {
                        "username": "ElayMarco",
                        "content": "No explanation as to why something works, or even what you are doing. It's not helpful to most people."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "For those friends who are worrying about negative target, here\\'s a Hint: That the number of ways to get -x is same as number of ways to get +x (just switch every sign in array). I cant believe even the editorial solution doesn\\'t get this right and solves unnecessarily for `[-x , x]` whereas `[0, x]` is sufficient!!"
                    },
                    {
                        "username": "r0hitm",
                        "content": "I think question should have been mentioned that we have to use all the elements of array. if i am wrong please correct me."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Is it only me who did get the recurrence relation but unable to implement DP? "
                    },
                    {
                        "username": "yogeshpractice",
                        "content": "I\\'m not able to convert my meoization to tabulation, can someone help me\\n```class Solution {\\npublic:\\n    int sumT;\\n    int solve(int idx, int sum, int target, vector<int> &arr, int n, map<pair<int,int>, int> &dp)\\n    {\\n        if(idx==n){\\n            if(sum == target) return 1;\\n            return 0;\\n        }\\n\\n        if(dp.count({idx, sum}) > 0)\\n        return dp[{idx, sum}];\\n\\n        int pos = solve(idx+1, sum+arr[idx], target, arr,n,dp);\\n        int neg = solve(idx+1, sum-arr[idx], target, arr,n, dp);\\n        dp[{idx, sum}] = (pos + neg); \\n        return dp[{idx, sum}];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(),sum=0;\\n        sumT=accumulate(nums.begin(), nums.end(), 0);\\n        map<pair<int, int>, int> dp;\\n        return solve(0,sum,target,nums,n, dp);\\n    }\\n};```"
                    },
                    {
                        "username": "Seemon2000",
                        "content": "check if the value is greater than -1 a 0 can be valid case for that option\\nif(dp.count({idx, sum}) > 0)"
                    },
                    {
                        "username": "SG-C",
                        "content": "They should write it Clearly that \" You have to use all element in nums array\" "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n\\n    int s1(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans -nums[i];\\n        return ans;\\n    }\\n    int s2(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans + nums[i];\\n        return ans;\\n    }\\n\\n    public:\\n\\nint findTargetSumWays(vector<int>&nums,int S){ \\n\\n    int minsum = s1(nums);\\n    int maxsum= s2(nums);\\n\\n    if(S>maxsum || S<minsum) return 0;\\n\\n    int r = nums.size();\\n    int c = maxsum - minsum+1;\\n\\n    int** dp = new int*[r];\\n\\n    for(int i=0;i<r;i++){\\n        dp[i] = new int[c];\\n    }\\n\\n    for(int i=0;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            dp[i][j]=0;\\n        }\\n    }\\n    //initlize first row\\n\\n    for(int i=0;i<c;i++){\\n        \\n        bool op1 = (i+minsum) == nums[0];\\n        bool op2 = (i+minsum) == (-1)*nums[0];\\n\\n        if(op1) dp[0][i]+=1;\\n        if(op2) dp[0][i]+=1;\\n    }\\n\\n    //build rest of matrix\\n\\n    for(int i=1;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            int a1 = (j-nums[i]>=0)?dp[i-1][j-nums[i]]:0;\\n            int a2 = (j+nums[i]< c)?dp[i-1][j+nums[i]]:0;\\n\\n            dp[i][j] = a1+a2;\\n        }\\n    }\\n\\n    return dp[r-1][S-minsum];\\n}\\n};"
                    },
                    {
                        "username": "VivekAbstract",
                        "content": "Dont post solution in discussion bro"
                    }
                ]
            },
            {
                "id": 1775100,
                "content": [
                    {
                        "username": "lingarajbal",
                        "content": "/**\\n *  Lets first see the concept here.\\n *  The question asked to assign symbols to each interger.In other words we have to \\n *  divide the whole array into two sub sets having sum S1 and S2. S1-S2=S. Lets draw some\\n *  relation here.\\n *  S1 + S2 = TotalSum(sum of all array elements) [ Equation 1]\\n *  S1 - S2 = S (asked in the question)           [Equation  2]\\n *  if we add Equation 1 and 2 we will have. S1 = (TotalSum + S)/2\\n *  Now the number of sub set of having sum S1 should be the answer to the question.\\n * \\n **/"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "anyone has coded this up? please share! Thanks"
                    },
                    {
                        "username": "aman3091",
                        "content": "i have used same approach still getting error kindly help \\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int s1=(target+sum)/2;\\n        int n=nums.size();\\n        if(n==1){\\n            if(target!=nums[0]&&target!=-1*nums[0]){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n      int t[n+1][s1+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<s1+1;j++){\\n                if(i==0){\\n                    t[i][j]=0;\\n                }\\n                if(j==0){\\n                    t[i][j]=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s1+1;j++){\\n                if(nums[i-1]<=j){\\n                    t[i][j]=t[i-1][j-nums[i-1]] + t[i-1][j];\\n                }\\n                else{\\n                    t[i][j]=t[i-1][j];\\n                }\\n            }\\n        }\\n        return t[n][s1];\\n    }\\n};"
                    },
                    {
                        "username": "kaiyikang",
                        "content": "The idea comes from [this post](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/discuss/97334/Java-(15-ms)-C++-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanation) and this graph shows my personal understanding of the DP solution.\\n![image](https://assets.leetcode.com/users/kaiyikang/image_1569211092.png)\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "from where did you get this dp pic can you please share that book or post"
                    },
                    {
                        "username": "ruokay",
                        "content": "even recursion got accepted :)"
                    },
                    {
                        "username": "ElayMarco",
                        "content": "No explanation as to why something works, or even what you are doing. It's not helpful to most people."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "For those friends who are worrying about negative target, here\\'s a Hint: That the number of ways to get -x is same as number of ways to get +x (just switch every sign in array). I cant believe even the editorial solution doesn\\'t get this right and solves unnecessarily for `[-x , x]` whereas `[0, x]` is sufficient!!"
                    },
                    {
                        "username": "r0hitm",
                        "content": "I think question should have been mentioned that we have to use all the elements of array. if i am wrong please correct me."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Is it only me who did get the recurrence relation but unable to implement DP? "
                    },
                    {
                        "username": "yogeshpractice",
                        "content": "I\\'m not able to convert my meoization to tabulation, can someone help me\\n```class Solution {\\npublic:\\n    int sumT;\\n    int solve(int idx, int sum, int target, vector<int> &arr, int n, map<pair<int,int>, int> &dp)\\n    {\\n        if(idx==n){\\n            if(sum == target) return 1;\\n            return 0;\\n        }\\n\\n        if(dp.count({idx, sum}) > 0)\\n        return dp[{idx, sum}];\\n\\n        int pos = solve(idx+1, sum+arr[idx], target, arr,n,dp);\\n        int neg = solve(idx+1, sum-arr[idx], target, arr,n, dp);\\n        dp[{idx, sum}] = (pos + neg); \\n        return dp[{idx, sum}];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(),sum=0;\\n        sumT=accumulate(nums.begin(), nums.end(), 0);\\n        map<pair<int, int>, int> dp;\\n        return solve(0,sum,target,nums,n, dp);\\n    }\\n};```"
                    },
                    {
                        "username": "Seemon2000",
                        "content": "check if the value is greater than -1 a 0 can be valid case for that option\\nif(dp.count({idx, sum}) > 0)"
                    },
                    {
                        "username": "SG-C",
                        "content": "They should write it Clearly that \" You have to use all element in nums array\" "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n\\n    int s1(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans -nums[i];\\n        return ans;\\n    }\\n    int s2(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans + nums[i];\\n        return ans;\\n    }\\n\\n    public:\\n\\nint findTargetSumWays(vector<int>&nums,int S){ \\n\\n    int minsum = s1(nums);\\n    int maxsum= s2(nums);\\n\\n    if(S>maxsum || S<minsum) return 0;\\n\\n    int r = nums.size();\\n    int c = maxsum - minsum+1;\\n\\n    int** dp = new int*[r];\\n\\n    for(int i=0;i<r;i++){\\n        dp[i] = new int[c];\\n    }\\n\\n    for(int i=0;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            dp[i][j]=0;\\n        }\\n    }\\n    //initlize first row\\n\\n    for(int i=0;i<c;i++){\\n        \\n        bool op1 = (i+minsum) == nums[0];\\n        bool op2 = (i+minsum) == (-1)*nums[0];\\n\\n        if(op1) dp[0][i]+=1;\\n        if(op2) dp[0][i]+=1;\\n    }\\n\\n    //build rest of matrix\\n\\n    for(int i=1;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            int a1 = (j-nums[i]>=0)?dp[i-1][j-nums[i]]:0;\\n            int a2 = (j+nums[i]< c)?dp[i-1][j+nums[i]]:0;\\n\\n            dp[i][j] = a1+a2;\\n        }\\n    }\\n\\n    return dp[r-1][S-minsum];\\n}\\n};"
                    },
                    {
                        "username": "VivekAbstract",
                        "content": "Dont post solution in discussion bro"
                    }
                ]
            },
            {
                "id": 1994764,
                "content": [
                    {
                        "username": "lingarajbal",
                        "content": "/**\\n *  Lets first see the concept here.\\n *  The question asked to assign symbols to each interger.In other words we have to \\n *  divide the whole array into two sub sets having sum S1 and S2. S1-S2=S. Lets draw some\\n *  relation here.\\n *  S1 + S2 = TotalSum(sum of all array elements) [ Equation 1]\\n *  S1 - S2 = S (asked in the question)           [Equation  2]\\n *  if we add Equation 1 and 2 we will have. S1 = (TotalSum + S)/2\\n *  Now the number of sub set of having sum S1 should be the answer to the question.\\n * \\n **/"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "anyone has coded this up? please share! Thanks"
                    },
                    {
                        "username": "aman3091",
                        "content": "i have used same approach still getting error kindly help \\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int s1=(target+sum)/2;\\n        int n=nums.size();\\n        if(n==1){\\n            if(target!=nums[0]&&target!=-1*nums[0]){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n      int t[n+1][s1+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<s1+1;j++){\\n                if(i==0){\\n                    t[i][j]=0;\\n                }\\n                if(j==0){\\n                    t[i][j]=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s1+1;j++){\\n                if(nums[i-1]<=j){\\n                    t[i][j]=t[i-1][j-nums[i-1]] + t[i-1][j];\\n                }\\n                else{\\n                    t[i][j]=t[i-1][j];\\n                }\\n            }\\n        }\\n        return t[n][s1];\\n    }\\n};"
                    },
                    {
                        "username": "kaiyikang",
                        "content": "The idea comes from [this post](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/discuss/97334/Java-(15-ms)-C++-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanation) and this graph shows my personal understanding of the DP solution.\\n![image](https://assets.leetcode.com/users/kaiyikang/image_1569211092.png)\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "from where did you get this dp pic can you please share that book or post"
                    },
                    {
                        "username": "ruokay",
                        "content": "even recursion got accepted :)"
                    },
                    {
                        "username": "ElayMarco",
                        "content": "No explanation as to why something works, or even what you are doing. It's not helpful to most people."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "For those friends who are worrying about negative target, here\\'s a Hint: That the number of ways to get -x is same as number of ways to get +x (just switch every sign in array). I cant believe even the editorial solution doesn\\'t get this right and solves unnecessarily for `[-x , x]` whereas `[0, x]` is sufficient!!"
                    },
                    {
                        "username": "r0hitm",
                        "content": "I think question should have been mentioned that we have to use all the elements of array. if i am wrong please correct me."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Is it only me who did get the recurrence relation but unable to implement DP? "
                    },
                    {
                        "username": "yogeshpractice",
                        "content": "I\\'m not able to convert my meoization to tabulation, can someone help me\\n```class Solution {\\npublic:\\n    int sumT;\\n    int solve(int idx, int sum, int target, vector<int> &arr, int n, map<pair<int,int>, int> &dp)\\n    {\\n        if(idx==n){\\n            if(sum == target) return 1;\\n            return 0;\\n        }\\n\\n        if(dp.count({idx, sum}) > 0)\\n        return dp[{idx, sum}];\\n\\n        int pos = solve(idx+1, sum+arr[idx], target, arr,n,dp);\\n        int neg = solve(idx+1, sum-arr[idx], target, arr,n, dp);\\n        dp[{idx, sum}] = (pos + neg); \\n        return dp[{idx, sum}];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(),sum=0;\\n        sumT=accumulate(nums.begin(), nums.end(), 0);\\n        map<pair<int, int>, int> dp;\\n        return solve(0,sum,target,nums,n, dp);\\n    }\\n};```"
                    },
                    {
                        "username": "Seemon2000",
                        "content": "check if the value is greater than -1 a 0 can be valid case for that option\\nif(dp.count({idx, sum}) > 0)"
                    },
                    {
                        "username": "SG-C",
                        "content": "They should write it Clearly that \" You have to use all element in nums array\" "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n\\n    int s1(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans -nums[i];\\n        return ans;\\n    }\\n    int s2(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans + nums[i];\\n        return ans;\\n    }\\n\\n    public:\\n\\nint findTargetSumWays(vector<int>&nums,int S){ \\n\\n    int minsum = s1(nums);\\n    int maxsum= s2(nums);\\n\\n    if(S>maxsum || S<minsum) return 0;\\n\\n    int r = nums.size();\\n    int c = maxsum - minsum+1;\\n\\n    int** dp = new int*[r];\\n\\n    for(int i=0;i<r;i++){\\n        dp[i] = new int[c];\\n    }\\n\\n    for(int i=0;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            dp[i][j]=0;\\n        }\\n    }\\n    //initlize first row\\n\\n    for(int i=0;i<c;i++){\\n        \\n        bool op1 = (i+minsum) == nums[0];\\n        bool op2 = (i+minsum) == (-1)*nums[0];\\n\\n        if(op1) dp[0][i]+=1;\\n        if(op2) dp[0][i]+=1;\\n    }\\n\\n    //build rest of matrix\\n\\n    for(int i=1;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            int a1 = (j-nums[i]>=0)?dp[i-1][j-nums[i]]:0;\\n            int a2 = (j+nums[i]< c)?dp[i-1][j+nums[i]]:0;\\n\\n            dp[i][j] = a1+a2;\\n        }\\n    }\\n\\n    return dp[r-1][S-minsum];\\n}\\n};"
                    },
                    {
                        "username": "VivekAbstract",
                        "content": "Dont post solution in discussion bro"
                    }
                ]
            },
            {
                "id": 1810973,
                "content": [
                    {
                        "username": "lingarajbal",
                        "content": "/**\\n *  Lets first see the concept here.\\n *  The question asked to assign symbols to each interger.In other words we have to \\n *  divide the whole array into two sub sets having sum S1 and S2. S1-S2=S. Lets draw some\\n *  relation here.\\n *  S1 + S2 = TotalSum(sum of all array elements) [ Equation 1]\\n *  S1 - S2 = S (asked in the question)           [Equation  2]\\n *  if we add Equation 1 and 2 we will have. S1 = (TotalSum + S)/2\\n *  Now the number of sub set of having sum S1 should be the answer to the question.\\n * \\n **/"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "anyone has coded this up? please share! Thanks"
                    },
                    {
                        "username": "aman3091",
                        "content": "i have used same approach still getting error kindly help \\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int s1=(target+sum)/2;\\n        int n=nums.size();\\n        if(n==1){\\n            if(target!=nums[0]&&target!=-1*nums[0]){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n      int t[n+1][s1+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<s1+1;j++){\\n                if(i==0){\\n                    t[i][j]=0;\\n                }\\n                if(j==0){\\n                    t[i][j]=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s1+1;j++){\\n                if(nums[i-1]<=j){\\n                    t[i][j]=t[i-1][j-nums[i-1]] + t[i-1][j];\\n                }\\n                else{\\n                    t[i][j]=t[i-1][j];\\n                }\\n            }\\n        }\\n        return t[n][s1];\\n    }\\n};"
                    },
                    {
                        "username": "kaiyikang",
                        "content": "The idea comes from [this post](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/discuss/97334/Java-(15-ms)-C++-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanation) and this graph shows my personal understanding of the DP solution.\\n![image](https://assets.leetcode.com/users/kaiyikang/image_1569211092.png)\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "from where did you get this dp pic can you please share that book or post"
                    },
                    {
                        "username": "ruokay",
                        "content": "even recursion got accepted :)"
                    },
                    {
                        "username": "ElayMarco",
                        "content": "No explanation as to why something works, or even what you are doing. It's not helpful to most people."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "For those friends who are worrying about negative target, here\\'s a Hint: That the number of ways to get -x is same as number of ways to get +x (just switch every sign in array). I cant believe even the editorial solution doesn\\'t get this right and solves unnecessarily for `[-x , x]` whereas `[0, x]` is sufficient!!"
                    },
                    {
                        "username": "r0hitm",
                        "content": "I think question should have been mentioned that we have to use all the elements of array. if i am wrong please correct me."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Is it only me who did get the recurrence relation but unable to implement DP? "
                    },
                    {
                        "username": "yogeshpractice",
                        "content": "I\\'m not able to convert my meoization to tabulation, can someone help me\\n```class Solution {\\npublic:\\n    int sumT;\\n    int solve(int idx, int sum, int target, vector<int> &arr, int n, map<pair<int,int>, int> &dp)\\n    {\\n        if(idx==n){\\n            if(sum == target) return 1;\\n            return 0;\\n        }\\n\\n        if(dp.count({idx, sum}) > 0)\\n        return dp[{idx, sum}];\\n\\n        int pos = solve(idx+1, sum+arr[idx], target, arr,n,dp);\\n        int neg = solve(idx+1, sum-arr[idx], target, arr,n, dp);\\n        dp[{idx, sum}] = (pos + neg); \\n        return dp[{idx, sum}];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(),sum=0;\\n        sumT=accumulate(nums.begin(), nums.end(), 0);\\n        map<pair<int, int>, int> dp;\\n        return solve(0,sum,target,nums,n, dp);\\n    }\\n};```"
                    },
                    {
                        "username": "Seemon2000",
                        "content": "check if the value is greater than -1 a 0 can be valid case for that option\\nif(dp.count({idx, sum}) > 0)"
                    },
                    {
                        "username": "SG-C",
                        "content": "They should write it Clearly that \" You have to use all element in nums array\" "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n\\n    int s1(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans -nums[i];\\n        return ans;\\n    }\\n    int s2(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans + nums[i];\\n        return ans;\\n    }\\n\\n    public:\\n\\nint findTargetSumWays(vector<int>&nums,int S){ \\n\\n    int minsum = s1(nums);\\n    int maxsum= s2(nums);\\n\\n    if(S>maxsum || S<minsum) return 0;\\n\\n    int r = nums.size();\\n    int c = maxsum - minsum+1;\\n\\n    int** dp = new int*[r];\\n\\n    for(int i=0;i<r;i++){\\n        dp[i] = new int[c];\\n    }\\n\\n    for(int i=0;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            dp[i][j]=0;\\n        }\\n    }\\n    //initlize first row\\n\\n    for(int i=0;i<c;i++){\\n        \\n        bool op1 = (i+minsum) == nums[0];\\n        bool op2 = (i+minsum) == (-1)*nums[0];\\n\\n        if(op1) dp[0][i]+=1;\\n        if(op2) dp[0][i]+=1;\\n    }\\n\\n    //build rest of matrix\\n\\n    for(int i=1;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            int a1 = (j-nums[i]>=0)?dp[i-1][j-nums[i]]:0;\\n            int a2 = (j+nums[i]< c)?dp[i-1][j+nums[i]]:0;\\n\\n            dp[i][j] = a1+a2;\\n        }\\n    }\\n\\n    return dp[r-1][S-minsum];\\n}\\n};"
                    },
                    {
                        "username": "VivekAbstract",
                        "content": "Dont post solution in discussion bro"
                    }
                ]
            },
            {
                "id": 1570050,
                "content": [
                    {
                        "username": "lingarajbal",
                        "content": "/**\\n *  Lets first see the concept here.\\n *  The question asked to assign symbols to each interger.In other words we have to \\n *  divide the whole array into two sub sets having sum S1 and S2. S1-S2=S. Lets draw some\\n *  relation here.\\n *  S1 + S2 = TotalSum(sum of all array elements) [ Equation 1]\\n *  S1 - S2 = S (asked in the question)           [Equation  2]\\n *  if we add Equation 1 and 2 we will have. S1 = (TotalSum + S)/2\\n *  Now the number of sub set of having sum S1 should be the answer to the question.\\n * \\n **/"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "anyone has coded this up? please share! Thanks"
                    },
                    {
                        "username": "aman3091",
                        "content": "i have used same approach still getting error kindly help \\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int s1=(target+sum)/2;\\n        int n=nums.size();\\n        if(n==1){\\n            if(target!=nums[0]&&target!=-1*nums[0]){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n      int t[n+1][s1+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<s1+1;j++){\\n                if(i==0){\\n                    t[i][j]=0;\\n                }\\n                if(j==0){\\n                    t[i][j]=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s1+1;j++){\\n                if(nums[i-1]<=j){\\n                    t[i][j]=t[i-1][j-nums[i-1]] + t[i-1][j];\\n                }\\n                else{\\n                    t[i][j]=t[i-1][j];\\n                }\\n            }\\n        }\\n        return t[n][s1];\\n    }\\n};"
                    },
                    {
                        "username": "kaiyikang",
                        "content": "The idea comes from [this post](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/discuss/97334/Java-(15-ms)-C++-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanation) and this graph shows my personal understanding of the DP solution.\\n![image](https://assets.leetcode.com/users/kaiyikang/image_1569211092.png)\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "from where did you get this dp pic can you please share that book or post"
                    },
                    {
                        "username": "ruokay",
                        "content": "even recursion got accepted :)"
                    },
                    {
                        "username": "ElayMarco",
                        "content": "No explanation as to why something works, or even what you are doing. It's not helpful to most people."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "For those friends who are worrying about negative target, here\\'s a Hint: That the number of ways to get -x is same as number of ways to get +x (just switch every sign in array). I cant believe even the editorial solution doesn\\'t get this right and solves unnecessarily for `[-x , x]` whereas `[0, x]` is sufficient!!"
                    },
                    {
                        "username": "r0hitm",
                        "content": "I think question should have been mentioned that we have to use all the elements of array. if i am wrong please correct me."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Is it only me who did get the recurrence relation but unable to implement DP? "
                    },
                    {
                        "username": "yogeshpractice",
                        "content": "I\\'m not able to convert my meoization to tabulation, can someone help me\\n```class Solution {\\npublic:\\n    int sumT;\\n    int solve(int idx, int sum, int target, vector<int> &arr, int n, map<pair<int,int>, int> &dp)\\n    {\\n        if(idx==n){\\n            if(sum == target) return 1;\\n            return 0;\\n        }\\n\\n        if(dp.count({idx, sum}) > 0)\\n        return dp[{idx, sum}];\\n\\n        int pos = solve(idx+1, sum+arr[idx], target, arr,n,dp);\\n        int neg = solve(idx+1, sum-arr[idx], target, arr,n, dp);\\n        dp[{idx, sum}] = (pos + neg); \\n        return dp[{idx, sum}];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(),sum=0;\\n        sumT=accumulate(nums.begin(), nums.end(), 0);\\n        map<pair<int, int>, int> dp;\\n        return solve(0,sum,target,nums,n, dp);\\n    }\\n};```"
                    },
                    {
                        "username": "Seemon2000",
                        "content": "check if the value is greater than -1 a 0 can be valid case for that option\\nif(dp.count({idx, sum}) > 0)"
                    },
                    {
                        "username": "SG-C",
                        "content": "They should write it Clearly that \" You have to use all element in nums array\" "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n\\n    int s1(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans -nums[i];\\n        return ans;\\n    }\\n    int s2(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans + nums[i];\\n        return ans;\\n    }\\n\\n    public:\\n\\nint findTargetSumWays(vector<int>&nums,int S){ \\n\\n    int minsum = s1(nums);\\n    int maxsum= s2(nums);\\n\\n    if(S>maxsum || S<minsum) return 0;\\n\\n    int r = nums.size();\\n    int c = maxsum - minsum+1;\\n\\n    int** dp = new int*[r];\\n\\n    for(int i=0;i<r;i++){\\n        dp[i] = new int[c];\\n    }\\n\\n    for(int i=0;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            dp[i][j]=0;\\n        }\\n    }\\n    //initlize first row\\n\\n    for(int i=0;i<c;i++){\\n        \\n        bool op1 = (i+minsum) == nums[0];\\n        bool op2 = (i+minsum) == (-1)*nums[0];\\n\\n        if(op1) dp[0][i]+=1;\\n        if(op2) dp[0][i]+=1;\\n    }\\n\\n    //build rest of matrix\\n\\n    for(int i=1;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            int a1 = (j-nums[i]>=0)?dp[i-1][j-nums[i]]:0;\\n            int a2 = (j+nums[i]< c)?dp[i-1][j+nums[i]]:0;\\n\\n            dp[i][j] = a1+a2;\\n        }\\n    }\\n\\n    return dp[r-1][S-minsum];\\n}\\n};"
                    },
                    {
                        "username": "VivekAbstract",
                        "content": "Dont post solution in discussion bro"
                    }
                ]
            },
            {
                "id": 1565294,
                "content": [
                    {
                        "username": "lingarajbal",
                        "content": "/**\\n *  Lets first see the concept here.\\n *  The question asked to assign symbols to each interger.In other words we have to \\n *  divide the whole array into two sub sets having sum S1 and S2. S1-S2=S. Lets draw some\\n *  relation here.\\n *  S1 + S2 = TotalSum(sum of all array elements) [ Equation 1]\\n *  S1 - S2 = S (asked in the question)           [Equation  2]\\n *  if we add Equation 1 and 2 we will have. S1 = (TotalSum + S)/2\\n *  Now the number of sub set of having sum S1 should be the answer to the question.\\n * \\n **/"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "anyone has coded this up? please share! Thanks"
                    },
                    {
                        "username": "aman3091",
                        "content": "i have used same approach still getting error kindly help \\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int s1=(target+sum)/2;\\n        int n=nums.size();\\n        if(n==1){\\n            if(target!=nums[0]&&target!=-1*nums[0]){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n      int t[n+1][s1+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<s1+1;j++){\\n                if(i==0){\\n                    t[i][j]=0;\\n                }\\n                if(j==0){\\n                    t[i][j]=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s1+1;j++){\\n                if(nums[i-1]<=j){\\n                    t[i][j]=t[i-1][j-nums[i-1]] + t[i-1][j];\\n                }\\n                else{\\n                    t[i][j]=t[i-1][j];\\n                }\\n            }\\n        }\\n        return t[n][s1];\\n    }\\n};"
                    },
                    {
                        "username": "kaiyikang",
                        "content": "The idea comes from [this post](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/discuss/97334/Java-(15-ms)-C++-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanation) and this graph shows my personal understanding of the DP solution.\\n![image](https://assets.leetcode.com/users/kaiyikang/image_1569211092.png)\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "from where did you get this dp pic can you please share that book or post"
                    },
                    {
                        "username": "ruokay",
                        "content": "even recursion got accepted :)"
                    },
                    {
                        "username": "ElayMarco",
                        "content": "No explanation as to why something works, or even what you are doing. It's not helpful to most people."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "For those friends who are worrying about negative target, here\\'s a Hint: That the number of ways to get -x is same as number of ways to get +x (just switch every sign in array). I cant believe even the editorial solution doesn\\'t get this right and solves unnecessarily for `[-x , x]` whereas `[0, x]` is sufficient!!"
                    },
                    {
                        "username": "r0hitm",
                        "content": "I think question should have been mentioned that we have to use all the elements of array. if i am wrong please correct me."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Is it only me who did get the recurrence relation but unable to implement DP? "
                    },
                    {
                        "username": "yogeshpractice",
                        "content": "I\\'m not able to convert my meoization to tabulation, can someone help me\\n```class Solution {\\npublic:\\n    int sumT;\\n    int solve(int idx, int sum, int target, vector<int> &arr, int n, map<pair<int,int>, int> &dp)\\n    {\\n        if(idx==n){\\n            if(sum == target) return 1;\\n            return 0;\\n        }\\n\\n        if(dp.count({idx, sum}) > 0)\\n        return dp[{idx, sum}];\\n\\n        int pos = solve(idx+1, sum+arr[idx], target, arr,n,dp);\\n        int neg = solve(idx+1, sum-arr[idx], target, arr,n, dp);\\n        dp[{idx, sum}] = (pos + neg); \\n        return dp[{idx, sum}];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(),sum=0;\\n        sumT=accumulate(nums.begin(), nums.end(), 0);\\n        map<pair<int, int>, int> dp;\\n        return solve(0,sum,target,nums,n, dp);\\n    }\\n};```"
                    },
                    {
                        "username": "Seemon2000",
                        "content": "check if the value is greater than -1 a 0 can be valid case for that option\\nif(dp.count({idx, sum}) > 0)"
                    },
                    {
                        "username": "SG-C",
                        "content": "They should write it Clearly that \" You have to use all element in nums array\" "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n\\n    int s1(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans -nums[i];\\n        return ans;\\n    }\\n    int s2(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans + nums[i];\\n        return ans;\\n    }\\n\\n    public:\\n\\nint findTargetSumWays(vector<int>&nums,int S){ \\n\\n    int minsum = s1(nums);\\n    int maxsum= s2(nums);\\n\\n    if(S>maxsum || S<minsum) return 0;\\n\\n    int r = nums.size();\\n    int c = maxsum - minsum+1;\\n\\n    int** dp = new int*[r];\\n\\n    for(int i=0;i<r;i++){\\n        dp[i] = new int[c];\\n    }\\n\\n    for(int i=0;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            dp[i][j]=0;\\n        }\\n    }\\n    //initlize first row\\n\\n    for(int i=0;i<c;i++){\\n        \\n        bool op1 = (i+minsum) == nums[0];\\n        bool op2 = (i+minsum) == (-1)*nums[0];\\n\\n        if(op1) dp[0][i]+=1;\\n        if(op2) dp[0][i]+=1;\\n    }\\n\\n    //build rest of matrix\\n\\n    for(int i=1;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            int a1 = (j-nums[i]>=0)?dp[i-1][j-nums[i]]:0;\\n            int a2 = (j+nums[i]< c)?dp[i-1][j+nums[i]]:0;\\n\\n            dp[i][j] = a1+a2;\\n        }\\n    }\\n\\n    return dp[r-1][S-minsum];\\n}\\n};"
                    },
                    {
                        "username": "VivekAbstract",
                        "content": "Dont post solution in discussion bro"
                    }
                ]
            },
            {
                "id": 1909781,
                "content": [
                    {
                        "username": "lingarajbal",
                        "content": "/**\\n *  Lets first see the concept here.\\n *  The question asked to assign symbols to each interger.In other words we have to \\n *  divide the whole array into two sub sets having sum S1 and S2. S1-S2=S. Lets draw some\\n *  relation here.\\n *  S1 + S2 = TotalSum(sum of all array elements) [ Equation 1]\\n *  S1 - S2 = S (asked in the question)           [Equation  2]\\n *  if we add Equation 1 and 2 we will have. S1 = (TotalSum + S)/2\\n *  Now the number of sub set of having sum S1 should be the answer to the question.\\n * \\n **/"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "anyone has coded this up? please share! Thanks"
                    },
                    {
                        "username": "aman3091",
                        "content": "i have used same approach still getting error kindly help \\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int s1=(target+sum)/2;\\n        int n=nums.size();\\n        if(n==1){\\n            if(target!=nums[0]&&target!=-1*nums[0]){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n      int t[n+1][s1+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<s1+1;j++){\\n                if(i==0){\\n                    t[i][j]=0;\\n                }\\n                if(j==0){\\n                    t[i][j]=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s1+1;j++){\\n                if(nums[i-1]<=j){\\n                    t[i][j]=t[i-1][j-nums[i-1]] + t[i-1][j];\\n                }\\n                else{\\n                    t[i][j]=t[i-1][j];\\n                }\\n            }\\n        }\\n        return t[n][s1];\\n    }\\n};"
                    },
                    {
                        "username": "kaiyikang",
                        "content": "The idea comes from [this post](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/discuss/97334/Java-(15-ms)-C++-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanation) and this graph shows my personal understanding of the DP solution.\\n![image](https://assets.leetcode.com/users/kaiyikang/image_1569211092.png)\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "from where did you get this dp pic can you please share that book or post"
                    },
                    {
                        "username": "ruokay",
                        "content": "even recursion got accepted :)"
                    },
                    {
                        "username": "ElayMarco",
                        "content": "No explanation as to why something works, or even what you are doing. It's not helpful to most people."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "For those friends who are worrying about negative target, here\\'s a Hint: That the number of ways to get -x is same as number of ways to get +x (just switch every sign in array). I cant believe even the editorial solution doesn\\'t get this right and solves unnecessarily for `[-x , x]` whereas `[0, x]` is sufficient!!"
                    },
                    {
                        "username": "r0hitm",
                        "content": "I think question should have been mentioned that we have to use all the elements of array. if i am wrong please correct me."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Is it only me who did get the recurrence relation but unable to implement DP? "
                    },
                    {
                        "username": "yogeshpractice",
                        "content": "I\\'m not able to convert my meoization to tabulation, can someone help me\\n```class Solution {\\npublic:\\n    int sumT;\\n    int solve(int idx, int sum, int target, vector<int> &arr, int n, map<pair<int,int>, int> &dp)\\n    {\\n        if(idx==n){\\n            if(sum == target) return 1;\\n            return 0;\\n        }\\n\\n        if(dp.count({idx, sum}) > 0)\\n        return dp[{idx, sum}];\\n\\n        int pos = solve(idx+1, sum+arr[idx], target, arr,n,dp);\\n        int neg = solve(idx+1, sum-arr[idx], target, arr,n, dp);\\n        dp[{idx, sum}] = (pos + neg); \\n        return dp[{idx, sum}];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(),sum=0;\\n        sumT=accumulate(nums.begin(), nums.end(), 0);\\n        map<pair<int, int>, int> dp;\\n        return solve(0,sum,target,nums,n, dp);\\n    }\\n};```"
                    },
                    {
                        "username": "Seemon2000",
                        "content": "check if the value is greater than -1 a 0 can be valid case for that option\\nif(dp.count({idx, sum}) > 0)"
                    },
                    {
                        "username": "SG-C",
                        "content": "They should write it Clearly that \" You have to use all element in nums array\" "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n\\n    int s1(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans -nums[i];\\n        return ans;\\n    }\\n    int s2(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans + nums[i];\\n        return ans;\\n    }\\n\\n    public:\\n\\nint findTargetSumWays(vector<int>&nums,int S){ \\n\\n    int minsum = s1(nums);\\n    int maxsum= s2(nums);\\n\\n    if(S>maxsum || S<minsum) return 0;\\n\\n    int r = nums.size();\\n    int c = maxsum - minsum+1;\\n\\n    int** dp = new int*[r];\\n\\n    for(int i=0;i<r;i++){\\n        dp[i] = new int[c];\\n    }\\n\\n    for(int i=0;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            dp[i][j]=0;\\n        }\\n    }\\n    //initlize first row\\n\\n    for(int i=0;i<c;i++){\\n        \\n        bool op1 = (i+minsum) == nums[0];\\n        bool op2 = (i+minsum) == (-1)*nums[0];\\n\\n        if(op1) dp[0][i]+=1;\\n        if(op2) dp[0][i]+=1;\\n    }\\n\\n    //build rest of matrix\\n\\n    for(int i=1;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            int a1 = (j-nums[i]>=0)?dp[i-1][j-nums[i]]:0;\\n            int a2 = (j+nums[i]< c)?dp[i-1][j+nums[i]]:0;\\n\\n            dp[i][j] = a1+a2;\\n        }\\n    }\\n\\n    return dp[r-1][S-minsum];\\n}\\n};"
                    },
                    {
                        "username": "VivekAbstract",
                        "content": "Dont post solution in discussion bro"
                    }
                ]
            },
            {
                "id": 1567979,
                "content": [
                    {
                        "username": "lingarajbal",
                        "content": "/**\\n *  Lets first see the concept here.\\n *  The question asked to assign symbols to each interger.In other words we have to \\n *  divide the whole array into two sub sets having sum S1 and S2. S1-S2=S. Lets draw some\\n *  relation here.\\n *  S1 + S2 = TotalSum(sum of all array elements) [ Equation 1]\\n *  S1 - S2 = S (asked in the question)           [Equation  2]\\n *  if we add Equation 1 and 2 we will have. S1 = (TotalSum + S)/2\\n *  Now the number of sub set of having sum S1 should be the answer to the question.\\n * \\n **/"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "anyone has coded this up? please share! Thanks"
                    },
                    {
                        "username": "aman3091",
                        "content": "i have used same approach still getting error kindly help \\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int s1=(target+sum)/2;\\n        int n=nums.size();\\n        if(n==1){\\n            if(target!=nums[0]&&target!=-1*nums[0]){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n      int t[n+1][s1+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<s1+1;j++){\\n                if(i==0){\\n                    t[i][j]=0;\\n                }\\n                if(j==0){\\n                    t[i][j]=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s1+1;j++){\\n                if(nums[i-1]<=j){\\n                    t[i][j]=t[i-1][j-nums[i-1]] + t[i-1][j];\\n                }\\n                else{\\n                    t[i][j]=t[i-1][j];\\n                }\\n            }\\n        }\\n        return t[n][s1];\\n    }\\n};"
                    },
                    {
                        "username": "kaiyikang",
                        "content": "The idea comes from [this post](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/discuss/97334/Java-(15-ms)-C++-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanation) and this graph shows my personal understanding of the DP solution.\\n![image](https://assets.leetcode.com/users/kaiyikang/image_1569211092.png)\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "from where did you get this dp pic can you please share that book or post"
                    },
                    {
                        "username": "ruokay",
                        "content": "even recursion got accepted :)"
                    },
                    {
                        "username": "ElayMarco",
                        "content": "No explanation as to why something works, or even what you are doing. It's not helpful to most people."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "For those friends who are worrying about negative target, here\\'s a Hint: That the number of ways to get -x is same as number of ways to get +x (just switch every sign in array). I cant believe even the editorial solution doesn\\'t get this right and solves unnecessarily for `[-x , x]` whereas `[0, x]` is sufficient!!"
                    },
                    {
                        "username": "r0hitm",
                        "content": "I think question should have been mentioned that we have to use all the elements of array. if i am wrong please correct me."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Is it only me who did get the recurrence relation but unable to implement DP? "
                    },
                    {
                        "username": "yogeshpractice",
                        "content": "I\\'m not able to convert my meoization to tabulation, can someone help me\\n```class Solution {\\npublic:\\n    int sumT;\\n    int solve(int idx, int sum, int target, vector<int> &arr, int n, map<pair<int,int>, int> &dp)\\n    {\\n        if(idx==n){\\n            if(sum == target) return 1;\\n            return 0;\\n        }\\n\\n        if(dp.count({idx, sum}) > 0)\\n        return dp[{idx, sum}];\\n\\n        int pos = solve(idx+1, sum+arr[idx], target, arr,n,dp);\\n        int neg = solve(idx+1, sum-arr[idx], target, arr,n, dp);\\n        dp[{idx, sum}] = (pos + neg); \\n        return dp[{idx, sum}];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(),sum=0;\\n        sumT=accumulate(nums.begin(), nums.end(), 0);\\n        map<pair<int, int>, int> dp;\\n        return solve(0,sum,target,nums,n, dp);\\n    }\\n};```"
                    },
                    {
                        "username": "Seemon2000",
                        "content": "check if the value is greater than -1 a 0 can be valid case for that option\\nif(dp.count({idx, sum}) > 0)"
                    },
                    {
                        "username": "SG-C",
                        "content": "They should write it Clearly that \" You have to use all element in nums array\" "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n\\n    int s1(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans -nums[i];\\n        return ans;\\n    }\\n    int s2(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans + nums[i];\\n        return ans;\\n    }\\n\\n    public:\\n\\nint findTargetSumWays(vector<int>&nums,int S){ \\n\\n    int minsum = s1(nums);\\n    int maxsum= s2(nums);\\n\\n    if(S>maxsum || S<minsum) return 0;\\n\\n    int r = nums.size();\\n    int c = maxsum - minsum+1;\\n\\n    int** dp = new int*[r];\\n\\n    for(int i=0;i<r;i++){\\n        dp[i] = new int[c];\\n    }\\n\\n    for(int i=0;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            dp[i][j]=0;\\n        }\\n    }\\n    //initlize first row\\n\\n    for(int i=0;i<c;i++){\\n        \\n        bool op1 = (i+minsum) == nums[0];\\n        bool op2 = (i+minsum) == (-1)*nums[0];\\n\\n        if(op1) dp[0][i]+=1;\\n        if(op2) dp[0][i]+=1;\\n    }\\n\\n    //build rest of matrix\\n\\n    for(int i=1;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            int a1 = (j-nums[i]>=0)?dp[i-1][j-nums[i]]:0;\\n            int a2 = (j+nums[i]< c)?dp[i-1][j+nums[i]]:0;\\n\\n            dp[i][j] = a1+a2;\\n        }\\n    }\\n\\n    return dp[r-1][S-minsum];\\n}\\n};"
                    },
                    {
                        "username": "VivekAbstract",
                        "content": "Dont post solution in discussion bro"
                    }
                ]
            },
            {
                "id": 1936179,
                "content": [
                    {
                        "username": "lingarajbal",
                        "content": "/**\\n *  Lets first see the concept here.\\n *  The question asked to assign symbols to each interger.In other words we have to \\n *  divide the whole array into two sub sets having sum S1 and S2. S1-S2=S. Lets draw some\\n *  relation here.\\n *  S1 + S2 = TotalSum(sum of all array elements) [ Equation 1]\\n *  S1 - S2 = S (asked in the question)           [Equation  2]\\n *  if we add Equation 1 and 2 we will have. S1 = (TotalSum + S)/2\\n *  Now the number of sub set of having sum S1 should be the answer to the question.\\n * \\n **/"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "anyone has coded this up? please share! Thanks"
                    },
                    {
                        "username": "aman3091",
                        "content": "i have used same approach still getting error kindly help \\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int s1=(target+sum)/2;\\n        int n=nums.size();\\n        if(n==1){\\n            if(target!=nums[0]&&target!=-1*nums[0]){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n      int t[n+1][s1+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<s1+1;j++){\\n                if(i==0){\\n                    t[i][j]=0;\\n                }\\n                if(j==0){\\n                    t[i][j]=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s1+1;j++){\\n                if(nums[i-1]<=j){\\n                    t[i][j]=t[i-1][j-nums[i-1]] + t[i-1][j];\\n                }\\n                else{\\n                    t[i][j]=t[i-1][j];\\n                }\\n            }\\n        }\\n        return t[n][s1];\\n    }\\n};"
                    },
                    {
                        "username": "kaiyikang",
                        "content": "The idea comes from [this post](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/discuss/97334/Java-(15-ms)-C++-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanation) and this graph shows my personal understanding of the DP solution.\\n![image](https://assets.leetcode.com/users/kaiyikang/image_1569211092.png)\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "from where did you get this dp pic can you please share that book or post"
                    },
                    {
                        "username": "ruokay",
                        "content": "even recursion got accepted :)"
                    },
                    {
                        "username": "ElayMarco",
                        "content": "No explanation as to why something works, or even what you are doing. It's not helpful to most people."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "For those friends who are worrying about negative target, here\\'s a Hint: That the number of ways to get -x is same as number of ways to get +x (just switch every sign in array). I cant believe even the editorial solution doesn\\'t get this right and solves unnecessarily for `[-x , x]` whereas `[0, x]` is sufficient!!"
                    },
                    {
                        "username": "r0hitm",
                        "content": "I think question should have been mentioned that we have to use all the elements of array. if i am wrong please correct me."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Is it only me who did get the recurrence relation but unable to implement DP? "
                    },
                    {
                        "username": "yogeshpractice",
                        "content": "I\\'m not able to convert my meoization to tabulation, can someone help me\\n```class Solution {\\npublic:\\n    int sumT;\\n    int solve(int idx, int sum, int target, vector<int> &arr, int n, map<pair<int,int>, int> &dp)\\n    {\\n        if(idx==n){\\n            if(sum == target) return 1;\\n            return 0;\\n        }\\n\\n        if(dp.count({idx, sum}) > 0)\\n        return dp[{idx, sum}];\\n\\n        int pos = solve(idx+1, sum+arr[idx], target, arr,n,dp);\\n        int neg = solve(idx+1, sum-arr[idx], target, arr,n, dp);\\n        dp[{idx, sum}] = (pos + neg); \\n        return dp[{idx, sum}];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(),sum=0;\\n        sumT=accumulate(nums.begin(), nums.end(), 0);\\n        map<pair<int, int>, int> dp;\\n        return solve(0,sum,target,nums,n, dp);\\n    }\\n};```"
                    },
                    {
                        "username": "Seemon2000",
                        "content": "check if the value is greater than -1 a 0 can be valid case for that option\\nif(dp.count({idx, sum}) > 0)"
                    },
                    {
                        "username": "SG-C",
                        "content": "They should write it Clearly that \" You have to use all element in nums array\" "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n\\n    int s1(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans -nums[i];\\n        return ans;\\n    }\\n    int s2(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans + nums[i];\\n        return ans;\\n    }\\n\\n    public:\\n\\nint findTargetSumWays(vector<int>&nums,int S){ \\n\\n    int minsum = s1(nums);\\n    int maxsum= s2(nums);\\n\\n    if(S>maxsum || S<minsum) return 0;\\n\\n    int r = nums.size();\\n    int c = maxsum - minsum+1;\\n\\n    int** dp = new int*[r];\\n\\n    for(int i=0;i<r;i++){\\n        dp[i] = new int[c];\\n    }\\n\\n    for(int i=0;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            dp[i][j]=0;\\n        }\\n    }\\n    //initlize first row\\n\\n    for(int i=0;i<c;i++){\\n        \\n        bool op1 = (i+minsum) == nums[0];\\n        bool op2 = (i+minsum) == (-1)*nums[0];\\n\\n        if(op1) dp[0][i]+=1;\\n        if(op2) dp[0][i]+=1;\\n    }\\n\\n    //build rest of matrix\\n\\n    for(int i=1;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            int a1 = (j-nums[i]>=0)?dp[i-1][j-nums[i]]:0;\\n            int a2 = (j+nums[i]< c)?dp[i-1][j+nums[i]]:0;\\n\\n            dp[i][j] = a1+a2;\\n        }\\n    }\\n\\n    return dp[r-1][S-minsum];\\n}\\n};"
                    },
                    {
                        "username": "VivekAbstract",
                        "content": "Dont post solution in discussion bro"
                    }
                ]
            },
            {
                "id": 1998685,
                "content": [
                    {
                        "username": "lingarajbal",
                        "content": "/**\\n *  Lets first see the concept here.\\n *  The question asked to assign symbols to each interger.In other words we have to \\n *  divide the whole array into two sub sets having sum S1 and S2. S1-S2=S. Lets draw some\\n *  relation here.\\n *  S1 + S2 = TotalSum(sum of all array elements) [ Equation 1]\\n *  S1 - S2 = S (asked in the question)           [Equation  2]\\n *  if we add Equation 1 and 2 we will have. S1 = (TotalSum + S)/2\\n *  Now the number of sub set of having sum S1 should be the answer to the question.\\n * \\n **/"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "anyone has coded this up? please share! Thanks"
                    },
                    {
                        "username": "aman3091",
                        "content": "i have used same approach still getting error kindly help \\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int s1=(target+sum)/2;\\n        int n=nums.size();\\n        if(n==1){\\n            if(target!=nums[0]&&target!=-1*nums[0]){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n      int t[n+1][s1+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<s1+1;j++){\\n                if(i==0){\\n                    t[i][j]=0;\\n                }\\n                if(j==0){\\n                    t[i][j]=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s1+1;j++){\\n                if(nums[i-1]<=j){\\n                    t[i][j]=t[i-1][j-nums[i-1]] + t[i-1][j];\\n                }\\n                else{\\n                    t[i][j]=t[i-1][j];\\n                }\\n            }\\n        }\\n        return t[n][s1];\\n    }\\n};"
                    },
                    {
                        "username": "kaiyikang",
                        "content": "The idea comes from [this post](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/discuss/97334/Java-(15-ms)-C++-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanation) and this graph shows my personal understanding of the DP solution.\\n![image](https://assets.leetcode.com/users/kaiyikang/image_1569211092.png)\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "from where did you get this dp pic can you please share that book or post"
                    },
                    {
                        "username": "ruokay",
                        "content": "even recursion got accepted :)"
                    },
                    {
                        "username": "ElayMarco",
                        "content": "No explanation as to why something works, or even what you are doing. It's not helpful to most people."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "For those friends who are worrying about negative target, here\\'s a Hint: That the number of ways to get -x is same as number of ways to get +x (just switch every sign in array). I cant believe even the editorial solution doesn\\'t get this right and solves unnecessarily for `[-x , x]` whereas `[0, x]` is sufficient!!"
                    },
                    {
                        "username": "r0hitm",
                        "content": "I think question should have been mentioned that we have to use all the elements of array. if i am wrong please correct me."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Is it only me who did get the recurrence relation but unable to implement DP? "
                    },
                    {
                        "username": "yogeshpractice",
                        "content": "I\\'m not able to convert my meoization to tabulation, can someone help me\\n```class Solution {\\npublic:\\n    int sumT;\\n    int solve(int idx, int sum, int target, vector<int> &arr, int n, map<pair<int,int>, int> &dp)\\n    {\\n        if(idx==n){\\n            if(sum == target) return 1;\\n            return 0;\\n        }\\n\\n        if(dp.count({idx, sum}) > 0)\\n        return dp[{idx, sum}];\\n\\n        int pos = solve(idx+1, sum+arr[idx], target, arr,n,dp);\\n        int neg = solve(idx+1, sum-arr[idx], target, arr,n, dp);\\n        dp[{idx, sum}] = (pos + neg); \\n        return dp[{idx, sum}];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(),sum=0;\\n        sumT=accumulate(nums.begin(), nums.end(), 0);\\n        map<pair<int, int>, int> dp;\\n        return solve(0,sum,target,nums,n, dp);\\n    }\\n};```"
                    },
                    {
                        "username": "Seemon2000",
                        "content": "check if the value is greater than -1 a 0 can be valid case for that option\\nif(dp.count({idx, sum}) > 0)"
                    },
                    {
                        "username": "SG-C",
                        "content": "They should write it Clearly that \" You have to use all element in nums array\" "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n\\n    int s1(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans -nums[i];\\n        return ans;\\n    }\\n    int s2(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans + nums[i];\\n        return ans;\\n    }\\n\\n    public:\\n\\nint findTargetSumWays(vector<int>&nums,int S){ \\n\\n    int minsum = s1(nums);\\n    int maxsum= s2(nums);\\n\\n    if(S>maxsum || S<minsum) return 0;\\n\\n    int r = nums.size();\\n    int c = maxsum - minsum+1;\\n\\n    int** dp = new int*[r];\\n\\n    for(int i=0;i<r;i++){\\n        dp[i] = new int[c];\\n    }\\n\\n    for(int i=0;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            dp[i][j]=0;\\n        }\\n    }\\n    //initlize first row\\n\\n    for(int i=0;i<c;i++){\\n        \\n        bool op1 = (i+minsum) == nums[0];\\n        bool op2 = (i+minsum) == (-1)*nums[0];\\n\\n        if(op1) dp[0][i]+=1;\\n        if(op2) dp[0][i]+=1;\\n    }\\n\\n    //build rest of matrix\\n\\n    for(int i=1;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            int a1 = (j-nums[i]>=0)?dp[i-1][j-nums[i]]:0;\\n            int a2 = (j+nums[i]< c)?dp[i-1][j+nums[i]]:0;\\n\\n            dp[i][j] = a1+a2;\\n        }\\n    }\\n\\n    return dp[r-1][S-minsum];\\n}\\n};"
                    },
                    {
                        "username": "VivekAbstract",
                        "content": "Dont post solution in discussion bro"
                    }
                ]
            },
            {
                "id": 1985106,
                "content": [
                    {
                        "username": "lingarajbal",
                        "content": "/**\\n *  Lets first see the concept here.\\n *  The question asked to assign symbols to each interger.In other words we have to \\n *  divide the whole array into two sub sets having sum S1 and S2. S1-S2=S. Lets draw some\\n *  relation here.\\n *  S1 + S2 = TotalSum(sum of all array elements) [ Equation 1]\\n *  S1 - S2 = S (asked in the question)           [Equation  2]\\n *  if we add Equation 1 and 2 we will have. S1 = (TotalSum + S)/2\\n *  Now the number of sub set of having sum S1 should be the answer to the question.\\n * \\n **/"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "anyone has coded this up? please share! Thanks"
                    },
                    {
                        "username": "aman3091",
                        "content": "i have used same approach still getting error kindly help \\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int s1=(target+sum)/2;\\n        int n=nums.size();\\n        if(n==1){\\n            if(target!=nums[0]&&target!=-1*nums[0]){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n      int t[n+1][s1+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<s1+1;j++){\\n                if(i==0){\\n                    t[i][j]=0;\\n                }\\n                if(j==0){\\n                    t[i][j]=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s1+1;j++){\\n                if(nums[i-1]<=j){\\n                    t[i][j]=t[i-1][j-nums[i-1]] + t[i-1][j];\\n                }\\n                else{\\n                    t[i][j]=t[i-1][j];\\n                }\\n            }\\n        }\\n        return t[n][s1];\\n    }\\n};"
                    },
                    {
                        "username": "kaiyikang",
                        "content": "The idea comes from [this post](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/discuss/97334/Java-(15-ms)-C++-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanation) and this graph shows my personal understanding of the DP solution.\\n![image](https://assets.leetcode.com/users/kaiyikang/image_1569211092.png)\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "from where did you get this dp pic can you please share that book or post"
                    },
                    {
                        "username": "ruokay",
                        "content": "even recursion got accepted :)"
                    },
                    {
                        "username": "ElayMarco",
                        "content": "No explanation as to why something works, or even what you are doing. It's not helpful to most people."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "For those friends who are worrying about negative target, here\\'s a Hint: That the number of ways to get -x is same as number of ways to get +x (just switch every sign in array). I cant believe even the editorial solution doesn\\'t get this right and solves unnecessarily for `[-x , x]` whereas `[0, x]` is sufficient!!"
                    },
                    {
                        "username": "r0hitm",
                        "content": "I think question should have been mentioned that we have to use all the elements of array. if i am wrong please correct me."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Is it only me who did get the recurrence relation but unable to implement DP? "
                    },
                    {
                        "username": "yogeshpractice",
                        "content": "I\\'m not able to convert my meoization to tabulation, can someone help me\\n```class Solution {\\npublic:\\n    int sumT;\\n    int solve(int idx, int sum, int target, vector<int> &arr, int n, map<pair<int,int>, int> &dp)\\n    {\\n        if(idx==n){\\n            if(sum == target) return 1;\\n            return 0;\\n        }\\n\\n        if(dp.count({idx, sum}) > 0)\\n        return dp[{idx, sum}];\\n\\n        int pos = solve(idx+1, sum+arr[idx], target, arr,n,dp);\\n        int neg = solve(idx+1, sum-arr[idx], target, arr,n, dp);\\n        dp[{idx, sum}] = (pos + neg); \\n        return dp[{idx, sum}];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(),sum=0;\\n        sumT=accumulate(nums.begin(), nums.end(), 0);\\n        map<pair<int, int>, int> dp;\\n        return solve(0,sum,target,nums,n, dp);\\n    }\\n};```"
                    },
                    {
                        "username": "Seemon2000",
                        "content": "check if the value is greater than -1 a 0 can be valid case for that option\\nif(dp.count({idx, sum}) > 0)"
                    },
                    {
                        "username": "SG-C",
                        "content": "They should write it Clearly that \" You have to use all element in nums array\" "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n\\n    int s1(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans -nums[i];\\n        return ans;\\n    }\\n    int s2(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans + nums[i];\\n        return ans;\\n    }\\n\\n    public:\\n\\nint findTargetSumWays(vector<int>&nums,int S){ \\n\\n    int minsum = s1(nums);\\n    int maxsum= s2(nums);\\n\\n    if(S>maxsum || S<minsum) return 0;\\n\\n    int r = nums.size();\\n    int c = maxsum - minsum+1;\\n\\n    int** dp = new int*[r];\\n\\n    for(int i=0;i<r;i++){\\n        dp[i] = new int[c];\\n    }\\n\\n    for(int i=0;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            dp[i][j]=0;\\n        }\\n    }\\n    //initlize first row\\n\\n    for(int i=0;i<c;i++){\\n        \\n        bool op1 = (i+minsum) == nums[0];\\n        bool op2 = (i+minsum) == (-1)*nums[0];\\n\\n        if(op1) dp[0][i]+=1;\\n        if(op2) dp[0][i]+=1;\\n    }\\n\\n    //build rest of matrix\\n\\n    for(int i=1;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            int a1 = (j-nums[i]>=0)?dp[i-1][j-nums[i]]:0;\\n            int a2 = (j+nums[i]< c)?dp[i-1][j+nums[i]]:0;\\n\\n            dp[i][j] = a1+a2;\\n        }\\n    }\\n\\n    return dp[r-1][S-minsum];\\n}\\n};"
                    },
                    {
                        "username": "VivekAbstract",
                        "content": "Dont post solution in discussion bro"
                    }
                ]
            },
            {
                "id": 1775100,
                "content": [
                    {
                        "username": "lingarajbal",
                        "content": "/**\\n *  Lets first see the concept here.\\n *  The question asked to assign symbols to each interger.In other words we have to \\n *  divide the whole array into two sub sets having sum S1 and S2. S1-S2=S. Lets draw some\\n *  relation here.\\n *  S1 + S2 = TotalSum(sum of all array elements) [ Equation 1]\\n *  S1 - S2 = S (asked in the question)           [Equation  2]\\n *  if we add Equation 1 and 2 we will have. S1 = (TotalSum + S)/2\\n *  Now the number of sub set of having sum S1 should be the answer to the question.\\n * \\n **/"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "anyone has coded this up? please share! Thanks"
                    },
                    {
                        "username": "aman3091",
                        "content": "i have used same approach still getting error kindly help \\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int s1=(target+sum)/2;\\n        int n=nums.size();\\n        if(n==1){\\n            if(target!=nums[0]&&target!=-1*nums[0]){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n      int t[n+1][s1+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<s1+1;j++){\\n                if(i==0){\\n                    t[i][j]=0;\\n                }\\n                if(j==0){\\n                    t[i][j]=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s1+1;j++){\\n                if(nums[i-1]<=j){\\n                    t[i][j]=t[i-1][j-nums[i-1]] + t[i-1][j];\\n                }\\n                else{\\n                    t[i][j]=t[i-1][j];\\n                }\\n            }\\n        }\\n        return t[n][s1];\\n    }\\n};"
                    },
                    {
                        "username": "kaiyikang",
                        "content": "The idea comes from [this post](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/discuss/97334/Java-(15-ms)-C++-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanation) and this graph shows my personal understanding of the DP solution.\\n![image](https://assets.leetcode.com/users/kaiyikang/image_1569211092.png)\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "from where did you get this dp pic can you please share that book or post"
                    },
                    {
                        "username": "ruokay",
                        "content": "even recursion got accepted :)"
                    },
                    {
                        "username": "ElayMarco",
                        "content": "No explanation as to why something works, or even what you are doing. It's not helpful to most people."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "For those friends who are worrying about negative target, here\\'s a Hint: That the number of ways to get -x is same as number of ways to get +x (just switch every sign in array). I cant believe even the editorial solution doesn\\'t get this right and solves unnecessarily for `[-x , x]` whereas `[0, x]` is sufficient!!"
                    },
                    {
                        "username": "r0hitm",
                        "content": "I think question should have been mentioned that we have to use all the elements of array. if i am wrong please correct me."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Is it only me who did get the recurrence relation but unable to implement DP? "
                    },
                    {
                        "username": "yogeshpractice",
                        "content": "I\\'m not able to convert my meoization to tabulation, can someone help me\\n```class Solution {\\npublic:\\n    int sumT;\\n    int solve(int idx, int sum, int target, vector<int> &arr, int n, map<pair<int,int>, int> &dp)\\n    {\\n        if(idx==n){\\n            if(sum == target) return 1;\\n            return 0;\\n        }\\n\\n        if(dp.count({idx, sum}) > 0)\\n        return dp[{idx, sum}];\\n\\n        int pos = solve(idx+1, sum+arr[idx], target, arr,n,dp);\\n        int neg = solve(idx+1, sum-arr[idx], target, arr,n, dp);\\n        dp[{idx, sum}] = (pos + neg); \\n        return dp[{idx, sum}];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(),sum=0;\\n        sumT=accumulate(nums.begin(), nums.end(), 0);\\n        map<pair<int, int>, int> dp;\\n        return solve(0,sum,target,nums,n, dp);\\n    }\\n};```"
                    },
                    {
                        "username": "Seemon2000",
                        "content": "check if the value is greater than -1 a 0 can be valid case for that option\\nif(dp.count({idx, sum}) > 0)"
                    },
                    {
                        "username": "SG-C",
                        "content": "They should write it Clearly that \" You have to use all element in nums array\" "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n\\n    int s1(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans -nums[i];\\n        return ans;\\n    }\\n    int s2(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans + nums[i];\\n        return ans;\\n    }\\n\\n    public:\\n\\nint findTargetSumWays(vector<int>&nums,int S){ \\n\\n    int minsum = s1(nums);\\n    int maxsum= s2(nums);\\n\\n    if(S>maxsum || S<minsum) return 0;\\n\\n    int r = nums.size();\\n    int c = maxsum - minsum+1;\\n\\n    int** dp = new int*[r];\\n\\n    for(int i=0;i<r;i++){\\n        dp[i] = new int[c];\\n    }\\n\\n    for(int i=0;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            dp[i][j]=0;\\n        }\\n    }\\n    //initlize first row\\n\\n    for(int i=0;i<c;i++){\\n        \\n        bool op1 = (i+minsum) == nums[0];\\n        bool op2 = (i+minsum) == (-1)*nums[0];\\n\\n        if(op1) dp[0][i]+=1;\\n        if(op2) dp[0][i]+=1;\\n    }\\n\\n    //build rest of matrix\\n\\n    for(int i=1;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            int a1 = (j-nums[i]>=0)?dp[i-1][j-nums[i]]:0;\\n            int a2 = (j+nums[i]< c)?dp[i-1][j+nums[i]]:0;\\n\\n            dp[i][j] = a1+a2;\\n        }\\n    }\\n\\n    return dp[r-1][S-minsum];\\n}\\n};"
                    },
                    {
                        "username": "VivekAbstract",
                        "content": "Dont post solution in discussion bro"
                    }
                ]
            },
            {
                "id": 1994764,
                "content": [
                    {
                        "username": "lingarajbal",
                        "content": "/**\\n *  Lets first see the concept here.\\n *  The question asked to assign symbols to each interger.In other words we have to \\n *  divide the whole array into two sub sets having sum S1 and S2. S1-S2=S. Lets draw some\\n *  relation here.\\n *  S1 + S2 = TotalSum(sum of all array elements) [ Equation 1]\\n *  S1 - S2 = S (asked in the question)           [Equation  2]\\n *  if we add Equation 1 and 2 we will have. S1 = (TotalSum + S)/2\\n *  Now the number of sub set of having sum S1 should be the answer to the question.\\n * \\n **/"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "anyone has coded this up? please share! Thanks"
                    },
                    {
                        "username": "aman3091",
                        "content": "i have used same approach still getting error kindly help \\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int s1=(target+sum)/2;\\n        int n=nums.size();\\n        if(n==1){\\n            if(target!=nums[0]&&target!=-1*nums[0]){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n      int t[n+1][s1+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<s1+1;j++){\\n                if(i==0){\\n                    t[i][j]=0;\\n                }\\n                if(j==0){\\n                    t[i][j]=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s1+1;j++){\\n                if(nums[i-1]<=j){\\n                    t[i][j]=t[i-1][j-nums[i-1]] + t[i-1][j];\\n                }\\n                else{\\n                    t[i][j]=t[i-1][j];\\n                }\\n            }\\n        }\\n        return t[n][s1];\\n    }\\n};"
                    },
                    {
                        "username": "kaiyikang",
                        "content": "The idea comes from [this post](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/discuss/97334/Java-(15-ms)-C++-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanation) and this graph shows my personal understanding of the DP solution.\\n![image](https://assets.leetcode.com/users/kaiyikang/image_1569211092.png)\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "from where did you get this dp pic can you please share that book or post"
                    },
                    {
                        "username": "ruokay",
                        "content": "even recursion got accepted :)"
                    },
                    {
                        "username": "ElayMarco",
                        "content": "No explanation as to why something works, or even what you are doing. It's not helpful to most people."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "For those friends who are worrying about negative target, here\\'s a Hint: That the number of ways to get -x is same as number of ways to get +x (just switch every sign in array). I cant believe even the editorial solution doesn\\'t get this right and solves unnecessarily for `[-x , x]` whereas `[0, x]` is sufficient!!"
                    },
                    {
                        "username": "r0hitm",
                        "content": "I think question should have been mentioned that we have to use all the elements of array. if i am wrong please correct me."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Is it only me who did get the recurrence relation but unable to implement DP? "
                    },
                    {
                        "username": "yogeshpractice",
                        "content": "I\\'m not able to convert my meoization to tabulation, can someone help me\\n```class Solution {\\npublic:\\n    int sumT;\\n    int solve(int idx, int sum, int target, vector<int> &arr, int n, map<pair<int,int>, int> &dp)\\n    {\\n        if(idx==n){\\n            if(sum == target) return 1;\\n            return 0;\\n        }\\n\\n        if(dp.count({idx, sum}) > 0)\\n        return dp[{idx, sum}];\\n\\n        int pos = solve(idx+1, sum+arr[idx], target, arr,n,dp);\\n        int neg = solve(idx+1, sum-arr[idx], target, arr,n, dp);\\n        dp[{idx, sum}] = (pos + neg); \\n        return dp[{idx, sum}];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(),sum=0;\\n        sumT=accumulate(nums.begin(), nums.end(), 0);\\n        map<pair<int, int>, int> dp;\\n        return solve(0,sum,target,nums,n, dp);\\n    }\\n};```"
                    },
                    {
                        "username": "Seemon2000",
                        "content": "check if the value is greater than -1 a 0 can be valid case for that option\\nif(dp.count({idx, sum}) > 0)"
                    },
                    {
                        "username": "SG-C",
                        "content": "They should write it Clearly that \" You have to use all element in nums array\" "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n\\n    int s1(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans -nums[i];\\n        return ans;\\n    }\\n    int s2(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans + nums[i];\\n        return ans;\\n    }\\n\\n    public:\\n\\nint findTargetSumWays(vector<int>&nums,int S){ \\n\\n    int minsum = s1(nums);\\n    int maxsum= s2(nums);\\n\\n    if(S>maxsum || S<minsum) return 0;\\n\\n    int r = nums.size();\\n    int c = maxsum - minsum+1;\\n\\n    int** dp = new int*[r];\\n\\n    for(int i=0;i<r;i++){\\n        dp[i] = new int[c];\\n    }\\n\\n    for(int i=0;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            dp[i][j]=0;\\n        }\\n    }\\n    //initlize first row\\n\\n    for(int i=0;i<c;i++){\\n        \\n        bool op1 = (i+minsum) == nums[0];\\n        bool op2 = (i+minsum) == (-1)*nums[0];\\n\\n        if(op1) dp[0][i]+=1;\\n        if(op2) dp[0][i]+=1;\\n    }\\n\\n    //build rest of matrix\\n\\n    for(int i=1;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            int a1 = (j-nums[i]>=0)?dp[i-1][j-nums[i]]:0;\\n            int a2 = (j+nums[i]< c)?dp[i-1][j+nums[i]]:0;\\n\\n            dp[i][j] = a1+a2;\\n        }\\n    }\\n\\n    return dp[r-1][S-minsum];\\n}\\n};"
                    },
                    {
                        "username": "VivekAbstract",
                        "content": "Dont post solution in discussion bro"
                    }
                ]
            },
            {
                "id": 1810973,
                "content": [
                    {
                        "username": "lingarajbal",
                        "content": "/**\\n *  Lets first see the concept here.\\n *  The question asked to assign symbols to each interger.In other words we have to \\n *  divide the whole array into two sub sets having sum S1 and S2. S1-S2=S. Lets draw some\\n *  relation here.\\n *  S1 + S2 = TotalSum(sum of all array elements) [ Equation 1]\\n *  S1 - S2 = S (asked in the question)           [Equation  2]\\n *  if we add Equation 1 and 2 we will have. S1 = (TotalSum + S)/2\\n *  Now the number of sub set of having sum S1 should be the answer to the question.\\n * \\n **/"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "anyone has coded this up? please share! Thanks"
                    },
                    {
                        "username": "aman3091",
                        "content": "i have used same approach still getting error kindly help \\n\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int s1=(target+sum)/2;\\n        int n=nums.size();\\n        if(n==1){\\n            if(target!=nums[0]&&target!=-1*nums[0]){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n      int t[n+1][s1+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<s1+1;j++){\\n                if(i==0){\\n                    t[i][j]=0;\\n                }\\n                if(j==0){\\n                    t[i][j]=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<s1+1;j++){\\n                if(nums[i-1]<=j){\\n                    t[i][j]=t[i-1][j-nums[i-1]] + t[i-1][j];\\n                }\\n                else{\\n                    t[i][j]=t[i-1][j];\\n                }\\n            }\\n        }\\n        return t[n][s1];\\n    }\\n};"
                    },
                    {
                        "username": "kaiyikang",
                        "content": "The idea comes from [this post](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1389/discuss/97334/Java-(15-ms)-C++-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanation) and this graph shows my personal understanding of the DP solution.\\n![image](https://assets.leetcode.com/users/kaiyikang/image_1569211092.png)\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "from where did you get this dp pic can you please share that book or post"
                    },
                    {
                        "username": "ruokay",
                        "content": "even recursion got accepted :)"
                    },
                    {
                        "username": "ElayMarco",
                        "content": "No explanation as to why something works, or even what you are doing. It's not helpful to most people."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "For those friends who are worrying about negative target, here\\'s a Hint: That the number of ways to get -x is same as number of ways to get +x (just switch every sign in array). I cant believe even the editorial solution doesn\\'t get this right and solves unnecessarily for `[-x , x]` whereas `[0, x]` is sufficient!!"
                    },
                    {
                        "username": "r0hitm",
                        "content": "I think question should have been mentioned that we have to use all the elements of array. if i am wrong please correct me."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Is it only me who did get the recurrence relation but unable to implement DP? "
                    },
                    {
                        "username": "yogeshpractice",
                        "content": "I\\'m not able to convert my meoization to tabulation, can someone help me\\n```class Solution {\\npublic:\\n    int sumT;\\n    int solve(int idx, int sum, int target, vector<int> &arr, int n, map<pair<int,int>, int> &dp)\\n    {\\n        if(idx==n){\\n            if(sum == target) return 1;\\n            return 0;\\n        }\\n\\n        if(dp.count({idx, sum}) > 0)\\n        return dp[{idx, sum}];\\n\\n        int pos = solve(idx+1, sum+arr[idx], target, arr,n,dp);\\n        int neg = solve(idx+1, sum-arr[idx], target, arr,n, dp);\\n        dp[{idx, sum}] = (pos + neg); \\n        return dp[{idx, sum}];\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n = nums.size(),sum=0;\\n        sumT=accumulate(nums.begin(), nums.end(), 0);\\n        map<pair<int, int>, int> dp;\\n        return solve(0,sum,target,nums,n, dp);\\n    }\\n};```"
                    },
                    {
                        "username": "Seemon2000",
                        "content": "check if the value is greater than -1 a 0 can be valid case for that option\\nif(dp.count({idx, sum}) > 0)"
                    },
                    {
                        "username": "SG-C",
                        "content": "They should write it Clearly that \" You have to use all element in nums array\" "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n\\n    int s1(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans -nums[i];\\n        return ans;\\n    }\\n    int s2(vector<int>nums){\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++) ans= ans + nums[i];\\n        return ans;\\n    }\\n\\n    public:\\n\\nint findTargetSumWays(vector<int>&nums,int S){ \\n\\n    int minsum = s1(nums);\\n    int maxsum= s2(nums);\\n\\n    if(S>maxsum || S<minsum) return 0;\\n\\n    int r = nums.size();\\n    int c = maxsum - minsum+1;\\n\\n    int** dp = new int*[r];\\n\\n    for(int i=0;i<r;i++){\\n        dp[i] = new int[c];\\n    }\\n\\n    for(int i=0;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            dp[i][j]=0;\\n        }\\n    }\\n    //initlize first row\\n\\n    for(int i=0;i<c;i++){\\n        \\n        bool op1 = (i+minsum) == nums[0];\\n        bool op2 = (i+minsum) == (-1)*nums[0];\\n\\n        if(op1) dp[0][i]+=1;\\n        if(op2) dp[0][i]+=1;\\n    }\\n\\n    //build rest of matrix\\n\\n    for(int i=1;i<r;i++){\\n        for(int j=0;j<c;j++){\\n            int a1 = (j-nums[i]>=0)?dp[i-1][j-nums[i]]:0;\\n            int a2 = (j+nums[i]< c)?dp[i-1][j+nums[i]]:0;\\n\\n            dp[i][j] = a1+a2;\\n        }\\n    }\\n\\n    return dp[r-1][S-minsum];\\n}\\n};"
                    },
                    {
                        "username": "VivekAbstract",
                        "content": "Dont post solution in discussion bro"
                    }
                ]
            },
            {
                "id": 1629395,
                "content": [
                    {
                        "username": "pawan_077",
                        "content": "Easiest C++ Solution with 96% faster with explanation\\nApproach:\\nThere are only two choices for every element it can be added to the sum or can be subtracted from the sum.\\nThus we can think the problem as partitioning the array in two subsets s1 and s2  such that abs(s1 - s2) = target.\\nSo we have two equations:-\\nsum(s1) + sum(s2) = sum(array)\\nsum(s1) - sum(s2) = target\\nHere s1 set contains all the elements which are having \\'+\\' sign and s2 set contains elements having \\'-\\' sign.\\n\\nso after adding both the equations we get:\\nsum(s1) = (sum(array) + target)/2\\nNow we have to find only count of subsets having sum = s1\\nSo the question reduced to count of number of subsets with a given sum.\\nHere is the code for finding number of subsets with given sum.\\n\\nExtreme case when sum + diff  becomes odd.\\nThen answer is not possible ...try various examples by yourself\\nEg [1,3,2,1] or [1,1,3,2] or [3,1,2,1] or any other example where sum=7 and given difference=2 (7+2=9)\\nyou cannot divide array into 2 proper subsets if the sum of the elements of array + difference is odd\\nNow try [3,2,1,1] where sum=7 and diff=3 now sum + diff=7+3=even so now answer can exist\\nans: [3,2] and [1,1]\\n5 - 2 = 3\\n5 + 2 = 7\\n\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        for(int it: nums)\\n            sum += it;\\n        if((sum+target)%2==1 or abs(target)>sum) // abs(target)>sum for some testcase like sum = 100 and target  = -200 here no solution exists\\n            return 0;\\n        sum = (sum + target)/2;\\n        int t[nums.size()+1][sum+1];\\n        for (int i = 0; i < sum+1; i++) t[0][i] = 0;\\n        for (int i = 0; i < nums.size()+1; i++) t[i][0] = 1;\\n        for (int i = 1; i < nums.size()+1; i++){\\n            for (int j = 0; j < sum+1; j++){\\n                if(nums[i-1]<=j)\\n                    t[i][j] = t[i-1][j] + t[i-1][j-nums[i-1]];\\n                else\\n                    t[i][j] = t[i-1][j];\\n            }\\n        }\\n        return t[nums.size()][sum];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KiranR",
                        "content": "My code worked but can someone explain why the division by 2 is needed?\\n\\n```class Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        \\n        n = len(nums)\\n\\n        @lru_cache(maxsize=None)\\n        def recur(ind, cur, sign):\\n            if ind == n:\\n                if cur == target:\\n                    # print(\"Here\")\\n                    return 1\\n                return 0\\n        \\n            cur_elem = nums[ind] if sign == \"+\" else -nums[ind]\\n            n1 = recur(ind+1, cur + cur_elem, \"+\")\\n            n2 = recur(ind+1, cur + cur_elem, \"-\")\\n            return n1 + n2\\n        \\n        \\n        \\n        return (recur(0, 0, \"+\") + recur(0, 0, \"-\")) // 2\\n```\\n"
                    },
                    {
                        "username": "shivanigam",
                        "content": "\"Sole Recurrence Relation is feeling Happy now.\""
                    },
                    {
                        "username": "apgupta3003",
                        "content": "what is happening? even an unmemoized code submitted successfully!\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "subset sum"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Loved this problem. Enjoyed solving it!"
                    },
                    {
                        "username": "jonathankhawbung",
                        "content": "yo man\\n"
                    },
                    {
                        "username": "devC_B",
                        "content": "can anyone tell me how to handel the negative target value without using any map , only using 2D vector ?"
                    },
                    {
                        "username": "layyy",
                        "content": "try partition equal subset sum before trying this"
                    },
                    {
                        "username": "aiden99",
                        "content": "I try to solve it using the Backtracking algorithm, but if input nums=[1,1,1,1], target=3, it outputs 3, with the found expression: \"+1+1+1\", \"+1 +1+1\", \"+1+1+1\". It is weird to me because there is indeed a condition check that `idx == len(nums)`.\\n\\n```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        ans = 0\\n\\n        def backtrack(idx, cnt):\\n            nonlocal ans\\n            if cnt == target and idx == len(nums):\\n                ans += 1\\n                return\\n\\n            for i in range(idx, len(nums)):\\n                # use \"+\"\\n                cnt += nums[i]\\n                backtrack(i+1, cnt)\\n                cnt -= nums[i]\\n\\n                # use \"-\"\\n                cnt -= nums[i]\\n                backtrack(i+1, cnt)\\n                cnt += nums[i]\\n\\n\\n        backtrack(0, 0)\\n        return ans\\n```"
                    },
                    {
                        "username": "ktanwar",
                        "content": "You need to check at least after each time you add or subtract. You are checking an index further down if not. So you hit the target ( which technically you cant because the target is less than sum(nums) so it should be 0 and you end up hitting 3 times ( ie, 1 + 1 + 1 each time that decision is evaluated.)\\n\\n\\nHere is simpler recursion that would have the same issue if you  put the check in the base case:\\n\\n```\\n    def findTargetSumWays_crappy_bruteForce(self, nums: List[int], target: int) -> int:\\n\\n        ways = 0\\n        # traverse passing current running sum,\\n        # and index in nums,\\n        # and sign\\n        def rec_trav(v,i,s):\\n            nonlocal ways\\n\\n            # bail when index is already at last\\n            # element - its already been accounted\\n            if i == 0:\\n                return 0\\n\\n            # current sum is \\n            # running sum + (sign * elem at next index)\\n            t_sum = v + (s * nums[i-1])\\n\\n            # if we are at last index and,\\n            # current sum is target,\\n            # we have found 1 possible way\\n            if t_sum == target and i==1:\\n                ways += 1\\n                # dont need to call further\\n                return\\n\\n            # continue to traverse down the list with,\\n            # either possiblity\\n            rec_trav(t_sum,i-1,1)\\n            rec_trav(t_sum,i-1,-1)\\n\\n        rec_trav(0,len(nums),1)\\n        rec_trav(0,len(nums),-1)\\n        return ways\\n```\\n"
                    }
                ]
            },
            {
                "id": 2066165,
                "content": [
                    {
                        "username": "pawan_077",
                        "content": "Easiest C++ Solution with 96% faster with explanation\\nApproach:\\nThere are only two choices for every element it can be added to the sum or can be subtracted from the sum.\\nThus we can think the problem as partitioning the array in two subsets s1 and s2  such that abs(s1 - s2) = target.\\nSo we have two equations:-\\nsum(s1) + sum(s2) = sum(array)\\nsum(s1) - sum(s2) = target\\nHere s1 set contains all the elements which are having \\'+\\' sign and s2 set contains elements having \\'-\\' sign.\\n\\nso after adding both the equations we get:\\nsum(s1) = (sum(array) + target)/2\\nNow we have to find only count of subsets having sum = s1\\nSo the question reduced to count of number of subsets with a given sum.\\nHere is the code for finding number of subsets with given sum.\\n\\nExtreme case when sum + diff  becomes odd.\\nThen answer is not possible ...try various examples by yourself\\nEg [1,3,2,1] or [1,1,3,2] or [3,1,2,1] or any other example where sum=7 and given difference=2 (7+2=9)\\nyou cannot divide array into 2 proper subsets if the sum of the elements of array + difference is odd\\nNow try [3,2,1,1] where sum=7 and diff=3 now sum + diff=7+3=even so now answer can exist\\nans: [3,2] and [1,1]\\n5 - 2 = 3\\n5 + 2 = 7\\n\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        for(int it: nums)\\n            sum += it;\\n        if((sum+target)%2==1 or abs(target)>sum) // abs(target)>sum for some testcase like sum = 100 and target  = -200 here no solution exists\\n            return 0;\\n        sum = (sum + target)/2;\\n        int t[nums.size()+1][sum+1];\\n        for (int i = 0; i < sum+1; i++) t[0][i] = 0;\\n        for (int i = 0; i < nums.size()+1; i++) t[i][0] = 1;\\n        for (int i = 1; i < nums.size()+1; i++){\\n            for (int j = 0; j < sum+1; j++){\\n                if(nums[i-1]<=j)\\n                    t[i][j] = t[i-1][j] + t[i-1][j-nums[i-1]];\\n                else\\n                    t[i][j] = t[i-1][j];\\n            }\\n        }\\n        return t[nums.size()][sum];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KiranR",
                        "content": "My code worked but can someone explain why the division by 2 is needed?\\n\\n```class Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        \\n        n = len(nums)\\n\\n        @lru_cache(maxsize=None)\\n        def recur(ind, cur, sign):\\n            if ind == n:\\n                if cur == target:\\n                    # print(\"Here\")\\n                    return 1\\n                return 0\\n        \\n            cur_elem = nums[ind] if sign == \"+\" else -nums[ind]\\n            n1 = recur(ind+1, cur + cur_elem, \"+\")\\n            n2 = recur(ind+1, cur + cur_elem, \"-\")\\n            return n1 + n2\\n        \\n        \\n        \\n        return (recur(0, 0, \"+\") + recur(0, 0, \"-\")) // 2\\n```\\n"
                    },
                    {
                        "username": "shivanigam",
                        "content": "\"Sole Recurrence Relation is feeling Happy now.\""
                    },
                    {
                        "username": "apgupta3003",
                        "content": "what is happening? even an unmemoized code submitted successfully!\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "subset sum"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Loved this problem. Enjoyed solving it!"
                    },
                    {
                        "username": "jonathankhawbung",
                        "content": "yo man\\n"
                    },
                    {
                        "username": "devC_B",
                        "content": "can anyone tell me how to handel the negative target value without using any map , only using 2D vector ?"
                    },
                    {
                        "username": "layyy",
                        "content": "try partition equal subset sum before trying this"
                    },
                    {
                        "username": "aiden99",
                        "content": "I try to solve it using the Backtracking algorithm, but if input nums=[1,1,1,1], target=3, it outputs 3, with the found expression: \"+1+1+1\", \"+1 +1+1\", \"+1+1+1\". It is weird to me because there is indeed a condition check that `idx == len(nums)`.\\n\\n```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        ans = 0\\n\\n        def backtrack(idx, cnt):\\n            nonlocal ans\\n            if cnt == target and idx == len(nums):\\n                ans += 1\\n                return\\n\\n            for i in range(idx, len(nums)):\\n                # use \"+\"\\n                cnt += nums[i]\\n                backtrack(i+1, cnt)\\n                cnt -= nums[i]\\n\\n                # use \"-\"\\n                cnt -= nums[i]\\n                backtrack(i+1, cnt)\\n                cnt += nums[i]\\n\\n\\n        backtrack(0, 0)\\n        return ans\\n```"
                    },
                    {
                        "username": "ktanwar",
                        "content": "You need to check at least after each time you add or subtract. You are checking an index further down if not. So you hit the target ( which technically you cant because the target is less than sum(nums) so it should be 0 and you end up hitting 3 times ( ie, 1 + 1 + 1 each time that decision is evaluated.)\\n\\n\\nHere is simpler recursion that would have the same issue if you  put the check in the base case:\\n\\n```\\n    def findTargetSumWays_crappy_bruteForce(self, nums: List[int], target: int) -> int:\\n\\n        ways = 0\\n        # traverse passing current running sum,\\n        # and index in nums,\\n        # and sign\\n        def rec_trav(v,i,s):\\n            nonlocal ways\\n\\n            # bail when index is already at last\\n            # element - its already been accounted\\n            if i == 0:\\n                return 0\\n\\n            # current sum is \\n            # running sum + (sign * elem at next index)\\n            t_sum = v + (s * nums[i-1])\\n\\n            # if we are at last index and,\\n            # current sum is target,\\n            # we have found 1 possible way\\n            if t_sum == target and i==1:\\n                ways += 1\\n                # dont need to call further\\n                return\\n\\n            # continue to traverse down the list with,\\n            # either possiblity\\n            rec_trav(t_sum,i-1,1)\\n            rec_trav(t_sum,i-1,-1)\\n\\n        rec_trav(0,len(nums),1)\\n        rec_trav(0,len(nums),-1)\\n        return ways\\n```\\n"
                    }
                ]
            },
            {
                "id": 2044810,
                "content": [
                    {
                        "username": "pawan_077",
                        "content": "Easiest C++ Solution with 96% faster with explanation\\nApproach:\\nThere are only two choices for every element it can be added to the sum or can be subtracted from the sum.\\nThus we can think the problem as partitioning the array in two subsets s1 and s2  such that abs(s1 - s2) = target.\\nSo we have two equations:-\\nsum(s1) + sum(s2) = sum(array)\\nsum(s1) - sum(s2) = target\\nHere s1 set contains all the elements which are having \\'+\\' sign and s2 set contains elements having \\'-\\' sign.\\n\\nso after adding both the equations we get:\\nsum(s1) = (sum(array) + target)/2\\nNow we have to find only count of subsets having sum = s1\\nSo the question reduced to count of number of subsets with a given sum.\\nHere is the code for finding number of subsets with given sum.\\n\\nExtreme case when sum + diff  becomes odd.\\nThen answer is not possible ...try various examples by yourself\\nEg [1,3,2,1] or [1,1,3,2] or [3,1,2,1] or any other example where sum=7 and given difference=2 (7+2=9)\\nyou cannot divide array into 2 proper subsets if the sum of the elements of array + difference is odd\\nNow try [3,2,1,1] where sum=7 and diff=3 now sum + diff=7+3=even so now answer can exist\\nans: [3,2] and [1,1]\\n5 - 2 = 3\\n5 + 2 = 7\\n\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        for(int it: nums)\\n            sum += it;\\n        if((sum+target)%2==1 or abs(target)>sum) // abs(target)>sum for some testcase like sum = 100 and target  = -200 here no solution exists\\n            return 0;\\n        sum = (sum + target)/2;\\n        int t[nums.size()+1][sum+1];\\n        for (int i = 0; i < sum+1; i++) t[0][i] = 0;\\n        for (int i = 0; i < nums.size()+1; i++) t[i][0] = 1;\\n        for (int i = 1; i < nums.size()+1; i++){\\n            for (int j = 0; j < sum+1; j++){\\n                if(nums[i-1]<=j)\\n                    t[i][j] = t[i-1][j] + t[i-1][j-nums[i-1]];\\n                else\\n                    t[i][j] = t[i-1][j];\\n            }\\n        }\\n        return t[nums.size()][sum];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KiranR",
                        "content": "My code worked but can someone explain why the division by 2 is needed?\\n\\n```class Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        \\n        n = len(nums)\\n\\n        @lru_cache(maxsize=None)\\n        def recur(ind, cur, sign):\\n            if ind == n:\\n                if cur == target:\\n                    # print(\"Here\")\\n                    return 1\\n                return 0\\n        \\n            cur_elem = nums[ind] if sign == \"+\" else -nums[ind]\\n            n1 = recur(ind+1, cur + cur_elem, \"+\")\\n            n2 = recur(ind+1, cur + cur_elem, \"-\")\\n            return n1 + n2\\n        \\n        \\n        \\n        return (recur(0, 0, \"+\") + recur(0, 0, \"-\")) // 2\\n```\\n"
                    },
                    {
                        "username": "shivanigam",
                        "content": "\"Sole Recurrence Relation is feeling Happy now.\""
                    },
                    {
                        "username": "apgupta3003",
                        "content": "what is happening? even an unmemoized code submitted successfully!\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "subset sum"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Loved this problem. Enjoyed solving it!"
                    },
                    {
                        "username": "jonathankhawbung",
                        "content": "yo man\\n"
                    },
                    {
                        "username": "devC_B",
                        "content": "can anyone tell me how to handel the negative target value without using any map , only using 2D vector ?"
                    },
                    {
                        "username": "layyy",
                        "content": "try partition equal subset sum before trying this"
                    },
                    {
                        "username": "aiden99",
                        "content": "I try to solve it using the Backtracking algorithm, but if input nums=[1,1,1,1], target=3, it outputs 3, with the found expression: \"+1+1+1\", \"+1 +1+1\", \"+1+1+1\". It is weird to me because there is indeed a condition check that `idx == len(nums)`.\\n\\n```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        ans = 0\\n\\n        def backtrack(idx, cnt):\\n            nonlocal ans\\n            if cnt == target and idx == len(nums):\\n                ans += 1\\n                return\\n\\n            for i in range(idx, len(nums)):\\n                # use \"+\"\\n                cnt += nums[i]\\n                backtrack(i+1, cnt)\\n                cnt -= nums[i]\\n\\n                # use \"-\"\\n                cnt -= nums[i]\\n                backtrack(i+1, cnt)\\n                cnt += nums[i]\\n\\n\\n        backtrack(0, 0)\\n        return ans\\n```"
                    },
                    {
                        "username": "ktanwar",
                        "content": "You need to check at least after each time you add or subtract. You are checking an index further down if not. So you hit the target ( which technically you cant because the target is less than sum(nums) so it should be 0 and you end up hitting 3 times ( ie, 1 + 1 + 1 each time that decision is evaluated.)\\n\\n\\nHere is simpler recursion that would have the same issue if you  put the check in the base case:\\n\\n```\\n    def findTargetSumWays_crappy_bruteForce(self, nums: List[int], target: int) -> int:\\n\\n        ways = 0\\n        # traverse passing current running sum,\\n        # and index in nums,\\n        # and sign\\n        def rec_trav(v,i,s):\\n            nonlocal ways\\n\\n            # bail when index is already at last\\n            # element - its already been accounted\\n            if i == 0:\\n                return 0\\n\\n            # current sum is \\n            # running sum + (sign * elem at next index)\\n            t_sum = v + (s * nums[i-1])\\n\\n            # if we are at last index and,\\n            # current sum is target,\\n            # we have found 1 possible way\\n            if t_sum == target and i==1:\\n                ways += 1\\n                # dont need to call further\\n                return\\n\\n            # continue to traverse down the list with,\\n            # either possiblity\\n            rec_trav(t_sum,i-1,1)\\n            rec_trav(t_sum,i-1,-1)\\n\\n        rec_trav(0,len(nums),1)\\n        rec_trav(0,len(nums),-1)\\n        return ways\\n```\\n"
                    }
                ]
            },
            {
                "id": 2019259,
                "content": [
                    {
                        "username": "pawan_077",
                        "content": "Easiest C++ Solution with 96% faster with explanation\\nApproach:\\nThere are only two choices for every element it can be added to the sum or can be subtracted from the sum.\\nThus we can think the problem as partitioning the array in two subsets s1 and s2  such that abs(s1 - s2) = target.\\nSo we have two equations:-\\nsum(s1) + sum(s2) = sum(array)\\nsum(s1) - sum(s2) = target\\nHere s1 set contains all the elements which are having \\'+\\' sign and s2 set contains elements having \\'-\\' sign.\\n\\nso after adding both the equations we get:\\nsum(s1) = (sum(array) + target)/2\\nNow we have to find only count of subsets having sum = s1\\nSo the question reduced to count of number of subsets with a given sum.\\nHere is the code for finding number of subsets with given sum.\\n\\nExtreme case when sum + diff  becomes odd.\\nThen answer is not possible ...try various examples by yourself\\nEg [1,3,2,1] or [1,1,3,2] or [3,1,2,1] or any other example where sum=7 and given difference=2 (7+2=9)\\nyou cannot divide array into 2 proper subsets if the sum of the elements of array + difference is odd\\nNow try [3,2,1,1] where sum=7 and diff=3 now sum + diff=7+3=even so now answer can exist\\nans: [3,2] and [1,1]\\n5 - 2 = 3\\n5 + 2 = 7\\n\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        for(int it: nums)\\n            sum += it;\\n        if((sum+target)%2==1 or abs(target)>sum) // abs(target)>sum for some testcase like sum = 100 and target  = -200 here no solution exists\\n            return 0;\\n        sum = (sum + target)/2;\\n        int t[nums.size()+1][sum+1];\\n        for (int i = 0; i < sum+1; i++) t[0][i] = 0;\\n        for (int i = 0; i < nums.size()+1; i++) t[i][0] = 1;\\n        for (int i = 1; i < nums.size()+1; i++){\\n            for (int j = 0; j < sum+1; j++){\\n                if(nums[i-1]<=j)\\n                    t[i][j] = t[i-1][j] + t[i-1][j-nums[i-1]];\\n                else\\n                    t[i][j] = t[i-1][j];\\n            }\\n        }\\n        return t[nums.size()][sum];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KiranR",
                        "content": "My code worked but can someone explain why the division by 2 is needed?\\n\\n```class Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        \\n        n = len(nums)\\n\\n        @lru_cache(maxsize=None)\\n        def recur(ind, cur, sign):\\n            if ind == n:\\n                if cur == target:\\n                    # print(\"Here\")\\n                    return 1\\n                return 0\\n        \\n            cur_elem = nums[ind] if sign == \"+\" else -nums[ind]\\n            n1 = recur(ind+1, cur + cur_elem, \"+\")\\n            n2 = recur(ind+1, cur + cur_elem, \"-\")\\n            return n1 + n2\\n        \\n        \\n        \\n        return (recur(0, 0, \"+\") + recur(0, 0, \"-\")) // 2\\n```\\n"
                    },
                    {
                        "username": "shivanigam",
                        "content": "\"Sole Recurrence Relation is feeling Happy now.\""
                    },
                    {
                        "username": "apgupta3003",
                        "content": "what is happening? even an unmemoized code submitted successfully!\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "subset sum"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Loved this problem. Enjoyed solving it!"
                    },
                    {
                        "username": "jonathankhawbung",
                        "content": "yo man\\n"
                    },
                    {
                        "username": "devC_B",
                        "content": "can anyone tell me how to handel the negative target value without using any map , only using 2D vector ?"
                    },
                    {
                        "username": "layyy",
                        "content": "try partition equal subset sum before trying this"
                    },
                    {
                        "username": "aiden99",
                        "content": "I try to solve it using the Backtracking algorithm, but if input nums=[1,1,1,1], target=3, it outputs 3, with the found expression: \"+1+1+1\", \"+1 +1+1\", \"+1+1+1\". It is weird to me because there is indeed a condition check that `idx == len(nums)`.\\n\\n```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        ans = 0\\n\\n        def backtrack(idx, cnt):\\n            nonlocal ans\\n            if cnt == target and idx == len(nums):\\n                ans += 1\\n                return\\n\\n            for i in range(idx, len(nums)):\\n                # use \"+\"\\n                cnt += nums[i]\\n                backtrack(i+1, cnt)\\n                cnt -= nums[i]\\n\\n                # use \"-\"\\n                cnt -= nums[i]\\n                backtrack(i+1, cnt)\\n                cnt += nums[i]\\n\\n\\n        backtrack(0, 0)\\n        return ans\\n```"
                    },
                    {
                        "username": "ktanwar",
                        "content": "You need to check at least after each time you add or subtract. You are checking an index further down if not. So you hit the target ( which technically you cant because the target is less than sum(nums) so it should be 0 and you end up hitting 3 times ( ie, 1 + 1 + 1 each time that decision is evaluated.)\\n\\n\\nHere is simpler recursion that would have the same issue if you  put the check in the base case:\\n\\n```\\n    def findTargetSumWays_crappy_bruteForce(self, nums: List[int], target: int) -> int:\\n\\n        ways = 0\\n        # traverse passing current running sum,\\n        # and index in nums,\\n        # and sign\\n        def rec_trav(v,i,s):\\n            nonlocal ways\\n\\n            # bail when index is already at last\\n            # element - its already been accounted\\n            if i == 0:\\n                return 0\\n\\n            # current sum is \\n            # running sum + (sign * elem at next index)\\n            t_sum = v + (s * nums[i-1])\\n\\n            # if we are at last index and,\\n            # current sum is target,\\n            # we have found 1 possible way\\n            if t_sum == target and i==1:\\n                ways += 1\\n                # dont need to call further\\n                return\\n\\n            # continue to traverse down the list with,\\n            # either possiblity\\n            rec_trav(t_sum,i-1,1)\\n            rec_trav(t_sum,i-1,-1)\\n\\n        rec_trav(0,len(nums),1)\\n        rec_trav(0,len(nums),-1)\\n        return ways\\n```\\n"
                    }
                ]
            },
            {
                "id": 2009449,
                "content": [
                    {
                        "username": "pawan_077",
                        "content": "Easiest C++ Solution with 96% faster with explanation\\nApproach:\\nThere are only two choices for every element it can be added to the sum or can be subtracted from the sum.\\nThus we can think the problem as partitioning the array in two subsets s1 and s2  such that abs(s1 - s2) = target.\\nSo we have two equations:-\\nsum(s1) + sum(s2) = sum(array)\\nsum(s1) - sum(s2) = target\\nHere s1 set contains all the elements which are having \\'+\\' sign and s2 set contains elements having \\'-\\' sign.\\n\\nso after adding both the equations we get:\\nsum(s1) = (sum(array) + target)/2\\nNow we have to find only count of subsets having sum = s1\\nSo the question reduced to count of number of subsets with a given sum.\\nHere is the code for finding number of subsets with given sum.\\n\\nExtreme case when sum + diff  becomes odd.\\nThen answer is not possible ...try various examples by yourself\\nEg [1,3,2,1] or [1,1,3,2] or [3,1,2,1] or any other example where sum=7 and given difference=2 (7+2=9)\\nyou cannot divide array into 2 proper subsets if the sum of the elements of array + difference is odd\\nNow try [3,2,1,1] where sum=7 and diff=3 now sum + diff=7+3=even so now answer can exist\\nans: [3,2] and [1,1]\\n5 - 2 = 3\\n5 + 2 = 7\\n\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        for(int it: nums)\\n            sum += it;\\n        if((sum+target)%2==1 or abs(target)>sum) // abs(target)>sum for some testcase like sum = 100 and target  = -200 here no solution exists\\n            return 0;\\n        sum = (sum + target)/2;\\n        int t[nums.size()+1][sum+1];\\n        for (int i = 0; i < sum+1; i++) t[0][i] = 0;\\n        for (int i = 0; i < nums.size()+1; i++) t[i][0] = 1;\\n        for (int i = 1; i < nums.size()+1; i++){\\n            for (int j = 0; j < sum+1; j++){\\n                if(nums[i-1]<=j)\\n                    t[i][j] = t[i-1][j] + t[i-1][j-nums[i-1]];\\n                else\\n                    t[i][j] = t[i-1][j];\\n            }\\n        }\\n        return t[nums.size()][sum];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KiranR",
                        "content": "My code worked but can someone explain why the division by 2 is needed?\\n\\n```class Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        \\n        n = len(nums)\\n\\n        @lru_cache(maxsize=None)\\n        def recur(ind, cur, sign):\\n            if ind == n:\\n                if cur == target:\\n                    # print(\"Here\")\\n                    return 1\\n                return 0\\n        \\n            cur_elem = nums[ind] if sign == \"+\" else -nums[ind]\\n            n1 = recur(ind+1, cur + cur_elem, \"+\")\\n            n2 = recur(ind+1, cur + cur_elem, \"-\")\\n            return n1 + n2\\n        \\n        \\n        \\n        return (recur(0, 0, \"+\") + recur(0, 0, \"-\")) // 2\\n```\\n"
                    },
                    {
                        "username": "shivanigam",
                        "content": "\"Sole Recurrence Relation is feeling Happy now.\""
                    },
                    {
                        "username": "apgupta3003",
                        "content": "what is happening? even an unmemoized code submitted successfully!\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "subset sum"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Loved this problem. Enjoyed solving it!"
                    },
                    {
                        "username": "jonathankhawbung",
                        "content": "yo man\\n"
                    },
                    {
                        "username": "devC_B",
                        "content": "can anyone tell me how to handel the negative target value without using any map , only using 2D vector ?"
                    },
                    {
                        "username": "layyy",
                        "content": "try partition equal subset sum before trying this"
                    },
                    {
                        "username": "aiden99",
                        "content": "I try to solve it using the Backtracking algorithm, but if input nums=[1,1,1,1], target=3, it outputs 3, with the found expression: \"+1+1+1\", \"+1 +1+1\", \"+1+1+1\". It is weird to me because there is indeed a condition check that `idx == len(nums)`.\\n\\n```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        ans = 0\\n\\n        def backtrack(idx, cnt):\\n            nonlocal ans\\n            if cnt == target and idx == len(nums):\\n                ans += 1\\n                return\\n\\n            for i in range(idx, len(nums)):\\n                # use \"+\"\\n                cnt += nums[i]\\n                backtrack(i+1, cnt)\\n                cnt -= nums[i]\\n\\n                # use \"-\"\\n                cnt -= nums[i]\\n                backtrack(i+1, cnt)\\n                cnt += nums[i]\\n\\n\\n        backtrack(0, 0)\\n        return ans\\n```"
                    },
                    {
                        "username": "ktanwar",
                        "content": "You need to check at least after each time you add or subtract. You are checking an index further down if not. So you hit the target ( which technically you cant because the target is less than sum(nums) so it should be 0 and you end up hitting 3 times ( ie, 1 + 1 + 1 each time that decision is evaluated.)\\n\\n\\nHere is simpler recursion that would have the same issue if you  put the check in the base case:\\n\\n```\\n    def findTargetSumWays_crappy_bruteForce(self, nums: List[int], target: int) -> int:\\n\\n        ways = 0\\n        # traverse passing current running sum,\\n        # and index in nums,\\n        # and sign\\n        def rec_trav(v,i,s):\\n            nonlocal ways\\n\\n            # bail when index is already at last\\n            # element - its already been accounted\\n            if i == 0:\\n                return 0\\n\\n            # current sum is \\n            # running sum + (sign * elem at next index)\\n            t_sum = v + (s * nums[i-1])\\n\\n            # if we are at last index and,\\n            # current sum is target,\\n            # we have found 1 possible way\\n            if t_sum == target and i==1:\\n                ways += 1\\n                # dont need to call further\\n                return\\n\\n            # continue to traverse down the list with,\\n            # either possiblity\\n            rec_trav(t_sum,i-1,1)\\n            rec_trav(t_sum,i-1,-1)\\n\\n        rec_trav(0,len(nums),1)\\n        rec_trav(0,len(nums),-1)\\n        return ways\\n```\\n"
                    }
                ]
            },
            {
                "id": 1985982,
                "content": [
                    {
                        "username": "pawan_077",
                        "content": "Easiest C++ Solution with 96% faster with explanation\\nApproach:\\nThere are only two choices for every element it can be added to the sum or can be subtracted from the sum.\\nThus we can think the problem as partitioning the array in two subsets s1 and s2  such that abs(s1 - s2) = target.\\nSo we have two equations:-\\nsum(s1) + sum(s2) = sum(array)\\nsum(s1) - sum(s2) = target\\nHere s1 set contains all the elements which are having \\'+\\' sign and s2 set contains elements having \\'-\\' sign.\\n\\nso after adding both the equations we get:\\nsum(s1) = (sum(array) + target)/2\\nNow we have to find only count of subsets having sum = s1\\nSo the question reduced to count of number of subsets with a given sum.\\nHere is the code for finding number of subsets with given sum.\\n\\nExtreme case when sum + diff  becomes odd.\\nThen answer is not possible ...try various examples by yourself\\nEg [1,3,2,1] or [1,1,3,2] or [3,1,2,1] or any other example where sum=7 and given difference=2 (7+2=9)\\nyou cannot divide array into 2 proper subsets if the sum of the elements of array + difference is odd\\nNow try [3,2,1,1] where sum=7 and diff=3 now sum + diff=7+3=even so now answer can exist\\nans: [3,2] and [1,1]\\n5 - 2 = 3\\n5 + 2 = 7\\n\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        for(int it: nums)\\n            sum += it;\\n        if((sum+target)%2==1 or abs(target)>sum) // abs(target)>sum for some testcase like sum = 100 and target  = -200 here no solution exists\\n            return 0;\\n        sum = (sum + target)/2;\\n        int t[nums.size()+1][sum+1];\\n        for (int i = 0; i < sum+1; i++) t[0][i] = 0;\\n        for (int i = 0; i < nums.size()+1; i++) t[i][0] = 1;\\n        for (int i = 1; i < nums.size()+1; i++){\\n            for (int j = 0; j < sum+1; j++){\\n                if(nums[i-1]<=j)\\n                    t[i][j] = t[i-1][j] + t[i-1][j-nums[i-1]];\\n                else\\n                    t[i][j] = t[i-1][j];\\n            }\\n        }\\n        return t[nums.size()][sum];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KiranR",
                        "content": "My code worked but can someone explain why the division by 2 is needed?\\n\\n```class Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        \\n        n = len(nums)\\n\\n        @lru_cache(maxsize=None)\\n        def recur(ind, cur, sign):\\n            if ind == n:\\n                if cur == target:\\n                    # print(\"Here\")\\n                    return 1\\n                return 0\\n        \\n            cur_elem = nums[ind] if sign == \"+\" else -nums[ind]\\n            n1 = recur(ind+1, cur + cur_elem, \"+\")\\n            n2 = recur(ind+1, cur + cur_elem, \"-\")\\n            return n1 + n2\\n        \\n        \\n        \\n        return (recur(0, 0, \"+\") + recur(0, 0, \"-\")) // 2\\n```\\n"
                    },
                    {
                        "username": "shivanigam",
                        "content": "\"Sole Recurrence Relation is feeling Happy now.\""
                    },
                    {
                        "username": "apgupta3003",
                        "content": "what is happening? even an unmemoized code submitted successfully!\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "subset sum"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Loved this problem. Enjoyed solving it!"
                    },
                    {
                        "username": "jonathankhawbung",
                        "content": "yo man\\n"
                    },
                    {
                        "username": "devC_B",
                        "content": "can anyone tell me how to handel the negative target value without using any map , only using 2D vector ?"
                    },
                    {
                        "username": "layyy",
                        "content": "try partition equal subset sum before trying this"
                    },
                    {
                        "username": "aiden99",
                        "content": "I try to solve it using the Backtracking algorithm, but if input nums=[1,1,1,1], target=3, it outputs 3, with the found expression: \"+1+1+1\", \"+1 +1+1\", \"+1+1+1\". It is weird to me because there is indeed a condition check that `idx == len(nums)`.\\n\\n```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        ans = 0\\n\\n        def backtrack(idx, cnt):\\n            nonlocal ans\\n            if cnt == target and idx == len(nums):\\n                ans += 1\\n                return\\n\\n            for i in range(idx, len(nums)):\\n                # use \"+\"\\n                cnt += nums[i]\\n                backtrack(i+1, cnt)\\n                cnt -= nums[i]\\n\\n                # use \"-\"\\n                cnt -= nums[i]\\n                backtrack(i+1, cnt)\\n                cnt += nums[i]\\n\\n\\n        backtrack(0, 0)\\n        return ans\\n```"
                    },
                    {
                        "username": "ktanwar",
                        "content": "You need to check at least after each time you add or subtract. You are checking an index further down if not. So you hit the target ( which technically you cant because the target is less than sum(nums) so it should be 0 and you end up hitting 3 times ( ie, 1 + 1 + 1 each time that decision is evaluated.)\\n\\n\\nHere is simpler recursion that would have the same issue if you  put the check in the base case:\\n\\n```\\n    def findTargetSumWays_crappy_bruteForce(self, nums: List[int], target: int) -> int:\\n\\n        ways = 0\\n        # traverse passing current running sum,\\n        # and index in nums,\\n        # and sign\\n        def rec_trav(v,i,s):\\n            nonlocal ways\\n\\n            # bail when index is already at last\\n            # element - its already been accounted\\n            if i == 0:\\n                return 0\\n\\n            # current sum is \\n            # running sum + (sign * elem at next index)\\n            t_sum = v + (s * nums[i-1])\\n\\n            # if we are at last index and,\\n            # current sum is target,\\n            # we have found 1 possible way\\n            if t_sum == target and i==1:\\n                ways += 1\\n                # dont need to call further\\n                return\\n\\n            # continue to traverse down the list with,\\n            # either possiblity\\n            rec_trav(t_sum,i-1,1)\\n            rec_trav(t_sum,i-1,-1)\\n\\n        rec_trav(0,len(nums),1)\\n        rec_trav(0,len(nums),-1)\\n        return ways\\n```\\n"
                    }
                ]
            },
            {
                "id": 1980462,
                "content": [
                    {
                        "username": "pawan_077",
                        "content": "Easiest C++ Solution with 96% faster with explanation\\nApproach:\\nThere are only two choices for every element it can be added to the sum or can be subtracted from the sum.\\nThus we can think the problem as partitioning the array in two subsets s1 and s2  such that abs(s1 - s2) = target.\\nSo we have two equations:-\\nsum(s1) + sum(s2) = sum(array)\\nsum(s1) - sum(s2) = target\\nHere s1 set contains all the elements which are having \\'+\\' sign and s2 set contains elements having \\'-\\' sign.\\n\\nso after adding both the equations we get:\\nsum(s1) = (sum(array) + target)/2\\nNow we have to find only count of subsets having sum = s1\\nSo the question reduced to count of number of subsets with a given sum.\\nHere is the code for finding number of subsets with given sum.\\n\\nExtreme case when sum + diff  becomes odd.\\nThen answer is not possible ...try various examples by yourself\\nEg [1,3,2,1] or [1,1,3,2] or [3,1,2,1] or any other example where sum=7 and given difference=2 (7+2=9)\\nyou cannot divide array into 2 proper subsets if the sum of the elements of array + difference is odd\\nNow try [3,2,1,1] where sum=7 and diff=3 now sum + diff=7+3=even so now answer can exist\\nans: [3,2] and [1,1]\\n5 - 2 = 3\\n5 + 2 = 7\\n\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        for(int it: nums)\\n            sum += it;\\n        if((sum+target)%2==1 or abs(target)>sum) // abs(target)>sum for some testcase like sum = 100 and target  = -200 here no solution exists\\n            return 0;\\n        sum = (sum + target)/2;\\n        int t[nums.size()+1][sum+1];\\n        for (int i = 0; i < sum+1; i++) t[0][i] = 0;\\n        for (int i = 0; i < nums.size()+1; i++) t[i][0] = 1;\\n        for (int i = 1; i < nums.size()+1; i++){\\n            for (int j = 0; j < sum+1; j++){\\n                if(nums[i-1]<=j)\\n                    t[i][j] = t[i-1][j] + t[i-1][j-nums[i-1]];\\n                else\\n                    t[i][j] = t[i-1][j];\\n            }\\n        }\\n        return t[nums.size()][sum];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KiranR",
                        "content": "My code worked but can someone explain why the division by 2 is needed?\\n\\n```class Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        \\n        n = len(nums)\\n\\n        @lru_cache(maxsize=None)\\n        def recur(ind, cur, sign):\\n            if ind == n:\\n                if cur == target:\\n                    # print(\"Here\")\\n                    return 1\\n                return 0\\n        \\n            cur_elem = nums[ind] if sign == \"+\" else -nums[ind]\\n            n1 = recur(ind+1, cur + cur_elem, \"+\")\\n            n2 = recur(ind+1, cur + cur_elem, \"-\")\\n            return n1 + n2\\n        \\n        \\n        \\n        return (recur(0, 0, \"+\") + recur(0, 0, \"-\")) // 2\\n```\\n"
                    },
                    {
                        "username": "shivanigam",
                        "content": "\"Sole Recurrence Relation is feeling Happy now.\""
                    },
                    {
                        "username": "apgupta3003",
                        "content": "what is happening? even an unmemoized code submitted successfully!\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "subset sum"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Loved this problem. Enjoyed solving it!"
                    },
                    {
                        "username": "jonathankhawbung",
                        "content": "yo man\\n"
                    },
                    {
                        "username": "devC_B",
                        "content": "can anyone tell me how to handel the negative target value without using any map , only using 2D vector ?"
                    },
                    {
                        "username": "layyy",
                        "content": "try partition equal subset sum before trying this"
                    },
                    {
                        "username": "aiden99",
                        "content": "I try to solve it using the Backtracking algorithm, but if input nums=[1,1,1,1], target=3, it outputs 3, with the found expression: \"+1+1+1\", \"+1 +1+1\", \"+1+1+1\". It is weird to me because there is indeed a condition check that `idx == len(nums)`.\\n\\n```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        ans = 0\\n\\n        def backtrack(idx, cnt):\\n            nonlocal ans\\n            if cnt == target and idx == len(nums):\\n                ans += 1\\n                return\\n\\n            for i in range(idx, len(nums)):\\n                # use \"+\"\\n                cnt += nums[i]\\n                backtrack(i+1, cnt)\\n                cnt -= nums[i]\\n\\n                # use \"-\"\\n                cnt -= nums[i]\\n                backtrack(i+1, cnt)\\n                cnt += nums[i]\\n\\n\\n        backtrack(0, 0)\\n        return ans\\n```"
                    },
                    {
                        "username": "ktanwar",
                        "content": "You need to check at least after each time you add or subtract. You are checking an index further down if not. So you hit the target ( which technically you cant because the target is less than sum(nums) so it should be 0 and you end up hitting 3 times ( ie, 1 + 1 + 1 each time that decision is evaluated.)\\n\\n\\nHere is simpler recursion that would have the same issue if you  put the check in the base case:\\n\\n```\\n    def findTargetSumWays_crappy_bruteForce(self, nums: List[int], target: int) -> int:\\n\\n        ways = 0\\n        # traverse passing current running sum,\\n        # and index in nums,\\n        # and sign\\n        def rec_trav(v,i,s):\\n            nonlocal ways\\n\\n            # bail when index is already at last\\n            # element - its already been accounted\\n            if i == 0:\\n                return 0\\n\\n            # current sum is \\n            # running sum + (sign * elem at next index)\\n            t_sum = v + (s * nums[i-1])\\n\\n            # if we are at last index and,\\n            # current sum is target,\\n            # we have found 1 possible way\\n            if t_sum == target and i==1:\\n                ways += 1\\n                # dont need to call further\\n                return\\n\\n            # continue to traverse down the list with,\\n            # either possiblity\\n            rec_trav(t_sum,i-1,1)\\n            rec_trav(t_sum,i-1,-1)\\n\\n        rec_trav(0,len(nums),1)\\n        rec_trav(0,len(nums),-1)\\n        return ways\\n```\\n"
                    }
                ]
            },
            {
                "id": 1980077,
                "content": [
                    {
                        "username": "pawan_077",
                        "content": "Easiest C++ Solution with 96% faster with explanation\\nApproach:\\nThere are only two choices for every element it can be added to the sum or can be subtracted from the sum.\\nThus we can think the problem as partitioning the array in two subsets s1 and s2  such that abs(s1 - s2) = target.\\nSo we have two equations:-\\nsum(s1) + sum(s2) = sum(array)\\nsum(s1) - sum(s2) = target\\nHere s1 set contains all the elements which are having \\'+\\' sign and s2 set contains elements having \\'-\\' sign.\\n\\nso after adding both the equations we get:\\nsum(s1) = (sum(array) + target)/2\\nNow we have to find only count of subsets having sum = s1\\nSo the question reduced to count of number of subsets with a given sum.\\nHere is the code for finding number of subsets with given sum.\\n\\nExtreme case when sum + diff  becomes odd.\\nThen answer is not possible ...try various examples by yourself\\nEg [1,3,2,1] or [1,1,3,2] or [3,1,2,1] or any other example where sum=7 and given difference=2 (7+2=9)\\nyou cannot divide array into 2 proper subsets if the sum of the elements of array + difference is odd\\nNow try [3,2,1,1] where sum=7 and diff=3 now sum + diff=7+3=even so now answer can exist\\nans: [3,2] and [1,1]\\n5 - 2 = 3\\n5 + 2 = 7\\n\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        for(int it: nums)\\n            sum += it;\\n        if((sum+target)%2==1 or abs(target)>sum) // abs(target)>sum for some testcase like sum = 100 and target  = -200 here no solution exists\\n            return 0;\\n        sum = (sum + target)/2;\\n        int t[nums.size()+1][sum+1];\\n        for (int i = 0; i < sum+1; i++) t[0][i] = 0;\\n        for (int i = 0; i < nums.size()+1; i++) t[i][0] = 1;\\n        for (int i = 1; i < nums.size()+1; i++){\\n            for (int j = 0; j < sum+1; j++){\\n                if(nums[i-1]<=j)\\n                    t[i][j] = t[i-1][j] + t[i-1][j-nums[i-1]];\\n                else\\n                    t[i][j] = t[i-1][j];\\n            }\\n        }\\n        return t[nums.size()][sum];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KiranR",
                        "content": "My code worked but can someone explain why the division by 2 is needed?\\n\\n```class Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        \\n        n = len(nums)\\n\\n        @lru_cache(maxsize=None)\\n        def recur(ind, cur, sign):\\n            if ind == n:\\n                if cur == target:\\n                    # print(\"Here\")\\n                    return 1\\n                return 0\\n        \\n            cur_elem = nums[ind] if sign == \"+\" else -nums[ind]\\n            n1 = recur(ind+1, cur + cur_elem, \"+\")\\n            n2 = recur(ind+1, cur + cur_elem, \"-\")\\n            return n1 + n2\\n        \\n        \\n        \\n        return (recur(0, 0, \"+\") + recur(0, 0, \"-\")) // 2\\n```\\n"
                    },
                    {
                        "username": "shivanigam",
                        "content": "\"Sole Recurrence Relation is feeling Happy now.\""
                    },
                    {
                        "username": "apgupta3003",
                        "content": "what is happening? even an unmemoized code submitted successfully!\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "subset sum"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Loved this problem. Enjoyed solving it!"
                    },
                    {
                        "username": "jonathankhawbung",
                        "content": "yo man\\n"
                    },
                    {
                        "username": "devC_B",
                        "content": "can anyone tell me how to handel the negative target value without using any map , only using 2D vector ?"
                    },
                    {
                        "username": "layyy",
                        "content": "try partition equal subset sum before trying this"
                    },
                    {
                        "username": "aiden99",
                        "content": "I try to solve it using the Backtracking algorithm, but if input nums=[1,1,1,1], target=3, it outputs 3, with the found expression: \"+1+1+1\", \"+1 +1+1\", \"+1+1+1\". It is weird to me because there is indeed a condition check that `idx == len(nums)`.\\n\\n```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        ans = 0\\n\\n        def backtrack(idx, cnt):\\n            nonlocal ans\\n            if cnt == target and idx == len(nums):\\n                ans += 1\\n                return\\n\\n            for i in range(idx, len(nums)):\\n                # use \"+\"\\n                cnt += nums[i]\\n                backtrack(i+1, cnt)\\n                cnt -= nums[i]\\n\\n                # use \"-\"\\n                cnt -= nums[i]\\n                backtrack(i+1, cnt)\\n                cnt += nums[i]\\n\\n\\n        backtrack(0, 0)\\n        return ans\\n```"
                    },
                    {
                        "username": "ktanwar",
                        "content": "You need to check at least after each time you add or subtract. You are checking an index further down if not. So you hit the target ( which technically you cant because the target is less than sum(nums) so it should be 0 and you end up hitting 3 times ( ie, 1 + 1 + 1 each time that decision is evaluated.)\\n\\n\\nHere is simpler recursion that would have the same issue if you  put the check in the base case:\\n\\n```\\n    def findTargetSumWays_crappy_bruteForce(self, nums: List[int], target: int) -> int:\\n\\n        ways = 0\\n        # traverse passing current running sum,\\n        # and index in nums,\\n        # and sign\\n        def rec_trav(v,i,s):\\n            nonlocal ways\\n\\n            # bail when index is already at last\\n            # element - its already been accounted\\n            if i == 0:\\n                return 0\\n\\n            # current sum is \\n            # running sum + (sign * elem at next index)\\n            t_sum = v + (s * nums[i-1])\\n\\n            # if we are at last index and,\\n            # current sum is target,\\n            # we have found 1 possible way\\n            if t_sum == target and i==1:\\n                ways += 1\\n                # dont need to call further\\n                return\\n\\n            # continue to traverse down the list with,\\n            # either possiblity\\n            rec_trav(t_sum,i-1,1)\\n            rec_trav(t_sum,i-1,-1)\\n\\n        rec_trav(0,len(nums),1)\\n        rec_trav(0,len(nums),-1)\\n        return ways\\n```\\n"
                    }
                ]
            },
            {
                "id": 1968767,
                "content": [
                    {
                        "username": "pawan_077",
                        "content": "Easiest C++ Solution with 96% faster with explanation\\nApproach:\\nThere are only two choices for every element it can be added to the sum or can be subtracted from the sum.\\nThus we can think the problem as partitioning the array in two subsets s1 and s2  such that abs(s1 - s2) = target.\\nSo we have two equations:-\\nsum(s1) + sum(s2) = sum(array)\\nsum(s1) - sum(s2) = target\\nHere s1 set contains all the elements which are having \\'+\\' sign and s2 set contains elements having \\'-\\' sign.\\n\\nso after adding both the equations we get:\\nsum(s1) = (sum(array) + target)/2\\nNow we have to find only count of subsets having sum = s1\\nSo the question reduced to count of number of subsets with a given sum.\\nHere is the code for finding number of subsets with given sum.\\n\\nExtreme case when sum + diff  becomes odd.\\nThen answer is not possible ...try various examples by yourself\\nEg [1,3,2,1] or [1,1,3,2] or [3,1,2,1] or any other example where sum=7 and given difference=2 (7+2=9)\\nyou cannot divide array into 2 proper subsets if the sum of the elements of array + difference is odd\\nNow try [3,2,1,1] where sum=7 and diff=3 now sum + diff=7+3=even so now answer can exist\\nans: [3,2] and [1,1]\\n5 - 2 = 3\\n5 + 2 = 7\\n\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        for(int it: nums)\\n            sum += it;\\n        if((sum+target)%2==1 or abs(target)>sum) // abs(target)>sum for some testcase like sum = 100 and target  = -200 here no solution exists\\n            return 0;\\n        sum = (sum + target)/2;\\n        int t[nums.size()+1][sum+1];\\n        for (int i = 0; i < sum+1; i++) t[0][i] = 0;\\n        for (int i = 0; i < nums.size()+1; i++) t[i][0] = 1;\\n        for (int i = 1; i < nums.size()+1; i++){\\n            for (int j = 0; j < sum+1; j++){\\n                if(nums[i-1]<=j)\\n                    t[i][j] = t[i-1][j] + t[i-1][j-nums[i-1]];\\n                else\\n                    t[i][j] = t[i-1][j];\\n            }\\n        }\\n        return t[nums.size()][sum];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KiranR",
                        "content": "My code worked but can someone explain why the division by 2 is needed?\\n\\n```class Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        \\n        n = len(nums)\\n\\n        @lru_cache(maxsize=None)\\n        def recur(ind, cur, sign):\\n            if ind == n:\\n                if cur == target:\\n                    # print(\"Here\")\\n                    return 1\\n                return 0\\n        \\n            cur_elem = nums[ind] if sign == \"+\" else -nums[ind]\\n            n1 = recur(ind+1, cur + cur_elem, \"+\")\\n            n2 = recur(ind+1, cur + cur_elem, \"-\")\\n            return n1 + n2\\n        \\n        \\n        \\n        return (recur(0, 0, \"+\") + recur(0, 0, \"-\")) // 2\\n```\\n"
                    },
                    {
                        "username": "shivanigam",
                        "content": "\"Sole Recurrence Relation is feeling Happy now.\""
                    },
                    {
                        "username": "apgupta3003",
                        "content": "what is happening? even an unmemoized code submitted successfully!\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "subset sum"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Loved this problem. Enjoyed solving it!"
                    },
                    {
                        "username": "jonathankhawbung",
                        "content": "yo man\\n"
                    },
                    {
                        "username": "devC_B",
                        "content": "can anyone tell me how to handel the negative target value without using any map , only using 2D vector ?"
                    },
                    {
                        "username": "layyy",
                        "content": "try partition equal subset sum before trying this"
                    },
                    {
                        "username": "aiden99",
                        "content": "I try to solve it using the Backtracking algorithm, but if input nums=[1,1,1,1], target=3, it outputs 3, with the found expression: \"+1+1+1\", \"+1 +1+1\", \"+1+1+1\". It is weird to me because there is indeed a condition check that `idx == len(nums)`.\\n\\n```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        ans = 0\\n\\n        def backtrack(idx, cnt):\\n            nonlocal ans\\n            if cnt == target and idx == len(nums):\\n                ans += 1\\n                return\\n\\n            for i in range(idx, len(nums)):\\n                # use \"+\"\\n                cnt += nums[i]\\n                backtrack(i+1, cnt)\\n                cnt -= nums[i]\\n\\n                # use \"-\"\\n                cnt -= nums[i]\\n                backtrack(i+1, cnt)\\n                cnt += nums[i]\\n\\n\\n        backtrack(0, 0)\\n        return ans\\n```"
                    },
                    {
                        "username": "ktanwar",
                        "content": "You need to check at least after each time you add or subtract. You are checking an index further down if not. So you hit the target ( which technically you cant because the target is less than sum(nums) so it should be 0 and you end up hitting 3 times ( ie, 1 + 1 + 1 each time that decision is evaluated.)\\n\\n\\nHere is simpler recursion that would have the same issue if you  put the check in the base case:\\n\\n```\\n    def findTargetSumWays_crappy_bruteForce(self, nums: List[int], target: int) -> int:\\n\\n        ways = 0\\n        # traverse passing current running sum,\\n        # and index in nums,\\n        # and sign\\n        def rec_trav(v,i,s):\\n            nonlocal ways\\n\\n            # bail when index is already at last\\n            # element - its already been accounted\\n            if i == 0:\\n                return 0\\n\\n            # current sum is \\n            # running sum + (sign * elem at next index)\\n            t_sum = v + (s * nums[i-1])\\n\\n            # if we are at last index and,\\n            # current sum is target,\\n            # we have found 1 possible way\\n            if t_sum == target and i==1:\\n                ways += 1\\n                # dont need to call further\\n                return\\n\\n            # continue to traverse down the list with,\\n            # either possiblity\\n            rec_trav(t_sum,i-1,1)\\n            rec_trav(t_sum,i-1,-1)\\n\\n        rec_trav(0,len(nums),1)\\n        rec_trav(0,len(nums),-1)\\n        return ways\\n```\\n"
                    }
                ]
            },
            {
                "id": 1932332,
                "content": [
                    {
                        "username": "pawan_077",
                        "content": "Easiest C++ Solution with 96% faster with explanation\\nApproach:\\nThere are only two choices for every element it can be added to the sum or can be subtracted from the sum.\\nThus we can think the problem as partitioning the array in two subsets s1 and s2  such that abs(s1 - s2) = target.\\nSo we have two equations:-\\nsum(s1) + sum(s2) = sum(array)\\nsum(s1) - sum(s2) = target\\nHere s1 set contains all the elements which are having \\'+\\' sign and s2 set contains elements having \\'-\\' sign.\\n\\nso after adding both the equations we get:\\nsum(s1) = (sum(array) + target)/2\\nNow we have to find only count of subsets having sum = s1\\nSo the question reduced to count of number of subsets with a given sum.\\nHere is the code for finding number of subsets with given sum.\\n\\nExtreme case when sum + diff  becomes odd.\\nThen answer is not possible ...try various examples by yourself\\nEg [1,3,2,1] or [1,1,3,2] or [3,1,2,1] or any other example where sum=7 and given difference=2 (7+2=9)\\nyou cannot divide array into 2 proper subsets if the sum of the elements of array + difference is odd\\nNow try [3,2,1,1] where sum=7 and diff=3 now sum + diff=7+3=even so now answer can exist\\nans: [3,2] and [1,1]\\n5 - 2 = 3\\n5 + 2 = 7\\n\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        for(int it: nums)\\n            sum += it;\\n        if((sum+target)%2==1 or abs(target)>sum) // abs(target)>sum for some testcase like sum = 100 and target  = -200 here no solution exists\\n            return 0;\\n        sum = (sum + target)/2;\\n        int t[nums.size()+1][sum+1];\\n        for (int i = 0; i < sum+1; i++) t[0][i] = 0;\\n        for (int i = 0; i < nums.size()+1; i++) t[i][0] = 1;\\n        for (int i = 1; i < nums.size()+1; i++){\\n            for (int j = 0; j < sum+1; j++){\\n                if(nums[i-1]<=j)\\n                    t[i][j] = t[i-1][j] + t[i-1][j-nums[i-1]];\\n                else\\n                    t[i][j] = t[i-1][j];\\n            }\\n        }\\n        return t[nums.size()][sum];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "KiranR",
                        "content": "My code worked but can someone explain why the division by 2 is needed?\\n\\n```class Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        \\n        n = len(nums)\\n\\n        @lru_cache(maxsize=None)\\n        def recur(ind, cur, sign):\\n            if ind == n:\\n                if cur == target:\\n                    # print(\"Here\")\\n                    return 1\\n                return 0\\n        \\n            cur_elem = nums[ind] if sign == \"+\" else -nums[ind]\\n            n1 = recur(ind+1, cur + cur_elem, \"+\")\\n            n2 = recur(ind+1, cur + cur_elem, \"-\")\\n            return n1 + n2\\n        \\n        \\n        \\n        return (recur(0, 0, \"+\") + recur(0, 0, \"-\")) // 2\\n```\\n"
                    },
                    {
                        "username": "shivanigam",
                        "content": "\"Sole Recurrence Relation is feeling Happy now.\""
                    },
                    {
                        "username": "apgupta3003",
                        "content": "what is happening? even an unmemoized code submitted successfully!\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "subset sum"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Loved this problem. Enjoyed solving it!"
                    },
                    {
                        "username": "jonathankhawbung",
                        "content": "yo man\\n"
                    },
                    {
                        "username": "devC_B",
                        "content": "can anyone tell me how to handel the negative target value without using any map , only using 2D vector ?"
                    },
                    {
                        "username": "layyy",
                        "content": "try partition equal subset sum before trying this"
                    },
                    {
                        "username": "aiden99",
                        "content": "I try to solve it using the Backtracking algorithm, but if input nums=[1,1,1,1], target=3, it outputs 3, with the found expression: \"+1+1+1\", \"+1 +1+1\", \"+1+1+1\". It is weird to me because there is indeed a condition check that `idx == len(nums)`.\\n\\n```\\nclass Solution:\\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\\n        ans = 0\\n\\n        def backtrack(idx, cnt):\\n            nonlocal ans\\n            if cnt == target and idx == len(nums):\\n                ans += 1\\n                return\\n\\n            for i in range(idx, len(nums)):\\n                # use \"+\"\\n                cnt += nums[i]\\n                backtrack(i+1, cnt)\\n                cnt -= nums[i]\\n\\n                # use \"-\"\\n                cnt -= nums[i]\\n                backtrack(i+1, cnt)\\n                cnt += nums[i]\\n\\n\\n        backtrack(0, 0)\\n        return ans\\n```"
                    },
                    {
                        "username": "ktanwar",
                        "content": "You need to check at least after each time you add or subtract. You are checking an index further down if not. So you hit the target ( which technically you cant because the target is less than sum(nums) so it should be 0 and you end up hitting 3 times ( ie, 1 + 1 + 1 each time that decision is evaluated.)\\n\\n\\nHere is simpler recursion that would have the same issue if you  put the check in the base case:\\n\\n```\\n    def findTargetSumWays_crappy_bruteForce(self, nums: List[int], target: int) -> int:\\n\\n        ways = 0\\n        # traverse passing current running sum,\\n        # and index in nums,\\n        # and sign\\n        def rec_trav(v,i,s):\\n            nonlocal ways\\n\\n            # bail when index is already at last\\n            # element - its already been accounted\\n            if i == 0:\\n                return 0\\n\\n            # current sum is \\n            # running sum + (sign * elem at next index)\\n            t_sum = v + (s * nums[i-1])\\n\\n            # if we are at last index and,\\n            # current sum is target,\\n            # we have found 1 possible way\\n            if t_sum == target and i==1:\\n                ways += 1\\n                # dont need to call further\\n                return\\n\\n            # continue to traverse down the list with,\\n            # either possiblity\\n            rec_trav(t_sum,i-1,1)\\n            rec_trav(t_sum,i-1,-1)\\n\\n        rec_trav(0,len(nums),1)\\n        rec_trav(0,len(nums),-1)\\n        return ways\\n```\\n"
                    }
                ]
            },
            {
                "id": 1903984,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Well, the constraints are very misleading. The tiny input size suggests an exponential backtraking approach.\\nYet, both my backtracking solutions (one using a bitmask, the other doing an explicit recursive backtracking) get rejected with a TLE... If the only accepted solution is DP, it is a weird \"trap\" to suggest backtracking with such low constraints"
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "nums = [0,0,0,0,0,0,0,0,1]\\ntarget = 1\\nOutput = 1\\nExpected = 256\\n\\nsomebody help me to understand the above testcase."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "Each 0 can be +0 or -0. If \"nums\" has n zeros, then there will be 2^n cases. So I calculate the number of zeros in \"nums\" and create a new non-zero list. The result lf non-zero list should multiply  2^n."
                    },
                    {
                        "username": "yaswanthkosuru",
                        "content": "\nplease solve it can any one why it exceeding time limit ''' `'''class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        ans=0\n        temp1,temp2=[],[]\n        temp1.append(nums[0])\n        temp1.append(-nums[0])\n        for i in range(1,len(nums)):\n            for k in temp1:\n                temp2.append(k+nums[i])\n                temp2.append(k-nums[i])\n            temp1=temp2.copy()\n            temp2=[]\n        return temp1.count(target).`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nstatic int countPartitionsUtil(int ind, int target, int[] arr,int[][] dp){\\n\\n     if(ind == 0){\\n        if(target==0 && arr[0]==0)\\n            return 2;\\n        if(target==0 || target == arr[0])\\n            return 1;\\n        return 0;\\n    }\\n    \\n    if(dp[ind][target]!=-1)\\n        return dp[ind][target];\\n        \\n    int notTaken = countPartitionsUtil(ind-1,target,arr,dp);\\n    \\n    int taken = 0;\\n    if(arr[ind]<=target)\\n        taken = countPartitionsUtil(ind-1,target-arr[ind],arr,dp);\\n        \\n    return dp[ind][target]= (notTaken + taken);\\n}\\n\\nstatic int targetSum(int n,int target,int[] arr){\\n    int totSum = 0;\\n    for(int i=0; i<arr.length;i++){\\n        totSum += arr[i];\\n    }\\n    \\n    //Checking for edge cases\\n    if(totSum-target<0) return 0;\\n    if((totSum-target)%2==1) return 0;\\n    \\n    int s2 = (totSum-target)/2;\\n    \\n    int dp[][]=new int[n][s2+1];\\n    for(int row[]: dp)\\n    Arrays.fill(row,-1);\\n    return countPartitionsUtil(n-1,s2,arr,dp);\\n}\\n`"
                    },
                    {
                        "username": "hosua",
                        "content": "In the official solution for approach #2, the post states:\n\n`The factor of total has been added as an offset to the sum value to map all the sums possible to positive integer range. By making use of memoization, we can get the result of each redundant function call in constant time.`\n\nCan someone explain why the memo is being indexed with `total+sum`? I tried it with just `sum` and it does not work, I don't understand why.\n\n\nEDIT: Figured it out literally 2 seconds after posting this lol. I'll leave this here incase someone runs into the same question. \nIt's because of the possibility of a negative sum, you cannot have a negative index, so an offset of `total` fixes this issue."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int backtrace(vector<int>& nums, int it, int sum, int target, map<string, int>& memo) {\\n        \\n        string key = to_string(it) + \",\" + to_string(sum);\\n\\n        if(it >= nums.size() ) {\\n            if(sum == target) {\\n                memo[key] = 1;\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if(memo.find(key) != memo.end()) {\\n            return memo[key];\\n        }\\n\\n        memo[key] = backtrace(nums, it + 1, sum + nums[it], target, memo) +\\n        backtrace(nums, it + 1, sum - nums[it], target, memo);\\n        return memo[key];\\n    }\\n\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        int res = 0;\\n        map<string,int> memo;\\n        backtrace(nums, 0, sum, target, memo);\\n        string key = \"0,0\";\\n        return memo[key];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "uavishal777",
                        "content": " for(int i=1;i<n+1;i++){\\n            for(int j=0;j<value+1;j++){      //@\\n                if(nums[i-1]<=j){\\n                    dp[i][j]=dp[i-1][j-nums[i-1]] + dp[i-1][j];\\n                }\\n                else{\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n            }\\n        }\\n\\nwhy after initialising the dp array i has to traverse array from j==0;\\n"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "because we need to handle the cases where multiple zeroes are there in the array which increases the number of subsets"
                    },
                    {
                        "username": "loser__",
                        "content": "class Solution {\\npublic:\\nint noofsubset(vector<int>&nums,int k,int n){\\n    int t[n+1][k+1];\\n    for(int i=0;i<=k;i++)\\n    t[0][i]=0;\\n    for(int i=0;i<=n;i++)\\n    t[i][0]=1;\\n    for(int i=1;i<=n;i++)\\n    {\\n        for(int j=0;j<=k;j++){\\n            \\n            if(nums[i-1]<=j){\\n            t[i][j]=t[i-1][j-nums[i-1]] +t[i-1][j];\\n            }\\n            else\\n            t[i][j]=t[i-1][j];\\n        }\\n    }\\n    return t[n][k];\\n\\n}\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum=0;\\n        target=abs(target);\\n        for(int i=0;i<n;i++){\\nsum+=nums[i];\\n        }\\n        if(((sum + target) % 2 != 0) || (target > sum))\\n        return 0;\\n        int k=(sum+target)/2;\\n      return  noofsubset(nums,k,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "braads07",
                        "content": "what is the error, anyone?\\n\\n \\nclass Solution {\\npublic:\\n    int solve(int n, int target , vector<vector<int>>&dp , vector<int>nums , int sum)\\n    {\\n        // n is basically representing the index\\n        if(n==0)\\n        {\\n            if((sum + nums[0])==target)\\n            return 1;\\n            else\\n            return 0;\\n        }\\n        // dp ki condition\\n        if(dp[n][sum]!=-1)\\n        return dp[n][sum];\\n\\n        return dp[n][sum] =( solve(n-1 , target,dp ,nums , sum- nums[n]) + solve(n-1 , target, dp , nums , sum+ nums[n]));\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n\\n        int count=0;\\n        vector<vector<int>>dp(nums.size()+1, vector<int>(target+1 , -1));\\n        int g=solve(nums.size()-1, target ,dp , nums , count );\\n        return g;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ra_hul",
                        "content": "Iterative solution -  Time & Space - O(n) \\n\\n```\\n        n = len(nums)\\n        root = (0, target, False)\\n        stack = [root]\\n        cache = {}\\n\\n        while len(stack) > 0:\\n\\n            idx, newTarget, visited = stack.pop()\\n\\n            if not visited:\\n                stack.append((idx, newTarget, True))\\n                if idx < n-1:\\n                    if (idx+1, newTarget-nums[idx]) not in cache:\\n                        stack.append((idx+1, newTarget-nums[idx], False))\\n                    if (idx+1, newTarget+nums[idx]) not in cache:\\n                        stack.append((idx+1, newTarget+nums[idx], False))\\n            else:\\n                value = 0\\n                if idx == n-1:\\n                    if newTarget == nums[idx]:\\n                        value += 1\\n                    if newTarget == -nums[idx]:\\n                        value += 1\\n                else:\\n                    value = cache[(idx+1, newTarget-nums[idx])] + cache[(idx+1, newTarget+nums[idx])]\\n                \\n                cache[(idx, newTarget)] = value\\n        \\n        return cache[0, target]\\n```\\n\\nThis solution solves the TargetSum problem by using postorder traversal on the expected recursion tree. It caches the nodes that are already computed."
                    }
                ]
            },
            {
                "id": 1870751,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Well, the constraints are very misleading. The tiny input size suggests an exponential backtraking approach.\\nYet, both my backtracking solutions (one using a bitmask, the other doing an explicit recursive backtracking) get rejected with a TLE... If the only accepted solution is DP, it is a weird \"trap\" to suggest backtracking with such low constraints"
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "nums = [0,0,0,0,0,0,0,0,1]\\ntarget = 1\\nOutput = 1\\nExpected = 256\\n\\nsomebody help me to understand the above testcase."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "Each 0 can be +0 or -0. If \"nums\" has n zeros, then there will be 2^n cases. So I calculate the number of zeros in \"nums\" and create a new non-zero list. The result lf non-zero list should multiply  2^n."
                    },
                    {
                        "username": "yaswanthkosuru",
                        "content": "\nplease solve it can any one why it exceeding time limit ''' `'''class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        ans=0\n        temp1,temp2=[],[]\n        temp1.append(nums[0])\n        temp1.append(-nums[0])\n        for i in range(1,len(nums)):\n            for k in temp1:\n                temp2.append(k+nums[i])\n                temp2.append(k-nums[i])\n            temp1=temp2.copy()\n            temp2=[]\n        return temp1.count(target).`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nstatic int countPartitionsUtil(int ind, int target, int[] arr,int[][] dp){\\n\\n     if(ind == 0){\\n        if(target==0 && arr[0]==0)\\n            return 2;\\n        if(target==0 || target == arr[0])\\n            return 1;\\n        return 0;\\n    }\\n    \\n    if(dp[ind][target]!=-1)\\n        return dp[ind][target];\\n        \\n    int notTaken = countPartitionsUtil(ind-1,target,arr,dp);\\n    \\n    int taken = 0;\\n    if(arr[ind]<=target)\\n        taken = countPartitionsUtil(ind-1,target-arr[ind],arr,dp);\\n        \\n    return dp[ind][target]= (notTaken + taken);\\n}\\n\\nstatic int targetSum(int n,int target,int[] arr){\\n    int totSum = 0;\\n    for(int i=0; i<arr.length;i++){\\n        totSum += arr[i];\\n    }\\n    \\n    //Checking for edge cases\\n    if(totSum-target<0) return 0;\\n    if((totSum-target)%2==1) return 0;\\n    \\n    int s2 = (totSum-target)/2;\\n    \\n    int dp[][]=new int[n][s2+1];\\n    for(int row[]: dp)\\n    Arrays.fill(row,-1);\\n    return countPartitionsUtil(n-1,s2,arr,dp);\\n}\\n`"
                    },
                    {
                        "username": "hosua",
                        "content": "In the official solution for approach #2, the post states:\n\n`The factor of total has been added as an offset to the sum value to map all the sums possible to positive integer range. By making use of memoization, we can get the result of each redundant function call in constant time.`\n\nCan someone explain why the memo is being indexed with `total+sum`? I tried it with just `sum` and it does not work, I don't understand why.\n\n\nEDIT: Figured it out literally 2 seconds after posting this lol. I'll leave this here incase someone runs into the same question. \nIt's because of the possibility of a negative sum, you cannot have a negative index, so an offset of `total` fixes this issue."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int backtrace(vector<int>& nums, int it, int sum, int target, map<string, int>& memo) {\\n        \\n        string key = to_string(it) + \",\" + to_string(sum);\\n\\n        if(it >= nums.size() ) {\\n            if(sum == target) {\\n                memo[key] = 1;\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if(memo.find(key) != memo.end()) {\\n            return memo[key];\\n        }\\n\\n        memo[key] = backtrace(nums, it + 1, sum + nums[it], target, memo) +\\n        backtrace(nums, it + 1, sum - nums[it], target, memo);\\n        return memo[key];\\n    }\\n\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        int res = 0;\\n        map<string,int> memo;\\n        backtrace(nums, 0, sum, target, memo);\\n        string key = \"0,0\";\\n        return memo[key];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "uavishal777",
                        "content": " for(int i=1;i<n+1;i++){\\n            for(int j=0;j<value+1;j++){      //@\\n                if(nums[i-1]<=j){\\n                    dp[i][j]=dp[i-1][j-nums[i-1]] + dp[i-1][j];\\n                }\\n                else{\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n            }\\n        }\\n\\nwhy after initialising the dp array i has to traverse array from j==0;\\n"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "because we need to handle the cases where multiple zeroes are there in the array which increases the number of subsets"
                    },
                    {
                        "username": "loser__",
                        "content": "class Solution {\\npublic:\\nint noofsubset(vector<int>&nums,int k,int n){\\n    int t[n+1][k+1];\\n    for(int i=0;i<=k;i++)\\n    t[0][i]=0;\\n    for(int i=0;i<=n;i++)\\n    t[i][0]=1;\\n    for(int i=1;i<=n;i++)\\n    {\\n        for(int j=0;j<=k;j++){\\n            \\n            if(nums[i-1]<=j){\\n            t[i][j]=t[i-1][j-nums[i-1]] +t[i-1][j];\\n            }\\n            else\\n            t[i][j]=t[i-1][j];\\n        }\\n    }\\n    return t[n][k];\\n\\n}\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum=0;\\n        target=abs(target);\\n        for(int i=0;i<n;i++){\\nsum+=nums[i];\\n        }\\n        if(((sum + target) % 2 != 0) || (target > sum))\\n        return 0;\\n        int k=(sum+target)/2;\\n      return  noofsubset(nums,k,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "braads07",
                        "content": "what is the error, anyone?\\n\\n \\nclass Solution {\\npublic:\\n    int solve(int n, int target , vector<vector<int>>&dp , vector<int>nums , int sum)\\n    {\\n        // n is basically representing the index\\n        if(n==0)\\n        {\\n            if((sum + nums[0])==target)\\n            return 1;\\n            else\\n            return 0;\\n        }\\n        // dp ki condition\\n        if(dp[n][sum]!=-1)\\n        return dp[n][sum];\\n\\n        return dp[n][sum] =( solve(n-1 , target,dp ,nums , sum- nums[n]) + solve(n-1 , target, dp , nums , sum+ nums[n]));\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n\\n        int count=0;\\n        vector<vector<int>>dp(nums.size()+1, vector<int>(target+1 , -1));\\n        int g=solve(nums.size()-1, target ,dp , nums , count );\\n        return g;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ra_hul",
                        "content": "Iterative solution -  Time & Space - O(n) \\n\\n```\\n        n = len(nums)\\n        root = (0, target, False)\\n        stack = [root]\\n        cache = {}\\n\\n        while len(stack) > 0:\\n\\n            idx, newTarget, visited = stack.pop()\\n\\n            if not visited:\\n                stack.append((idx, newTarget, True))\\n                if idx < n-1:\\n                    if (idx+1, newTarget-nums[idx]) not in cache:\\n                        stack.append((idx+1, newTarget-nums[idx], False))\\n                    if (idx+1, newTarget+nums[idx]) not in cache:\\n                        stack.append((idx+1, newTarget+nums[idx], False))\\n            else:\\n                value = 0\\n                if idx == n-1:\\n                    if newTarget == nums[idx]:\\n                        value += 1\\n                    if newTarget == -nums[idx]:\\n                        value += 1\\n                else:\\n                    value = cache[(idx+1, newTarget-nums[idx])] + cache[(idx+1, newTarget+nums[idx])]\\n                \\n                cache[(idx, newTarget)] = value\\n        \\n        return cache[0, target]\\n```\\n\\nThis solution solves the TargetSum problem by using postorder traversal on the expected recursion tree. It caches the nodes that are already computed."
                    }
                ]
            },
            {
                "id": 1789082,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Well, the constraints are very misleading. The tiny input size suggests an exponential backtraking approach.\\nYet, both my backtracking solutions (one using a bitmask, the other doing an explicit recursive backtracking) get rejected with a TLE... If the only accepted solution is DP, it is a weird \"trap\" to suggest backtracking with such low constraints"
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "nums = [0,0,0,0,0,0,0,0,1]\\ntarget = 1\\nOutput = 1\\nExpected = 256\\n\\nsomebody help me to understand the above testcase."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "Each 0 can be +0 or -0. If \"nums\" has n zeros, then there will be 2^n cases. So I calculate the number of zeros in \"nums\" and create a new non-zero list. The result lf non-zero list should multiply  2^n."
                    },
                    {
                        "username": "yaswanthkosuru",
                        "content": "\nplease solve it can any one why it exceeding time limit ''' `'''class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        ans=0\n        temp1,temp2=[],[]\n        temp1.append(nums[0])\n        temp1.append(-nums[0])\n        for i in range(1,len(nums)):\n            for k in temp1:\n                temp2.append(k+nums[i])\n                temp2.append(k-nums[i])\n            temp1=temp2.copy()\n            temp2=[]\n        return temp1.count(target).`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nstatic int countPartitionsUtil(int ind, int target, int[] arr,int[][] dp){\\n\\n     if(ind == 0){\\n        if(target==0 && arr[0]==0)\\n            return 2;\\n        if(target==0 || target == arr[0])\\n            return 1;\\n        return 0;\\n    }\\n    \\n    if(dp[ind][target]!=-1)\\n        return dp[ind][target];\\n        \\n    int notTaken = countPartitionsUtil(ind-1,target,arr,dp);\\n    \\n    int taken = 0;\\n    if(arr[ind]<=target)\\n        taken = countPartitionsUtil(ind-1,target-arr[ind],arr,dp);\\n        \\n    return dp[ind][target]= (notTaken + taken);\\n}\\n\\nstatic int targetSum(int n,int target,int[] arr){\\n    int totSum = 0;\\n    for(int i=0; i<arr.length;i++){\\n        totSum += arr[i];\\n    }\\n    \\n    //Checking for edge cases\\n    if(totSum-target<0) return 0;\\n    if((totSum-target)%2==1) return 0;\\n    \\n    int s2 = (totSum-target)/2;\\n    \\n    int dp[][]=new int[n][s2+1];\\n    for(int row[]: dp)\\n    Arrays.fill(row,-1);\\n    return countPartitionsUtil(n-1,s2,arr,dp);\\n}\\n`"
                    },
                    {
                        "username": "hosua",
                        "content": "In the official solution for approach #2, the post states:\n\n`The factor of total has been added as an offset to the sum value to map all the sums possible to positive integer range. By making use of memoization, we can get the result of each redundant function call in constant time.`\n\nCan someone explain why the memo is being indexed with `total+sum`? I tried it with just `sum` and it does not work, I don't understand why.\n\n\nEDIT: Figured it out literally 2 seconds after posting this lol. I'll leave this here incase someone runs into the same question. \nIt's because of the possibility of a negative sum, you cannot have a negative index, so an offset of `total` fixes this issue."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int backtrace(vector<int>& nums, int it, int sum, int target, map<string, int>& memo) {\\n        \\n        string key = to_string(it) + \",\" + to_string(sum);\\n\\n        if(it >= nums.size() ) {\\n            if(sum == target) {\\n                memo[key] = 1;\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if(memo.find(key) != memo.end()) {\\n            return memo[key];\\n        }\\n\\n        memo[key] = backtrace(nums, it + 1, sum + nums[it], target, memo) +\\n        backtrace(nums, it + 1, sum - nums[it], target, memo);\\n        return memo[key];\\n    }\\n\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        int res = 0;\\n        map<string,int> memo;\\n        backtrace(nums, 0, sum, target, memo);\\n        string key = \"0,0\";\\n        return memo[key];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "uavishal777",
                        "content": " for(int i=1;i<n+1;i++){\\n            for(int j=0;j<value+1;j++){      //@\\n                if(nums[i-1]<=j){\\n                    dp[i][j]=dp[i-1][j-nums[i-1]] + dp[i-1][j];\\n                }\\n                else{\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n            }\\n        }\\n\\nwhy after initialising the dp array i has to traverse array from j==0;\\n"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "because we need to handle the cases where multiple zeroes are there in the array which increases the number of subsets"
                    },
                    {
                        "username": "loser__",
                        "content": "class Solution {\\npublic:\\nint noofsubset(vector<int>&nums,int k,int n){\\n    int t[n+1][k+1];\\n    for(int i=0;i<=k;i++)\\n    t[0][i]=0;\\n    for(int i=0;i<=n;i++)\\n    t[i][0]=1;\\n    for(int i=1;i<=n;i++)\\n    {\\n        for(int j=0;j<=k;j++){\\n            \\n            if(nums[i-1]<=j){\\n            t[i][j]=t[i-1][j-nums[i-1]] +t[i-1][j];\\n            }\\n            else\\n            t[i][j]=t[i-1][j];\\n        }\\n    }\\n    return t[n][k];\\n\\n}\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum=0;\\n        target=abs(target);\\n        for(int i=0;i<n;i++){\\nsum+=nums[i];\\n        }\\n        if(((sum + target) % 2 != 0) || (target > sum))\\n        return 0;\\n        int k=(sum+target)/2;\\n      return  noofsubset(nums,k,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "braads07",
                        "content": "what is the error, anyone?\\n\\n \\nclass Solution {\\npublic:\\n    int solve(int n, int target , vector<vector<int>>&dp , vector<int>nums , int sum)\\n    {\\n        // n is basically representing the index\\n        if(n==0)\\n        {\\n            if((sum + nums[0])==target)\\n            return 1;\\n            else\\n            return 0;\\n        }\\n        // dp ki condition\\n        if(dp[n][sum]!=-1)\\n        return dp[n][sum];\\n\\n        return dp[n][sum] =( solve(n-1 , target,dp ,nums , sum- nums[n]) + solve(n-1 , target, dp , nums , sum+ nums[n]));\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n\\n        int count=0;\\n        vector<vector<int>>dp(nums.size()+1, vector<int>(target+1 , -1));\\n        int g=solve(nums.size()-1, target ,dp , nums , count );\\n        return g;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ra_hul",
                        "content": "Iterative solution -  Time & Space - O(n) \\n\\n```\\n        n = len(nums)\\n        root = (0, target, False)\\n        stack = [root]\\n        cache = {}\\n\\n        while len(stack) > 0:\\n\\n            idx, newTarget, visited = stack.pop()\\n\\n            if not visited:\\n                stack.append((idx, newTarget, True))\\n                if idx < n-1:\\n                    if (idx+1, newTarget-nums[idx]) not in cache:\\n                        stack.append((idx+1, newTarget-nums[idx], False))\\n                    if (idx+1, newTarget+nums[idx]) not in cache:\\n                        stack.append((idx+1, newTarget+nums[idx], False))\\n            else:\\n                value = 0\\n                if idx == n-1:\\n                    if newTarget == nums[idx]:\\n                        value += 1\\n                    if newTarget == -nums[idx]:\\n                        value += 1\\n                else:\\n                    value = cache[(idx+1, newTarget-nums[idx])] + cache[(idx+1, newTarget+nums[idx])]\\n                \\n                cache[(idx, newTarget)] = value\\n        \\n        return cache[0, target]\\n```\\n\\nThis solution solves the TargetSum problem by using postorder traversal on the expected recursion tree. It caches the nodes that are already computed."
                    }
                ]
            },
            {
                "id": 1780052,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Well, the constraints are very misleading. The tiny input size suggests an exponential backtraking approach.\\nYet, both my backtracking solutions (one using a bitmask, the other doing an explicit recursive backtracking) get rejected with a TLE... If the only accepted solution is DP, it is a weird \"trap\" to suggest backtracking with such low constraints"
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "nums = [0,0,0,0,0,0,0,0,1]\\ntarget = 1\\nOutput = 1\\nExpected = 256\\n\\nsomebody help me to understand the above testcase."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "Each 0 can be +0 or -0. If \"nums\" has n zeros, then there will be 2^n cases. So I calculate the number of zeros in \"nums\" and create a new non-zero list. The result lf non-zero list should multiply  2^n."
                    },
                    {
                        "username": "yaswanthkosuru",
                        "content": "\nplease solve it can any one why it exceeding time limit ''' `'''class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        ans=0\n        temp1,temp2=[],[]\n        temp1.append(nums[0])\n        temp1.append(-nums[0])\n        for i in range(1,len(nums)):\n            for k in temp1:\n                temp2.append(k+nums[i])\n                temp2.append(k-nums[i])\n            temp1=temp2.copy()\n            temp2=[]\n        return temp1.count(target).`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nstatic int countPartitionsUtil(int ind, int target, int[] arr,int[][] dp){\\n\\n     if(ind == 0){\\n        if(target==0 && arr[0]==0)\\n            return 2;\\n        if(target==0 || target == arr[0])\\n            return 1;\\n        return 0;\\n    }\\n    \\n    if(dp[ind][target]!=-1)\\n        return dp[ind][target];\\n        \\n    int notTaken = countPartitionsUtil(ind-1,target,arr,dp);\\n    \\n    int taken = 0;\\n    if(arr[ind]<=target)\\n        taken = countPartitionsUtil(ind-1,target-arr[ind],arr,dp);\\n        \\n    return dp[ind][target]= (notTaken + taken);\\n}\\n\\nstatic int targetSum(int n,int target,int[] arr){\\n    int totSum = 0;\\n    for(int i=0; i<arr.length;i++){\\n        totSum += arr[i];\\n    }\\n    \\n    //Checking for edge cases\\n    if(totSum-target<0) return 0;\\n    if((totSum-target)%2==1) return 0;\\n    \\n    int s2 = (totSum-target)/2;\\n    \\n    int dp[][]=new int[n][s2+1];\\n    for(int row[]: dp)\\n    Arrays.fill(row,-1);\\n    return countPartitionsUtil(n-1,s2,arr,dp);\\n}\\n`"
                    },
                    {
                        "username": "hosua",
                        "content": "In the official solution for approach #2, the post states:\n\n`The factor of total has been added as an offset to the sum value to map all the sums possible to positive integer range. By making use of memoization, we can get the result of each redundant function call in constant time.`\n\nCan someone explain why the memo is being indexed with `total+sum`? I tried it with just `sum` and it does not work, I don't understand why.\n\n\nEDIT: Figured it out literally 2 seconds after posting this lol. I'll leave this here incase someone runs into the same question. \nIt's because of the possibility of a negative sum, you cannot have a negative index, so an offset of `total` fixes this issue."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int backtrace(vector<int>& nums, int it, int sum, int target, map<string, int>& memo) {\\n        \\n        string key = to_string(it) + \",\" + to_string(sum);\\n\\n        if(it >= nums.size() ) {\\n            if(sum == target) {\\n                memo[key] = 1;\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if(memo.find(key) != memo.end()) {\\n            return memo[key];\\n        }\\n\\n        memo[key] = backtrace(nums, it + 1, sum + nums[it], target, memo) +\\n        backtrace(nums, it + 1, sum - nums[it], target, memo);\\n        return memo[key];\\n    }\\n\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        int res = 0;\\n        map<string,int> memo;\\n        backtrace(nums, 0, sum, target, memo);\\n        string key = \"0,0\";\\n        return memo[key];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "uavishal777",
                        "content": " for(int i=1;i<n+1;i++){\\n            for(int j=0;j<value+1;j++){      //@\\n                if(nums[i-1]<=j){\\n                    dp[i][j]=dp[i-1][j-nums[i-1]] + dp[i-1][j];\\n                }\\n                else{\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n            }\\n        }\\n\\nwhy after initialising the dp array i has to traverse array from j==0;\\n"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "because we need to handle the cases where multiple zeroes are there in the array which increases the number of subsets"
                    },
                    {
                        "username": "loser__",
                        "content": "class Solution {\\npublic:\\nint noofsubset(vector<int>&nums,int k,int n){\\n    int t[n+1][k+1];\\n    for(int i=0;i<=k;i++)\\n    t[0][i]=0;\\n    for(int i=0;i<=n;i++)\\n    t[i][0]=1;\\n    for(int i=1;i<=n;i++)\\n    {\\n        for(int j=0;j<=k;j++){\\n            \\n            if(nums[i-1]<=j){\\n            t[i][j]=t[i-1][j-nums[i-1]] +t[i-1][j];\\n            }\\n            else\\n            t[i][j]=t[i-1][j];\\n        }\\n    }\\n    return t[n][k];\\n\\n}\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum=0;\\n        target=abs(target);\\n        for(int i=0;i<n;i++){\\nsum+=nums[i];\\n        }\\n        if(((sum + target) % 2 != 0) || (target > sum))\\n        return 0;\\n        int k=(sum+target)/2;\\n      return  noofsubset(nums,k,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "braads07",
                        "content": "what is the error, anyone?\\n\\n \\nclass Solution {\\npublic:\\n    int solve(int n, int target , vector<vector<int>>&dp , vector<int>nums , int sum)\\n    {\\n        // n is basically representing the index\\n        if(n==0)\\n        {\\n            if((sum + nums[0])==target)\\n            return 1;\\n            else\\n            return 0;\\n        }\\n        // dp ki condition\\n        if(dp[n][sum]!=-1)\\n        return dp[n][sum];\\n\\n        return dp[n][sum] =( solve(n-1 , target,dp ,nums , sum- nums[n]) + solve(n-1 , target, dp , nums , sum+ nums[n]));\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n\\n        int count=0;\\n        vector<vector<int>>dp(nums.size()+1, vector<int>(target+1 , -1));\\n        int g=solve(nums.size()-1, target ,dp , nums , count );\\n        return g;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ra_hul",
                        "content": "Iterative solution -  Time & Space - O(n) \\n\\n```\\n        n = len(nums)\\n        root = (0, target, False)\\n        stack = [root]\\n        cache = {}\\n\\n        while len(stack) > 0:\\n\\n            idx, newTarget, visited = stack.pop()\\n\\n            if not visited:\\n                stack.append((idx, newTarget, True))\\n                if idx < n-1:\\n                    if (idx+1, newTarget-nums[idx]) not in cache:\\n                        stack.append((idx+1, newTarget-nums[idx], False))\\n                    if (idx+1, newTarget+nums[idx]) not in cache:\\n                        stack.append((idx+1, newTarget+nums[idx], False))\\n            else:\\n                value = 0\\n                if idx == n-1:\\n                    if newTarget == nums[idx]:\\n                        value += 1\\n                    if newTarget == -nums[idx]:\\n                        value += 1\\n                else:\\n                    value = cache[(idx+1, newTarget-nums[idx])] + cache[(idx+1, newTarget+nums[idx])]\\n                \\n                cache[(idx, newTarget)] = value\\n        \\n        return cache[0, target]\\n```\\n\\nThis solution solves the TargetSum problem by using postorder traversal on the expected recursion tree. It caches the nodes that are already computed."
                    }
                ]
            },
            {
                "id": 1771775,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Well, the constraints are very misleading. The tiny input size suggests an exponential backtraking approach.\\nYet, both my backtracking solutions (one using a bitmask, the other doing an explicit recursive backtracking) get rejected with a TLE... If the only accepted solution is DP, it is a weird \"trap\" to suggest backtracking with such low constraints"
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "nums = [0,0,0,0,0,0,0,0,1]\\ntarget = 1\\nOutput = 1\\nExpected = 256\\n\\nsomebody help me to understand the above testcase."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "Each 0 can be +0 or -0. If \"nums\" has n zeros, then there will be 2^n cases. So I calculate the number of zeros in \"nums\" and create a new non-zero list. The result lf non-zero list should multiply  2^n."
                    },
                    {
                        "username": "yaswanthkosuru",
                        "content": "\nplease solve it can any one why it exceeding time limit ''' `'''class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        ans=0\n        temp1,temp2=[],[]\n        temp1.append(nums[0])\n        temp1.append(-nums[0])\n        for i in range(1,len(nums)):\n            for k in temp1:\n                temp2.append(k+nums[i])\n                temp2.append(k-nums[i])\n            temp1=temp2.copy()\n            temp2=[]\n        return temp1.count(target).`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nstatic int countPartitionsUtil(int ind, int target, int[] arr,int[][] dp){\\n\\n     if(ind == 0){\\n        if(target==0 && arr[0]==0)\\n            return 2;\\n        if(target==0 || target == arr[0])\\n            return 1;\\n        return 0;\\n    }\\n    \\n    if(dp[ind][target]!=-1)\\n        return dp[ind][target];\\n        \\n    int notTaken = countPartitionsUtil(ind-1,target,arr,dp);\\n    \\n    int taken = 0;\\n    if(arr[ind]<=target)\\n        taken = countPartitionsUtil(ind-1,target-arr[ind],arr,dp);\\n        \\n    return dp[ind][target]= (notTaken + taken);\\n}\\n\\nstatic int targetSum(int n,int target,int[] arr){\\n    int totSum = 0;\\n    for(int i=0; i<arr.length;i++){\\n        totSum += arr[i];\\n    }\\n    \\n    //Checking for edge cases\\n    if(totSum-target<0) return 0;\\n    if((totSum-target)%2==1) return 0;\\n    \\n    int s2 = (totSum-target)/2;\\n    \\n    int dp[][]=new int[n][s2+1];\\n    for(int row[]: dp)\\n    Arrays.fill(row,-1);\\n    return countPartitionsUtil(n-1,s2,arr,dp);\\n}\\n`"
                    },
                    {
                        "username": "hosua",
                        "content": "In the official solution for approach #2, the post states:\n\n`The factor of total has been added as an offset to the sum value to map all the sums possible to positive integer range. By making use of memoization, we can get the result of each redundant function call in constant time.`\n\nCan someone explain why the memo is being indexed with `total+sum`? I tried it with just `sum` and it does not work, I don't understand why.\n\n\nEDIT: Figured it out literally 2 seconds after posting this lol. I'll leave this here incase someone runs into the same question. \nIt's because of the possibility of a negative sum, you cannot have a negative index, so an offset of `total` fixes this issue."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int backtrace(vector<int>& nums, int it, int sum, int target, map<string, int>& memo) {\\n        \\n        string key = to_string(it) + \",\" + to_string(sum);\\n\\n        if(it >= nums.size() ) {\\n            if(sum == target) {\\n                memo[key] = 1;\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if(memo.find(key) != memo.end()) {\\n            return memo[key];\\n        }\\n\\n        memo[key] = backtrace(nums, it + 1, sum + nums[it], target, memo) +\\n        backtrace(nums, it + 1, sum - nums[it], target, memo);\\n        return memo[key];\\n    }\\n\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        int res = 0;\\n        map<string,int> memo;\\n        backtrace(nums, 0, sum, target, memo);\\n        string key = \"0,0\";\\n        return memo[key];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "uavishal777",
                        "content": " for(int i=1;i<n+1;i++){\\n            for(int j=0;j<value+1;j++){      //@\\n                if(nums[i-1]<=j){\\n                    dp[i][j]=dp[i-1][j-nums[i-1]] + dp[i-1][j];\\n                }\\n                else{\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n            }\\n        }\\n\\nwhy after initialising the dp array i has to traverse array from j==0;\\n"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "because we need to handle the cases where multiple zeroes are there in the array which increases the number of subsets"
                    },
                    {
                        "username": "loser__",
                        "content": "class Solution {\\npublic:\\nint noofsubset(vector<int>&nums,int k,int n){\\n    int t[n+1][k+1];\\n    for(int i=0;i<=k;i++)\\n    t[0][i]=0;\\n    for(int i=0;i<=n;i++)\\n    t[i][0]=1;\\n    for(int i=1;i<=n;i++)\\n    {\\n        for(int j=0;j<=k;j++){\\n            \\n            if(nums[i-1]<=j){\\n            t[i][j]=t[i-1][j-nums[i-1]] +t[i-1][j];\\n            }\\n            else\\n            t[i][j]=t[i-1][j];\\n        }\\n    }\\n    return t[n][k];\\n\\n}\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum=0;\\n        target=abs(target);\\n        for(int i=0;i<n;i++){\\nsum+=nums[i];\\n        }\\n        if(((sum + target) % 2 != 0) || (target > sum))\\n        return 0;\\n        int k=(sum+target)/2;\\n      return  noofsubset(nums,k,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "braads07",
                        "content": "what is the error, anyone?\\n\\n \\nclass Solution {\\npublic:\\n    int solve(int n, int target , vector<vector<int>>&dp , vector<int>nums , int sum)\\n    {\\n        // n is basically representing the index\\n        if(n==0)\\n        {\\n            if((sum + nums[0])==target)\\n            return 1;\\n            else\\n            return 0;\\n        }\\n        // dp ki condition\\n        if(dp[n][sum]!=-1)\\n        return dp[n][sum];\\n\\n        return dp[n][sum] =( solve(n-1 , target,dp ,nums , sum- nums[n]) + solve(n-1 , target, dp , nums , sum+ nums[n]));\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n\\n        int count=0;\\n        vector<vector<int>>dp(nums.size()+1, vector<int>(target+1 , -1));\\n        int g=solve(nums.size()-1, target ,dp , nums , count );\\n        return g;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ra_hul",
                        "content": "Iterative solution -  Time & Space - O(n) \\n\\n```\\n        n = len(nums)\\n        root = (0, target, False)\\n        stack = [root]\\n        cache = {}\\n\\n        while len(stack) > 0:\\n\\n            idx, newTarget, visited = stack.pop()\\n\\n            if not visited:\\n                stack.append((idx, newTarget, True))\\n                if idx < n-1:\\n                    if (idx+1, newTarget-nums[idx]) not in cache:\\n                        stack.append((idx+1, newTarget-nums[idx], False))\\n                    if (idx+1, newTarget+nums[idx]) not in cache:\\n                        stack.append((idx+1, newTarget+nums[idx], False))\\n            else:\\n                value = 0\\n                if idx == n-1:\\n                    if newTarget == nums[idx]:\\n                        value += 1\\n                    if newTarget == -nums[idx]:\\n                        value += 1\\n                else:\\n                    value = cache[(idx+1, newTarget-nums[idx])] + cache[(idx+1, newTarget+nums[idx])]\\n                \\n                cache[(idx, newTarget)] = value\\n        \\n        return cache[0, target]\\n```\\n\\nThis solution solves the TargetSum problem by using postorder traversal on the expected recursion tree. It caches the nodes that are already computed."
                    }
                ]
            },
            {
                "id": 1764211,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Well, the constraints are very misleading. The tiny input size suggests an exponential backtraking approach.\\nYet, both my backtracking solutions (one using a bitmask, the other doing an explicit recursive backtracking) get rejected with a TLE... If the only accepted solution is DP, it is a weird \"trap\" to suggest backtracking with such low constraints"
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "nums = [0,0,0,0,0,0,0,0,1]\\ntarget = 1\\nOutput = 1\\nExpected = 256\\n\\nsomebody help me to understand the above testcase."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "Each 0 can be +0 or -0. If \"nums\" has n zeros, then there will be 2^n cases. So I calculate the number of zeros in \"nums\" and create a new non-zero list. The result lf non-zero list should multiply  2^n."
                    },
                    {
                        "username": "yaswanthkosuru",
                        "content": "\nplease solve it can any one why it exceeding time limit ''' `'''class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        ans=0\n        temp1,temp2=[],[]\n        temp1.append(nums[0])\n        temp1.append(-nums[0])\n        for i in range(1,len(nums)):\n            for k in temp1:\n                temp2.append(k+nums[i])\n                temp2.append(k-nums[i])\n            temp1=temp2.copy()\n            temp2=[]\n        return temp1.count(target).`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nstatic int countPartitionsUtil(int ind, int target, int[] arr,int[][] dp){\\n\\n     if(ind == 0){\\n        if(target==0 && arr[0]==0)\\n            return 2;\\n        if(target==0 || target == arr[0])\\n            return 1;\\n        return 0;\\n    }\\n    \\n    if(dp[ind][target]!=-1)\\n        return dp[ind][target];\\n        \\n    int notTaken = countPartitionsUtil(ind-1,target,arr,dp);\\n    \\n    int taken = 0;\\n    if(arr[ind]<=target)\\n        taken = countPartitionsUtil(ind-1,target-arr[ind],arr,dp);\\n        \\n    return dp[ind][target]= (notTaken + taken);\\n}\\n\\nstatic int targetSum(int n,int target,int[] arr){\\n    int totSum = 0;\\n    for(int i=0; i<arr.length;i++){\\n        totSum += arr[i];\\n    }\\n    \\n    //Checking for edge cases\\n    if(totSum-target<0) return 0;\\n    if((totSum-target)%2==1) return 0;\\n    \\n    int s2 = (totSum-target)/2;\\n    \\n    int dp[][]=new int[n][s2+1];\\n    for(int row[]: dp)\\n    Arrays.fill(row,-1);\\n    return countPartitionsUtil(n-1,s2,arr,dp);\\n}\\n`"
                    },
                    {
                        "username": "hosua",
                        "content": "In the official solution for approach #2, the post states:\n\n`The factor of total has been added as an offset to the sum value to map all the sums possible to positive integer range. By making use of memoization, we can get the result of each redundant function call in constant time.`\n\nCan someone explain why the memo is being indexed with `total+sum`? I tried it with just `sum` and it does not work, I don't understand why.\n\n\nEDIT: Figured it out literally 2 seconds after posting this lol. I'll leave this here incase someone runs into the same question. \nIt's because of the possibility of a negative sum, you cannot have a negative index, so an offset of `total` fixes this issue."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int backtrace(vector<int>& nums, int it, int sum, int target, map<string, int>& memo) {\\n        \\n        string key = to_string(it) + \",\" + to_string(sum);\\n\\n        if(it >= nums.size() ) {\\n            if(sum == target) {\\n                memo[key] = 1;\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if(memo.find(key) != memo.end()) {\\n            return memo[key];\\n        }\\n\\n        memo[key] = backtrace(nums, it + 1, sum + nums[it], target, memo) +\\n        backtrace(nums, it + 1, sum - nums[it], target, memo);\\n        return memo[key];\\n    }\\n\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        int res = 0;\\n        map<string,int> memo;\\n        backtrace(nums, 0, sum, target, memo);\\n        string key = \"0,0\";\\n        return memo[key];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "uavishal777",
                        "content": " for(int i=1;i<n+1;i++){\\n            for(int j=0;j<value+1;j++){      //@\\n                if(nums[i-1]<=j){\\n                    dp[i][j]=dp[i-1][j-nums[i-1]] + dp[i-1][j];\\n                }\\n                else{\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n            }\\n        }\\n\\nwhy after initialising the dp array i has to traverse array from j==0;\\n"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "because we need to handle the cases where multiple zeroes are there in the array which increases the number of subsets"
                    },
                    {
                        "username": "loser__",
                        "content": "class Solution {\\npublic:\\nint noofsubset(vector<int>&nums,int k,int n){\\n    int t[n+1][k+1];\\n    for(int i=0;i<=k;i++)\\n    t[0][i]=0;\\n    for(int i=0;i<=n;i++)\\n    t[i][0]=1;\\n    for(int i=1;i<=n;i++)\\n    {\\n        for(int j=0;j<=k;j++){\\n            \\n            if(nums[i-1]<=j){\\n            t[i][j]=t[i-1][j-nums[i-1]] +t[i-1][j];\\n            }\\n            else\\n            t[i][j]=t[i-1][j];\\n        }\\n    }\\n    return t[n][k];\\n\\n}\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum=0;\\n        target=abs(target);\\n        for(int i=0;i<n;i++){\\nsum+=nums[i];\\n        }\\n        if(((sum + target) % 2 != 0) || (target > sum))\\n        return 0;\\n        int k=(sum+target)/2;\\n      return  noofsubset(nums,k,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "braads07",
                        "content": "what is the error, anyone?\\n\\n \\nclass Solution {\\npublic:\\n    int solve(int n, int target , vector<vector<int>>&dp , vector<int>nums , int sum)\\n    {\\n        // n is basically representing the index\\n        if(n==0)\\n        {\\n            if((sum + nums[0])==target)\\n            return 1;\\n            else\\n            return 0;\\n        }\\n        // dp ki condition\\n        if(dp[n][sum]!=-1)\\n        return dp[n][sum];\\n\\n        return dp[n][sum] =( solve(n-1 , target,dp ,nums , sum- nums[n]) + solve(n-1 , target, dp , nums , sum+ nums[n]));\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n\\n        int count=0;\\n        vector<vector<int>>dp(nums.size()+1, vector<int>(target+1 , -1));\\n        int g=solve(nums.size()-1, target ,dp , nums , count );\\n        return g;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ra_hul",
                        "content": "Iterative solution -  Time & Space - O(n) \\n\\n```\\n        n = len(nums)\\n        root = (0, target, False)\\n        stack = [root]\\n        cache = {}\\n\\n        while len(stack) > 0:\\n\\n            idx, newTarget, visited = stack.pop()\\n\\n            if not visited:\\n                stack.append((idx, newTarget, True))\\n                if idx < n-1:\\n                    if (idx+1, newTarget-nums[idx]) not in cache:\\n                        stack.append((idx+1, newTarget-nums[idx], False))\\n                    if (idx+1, newTarget+nums[idx]) not in cache:\\n                        stack.append((idx+1, newTarget+nums[idx], False))\\n            else:\\n                value = 0\\n                if idx == n-1:\\n                    if newTarget == nums[idx]:\\n                        value += 1\\n                    if newTarget == -nums[idx]:\\n                        value += 1\\n                else:\\n                    value = cache[(idx+1, newTarget-nums[idx])] + cache[(idx+1, newTarget+nums[idx])]\\n                \\n                cache[(idx, newTarget)] = value\\n        \\n        return cache[0, target]\\n```\\n\\nThis solution solves the TargetSum problem by using postorder traversal on the expected recursion tree. It caches the nodes that are already computed."
                    }
                ]
            },
            {
                "id": 1740994,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Well, the constraints are very misleading. The tiny input size suggests an exponential backtraking approach.\\nYet, both my backtracking solutions (one using a bitmask, the other doing an explicit recursive backtracking) get rejected with a TLE... If the only accepted solution is DP, it is a weird \"trap\" to suggest backtracking with such low constraints"
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "nums = [0,0,0,0,0,0,0,0,1]\\ntarget = 1\\nOutput = 1\\nExpected = 256\\n\\nsomebody help me to understand the above testcase."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "Each 0 can be +0 or -0. If \"nums\" has n zeros, then there will be 2^n cases. So I calculate the number of zeros in \"nums\" and create a new non-zero list. The result lf non-zero list should multiply  2^n."
                    },
                    {
                        "username": "yaswanthkosuru",
                        "content": "\nplease solve it can any one why it exceeding time limit ''' `'''class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        ans=0\n        temp1,temp2=[],[]\n        temp1.append(nums[0])\n        temp1.append(-nums[0])\n        for i in range(1,len(nums)):\n            for k in temp1:\n                temp2.append(k+nums[i])\n                temp2.append(k-nums[i])\n            temp1=temp2.copy()\n            temp2=[]\n        return temp1.count(target).`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nstatic int countPartitionsUtil(int ind, int target, int[] arr,int[][] dp){\\n\\n     if(ind == 0){\\n        if(target==0 && arr[0]==0)\\n            return 2;\\n        if(target==0 || target == arr[0])\\n            return 1;\\n        return 0;\\n    }\\n    \\n    if(dp[ind][target]!=-1)\\n        return dp[ind][target];\\n        \\n    int notTaken = countPartitionsUtil(ind-1,target,arr,dp);\\n    \\n    int taken = 0;\\n    if(arr[ind]<=target)\\n        taken = countPartitionsUtil(ind-1,target-arr[ind],arr,dp);\\n        \\n    return dp[ind][target]= (notTaken + taken);\\n}\\n\\nstatic int targetSum(int n,int target,int[] arr){\\n    int totSum = 0;\\n    for(int i=0; i<arr.length;i++){\\n        totSum += arr[i];\\n    }\\n    \\n    //Checking for edge cases\\n    if(totSum-target<0) return 0;\\n    if((totSum-target)%2==1) return 0;\\n    \\n    int s2 = (totSum-target)/2;\\n    \\n    int dp[][]=new int[n][s2+1];\\n    for(int row[]: dp)\\n    Arrays.fill(row,-1);\\n    return countPartitionsUtil(n-1,s2,arr,dp);\\n}\\n`"
                    },
                    {
                        "username": "hosua",
                        "content": "In the official solution for approach #2, the post states:\n\n`The factor of total has been added as an offset to the sum value to map all the sums possible to positive integer range. By making use of memoization, we can get the result of each redundant function call in constant time.`\n\nCan someone explain why the memo is being indexed with `total+sum`? I tried it with just `sum` and it does not work, I don't understand why.\n\n\nEDIT: Figured it out literally 2 seconds after posting this lol. I'll leave this here incase someone runs into the same question. \nIt's because of the possibility of a negative sum, you cannot have a negative index, so an offset of `total` fixes this issue."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int backtrace(vector<int>& nums, int it, int sum, int target, map<string, int>& memo) {\\n        \\n        string key = to_string(it) + \",\" + to_string(sum);\\n\\n        if(it >= nums.size() ) {\\n            if(sum == target) {\\n                memo[key] = 1;\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if(memo.find(key) != memo.end()) {\\n            return memo[key];\\n        }\\n\\n        memo[key] = backtrace(nums, it + 1, sum + nums[it], target, memo) +\\n        backtrace(nums, it + 1, sum - nums[it], target, memo);\\n        return memo[key];\\n    }\\n\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        int res = 0;\\n        map<string,int> memo;\\n        backtrace(nums, 0, sum, target, memo);\\n        string key = \"0,0\";\\n        return memo[key];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "uavishal777",
                        "content": " for(int i=1;i<n+1;i++){\\n            for(int j=0;j<value+1;j++){      //@\\n                if(nums[i-1]<=j){\\n                    dp[i][j]=dp[i-1][j-nums[i-1]] + dp[i-1][j];\\n                }\\n                else{\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n            }\\n        }\\n\\nwhy after initialising the dp array i has to traverse array from j==0;\\n"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "because we need to handle the cases where multiple zeroes are there in the array which increases the number of subsets"
                    },
                    {
                        "username": "loser__",
                        "content": "class Solution {\\npublic:\\nint noofsubset(vector<int>&nums,int k,int n){\\n    int t[n+1][k+1];\\n    for(int i=0;i<=k;i++)\\n    t[0][i]=0;\\n    for(int i=0;i<=n;i++)\\n    t[i][0]=1;\\n    for(int i=1;i<=n;i++)\\n    {\\n        for(int j=0;j<=k;j++){\\n            \\n            if(nums[i-1]<=j){\\n            t[i][j]=t[i-1][j-nums[i-1]] +t[i-1][j];\\n            }\\n            else\\n            t[i][j]=t[i-1][j];\\n        }\\n    }\\n    return t[n][k];\\n\\n}\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum=0;\\n        target=abs(target);\\n        for(int i=0;i<n;i++){\\nsum+=nums[i];\\n        }\\n        if(((sum + target) % 2 != 0) || (target > sum))\\n        return 0;\\n        int k=(sum+target)/2;\\n      return  noofsubset(nums,k,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "braads07",
                        "content": "what is the error, anyone?\\n\\n \\nclass Solution {\\npublic:\\n    int solve(int n, int target , vector<vector<int>>&dp , vector<int>nums , int sum)\\n    {\\n        // n is basically representing the index\\n        if(n==0)\\n        {\\n            if((sum + nums[0])==target)\\n            return 1;\\n            else\\n            return 0;\\n        }\\n        // dp ki condition\\n        if(dp[n][sum]!=-1)\\n        return dp[n][sum];\\n\\n        return dp[n][sum] =( solve(n-1 , target,dp ,nums , sum- nums[n]) + solve(n-1 , target, dp , nums , sum+ nums[n]));\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n\\n        int count=0;\\n        vector<vector<int>>dp(nums.size()+1, vector<int>(target+1 , -1));\\n        int g=solve(nums.size()-1, target ,dp , nums , count );\\n        return g;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ra_hul",
                        "content": "Iterative solution -  Time & Space - O(n) \\n\\n```\\n        n = len(nums)\\n        root = (0, target, False)\\n        stack = [root]\\n        cache = {}\\n\\n        while len(stack) > 0:\\n\\n            idx, newTarget, visited = stack.pop()\\n\\n            if not visited:\\n                stack.append((idx, newTarget, True))\\n                if idx < n-1:\\n                    if (idx+1, newTarget-nums[idx]) not in cache:\\n                        stack.append((idx+1, newTarget-nums[idx], False))\\n                    if (idx+1, newTarget+nums[idx]) not in cache:\\n                        stack.append((idx+1, newTarget+nums[idx], False))\\n            else:\\n                value = 0\\n                if idx == n-1:\\n                    if newTarget == nums[idx]:\\n                        value += 1\\n                    if newTarget == -nums[idx]:\\n                        value += 1\\n                else:\\n                    value = cache[(idx+1, newTarget-nums[idx])] + cache[(idx+1, newTarget+nums[idx])]\\n                \\n                cache[(idx, newTarget)] = value\\n        \\n        return cache[0, target]\\n```\\n\\nThis solution solves the TargetSum problem by using postorder traversal on the expected recursion tree. It caches the nodes that are already computed."
                    }
                ]
            },
            {
                "id": 1734999,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Well, the constraints are very misleading. The tiny input size suggests an exponential backtraking approach.\\nYet, both my backtracking solutions (one using a bitmask, the other doing an explicit recursive backtracking) get rejected with a TLE... If the only accepted solution is DP, it is a weird \"trap\" to suggest backtracking with such low constraints"
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "nums = [0,0,0,0,0,0,0,0,1]\\ntarget = 1\\nOutput = 1\\nExpected = 256\\n\\nsomebody help me to understand the above testcase."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "Each 0 can be +0 or -0. If \"nums\" has n zeros, then there will be 2^n cases. So I calculate the number of zeros in \"nums\" and create a new non-zero list. The result lf non-zero list should multiply  2^n."
                    },
                    {
                        "username": "yaswanthkosuru",
                        "content": "\nplease solve it can any one why it exceeding time limit ''' `'''class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        ans=0\n        temp1,temp2=[],[]\n        temp1.append(nums[0])\n        temp1.append(-nums[0])\n        for i in range(1,len(nums)):\n            for k in temp1:\n                temp2.append(k+nums[i])\n                temp2.append(k-nums[i])\n            temp1=temp2.copy()\n            temp2=[]\n        return temp1.count(target).`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nstatic int countPartitionsUtil(int ind, int target, int[] arr,int[][] dp){\\n\\n     if(ind == 0){\\n        if(target==0 && arr[0]==0)\\n            return 2;\\n        if(target==0 || target == arr[0])\\n            return 1;\\n        return 0;\\n    }\\n    \\n    if(dp[ind][target]!=-1)\\n        return dp[ind][target];\\n        \\n    int notTaken = countPartitionsUtil(ind-1,target,arr,dp);\\n    \\n    int taken = 0;\\n    if(arr[ind]<=target)\\n        taken = countPartitionsUtil(ind-1,target-arr[ind],arr,dp);\\n        \\n    return dp[ind][target]= (notTaken + taken);\\n}\\n\\nstatic int targetSum(int n,int target,int[] arr){\\n    int totSum = 0;\\n    for(int i=0; i<arr.length;i++){\\n        totSum += arr[i];\\n    }\\n    \\n    //Checking for edge cases\\n    if(totSum-target<0) return 0;\\n    if((totSum-target)%2==1) return 0;\\n    \\n    int s2 = (totSum-target)/2;\\n    \\n    int dp[][]=new int[n][s2+1];\\n    for(int row[]: dp)\\n    Arrays.fill(row,-1);\\n    return countPartitionsUtil(n-1,s2,arr,dp);\\n}\\n`"
                    },
                    {
                        "username": "hosua",
                        "content": "In the official solution for approach #2, the post states:\n\n`The factor of total has been added as an offset to the sum value to map all the sums possible to positive integer range. By making use of memoization, we can get the result of each redundant function call in constant time.`\n\nCan someone explain why the memo is being indexed with `total+sum`? I tried it with just `sum` and it does not work, I don't understand why.\n\n\nEDIT: Figured it out literally 2 seconds after posting this lol. I'll leave this here incase someone runs into the same question. \nIt's because of the possibility of a negative sum, you cannot have a negative index, so an offset of `total` fixes this issue."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int backtrace(vector<int>& nums, int it, int sum, int target, map<string, int>& memo) {\\n        \\n        string key = to_string(it) + \",\" + to_string(sum);\\n\\n        if(it >= nums.size() ) {\\n            if(sum == target) {\\n                memo[key] = 1;\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if(memo.find(key) != memo.end()) {\\n            return memo[key];\\n        }\\n\\n        memo[key] = backtrace(nums, it + 1, sum + nums[it], target, memo) +\\n        backtrace(nums, it + 1, sum - nums[it], target, memo);\\n        return memo[key];\\n    }\\n\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        int res = 0;\\n        map<string,int> memo;\\n        backtrace(nums, 0, sum, target, memo);\\n        string key = \"0,0\";\\n        return memo[key];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "uavishal777",
                        "content": " for(int i=1;i<n+1;i++){\\n            for(int j=0;j<value+1;j++){      //@\\n                if(nums[i-1]<=j){\\n                    dp[i][j]=dp[i-1][j-nums[i-1]] + dp[i-1][j];\\n                }\\n                else{\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n            }\\n        }\\n\\nwhy after initialising the dp array i has to traverse array from j==0;\\n"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "because we need to handle the cases where multiple zeroes are there in the array which increases the number of subsets"
                    },
                    {
                        "username": "loser__",
                        "content": "class Solution {\\npublic:\\nint noofsubset(vector<int>&nums,int k,int n){\\n    int t[n+1][k+1];\\n    for(int i=0;i<=k;i++)\\n    t[0][i]=0;\\n    for(int i=0;i<=n;i++)\\n    t[i][0]=1;\\n    for(int i=1;i<=n;i++)\\n    {\\n        for(int j=0;j<=k;j++){\\n            \\n            if(nums[i-1]<=j){\\n            t[i][j]=t[i-1][j-nums[i-1]] +t[i-1][j];\\n            }\\n            else\\n            t[i][j]=t[i-1][j];\\n        }\\n    }\\n    return t[n][k];\\n\\n}\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum=0;\\n        target=abs(target);\\n        for(int i=0;i<n;i++){\\nsum+=nums[i];\\n        }\\n        if(((sum + target) % 2 != 0) || (target > sum))\\n        return 0;\\n        int k=(sum+target)/2;\\n      return  noofsubset(nums,k,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "braads07",
                        "content": "what is the error, anyone?\\n\\n \\nclass Solution {\\npublic:\\n    int solve(int n, int target , vector<vector<int>>&dp , vector<int>nums , int sum)\\n    {\\n        // n is basically representing the index\\n        if(n==0)\\n        {\\n            if((sum + nums[0])==target)\\n            return 1;\\n            else\\n            return 0;\\n        }\\n        // dp ki condition\\n        if(dp[n][sum]!=-1)\\n        return dp[n][sum];\\n\\n        return dp[n][sum] =( solve(n-1 , target,dp ,nums , sum- nums[n]) + solve(n-1 , target, dp , nums , sum+ nums[n]));\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n\\n        int count=0;\\n        vector<vector<int>>dp(nums.size()+1, vector<int>(target+1 , -1));\\n        int g=solve(nums.size()-1, target ,dp , nums , count );\\n        return g;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ra_hul",
                        "content": "Iterative solution -  Time & Space - O(n) \\n\\n```\\n        n = len(nums)\\n        root = (0, target, False)\\n        stack = [root]\\n        cache = {}\\n\\n        while len(stack) > 0:\\n\\n            idx, newTarget, visited = stack.pop()\\n\\n            if not visited:\\n                stack.append((idx, newTarget, True))\\n                if idx < n-1:\\n                    if (idx+1, newTarget-nums[idx]) not in cache:\\n                        stack.append((idx+1, newTarget-nums[idx], False))\\n                    if (idx+1, newTarget+nums[idx]) not in cache:\\n                        stack.append((idx+1, newTarget+nums[idx], False))\\n            else:\\n                value = 0\\n                if idx == n-1:\\n                    if newTarget == nums[idx]:\\n                        value += 1\\n                    if newTarget == -nums[idx]:\\n                        value += 1\\n                else:\\n                    value = cache[(idx+1, newTarget-nums[idx])] + cache[(idx+1, newTarget+nums[idx])]\\n                \\n                cache[(idx, newTarget)] = value\\n        \\n        return cache[0, target]\\n```\\n\\nThis solution solves the TargetSum problem by using postorder traversal on the expected recursion tree. It caches the nodes that are already computed."
                    }
                ]
            },
            {
                "id": 1714349,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Well, the constraints are very misleading. The tiny input size suggests an exponential backtraking approach.\\nYet, both my backtracking solutions (one using a bitmask, the other doing an explicit recursive backtracking) get rejected with a TLE... If the only accepted solution is DP, it is a weird \"trap\" to suggest backtracking with such low constraints"
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "nums = [0,0,0,0,0,0,0,0,1]\\ntarget = 1\\nOutput = 1\\nExpected = 256\\n\\nsomebody help me to understand the above testcase."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "Each 0 can be +0 or -0. If \"nums\" has n zeros, then there will be 2^n cases. So I calculate the number of zeros in \"nums\" and create a new non-zero list. The result lf non-zero list should multiply  2^n."
                    },
                    {
                        "username": "yaswanthkosuru",
                        "content": "\nplease solve it can any one why it exceeding time limit ''' `'''class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        ans=0\n        temp1,temp2=[],[]\n        temp1.append(nums[0])\n        temp1.append(-nums[0])\n        for i in range(1,len(nums)):\n            for k in temp1:\n                temp2.append(k+nums[i])\n                temp2.append(k-nums[i])\n            temp1=temp2.copy()\n            temp2=[]\n        return temp1.count(target).`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nstatic int countPartitionsUtil(int ind, int target, int[] arr,int[][] dp){\\n\\n     if(ind == 0){\\n        if(target==0 && arr[0]==0)\\n            return 2;\\n        if(target==0 || target == arr[0])\\n            return 1;\\n        return 0;\\n    }\\n    \\n    if(dp[ind][target]!=-1)\\n        return dp[ind][target];\\n        \\n    int notTaken = countPartitionsUtil(ind-1,target,arr,dp);\\n    \\n    int taken = 0;\\n    if(arr[ind]<=target)\\n        taken = countPartitionsUtil(ind-1,target-arr[ind],arr,dp);\\n        \\n    return dp[ind][target]= (notTaken + taken);\\n}\\n\\nstatic int targetSum(int n,int target,int[] arr){\\n    int totSum = 0;\\n    for(int i=0; i<arr.length;i++){\\n        totSum += arr[i];\\n    }\\n    \\n    //Checking for edge cases\\n    if(totSum-target<0) return 0;\\n    if((totSum-target)%2==1) return 0;\\n    \\n    int s2 = (totSum-target)/2;\\n    \\n    int dp[][]=new int[n][s2+1];\\n    for(int row[]: dp)\\n    Arrays.fill(row,-1);\\n    return countPartitionsUtil(n-1,s2,arr,dp);\\n}\\n`"
                    },
                    {
                        "username": "hosua",
                        "content": "In the official solution for approach #2, the post states:\n\n`The factor of total has been added as an offset to the sum value to map all the sums possible to positive integer range. By making use of memoization, we can get the result of each redundant function call in constant time.`\n\nCan someone explain why the memo is being indexed with `total+sum`? I tried it with just `sum` and it does not work, I don't understand why.\n\n\nEDIT: Figured it out literally 2 seconds after posting this lol. I'll leave this here incase someone runs into the same question. \nIt's because of the possibility of a negative sum, you cannot have a negative index, so an offset of `total` fixes this issue."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int backtrace(vector<int>& nums, int it, int sum, int target, map<string, int>& memo) {\\n        \\n        string key = to_string(it) + \",\" + to_string(sum);\\n\\n        if(it >= nums.size() ) {\\n            if(sum == target) {\\n                memo[key] = 1;\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if(memo.find(key) != memo.end()) {\\n            return memo[key];\\n        }\\n\\n        memo[key] = backtrace(nums, it + 1, sum + nums[it], target, memo) +\\n        backtrace(nums, it + 1, sum - nums[it], target, memo);\\n        return memo[key];\\n    }\\n\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        int res = 0;\\n        map<string,int> memo;\\n        backtrace(nums, 0, sum, target, memo);\\n        string key = \"0,0\";\\n        return memo[key];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "uavishal777",
                        "content": " for(int i=1;i<n+1;i++){\\n            for(int j=0;j<value+1;j++){      //@\\n                if(nums[i-1]<=j){\\n                    dp[i][j]=dp[i-1][j-nums[i-1]] + dp[i-1][j];\\n                }\\n                else{\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n            }\\n        }\\n\\nwhy after initialising the dp array i has to traverse array from j==0;\\n"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "because we need to handle the cases where multiple zeroes are there in the array which increases the number of subsets"
                    },
                    {
                        "username": "loser__",
                        "content": "class Solution {\\npublic:\\nint noofsubset(vector<int>&nums,int k,int n){\\n    int t[n+1][k+1];\\n    for(int i=0;i<=k;i++)\\n    t[0][i]=0;\\n    for(int i=0;i<=n;i++)\\n    t[i][0]=1;\\n    for(int i=1;i<=n;i++)\\n    {\\n        for(int j=0;j<=k;j++){\\n            \\n            if(nums[i-1]<=j){\\n            t[i][j]=t[i-1][j-nums[i-1]] +t[i-1][j];\\n            }\\n            else\\n            t[i][j]=t[i-1][j];\\n        }\\n    }\\n    return t[n][k];\\n\\n}\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum=0;\\n        target=abs(target);\\n        for(int i=0;i<n;i++){\\nsum+=nums[i];\\n        }\\n        if(((sum + target) % 2 != 0) || (target > sum))\\n        return 0;\\n        int k=(sum+target)/2;\\n      return  noofsubset(nums,k,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "braads07",
                        "content": "what is the error, anyone?\\n\\n \\nclass Solution {\\npublic:\\n    int solve(int n, int target , vector<vector<int>>&dp , vector<int>nums , int sum)\\n    {\\n        // n is basically representing the index\\n        if(n==0)\\n        {\\n            if((sum + nums[0])==target)\\n            return 1;\\n            else\\n            return 0;\\n        }\\n        // dp ki condition\\n        if(dp[n][sum]!=-1)\\n        return dp[n][sum];\\n\\n        return dp[n][sum] =( solve(n-1 , target,dp ,nums , sum- nums[n]) + solve(n-1 , target, dp , nums , sum+ nums[n]));\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n\\n        int count=0;\\n        vector<vector<int>>dp(nums.size()+1, vector<int>(target+1 , -1));\\n        int g=solve(nums.size()-1, target ,dp , nums , count );\\n        return g;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ra_hul",
                        "content": "Iterative solution -  Time & Space - O(n) \\n\\n```\\n        n = len(nums)\\n        root = (0, target, False)\\n        stack = [root]\\n        cache = {}\\n\\n        while len(stack) > 0:\\n\\n            idx, newTarget, visited = stack.pop()\\n\\n            if not visited:\\n                stack.append((idx, newTarget, True))\\n                if idx < n-1:\\n                    if (idx+1, newTarget-nums[idx]) not in cache:\\n                        stack.append((idx+1, newTarget-nums[idx], False))\\n                    if (idx+1, newTarget+nums[idx]) not in cache:\\n                        stack.append((idx+1, newTarget+nums[idx], False))\\n            else:\\n                value = 0\\n                if idx == n-1:\\n                    if newTarget == nums[idx]:\\n                        value += 1\\n                    if newTarget == -nums[idx]:\\n                        value += 1\\n                else:\\n                    value = cache[(idx+1, newTarget-nums[idx])] + cache[(idx+1, newTarget+nums[idx])]\\n                \\n                cache[(idx, newTarget)] = value\\n        \\n        return cache[0, target]\\n```\\n\\nThis solution solves the TargetSum problem by using postorder traversal on the expected recursion tree. It caches the nodes that are already computed."
                    }
                ]
            },
            {
                "id": 1707200,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Well, the constraints are very misleading. The tiny input size suggests an exponential backtraking approach.\\nYet, both my backtracking solutions (one using a bitmask, the other doing an explicit recursive backtracking) get rejected with a TLE... If the only accepted solution is DP, it is a weird \"trap\" to suggest backtracking with such low constraints"
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "nums = [0,0,0,0,0,0,0,0,1]\\ntarget = 1\\nOutput = 1\\nExpected = 256\\n\\nsomebody help me to understand the above testcase."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "Each 0 can be +0 or -0. If \"nums\" has n zeros, then there will be 2^n cases. So I calculate the number of zeros in \"nums\" and create a new non-zero list. The result lf non-zero list should multiply  2^n."
                    },
                    {
                        "username": "yaswanthkosuru",
                        "content": "\nplease solve it can any one why it exceeding time limit ''' `'''class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        ans=0\n        temp1,temp2=[],[]\n        temp1.append(nums[0])\n        temp1.append(-nums[0])\n        for i in range(1,len(nums)):\n            for k in temp1:\n                temp2.append(k+nums[i])\n                temp2.append(k-nums[i])\n            temp1=temp2.copy()\n            temp2=[]\n        return temp1.count(target).`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nstatic int countPartitionsUtil(int ind, int target, int[] arr,int[][] dp){\\n\\n     if(ind == 0){\\n        if(target==0 && arr[0]==0)\\n            return 2;\\n        if(target==0 || target == arr[0])\\n            return 1;\\n        return 0;\\n    }\\n    \\n    if(dp[ind][target]!=-1)\\n        return dp[ind][target];\\n        \\n    int notTaken = countPartitionsUtil(ind-1,target,arr,dp);\\n    \\n    int taken = 0;\\n    if(arr[ind]<=target)\\n        taken = countPartitionsUtil(ind-1,target-arr[ind],arr,dp);\\n        \\n    return dp[ind][target]= (notTaken + taken);\\n}\\n\\nstatic int targetSum(int n,int target,int[] arr){\\n    int totSum = 0;\\n    for(int i=0; i<arr.length;i++){\\n        totSum += arr[i];\\n    }\\n    \\n    //Checking for edge cases\\n    if(totSum-target<0) return 0;\\n    if((totSum-target)%2==1) return 0;\\n    \\n    int s2 = (totSum-target)/2;\\n    \\n    int dp[][]=new int[n][s2+1];\\n    for(int row[]: dp)\\n    Arrays.fill(row,-1);\\n    return countPartitionsUtil(n-1,s2,arr,dp);\\n}\\n`"
                    },
                    {
                        "username": "hosua",
                        "content": "In the official solution for approach #2, the post states:\n\n`The factor of total has been added as an offset to the sum value to map all the sums possible to positive integer range. By making use of memoization, we can get the result of each redundant function call in constant time.`\n\nCan someone explain why the memo is being indexed with `total+sum`? I tried it with just `sum` and it does not work, I don't understand why.\n\n\nEDIT: Figured it out literally 2 seconds after posting this lol. I'll leave this here incase someone runs into the same question. \nIt's because of the possibility of a negative sum, you cannot have a negative index, so an offset of `total` fixes this issue."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int backtrace(vector<int>& nums, int it, int sum, int target, map<string, int>& memo) {\\n        \\n        string key = to_string(it) + \",\" + to_string(sum);\\n\\n        if(it >= nums.size() ) {\\n            if(sum == target) {\\n                memo[key] = 1;\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if(memo.find(key) != memo.end()) {\\n            return memo[key];\\n        }\\n\\n        memo[key] = backtrace(nums, it + 1, sum + nums[it], target, memo) +\\n        backtrace(nums, it + 1, sum - nums[it], target, memo);\\n        return memo[key];\\n    }\\n\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int sum = 0;\\n        int res = 0;\\n        map<string,int> memo;\\n        backtrace(nums, 0, sum, target, memo);\\n        string key = \"0,0\";\\n        return memo[key];\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "uavishal777",
                        "content": " for(int i=1;i<n+1;i++){\\n            for(int j=0;j<value+1;j++){      //@\\n                if(nums[i-1]<=j){\\n                    dp[i][j]=dp[i-1][j-nums[i-1]] + dp[i-1][j];\\n                }\\n                else{\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n            }\\n        }\\n\\nwhy after initialising the dp array i has to traverse array from j==0;\\n"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "because we need to handle the cases where multiple zeroes are there in the array which increases the number of subsets"
                    },
                    {
                        "username": "loser__",
                        "content": "class Solution {\\npublic:\\nint noofsubset(vector<int>&nums,int k,int n){\\n    int t[n+1][k+1];\\n    for(int i=0;i<=k;i++)\\n    t[0][i]=0;\\n    for(int i=0;i<=n;i++)\\n    t[i][0]=1;\\n    for(int i=1;i<=n;i++)\\n    {\\n        for(int j=0;j<=k;j++){\\n            \\n            if(nums[i-1]<=j){\\n            t[i][j]=t[i-1][j-nums[i-1]] +t[i-1][j];\\n            }\\n            else\\n            t[i][j]=t[i-1][j];\\n        }\\n    }\\n    return t[n][k];\\n\\n}\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum=0;\\n        target=abs(target);\\n        for(int i=0;i<n;i++){\\nsum+=nums[i];\\n        }\\n        if(((sum + target) % 2 != 0) || (target > sum))\\n        return 0;\\n        int k=(sum+target)/2;\\n      return  noofsubset(nums,k,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "braads07",
                        "content": "what is the error, anyone?\\n\\n \\nclass Solution {\\npublic:\\n    int solve(int n, int target , vector<vector<int>>&dp , vector<int>nums , int sum)\\n    {\\n        // n is basically representing the index\\n        if(n==0)\\n        {\\n            if((sum + nums[0])==target)\\n            return 1;\\n            else\\n            return 0;\\n        }\\n        // dp ki condition\\n        if(dp[n][sum]!=-1)\\n        return dp[n][sum];\\n\\n        return dp[n][sum] =( solve(n-1 , target,dp ,nums , sum- nums[n]) + solve(n-1 , target, dp , nums , sum+ nums[n]));\\n    }\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n\\n        int count=0;\\n        vector<vector<int>>dp(nums.size()+1, vector<int>(target+1 , -1));\\n        int g=solve(nums.size()-1, target ,dp , nums , count );\\n        return g;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ra_hul",
                        "content": "Iterative solution -  Time & Space - O(n) \\n\\n```\\n        n = len(nums)\\n        root = (0, target, False)\\n        stack = [root]\\n        cache = {}\\n\\n        while len(stack) > 0:\\n\\n            idx, newTarget, visited = stack.pop()\\n\\n            if not visited:\\n                stack.append((idx, newTarget, True))\\n                if idx < n-1:\\n                    if (idx+1, newTarget-nums[idx]) not in cache:\\n                        stack.append((idx+1, newTarget-nums[idx], False))\\n                    if (idx+1, newTarget+nums[idx]) not in cache:\\n                        stack.append((idx+1, newTarget+nums[idx], False))\\n            else:\\n                value = 0\\n                if idx == n-1:\\n                    if newTarget == nums[idx]:\\n                        value += 1\\n                    if newTarget == -nums[idx]:\\n                        value += 1\\n                else:\\n                    value = cache[(idx+1, newTarget-nums[idx])] + cache[(idx+1, newTarget+nums[idx])]\\n                \\n                cache[(idx, newTarget)] = value\\n        \\n        return cache[0, target]\\n```\\n\\nThis solution solves the TargetSum problem by using postorder traversal on the expected recursion tree. It caches the nodes that are already computed."
                    }
                ]
            }
        ]
    }
]