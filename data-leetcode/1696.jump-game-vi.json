[
    {
        "title": "Stone Game",
        "question_content": "Alice and Bob play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].\nThe objective of the game is to end with the most stones. The total number of stones across all the piles is odd, so there are no ties.\nAlice and Bob take turns, with Alice starting first. Each turn, a player takes the entire pile of stones either from the beginning or from the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins.\nAssuming Alice and Bob play optimally, return true if Alice wins the game, or false if Bob wins.\n&nbsp;\nExample 1:\n\nInput: piles = [5,3,4,5]\nOutput: true\nExplanation: \nAlice starts first, and can only take the first 5 or the last 5.\nSay she takes the first 5, so that the row becomes [3, 4, 5].\nIf Bob takes 3, then the board is [4, 5], and Alice takes 5 to win with 10 points.\nIf Bob takes the last 5, then the board is [3, 4], and Alice takes 4 to win with 9 points.\nThis demonstrated that taking the first 5 was a winning move for Alice, so we return true.\n\nExample 2:\n\nInput: piles = [3,7,2,3]\nOutput: true\n\n&nbsp;\nConstraints:\n\n\t2 <= piles.length <= 500\n\tpiles.length is even.\n\t1 <= piles[i] <= 500\n\tsum(piles[i]) is odd.",
        "solutions": [
            {
                "id": 154610,
                "title": "dp-or-just-return-true",
                "content": "## Approach 1: Just return true\\nAlex is first to pick pile.\\n`piles.length` is even, and this lead to an interesting fact:\\nAlex can always pick odd piles or always pick even piles!\\n\\nFor example,\\nIf Alex wants to pick even indexed piles `piles[0], piles[2], ....., piles[n-2]`,\\nhe picks first `piles[0]`, then Lee can pick either `piles[1]` or `piles[n - 1]`.\\nEvery turn, Alex can always pick even indexed piles and Lee can only pick odd indexed piles.\\n\\nIn the description, we know that `sum(piles)` is odd.\\nIf `sum(piles[even]) > sum(piles[odd])`, Alex just picks all evens and wins.\\nIf `sum(piles[even]) < sum(piles[odd])`, Alex just picks all odds and wins.\\n\\nSo, Alex always defeats Lee in this game.\\n\\n**C++/Java**\\n```\\n    return true;\\n```\\n\\n**Python:**\\n```\\n    return True\\n```\\n<br/>\\n\\n## Approach 2: 2D DP\\n\\nIt\\'s tricky when we have even number of piles of stones. You may not have this condition in an interview.\\n\\n**Follow-up:**\\n\\nWhat if piles.length can be odd?\\nWhat if we want to know exactly the diffenerce of score?\\nThen we need to solve it with DP.\\n\\n`dp[i][j]` means the biggest number of stones you can get more than opponent picking piles in `piles[i] ~ piles[j]`.\\nYou can first pick `piles[i]` or  `piles[j]`.\\n1. If you pick `piles[i]`, your result will be `piles[i] - dp[i + 1][j]`\\n1. If you pick `piles[j]`, your result will be `piles[j] - dp[i][j - 1]`\\n\\nSo we get:\\n`dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])`\\nWe start from smaller subarray and then we use that to calculate bigger subarray.\\n\\nNote that take evens or take odds, it\\'s just an easy strategy to win when the number of stones is even. \\n**It\\'s not the best solution!**\\nI didn\\'t find a tricky solution when the number of stones is odd (maybe there is).\\n\\n**C++:**\\n```\\n    bool stoneGame(vector<int>& p) {\\n        int n = p.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        for (int i = 0; i < n; i++) dp[i][i] = p[i];\\n        for (int d = 1; d < n; d++)\\n            for (int i = 0; i < n - d; i++)\\n                dp[i][i + d] = max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1]);\\n        return dp[0][n - 1] > 0;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public boolean stoneGame(int[] p) {\\n        int n = p.length;\\n        int[][] dp  = new int[n][n];\\n        for (int i = 0; i < n; i++) dp[i][i] = p[i];\\n        for (int d = 1; d < n; d++)\\n            for (int i = 0; i < n - d; i++)\\n                dp[i][i + d] = Math.max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1]);\\n        return dp[0][n - 1] > 0;\\n    }\\n```\\n**Python:**\\n```\\n    def stoneGame(self, p):\\n        n = len(p)\\n        dp = [[0] * n for i in range(n)]\\n        for i in range(n): dp[i][i] = p[i]\\n        for d in range(1, n):\\n            for i in range(n - d):\\n                dp[i][i + d] = max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1])\\n        return dp[0][-1] > 0\\n```\\n<br/>\\n\\n## Approach 3: 1D DP\\nFollow up: Use only O(N) space?\\n\\nSimplify to 1D DP.\\n\\n**C++:**\\n```\\n    bool stoneGame(vector<int>& p) {\\n        vector<int> dp = p;\\n        for (int d = 1; d < p.size(); d++)\\n            for (int i = 0; i < p.size() - d; i++)\\n                dp[i] = max(p[i] - dp[i + 1], p[i + d] - dp[i]);\\n        return dp[0] > 0;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public boolean stoneGame(int[] p) {\\n        int[] dp = Arrays.copyOf(p, p.length);;\\n        for (int d = 1; d < p.length; d++)\\n            for (int i = 0; i < p.length - d; i++)\\n                dp[i] = Math.max(p[i] - dp[i + 1], p[i + d] - dp[i]);\\n        return dp[0] > 0;\\n    }\\n```\\n**Python:**\\n```\\n    def stoneGame(self, p):\\n        n = len(p)\\n        dp = p[:]\\n        for d in range(1, n):\\n            for i in range(n - d):\\n                dp[i] = max(p[i] - dp[i + 1], p[i + d] - dp[i])\\n        return dp[0] > 0\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n    return true;\\n```\n```\\n    return True\\n```\n```\\n    bool stoneGame(vector<int>& p) {\\n        int n = p.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        for (int i = 0; i < n; i++) dp[i][i] = p[i];\\n        for (int d = 1; d < n; d++)\\n            for (int i = 0; i < n - d; i++)\\n                dp[i][i + d] = max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1]);\\n        return dp[0][n - 1] > 0;\\n    }\\n```\n```\\n    public boolean stoneGame(int[] p) {\\n        int n = p.length;\\n        int[][] dp  = new int[n][n];\\n        for (int i = 0; i < n; i++) dp[i][i] = p[i];\\n        for (int d = 1; d < n; d++)\\n            for (int i = 0; i < n - d; i++)\\n                dp[i][i + d] = Math.max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1]);\\n        return dp[0][n - 1] > 0;\\n    }\\n```\n```\\n    def stoneGame(self, p):\\n        n = len(p)\\n        dp = [[0] * n for i in range(n)]\\n        for i in range(n): dp[i][i] = p[i]\\n        for d in range(1, n):\\n            for i in range(n - d):\\n                dp[i][i + d] = max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1])\\n        return dp[0][-1] > 0\\n```\n```\\n    bool stoneGame(vector<int>& p) {\\n        vector<int> dp = p;\\n        for (int d = 1; d < p.size(); d++)\\n            for (int i = 0; i < p.size() - d; i++)\\n                dp[i] = max(p[i] - dp[i + 1], p[i + d] - dp[i]);\\n        return dp[0] > 0;\\n    }\\n```\n```\\n    public boolean stoneGame(int[] p) {\\n        int[] dp = Arrays.copyOf(p, p.length);;\\n        for (int d = 1; d < p.length; d++)\\n            for (int i = 0; i < p.length - d; i++)\\n                dp[i] = Math.max(p[i] - dp[i + 1], p[i + d] - dp[i]);\\n        return dp[0] > 0;\\n    }\\n```\n```\\n    def stoneGame(self, p):\\n        n = len(p)\\n        dp = p[:]\\n        for d in range(1, n):\\n            for i in range(n - d):\\n                dp[i] = max(p[i] - dp[i + 1], p[i + d] - dp[i])\\n        return dp[0] > 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 154660,
                "title": "java-this-is-minimax-dp-fully-detailed-explanation-generalization-easy-understand-code",
                "content": "The problem was made a \"trick problem,\" because Alex always wins, but if you want to learn the **general idea behind these problems** here is the explanation for other cases.\\n\\n```\\nclass Solution {\\n    int [][][] memo;\\n    public boolean stoneGame(int[] piles) {\\n        memo = new int[piles.length + 1][piles.length + 1][2];\\n        for(int [][] arr : memo)\\n            for(int [] subArr : arr)\\n                Arrays.fill(subArr, -1);\\n        \\n        return (helper(0, piles.length - 1, piles, 1) >= 0);\\n    }\\n    \\n    public int helper(int l, int r, int [] piles, int ID){\\n        if(r < l)\\n            return 0;\\n        if(memo[l][r][ID] != -1)\\n            return memo[l][r][ID];\\n        \\n        int next = Math.abs(ID - 1);\\n        if(ID == 1)\\n            memo[l][r][ID] = Math.max(piles[l] + helper(l + 1, r, piles, next), piles[r] + helper(l, r - 1, piles, next));\\n        else\\n            memo[l][r][ID] = Math.min(-piles[l] + helper(l + 1, r, piles, next), -piles[r] + helper(l, r - 1, piles, next));\\n        \\n        return memo[l][r][ID];\\n    }\\n}\\n```\\n\\nThis is a **Minimax** problem. Each player plays optimally to win, but you can\\'t greedily choose the optimal strategy so you have to try *all* strategies, this is DP now.\\n\\nWhat does it mean for Alex to win? Alex will win if `score(Alex) >= score(Lee)`, but this also means `score(Alex) - score(Lee) >= 0`, so here you have a **common parameter** which is a `score` variable. The `score` parameter really means `score = score(Alex) - score(Lee)`.\\n\\nNow, if each player is suppoed to play optimally, how do you decide this with one variable?\\n\\nWell since Alex is playing optimally, he wants to **maximize** the `score` variable because remember, Alex only wins if `score = score(Alex) - score(Lee) >= 0` Alex should *add* to the score because he wants to maximize it.\\nSince Lee is also playing optimally, he wants to **minimize** the `score` variable, since if the `score` variable becomes negative, Lee has more individual score than Alex. But since we have only one variable, Lee should *damage* the score (or in other words, *subtract* from the score).\\n\\nNow, let\\'s think of the brute force solution. You are at the current state, say this is Alex\\'s turn. Alex can choose either `left` or `right`, but he can\\'t greedily pick so you try *both* of them, this is `O(2^n)` for runtime.\\n\\nBut realize the `state` you are in. You can easily memoize the this, the varying parameters are `l, r, ID`, where `ID` is the player ID (`1 for Alex, 0 for Lee`), hence you can make a DP/Cache table and return answer if you have discovered the state.\\n\\nFinally, in your main function you call this `helper` function and check if you were able to get a `score >= 0`.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int [][][] memo;\\n    public boolean stoneGame(int[] piles) {\\n        memo = new int[piles.length + 1][piles.length + 1][2];\\n        for(int [][] arr : memo)\\n            for(int [] subArr : arr)\\n                Arrays.fill(subArr, -1);\\n        \\n        return (helper(0, piles.length - 1, piles, 1) >= 0);\\n    }\\n    \\n    public int helper(int l, int r, int [] piles, int ID){\\n        if(r < l)\\n            return 0;\\n        if(memo[l][r][ID] != -1)\\n            return memo[l][r][ID];\\n        \\n        int next = Math.abs(ID - 1);\\n        if(ID == 1)\\n            memo[l][r][ID] = Math.max(piles[l] + helper(l + 1, r, piles, next), piles[r] + helper(l, r - 1, piles, next));\\n        else\\n            memo[l][r][ID] = Math.min(-piles[l] + helper(l + 1, r, piles, next), -piles[r] + helper(l, r - 1, piles, next));\\n        \\n        return memo[l][r][ID];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 261718,
                "title": "step-by-step-recursive-topdown-bottomup-and-bottomup-using-o-n-space-in-java",
                "content": "Explaination : In the Questions of DP do start from the Recusive Solution of the Question then proceed to TopDown Approach and then Proceed to BottomUp and then Efficient Approach.\\n\\nIntuition : \\n__Talking about the Recursive Solution__ -> Consider a boolean variable that will decide if the turn is of Alex or Lee.\\n If it is Alex\\'s Turn then we will find the max number of stones we can get by either consuming the first pile from the piles or by consuming the last pile.\\nIf it is Lee\\'s turn then we will find the min number of stones we can get by decreasing the amount of the Alex\\'s score.\\n\\n__Talking About the TopDown Approach__ : We will take a 2 D Array and save the answer at particular index and use that value in case of redundant calls.\\n\\n__Talking About the BottomUp Approach__ : Here we will implement the same approach but Iteratively using 2D array.\\n\\n__Taking about the BottomUp Efficient Approach__ : Here we will implement the same BottomUp approach Using 1D Array.\\n\\n__Recursive Solution__\\n<pre><code=\"lang-java\">\\n// si -> Starting Index, ei -> Ending Index\\n// turn -> If True then Alex\\'s turn else Lee\\'s turn\\npublic static int gameOnInt(int[] piles, int si, int ei, boolean turn){ \\n\\n\\t\\t    if(si > ei){\\n\\t\\t     \\treturn 0;\\n\\t     \\t}\\n\\n\\t\\tif(turn){ // If its Alex\\'s Turn\\n\\t\\t\\tint rr1 = gameOnInt(piles, si + 1,ei,false) + piles[si]; //Consuming from Starting Index\\n\\t\\t\\tint rr2 = gameOnInt(piles, si,ei - 1,false) + piles[ei]; //Consuming form Ending Index\\n\\t\\t\\treturn Math.max(rr1, rr2); //Choosing the Maximum From both of the results\\n\\t\\t}\\n\\t\\t\\n\\t\\t// If it is Lee\\'s Turn\\n\\t\\tint rr1 = gameOnInt(piles, si + 1, ei, true) - piles[si]; //Consuming from the Starting Index\\n\\t\\tint rr2 = gameOnInt(piles, si, ei - 1, true) - piles[ei];//Consuming from the Ending Index\\n\\t\\treturn Math.min(rr1, rr2); // Choosing the Minimum from the Recursion Result\\n\\t}\\n\\t\\n</code></pre>\\n\\n__TopDown Approach__\\n<pre><code=\"lang-java\">\\n// Same Code as Above just Using an 2D array to save the Calculated answer\\npublic static int gameOnIntTD(int[] piles, int si, int ei, boolean turn, int[][] strg){\\n\\t\\tif(si > ei){\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// If the Recursion has Calculated the Answer  \\n\\t\\tif(strg[si][ei] > 0){\\n\\t\\t\\treturn strg[si][ei]; // return that Stored Answer\\n\\t\\t}\\n\\n\\t\\tif(turn){ // If it is Alex\\'s Turn\\n\\t\\t\\tint rr1 = gameOnIntTD(piles, si + 1,ei,false, strg) + piles[si]; // Same as Above\\n\\t\\t\\tint rr2 = gameOnIntTD(piles, si,ei - 1,false, strg) + piles[ei]; // Same as Above\\n\\t\\t\\tstrg[si][ei] = Math.max(rr1, rr2); // Storing the max ans at particular indices\\n\\t\\t\\treturn strg[si][ei];\\n\\t\\t}\\n\\t\\t// If it is Lee\\'s Turn\\n\\t\\tint rr1 = gameOnIntTD(piles, si + 1, ei, true, strg) - piles[si]; //Same logic as above\\n\\t\\tint rr2 = gameOnIntTD(piles, si, ei - 1, true, strg) - piles[ei];//Same logic as above\\n\\t\\tstrg[si][ei] = Math.min(rr1, rr2); //Storing the answer at particular indices\\n\\t\\treturn strg[si][ei];\\n\\t}\\n</code></pre>\\n\\n__BottomUp Approach__ : In the Bottom Up approach, we will fill the 2D array in a Slide manner(To study the slide manner read the BottomUp approach of the Matrix Multiplication Question). In the Slide approach the array is filled like in the manner stated below :\\nHere elements below the main diagonal are of no use as there starting index is greater than the ending Index which was our Base case in the Recusive Solution as discussed above.\\n\\nConsider a 2D Matrix of 4x4 :\\nStep 1 : First we will fill the main diagonal(For Slide = 1)\\n__00__ 01 02  03\\n10 __11__ 12 13\\n20 21 __22__ 23\\n30 31 32 __33__\\n\\nStep2 : For slide = 2\\n00 __01__ 02  03\\n10 11  __12__ 13\\n20 21 22 __23__\\n30 31 32 33\\n\\nStep3 : For Slide = 3\\n00 01 __02__  03\\n10 11  12 __13__\\n20 21 22 23\\n30 31 32 33\\n\\nStep4: For Slide = 4\\n00 01 02 __03__\\n10 11  12 13\\n20 21 22 23\\n30 31 32 33\\n\\nNote : With this Approach the Answer will be available at strg[0][strg.length  - 1],\\n\\t\\t  which is the last element of the First Row.\\n<pre><code=\"lang-java\">\\npublic static int gameOnIntBU(int[] piles){\\n\\t\\t //To calculate the Answer\\n\\t\\tint[][] strg = new int[piles.length ][piles.length ];\\n\\t\\tboolean turn = false; // To store the turn\\n\\n\\t\\t/* Slide that will help to calculate the particular si and ei, so that we can work in a slide\\n\\t\\tmanner as discussed above */\\n\\t\\tfor(int slide = 0; slide < piles.length;slide++){ \\n\\t\\t\\tfor(int si = 0;si < piles.length - slide;si++){\\n\\t\\t\\t\\tint ei = slide + si;\\n\\t\\t\\t\\t/*This condition ensures we are on the diagonal and only one pile is left. As \\n\\t\\t\\t\\tyou know if there are Even Piles and Alex starts the Game, then the Last Pile \\n\\t\\t\\t\\twill be of Lee. So We need to subtract the stones from the amount of Alex viz\\n\\t\\t\\t\\tzero   for now */\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(si == ei){ \\n\\t\\t\\t\\t\\tstrg[si][ei] = -piles[si];\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(turn){\\n\\t\\t\\t\\t\\t// Similar Logic as dicussed in Recursive Approach\\n\\t\\t\\t\\t\\tstrg[si][ei] = Math.max(strg[si + 1][ei] + piles[si] ,strg[si][ei - 1] + piles[ei]);\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t//Same as discussed in Recursive Approach\\n\\t\\t\\t\\t\\tstrg[si][ei] = Math.min(strg[si + 1][ei] - piles[si], strg[si][ei - 1] - piles[ei]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// Changing the Turn\\n\\t\\t\\tturn = !turn;\\n\\t\\t}\\n\\t\\t\\t// Answer wil be stored at this Index\\n\\t\\t\\treturn strg[0][strg.length - 1];\\n\\n\\t}\\n</code></pre>\\n\\n//Same as above bt here we need not to consider the 2D Array we can also do it using 1D too.\\n\\n\\n__BottomUp Approach - Efficient__\\n<pre><code=\"lang-java\">\\npublic static int gameOnIntBU(int[] piles){\\n        int[] strg = new int[piles.length];\\n        strg[piles.length - 1] = piles[piles.length - 1];\\n\\n        for(int si = piles.length - 1; si >= 0;si--){\\n\\n            boolean turn = false;    \\n\\n            for(int ei = si; ei < piles.length; ei++){\\n\\n                if(si == ei){\\n\\n                    strg[ei] = piles[ei];\\n                    turn = !turn;\\n                    continue;\\n                }\\n\\n                if(turn){\\n\\n                    strg[ei] = Math.max(strg[ei] + piles[ei], strg[ei - 1] + piles[ei - 1]);\\n                }else{\\n\\n                    strg[ei] = Math.min(strg[ei] - piles[ei], strg[ei - 1] - piles[ei - 1]);\\n                }\\n\\n                turn = !turn;\\n            }\\n\\n        }\\n\\n        return strg[strg.length - 1];\\n    }\\n</pre></code>",
                "solutionTags": [],
                "code": "Explaination : In the Questions of DP do start from the Recusive Solution of the Question then proceed to TopDown Approach and then Proceed to BottomUp and then Efficient Approach.\\n\\nIntuition : \\n__Talking about the Recursive Solution__ -> Consider a boolean variable that will decide if the turn is of Alex or Lee.\\n If it is Alex\\'s Turn then we will find the max number of stones we can get by either consuming the first pile from the piles or by consuming the last pile.\\nIf it is Lee\\'s turn then we will find the min number of stones we can get by decreasing the amount of the Alex\\'s score.\\n\\n__Talking About the TopDown Approach__ : We will take a 2 D Array and save the answer at particular index and use that value in case of redundant calls.\\n\\n__Talking About the BottomUp Approach__ : Here we will implement the same approach but Iteratively using 2D array.\\n\\n__Taking about the BottomUp Efficient Approach__ : Here we will implement the same BottomUp approach Using 1D Array.\\n\\n__Recursive Solution__\\n<pre><code=\"lang-java\">\\n// si -> Starting Index, ei -> Ending Index\\n// turn -> If True then Alex\\'s turn else Lee\\'s turn\\npublic static int gameOnInt(int[] piles, int si, int ei, boolean turn){ \\n\\n\\t\\t    if(si > ei){\\n\\t\\t     \\treturn 0;\\n\\t     \\t}\\n\\n\\t\\tif(turn){ // If its Alex\\'s Turn\\n\\t\\t\\tint rr1 = gameOnInt(piles, si + 1,ei,false) + piles[si]; //Consuming from Starting Index\\n\\t\\t\\tint rr2 = gameOnInt(piles, si,ei - 1,false) + piles[ei]; //Consuming form Ending Index\\n\\t\\t\\treturn Math.max(rr1, rr2); //Choosing the Maximum From both of the results\\n\\t\\t}\\n\\t\\t\\n\\t\\t// If it is Lee\\'s Turn\\n\\t\\tint rr1 = gameOnInt(piles, si + 1, ei, true) - piles[si]; //Consuming from the Starting Index\\n\\t\\tint rr2 = gameOnInt(piles, si, ei - 1, true) - piles[ei];//Consuming from the Ending Index\\n\\t\\treturn Math.min(rr1, rr2); // Choosing the Minimum from the Recursion Result\\n\\t}\\n\\t\\n</code></pre>\\n\\n__TopDown Approach__\\n<pre><code=\"lang-java\">\\n// Same Code as Above just Using an 2D array to save the Calculated answer\\npublic static int gameOnIntTD(int[] piles, int si, int ei, boolean turn, int[][] strg){\\n\\t\\tif(si > ei){\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// If the Recursion has Calculated the Answer  \\n\\t\\tif(strg[si][ei] > 0){\\n\\t\\t\\treturn strg[si][ei]; // return that Stored Answer\\n\\t\\t}\\n\\n\\t\\tif(turn){ // If it is Alex\\'s Turn\\n\\t\\t\\tint rr1 = gameOnIntTD(piles, si + 1,ei,false, strg) + piles[si]; // Same as Above\\n\\t\\t\\tint rr2 = gameOnIntTD(piles, si,ei - 1,false, strg) + piles[ei]; // Same as Above\\n\\t\\t\\tstrg[si][ei] = Math.max(rr1, rr2); // Storing the max ans at particular indices\\n\\t\\t\\treturn strg[si][ei];\\n\\t\\t}\\n\\t\\t// If it is Lee\\'s Turn\\n\\t\\tint rr1 = gameOnIntTD(piles, si + 1, ei, true, strg) - piles[si]; //Same logic as above\\n\\t\\tint rr2 = gameOnIntTD(piles, si, ei - 1, true, strg) - piles[ei];//Same logic as above\\n\\t\\tstrg[si][ei] = Math.min(rr1, rr2); //Storing the answer at particular indices\\n\\t\\treturn strg[si][ei];\\n\\t}\\n</code></pre>\\n\\n__BottomUp Approach__ : In the Bottom Up approach, we will fill the 2D array in a Slide manner(To study the slide manner read the BottomUp approach of the Matrix Multiplication Question). In the Slide approach the array is filled like in the manner stated below :\\nHere elements below the main diagonal are of no use as there starting index is greater than the ending Index which was our Base case in the Recusive Solution as discussed above.\\n\\nConsider a 2D Matrix of 4x4 :\\nStep 1 : First we will fill the main diagonal(For Slide = 1)\\n__00__ 01 02  03\\n10 __11__ 12 13\\n20 21 __22__ 23\\n30 31 32 __33__\\n\\nStep2 : For slide = 2\\n00 __01__ 02  03\\n10 11  __12__ 13\\n20 21 22 __23__\\n30 31 32 33\\n\\nStep3 : For Slide = 3\\n00 01 __02__  03\\n10 11  12 __13__\\n20 21 22 23\\n30 31 32 33\\n\\nStep4: For Slide = 4\\n00 01 02 __03__\\n10 11  12 13\\n20 21 22 23\\n30 31 32 33\\n\\nNote : With this Approach the Answer will be available at strg[0][strg.length  - 1],\\n\\t\\t  which is the last element of the First Row.\\n<pre><code=\"lang-java\">\\npublic static int gameOnIntBU(int[] piles){\\n\\t\\t //To calculate the Answer\\n\\t\\tint[][] strg = new int[piles.length ][piles.length ];\\n\\t\\tboolean turn = false; // To store the turn\\n\\n\\t\\t/* Slide that will help to calculate the particular si and ei, so that we can work in a slide\\n\\t\\tmanner as discussed above */\\n\\t\\tfor(int slide = 0; slide < piles.length;slide++){ \\n\\t\\t\\tfor(int si = 0;si < piles.length - slide;si++){\\n\\t\\t\\t\\tint ei = slide + si;\\n\\t\\t\\t\\t/*This condition ensures we are on the diagonal and only one pile is left. As \\n\\t\\t\\t\\tyou know if there are Even Piles and Alex starts the Game, then the Last Pile \\n\\t\\t\\t\\twill be of Lee. So We need to subtract the stones from the amount of Alex viz\\n\\t\\t\\t\\tzero   for now */\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(si == ei){ \\n\\t\\t\\t\\t\\tstrg[si][ei] = -piles[si];\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(turn){\\n\\t\\t\\t\\t\\t// Similar Logic as dicussed in Recursive Approach\\n\\t\\t\\t\\t\\tstrg[si][ei] = Math.max(strg[si + 1][ei] + piles[si] ,strg[si][ei - 1] + piles[ei]);\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t//Same as discussed in Recursive Approach\\n\\t\\t\\t\\t\\tstrg[si][ei] = Math.min(strg[si + 1][ei] - piles[si], strg[si][ei - 1] - piles[ei]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// Changing the Turn\\n\\t\\t\\tturn = !turn;\\n\\t\\t}\\n\\t\\t\\t// Answer wil be stored at this Index\\n\\t\\t\\treturn strg[0][strg.length - 1];\\n\\n\\t}\\n</code></pre>\\n\\n//Same as above bt here we need not to consider the 2D Array we can also do it using 1D too.\\n\\n\\n__BottomUp Approach - Efficient__\\n<pre><code=\"lang-java\">\\npublic static int gameOnIntBU(int[] piles){\\n        int[] strg = new int[piles.length];\\n        strg[piles.length - 1] = piles[piles.length - 1];\\n\\n        for(int si = piles.length - 1; si >= 0;si--){\\n\\n            boolean turn = false;    \\n\\n            for(int ei = si; ei < piles.length; ei++){\\n\\n                if(si == ei){\\n\\n                    strg[ei] = piles[ei];\\n                    turn = !turn;\\n                    continue;\\n                }\\n\\n                if(turn){\\n\\n                    strg[ei] = Math.max(strg[ei] + piles[ei], strg[ei - 1] + piles[ei - 1]);\\n                }else{\\n\\n                    strg[ei] = Math.min(strg[ei] - piles[ei], strg[ei - 1] - piles[ei - 1]);\\n                }\\n\\n                turn = !turn;\\n            }\\n\\n        }\\n\\n        return strg[strg.length - 1];\\n    }\\n</pre></code>",
                "codeTag": "Unknown"
            },
            {
                "id": 1384652,
                "title": "c-python-dp-no-math-easy-to-understand-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Top down DP**\\n- Please note that **both players are playing optimally**, so we just play optimally regardless of who is Alex, who is Lee.\\n- Let `dp(left, right)` return `[firstScore, secondScore]` where `firstScore` is the maximum score when the **player1 play first**, `secondScore` is the maximum score when the **player2 play second**, they pick stones in `piles[left]...piles[right]`.\\n- For stones in `piles[left]...piles[right]`, there are 2 choices for the player1 to pick:\\n\\t- Pick left: `pickLeft = dp(left + 1, right)`. \\n\\t\\t- The score of the player1 = `piles[left]` + the second pick score from `pickLeft`, so `firstScore = piles[left] + pickLeft[1]`\\n\\t\\t- The score of the player2 = first pick score from `pickLeft`, so `secondScore = pickLeft[0]`\\n\\t- Pick right: `pickRight = dp(left, right - 1)`.\\n\\t\\t- The score of the player1 = `piles[right]` + the second pick score from `pickRight`,  so `firstScore = piles[right] + pickRight[1]`\\n\\t\\t- The score of the player2 = first pick score from `pickRight`, so `secondScore = pickRight[0]`.\\n- We need to get the maximum score when the player1 plays first from above 2 choices.\\n- Finally, `dp(0, len(piles) - 1)` return `[firstScore, secondScore]`, where `alexScore = firstScore` since Alex plays first, `leeScore = secondScore` since Lee plays second.\\n\\n<iframe src=\"https://leetcode.com/playground/iQ3cX7yz/shared\" frameBorder=\"0\" width=\"100%\" height=\"420\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 500` is the size of `piles` array. \\n- Space: `O(N^2)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Bottom up DP**\\n- Just convert from **Top down DP** to **Bottom up DP** to eliminate recursion memory stack.\\n\\n<iframe src=\"https://leetcode.com/playground/KodaRUHU/shared\" frameBorder=\"0\" width=\"100%\" height=\"480\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 500` is the size of `piles` array. \\n- Space: `O(N^2)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 3: Alex is always WIN!**\\n- Some notices in the problem constraint:\\n\\t- The total number of stones is odd, so there is WIN or LOSE, no tie!\\n\\t- The number of piles is even, so both Alex and Lee pick `piles.length/2` piles.\\n\\t- Alex plays first.\\n- Because Alex always choose the maximum score between 2 choices, so he\\'s always WIN!\\n\\n```python\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```\\n**Complexity**\\n- Time & Space: `O(1)`.\\n\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 154607,
                "title": "alex-won-t-lose",
                "content": "Alex can always take all odd piles or always take all even piles\\nSince sum of all piles is odd then sum of all odd piles won\\'t equals sum of all even piles, Alex could just take the bigger ones. \\n```\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 298170,
                "title": "c-very-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1005][1005];\\n    \\n    int f(int l, int r, vector <int> &piles) {\\n        if(l == r-1) return max(piles[l], piles[r]);\\n        \\n        if(dp[l][r] != -1) return dp[l][r];\\n        \\n        int ifleft = piles[l] + max(f(l+2, r, piles), f(l+1, r-1, piles));\\n        int ifright = piles[r] + max(f(l+1, r-1, piles), f(l, r-2, piles));\\n        \\n        return dp[l][r] = max(ifleft, ifright);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int l = 0, r = piles.size()-1;\\n        memset(dp, -1, sizeof(dp));\\n        int alex = f(l, r, piles);\\n        int sum = 0;\\n        for(int i=0;i<piles.size();i++) sum += piles[i];\\n\\n        return alex > (sum - alex);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1005][1005];\\n    \\n    int f(int l, int r, vector <int> &piles) {\\n        if(l == r-1) return max(piles[l], piles[r]);\\n        \\n        if(dp[l][r] != -1) return dp[l][r];\\n        \\n        int ifleft = piles[l] + max(f(l+2, r, piles), f(l+1, r-1, piles));\\n        int ifright = piles[r] + max(f(l+1, r-1, piles), f(l, r-2, piles));\\n        \\n        return dp[l][r] = max(ifleft, ifright);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int l = 0, r = piles.size()-1;\\n        memset(dp, -1, sizeof(dp));\\n        int alex = f(l, r, piles);\\n        int sum = 0;\\n        for(int i=0;i<piles.size();i++) sum += piles[i];\\n\\n        return alex > (sum - alex);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384518,
                "title": "stone-game-3-approaches-1-d-2-d-dp-or-just-return-true-c-java-python",
                "content": "## \\u2714\\uFE0F**Approach 1: Just return true**\\n\\n* Alex is first to pick pile.\\n* `piles.length` is even, and this lead to an interesting fact:\\n* Alex can always pick odd piles or always pick even piles!\\n\\n**For example,**\\n* If Alex wants to pick even indexed piles `piles[0], piles[2], ....., piles[n-2],`\\nhe picks first `piles[0]`, then Lee can pick either `piles[1] or piles[n - 1].`\\n* Every turn, Alex can always pick even indexed piles and Lee can only pick odd indexed piles.\\n\\n* In the description, we know that sum(piles) is odd.\\n\\t* If `sum(piles[even]) > sum(piles[odd])`, Alex just picks all evens and wins.\\n\\t* If `sum(piles[even]) < sum(piles[odd])`, Alex just picks all odds and wins.\\n\\n*So, Alex always defeats Lee in this game*\\n\\n`In C++ OR JAVA`\\n```\\n    return true;\\n```\\n`In Python`\\n```\\n    return True\\n```\\n\\n<hr>\\n\\n## \\u2714\\uFE0F**Approach 2: 2D DP**\\n\\n* `dp[i][j]` means the biggest number of stones you can get more than opponent picking piles in `piles[i] ~ piles[j].`\\n* You can first pick `piles[i]` or `piles[j].`\\n1. If you pick piles[i], your result will be` piles[i] - dp[i + 1][j]`\\n2. If you pick piles[j], your result will be `piles[j] - dp[i][j - 1]`\\n\\nSo the result is: \\n  ``` dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])```\\n\\n* We start from smaller subarray and then we use that to calculate bigger subarray.\\n* Note that take evens or take odds, it\\'s just an easy strategy to win when the number of stones is even.\\n\\n**SOLUTION** \\n\\n`In C++`\\n```\\nbool stoneGame(vector<int>& p) {\\n        int n = p.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        for (int i = 0; i < n; i++) dp[i][i] = p[i];\\n        for (int d = 1; d < n; d++)\\n            for (int i = 0; i < n - d; i++)\\n                dp[i][i + d] = max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1]);\\n        return dp[0][n - 1] > 0;\\n    }\\n```\\n`In JAVA`\\n```\\n public boolean stoneGame(int[] p) {\\n        int n = p.length;\\n        int[][] dp  = new int[n][n];\\n        for (int i = 0; i < n; i++) dp[i][i] = p[i];\\n        for (int d = 1; d < n; d++)\\n            for (int i = 0; i < n - d; i++)\\n                dp[i][i + d] = Math.max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1]);\\n        return dp[0][n - 1] > 0;\\n    }\\n```\\n`In Python`\\n```\\ndef stoneGame(self, p):\\n        n = len(p)\\n        dp = [[0] * n for i in range(n)]\\n        for i in range(n): dp[i][i] = p[i]\\n        for d in range(1, n):\\n            for i in range(n - d):\\n                dp[i][i + d] = max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1])\\n        return dp[0][-1] > 0\\n```\\n\\n<hr>\\n\\n## \\u2714\\uFE0F**Approach 3: 1D DP**\\n\\nWhat if, we use only O(N) space?\\n\\n**SOLUTION**\\n`In C++`\\n```\\n bool stoneGame(vector<int>& p) {\\n        vector<int> dp = p;\\n        for (int d = 1; d < p.size(); d++)\\n            for (int i = 0; i < p.size() - d; i++)\\n                dp[i] = max(p[i] - dp[i + 1], p[i + d] - dp[i]);\\n        return dp[0] > 0;\\n    }\\n```\\n`In Java`\\n```\\npublic boolean stoneGame(int[] p) {\\n        int[] dp = Arrays.copyOf(p, p.length);;\\n        for (int d = 1; d < p.length; d++)\\n            for (int i = 0; i < p.length - d; i++)\\n                dp[i] = Math.max(p[i] - dp[i + 1], p[i + d] - dp[i]);\\n        return dp[0] > 0;\\n    }\\n```\\n`In Python`\\n```\\ndef stoneGame(self, p):\\n        n = len(p)\\n        dp = p[:]\\n        for d in range(1, n):\\n            for i in range(n - d):\\n                dp[i] = max(p[i] - dp[i + 1], p[i + d] - dp[i])\\n        return dp[0] > 0\\n```\\n\\n<hr>\\n\\nHere is a video if you need a more intuitive answer\\n[Click Here](https://www.youtube.com/watch?v=WxpIHvsu1RI)",
                "solutionTags": [],
                "code": "```\\n    return true;\\n```\n```\\n    return True\\n```\n``` dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])```\n```\\nbool stoneGame(vector<int>& p) {\\n        int n = p.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        for (int i = 0; i < n; i++) dp[i][i] = p[i];\\n        for (int d = 1; d < n; d++)\\n            for (int i = 0; i < n - d; i++)\\n                dp[i][i + d] = max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1]);\\n        return dp[0][n - 1] > 0;\\n    }\\n```\n```\\n public boolean stoneGame(int[] p) {\\n        int n = p.length;\\n        int[][] dp  = new int[n][n];\\n        for (int i = 0; i < n; i++) dp[i][i] = p[i];\\n        for (int d = 1; d < n; d++)\\n            for (int i = 0; i < n - d; i++)\\n                dp[i][i + d] = Math.max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1]);\\n        return dp[0][n - 1] > 0;\\n    }\\n```\n```\\ndef stoneGame(self, p):\\n        n = len(p)\\n        dp = [[0] * n for i in range(n)]\\n        for i in range(n): dp[i][i] = p[i]\\n        for d in range(1, n):\\n            for i in range(n - d):\\n                dp[i][i + d] = max(p[i] - dp[i + 1][i + d], p[i + d] - dp[i][i + d - 1])\\n        return dp[0][-1] > 0\\n```\n```\\n bool stoneGame(vector<int>& p) {\\n        vector<int> dp = p;\\n        for (int d = 1; d < p.size(); d++)\\n            for (int i = 0; i < p.size() - d; i++)\\n                dp[i] = max(p[i] - dp[i + 1], p[i + d] - dp[i]);\\n        return dp[0] > 0;\\n    }\\n```\n```\\npublic boolean stoneGame(int[] p) {\\n        int[] dp = Arrays.copyOf(p, p.length);;\\n        for (int d = 1; d < p.length; d++)\\n            for (int i = 0; i < p.length - d; i++)\\n                dp[i] = Math.max(p[i] - dp[i + 1], p[i + d] - dp[i]);\\n        return dp[0] > 0;\\n    }\\n```\n```\\ndef stoneGame(self, p):\\n        n = len(p)\\n        dp = p[:]\\n        for d in range(1, n):\\n            for i in range(n - d):\\n                dp[i] = max(p[i] - dp[i + 1], p[i + d] - dp[i])\\n        return dp[0] > 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1384896,
                "title": "c-solution-dp-with-explanation",
                "content": "**This will work on the statement that :-\\nWhen you have to do something, do your best. But when things happen to you, prepare for worst ( HAPPY LIFE MANTRA :))**\\n*Case 1:\\nAlex takes (i)th pile than array became (i+1, j)\\nnow if Lee will take the (i+1)th pile then array became (i+2, j)\\nand if Lee will take the (j)th pile then array became (i+1, j-1)\\n=> Lee is supposed to take the maxi among 2 choices then Alex will reamin with min of these 2 choices\\n                    \\nCase 2:\\nAlex takes (j)th pile than array became (i, j-1)\\nnow if Lee will take the (i)th pile then array became (i+1, j-1)\\nand if Lee will take the (j-1)th pile then array became (i, j-2)\\n=> Lee is supposed to take the maxi among 2 choices then Alex will reamin with min of these 2 choices*\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<vector<int>>dp(n, vector<int>(n));\\n        \\n        for(int gap = 0; gap < n; gap++)\\n            for(int i = 0, j = gap; j < n; i++, j++){\\n                if(gap == 0) dp[i][j] = piles[i];\\n                else if(gap == 1) dp[i][j] = max(piles[i], piles[j]);\\n                else{\\n                    int case1 = piles[i] + min(dp[i+2][j], dp[i+1][j-1]);\\n                    int case2 = piles[j] + min(dp[i+1][j-1], dp[i][j-2]);\\n                    dp[i][j] = max(case1, case2); // maximum of these 2 cases\\n                }\\n            }\\n        return dp[0][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<vector<int>>dp(n, vector<int>(n));\\n        \\n        for(int gap = 0; gap < n; gap++)\\n            for(int i = 0, j = gap; j < n; i++, j++){\\n                if(gap == 0) dp[i][j] = piles[i];\\n                else if(gap == 1) dp[i][j] = max(piles[i], piles[j]);\\n                else{\\n                    int case1 = piles[i] + min(dp[i+2][j], dp[i+1][j-1]);\\n                    int case2 = piles[j] + min(dp[i+1][j-1], dp[i][j-2]);\\n                    dp[i][j] = max(case1, case2); // maximum of these 2 cases\\n                }\\n            }\\n        return dp[0][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099490,
                "title": "proof-why-should-you-return-true-only",
                "content": "```\\n** Just return true**\\n\\nAlex is first to pick pile.\\npiles.length is even, and this lead to an interesting fact:\\nAlex can always pick odd piles or always pick even piles!\\n\\nFor example,\\nIf Alex wants to pick even indexed piles piles[0], piles[2], ....., piles[n-2],\\nhe picks first piles[0], then Lee can pick either piles[1] or piles[n - 1].\\nEvery turn, Alex can always pick even indexed piles and Lee can only pick odd indexed piles.\\n\\nIn the description, we know that sum(piles) is odd.\\nIf sum(piles[even]) > sum(piles[odd]), Alex just picks all evens and wins.\\nIf sum(piles[even]) < sum(piles[odd]), Alex just picks all odds and wins.\\n\\nSo, Alex always defeats Lee in this game.\\n```",
                "solutionTags": [],
                "code": "```\\n** Just return true**\\n\\nAlex is first to pick pile.\\npiles.length is even, and this lead to an interesting fact:\\nAlex can always pick odd piles or always pick even piles!\\n\\nFor example,\\nIf Alex wants to pick even indexed piles piles[0], piles[2], ....., piles[n-2],\\nhe picks first piles[0], then Lee can pick either piles[1] or piles[n - 1].\\nEvery turn, Alex can always pick even indexed piles and Lee can only pick odd indexed piles.\\n\\nIn the description, we know that sum(piles) is odd.\\nIf sum(piles[even]) > sum(piles[odd]), Alex just picks all evens and wins.\\nIf sum(piles[even]) < sum(piles[odd]), Alex just picks all odds and wins.\\n\\nSo, Alex always defeats Lee in this game.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 154604,
                "title": "python-recursive-dp-mini-max",
                "content": "The idea is based on minimax algorithm for adversarial game playing.\\np1 tries to maximize his return by calling pmax. p2 tries to minimize p1\\'s return by calling pmin.\\n\\npmin(i, j) => Given a pile from i...j and its p2\\'s turn to play, return what p1 will get. \\npmax(i, j) => Given a pile from i..j and its p1\\'s turn to play, return what p1 will get.\\n\\nIn my logic, I am simply calculating what is the value that p1 will get if both play optimally. The value for p2 is the remaining and p1 > p2 tells if p1 will win.\\n\\n\\n```\\n    def stoneGame(self, piles):\\n        def pmin(i, j):\\n            if (i,j) in mincache: return mincache[(i,j)]\\n            if i == j: return 0\\n            mincache[(i,j)] =  min(pmax(i+1, j), pmax(i, j-1))\\n            return mincache[(i,j)]\\n\\n        def pmax(i, j):\\n            if (i,j) in maxcache: return maxcache[(i,j)]\\n            if i == j: return piles[i]\\n            maxcache[(i,j)] =  max(piles[i] + pmin(i+1, j), pmin(i, j-1) + piles[j])\\n            return maxcache[(i,j)]\\n\\n        mincache, maxcache = {}, {}\\n        p1 = pmax(0, len(piles)-1)\\n        p2 = sum(piles) - p1\\n        return p1 > p2\\n```",
                "solutionTags": [],
                "code": "```\\n    def stoneGame(self, piles):\\n        def pmin(i, j):\\n            if (i,j) in mincache: return mincache[(i,j)]\\n            if i == j: return 0\\n            mincache[(i,j)] =  min(pmax(i+1, j), pmax(i, j-1))\\n            return mincache[(i,j)]\\n\\n        def pmax(i, j):\\n            if (i,j) in maxcache: return maxcache[(i,j)]\\n            if i == j: return piles[i]\\n            maxcache[(i,j)] =  max(piles[i] + pmin(i+1, j), pmin(i, j-1) + piles[j])\\n            return maxcache[(i,j)]\\n\\n        mincache, maxcache = {}, {}\\n        p1 = pmax(0, len(piles)-1)\\n        p2 = sum(piles) - p1\\n        return p1 > p2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1384508,
                "title": "python-two-solutions-dp-and-math-explained",
                "content": "#### Solution 1\\nLet us `dfs(i, j)` be the maximum difference Alex can gain if he plays optimally for piles `i ... j`. There there will be two options: player can take pile `i` or pile `j`. Note, that because turn chances, we need to take gain with minus sign, so we have options `P[i] - dp(i+1, j)` and `P[j] - dp(i, j-1)` and we choose the maximum one.\\n\\n#### Complexity\\nTime and space complexity is `O(n^2)`. Space complexity is also `O(n^2)`, which can be reduced to `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def stoneGame(self, P):\\n        @lru_cache(None)\\n        def dp(i, j): \\n            if i == j: return P[i]\\n            return max(P[i] - dp(i+1, j), P[j] - dp(i, j-1))\\n        \\n        return dp(0, len(P) - 1) > 0\\n```\\n\\n#### Solution 2\\nWe can prove that Alex always wins! The idea is that he always can play in such a way that he get all odd piles or all even piles. On the first move he needs to decide what is bigger and play this strategy.\\n\\n#### Complexity\\nIt is just `O(1)`\\n\\n#### Code\\n```python\\nclass Solution:\\n    def stoneGame(self, P):\\n\\t\\treturn True\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def stoneGame(self, P):\\n        @lru_cache(None)\\n        def dp(i, j): \\n            if i == j: return P[i]\\n            return max(P[i] - dp(i+1, j), P[j] - dp(i, j-1))\\n        \\n        return dp(0, len(P) - 1) > 0\\n```\n```python\\nclass Solution:\\n    def stoneGame(self, P):\\n\\t\\treturn True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 497647,
                "title": "java-dp-solution",
                "content": "The dp table stores how many stones the player can win between i and j.\\nAssume every player remains sober, then dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])\\n\\n```\\nclass Solution {\\n    public boolean stoneGame(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return true;\\n        }\\n\\n        int[][] dp = new int[nums.length][nums.length];\\n\\t\\t\\n\\t// dp initialization\\n        for (int i = 0; i < dp.length; i++) {\\n            dp[i][i] = nums[i];\\n        }\\n\\t\\t\\n\\t// filling dp table\\n        for (int len = 2; len <= nums.length; len++) {\\n            for (int i = 0; i < nums.length; i++) {\\n                int j = i + len - 1;\\n                if (j >= nums.length) {\\n                    continue;\\n                }\\n                dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\\n            }\\n        }\\n        return dp[0][nums.length - 1] > 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            return true;\\n        }\\n\\n        int[][] dp = new int[nums.length][nums.length];\\n\\t\\t\\n\\t// dp initialization\\n        for (int i = 0; i < dp.length; i++) {\\n            dp[i][i] = nums[i];\\n        }\\n\\t\\t\\n\\t// filling dp table\\n        for (int len = 2; len <= nums.length; len++) {\\n            for (int i = 0; i < nums.length; i++) {\\n                int j = i + len - 1;\\n                if (j >= nums.length) {\\n                    continue;\\n                }\\n                dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\\n            }\\n        }\\n        return dp[0][nums.length - 1] > 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346757,
                "title": "c-minimax-game-theory-stone-game",
                "content": "- https://en.wikipedia.org/wiki/Minimax\\n\\n**Related Questions:**\\n\\n- https://leetcode.com/problems/stone-game-vii/\\n- https://leetcode.com/problems/stone-game-ii/description/\\n- https://leetcode.com/problems/nim-game/description/\\n- https://leetcode.com/problems/predict-the-winner/description/ \\n- https://leetcode.com/problems/can-i-win/description/ (Bitmasking, DP)\\n\\n\\n`score = Score(Alex) - Score(Lee)`. Alex, who is optimally playing wins only if `score > 0`, and should add to the score because he wants to maximize it. Lee, who is also playing optimally, wants to minimize the score variable, and deducts from it.\\n\\n```\\nclass Solution {\\npublic: \\n    int dp[501][501][2];\\n    \\n    int getAns(int l, int r, vector <int> &piles, int turn) {\\n        \\n        if(l > r) {\\n            return 0;\\n        }\\n        \\n        if(dp[l][r][turn]!=-1) {\\n            return dp[l][r][turn];\\n        }\\n        \\n        int res = 0;\\n        \\n        if(turn == 0) {\\n            res = max(piles[l] + getAns(l+1,r,piles,1-turn), piles[r] + getAns(l,r-1,piles,1-turn));\\n        } else {\\n            res = min(getAns(l+1,r,piles,1-turn) - piles[l], getAns(l,r-1,piles,1-turn) - piles[r]);\\n        }\\n        \\n        dp[l][r][turn] = res;\\n        return res;\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        int l = 0;\\n        int r = piles.size()-1;\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        // score = score(Alex) - score(Lee)\\n        int score = getAns(l, r, piles, 0); // 0 -> Alex turn\\n        \\n        return score > 0;\\n    }\\n};\\n```\\n\\n- https://leetcode.com/problems/stone-game-vii/\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001][2];\\n    \\n    int getAns(int l, int r, vector <int> &piles, int turn, int sum) {\\n        if(l > r) {\\n            return 0;\\n        }\\n        \\n        if(dp[l][r][turn]!=-1) {\\n            return dp[l][r][turn];\\n        }\\n        \\n        int res = 0;\\n        int L = sum - piles[l];\\n        int R = sum - piles[r];\\n        \\n        if(turn == 0) {\\n            res = max(L + getAns(l+1,r,piles,1-turn, L), R + getAns(l,r-1,piles,1-turn, R));\\n        } else {\\n            res = min(getAns(l+1,r,piles,1-turn, L) - L, getAns(l,r-1,piles,1-turn, R) - R);\\n        }\\n        \\n        dp[l][r][turn] = res;\\n        return res;\\n    }\\n    \\n    int stoneGameVII(vector<int>& piles) {\\n        int l = 0;\\n        int r = piles.size()-1;\\n        \\n        int sum = 0;\\n        for (int i = 0; i < piles.size(); i++) {\\n            sum += piles[i];\\n        }\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        // score = score(Alice) - score(Bob)\\n        int score = getAns(l, r, piles, 0, sum); // 0 -> Alice turn\\n        return score;\\n    }\\n};\\n```\\n- https://leetcode.com/problems/divisor-game/description/\\n\\n```\\n\\n// Bottom Up\\nclass Solution {\\npublic:\\n    \\n    bool divisorGame(int N) {\\n        vector<bool> winningState(N+1);\\n        winningState[1] = false;\\n        winningState[2] = true;\\n        \\n        for(int i=3;i<=N;i++) {\\n            bool res = false;\\n            for(int j=1;j<i;j++) {\\n                if(i % j == 0) {\\n                    res |= (!winningState[i-j]);\\n                }\\n            }\\n            winningState[i] = res;\\n        }\\n        return winningState[N]; \\n    }\\n};\\n\\n// Top Down\\nclass Solution {\\npublic:\\n    \\n    map<pair<int,int>, bool> winningState; \\n    \\n    bool getAns(int N, int turn) {\\n        if(winningState.find({N,turn}) != winningState.end()) {\\n            return winningState[{N,turn}] ;\\n        }\\n        \\n        bool win = false;\\n            \\n        for(int x=1;x<N;x++) {\\n            if(N % x == 0) {\\n                bool res = getAns(N - x, turn^1);\\n                win |= (!res);\\n            } \\n        }\\n        winningState[{N,turn}] = win;\\n        return win;\\n    }\\n    \\n    bool divisorGame(int N) {\\n        return getAns(N,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic: \\n    int dp[501][501][2];\\n    \\n    int getAns(int l, int r, vector <int> &piles, int turn) {\\n        \\n        if(l > r) {\\n            return 0;\\n        }\\n        \\n        if(dp[l][r][turn]!=-1) {\\n            return dp[l][r][turn];\\n        }\\n        \\n        int res = 0;\\n        \\n        if(turn == 0) {\\n            res = max(piles[l] + getAns(l+1,r,piles,1-turn), piles[r] + getAns(l,r-1,piles,1-turn));\\n        } else {\\n            res = min(getAns(l+1,r,piles,1-turn) - piles[l], getAns(l,r-1,piles,1-turn) - piles[r]);\\n        }\\n        \\n        dp[l][r][turn] = res;\\n        return res;\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        int l = 0;\\n        int r = piles.size()-1;\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        // score = score(Alex) - score(Lee)\\n        int score = getAns(l, r, piles, 0); // 0 -> Alex turn\\n        \\n        return score > 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001][2];\\n    \\n    int getAns(int l, int r, vector <int> &piles, int turn, int sum) {\\n        if(l > r) {\\n            return 0;\\n        }\\n        \\n        if(dp[l][r][turn]!=-1) {\\n            return dp[l][r][turn];\\n        }\\n        \\n        int res = 0;\\n        int L = sum - piles[l];\\n        int R = sum - piles[r];\\n        \\n        if(turn == 0) {\\n            res = max(L + getAns(l+1,r,piles,1-turn, L), R + getAns(l,r-1,piles,1-turn, R));\\n        } else {\\n            res = min(getAns(l+1,r,piles,1-turn, L) - L, getAns(l,r-1,piles,1-turn, R) - R);\\n        }\\n        \\n        dp[l][r][turn] = res;\\n        return res;\\n    }\\n    \\n    int stoneGameVII(vector<int>& piles) {\\n        int l = 0;\\n        int r = piles.size()-1;\\n        \\n        int sum = 0;\\n        for (int i = 0; i < piles.size(); i++) {\\n            sum += piles[i];\\n        }\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        // score = score(Alice) - score(Bob)\\n        int score = getAns(l, r, piles, 0, sum); // 0 -> Alice turn\\n        return score;\\n    }\\n};\\n```\n```\\n\\n// Bottom Up\\nclass Solution {\\npublic:\\n    \\n    bool divisorGame(int N) {\\n        vector<bool> winningState(N+1);\\n        winningState[1] = false;\\n        winningState[2] = true;\\n        \\n        for(int i=3;i<=N;i++) {\\n            bool res = false;\\n            for(int j=1;j<i;j++) {\\n                if(i % j == 0) {\\n                    res |= (!winningState[i-j]);\\n                }\\n            }\\n            winningState[i] = res;\\n        }\\n        return winningState[N]; \\n    }\\n};\\n\\n// Top Down\\nclass Solution {\\npublic:\\n    \\n    map<pair<int,int>, bool> winningState; \\n    \\n    bool getAns(int N, int turn) {\\n        if(winningState.find({N,turn}) != winningState.end()) {\\n            return winningState[{N,turn}] ;\\n        }\\n        \\n        bool win = false;\\n            \\n        for(int x=1;x<N;x++) {\\n            if(N % x == 0) {\\n                bool res = getAns(N - x, turn^1);\\n                win |= (!res);\\n            } \\n        }\\n        winningState[{N,turn}] = win;\\n        return win;\\n    }\\n    \\n    bool divisorGame(int N) {\\n        return getAns(N,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882969,
                "title": "c-recursive-dp-minimax-solution",
                "content": "Runtime: 28 ms, faster than 35.53% of C++ online submissions for Stone Game.\\nMemory Usage: 9.2 MB, less than 38.94% of C++ online submissions for Stone Game.\\n\\nSolved using MiniMax Algorithm where player1 tries to maximize his score and player2 tries to \\nminimize player1\\'s score recursively. To get the game score between two player we can add player1\\'s\\nchoice and deduce player2\\'s choice which will give max score of player1 - max score of player 2 at the end,\\ngiven that player1 took the first turn in the game.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // Alex\\'s turn adds piles and Lee\\'s turn deducts piles\\n    // Game result = max piles count of Alex - max piles count of Lee\\n    // dp vector tracks the game result in range l to h\\n    int dp[501][501]={};\\n    \\n    int takeStone(bool alex, int l, int h, vector<int>& piles)\\n    {\\n        // base cases\\n        if(l>h) return 0;\\n        if(l==h) return piles[l];\\n        \\n        // return precalculated result\\n        if(dp[l][h]!=-1) return dp[l][h];\\n        \\n        // alex\\'s turn, alex can take either piles[l] or piles[h] so we add them with the recursion call as\\n        // piles[l]+takeStone(l+1,h) or piles[h]+takeStone(l,h-1) and get the max value betweeen them \\n        // for getting the game result as alex always tries to maximize his pile count\\n        if(alex)    \\n            dp[l][h] = max(piles[l]+takeStone(!alex,l+1,h,piles),piles[h]+takeStone(!alex,l,h-1,piles));\\n        \\n        // lee\\'s turn, choice for lee is same as alex, only differece is that lee wants to maximize his\\n        // game result by minimizing alex\\'s result and so we return the min value between those two choices\\n        // also to get game result we deduct piles[l] or piles[h] with recursion calls\\n        else\\n            dp[l][h] = min(-piles[l]+takeStone(!alex,l+1,h,piles),-piles[h]+takeStone(!alex,l,h-1,piles));\\n\\n        return dp[l][h];\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        \\n        int n = piles.size();\\n        memset(dp,-1,sizeof(dp));\\n        \\n        // alex turn = true, lee turn = false\\n        // Game result = max piles count of Alex - max piles count of Lee\\n        // If result > 0 then Alex wins\\n        return takeStone(true,0,n-1,piles) > 0;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Alex\\'s turn adds piles and Lee\\'s turn deducts piles\\n    // Game result = max piles count of Alex - max piles count of Lee\\n    // dp vector tracks the game result in range l to h\\n    int dp[501][501]={};\\n    \\n    int takeStone(bool alex, int l, int h, vector<int>& piles)\\n    {\\n        // base cases\\n        if(l>h) return 0;\\n        if(l==h) return piles[l];\\n        \\n        // return precalculated result\\n        if(dp[l][h]!=-1) return dp[l][h];\\n        \\n        // alex\\'s turn, alex can take either piles[l] or piles[h] so we add them with the recursion call as\\n        // piles[l]+takeStone(l+1,h) or piles[h]+takeStone(l,h-1) and get the max value betweeen them \\n        // for getting the game result as alex always tries to maximize his pile count\\n        if(alex)    \\n            dp[l][h] = max(piles[l]+takeStone(!alex,l+1,h,piles),piles[h]+takeStone(!alex,l,h-1,piles));\\n        \\n        // lee\\'s turn, choice for lee is same as alex, only differece is that lee wants to maximize his\\n        // game result by minimizing alex\\'s result and so we return the min value between those two choices\\n        // also to get game result we deduct piles[l] or piles[h] with recursion calls\\n        else\\n            dp[l][h] = min(-piles[l]+takeStone(!alex,l+1,h,piles),-piles[h]+takeStone(!alex,l,h-1,piles));\\n\\n        return dp[l][h];\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        \\n        int n = piles.size();\\n        memset(dp,-1,sizeof(dp));\\n        \\n        // alex turn = true, lee turn = false\\n        // Game result = max piles count of Alex - max piles count of Lee\\n        // If result > 0 then Alex wins\\n        return takeStone(true,0,n-1,piles) > 0;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385866,
                "title": "java-python-concise-code",
                "content": "Whenever question is about two player and both plays optimally then the key to solving the problem is **making a  optimal choice in the recursion and subtract the next recursive value**\\n\\nExplaination ->\\n\\nAlex plays a optimal move  ( recursion 1 ) \\nthen\\nBob plays a optimal move ( recursion 2)\\nthen \\nAlex plays a optimal move ( recursion 3 )\\n\\t\\nFrom this we can derive we have to add the odd recursion stack values and subtract the even ones, thats why in the code we are subtracking the next recursion value\\n\\nrecursion1 \\n\\tAlex optimal choice - recursion2\\nrecursion2\\n\\tBob optimal choice - recursion3 \\n\\nsubsituting the value of recursion2 in recursion1 we get\\nrecursion1 \\n\\tAlex optimal choice - (Bob optimal choice - recursion3 ) =Alex optimal choice- (Bob optimal choice)+recursion3\\n\\nPython\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        @cache # annotation which caches the repeated recursive calls.No need to store in dp arrays\\n        def recursion( start=0,end=len(piles)-1):\\n            if start >= end:\\n                return 0\\n\\t\\t\\t\\t\\n            choice1 = piles[start] - recursion( start+1,end)\\n            choice2 = piles[end] - recursion(start,end-1)\\n      \\n            return max( choice1, choice2 )\\n        \\n        result = recursion()\\n        return result > 0\\n```\\n\\n\\nJava\\n```\\nclass Solution {\\n    Integer[][] dp = new Integer[501][501];\\n    public boolean stoneGame(int[] piles) {\\n        return recursion( 0,piles.length-1,piles) > 0;\\n    }\\n    \\n    public int recursion( int start, int end, int[] piles )\\n    {\\n        if( start > end )\\n            return 0;\\n        if( dp[start][end] != null )\\n            return dp[start][end];\\n\\t\\t\\t\\n        int option1 = piles[start]-recursion( start+1,end,piles);\\n        int option2 = piles[end]-recursion(start,end-1,piles);\\n        \\n        return dp[start][end] = Math.max(option1,option2);\\n    }\\n}\\n```\\n\\nSpace Complexity is O(n2)\\nTime Complexity is O(n2) since in the recursion call we have two parameters and order will be n2\\n\\nIf you find it useful, **Please upvote**\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        @cache # annotation which caches the repeated recursive calls.No need to store in dp arrays\\n        def recursion( start=0,end=len(piles)-1):\\n            if start >= end:\\n                return 0\\n\\t\\t\\t\\t\\n            choice1 = piles[start] - recursion( start+1,end)\\n            choice2 = piles[end] - recursion(start,end-1)\\n      \\n            return max( choice1, choice2 )\\n        \\n        result = recursion()\\n        return result > 0\\n```\n```\\nclass Solution {\\n    Integer[][] dp = new Integer[501][501];\\n    public boolean stoneGame(int[] piles) {\\n        return recursion( 0,piles.length-1,piles) > 0;\\n    }\\n    \\n    public int recursion( int start, int end, int[] piles )\\n    {\\n        if( start > end )\\n            return 0;\\n        if( dp[start][end] != null )\\n            return dp[start][end];\\n\\t\\t\\t\\n        int option1 = piles[start]-recursion( start+1,end,piles);\\n        int option2 = piles[end]-recursion(start,end-1,piles);\\n        \\n        return dp[start][end] = Math.max(option1,option2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485238,
                "title": "rz-top-down-and-bottom-up-solutions-in-python",
                "content": "In this problem there are two players picking up stones from piles, each player can pick one pile from the left end or right end and the goal is to get the most stones.\\n\\nOne important info is that both players will play optimally, so after one player makes the best move, the other player will again make his best move out of the rest piles, then the problem player two faces is a sub-problem of the one player one faces (as it has one less pile to deal with).\\n\\nSince the final winner is the one with more stones, either we compare both players stones in the end to decide who wins, this way we need to keep two numbers, one for each player, or we can just record the max difference of stones between \\'current\\' player and \\'the other\\' player, if finally the difference is greater than 0, it means player 1 can win.\\n\\n**1. Top down solution with memoization ---> O(n ^ 2) time, O(n ^ 2) space**\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return self.helper(piles, 0, len(piles) - 1, {}) > 0\\n    \\n\\t# returns the maximum number of stones current player can get more than the other player out of piles[i] ... piles[j]\\n    def helper(self, piles, l, r, cache):\\n        if (l, r) in cache:\\n            return cache[(l, r)]\\n        if l > r:\\n            return 0\\n        if l == r:\\n            return piles[l]\\n        \\n\\t\\t\"\"\" \\n\\t\\tassume current player is player 1, then if player 1 chooses piles[l], \\n\\t\\tself.helper(piles, l + 1, r, cache) will return the maximum stones player 2 \\n\\t\\tcan get more than player 1 from the rest (piles[l + 1] ... piles[r]), then\\n\\t\\tby subtracting it from piles[l], we get how many stones player 1 can get\\n\\t\\tmore than player 2. Since we want to maximize final result, we choose the\\n\\t\\tmax of both options player 1 can make (pick piles[l] or piles[r])\\n\\t\\t\"\"\"\\n        res = max(piles[l] - self.helper(piles, l + 1, r, cache), piles[r] - self.helper(piles, l, r - 1, cache))\\n        cache[(l, r)] = res\\n        return res\\n```\\n\\n**2. Bottom up solution ---> O(n ^ 2) time, O(n ^ 2) space**\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        n = len(piles)\\n        f = [[0 for _ in range(n)] for _ in range(n)]\\n        \\n        for i in range(n):\\n            f[i][i] = piles[i]\\n        \\n        for i in range(n - 1, -1, -1):\\n            for j in range(i + 1, n):\\n                f[i][j] = max(piles[i] - f[i + 1][j], piles[j] - f[i][j - 1])\\n        \\n        return f[0][n - 1] > 0\\n```\\n**3. Bottom up solution ---> O(n ^ 2) time, O(n) space**\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        n = len(piles)\\n        f = [0] * n\\n        \\n        for i in range(n - 1, -1, -1):\\n            for j in range(i + 1, n):\\n                f[j] = max(piles[i] - f[j], piles[j] - f[j - 1])\\n        \\n        return f[n - 1] > 0\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return self.helper(piles, 0, len(piles) - 1, {}) > 0\\n    \\n\\t# returns the maximum number of stones current player can get more than the other player out of piles[i] ... piles[j]\\n    def helper(self, piles, l, r, cache):\\n        if (l, r) in cache:\\n            return cache[(l, r)]\\n        if l > r:\\n            return 0\\n        if l == r:\\n            return piles[l]\\n        \\n\\t\\t\"\"\" \\n\\t\\tassume current player is player 1, then if player 1 chooses piles[l], \\n\\t\\tself.helper(piles, l + 1, r, cache) will return the maximum stones player 2 \\n\\t\\tcan get more than player 1 from the rest (piles[l + 1] ... piles[r]), then\\n\\t\\tby subtracting it from piles[l], we get how many stones player 1 can get\\n\\t\\tmore than player 2. Since we want to maximize final result, we choose the\\n\\t\\tmax of both options player 1 can make (pick piles[l] or piles[r])\\n\\t\\t\"\"\"\\n        res = max(piles[l] - self.helper(piles, l + 1, r, cache), piles[r] - self.helper(piles, l, r - 1, cache))\\n        cache[(l, r)] = res\\n        return res\\n```\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        n = len(piles)\\n        f = [[0 for _ in range(n)] for _ in range(n)]\\n        \\n        for i in range(n):\\n            f[i][i] = piles[i]\\n        \\n        for i in range(n - 1, -1, -1):\\n            for j in range(i + 1, n):\\n                f[i][j] = max(piles[i] - f[i + 1][j], piles[j] - f[i][j - 1])\\n        \\n        return f[0][n - 1] > 0\\n```\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        n = len(piles)\\n        f = [0] * n\\n        \\n        for i in range(n - 1, -1, -1):\\n            for j in range(i + 1, n):\\n                f[j] = max(piles[i] - f[j], piles[j] - f[j - 1])\\n        \\n        return f[n - 1] > 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564917,
                "title": "cpp-recursive-memoization-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Optimal Strategy:** \\n`Understand that both players play optimally, meaning they will always choose the move that gives them the maximum score. Keep in mind that each player will try to minimize the opponent\\'s score while maximizing their own.`\\n\\n**Recursion with Memoization**:\\n` Use recursion to explore all possible moves and outcomes. Break down the problem into subproblems by considering different choices for the current player (either picking the first or last pile). To optimize the solution, implement memoization to store and reuse previously computed results, reducing redundant calculations.`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1)  The function solve takes several parameters:\\n\\n    - piles is a reference to a vector of integers representing the  piles of stones.\\n    - start and end represent the indices of the current subarray being considered.\\n    - turn is a boolean flag indicating whether it is the current player\\'s turn or not.\\n    - dp is a reference to a 2D vector used for memoization.\\n    \\n2) The base case of the recursion is checked first. If start becomes greater than end, it means there are no more piles left to consider, so the function returns 0. This represents the score of the current player when there are no more moves to make.\\n\\n3) The next step is to check if the current subproblem has already been solved and its result is stored in the dp array. If dp[start][end] is not equal to -1, it means the subproblem has already been solved and the result is returned directly from the dp array.\\n\\n4) Depending on the value of turn, two scenarios are considered:\\n\\n- If it is the current player\\'s turn (turn is true), two recursive calls are made to evaluate the scores when choosing either the first or the last pile. The scores are calculated by calling solve recursively with the updated values of start and end and turn set to false. The score of choosing the first pile is solve(piles, start+1, end, false, dp) + piles[start], and the score of choosing the last pile is solve(piles, start, end-1, false, dp) + piles[end]. The maximum score between the two options is returned and stored in dp[start][end].\\n- If it is not the current player\\'s turn (turn is false), the same process is followed, but this time the scores are calculated by subtracting the chosen pile\\'s value from the recursive calls. The score of not choosing the first pile is solve(piles, start+1, end, true, dp) - piles[start], and the score of not choosing the last pile is solve(piles, start, end-1, true, dp) - piles[end]. Again, the maximum score between the two options is returned and stored in dp[start][end].\\n\\n5. Finally, in the stoneGame function, the initial values for start, end, turn, and dp are set. The dp array is initialized with -1, indicating that no subproblems have been solved yet. Then, the solve function is called with the initial parameters, and its result is returned as the final answer.\\n\\n\\n# Complexity\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Time Complexity:\\nThe time complexity of the code depends on the number of subproblems that need to be solved. Since the code uses memoization, each subproblem is solved only once. The number of subproblems is determined by the number of unique combinations of start and end indices, which is approximately (n^2)/2, where n is the number of piles. For each subproblem, the code makes two recursive calls. Therefore, the overall time complexity can be expressed as O(n^3), where n is the number of piles.\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- Space Complexity:\\nThe space complexity is determined by the space required for the memoization table (dp array) and the recursion stack. The size of the dp array is (n+1) x (n+1), where n is the number of piles. Hence, the space complexity for the dp array is O(n^2). The recursion stack depth is proportional to the number of recursive calls made, which is also approximately (n^2)/2. Therefore, the space complexity of the recursion stack is O(n^2).\\n\\n# **Recursive Code**\\n\\n```\\nbool solve(vector<int>& piles, int start, int end, bool turn)\\n    {\\n        if(start>end)\\n        return 0;\\n\\n        if(turn)\\n        {\\n            int rr1 = solve(piles,start+1,end,false) + piles[start];\\n            int rr2 = solve(piles,start,end-1,false) + piles[end];\\n            return max(rr1,rr2);\\n        }\\n        int rr1 = solve(piles,start+1,end,true) - piles[start];\\n        int rr2 = solve(piles,start,end-1,true) - piles[end];\\n        return max(rr1,rr2);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int start = 0, end = piles.size()-1;\\n        bool turn = true;\\n        return solve(piles,start,end,turn);\\n    }\\n\\n```\\n# Memoization Code\\n```\\nclass Solution {\\npublic:\\n   bool solve(vector<int>& piles, int start, int end, bool turn,vector<vector<int>> &dp)\\n    {\\n        if(start>end)\\n        return 0;\\n\\n        if(dp[start][end]!=-1)\\n        return dp[start][end];\\n\\n\\n        if(turn)\\n        {\\n            int rr1 = solve(piles,start+1,end,false,dp) + piles[start];\\n            int rr2 = solve(piles,start,end-1,false,dp) + piles[end];\\n            return dp[start][end] = max(rr1,rr2);\\n        }\\n        int rr1 = solve(piles,start+1,end,true,dp) - piles[start];\\n        int rr2 = solve(piles,start,end-1,true,dp) - piles[end];\\n        return dp[start][end] = max(rr1,rr2);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int start = 0, end = piles.size()-1;\\n        bool turn = true;\\n        int n = piles.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return solve(piles,start,end,turn,dp);\\n    }\\n};\\n```\\n![coderuns.jpeg](https://assets.leetcode.com/users/images/f089014f-419f-4fb3-bade-ffbdb3e954f1_1685278388.128951.jpeg)\\nIf you like the solution please upvote.....\\uD83D\\uDE09\\n\\n",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nbool solve(vector<int>& piles, int start, int end, bool turn)\\n    {\\n        if(start>end)\\n        return 0;\\n\\n        if(turn)\\n        {\\n            int rr1 = solve(piles,start+1,end,false) + piles[start];\\n            int rr2 = solve(piles,start,end-1,false) + piles[end];\\n            return max(rr1,rr2);\\n        }\\n        int rr1 = solve(piles,start+1,end,true) - piles[start];\\n        int rr2 = solve(piles,start,end-1,true) - piles[end];\\n        return max(rr1,rr2);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int start = 0, end = piles.size()-1;\\n        bool turn = true;\\n        return solve(piles,start,end,turn);\\n    }\\n\\n```\n```\\nclass Solution {\\npublic:\\n   bool solve(vector<int>& piles, int start, int end, bool turn,vector<vector<int>> &dp)\\n    {\\n        if(start>end)\\n        return 0;\\n\\n        if(dp[start][end]!=-1)\\n        return dp[start][end];\\n\\n\\n        if(turn)\\n        {\\n            int rr1 = solve(piles,start+1,end,false,dp) + piles[start];\\n            int rr2 = solve(piles,start,end-1,false,dp) + piles[end];\\n            return dp[start][end] = max(rr1,rr2);\\n        }\\n        int rr1 = solve(piles,start+1,end,true,dp) - piles[start];\\n        int rr2 = solve(piles,start,end-1,true,dp) - piles[end];\\n        return dp[start][end] = max(rr1,rr2);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int start = 0, end = piles.size()-1;\\n        bool turn = true;\\n        int n = piles.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return solve(piles,start,end,turn,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710180,
                "title": "explanation",
                "content": "**Roadmap**\\n\\n1. \\u0917\\u094C\\u0930 \\u0915\\u0930\\u0928\\u0947 \\u0935\\u093E\\u0932\\u0947 \\u092C\\u093E\\u0924 \\u092F\\u0939 \\u0939\\u0948 \\u0915\\u0940 piles array \\u0915\\u0940 length, even \\u0939\\u0948, \\u0907\\u0938\\u0915\\u093E \\u092E\\u0924\\u0932\\u092C \\u092F\\u0939 \\u0939\\u0948 \\u0915\\u0940 array  \\u092E\\u0947\\u0902 even index  \\u0914\\u0930 odd index \\u092C\\u0930\\u093E\\u092C\\u0930 \\u0939\\u094B\\u0902\\u0917\\u0947\\u0964  \\n2. \\u0926\\u0942\\u0938\\u0930\\u0940 \\u0917\\u094C\\u0930 \\u0915\\u0930\\u0928\\u0947 \\u0935\\u093E\\u0932\\u0940 \\u092C\\u093E\\u0924 \\u092F\\u0947 \\u0939\\u0948 \\u0915\\u0940 , array \\u0915\\u0947 \\u0938\\u093E\\u0930\\u0947 stones  \\u0915\\u093E sum, odd \\u0926\\u093F\\u092F\\u093E \\u0917\\u092F\\u093E \\u0939\\u0948\\u0964  \\u0915\\u092D\\u0940 \\u092D\\u0940 \\u0915\\u094B\\u0908 2 numbers  \\u0915\\u093E sum odd \\u0924\\u092D\\u0940 \\u0906\\u0924\\u093E \\u0939\\u0948 \\u091C\\u092C \\u0939\\u092E \\u0909\\u0928 \\u0926\\u094B\\u0928\\u094B\\u0902 \\u0928\\u0902\\u092C\\u0930\\u094D\\u0938 \\u092E\\u0947\\u0902 \\u0938\\u0947 \\u0915\\u094B\\u0908 \\u090F\\u0915 odd \\u0939\\u094B \\u0914\\u0930 \\u0926\\u0942\\u0938\\u0930\\u093E even \\u0939\\u094B\\u0924\\u093E \\u0939\\u0948 . \\n3. \\u0924\\u0940\\u0938\\u0930\\u0940 \\u0917\\u094C\\u0930 \\u0915\\u0930\\u0928\\u0947 \\u0935\\u093E\\u0932\\u0940 \\u092C\\u093E\\u0924 \\u092F\\u0939 \\u0930\\u0939\\u0940 \\u0915\\u0940 \\u0905\\u0917\\u0930 piles [i] \\u092E\\u0947\\u0902 \\u091C\\u0939\\u093E \\u092D\\u0940 \\' i \\' odd \\u0939\\u0948 \\u0909\\u0928 \\u0938\\u092D\\u0940 \\u0915\\u093E \\u091C\\u094B\\u095C \\u0932\\u093F\\u092F\\u093E \\u091C\\u093E\\u090F \\u0914\\u0930 \\u091C\\u0939\\u093E \\u092D\\u0940 \\' i \\'  \\u0907\\u0935\\u0928 \\u0939\\u0948 \\u0909\\u0928\\u0915\\u093E \\u091C\\u094B\\u095C \\u0932\\u093F\\u092F\\u093E \\u091C\\u093E\\u090F \\u0924\\u094B\\u0939 \\u092C\\u093F\\u0902\\u0926\\u0941 \\u0915\\u094D\\u0930\\u092E\\u093E\\u0902\\u0915 1 \\u0914\\u0930 2 \\u0915\\u0947 \\u0915\\u093E\\u0930\\u0923 \\u0909\\u0928 \\u0926\\u094B\\u0928\\u094B\\u0902  \\u092E\\u0947\\u0902 \\u0938\\u0947 \\u090F\\u0915 odd \\u0939\\u094B\\u0917\\u093E \\u0914\\u0930 \\u0926\\u0942\\u0938\\u0930\\u093E even \\u0939\\u094B\\u0917\\u0964  \\n\\n\\u0939\\u092E \\u0926\\u0947\\u0916 \\u0932\\u0947\\u0902\\u0917\\u0947 \\u0915\\u0940 sum of all the elements at piles[even index] aur piles[odd indices] \\u092E\\u0947\\u0902 \\u0938\\u0947 \\u091C\\u094B \\u092C\\u095C\\u093E \\u0939\\u094B \\u0935\\u094B Akshay \\u0932\\u0947 \\u0932\\u0947\\u0917\\u093E \\u0914\\u0930 Binod \\u0915\\u094B \\u091B\\u094B\\u091F\\u093E \\u0935\\u093E\\u0932\\u093E sum \\u0932\\u0947\\u0928\\u093E \\u0915\\u0940 \\u092A\\u095C\\u0947\\u0917\\u0964  \\u0907\\u0938\\u0932\\u093F\\u090F \\u092F\\u0939 \\u0916\\u0947\\u0932 \\u0935\\u094B \\u091C\\u0940\\u0924\\u0947\\u0917\\u093E \\u091C\\u094B \\u092A\\u0939\\u0932\\u0947 \\u091A\\u093E\\u0932 \\u091A\\u0932\\u0947\\u0917\\u0964  Akshay \\u0915\\u094B \\u0939\\u0930\\u093E\\u0928\\u093E \\u0928\\u093E\\u092E\\u0941\\u092E\\u0915\\u093F\\u0928 \\u0939\\u0948\\u0964  \\n\\n\\u0964\\u0964  \\u0928\\u092E\\u0938\\u094D\\u0915\\u093E\\u0930\\u0964\\u0964   \\n\\n\\n**Code**\\n\\n\\n```\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1384682,
                "title": "python3-easy-solution",
                "content": "```\\ndef stoneGame(self, piles: List[int]) -> bool:\\n\\tn=len(piles)\\n\\tdef helper(i, j, alex, lee):\\n\\t\\tif i > j:\\n\\t\\t\\treturn alex > lee\\n\\t\\treturn helper(i + 1, j - 1, alex + piles[i], lee + piles[j]) or helper(i + 1, j - 1, alex + piles[j], lee + piles[i])\\n\\treturn helper(0, n - 1, 0, 0)",
                "solutionTags": [],
                "code": "```\\ndef stoneGame(self, piles: List[int]) -> bool:\\n\\tn=len(piles)\\n\\tdef helper(i, j, alex, lee):\\n\\t\\tif i > j:\\n\\t\\t\\treturn alex > lee\\n\\t\\treturn helper(i + 1, j - 1, alex + piles[i], lee + piles[j]) or helper(i + 1, j - 1, alex + piles[j], lee + piles[i])\\n\\treturn helper(0, n - 1, 0, 0)",
                "codeTag": "Python3"
            },
            {
                "id": 3566794,
                "title": "return-true",
                "content": "Alex is first to pick pile.\\npiles.length is even, and this lead to an interesting fact:\\nAlex can always pick odd piles or always pick even piles!\\n\\nFor example,\\nIf Alex wants to pick even indexed piles piles[0], piles[2], ....., piles[n-2],\\nhe picks first piles[0], then Lee can pick either piles[1] or piles[n - 1].\\nEvery turn, Alex can always pick even indexed piles and Lee can only pick odd indexed piles.\\n\\nIn the description, we know that sum(piles) is odd.\\nIf sum(piles[even]) > sum(piles[odd]), Alex just picks all evens and wins.\\nIf sum(piles[even]) < sum(piles[odd]), Alex just picks all odds and wins.\\n\\nSo, Alex always defeats Lee in this game.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345713,
                "title": "c-with-memorized-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int tot = 0;\\n        for (auto& x : piles) {\\n            tot += x;            \\n        }\\n        vector<vector<int> > dp(piles.size(), vector<int>(piles.size(), 0));    \\n        return maxStone(0, piles.size()-1, piles, dp) > tot/2;\\n    }\\n\\nprivate:\\n    int maxStone(int i, int j, vector<int>& piles, vector<vector<int> >& dp) {\\n        if (dp[i][j] > 0) {\\n            return dp[i][j];\\n        }\\n        else if (i+1 == j) {\\n            dp[i][j] = max(piles[i], piles[j]);\\n            return dp[i][j];\\n        }\\n        else {\\n            int a = piles[i] + min(maxStone(i+2,j, piles, dp), maxStone(i+1,j-1,piles,dp));\\n            int b = piles[j] + min(maxStone(i+1,j-1, piles, dp), maxStone(i, j-2, piles, dp));\\n            dp[i][j] = max(a,b);\\n            return dp[i][j];        \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int tot = 0;\\n        for (auto& x : piles) {\\n            tot += x;            \\n        }\\n        vector<vector<int> > dp(piles.size(), vector<int>(piles.size(), 0));    \\n        return maxStone(0, piles.size()-1, piles, dp) > tot/2;\\n    }\\n\\nprivate:\\n    int maxStone(int i, int j, vector<int>& piles, vector<vector<int> >& dp) {\\n        if (dp[i][j] > 0) {\\n            return dp[i][j];\\n        }\\n        else if (i+1 == j) {\\n            dp[i][j] = max(piles[i], piles[j]);\\n            return dp[i][j];\\n        }\\n        else {\\n            int a = piles[i] + min(maxStone(i+2,j, piles, dp), maxStone(i+1,j-1,piles,dp));\\n            int b = piles[j] + min(maxStone(i+1,j-1, piles, dp), maxStone(i, j-2, piles, dp));\\n            dp[i][j] = max(a,b);\\n            return dp[i][j];        \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855702,
                "title": "simple-intuitive-for-interviews-top-down-memoisation",
                "content": "When preparing for interviews keep the preparation generic for variety of problems. A simple recurrsive approach for this problem that I came up with after following editorial tips.\\n\\n```\\n    int n;\\n    int dp[][];\\n\\n    public boolean stoneGame(int[] piles) {\\n        n = piles.length;\\n        dp = new int[n][n];\\n\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n\\n        stoneGameHelper(0, piles, 0, piles.length - 1);\\n\\n        return dp[0][n - 1] > 0;\\n    }\\n\\n    private int stoneGameHelper(int playerToPlay, int[] piles, int start, int end) {\\n        if (start > end) {  // Base case for bounds\\n            return 0;\\n        }\\n\\n        if (start == end) {  // only remaining pile\\n            return piles[start];\\n        }\\n\\n        if (dp[start][end] != -1) return dp[start][end]; // Already computed window\\n\\n        int stones;\\n        if (playerToPlay == 0) { // \\'0\\' is Alex\\n            stones = Math.max(piles[start] + stoneGameHelper(1, piles, start + 1, end),\\n                    piles[end] + stoneGameHelper(1, piles, start, end - 1));\\n        } else { // Lee plays and deducts our points, since its optimal play we take the most negative value\\n            stones = Math.min(-piles[start] + stoneGameHelper(0, piles, start + 1, end),\\n                    -piles[end] + stoneGameHelper(0, piles, start, end - 1));\\n        }\\n        dp[start][end] = stones;\\n        return stones;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "When preparing for interviews keep the preparation generic for variety of problems. A simple recurrsive approach for this problem that I came up with after following editorial tips.\\n\\n```\\n    int n;\\n    int dp[][];\\n\\n    public boolean stoneGame(int[] piles) {\\n        n = piles.length;\\n        dp = new int[n][n];\\n\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n\\n        stoneGameHelper(0, piles, 0, piles.length - 1);\\n\\n        return dp[0][n - 1] > 0;\\n    }\\n\\n    private int stoneGameHelper(int playerToPlay, int[] piles, int start, int end) {\\n        if (start > end) {  // Base case for bounds\\n            return 0;\\n        }\\n\\n        if (start == end) {  // only remaining pile\\n            return piles[start];\\n        }\\n\\n        if (dp[start][end] != -1) return dp[start][end]; // Already computed window\\n\\n        int stones;\\n        if (playerToPlay == 0) { // \\'0\\' is Alex\\n            stones = Math.max(piles[start] + stoneGameHelper(1, piles, start + 1, end),\\n                    piles[end] + stoneGameHelper(1, piles, start, end - 1));\\n        } else { // Lee plays and deducts our points, since its optimal play we take the most negative value\\n            stones = Math.min(-piles[start] + stoneGameHelper(0, piles, start + 1, end),\\n                    -piles[end] + stoneGameHelper(0, piles, start, end - 1));\\n        }\\n        dp[start][end] = stones;\\n        return stones;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 182988,
                "title": "minimax-using-alpha-beta-pruning-written-in-java",
                "content": "**WARNING** - This solution will suffer from **TLE** in the test cases since it has an exponential time complexity. It\\'s intended to provide an implementation of the well known [alpha\\u2013beta pruning algorithm](https://en.wikipedia.org/wiki/Alpha\\u2013beta_pruning).\\n\\nFor a viable solution, Alex has a winning strategy according to [Zermelo\\'s theorem](https://en.wikipedia.org/wiki/Zermelo%27s_theorem_(game_theory)). So just return `true`.\\n\\n```java\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return minimax(piles, 0, piles.length - 1, Integer.MIN_VALUE, Integer.MAX_VALUE, true) > 0;\\n    }\\n    \\n    private int minimax(int[] piles, int begin, int end,\\n                        int alpha, int beta, boolean maximizing) {\\n        if (begin > end) return 0;\\n        \\n        if (maximizing) {\\n            int val = Integer.MIN_VALUE;\\n            val = Math.max(val, minimax(piles, begin + 1, end, alpha, beta, false) + piles[begin]);\\n            alpha = Math.max(alpha, val);\\n            if (alpha >= beta) return val;\\n\\t\\t\\t\\t\\t\\t\\n            val = Math.max(val, minimax(piles, begin, end - 1, alpha, beta, false) + piles[end]);\\n            return val;\\n        } else {\\n            int val = Integer.MAX_VALUE;\\n            val = Math.min(val, minimax(piles, begin + 1, end, alpha, beta, true) - piles[begin]);\\n            beta = Math.min(beta, val);\\n            if (alpha >= beta) return val;\\n\\t\\t\\t\\t\\t\\t\\n            val = Math.min(val, minimax(piles, begin, end - 1, alpha, beta, true) - piles[end]);\\n            return val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return minimax(piles, 0, piles.length - 1, Integer.MIN_VALUE, Integer.MAX_VALUE, true) > 0;\\n    }\\n    \\n    private int minimax(int[] piles, int begin, int end,\\n                        int alpha, int beta, boolean maximizing) {\\n        if (begin > end) return 0;\\n        \\n        if (maximizing) {\\n            int val = Integer.MIN_VALUE;\\n            val = Math.max(val, minimax(piles, begin + 1, end, alpha, beta, false) + piles[begin]);\\n            alpha = Math.max(alpha, val);\\n            if (alpha >= beta) return val;\\n\\t\\t\\t\\t\\t\\t\\n            val = Math.max(val, minimax(piles, begin, end - 1, alpha, beta, false) + piles[end]);\\n            return val;\\n        } else {\\n            int val = Integer.MAX_VALUE;\\n            val = Math.min(val, minimax(piles, begin + 1, end, alpha, beta, true) - piles[begin]);\\n            beta = Math.min(beta, val);\\n            if (alpha >= beta) return val;\\n\\t\\t\\t\\t\\t\\t\\n            val = Math.min(val, minimax(piles, begin, end - 1, alpha, beta, true) - piles[end]);\\n            return val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385589,
                "title": "my-1-line-solution-100-logic-0-code-with-explanation",
                "content": "All we need to do is return true because the game is a biased game which gives edge to player-1 so since draw is ruled out and player-1 plays optimally , player-1 always wins.\\n\\nsince the number of piles is even, player-1 will only select from either all odd positions or all even positions.\\n\\nIf player-1 decides to select even positions (by choosing pile[0] first) player-1 can  force player-2  into picking odd positions only.\\nIf player-1 decides to select odd positions (by choosing the last element) player can force player-2 into picking even positions only.\\nSo before the first move player-1 should calculate , if the total no of stones in  even position is greater than the total no of stones at odd positions then he should go with strictly choosing even positions only . else vise-versa. \\n\\nIn the description, we know that sum(piles) is odd.\\nIf sum(piles[even]) > sum(piles[odd]), Player-1 just picks all evens and wins.\\nIf sum(piles[even]) < sum(piles[odd]), Player-1 just picks all odds and wins\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 154779,
                "title": "java-recursion-memoization",
                "content": "We know that all the `even` turns are Alex\\'s and `odd` turns are Lee\\'s.\\n\\nWe can keep two pointers one from `start`, and one from `end`. We can select one of them first and see what is the result, then select the other one and again check what is the result. In any case if `Alex` wins, we need to return `true`, because he is the first guy to start game. We can recursively keep doing these simply.\\n\\nHowever, we know that we repeat same calls. For that, we can have a `HashMap`. Key must be unique for each `start&end` pair. If you\\'d like to you can have a `hash` function for them, or basically make the key String and put a comma `,` in between `start & end` and merge them together.\\n\\nBelow is my implementation:\\n```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        Map<String,Boolean> map = new HashMap<>();\\n        return util(piles, 0, piles.length - 1, 0, 0, map);\\n    }\\n    \\n    private Boolean util(int[] piles, int start, int end, int alex, int lee, Map<String,Boolean> map) {\\n        if (end < start) {\\n            return alex > lee;\\n        } \\n        String key = start + \",\" + end;\\n        if ((start + end) % 2 == 0) {\\n            if (!map.containsKey(key)) {\\n                Boolean val = util(piles, start + 1, end, alex + piles[start], lee, map) \\n                    || util(piles, start, end - 1, alex + piles[end], lee, map);\\n                map.put(key, val);\\n            }\\n            return map.get(key);\\n        } else {\\n            if (!map.containsKey(key)) {\\n                Boolean val = util(piles, start + 1, end, alex, lee + piles[start], map) \\n                    || util(piles, start, end - 1, alex, lee + piles[end], map);\\n                map.put(key, val);\\n            }\\n            return map.get(key);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        Map<String,Boolean> map = new HashMap<>();\\n        return util(piles, 0, piles.length - 1, 0, 0, map);\\n    }\\n    \\n    private Boolean util(int[] piles, int start, int end, int alex, int lee, Map<String,Boolean> map) {\\n        if (end < start) {\\n            return alex > lee;\\n        } \\n        String key = start + \",\" + end;\\n        if ((start + end) % 2 == 0) {\\n            if (!map.containsKey(key)) {\\n                Boolean val = util(piles, start + 1, end, alex + piles[start], lee, map) \\n                    || util(piles, start, end - 1, alex + piles[end], lee, map);\\n                map.put(key, val);\\n            }\\n            return map.get(key);\\n        } else {\\n            if (!map.containsKey(key)) {\\n                Boolean val = util(piles, start + 1, end, alex, lee + piles[start], map) \\n                    || util(piles, start, end - 1, alex, lee + piles[end], map);\\n                map.put(key, val);\\n            }\\n            return map.get(key);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260028,
                "title": "alice-always-wins-explained",
                "content": "**Explanation :**\\n\\n**Points to Ponder :**\\n**1) Alice will always choose the row with maximum stones(or equal stones) from extreme left/right end. \\n2) Number of rows are even.**\\n\\n**If there are just 2 piles then Alice picks the maximum one and wins the 2-Pile game.**\\n\\n**Now say if there are 4 piles, then : (1st 2nd 3rd 4th) piles\\nIf Alice takes the first pile initially, she can always take the third pile. If she takes the fourth pile initially, she can always take the second pile. At least one of first + third, second + fourth is larger, so she can always win.**\\n\\n**Now say N piles. Say the total no. of stones in the first, third, fifth, seventh, etc. piles are X, and the total no. of stones in second, fourth, sixth, eighth, etc. piles are Y. \\nAlice can always take either X or Y stones and one of the X or Y must be larger than the other.**\\n\\n**Hence, Atlast Alice will surely WIN.**\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n\\n```\\n**Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F\\nIf you have some \\uD83E\\uDD14 doubts feel free to bug me (^~^)***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900079,
                "title": "o-1-solution-with-explanation",
                "content": "explain\\nbecause it given that array size is even alice can either pick all odd indexed stone or all the even once \\nhow so??\\n--> consider an array arr of even size [a0,a1,a2,.........an-1] of length n, now if alice pick n-1 index then bob can either pick  n-2 or 0 th which are even then after bob\\'s pick there will be a 1 or a n-3 left to pick\\nsame logic can be applied if alice pick index 0 first  but this case alice will all even indexes\\n\\nsince alice have first choice she will pick max(all_even_indexed_sum, all_odd_indexed_sum) \\nand win the game\\n\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n          return true;\\n    }\\n};\\n\\n\\n//this is my first post do upvote it if you like it comment if my explaination isn\\'t good enough",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n          return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1755050,
                "title": "2-methods-c-bottom-up-dp-explained-and-o-1-method",
                "content": "# 1st Way \"Recursion+Memorise..\"\\nThe whole idea lie b/w the wining of alice or bob. We have only two choices `weather we select from start or select from end.`\\n==> alice has two option ( either choose first or last)\\n==> bob has two option (either choose first or last)\\n*----------------------------------------------------------------------*\\nSo, our recursive case handle some point \\n`solve(int start,int end ,piles,turn)`\\n`start`=>starting point of choices\\n`end`=>ending point of choices\\n`turn` =>its a boolean value which help` to chek weather its a turn of alice or bob.`\\n*----------------------------------------------------------------------*\\nwhen `turn =1`\\nIts` time for alice ,now alice has two choices weather select first or last`\\n=> So we` two choices`  1.`piles[i]+solve(i+1,j,piles,0)`  2.`piles[j]+solve(i,j-1,piles,0);`\\n=>we take maixum of both.\\n*----------------------------------------------------------------------*\\n`similary we do for turn =0`\\nwe try to` maximise the value of bob by decresing the value of alice.`\\n=> we `decrese the value that alice gain `.\\n=>` 1.  -piles[i]+solve(i+1,j,piles,1)`  `  2.  - piles[j]+solve(i,j-1,piles,1)`\\n=>taking minimum of both.\\n*----------------------------------------------------------------------*\\n```\\n\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    \\n     bool solve(int i,int j,vector<int>&piles,bool turn)\\n     {\\n         if(i>j)\\n         {\\n            \\n             return 0;\\n         }\\n         if(dp[i][j]!=-1)\\n         {\\n             return dp[i][j];\\n             \\n         }\\n        \\n \\n         if(turn ==1)\\n         {\\n              dp[i][j]= max(piles[i]+solve(i+1,j,piles,0),piles[j]+solve(i,j-1,piles,0));\\n         }\\n         else\\n         {\\n             dp[i][j]= min(-piles[i]+solve(i+1,j,piles,1),-piles[j]+solve(i,j-1,piles,1));\\n         }\\n         return dp[i][j];\\n         \\n     }\\n    \\n    \\n    bool stoneGame(vector<int>& piles) {\\n        \\n        int n=piles.size();\\n        for(int i=0;i<501;i++)\\n        {\\n            for(int j=0;j<501;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return solve(0,n-1,piles,1);\\n        \\n    }\\n};\\n```\\n\\n# 2nd way O(1)\\n# \\nIts quite obivous that sum of al`l piles is odd `it means` we can\\'t equall divide int two part.`\\nSo if we` slect all odd position piles =>pile_odd.`\\nand` select all even postion piles =>pile_even.`\\nAfter finding it\\nWe` conclude that` weather` pile_odd is stricttly greater or pile_even is stricly grater `\\nIf` pile_odd is greater`=>**alice selcet it and win the game**\\nif `pile_even is greater` =>**alice select it and win the game**\\nBoth case** alice win the game .**\\nSo we only have to **return true**\\n```\\n\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    \\n     bool solve(int i,int j,vector<int>&piles,bool turn)\\n     {\\n         if(i>j)\\n         {\\n            \\n             return 0;\\n         }\\n         if(dp[i][j]!=-1)\\n         {\\n             return dp[i][j];\\n             \\n         }\\n        \\n \\n         if(turn ==1)\\n         {\\n              dp[i][j]= max(piles[i]+solve(i+1,j,piles,0),piles[j]+solve(i,j-1,piles,0));\\n         }\\n         else\\n         {\\n             dp[i][j]= min(-piles[i]+solve(i+1,j,piles,1),-piles[j]+solve(i,j-1,piles,1));\\n         }\\n         return dp[i][j];\\n         \\n     }\\n    \\n    \\n    bool stoneGame(vector<int>& piles) {\\n        \\n        int n=piles.size();\\n        for(int i=0;i<501;i++)\\n        {\\n            for(int j=0;j<501;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return solve(0,n-1,piles,1);\\n        \\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384650,
                "title": "c-two-solution-with-explanation",
                "content": "```\\nmethod 1:(maths)\\nalex need to play optimally and and that is why he will always choose whatever suits him. As for example :[3,2,10,4]\\nhere , we may think that alex will first choose 4 and then our resulting array would be->[3,2,10] then lee will play optimally and choose 10 and so on.\\nbut alex need to play for himself as well as he also have to make lee lose in the match by choosing such a choice that in lee\\'s round he can\\'t choose best one.\\nand that is why he will choose 3 and our resulting array become->[2,10,4]\\nhere if lee play optimally then also he will pick 4 and alex automatically get 10 that is the highest one....\\nSo alex will win in each and every case...\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\nmethod 2:(dp)\\nin this method we are playing optimally without caring about alex and lee. \\nso we are choosing both first and last entry from the piles and \\nrecurse on the remainning piles so that the opponent can also play optimally\\nfor themselves.\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int solve(int i,int j,vector<int>&piles)\\n    {\\n        if(i==j)\\n            return dp[i][j]=piles[i];\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        return dp[i][j]=max(piles[i]-solve(i+1,j,piles),piles[j]-solve(i,j-1,piles));\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,piles.size()-1,piles)>0;\\n    }\\n};\\nplz endure with my english ....do upvote if you find it useful.........\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nmethod 1:(maths)\\nalex need to play optimally and and that is why he will always choose whatever suits him. As for example :[3,2,10,4]\\nhere , we may think that alex will first choose 4 and then our resulting array would be->[3,2,10] then lee will play optimally and choose 10 and so on.\\nbut alex need to play for himself as well as he also have to make lee lose in the match by choosing such a choice that in lee\\'s round he can\\'t choose best one.\\nand that is why he will choose 3 and our resulting array become->[2,10,4]\\nhere if lee play optimally then also he will pick 4 and alex automatically get 10 that is the highest one....\\nSo alex will win in each and every case...\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\nmethod 2:(dp)\\nin this method we are playing optimally without caring about alex and lee. \\nso we are choosing both first and last entry from the piles and \\nrecurse on the remainning piles so that the opponent can also play optimally\\nfor themselves.\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int solve(int i,int j,vector<int>&piles)\\n    {\\n        if(i==j)\\n            return dp[i][j]=piles[i];\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        return dp[i][j]=max(piles[i]-solve(i+1,j,piles),piles[j]-solve(i,j-1,piles));\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,piles.size()-1,piles)>0;\\n    }\\n};\\nplz endure with my english ....do upvote if you find it useful.........\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262913,
                "title": "using-dp-table-diagonally-filling-gap-strategy-storing-both-players-score-simultaneously",
                "content": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        \\n        int n = piles.size();\\n        pair<int, int> dp[n][n];\\n    \\n\\t\\t//filling first diagonal\\n        for(int i=0; i<n; i++)\\n            dp[i][i] = {piles[i], 0};\\n\\t\\t\\t\\n\\t\\t//second diagonal\\t\\n        for(int i=0; i<n-1; i++)\\n            dp[i][i+1] = {max(piles[i], piles[i+1]), min(piles[i], piles[i+1]) };\\n\\n        for(int k=3; k<=n; k++)\\n        {\\n            for(int i=0; i<=n-k; i++)\\n            {\\n                //i -> i+k-1....starting and ending index\\n                int x = piles[i] + dp[i+1][i+k-1].second;\\n                int y = piles[i+k-1] + dp[i][i+k-2].second;\\n\\n                if(x > y)\\n                {\\n                    dp[i][i+k-1].first = x;\\n                    dp[i][i+k-1].second = dp[i+1][i+k-1].first;\\n                }\\n                else\\n                {\\n                    dp[i][i+k-1].first = y;\\n                    dp[i][i+k-1].second = dp[i][i+k-2].first;\\n                }\\n            }\\n        }\\n\\n        return (dp[0][n-1].first > dp[0][n-1].second);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        \\n        int n = piles.size();\\n        pair<int, int> dp[n][n];\\n    \\n\\t\\t//filling first diagonal\\n        for(int i=0; i<n; i++)\\n            dp[i][i] = {piles[i], 0}",
                "codeTag": "Java"
            },
            {
                "id": 1099487,
                "title": "gap-strategy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        int dp[n][n];\\n        for(int g=0;g<n;g++){\\n            for(int i=0,j=g;j<n;j++,i++){\\n                if(g==0)\\n                    dp[i][j]=piles[i];\\n                else if(g==1)\\n                    dp[i][j]=max(piles[i],piles[j]);\\n                else{\\n                    int val1=piles[i]+min(dp[i+2][j],dp[i+1][j-1]);\\n                    int val2=piles[j]+min(dp[i+1][j-1],dp[i][j-2]);\\n                    dp[i][j]=max(val1,val2);\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        int dp[n][n];\\n        for(int g=0;g<n;g++){\\n            for(int i=0,j=g;j<n;j++,i++){\\n                if(g==0)\\n                    dp[i][j]=piles[i];\\n                else if(g==1)\\n                    dp[i][j]=max(piles[i],piles[j]);\\n                else{\\n                    int val1=piles[i]+min(dp[i+2][j],dp[i+1][j-1]);\\n                    int val2=piles[j]+min(dp[i+1][j-1],dp[i][j-2]);\\n                    dp[i][j]=max(val1,val2);\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096602,
                "title": "o-1-solution",
                "content": "0 1 2 3 4 5\\n[5 6 7 10 8 9]\\n\\nSo Alex can start with choosing odd or even indexed pile\\nSo if he chooses odd then Lee can only choose between even\\nas Suppose Alex chose 5th now l = 0 r = 4,so Lee got only even choice\\nNow as the problem says total stones are odd , so with carefull obervations if divide total number of stone as\\n\\ntotal(stones) = oddIndexed(stones) + evenIndexed(stones)\\nAs odd and even indexed stones can\\'t be equal then either of them is greater and in start Alex has the choice to restrict Lee to whatever index he wants , so if Alex plays optimally he would always win\\n\\n\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n   return true;\\n }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n   return true;\\n }",
                "codeTag": "Java"
            },
            {
                "id": 678326,
                "title": "java-simple-dp",
                "content": "dp[i][j] means when max diff the current player can get when i piles left, starting from jth pile\\n```\\n    public boolean stoneGame(int[] ps) {\\n        int n = ps.length, dp[][] = new int[n + 1][n + 1]; \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= n - i; j++) {\\n                dp[i][j] = Math.max(ps[j] - dp[i - 1][j + 1], ps[j + i - 1] - dp[i - 1][j]);\\n            }\\n        }\\n        return dp[n][0] > 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean stoneGame(int[] ps) {\\n        int n = ps.length, dp[][] = new int[n + 1][n + 1]; \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= n - i; j++) {\\n                dp[i][j] = Math.max(ps[j] - dp[i - 1][j + 1], ps[j + i - 1] - dp[i - 1][j]);\\n            }\\n        }\\n        return dp[n][0] > 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 643412,
                "title": "python-o-n-2-by-top-down-dp-w-comment",
                "content": "[Tutorial video in Chinese \\u4E2D\\u6587\\u89E3\\u984C\\u5F71\\u7247](https://www.youtube.com/watch?v=JjgNBSb_maE&t=27s)\\n\\nPython O( n^2 ) by top-down DP\\n\\n---\\n\\n**Implementation** by top-down DP:\\n\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        \\n        # DP Table\\n        memo = {}\\n\\n        def take(left, right):\\n            \\n            # Look-up DP Table\\n            if (left, right) in memo:\\n                return memo[(left, right)]\\n\\n            # Base case\\n            if left == right:\\n                return piles[left]\\n\\n            # General cases\\n            # Option_1\\n            take_first_pile = piles[left] - take(left+1, right)\\n\\n            # Option_2\\n            tkae_last_pile = piles[right] - take(left, right-1)\\n\\n            memo[(left, right)] = max( take_first_pile,  tkae_last_pile)\\n            return memo[(left, right)]\\n        #================================\\n        return take(0, len(piles)-1) > 0\\n```\\n\\n---\\n\\nThe solution below is just for fun and sharing\\n\\n**Implementation** by observation:\\n\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        \\n\\t\\t# Alice always win finally\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        \\n        # DP Table\\n        memo = {}\\n\\n        def take(left, right):\\n            \\n            # Look-up DP Table\\n            if (left, right) in memo:\\n                return memo[(left, right)]\\n\\n            # Base case\\n            if left == right:\\n                return piles[left]\\n\\n            # General cases\\n            # Option_1\\n            take_first_pile = piles[left] - take(left+1, right)\\n\\n            # Option_2\\n            tkae_last_pile = piles[right] - take(left, right-1)\\n\\n            memo[(left, right)] = max( take_first_pile,  tkae_last_pile)\\n            return memo[(left, right)]\\n        #================================\\n        return take(0, len(piles)-1) > 0\\n```\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        \\n\\t\\t# Alice always win finally\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 263935,
                "title": "always-win-and-why",
                "content": "Since there are even numbers, and sum is odd. You may decide to pick either all the odd or all the even terms, and the other person can only pick the other type of position. So if sum of all even terms is larger, you start with last one, otherwise, you start with the first one.\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910565,
                "title": "mind-blow-up-solution-beginer-friendly",
                "content": "# Intuition\\nAll the time Alice take the first number. So if alice isn\\'t stupid  she takes the big number of the list. Alice never lose the game.\\n\\n# Approach\\nWrite to the return True\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827656,
                "title": "recursion-memoization-easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nthis is a **(min, max) Problem**, Here for **Alice\\'s Turn** we have to **maximize the score** and for **Bob\\'s Turn** we have to **minimize the score**.\\n\\nAccording to the above situation, here i Implementate the **Recursive Code** and **Memoize** the Recursive Calls to Avoid TLE.\\n\\n\\n\\n# Complexity\\n- Time complexity:O(N^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:(N* N* 2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[501][501][2];\\n    int solve(vector<int> arr,int i,int j,int f)\\n    {\\n        if(i>j) return 0;\\n        if(dp[i][j][f]!=-1) return dp[i][j][f];\\n        if(f) return dp[i][j][f] = max(arr[i]+solve(arr,i+1,j,0),arr[j]+solve(arr,i,j-1,0));\\n        return dp[i][j][f] = min(-arr[i]+solve(arr,i+1,j,1),-arr[j]+solve(arr,i,j-1,1));\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(piles,0,piles.size()-1,1)>0;  \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/41e4e692-ea44-4d35-b02b-7ea128cfc619_1690531535.4428308.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501][2];\\n    int solve(vector<int> arr,int i,int j,int f)\\n    {\\n        if(i>j) return 0;\\n        if(dp[i][j][f]!=-1) return dp[i][j][f];\\n        if(f) return dp[i][j][f] = max(arr[i]+solve(arr,i+1,j,0),arr[j]+solve(arr,i,j-1,0));\\n        return dp[i][j][f] = min(-arr[i]+solve(arr,i+1,j,1),-arr[j]+solve(arr,i,j-1,1));\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(piles,0,piles.size()-1,1)>0;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168887,
                "title": "recursion-memoization-c-explained",
                "content": "# Approach :  RECURSION\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint alice(int idx1,int idx2,vector<int>&piles){\\n    int n=piles.size();\\n    if(idx1==n-1){\\n        return piles[idx1];\\n    }\\n    if(idx2==0){\\n        return piles[idx2];\\n    }\\n    int front=piles[idx1]+max(alice(idx1+1,idx2-1,piles),alice(idx1+1,idx2-1,piles));\\n    int back=piles[idx2]+max(alice(idx1+1,idx2-1,piles),alice(idx1+1,idx2-1,piles));\\n    return max(front,back);\\n}\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n ans+=piles[i];\\n        }\\n        int q=alice(0,n-1,piles);\\n        return q>(ans-q);\\n    }\\n};\\n```\\n\\n# Approach :  MEMOIZATION\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*N)+O(N)   {RECURION STACK SPACE}\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint alice(int idx1,int idx2,vector<int>&piles,vector<vector<int>>&dp){\\n    int n=piles.size();\\n    if(idx1==n-1){\\n        return piles[idx1];\\n    }\\n    if(idx2==0){\\n        return piles[idx2];\\n    }\\n    if(dp[idx1][idx2]!=-1){\\n        return dp[idx1][idx2];\\n    }\\n    int front=piles[idx1]+max(alice(idx1+1,idx2-1,piles,dp),alice(idx1+1,idx2-1,piles,dp));\\n    int back=piles[idx2]+max(alice(idx1+1,idx2-1,piles,dp),alice(idx1+1,idx2-1,piles,dp));\\n    return dp[idx1][idx2]=max(front,back);\\n}\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        int ans=0;\\n        vector<vector<int>>dp(n+1,vector<int>(n+1-1));\\n        for(int i=0;i<n;i++){\\n ans+=piles[i];\\n        }\\n        int q=alice(0,n-1,piles,dp);\\n        return q<(ans-q);\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint alice(int idx1,int idx2,vector<int>&piles){\\n    int n=piles.size();\\n    if(idx1==n-1){\\n        return piles[idx1];\\n    }\\n    if(idx2==0){\\n        return piles[idx2];\\n    }\\n    int front=piles[idx1]+max(alice(idx1+1,idx2-1,piles),alice(idx1+1,idx2-1,piles));\\n    int back=piles[idx2]+max(alice(idx1+1,idx2-1,piles),alice(idx1+1,idx2-1,piles));\\n    return max(front,back);\\n}\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n ans+=piles[i];\\n        }\\n        int q=alice(0,n-1,piles);\\n        return q>(ans-q);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint alice(int idx1,int idx2,vector<int>&piles,vector<vector<int>>&dp){\\n    int n=piles.size();\\n    if(idx1==n-1){\\n        return piles[idx1];\\n    }\\n    if(idx2==0){\\n        return piles[idx2];\\n    }\\n    if(dp[idx1][idx2]!=-1){\\n        return dp[idx1][idx2];\\n    }\\n    int front=piles[idx1]+max(alice(idx1+1,idx2-1,piles,dp),alice(idx1+1,idx2-1,piles,dp));\\n    int back=piles[idx2]+max(alice(idx1+1,idx2-1,piles,dp),alice(idx1+1,idx2-1,piles,dp));\\n    return dp[idx1][idx2]=max(front,back);\\n}\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        int ans=0;\\n        vector<vector<int>>dp(n+1,vector<int>(n+1-1));\\n        for(int i=0;i<n;i++){\\n ans+=piles[i];\\n        }\\n        int q=alice(0,n-1,piles,dp);\\n        return q<(ans-q);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982701,
                "title": "2-d-dynamic-programming-solution-with-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- For each possible case, find the \\'advantage score\\' for the player who draw first. Using an intuitive 2-D DP to calculate the advantage score.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- dp[ i ][ j ] indicates the advantage score for piles[ i : j+1 ], where dp[ i ][ j ] = max(piles[ i ] - dp[ i+1 ][ j ], piles[ j ] - dp[ i ][ j-1 ]). \\n- Besides, we need to pay more attention on the order of updating, where we need to update from small-gap cases to huge-gap cases.\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def stoneGame(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # allocate the space, not so efficient\\n        dp = [[0]*(len(piles)) for k in range(len(piles))]\\n\\n        # initial conditions:\\n        for i in range(len(piles)):\\n            dp[i][i] = piles[i]\\n        \\n        # make caution of the sequence of updating, from small-gap to huge-gap (controlled by d)\\n        for d in range(1, len(piles)):\\n            for i in range(len(piles) - d):\\n                dp[i][i+d] = max(piles[i] - dp[i+1][i+d], piles[i+d] - dp[i][i+d-1])\\n\\n        print(dp)      \\n        if dp[0][-1] > 0:\\n            return True\\n        \\n        return False\\n        \\n        \\n        # \\'return True\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def stoneGame(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # allocate the space, not so efficient\\n        dp = [[0]*(len(piles)) for k in range(len(piles))]\\n\\n        # initial conditions:\\n        for i in range(len(piles)):\\n            dp[i][i] = piles[i]\\n        \\n        # make caution of the sequence of updating, from small-gap to huge-gap (controlled by d)\\n        for d in range(1, len(piles)):\\n            for i in range(len(piles) - d):\\n                dp[i][i+d] = max(piles[i] - dp[i+1][i+d], piles[i+d] - dp[i][i+d-1])\\n\\n        print(dp)      \\n        if dp[0][-1] > 0:\\n            return True\\n        \\n        return False\\n        \\n        \\n        # \\'return True\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289506,
                "title": "alice-will-always-win-c-easy-solution-using-recursion-memoization",
                "content": "```\\nclass Solution {\\n    int dp[501][501][2];\\n    bool solve(vector<int>& piles,int i,int j,int f,int alice,int bob,int sum){\\n        if(i>=j)\\n            return alice>bob;\\n        \\n        if(alice>sum)\\n            return true;\\n        if(bob>sum)\\n            return false;\\n        \\n        if(dp[i][j][f]!=-1)\\n            return dp[i][j][f];\\n        \\n        int first=0,second=0;\\n        \\n        if(f==0){\\n            first=solve(piles,i+1,j,1,alice+piles[i],bob,sum) || solve(piles,i,j-1,1,alice+piles[j],bob,sum);\\n        }\\n        \\n        if(f==1){\\n            second=solve(piles,i+1,j,0,alice,bob+piles[i],sum) || solve(piles,i,j-1,0,alice,bob+piles[j],sum);\\n        }\\n        \\n        return dp[i][j][f]=first||second;\\n        // return first||second;\\n        \\n        \\n    }\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size(),alice=0,bob=0;\\n        int sum=accumulate(piles.begin(),piles.end(),0);\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(piles,0,n-1,0,alice,bob,sum/2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp[501][501][2];\\n    bool solve(vector<int>& piles,int i,int j,int f,int alice,int bob,int sum){\\n        if(i>=j)\\n            return alice>bob;\\n        \\n        if(alice>sum)\\n            return true;\\n        if(bob>sum)\\n            return false;\\n        \\n        if(dp[i][j][f]!=-1)\\n            return dp[i][j][f];\\n        \\n        int first=0,second=0;\\n        \\n        if(f==0){\\n            first=solve(piles,i+1,j,1,alice+piles[i],bob,sum) || solve(piles,i,j-1,1,alice+piles[j],bob,sum);\\n        }\\n        \\n        if(f==1){\\n            second=solve(piles,i+1,j,0,alice,bob+piles[i],sum) || solve(piles,i,j-1,0,alice,bob+piles[j],sum);\\n        }\\n        \\n        return dp[i][j][f]=first||second;\\n        // return first||second;\\n        \\n        \\n    }\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size(),alice=0,bob=0;\\n        int sum=accumulate(piles.begin(),piles.end(),0);\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(piles,0,n-1,0,alice,bob,sum/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169232,
                "title": "java-dp-minimax",
                "content": "This is pretty similar to [486. Predict the Winner](https://leetcode.com/problems/predict-the-winner/solution/ ). You can check the first solution of this problem to understand the algorithm.\\n```\\nclass Solution {\\n    int[][] dp;\\n    public boolean stoneGame(int[] piles) {\\n        int n = piles.length;\\n        dp = new int[n][n];\\n        return minimax(piles,0,n-1,1) > 0;\\n    }\\n    private int minimax(int[] nums, int i, int j, int turn) {\\n        if(i==j)\\n            return turn * nums[i];\\n        if(dp[i][j] != 0)\\n            return dp[i][j];\\n\\t\\t\\t\\n        int l = turn * nums[i] + minimax(nums, i+1, j, -turn);\\n        int r = turn * nums[j] + minimax(nums, i, j-1, -turn);\\n        dp[i][j] = turn > 0 ? Math.max(l,r) : Math.min(l,r);\\n\\t\\t\\n        return dp[i][j];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dp;\\n    public boolean stoneGame(int[] piles) {\\n        int n = piles.length;\\n        dp = new int[n][n];\\n        return minimax(piles,0,n-1,1) > 0;\\n    }\\n    private int minimax(int[] nums, int i, int j, int turn) {\\n        if(i==j)\\n            return turn * nums[i];\\n        if(dp[i][j] != 0)\\n            return dp[i][j];\\n\\t\\t\\t\\n        int l = turn * nums[i] + minimax(nums, i+1, j, -turn);\\n        int r = turn * nums[j] + minimax(nums, i, j-1, -turn);\\n        dp[i][j] = turn > 0 ? Math.max(l,r) : Math.min(l,r);\\n\\t\\t\\n        return dp[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885111,
                "title": "simplest-just-one-line",
                "content": "```\\ndef stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```\\n\\t\\t\\nALEX can ALWAYS WIN the game!!",
                "solutionTags": [],
                "code": "```\\ndef stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 787688,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n\\t// reliased the algorithm after first writing the recursion for the solution\\n\\t// in any subset, starting at i, and ending at j, alex has two choices:\\n\\t\\t//1.pick the ith stone and then Lee picks correspondingly in the set (i+1,j]\\n\\t\\t//2.pick the jth stone and then Lee picks correspondingly in the set [i,j-)\\n\\t\\t// we identify the max sum on the basis of picking either the ith or the jth values\\n\\t\\t// The max total of the set [i, j] will be the maximum of the two values above\\n    public boolean stoneGame(int[] piles) {\\n        int m =piles.length;\\n        int findMax[][] = new int[m][m];\\n\\t\\t// setting the base condition, when the subset is [i,i], the max value one player can get is piles[i]\\n        for(int i=0;i<m;i++){\\n            findMax[i][i] = piles[i];\\n        }\\n\\t\\t// as we increase the length of the subset\\n\\t\\t// we can calculate in the bottom up manner the max value for the subset[0,m-1]\\n        for(int l=2;l<=m;l++){\\n            for(int i=0;i+l-1<m;i++){\\n                int j = i+l-1;\\n\\t\\t\\t\\t// max sum possible when Alex picks i, minus when Lee picks in the range which remaining\\n                int a = piles[i] - findMax[i+1][j];\\n\\t\\t\\t\\t// max sum possible when Alex picks j, minus when Lee picks in the range which remaining\\n                int b = piles[j] - findMax[i][j-1];\\n\\t\\t\\t\\t// max sum of the subset [i,j]\\n                findMax[i][j] = Integer.max(a,b);\\n            }\\n        }\\n\\t\\treturn findMax[0][m-1]>0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\t// reliased the algorithm after first writing the recursion for the solution\\n\\t// in any subset, starting at i, and ending at j, alex has two choices:\\n\\t\\t//1.pick the ith stone and then Lee picks correspondingly in the set (i+1,j]\\n\\t\\t//2.pick the jth stone and then Lee picks correspondingly in the set [i,j-)\\n\\t\\t// we identify the max sum on the basis of picking either the ith or the jth values\\n\\t\\t// The max total of the set [i, j] will be the maximum of the two values above\\n    public boolean stoneGame(int[] piles) {\\n        int m =piles.length;\\n        int findMax[][] = new int[m][m];\\n\\t\\t// setting the base condition, when the subset is [i,i], the max value one player can get is piles[i]\\n        for(int i=0;i<m;i++){\\n            findMax[i][i] = piles[i];\\n        }\\n\\t\\t// as we increase the length of the subset\\n\\t\\t// we can calculate in the bottom up manner the max value for the subset[0,m-1]\\n        for(int l=2;l<=m;l++){\\n            for(int i=0;i+l-1<m;i++){\\n                int j = i+l-1;\\n\\t\\t\\t\\t// max sum possible when Alex picks i, minus when Lee picks in the range which remaining\\n                int a = piles[i] - findMax[i+1][j];\\n\\t\\t\\t\\t// max sum possible when Alex picks j, minus when Lee picks in the range which remaining\\n                int b = piles[j] - findMax[i][j-1];\\n\\t\\t\\t\\t// max sum of the subset [i,j]\\n                findMax[i][j] = Integer.max(a,b);\\n            }\\n        }\\n\\t\\treturn findMax[0][m-1]>0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632233,
                "title": "interview-2d-dp-brute-force-recursion-optimised-using-bottom-up-dp-explained-in-detail",
                "content": "\\n#  When num of piles are given even then there is atleast one case in which if alex plays optimally, she is able to partition the array with more stones\\n#  But if num of piles are odd, then no such mathamatical then there is no mathamatical solution exists in that case and we need to stick to our basics in following apprioches like\\n#  1) Brute Force Recursion\\n#  2) Brute Force Recursion + Memoization\\n#  3) Bottom up iterative DP (Difficult to reach in first go so be patient while solving this problem !)\\n#  \\n\\nApproach -1 \\n```\\n// Time Complexity - Exponential    // Space Complexity - O(N)\\npublic class Medium_Stone_Game {\\n    // This solution will give time limit exceeded in leetcode and we can see that only 26/46 test cases were able to pass in the permitted time\\n    // We can optimize out brute force solution using memoization of states since this recursion clearly has Optimal substructure + Overlapping sub-problem\\n    private boolean Recursion(int[] arr,int start,int end,int alex_score,int lee_score,boolean alex_turn){\\n\\n            if( (start+1)==end){    // Since both are playing optimally, they will try to maximise only there own reward only\\n                if(alex_turn){\\n                    alex_score+=Math.max(arr[start],arr[end]);\\n                    lee_score+=Math.min(arr[start],arr[end]);\\n                }else{\\n                    alex_score+=Math.min(arr[start],arr[end]);\\n                    lee_score+=Math.max(arr[start],arr[end]);\\n                }\\n                if(alex_score>lee_score)return true;\\n                return false;\\n            }\\n            int alex_score_copy=alex_score;\\n            int lee_score_copy=lee_score;\\n            // I am choosing left most element in this recursive call for alex or lee\\n            if(alex_turn){\\n                alex_score+=arr[start];\\n            }else{\\n                lee_score+=arr[start];\\n            }\\n\\n            boolean left_recur=Recursion(arr,start+1,end,alex_score,lee_score,!alex_turn);\\n\\n            // I am choosing right most element in this recursive call for alex or lee\\n            if(alex_turn){\\n                alex_score_copy+=arr[end];\\n            }else{\\n                lee_score_copy+=arr[end];\\n            }\\n\\n            boolean right_recur=Recursion(arr,start,end-1,alex_score_copy,lee_score_copy,!alex_turn);\\n\\n            return left_recur||right_recur;\\n    }\\n```\\n\\nApproach - 2 \\n***I leave applying memoization to reader (I was finding it really difficult to use memo instead excessive brainstoring on this lead me to its far easier bottom up solution) :)***\\n\\nApproach - 3\\n\\n// Bottom up DP solution is quite easier and intituive If you would give a deeper thought to the problem\\n    // Actually I was trying to apply memoization to above solution but instead derived new bottom up solution\\n    // The Main recurences happening are-:\\n    \\n       Alex[i][j]= Max(arr[i] + Lee[i+1][j] , arr[j] + Lee[i][j-1]\\n       Lee[i][j] = Min(Alex[i+1][j],Alex[i][j-1])\\n    \\n       Base Conditions-: Alex[i][i]=arr[i]         // Since Alex gets first turn with the only pile to pick\\n                         Lee[i][i]=0;              // Leo won\\'t get any chance to pick any pile if there is only 1 pile\\n    \\n```\\n // Time Complexity- O(N^2) Space Complexity- O(N^2)\\n    public boolean stoneGame_BottomUpDp(int[] arr){\\n            if(arr==null || arr.length==0)return false;\\n            // Minimum 1 pile garunteed\\n            if(arr.length==1)return true;\\n\\n            int[][] Alex_Score=new int[arr.length][arr.length];\\n            int[][] Lee_Score=new int[arr.length][arr.length];\\n            // considering all piles individually as base case  (For Lee it would always be 0 so no need to do anything)\\n\\n            for(int i=0;i<arr.length;i++)\\n                Alex_Score[i][i]=arr[i];\\n\\n            // Now Procesing diagnol wise (First picking piles in pairs then triplets then so on and so forth)\\n\\n            int i=0,j=1;\\n\\n            while( ((i<arr.length) && (j<arr.length)) ){\\n                int row=i,col=j;\\n\\n                for(;((row<arr.length) && (col<arr.length));row++,col++){\\n                    Alex_Score[row][col]=Math.max(arr[row] + Lee_Score[row+1][col],arr[col] + Lee_Score[row][col-1]);\\n                    Lee_Score[row][col]=Math.min(Alex_Score[row+1][col],Alex_Score[row][col-1]);\\n                }\\n                j++;\\n            }\\n\\n\\n            return ((Alex_Score[0][arr.length-1] - Lee_Score[0][arr.length-1])  >  0);\\n    }\\n```\\n\\nPlease upvote if this helped you in better understanding  :)\\nHave a nice day !",
                "solutionTags": [],
                "code": "```\\n// Time Complexity - Exponential    // Space Complexity - O(N)\\npublic class Medium_Stone_Game {\\n    // This solution will give time limit exceeded in leetcode and we can see that only 26/46 test cases were able to pass in the permitted time\\n    // We can optimize out brute force solution using memoization of states since this recursion clearly has Optimal substructure + Overlapping sub-problem\\n    private boolean Recursion(int[] arr,int start,int end,int alex_score,int lee_score,boolean alex_turn){\\n\\n            if( (start+1)==end){    // Since both are playing optimally, they will try to maximise only there own reward only\\n                if(alex_turn){\\n                    alex_score+=Math.max(arr[start],arr[end]);\\n                    lee_score+=Math.min(arr[start],arr[end]);\\n                }else{\\n                    alex_score+=Math.min(arr[start],arr[end]);\\n                    lee_score+=Math.max(arr[start],arr[end]);\\n                }\\n                if(alex_score>lee_score)return true;\\n                return false;\\n            }\\n            int alex_score_copy=alex_score;\\n            int lee_score_copy=lee_score;\\n            // I am choosing left most element in this recursive call for alex or lee\\n            if(alex_turn){\\n                alex_score+=arr[start];\\n            }else{\\n                lee_score+=arr[start];\\n            }\\n\\n            boolean left_recur=Recursion(arr,start+1,end,alex_score,lee_score,!alex_turn);\\n\\n            // I am choosing right most element in this recursive call for alex or lee\\n            if(alex_turn){\\n                alex_score_copy+=arr[end];\\n            }else{\\n                lee_score_copy+=arr[end];\\n            }\\n\\n            boolean right_recur=Recursion(arr,start,end-1,alex_score_copy,lee_score_copy,!alex_turn);\\n\\n            return left_recur||right_recur;\\n    }\\n```\n```\\n // Time Complexity- O(N^2) Space Complexity- O(N^2)\\n    public boolean stoneGame_BottomUpDp(int[] arr){\\n            if(arr==null || arr.length==0)return false;\\n            // Minimum 1 pile garunteed\\n            if(arr.length==1)return true;\\n\\n            int[][] Alex_Score=new int[arr.length][arr.length];\\n            int[][] Lee_Score=new int[arr.length][arr.length];\\n            // considering all piles individually as base case  (For Lee it would always be 0 so no need to do anything)\\n\\n            for(int i=0;i<arr.length;i++)\\n                Alex_Score[i][i]=arr[i];\\n\\n            // Now Procesing diagnol wise (First picking piles in pairs then triplets then so on and so forth)\\n\\n            int i=0,j=1;\\n\\n            while( ((i<arr.length) && (j<arr.length)) ){\\n                int row=i,col=j;\\n\\n                for(;((row<arr.length) && (col<arr.length));row++,col++){\\n                    Alex_Score[row][col]=Math.max(arr[row] + Lee_Score[row+1][col],arr[col] + Lee_Score[row][col-1]);\\n                    Lee_Score[row][col]=Math.min(Alex_Score[row+1][col],Alex_Score[row][col-1]);\\n                }\\n                j++;\\n            }\\n\\n\\n            return ((Alex_Score[0][arr.length-1] - Lee_Score[0][arr.length-1])  >  0);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566617,
                "title": "dp-solution-clearly-simple-solution-with-comment",
                "content": "```java\\n\\tpublic boolean stoneGame(int[] piles) {\\n\\t\\tint n = piles.length;\\n\\n\\t\\t// dp(i,j) represents the relative score that i can achieve\\n\\t\\t// if i got to play the first hand, where the piles remaining are [i, j]\\n\\t\\tint[][] dp = new int[n][n];\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tdp[i][i] = piles[i]; // diagonal elements, interval length = 0\\n\\t\\t}\\n\\n\\t\\t// length of interval from [1, n-1]\\n\\t\\tfor (int interval = 1; interval < n; interval++) {\\n\\n\\t\\t\\tfor (int l = 0; l < n - interval; l++) { // start of interval\\n\\n\\t\\t\\t\\tint r = l + interval; // end of interval\\n\\n\\t\\t\\t\\t// the gain of picking left stone,\\n\\t\\t\\t\\t// minus the gain of my opponent playing first hand at interval [l+1, r]\\n\\t\\t\\t\\tint pickLeft = piles[l] - dp[l + 1][r];\\n\\n\\t\\t\\t\\t// the gain of picking right stone,\\n\\t\\t\\t\\t// minus the gain of my opponent picking first hand at interval [l, r-1]\\n\\t\\t\\t\\tint pickRight = piles[r] - dp[l][r - 1];\\n\\n\\t\\t\\t\\tdp[l][r] = dp[l][r] = Math.max(pickLeft, pickRight);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[0][n - 1] > 0;\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\n\\tpublic boolean stoneGame(int[] piles) {\\n\\t\\tint n = piles.length;\\n\\n\\t\\t// dp(i,j) represents the relative score that i can achieve\\n\\t\\t// if i got to play the first hand, where the piles remaining are [i, j]\\n\\t\\tint[][] dp = new int[n][n];\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tdp[i][i] = piles[i]; // diagonal elements, interval length = 0\\n\\t\\t}\\n\\n\\t\\t// length of interval from [1, n-1]\\n\\t\\tfor (int interval = 1; interval < n; interval++) {\\n\\n\\t\\t\\tfor (int l = 0; l < n - interval; l++) { // start of interval\\n\\n\\t\\t\\t\\tint r = l + interval; // end of interval\\n\\n\\t\\t\\t\\t// the gain of picking left stone,\\n\\t\\t\\t\\t// minus the gain of my opponent playing first hand at interval [l+1, r]\\n\\t\\t\\t\\tint pickLeft = piles[l] - dp[l + 1][r];\\n\\n\\t\\t\\t\\t// the gain of picking right stone,\\n\\t\\t\\t\\t// minus the gain of my opponent picking first hand at interval [l, r-1]\\n\\t\\t\\t\\tint pickRight = piles[r] - dp[l][r - 1];\\n\\n\\t\\t\\t\\tdp[l][r] = dp[l][r] = Math.max(pickLeft, pickRight);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[0][n - 1] > 0;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 549945,
                "title": "alex-can-always-win",
                "content": "# Alex can always win\\nIn this particular problem, with all the given constraints specially `total number of stones is odd`,  suggest that alex can always win.\\n\\n## How?\\nNotice the fact that, total number of piles are even and alex always start the game, thus he has the choice that he can either choose all even numbered piles or odd numbered piles. So, if sum off odd numbered piles is greater than sum of even numbered piles he will choose them and win.\\n\\n```\\ndef stoneGame(piles):\\n\\treturn True\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef stoneGame(piles):\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 384891,
                "title": "explain-play-optimally-a-straightforward-solution-with-detailed-steps",
                "content": "What does \"play optimally\" mean? \\n\\nIf you are not a master on one topic, you most likely won\\'t know, such an algorithm will be impossible to implement in a short period of time, stop trying.\\n\\nHowever if you are familiar with cheating in a game or anything similar(just kidding), there is a consistent way to play optimally, it is playing with the answer directly, like you are coming from \"the future\".  In programming, recursive methods will give you this ability.\\n\\nFor the stone game, lets use stones(left,right) to indicate number of stones Alice can get given a pile array, left is pointed to the first element, and right is the pointed to the last.\\nAlex is trying to get the most stones, he can chose either the left one or the right one.\\n```\\nstones(left,right) = Math.max(piles[left] + LeesMove1 , piles[right] + LeesMove2)\\n```\\nThen its Lee\\'s turn, what he want is the most stones as well, in another word, he wants Alex to have less. He is playing based on direct answers (will have eventually) here -- choose from two moves he can make that gives Alex less-- which is as optimal as he can get. \\n\\nAs we are tracking Lee\\'s stones(only), this moves will give us a (Alex\\'s)stone state like below\\n```\\n// Alex take piles[left] previously \\nLeesMove1 = Math.min(AlexsNextMove1 , AlexsNextMove2)\\n// Alex takes piles[right] previously\\nLeesMove2 = Math.min(AlexsNextMove3 , AlexsNextMove4)\\n```\\nWhat are Alex\\'s next move 1 2 3 4? They are fixed based on the two previous moves,\\nFor example If Alex take piles[left], Lee takes piles[right], the array becomes [left+1,...,right-1],  the move will be \\n```\\nMath.max(piles[left+1] + Lee\\'s move1 , piles[right-1] + Lee\\'s move2)\\n```\\n\\nCombine one round together we will have the below function findMax(which returns max as an int)\\n\\n```\\nmax = Math.max(piles[left] + Math.min(findMax(left + 2, right, piles), findMax(left + 1, right - 1, piles)),\\n                piles[right] + Math.min(findMax(left + 1, right - 1, piles), findMax(left, right - 2, piles)));\\n \\n```\\n\\nUsing this function we can calculate the max stones Alex will have from any given array. Comparing with the sum of all piles, we can tell if Alex wins this time.\\n\\nBelow is my java code, added memo to improve performance.\\n\\n```\\npublic boolean stoneGame(int[] piles) {\\n\\n        int sum = 0;\\n        for (int i : piles) {\\n            sum += i;\\n        }\\n        int[][] mem = new int[piles.length][piles.length];\\n        return 2 * findMax(0, piles.length - 1, piles, mem) >= sum;\\n    }\\n\\n    private int findMax(int left, int right, int[] piles, int[][] mem) {\\n        if (left < 0 || right < 0 || left > right)\\n            return 0;\\n        if (mem[left][right] != 0)\\n            return mem[left][right];\\n        if (left == right) {\\n            mem[left][right] = piles[left];\\n            return piles[left];\\n        }\\n\\n        int max = Math.max(piles[left] + Math.min(findMax(left + 2, right, piles, mem), findMax(left + 1, right - 1, piles, mem)),\\n                piles[right] + Math.min(findMax(left + 1, right - 1, piles, mem), findMax(left, right - 2, piles, mem)));\\n        mem[left][right] = max;\\n        return max;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nstones(left,right) = Math.max(piles[left] + LeesMove1 , piles[right] + LeesMove2)\\n```\n```\\n// Alex take piles[left] previously \\nLeesMove1 = Math.min(AlexsNextMove1 , AlexsNextMove2)\\n// Alex takes piles[right] previously\\nLeesMove2 = Math.min(AlexsNextMove3 , AlexsNextMove4)\\n```\n```\\nMath.max(piles[left+1] + Lee\\'s move1 , piles[right-1] + Lee\\'s move2)\\n```\n```\\nmax = Math.max(piles[left] + Math.min(findMax(left + 2, right, piles), findMax(left + 1, right - 1, piles)),\\n                piles[right] + Math.min(findMax(left + 1, right - 1, piles), findMax(left, right - 2, piles)));\\n \\n```\n```\\npublic boolean stoneGame(int[] piles) {\\n\\n        int sum = 0;\\n        for (int i : piles) {\\n            sum += i;\\n        }\\n        int[][] mem = new int[piles.length][piles.length];\\n        return 2 * findMax(0, piles.length - 1, piles, mem) >= sum;\\n    }\\n\\n    private int findMax(int left, int right, int[] piles, int[][] mem) {\\n        if (left < 0 || right < 0 || left > right)\\n            return 0;\\n        if (mem[left][right] != 0)\\n            return mem[left][right];\\n        if (left == right) {\\n            mem[left][right] = piles[left];\\n            return piles[left];\\n        }\\n\\n        int max = Math.max(piles[left] + Math.min(findMax(left + 2, right, piles, mem), findMax(left + 1, right - 1, piles, mem)),\\n                piles[right] + Math.min(findMax(left + 1, right - 1, piles, mem), findMax(left, right - 2, piles, mem)));\\n        mem[left][right] = max;\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 277753,
                "title": "java-dp-solution-calculates-number-of-stones-instead-of-difference",
                "content": "The easy solution is to just return true as discussed in most of the other solutions. The problem becomes hard when you are asked to get the number of stones alex gathers at the end of the game.\\n\\nApproach 1: You can solve the problem saving the difference of number of stones at each point. \\nLet say we have an array of piles with i,j denoting the first and last position in the array.\\nIf Alex choose the first pile, then your answer is piles[i] - dp[i+1][j]\\nIf Alex choose jth pile, then your answer is  piles[j] - dp[i][j-1]\\nYou can find the code here https://leetcode.com/problems/stone-game/discuss/154610/DP-or-Just-return-true\\n\\nApproach 2: You can solve the problem by saving the number of stones at each point.\\nLet say we have an array of piles with i,j denoting the first and last position in the array.\\nIf Alex chooses the first pile then the optimal number of stones he can collect would be the number of stones in the first pile + minimum number of stones he can collect from the remaining piles .i.e as Lee is playing optimally \\n\\nHow can Alex calculate that how many number of stones can he collect if he chooses the first pile considering that Lee is playing optimally?\\nIf Alex choose the first pile, then Lee has two options\\n1. Lee chooses the first pile , then answer is \\n    dp[i+2][j] (Alex would get chance to choose from [i+2,j] as i+1 pile is taken by Lee.\\n2. Lee chooses the last pile, then answer is \\n    dp[i+1][j-1] (Alex would get chance to choose from [i+1,j-1] as j pile is taken by Lee.\\nAs we know that Lee is playing optimally he would choose from the above two options such that Alex gets minimum number of stones, hence the answer would be  piles[i]+ min(dp[i+2][j] , dp[i+1][j-1] )\\n\\nHow can Alex calculate that how many number of stones can he collect if he chooses the last pile considering that Lee is playing optimally?\\n1. Lee chooses the first pile , then answer is \\n    dp[i+1][j-1] (Alex would get chance to choose from [i+1,j-1] as i pile is taken by Lee.\\n2. Lee chooses the last pile, then answer is \\n    dp[i][j-2] (Alex would get chance to choose from [i,j-2] as j-1 pile is taken by Lee.\\nAs we know that Lee is playing optimally he would choose from the above two options such that Alex gets minimum number of stones, hence the answer would be  piles[j]+ min(dp[i+1][j-1] , dp[i][j-2] )\\n\\nNow, Alex knows how to calculate optimal number of stones if he choose the first pile or the last pile. The answer will be the maximum of the two choices. \\n\\ndp[i][j] = max( piles[i]+ min(dp[i+2][j] , dp[i+1][j-1] ) , piles[j]+ min(dp[i+1][j-1] , dp[i][j-2] ))\\n\\nHere goes the code!\\n\\n    public boolean stoneGame(int[] piles) {\\n        int n = piles.length;\\n        boolean first = false; // to get the idea to what Alex chose .i.e the first pile or the last pile to get the optimal solution\\n        \\n        if(n == 2)\\n            return true;\\n        \\n        int [][]dp = new int[n][n];\\n        \\n\\t\\t//initialize values when there is only one pile\\n        for(int i=0;i<=n-1;i++){\\n            dp[i][i] = piles[i];\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<=n-1;j++){\\n                if(i < j){\\n                    int firstCutMax = Math.min((i+2 >= n ? 0 : dp[i+2][j]), i+1 >= n ? 0 : dp[i+1][j-1]);\\n                    int lastCutMax = Math.min(j-1 < i+1 ? 0 : dp[i+1][j-1], j-2 < 0 ? 0 : dp[i][j-2]);\\n                    \\n                    dp[i][j] = Math.max(piles[i] + firstCutMax, piles[j] + lastCutMax);\\n                    \\n                    if(i == 0 && j == n-1){\\n                        if(piles[i] + firstCutMax > piles[j] + lastCutMax)\\n                            first = true;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n               \\n        \\n        if(first){\\n            return dp[0][n-1] > dp[1][n-1];\\n        }\\n        else{\\n            return dp[0][n-1] > dp[0][n-2];\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "The easy solution is to just return true as discussed in most of the other solutions. The problem becomes hard when you are asked to get the number of stones alex gathers at the end of the game.\\n\\nApproach 1: You can solve the problem saving the difference of number of stones at each point. \\nLet say we have an array of piles with i,j denoting the first and last position in the array.\\nIf Alex choose the first pile, then your answer is piles[i] - dp[i+1][j]\\nIf Alex choose jth pile, then your answer is  piles[j] - dp[i][j-1]\\nYou can find the code here https://leetcode.com/problems/stone-game/discuss/154610/DP-or-Just-return-true\\n\\nApproach 2: You can solve the problem by saving the number of stones at each point.\\nLet say we have an array of piles with i,j denoting the first and last position in the array.\\nIf Alex chooses the first pile then the optimal number of stones he can collect would be the number of stones in the first pile + minimum number of stones he can collect from the remaining piles .i.e as Lee is playing optimally \\n\\nHow can Alex calculate that how many number of stones can he collect if he chooses the first pile considering that Lee is playing optimally?\\nIf Alex choose the first pile, then Lee has two options\\n1. Lee chooses the first pile , then answer is \\n    dp[i+2][j] (Alex would get chance to choose from [i+2,j] as i+1 pile is taken by Lee.\\n2. Lee chooses the last pile, then answer is \\n    dp[i+1][j-1] (Alex would get chance to choose from [i+1,j-1] as j pile is taken by Lee.\\nAs we know that Lee is playing optimally he would choose from the above two options such that Alex gets minimum number of stones, hence the answer would be  piles[i]+ min(dp[i+2][j] , dp[i+1][j-1] )\\n\\nHow can Alex calculate that how many number of stones can he collect if he chooses the last pile considering that Lee is playing optimally?\\n1. Lee chooses the first pile , then answer is \\n    dp[i+1][j-1] (Alex would get chance to choose from [i+1,j-1] as i pile is taken by Lee.\\n2. Lee chooses the last pile, then answer is \\n    dp[i][j-2] (Alex would get chance to choose from [i,j-2] as j-1 pile is taken by Lee.\\nAs we know that Lee is playing optimally he would choose from the above two options such that Alex gets minimum number of stones, hence the answer would be  piles[j]+ min(dp[i+1][j-1] , dp[i][j-2] )\\n\\nNow, Alex knows how to calculate optimal number of stones if he choose the first pile or the last pile. The answer will be the maximum of the two choices. \\n\\ndp[i][j] = max( piles[i]+ min(dp[i+2][j] , dp[i+1][j-1] ) , piles[j]+ min(dp[i+1][j-1] , dp[i][j-2] ))\\n\\nHere goes the code!\\n\\n    public boolean stoneGame(int[] piles) {\\n        int n = piles.length;\\n        boolean first = false; // to get the idea to what Alex chose .i.e the first pile or the last pile to get the optimal solution\\n        \\n        if(n == 2)\\n            return true;\\n        \\n        int [][]dp = new int[n][n];\\n        \\n\\t\\t//initialize values when there is only one pile\\n        for(int i=0;i<=n-1;i++){\\n            dp[i][i] = piles[i];\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<=n-1;j++){\\n                if(i < j){\\n                    int firstCutMax = Math.min((i+2 >= n ? 0 : dp[i+2][j]), i+1 >= n ? 0 : dp[i+1][j-1]);\\n                    int lastCutMax = Math.min(j-1 < i+1 ? 0 : dp[i+1][j-1], j-2 < 0 ? 0 : dp[i][j-2]);\\n                    \\n                    dp[i][j] = Math.max(piles[i] + firstCutMax, piles[j] + lastCutMax);\\n                    \\n                    if(i == 0 && j == n-1){\\n                        if(piles[i] + firstCutMax > piles[j] + lastCutMax)\\n                            first = true;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n               \\n        \\n        if(first){\\n            return dp[0][n-1] > dp[1][n-1];\\n        }\\n        else{\\n            return dp[0][n-1] > dp[0][n-2];\\n        }\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 169012,
                "title": "easiest-top-down-dp-approach-with-memoization-python",
                "content": "```\\nclass Solution:\\n    def stoneGame(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # If solution to piles[:n-1] and  piles[1:n] and piles[2:]\\n        # was known then how do we get the complete solution?\\n        # Possibilities:\\n        #   1.1 Alex picks from start and Lee from the start of the remaining piles. Then problem reduces to piles[2:]\\n        #   2.1: Alex picks from start and Lee from the end of the remaining piles.\\n        #   2.2: Alex picks from end and Lee picks from start.\\n        #       => Then problem reduces to piles[1:n]\\n        #   3. Alex picks from end and Lee picks from the end of the remaining piles. Then problem reduces to piles[:n-1]\\n        memo = {}\\n        def helper(alex, lee, start, end):\\n            if start > end:\\n                return alex > lee\\n            if (start, end) in memo:\\n                return memo[(start, end)]\\n            ret = (helper(alex + piles[start], lee + piles[end], start + 1, end - 1) or\\n                   helper(alex + piles[start], lee + piles[start + 1], start + 2, end) or\\n                   helper(alex + piles[end], lee + piles[start], start + 1, end - 1) or\\n                   helper(alex + piles[end], lee + piles[end - 1], start, end - 2))\\n            memo[(start, end)] = ret\\n            return ret\\n        return helper(0, 0, 0, len(piles) - 1)\\n\\t\\t\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # If solution to piles[:n-1] and  piles[1:n] and piles[2:]\\n        # was known then how do we get the complete solution?\\n        # Possibilities:\\n        #   1.1 Alex picks from start and Lee from the start of the remaining piles. Then problem reduces to piles[2:]\\n        #   2.1: Alex picks from start and Lee from the end of the remaining piles.\\n        #   2.2: Alex picks from end and Lee picks from start.\\n        #       => Then problem reduces to piles[1:n]\\n        #   3. Alex picks from end and Lee picks from the end of the remaining piles. Then problem reduces to piles[:n-1]\\n        memo = {}\\n        def helper(alex, lee, start, end):\\n            if start > end:\\n                return alex > lee\\n            if (start, end) in memo:\\n                return memo[(start, end)]\\n            ret = (helper(alex + piles[start], lee + piles[end], start + 1, end - 1) or\\n                   helper(alex + piles[start], lee + piles[start + 1], start + 2, end) or\\n                   helper(alex + piles[end], lee + piles[start], start + 1, end - 1) or\\n                   helper(alex + piles[end], lee + piles[end - 1], start, end - 2))\\n            memo[(start, end)] = ret\\n            return ret\\n        return helper(0, 0, 0, len(piles) - 1)\\n\\t\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 154624,
                "title": "recursion-with-dp",
                "content": "The idea here is to use recursion + DP to cache the already computed results. \\n\\nAlex can win by choosing the first element or the last element so we try both (indexed by i and j) and if either of them succeeds, we declare him the winner\\n\\n```python\\nclass Solution:\\n    def stoneGame(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        def helper(i,j, me, other):\\n            if i > j:\\n                return me < other\\n            else:\\n                key = (i,j,me,other)\\n                if key in table:\\n                    return table[key]\\n                ans =  helper(i+1,j, other, me + piles[i]) or helper(i,j-1, other, me + piles[j])\\n                table[key] = ans\\n                return ans\\n        table = {}\\n        return helper(0, len(piles)-1, 0, 0)\\n```\\n\\nI submitted this in the contest when i had only 5 seconds left and was pleasantly surprised that it got accepted. ",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def stoneGame(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        def helper(i,j, me, other):\\n            if i > j:\\n                return me < other\\n            else:\\n                key = (i,j,me,other)\\n                if key in table:\\n                    return table[key]\\n                ans =  helper(i+1,j, other, me + piles[i]) or helper(i,j-1, other, me + piles[j])\\n                table[key] = ans\\n                return ans\\n        table = {}\\n        return helper(0, len(piles)-1, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 154614,
                "title": "my-one-line-python-slution",
                "content": "```\\nclass Solution(object):\\n    def stoneGame(self, piles):\\n        return True\\n\\t\\t\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def stoneGame(self, piles):\\n        return True\\n\\t\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3563643,
                "title": "c-easy-to-understand-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& piles, int i, int j, int sum, vector<vector<int>>& dp) {\\n        if(i>j)\\n            return 0;\\n        if(i==j)\\n            return piles[i];\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        return dp[i][j] = max(sum - solve(piles, i+1, j, sum-piles[i], dp), sum - solve(piles, i, j-1, sum-piles[j], dp));\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        int sum = accumulate(piles.begin(), piles.end(), 0);\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        int alexStones = solve(piles, 0, n-1, sum, dp);\\n        return alexStones > sum-alexStones;\\n    }\\n};\\n```\\n\\nUpvote if you like it!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& piles, int i, int j, int sum, vector<vector<int>>& dp) {\\n        if(i>j)\\n            return 0;\\n        if(i==j)\\n            return piles[i];\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        return dp[i][j] = max(sum - solve(piles, i+1, j, sum-piles[i], dp), sum - solve(piles, i, j-1, sum-piles[j], dp));\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        int sum = accumulate(piles.begin(), piles.end(), 0);\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        int alexStones = solve(piles, 0, n-1, sum, dp);\\n        return alexStones > sum-alexStones;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765540,
                "title": "one-word-solution-return-true",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586858,
                "title": "simple-two-pointer-approach-c-o-1-space",
                "content": "****upvote if you find helpfull and easy****\\t\\n\\t\\n\\t\\n\\tbool stoneGame(vector<int>& piles) {\\n        int a ,b,i,j;\\n        a=b=i=0;\\n        j=piles.size()-1;\\n        while(i<j){\\n            if(piles[i]>piles[j]){\\n                a+=piles[i++];\\n                b+=piles[j--];\\n            }\\n            else{\\n                a+=piles[j--];\\n                b+=piles[i++];\\n            }\\n        }\\n        if(a>b) return true;\\n        return false;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "****upvote if you find helpfull and easy****\\t\\n\\t\\n\\t\\n\\tbool stoneGame(vector<int>& piles) {\\n        int a ,b,i,j;\\n        a=b=i=0;\\n        j=piles.size()-1;\\n        while(i<j){\\n            if(piles[i]>piles[j]){\\n                a+=piles[i++];\\n                b+=piles[j--];\\n            }\\n            else{\\n                a+=piles[j--];\\n                b+=piles[i++];\\n            }\\n        }\\n        if(a>b) return true;\\n        return false;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2579538,
                "title": "c-game-theory-concept-of-min-max-o-n-2",
                "content": "* **GAME THEORY:**\\n* **pA - Player A & pB - Player B.**\\n* Played from player A perspective: To win the game pA need to maximize his score or minimize pB score.\\n* Similarly from player B perspective: To win the game pB need to maximize his score or minimize pA score.\\n* PLAYER A POINT OF VIEW -\\n* When its pA\\'s turn - Choose the option that **maximizes pA\\'s score**.\\n* When its pB\\'s turn - Choose the option that **minimizes pA\\'s score**.\\n* As the function keeps track of & returns pA\\'s score only.\\n* When it\\'s pA\\'s turn add the score & for pB\\'s turn do not add to the score (pA\\'s score) but make the choice.\\n* The function returns the optimal score of pA. Add all the values in the array to get the TOTAL score.\\n* Calculate pB score by : **pB Score = TOTAL - pA Score**.\\n* Return (pA>=pB).\\n* You can remove the variables pathA & pathB which represents the two choice a player can take to reduce space complexity.\\n* **Time Complexity = O(N^2)**\\n* Upvote!\\n```\\nclass Solution {\\npublic:\\n    //PARAMETERS:\\n    //i & j : Ends of the array.\\n    //turn : 1 If turn of player A. 0 If turn of player B.\\n    int find(int i, int j, bool turn, vector<int> &array, vector<vector<vector<int>>> &dp){\\n        if(i>j) return 0;\\n\\n        if(dp[i][j][turn]!=-1) return dp[i][j][turn]; \\n\\n        //PLAYER A: Maximize the score of player A.\\n        if(turn){\\n            int pathA = array[i] + find(i+1, j, 0, array, dp);\\n            int pathB = array[j] + find(i, j-1, 0, array, dp);\\n            return dp[i][j][turn] = max(pathA, pathB);\\n        }\\n\\n        //PLAYER B: Minimize the score of player A.\\n        else{\\n            int pathA = find(i+1, j, 1, array, dp);\\n            int pathB = find(i, j-1, 1, array, dp);\\n            return dp[i][j][turn] = min(pathA, pathB);\\n        }\\n        \\n    }\\n    \\n    bool PredictTheWinner(vector<int>& array) {\\n        int i=0; int j=array.size()-1;\\n        int n = array.size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(2, -1)));\\n        int pA = find(i, j, 1, array, dp);\\n\\n        int total=0; for(const int &i: array) total+=i;\\n        int pB = total - pA;\\n\\n        return (pA>=pB);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //PARAMETERS:\\n    //i & j : Ends of the array.\\n    //turn : 1 If turn of player A. 0 If turn of player B.\\n    int find(int i, int j, bool turn, vector<int> &array, vector<vector<vector<int>>> &dp){\\n        if(i>j) return 0;\\n\\n        if(dp[i][j][turn]!=-1) return dp[i][j][turn]; \\n\\n        //PLAYER A: Maximize the score of player A.\\n        if(turn){\\n            int pathA = array[i] + find(i+1, j, 0, array, dp);\\n            int pathB = array[j] + find(i, j-1, 0, array, dp);\\n            return dp[i][j][turn] = max(pathA, pathB);\\n        }\\n\\n        //PLAYER B: Minimize the score of player A.\\n        else{\\n            int pathA = find(i+1, j, 1, array, dp);\\n            int pathB = find(i, j-1, 1, array, dp);\\n            return dp[i][j][turn] = min(pathA, pathB);\\n        }\\n        \\n    }\\n    \\n    bool PredictTheWinner(vector<int>& array) {\\n        int i=0; int j=array.size()-1;\\n        int n = array.size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(2, -1)));\\n        int pA = find(i, j, 1, array, dp);\\n\\n        int total=0; for(const int &i: array) total+=i;\\n        int pB = total - pA;\\n\\n        return (pA>=pB);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477951,
                "title": "100-faster-solution-c-just-one-line-code",
                "content": "\\'\\'\\'class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1914270,
                "title": "c-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[500+1][500+1][2];\\n    int knapsack(vector<int>&arr,int i,int j,\\n                 int chance)\\n    {\\n        if(i>j)\\n            return 0;\\n        if(dp[i][j][chance]!=-1)\\n            return dp[i][j][chance];\\n        if(chance==1)\\n        {\\n            return dp[i][j][chance]= max(arr[i]+knapsack(arr,i+1,j,0),\\n                     arr[j]+knapsack(arr,i,j-1,0));\\n        }\\n        if(chance==0)\\n        {\\n            return dp[i][j][chance]= min(knapsack(arr,i+1,j,1),\\n                     knapsack(arr,i,j-1,1));\\n        }\\n        return 0;\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof dp);\\n        int sum=0;\\n        for(auto i : piles)\\n        {\\n            sum+=i;\\n        }\\n        if(sum-2*knapsack(piles,0,piles.size()-1,1)<0)\\n            return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[500+1][500+1][2];\\n    int knapsack(vector<int>&arr,int i,int j,\\n                 int chance)\\n    {\\n        if(i>j)\\n            return 0;\\n        if(dp[i][j][chance]!=-1)\\n            return dp[i][j][chance];\\n        if(chance==1)\\n        {\\n            return dp[i][j][chance]= max(arr[i]+knapsack(arr,i+1,j,0),\\n                     arr[j]+knapsack(arr,i,j-1,0));\\n        }\\n        if(chance==0)\\n        {\\n            return dp[i][j][chance]= min(knapsack(arr,i+1,j,1),\\n                     knapsack(arr,i,j-1,1));\\n        }\\n        return 0;\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof dp);\\n        int sum=0;\\n        for(auto i : piles)\\n        {\\n            sum+=i;\\n        }\\n        if(sum-2*knapsack(piles,0,piles.size()-1,1)<0)\\n            return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830632,
                "title": "simple-recursion",
                "content": "As the Constraints given are too low so normal recursion will also run and no TLE will be there \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool possible(vector<int>&piles,int start,int end,int sm,int total){\\n        \\n        if(start>=end){\\n            if(sm<total-sm) return false;\\n            return true;\\n        }\\n        \\n        return possible(piles,start+1,end,sm+piles[start],total)||\\n            possible(piles,start,end-1,sm+piles[end],total);\\n        \\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n                \\n        int sm=0,total=0;\\n        \\n        for(auto x:piles) total+=x;\\n        \\n        return possible(piles,0,piles.size()-1,0,total);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool possible(vector<int>&piles,int start,int end,int sm,int total){\\n        \\n        if(start>=end){\\n            if(sm<total-sm) return false;\\n            return true;\\n        }\\n        \\n        return possible(piles,start+1,end,sm+piles[start],total)||\\n            possible(piles,start,end-1,sm+piles[end],total);\\n        \\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n                \\n        int sm=0,total=0;\\n        \\n        for(auto x:piles) total+=x;\\n        \\n        return possible(piles,0,piles.size()-1,0,total);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726064,
                "title": "dp-approach-recursion-memorization-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int solve(int i,int j,vector<int> &piles){\\n        if(i > j) return 0;\\n        else if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int option1 = piles[i] + min(solve(i+2,j,piles) , solve(i+1,j-1,piles));\\n        \\n        int option2 = piles[j] + min(solve(i+1,j-1,piles) , solve(i,j-2,piles));\\n        \\n        int alice = max(option1,option2);\\n        \\n        return dp[i][j] = alice;\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        int i = 0, j = n-1;\\n        \\n        memset(dp,-1,sizeof dp);\\n        \\n        int alice = solve(i,j,piles);\\n        int bob = sum - alice;\\n        \\n        int res = alice > bob;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int solve(int i,int j,vector<int> &piles){\\n        if(i > j) return 0;\\n        else if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int option1 = piles[i] + min(solve(i+2,j,piles) , solve(i+1,j-1,piles));\\n        \\n        int option2 = piles[j] + min(solve(i+1,j-1,piles) , solve(i,j-2,piles));\\n        \\n        int alice = max(option1,option2);\\n        \\n        return dp[i][j] = alice;\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        int i = 0, j = n-1;\\n        \\n        memset(dp,-1,sizeof dp);\\n        \\n        int alice = solve(i,j,piles);\\n        int bob = sum - alice;\\n        \\n        int res = alice > bob;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439113,
                "title": "c-clean-concise-solution-with-detailed-explaination",
                "content": "* **Solution**\\nWe can see that if there are just two piles of stone , Alice will always win. Expand the idea we can see that if we marked every piles of stone with black(b) and white(w) alternately we will have \\nfor example : with piles = [5,3,4,5]  \\nwe will have W B W B so if Alice goes first she will always can have all white piles or all black piles and because the number of piles is even and sum of all piles is odd so if we divide all the piles into two kinds of black and white, the sum of all piles of one kind will larger than the other. Therefore, Alice can always chooses the kind that the sum of all piles is larger so Alice always wins no matter what.\\n\\n* **Time Complexity**\\nWe just return true so the time complexity is **O(1)**.\\n\\n* **Space Complexity**\\nBecause we do not use any variables so the space complexity is **O(1)**.\\n\\n* **Source Code**\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385343,
                "title": "c-standard-optimal-game-strategy-recur-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int t[501][501];\\n    int solve(vector<int>& piles, int left, int right) {\\n        if(left > right)\\n            return 0;\\n        \\n        if(left == right)\\n            return piles[left];\\n        \\n        if(t[left][right] != -1)\\n            return t[left][right];\\n        \\n        /*\\n            That\\'s how optimal game strategy works. Expect your opponent to be playing optimally\\n            -When it\\'s your turn, do your best\\n            -When it\\'s your opponent\\'s turn, expect the worst (that\\'s why min() is taken below)\\n        */\\n        int choose_left  = piles[left]  + min(solve(piles, left+2, right), solve(piles, left+1, right-1));\\n        int choose_right = piles[right] + min(solve(piles, left, right-2), solve(piles, left+1, right-1));\\n        \\n        return t[left][right] = max(choose_left, choose_right);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        n = piles.size();\\n        memset(t, -1, sizeof(t));\\n        int sum = accumulate(begin(piles), end(piles), 0);\\n        int alexScore = solve(piles, 0, n-1);\\n        \\n        return alexScore > sum/2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int t[501][501];\\n    int solve(vector<int>& piles, int left, int right) {\\n        if(left > right)\\n            return 0;\\n        \\n        if(left == right)\\n            return piles[left];\\n        \\n        if(t[left][right] != -1)\\n            return t[left][right];\\n        \\n        /*\\n            That\\'s how optimal game strategy works. Expect your opponent to be playing optimally\\n            -When it\\'s your turn, do your best\\n            -When it\\'s your opponent\\'s turn, expect the worst (that\\'s why min() is taken below)\\n        */\\n        int choose_left  = piles[left]  + min(solve(piles, left+2, right), solve(piles, left+1, right-1));\\n        int choose_right = piles[right] + min(solve(piles, left, right-2), solve(piles, left+1, right-1));\\n        \\n        return t[left][right] = max(choose_left, choose_right);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        n = piles.size();\\n        memset(t, -1, sizeof(t));\\n        int sum = accumulate(begin(piles), end(piles), 0);\\n        int alexScore = solve(piles, 0, n-1);\\n        \\n        return alexScore > sum/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384929,
                "title": "a-few-solutions",
                "content": "**Synopsis:** [\\uD83C\\uDFA8 The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n\\n```\\n// 3:27am - 4:06am => ~39 minutes\\n\\n/*\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/4394\\n\\nPlease fix the problem statement; even/odd cardinality of the input array of stones is irrelevant.\\n\\n\\u274C \"The total number of stones is odd, so there are no ties.\"\\n\\n\\u2705 \"The accumulated sum of all of the stones values is odd, so there are no ties.\"\\n\\n*/\\n\\n/*\\n\\n3:45am: game plan, take best of first/last minus whatever\\'s leftover\\n\\nthe recursive function then needs to return the best solution as the recursive stack unwinds, so we need to consider all possibilities:\\n\\na - take first\\nb - take last\\n\\n*/\\n\\n// 3:59am brute-force TLE => ~22 minutes\\n/*\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<bool(int, int)>;\\n    bool stoneGame(VI& A) {\\n        int N = A.size();\\n        fun go = [&](auto i, auto j) {\\n            if (i == j)                    // \\uD83D\\uDED1 base case\\n                return A[i];\\n            auto a = A[i] - go(i + 1, j),  // \\uD83D\\uDE80 take first and recursively go find and subtract the best adversarial score\\n                 b = A[j] - go(i, j - 1);  // \\uD83D\\uDE80 take last and recursively go find and subtract the best adversarial score\\n            return max(a, b);              // \\uD83C\\uDFAF best of first, last for subproblem i..j\\n        };\\n        return 0 <= go(0, N - 1);          // \\uD83C\\uDFAF best of first, last for the original problem itself 0..N-1\\n    }\\n};\\n*/\\n\\n// 4:00am +memo for AC => + ~10 seconds\\n/*\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<bool(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    bool stoneGame(VI& A, Map m = {}) {\\n        int N = A.size();\\n        fun go = [&](auto i, auto j) {\\n            if (i == j)                              // \\uD83D\\uDED1 base case\\n                return A[i];\\n            stringstream key; key << i << \",\" << j;\\n            if (m.find(key.str()) != m.end())        // \\uD83E\\uDD14 memo\\n                return m[key.str()];\\n            auto a = A[i] - go(i + 1, j),            // \\uD83D\\uDE80 take first and recursively go find and subtract the best adversarial score\\n                 b = A[j] - go(i, j - 1);            // \\uD83D\\uDE80 take last and recursively go find and subtract the best adversarial score\\n            return m[key.str()] = max(a, b);         // \\uD83C\\uDFAF best of first, last for subproblem i..j\\n        };\\n        return 0 <= go(0, N - 1);                    // \\uD83C\\uDFAF best of first, last for the original problem itself 0..N-1\\n    }\\n};\\n*/\\n\\n// bottom-up: 4:01am - 4:06am => ~5 minutes\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    bool stoneGame(VI& A) {\\n        int N = A.size();\\n        VVI dp(N, VI(N));                           // \\uD83E\\uDD14 memo\\n        for (auto i{ 0 }; i < N; ++i)               // \\uD83D\\uDED1 base case\\n            dp[i][i] = A[i];\\n        for (auto i{ 0 }; i + 1 < N; ++i) {\\n            for (auto j{ 1 }; j < N; ++j) {\\n                auto a = A[i] - dp[i + 1][j],       // \\uD83D\\uDE80 take first and recursively go find and subtract the best adversarial score\\n                     b = A[j] - dp[i][j - 1];       // \\uD83D\\uDE80 take last and recursively go find and subtract the best adversarial score\\n                dp[i][j] = max(a, b);               // \\uD83C\\uDFAF best of first, last for subproblem i..j\\n            }\\n        }\\n        return 0 <= dp[0][N - 1];                   // \\uD83C\\uDFAF best of first, last for the original problem itself 0..N-1\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// 3:27am - 4:06am => ~39 minutes\\n\\n/*\\n\\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/4394\\n\\nPlease fix the problem statement; even/odd cardinality of the input array of stones is irrelevant.\\n\\n\\u274C \"The total number of stones is odd, so there are no ties.\"\\n\\n\\u2705 \"The accumulated sum of all of the stones values is odd, so there are no ties.\"\\n\\n*/\\n\\n/*\\n\\n3:45am: game plan, take best of first/last minus whatever\\'s leftover\\n\\nthe recursive function then needs to return the best solution as the recursive stack unwinds, so we need to consider all possibilities:\\n\\na - take first\\nb - take last\\n\\n*/\\n\\n// 3:59am brute-force TLE => ~22 minutes\\n/*\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<bool(int, int)>;\\n    bool stoneGame(VI& A) {\\n        int N = A.size();\\n        fun go = [&](auto i, auto j) {\\n            if (i == j)                    // \\uD83D\\uDED1 base case\\n                return A[i];\\n            auto a = A[i] - go(i + 1, j),  // \\uD83D\\uDE80 take first and recursively go find and subtract the best adversarial score\\n                 b = A[j] - go(i, j - 1);  // \\uD83D\\uDE80 take last and recursively go find and subtract the best adversarial score\\n            return max(a, b);              // \\uD83C\\uDFAF best of first, last for subproblem i..j\\n        };\\n        return 0 <= go(0, N - 1);          // \\uD83C\\uDFAF best of first, last for the original problem itself 0..N-1\\n    }\\n};\\n*/\\n\\n// 4:00am +memo for AC => + ~10 seconds\\n/*\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<bool(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    bool stoneGame(VI& A, Map m = {}) {\\n        int N = A.size();\\n        fun go = [&](auto i, auto j) {\\n            if (i == j)                              // \\uD83D\\uDED1 base case\\n                return A[i];\\n            stringstream key; key << i << \",\" << j;\\n            if (m.find(key.str()) != m.end())        // \\uD83E\\uDD14 memo\\n                return m[key.str()];\\n            auto a = A[i] - go(i + 1, j),            // \\uD83D\\uDE80 take first and recursively go find and subtract the best adversarial score\\n                 b = A[j] - go(i, j - 1);            // \\uD83D\\uDE80 take last and recursively go find and subtract the best adversarial score\\n            return m[key.str()] = max(a, b);         // \\uD83C\\uDFAF best of first, last for subproblem i..j\\n        };\\n        return 0 <= go(0, N - 1);                    // \\uD83C\\uDFAF best of first, last for the original problem itself 0..N-1\\n    }\\n};\\n*/\\n\\n// bottom-up: 4:01am - 4:06am => ~5 minutes\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    bool stoneGame(VI& A) {\\n        int N = A.size();\\n        VVI dp(N, VI(N));                           // \\uD83E\\uDD14 memo\\n        for (auto i{ 0 }; i < N; ++i)               // \\uD83D\\uDED1 base case\\n            dp[i][i] = A[i];\\n        for (auto i{ 0 }; i + 1 < N; ++i) {\\n            for (auto j{ 1 }; j < N; ++j) {\\n                auto a = A[i] - dp[i + 1][j],       // \\uD83D\\uDE80 take first and recursively go find and subtract the best adversarial score\\n                     b = A[j] - dp[i][j - 1];       // \\uD83D\\uDE80 take last and recursively go find and subtract the best adversarial score\\n                dp[i][j] = max(a, b);               // \\uD83C\\uDFAF best of first, last for subproblem i..j\\n            }\\n        }\\n        return 0 <= dp[0][N - 1];                   // \\uD83C\\uDFAF best of first, last for the original problem itself 0..N-1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265664,
                "title": "c-dp-explained-commented-code",
                "content": "I used DP to solve this question.\\nConsider a range [i,j]. This represents numbers that would be present initially. Now, I have 2 options to choose from either front i.e if i choose i or choose from back i.e choose j. \\nCase 1: If i pick i, I would be left with [i+1,j]\\nCase 2: If i pick j, I would be left with [i,j-1]\\n\\nNow, from Case 1, i have the range [i+1,j], i have again 2 choices:\\nCase 1.1: If i pick i+1, I would be left with [i+2,j]\\nCase 1.2: If i pick j, I would be left with [i+1,j-1]\\n\\nAnd, from Case 2, i have the range [i,j-1], i have again 2 choices:\\nCase 2.1: If i pick i, I would be left with [i+1,j-1]\\nCase 2.2: If i pick j-1, I would be left with [i,j-2]\\n\\nThis formulates our dp. \\nWhen n=1 : If there is only one number in the array, Alice will pick that and win always.\\nWhen n=2 : If there are two numbers in the array, Alice will pick the maximum number first and win.\\nWhen n=3 : We have to think optimally now i.e Alice should pick a number in such a way that in the next chance, even if Bob picks maximum out of the either ends, he still loses. So, we can do this by making sure that Alice always picks maximum of previous minimum.\\nIt would be more clear from the below diagram:\\n\\n![image](https://assets.leetcode.com/users/images/13a56317-e29c-4376-ac5f-fa5a4cbe3c12_1623439399.7229393.png)\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n,vector<int>(n));      //dp[i][j] contains the number of stones that Alice would have collected in the range [i,j]\\n        for(int g=0;g<n;g++) {                  //This represents gap i.e when g=0, there is 1 number in the array, when g=1, we have 2 numbers in the array\\n            for(int i=0,j=g;j<n;i++,j++) {\\n                if(g==0)    dp[i][j]=piles[i];                when g=0, there is 1 number in the array\\n                else if(g==1)    dp[i][j]=max(piles[i],piles[j]);\\n                else {\\n                    int val1=piles[i]+min(dp[i+2][j],dp[i+1][j-1]);\\n                    int val2=piles[j]+min(dp[i+1][j-1],dp[i][j-2]);\\n                    dp[i][j]=max(val1,val2);\\n                }\\n            }\\n        }\\n        int total=0;\\n        for(int i: piles)    total+=i;\\n        int second=total-dp[0][n-1];              //dp[0][n-1] will contain the maximum number of stones at the end that Alice will have\\n        return total-second > second;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n,vector<int>(n));      //dp[i][j] contains the number of stones that Alice would have collected in the range [i,j]\\n        for(int g=0;g<n;g++) {                  //This represents gap i.e when g=0, there is 1 number in the array, when g=1, we have 2 numbers in the array\\n            for(int i=0,j=g;j<n;i++,j++) {\\n                if(g==0)    dp[i][j]=piles[i];                when g=0, there is 1 number in the array\\n                else if(g==1)    dp[i][j]=max(piles[i],piles[j]);\\n                else {\\n                    int val1=piles[i]+min(dp[i+2][j],dp[i+1][j-1]);\\n                    int val2=piles[j]+min(dp[i+1][j-1],dp[i][j-2]);\\n                    dp[i][j]=max(val1,val2);\\n                }\\n            }\\n        }\\n        int total=0;\\n        for(int i: piles)    total+=i;\\n        int second=total-dp[0][n-1];              //dp[0][n-1] will contain the maximum number of stones at the end that Alice will have\\n        return total-second > second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1059103,
                "title": "c-fully-explained-simple-logic-for-zerosum-game-questions",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n    bool stoneGame(vector<int>& piles) {\\n        \\n\\t\\t\\t// ZERO SUM GAME SIMILAR TO the problem https://leetcode.com/problems/stone-game-iii/ \\n\\n\\t\\t\\tint n=piles.size();\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(n,0));\\n\\n\\t\\t\\t//dp[i][j] represents the difference between the scores of P1 & P2 for the array i to j assuming P1 starts first\\n\\t\\t\\t\\n\\t\\t\\t//P1 can be anyone and we are simulating the choice for the 2nd player also in the same step so dp[i][j] always represents the difference between Player1 and Player2\\n\\t\\t\\t//since simulating 2nd player also in the same step so no need of a player dimension\\n\\n\\n\\t\\t\\t//by seeing the recurrence, we observe that the subproblem subarray length is 1 less than this problem and this 1 is less either from start or from the end so this is a LENGTH DP *************\\n\\n\\t\\t\\t//also you get hint of length dp as when we try to enumerate base cases then we see that if 1 pile is there then ans= itself ,,if two then max-other one ....\\n\\t\\t\\t//so we see that we need to go length wise same as that of longest palindromic substring/sequent\\n\\n\\t//so recurrence : T(piles,i,j)= max(piles[i]-T(piles,i+1,j), piles[j]-T(piles,i,j-1))\\n\\n\\t\\t\\t//base case ...subarray of length =1\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t\\tdp[i][i]=1;\\n\\n\\t\\t\\tfor(int i=2;i<=n;i++) ////outer loop for length of array considered *****remember it has to go till n as max length of array is n not n-1\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j+i-1<n;j++)    //inner loop for start index determination\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint start=j,end=j+i-1;\\n\\n\\t\\t\\t\\t\\tdp[start][end]=max(piles[start]-dp[start+1][end],piles[end]-dp[start][end-1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[0][n-1] >0 ? true :false ;   //so P1-P2 >0 means than P1 scored more points and since P1 was Alex at the starting of game so if P1-P2>0 then this means Alex wins\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    bool stoneGame(vector<int>& piles) {\\n        \\n\\t\\t\\t// ZERO SUM GAME SIMILAR TO the problem https://leetcode.com/problems/stone-game-iii/ \\n\\n\\t\\t\\tint n=piles.size();\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(n,0));\\n\\n\\t\\t\\t//dp[i][j] represents the difference between the scores of P1 & P2 for the array i to j assuming P1 starts first\\n\\t\\t\\t\\n\\t\\t\\t//P1 can be anyone and we are simulating the choice for the 2nd player also in the same step so dp[i][j] always represents the difference between Player1 and Player2\\n\\t\\t\\t//since simulating 2nd player also in the same step so no need of a player dimension\\n\\n\\n\\t\\t\\t//by seeing the recurrence, we observe that the subproblem subarray length is 1 less than this problem and this 1 is less either from start or from the end so this is a LENGTH DP *************\\n\\n\\t\\t\\t//also you get hint of length dp as when we try to enumerate base cases then we see that if 1 pile is there then ans= itself ,,if two then max-other one ....\\n\\t\\t\\t//so we see that we need to go length wise same as that of longest palindromic substring/sequent\\n\\n\\t//so recurrence : T(piles,i,j)= max(piles[i]-T(piles,i+1,j), piles[j]-T(piles,i,j-1))\\n\\n\\t\\t\\t//base case ...subarray of length =1\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t\\tdp[i][i]=1;\\n\\n\\t\\t\\tfor(int i=2;i<=n;i++) ////outer loop for length of array considered *****remember it has to go till n as max length of array is n not n-1\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j+i-1<n;j++)    //inner loop for start index determination\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint start=j,end=j+i-1;\\n\\n\\t\\t\\t\\t\\tdp[start][end]=max(piles[start]-dp[start+1][end],piles[end]-dp[start][end-1]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 992564,
                "title": "alex-will-only-lose-if-even-sum-odd-sum-which-is-not-possible",
                "content": "```\\nbool stoneGame(vector<int>& piles) {\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool stoneGame(vector<int>& piles) {\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 902060,
                "title": "short-clean-cpp-dp",
                "content": "similar idea shorter version\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> memo;\\n    int dfs(vector<int> &piles, int index) {\\n        if (index == piles.size() / 2) return 0;\\n        if (memo.count(index)) return memo[index];\\n        int n = piles.size() - 1;\\n        int l = piles[index] + dfs(piles, index + 1);\\n        int r = piles[n - index] + dfs(piles, index + 1);\\n        return memo[index] = max(l, r);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        return dfs(piles, 0) * 2 > accumulate(begin(piles), end(piles), 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> memo;\\n    int dfs(vector<int> &piles, int index) {\\n        if (index == piles.size() / 2) return 0;\\n        if (memo.count(index)) return memo[index];\\n        int n = piles.size() - 1;\\n        int l = piles[index] + dfs(piles, index + 1);\\n        int r = piles[n - index] + dfs(piles, index + 1);\\n        return memo[index] = max(l, r);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        return dfs(piles, 0) * 2 > accumulate(begin(piles), end(piles), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731428,
                "title": "javascript-solution-top-down-with-memoization",
                "content": "```\\nvar stoneGame = function(piles) {\\n    const n = piles.length;\\n    \\n    const memo = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        memo[i] = [];\\n    }\\n    \\n    return topDown(0, n - 1) > 0;\\n    \\n    function topDown(start, end) {\\n        if (start == end) return piles[start];\\n        if (memo[start][end]) return memo[start][end];\\n        \\n        const startPick = piles[start] - topDown(start + 1, end);\\n        const endPick = piles[end] - topDown(start, end - 1);\\n        \\n        const res = Math.max(startPick, endPick);\\n        \\n        memo[start][end] = res;\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nvar stoneGame = function(piles) {\\n    const n = piles.length;\\n    \\n    const memo = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        memo[i] = [];\\n    }\\n    \\n    return topDown(0, n - 1) > 0;\\n    \\n    function topDown(start, end) {\\n        if (start == end) return piles[start];\\n        if (memo[start][end]) return memo[start][end];\\n        \\n        const startPick = piles[start] - topDown(start + 1, end);\\n        const endPick = piles[end] - topDown(start, end - 1);\\n        \\n        const res = Math.max(startPick, endPick);\\n        \\n        memo[start][end] = res;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 470957,
                "title": "c-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int help(vector<int>& piles, int i, int j, vector<vector<int>>& memo){\\n        if(i>=j)\\n            return 0;\\n        if(memo[i][j] != 0)\\n            return memo[i][j];\\n        int a = piles[i] + min(help(piles,i+2,j, memo),help(piles,i+1,j-1, memo));\\n        int b = piles[j] + min(help(piles,i+1,j-1, memo), help(piles,i,j-2, memo));\\n        memo[i][j] = max(a,b);\\n        return memo[i][j];\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        int sum = 0;\\n        int n = piles.size();\\n        for(int i=0; i<n; i++){\\n            sum += piles[i];\\n        }\\n        \\n        vector<vector<int>> memo(n, vector<int>(n, 0));\\n        int info = help(piles, 0, n-1, memo);\\n        if(info > (sum - info))\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int help(vector<int>& piles, int i, int j, vector<vector<int>>& memo){\\n        if(i>=j)\\n            return 0;\\n        if(memo[i][j] != 0)\\n            return memo[i][j];\\n        int a = piles[i] + min(help(piles,i+2,j, memo),help(piles,i+1,j-1, memo));\\n        int b = piles[j] + min(help(piles,i+1,j-1, memo), help(piles,i,j-2, memo));\\n        memo[i][j] = max(a,b);\\n        return memo[i][j];\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        int sum = 0;\\n        int n = piles.size();\\n        for(int i=0; i<n; i++){\\n            sum += piles[i];\\n        }\\n        \\n        vector<vector<int>> memo(n, vector<int>(n, 0));\\n        int info = help(piles, 0, n-1, memo);\\n        if(info > (sum - info))\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 177041,
                "title": "c-solutin-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int findwin(vector<int>&piles, int left, int right, vector<vector<int>>& dp){\\n        if(left > right)\\n            return 0;\\n        if(dp[left][right] != -1)\\n            return dp[left][right];\\n        int pos1 = piles[left] + min(findwin(piles, left + 2, right, dp), findwin(piles, left+1, right-1, dp));\\n        int pos2 = piles[right] + min(findwin(piles, left+1, right-1, dp), findwin(piles, left, right-2, dp));\\n        return dp[left][right] = max(pos1, pos2);\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        \\n        vector<vector<int>> dp(piles.size(), vector<int>(piles.size(), -1));\\n        int left = 0;\\n        int right = piles.size()-1;\\n        int alex = findwin(piles, left, right, dp);\\n        int sum = 0;\\n        for(int i=0; i<piles.size(); i++)\\n            sum += piles[i];\\n        return alex > sum - alex;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findwin(vector<int>&piles, int left, int right, vector<vector<int>>& dp){\\n        if(left > right)\\n            return 0;\\n        if(dp[left][right] != -1)\\n            return dp[left][right];\\n        int pos1 = piles[left] + min(findwin(piles, left + 2, right, dp), findwin(piles, left+1, right-1, dp));\\n        int pos2 = piles[right] + min(findwin(piles, left+1, right-1, dp), findwin(piles, left, right-2, dp));\\n        return dp[left][right] = max(pos1, pos2);\\n    }\\n    \\n    bool stoneGame(vector<int>& piles) {\\n        \\n        vector<vector<int>> dp(piles.size(), vector<int>(piles.size(), -1));\\n        int left = 0;\\n        int right = piles.size()-1;\\n        int alex = findwin(piles, left, right, dp);\\n        int sum = 0;\\n        for(int i=0; i<piles.size(); i++)\\n            sum += piles[i];\\n        return alex > sum - alex;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828247,
                "title": "c-o-1-solution-o-1-space",
                "content": "# Intuition\\nTestCase is not Like codeforces\\n\\nAs array length is even and sum is always odd so Alice will win always.\\n\\n# Approach\\nReturn true\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n``` Just upvote it :) ```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` Just upvote it :) ```\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620322,
                "title": "alice-will-win-cpp-easy-2d-dp-just-return-true",
                "content": "```\\n\\n```class Solution {\\nprivate:\\n   //function that see weather alice win if return true.\\n   //piles given vector and dp to store result and use in future and start and end to compare \\n   //both possible piles value/amount in it to choose optimal one.\\n    bool solve(vector<int>&piles,vector<vector<int>>&dp,int start,int end,int alice,int bob,int turn){\\n\\t//if both pointer cross/ at same point;\\n        if(end<=start){\\n            if(turn==0)alice+=piles[end];\\n            else bob+=piles[end];\\n\\t\\t\\t//base case alice wins\\n            if(alice>bob)return 1;\\n            return 0;\\n        }\\n\\t\\t//check this operation is previously done if return what was answer.\\n       if(dp[start][end]!=-1)return dp[start][end];\\n\\t   //all possible ways i.e 12 \\uD83E\\uDD72\\n        bool s1=0,s2=0,s3=0,s4=0,s5=0,s6=0,s7=0,s8=0,s9=0,s10=0,s11=0,s12=0;\\n\\t  //if both value present at start and end are same.\\n        if(piles[start]==piles[end]){\\n\\t\\t//if then check for turn 0 for alice and 1 for bob.\\n            if(turn==0){\\n\\t\\t\\t     //alice turn.\\n\\t\\t\\t    //go for both call because same value at start end end.\\n\\t\\t\\t\\t//start call select and go for other.\\n                s1=solve(piles,dp,start+1,end,alice+piles[start],bob,1);\\n\\t\\t\\t\\t//selecting end call and go forward.\\n                s2=solve(piles,dp,start,end-1,alice+piles[end],bob,1);\\n            }else{\\n\\t\\t\\t //if bobs turn .\\n\\t\\t\\t //start call.\\n                s3=solve(piles,dp,start+1,end,alice,bob+piles[start],0);\\n\\t\\t\\t//end call.\\n                s4=solve(piles,dp,start,end-1,alice,bob+piles[end],0);\\n            }\\n        }\\n\\t\\t//if value at start index is greater then end.\\n        if(piles[start]>piles[end]){\\n\\t\\t//alice turn.\\n             if(turn==0){\\n\\t\\t\\t   //here we need to check for both possiblity because if in futhure this kind of case may occur [3,2,10,4].\\n\\t\\t\\t   //i.e ur choosing for current position is optimal but for further calls it will not be optimal so we choose both calls.\\n                s5=solve(piles,dp,start+1,end,alice+piles[start],bob,1);\\n\\t\\t\\t\\t//very important to understand and call.\\n                s6=solve(piles,dp,start,end-1,alice+piles[end],bob,1);\\n            }\\n\\t\\t//bobs turn.\\n\\t\\t\\telse{\\n\\t\\t\\t //same as alice possibility bob also need to play optimally.\\n                s7=solve(piles,dp,start+1,end,alice,bob+piles[start],0);\\n               s8=solve(piles,dp,start,end-1,alice,bob+piles[end],0);\\n            }\\n        }else{\\n\\t\\t  //similar thought process goes for this possibility.\\n             if(turn==0){\\n\\t\\t\\t    //if end index value greater then start.\\n                s9=solve(piles,dp,start+1,end,alice+piles[start],bob,1);\\n                s10=solve(piles,dp,start,end-1,alice+piles[end],bob,1);\\n            }else{\\n                s11=solve(piles,dp,start+1,end,alice,bob+piles[start],0);\\n                s12=solve(piles,dp,start,end-1,alice,bob+piles[end],0);\\n            }\\n        }\\n\\t\\t//at the end store/return all possibilitys.\\n        return dp[start][end]=(s1||s2||s3||s4||s5||s6||s7||s8||s9||s10||s11||s12);\\n    }\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n\\t\\t//2d dp vector to see both side possibility start/end of row.\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        return solve(piles,dp,0,n-1,0,0,0);\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/5881e682-f80a-481b-915b-78fd5c8442d3_1689053130.4833167.jpeg)\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n\\n```\n```\\n![image](https://assets.leetcode.com/users/images/5881e682-f80a-481b-915b-78fd5c8442d3_1689053130.4833167.jpeg)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3573069,
                "title": "python-short-and-clean-functional-programming",
                "content": "# Approach 1: Recursive DP\\n\\n# Complexity\\n- Time complexity: $$O(n ^ 2)$$\\n\\n- Space complexity: $$O(n ^ 2)$$\\n\\nwhere, `n is number of piles.`\\n\\n# Code\\n```python\\nclass Solution:\\n    def stoneGame(self, piles: list[int]) -> bool:\\n        @cache\\n        def score(i: int, j: int) -> int:\\n            return (i < j) and max(piles[i] + score(i + 1, j), piles[j] + score(i, j - 1))\\n        \\n        return score(0, len(piles) - 1)\\n\\n\\n```\\n\\n# Approach 2: Math\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def stoneGame(self, piles: list[int]) -> bool:\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Game Theory"
                ],
                "code": "```python\\nclass Solution:\\n    def stoneGame(self, piles: list[int]) -> bool:\\n        @cache\\n        def score(i: int, j: int) -> int:\\n            return (i < j) and max(piles[i] + score(i + 1, j), piles[j] + score(i, j - 1))\\n        \\n        return score(0, len(piles) - 1)\\n\\n\\n```\n```python\\nclass Solution:\\n    def stoneGame(self, piles: list[int]) -> bool:\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565994,
                "title": "4-solutions-why-alice-always-wins-intuition-explained-brute-optimal-with-comment-explanation",
                "content": "\\uD83D\\uDE0A \\uD835\\uDE4E\\uD835\\uDE5A\\uD835\\uDE61\\uD835\\uDE5B \\uD835\\uDE3E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE56\\uD835\\uDE69\\uD835\\uDE5A\\uD835\\uDE59 \\uD835\\uDE47\\uD835\\uDE64\\uD835\\uDE5C\\uD835\\uDE5E\\uD835\\uDE58 ~ \\uD835\\uDE52\\uD835\\uDE5E\\uD835\\uDE69\\uD835\\uDE5D \\u2764\\uFE0F \\uD835\\uDE57\\uD835\\uDE6E \\uD835\\uDE43\\uD835\\uDE5E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE63\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- If You\\'re Thinking I Am Also Here With Rough And Same Explanations As Others Of Why Alice Always Wins. But No, Believe Me I Understand It And Made The Intuition Myself. \\n\\n- I Bet You\\'ll Say In The End That You Got It.\\n- The Only Thing You Have To Do Is To Just Look At The Code And Read The Comments With A Happy Face, Thats It!\\n\\nNote : Start reading from the Main Method\\n\\n- If you\\'re raised with any kinda doubt, The comment section is free to be filled. I will Definately Reply!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n4 Solutions :-\\n1. Recursion\\n2. Recursion + Memoization\\n3. Easy Two Pointers\\n4. One Line Solution - With Actual Intuition & Reason\\n\\n# Complexity\\n- Time complexity: Mentioned in the code\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Mentioned in the code\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Program to verify Alice wins the game or Bob as both the players are playing optimally ~ coded by Hiren\\n#include <iostream>\\n#include <vector>\\n#include <numeric>\\nusing namespace std;\\n\\n// #1 Method Helper\\nint solveWithoutMemo(vector<int>& piles, bool turn, int i, int j) {\\n    // Edge case\\n    if(i > j)\\n        return 0;\\n\\n    // There are two possible strategies for the current player to maximize their score\\n    int ithPile = piles[i] + solveWithoutMemo(piles, !turn, i+1, j); // Is to take the ith pile and wait for the next turn\\n    int jthPile = piles[j] + solveWithoutMemo(piles, !turn, i, j-1); // Or is to take the jth pile and wait for the next turn\\n\\n    int currentStone = 0; // Requires to store the score \\n\\n    if(turn)\\n        currentStone = max(ithPile, jthPile); // The current player with initial turn always wants to win hence it takes the maximum score \\n    else\\n        currentStone = min(ithPile, jthPile); // And the current player also wants that the second player losses hence it showed up with minimum score \\n\\n    return currentStone;\\n}\\n\\n// #1 Method to verify Alice wins the game or Bob - O(2^N) & O(N)\\nbool stoneGame_1(vector<int>& piles) {\\n    int n = piles.size();\\n\\n    int aliceStones = solveWithoutMemo(piles, true, 0, n-1); // Find and store the maximum score Alice can make\\n    int totalStone = accumulate(begin(piles), end(piles), 0);\\n    int bobStones = totalStone-aliceStones; // Logically the remaining score is the score that Bob can make   \\n\\n    return aliceStones > bobStones;   \\n}\\n// Note: This one can give TLE\\n\\n// #2 Method Helper\\nint solveWithMemo(vector<int>& piles, bool turn, int i, int j, vector<vector<int>>& memo) {\\n    // Edge case\\n    if(i > j)\\n        return 0;\\n\\n    if(memo[i][j] != -1)\\n        return memo[i][j];\\n\\n    // There are two possible strategies for the current player to maximize their score\\n    int ithPile = piles[i] + solveWithMemo(piles, !turn, i+1, j, memo); // Is to take the ith pile and wait for the next turn\\n    int jthPile = piles[j] + solveWithMemo(piles, !turn, i, j-1, memo); // Or is to take the jth pile and wait for the next turn\\n\\n    int currentStone = 0; // Requires to store the score \\n\\n    if(turn)\\n        currentStone = max(ithPile, jthPile); // The current player with initial turn always wants to win hence it takes the maximum score \\n    else\\n        currentStone = min(ithPile, jthPile); // And the current player also wants that the second player losses hence it showed up with minimum score \\n\\n    return memo[i][j] = currentStone;\\n}\\n\\n// #2 Method to verify Alice wins the game or Bob - O(N^2) & O(N^2)\\nbool stoneGame_2(vector<int>& piles) {\\n    int n = piles.size();\\n\\n    vector<vector<int>> memo(n, vector<int>(n, -1));\\n\\n    int aliceStones = solveWithMemo(piles, true, 0, n-1, memo); // Find and store the maximum score Alice can make\\n    int totalStone = accumulate(begin(piles), end(piles), 0);\\n    int bobStones = totalStone-aliceStones; // Logically the remaining score is the score that Bob can make   \\n\\n    return aliceStones > bobStones;   \\n}\\n// Note: Can also make the Bottom Up Approach\\n\\n// #3 Method to verify Alice wins the game or Bob - O(N) & O(1)\\nbool stoneGame_3(vector<int>& piles) {\\n    int i = 0;\\n    int j = piles.size() - 1;\\n\\n    int aliceStones = 0, bobStones = 0;\\n    bool aliceTurn = true; // We know Alice always starts the game that means she always wants to maximize her score\\n\\n    while(i <= j) {\\n        // If its Alice\\'s turn\\n        if(aliceTurn) {\\n            // Take the maximum score for her because she is the initial player with turn and she wants to win\\n            if(piles[i] > piles[j])\\n                aliceStones += piles[i++];\\n            else\\n                aliceStones += piles[j--];\\n        }\\n        // Else its Bob\\'s turn\\n        else {\\n            // Let him with the minimum score because the initial turn player(Alice) wants to win\\n            if(piles[i] > piles[j])\\n                bobStones += piles[j--];\\n            else\\n                bobStones += piles[i++];\\n        }\\n        \\n        aliceTurn = !aliceTurn; // Change the player turn\\n    }\\n\\n    // Alice wins if she has more stones than Bob\\n    return aliceStones > bobStones;\\n}\\n\\n// #4 Method to verify Alice wins the game or Bob - O(1) & O(1)\\nbool stoneGame_4(vector<int>& piles) {\\n    // Alice always wins the game : Read the reason with below example\\n    \\n    /* \\n        1. We know both Alice and Bob have two possibility - Is that the player with its turn can take the entire pile of stones either from the beginning or from the end of the row\\n\\n        2. If you notice the player who starts the game :-\\n            - If it chooses the possibility of taking the entire piles from extreme left than this player will absolutely moving in odd fashion \\n            - If it chooses the possibility of taking the entire piles from extreme right than this player will absolutely moving in even fashion \\n\\n        3. So, Lets understand with the Example : [5, 2, 3, 3]\\n                                        Position - 1  2  3  4\\n\\n            -> We know Alice always starts the game, Than the odd fashion results of Alice and Bob will be :-\\n                    Alice Stones - [5, 3] (Maximum is 8)\\n                    Bob Stones   - [2, 3] (Maximum is 5)\\n\\n            -> We know Alice always starts the game, Than the even fashion results of Alice and Bob will be :-\\n                    Alice Stones - [3, 2] (Maximum is 5) \\n                    Bob Stones   - [3, 5] (Maximum is 8)\\n\\n\\n            Imp: If you notice you can see both the players have choosen all positions from both the possibility\\n                That means Alice and Bob both got the maximum results, That means both are going to Win! As both made the maximum. But No, Its not like that\\n                The reason why Alice is always the winner is because Alice is ending up with all the positions first which we can see in the second possibility, Here again take a look at it :-\\n\\n                    Alice Stones - [3, 2] (Maximum is 5) --> See Alice is ending up firstly! Which means, When the player who made all the positions first from both the possibility has got the game! Because we know taking all the positions means that the larger score lies in that, and we can see from both the possibility that Alice made it first, Thats why Alice always wins the game\\n\\n                    Bob Stones   - [3, 5] (Maximum is 8) --> As Alice ended up firstly! There is no way to win for Bob       \\n\\n        4. Again, Alice always wins the game because we know the maximum result always lies in anyone possibility and hence Alice ended up with all the positions first! She\\'s got the game\\n    */\\n   \\n    return true;\\n}\\n\\n// Driver code\\nint main() {\\n    vector<int> piles{5, 2, 3, 3};\\n    // Print values\\n    for(int stone : piles)\\n        cout<<stone<<\\' \\';\\n\\n    // Method call\\n    if(stoneGame_4(piles))\\n        cout<<\"\\\\nAlice wins the game with maximum stones!\";\\n    else\\n        cout<<\"\\\\nBob wins the game with maximum stones!\";\\n\\n    return 0;\\n}\\n// Link: https://leetcode.com/problems/stone-game/\\n```\\n\\uD835\\uDDE8\\uD835\\uDDE3\\uD835\\uDDE9\\uD835\\uDDE2\\uD835\\uDDE7\\uD835\\uDDD8 \\uD835\\uDDDC\\uD835\\uDDD9 \\uD835\\uDDEC\\uD835\\uDDE2\\uD835\\uDDE8 \\uD835\\uDDDF\\uD835\\uDDDC\\uD835\\uDDDE\\uD835\\uDDD8 \\uD835\\uDDE7\\uD835\\uDDDB\\uD835\\uDDD8 \\uD835\\uDDE6\\uD835\\uDDE2\\uD835\\uDDDF\\uD835\\uDDE8\\uD835\\uDDE7\\uD835\\uDDDC\\uD835\\uDDE2\\uD835\\uDDE1 \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Dynamic Programming",
                    "Game Theory"
                ],
                "code": "```\\n// Program to verify Alice wins the game or Bob as both the players are playing optimally ~ coded by Hiren\\n#include <iostream>\\n#include <vector>\\n#include <numeric>\\nusing namespace std;\\n\\n// #1 Method Helper\\nint solveWithoutMemo(vector<int>& piles, bool turn, int i, int j) {\\n    // Edge case\\n    if(i > j)\\n        return 0;\\n\\n    // There are two possible strategies for the current player to maximize their score\\n    int ithPile = piles[i] + solveWithoutMemo(piles, !turn, i+1, j); // Is to take the ith pile and wait for the next turn\\n    int jthPile = piles[j] + solveWithoutMemo(piles, !turn, i, j-1); // Or is to take the jth pile and wait for the next turn\\n\\n    int currentStone = 0; // Requires to store the score \\n\\n    if(turn)\\n        currentStone = max(ithPile, jthPile); // The current player with initial turn always wants to win hence it takes the maximum score \\n    else\\n        currentStone = min(ithPile, jthPile); // And the current player also wants that the second player losses hence it showed up with minimum score \\n\\n    return currentStone;\\n}\\n\\n// #1 Method to verify Alice wins the game or Bob - O(2^N) & O(N)\\nbool stoneGame_1(vector<int>& piles) {\\n    int n = piles.size();\\n\\n    int aliceStones = solveWithoutMemo(piles, true, 0, n-1); // Find and store the maximum score Alice can make\\n    int totalStone = accumulate(begin(piles), end(piles), 0);\\n    int bobStones = totalStone-aliceStones; // Logically the remaining score is the score that Bob can make   \\n\\n    return aliceStones > bobStones;   \\n}\\n// Note: This one can give TLE\\n\\n// #2 Method Helper\\nint solveWithMemo(vector<int>& piles, bool turn, int i, int j, vector<vector<int>>& memo) {\\n    // Edge case\\n    if(i > j)\\n        return 0;\\n\\n    if(memo[i][j] != -1)\\n        return memo[i][j];\\n\\n    // There are two possible strategies for the current player to maximize their score\\n    int ithPile = piles[i] + solveWithMemo(piles, !turn, i+1, j, memo); // Is to take the ith pile and wait for the next turn\\n    int jthPile = piles[j] + solveWithMemo(piles, !turn, i, j-1, memo); // Or is to take the jth pile and wait for the next turn\\n\\n    int currentStone = 0; // Requires to store the score \\n\\n    if(turn)\\n        currentStone = max(ithPile, jthPile); // The current player with initial turn always wants to win hence it takes the maximum score \\n    else\\n        currentStone = min(ithPile, jthPile); // And the current player also wants that the second player losses hence it showed up with minimum score \\n\\n    return memo[i][j] = currentStone;\\n}\\n\\n// #2 Method to verify Alice wins the game or Bob - O(N^2) & O(N^2)\\nbool stoneGame_2(vector<int>& piles) {\\n    int n = piles.size();\\n\\n    vector<vector<int>> memo(n, vector<int>(n, -1));\\n\\n    int aliceStones = solveWithMemo(piles, true, 0, n-1, memo); // Find and store the maximum score Alice can make\\n    int totalStone = accumulate(begin(piles), end(piles), 0);\\n    int bobStones = totalStone-aliceStones; // Logically the remaining score is the score that Bob can make   \\n\\n    return aliceStones > bobStones;   \\n}\\n// Note: Can also make the Bottom Up Approach\\n\\n// #3 Method to verify Alice wins the game or Bob - O(N) & O(1)\\nbool stoneGame_3(vector<int>& piles) {\\n    int i = 0;\\n    int j = piles.size() - 1;\\n\\n    int aliceStones = 0, bobStones = 0;\\n    bool aliceTurn = true; // We know Alice always starts the game that means she always wants to maximize her score\\n\\n    while(i <= j) {\\n        // If its Alice\\'s turn\\n        if(aliceTurn) {\\n            // Take the maximum score for her because she is the initial player with turn and she wants to win\\n            if(piles[i] > piles[j])\\n                aliceStones += piles[i++];\\n            else\\n                aliceStones += piles[j--];\\n        }\\n        // Else its Bob\\'s turn\\n        else {\\n            // Let him with the minimum score because the initial turn player(Alice) wants to win\\n            if(piles[i] > piles[j])\\n                bobStones += piles[j--];\\n            else\\n                bobStones += piles[i++];\\n        }\\n        \\n        aliceTurn = !aliceTurn; // Change the player turn\\n    }\\n\\n    // Alice wins if she has more stones than Bob\\n    return aliceStones > bobStones;\\n}\\n\\n// #4 Method to verify Alice wins the game or Bob - O(1) & O(1)\\nbool stoneGame_4(vector<int>& piles) {\\n    // Alice always wins the game : Read the reason with below example\\n    \\n    /* \\n        1. We know both Alice and Bob have two possibility - Is that the player with its turn can take the entire pile of stones either from the beginning or from the end of the row\\n\\n        2. If you notice the player who starts the game :-\\n            - If it chooses the possibility of taking the entire piles from extreme left than this player will absolutely moving in odd fashion \\n            - If it chooses the possibility of taking the entire piles from extreme right than this player will absolutely moving in even fashion \\n\\n        3. So, Lets understand with the Example : [5, 2, 3, 3]\\n                                        Position - 1  2  3  4\\n\\n            -> We know Alice always starts the game, Than the odd fashion results of Alice and Bob will be :-\\n                    Alice Stones - [5, 3] (Maximum is 8)\\n                    Bob Stones   - [2, 3] (Maximum is 5)\\n\\n            -> We know Alice always starts the game, Than the even fashion results of Alice and Bob will be :-\\n                    Alice Stones - [3, 2] (Maximum is 5) \\n                    Bob Stones   - [3, 5] (Maximum is 8)\\n\\n\\n            Imp: If you notice you can see both the players have choosen all positions from both the possibility\\n                That means Alice and Bob both got the maximum results, That means both are going to Win! As both made the maximum. But No, Its not like that\\n                The reason why Alice is always the winner is because Alice is ending up with all the positions first which we can see in the second possibility, Here again take a look at it :-\\n\\n                    Alice Stones - [3, 2] (Maximum is 5) --> See Alice is ending up firstly! Which means, When the player who made all the positions first from both the possibility has got the game! Because we know taking all the positions means that the larger score lies in that, and we can see from both the possibility that Alice made it first, Thats why Alice always wins the game\\n\\n                    Bob Stones   - [3, 5] (Maximum is 8) --> As Alice ended up firstly! There is no way to win for Bob       \\n\\n        4. Again, Alice always wins the game because we know the maximum result always lies in anyone possibility and hence Alice ended up with all the positions first! She\\'s got the game\\n    */\\n   \\n    return true;\\n}\\n\\n// Driver code\\nint main() {\\n    vector<int> piles{5, 2, 3, 3};\\n    // Print values\\n    for(int stone : piles)\\n        cout<<stone<<\\' \\';\\n\\n    // Method call\\n    if(stoneGame_4(piles))\\n        cout<<\"\\\\nAlice wins the game with maximum stones!\";\\n    else\\n        cout<<\"\\\\nBob wins the game with maximum stones!\";\\n\\n    return 0;\\n}\\n// Link: https://leetcode.com/problems/stone-game/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3565641,
                "title": "stone-game-slightly-diff-house-robber",
                "content": "```\\nclass Solution {\\npublic:\\n    bool f(int i,vector<int>& piles,vector<int>&dp)\\n    {\\n        if(i<0) return false;\\n        if(i==0) return piles[i];\\n        if(dp[i]!=-1) return dp[i];\\n        int take=f(i-1,piles,dp)+piles[i];\\n        int nott=f(i-2,piles,dp)+0;\\n        return dp[i]=max(take,nott);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        vector<int>dp(n,-1);\\n        return max(f(n-1,piles,dp),f(0,piles,dp));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(int i,vector<int>& piles,vector<int>&dp)\\n    {\\n        if(i<0) return false;\\n        if(i==0) return piles[i];\\n        if(dp[i]!=-1) return dp[i];\\n        int take=f(i-1,piles,dp)+piles[i];\\n        int nott=f(i-2,piles,dp)+0;\\n        return dp[i]=max(take,nott);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        vector<int>dp(n,-1);\\n        return max(f(n-1,piles,dp),f(0,piles,dp));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503835,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& v) {\\n        int a=0,b=0,i=0,j=v.size()-1;\\n        while(i<j){\\n          if(v[i]>v[j]){\\n            a+=v[i];\\n            b+=v[j];\\n          }\\n          else{\\n            a+=v[j];\\n            b+=v[i];\\n          }\\n          i++;\\n          j--;\\n        }\\n        return a>b;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        int n=piles.length;\\n        int sum1=0,sum2=0,sum3=0,sum4=0;\\n        for(int i=0;i<n;i++){\\n            if((i+1)%2!=0){\\n                     sum1+=piles[i];\\n                 }else {\\n                     sum2+=piles[i];\\n                 }\\n        }\\n        for(int i=n-1;i>=0;i--){\\n                 if(i%2!=0){\\n                     sum3+=piles[i];\\n                 }else {\\n                     sum4+=piles[i];\\n                 }\\n             }\\n        if(sum1>sum3){\\n            if(sum1>sum2)return true;\\n        }else{\\n           if(sum3>sum4)return true;\\n        }\\n        return false;         \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& v) {\\n        int a=0,b=0,i=0,j=v.size()-1;\\n        while(i<j){\\n          if(v[i]>v[j]){\\n            a+=v[i];\\n            b+=v[j];\\n          }\\n          else{\\n            a+=v[j];\\n            b+=v[i];\\n          }\\n          i++;\\n          j--;\\n        }\\n        return a>b;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```\n```Java []\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        int n=piles.length;\\n        int sum1=0,sum2=0,sum3=0,sum4=0;\\n        for(int i=0;i<n;i++){\\n            if((i+1)%2!=0){\\n                     sum1+=piles[i];\\n                 }else {\\n                     sum2+=piles[i];\\n                 }\\n        }\\n        for(int i=n-1;i>=0;i--){\\n                 if(i%2!=0){\\n                     sum3+=piles[i];\\n                 }else {\\n                     sum4+=piles[i];\\n                 }\\n             }\\n        if(sum1>sum3){\\n            if(sum1>sum2)return true;\\n        }else{\\n           if(sum3>sum4)return true;\\n        }\\n        return false;         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083108,
                "title": "easy-two-pointer-solution-javascript",
                "content": "# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n# Code\\n```\\n/**\\n * @param {number[]} piles\\n * @return {boolean}\\n */\\nvar stoneGame = function(piles) {\\n    return true; // Alice wins anyways\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math",
                    "Two Pointers",
                    "Game Theory"
                ],
                "code": "```\\n/**\\n * @param {number[]} piles\\n * @return {boolean}\\n */\\nvar stoneGame = function(piles) {\\n    return true; // Alice wins anyways\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3031911,
                "title": "0ms-with-100-beats-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n    return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n    return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958537,
                "title": "c-easy-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool helper(int start, int end, int turn, vector<int> &piles, int scorea, int scoreb, vector<vector<int>> &dp){\\n\\n        if(start == end){\\n            if(turn == 0){\\n                scorea += piles[start];\\n            }else if(turn == 1){\\n                scoreb += piles[start];\\n            }\\n            if(scorea > scoreb) return true;\\n            return false;\\n        }\\n\\n        if(dp[start][end] != -1) return dp[start][end];\\n\\n        bool check = false;\\n\\n        if(turn == 0){\\n            check = helper(start+1,end,1,piles,scorea+piles[start],scoreb,dp) || helper(start,end-1,1,piles,scorea+piles[end],scoreb,dp);\\n        }else if(turn == 1){\\n            check = helper(start+1,end,0,piles,scorea,scoreb+piles[start],dp) || helper(start,end-1,0,piles,scorea,scoreb+piles[end],dp);\\n        }\\n\\n        return dp[start][end] = check;\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n+1, vector<int> (n+1, -1));\\n        return helper(0,n-1,0,piles,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool helper(int start, int end, int turn, vector<int> &piles, int scorea, int scoreb, vector<vector<int>> &dp){\\n\\n        if(start == end){\\n            if(turn == 0){\\n                scorea += piles[start];\\n            }else if(turn == 1){\\n                scoreb += piles[start];\\n            }\\n            if(scorea > scoreb) return true;\\n            return false;\\n        }\\n\\n        if(dp[start][end] != -1) return dp[start][end];\\n\\n        bool check = false;\\n\\n        if(turn == 0){\\n            check = helper(start+1,end,1,piles,scorea+piles[start],scoreb,dp) || helper(start,end-1,1,piles,scorea+piles[end],scoreb,dp);\\n        }else if(turn == 1){\\n            check = helper(start+1,end,0,piles,scorea,scoreb+piles[start],dp) || helper(start,end-1,0,piles,scorea,scoreb+piles[end],dp);\\n        }\\n\\n        return dp[start][end] = check;\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n+1, vector<int> (n+1, -1));\\n        return helper(0,n-1,0,piles,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952643,
                "title": "java-1-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAlice always WINS given the constraints.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849282,
                "title": "100-fast-with-proof",
                "content": "![image](https://assets.leetcode.com/users/images/99cb3dd4-a443-4e8d-be6e-92726e6305cb_1669445820.873135.png)\\n\\nCode Source : -\\nsort(piles.begin(),piles.end());\\n        int x=piles.size();\\n        int sum=0,sum1=0;    \\n        for(int i=x-1; i>=0; i=i-2)\\n        {\\n            sum=sum+piles[i];\\n        }\\n        for(int i=x-2; i>=1; i=i-2)\\n        {\\n            sum1=sum1+piles[i];\\n        }\\n        if(sum>sum1)\\n            return true;\\n        else\\n            return false;\\n\\t\\t\\t\\nIf its help upvote...\\n\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/99cb3dd4-a443-4e8d-be6e-92726e6305cb_1669445820.873135.png)\\n\\nCode Source : -\\nsort(piles.begin(),piles.end());\\n        int x=piles.size();\\n        int sum=0,sum1=0;    \\n        for(int i=x-1; i>=0; i=i-2)\\n        {\\n            sum=sum+piles[i];\\n        }\\n        for(int i=x-2; i>=1; i=i-2)\\n        {\\n            sum1=sum1+piles[i];\\n        }\\n        if(sum>sum1)\\n            return true;\\n        else\\n            return false;\\n\\t\\t\\t\\nIf its help upvote...\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2783421,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\ntypedef pair<int, int> pii;\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int> &piles) {\\n        int n = piles.size();\\n        vector<vector<pii>> dp(n, vector<pii>(n));\\n        for (int left = n - 1; left >= 0; --left) {\\n            for (int right = left; right < n; ++right) {\\n                if (left == right) { \\n                    dp[left][right] = make_pair(piles[left], 0);\\n                    continue;\\n                }\\n                pii pickLeft = dp[left + 1][right];\\n                pii pickRight = dp[left][right - 1];\\n                if (piles[left] + pickLeft.second > piles[right] + pickRight.second) \\n                    dp[left][right] = make_pair(piles[left] + pickLeft.second, pickLeft.first);\\n                else\\n                    dp[left][right] = make_pair(piles[right] + pickRight.second, pickRight.first);\\n            }\\n        }\\n        auto[aliceScore, leeScore] = dp[0][n - 1];\\n        return aliceScore > leeScore;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef pair<int, int> pii;\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int> &piles) {\\n        int n = piles.size();\\n        vector<vector<pii>> dp(n, vector<pii>(n));\\n        for (int left = n - 1; left >= 0; --left) {\\n            for (int right = left; right < n; ++right) {\\n                if (left == right) { \\n                    dp[left][right] = make_pair(piles[left], 0);\\n                    continue;\\n                }\\n                pii pickLeft = dp[left + 1][right];\\n                pii pickRight = dp[left][right - 1];\\n                if (piles[left] + pickLeft.second > piles[right] + pickRight.second) \\n                    dp[left][right] = make_pair(piles[left] + pickLeft.second, pickLeft.first);\\n                else\\n                    dp[left][right] = make_pair(piles[right] + pickRight.second, pickRight.first);\\n            }\\n        }\\n        auto[aliceScore, leeScore] = dp[0][n - 1];\\n        return aliceScore > leeScore;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691615,
                "title": "alice-always-wins",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we have even number of piles, Alice can pick such that she takes all even indexed piles or all odd indexed piles. And since the sum of all piles is odd, Alice always wins.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583186,
                "title": "stone-game-c-recursion-to-dp-memoisation",
                "content": "**Recursion:**\\n```\\nclass Solution {\\npublic:\\n    // 1->alice , 0->bob\\n    bool solve(vector<int>& piles,int l, int r,int turn){\\n        if(l>r) return 0;\\n\\n        int left = piles[l]+ solve(piles,l+1,r,turn);        \\n        int right = piles[r]+ solve(piles,l,r-1,turn);\\n        int alice=0,bob=0;\\n        turn==1?alice+=max(left,right):bob+=max(left,right);\\n        \\n        return alice>bob?true:false;\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        return solve(piles,0,piles.size()-1,1);\\n    }\\n};\\n```\\nGives TLE, storing the overlapping cases using memoisation\\n\\n**DP[Memoisation]:**\\n\\n```\\nclass Solution {\\npublic:\\n    // turn: 1->alice , 0->bob \\n    int dp[501][501][2];\\n    bool solve(vector<int>& piles,int l, int r,int tn){\\n        if(l>r) return 0;\\n        if(dp[l][r][tn]!=-1) return dp[l][r][tn]; // if case has already been encountered\\n\\n        int alice=0,bob=0;\\n        int left,right;\\n        if(tn==1){\\n            left = piles[l]+ solve(piles,l+1,r,0);        \\n            right = piles[r]+ solve(piles,l,r-1,0);\\n            return dp[l][r][tn]=max(left,right); //storing the result in dp for alice\\n        }\\n        else{\\n            left = piles[l]+ solve(piles,l+1,r,1);        \\n            right = piles[r]+ solve(piles,l,r-1,1);\\n            return dp[l][r][tn]=max(left,right); //storing the result in dp for bob\\n        }\\n        \\n        return 0;\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(piles,0,piles.size()-1,1);\\n\\t        \\n        int sum=0;\\n        for(auto i : piles){\\n            sum+=i;\\n        }\\n        \\n        if(sum-2*solve(piles,0,piles.size()-1,1)<0) return true;\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // 1->alice , 0->bob\\n    bool solve(vector<int>& piles,int l, int r,int turn){\\n        if(l>r) return 0;\\n\\n        int left = piles[l]+ solve(piles,l+1,r,turn);        \\n        int right = piles[r]+ solve(piles,l,r-1,turn);\\n        int alice=0,bob=0;\\n        turn==1?alice+=max(left,right):bob+=max(left,right);\\n        \\n        return alice>bob?true:false;\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        return solve(piles,0,piles.size()-1,1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // turn: 1->alice , 0->bob \\n    int dp[501][501][2];\\n    bool solve(vector<int>& piles,int l, int r,int tn){\\n        if(l>r) return 0;\\n        if(dp[l][r][tn]!=-1) return dp[l][r][tn]; // if case has already been encountered\\n\\n        int alice=0,bob=0;\\n        int left,right;\\n        if(tn==1){\\n            left = piles[l]+ solve(piles,l+1,r,0);        \\n            right = piles[r]+ solve(piles,l,r-1,0);\\n            return dp[l][r][tn]=max(left,right); //storing the result in dp for alice\\n        }\\n        else{\\n            left = piles[l]+ solve(piles,l+1,r,1);        \\n            right = piles[r]+ solve(piles,l,r-1,1);\\n            return dp[l][r][tn]=max(left,right); //storing the result in dp for bob\\n        }\\n        \\n        return 0;\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(piles,0,piles.size()-1,1);\\n\\t        \\n        int sum=0;\\n        for(auto i : piles){\\n            sum+=i;\\n        }\\n        \\n        if(sum-2*solve(piles,0,piles.size()-1,1)<0) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409754,
                "title": "just-return-true",
                "content": "Whoever starts first, would win this gme.\\nAs, Alice starts first, she wins everytime and hence we return true.\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322020,
                "title": "very-easy-c-solution-only-just-return-true-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276961,
                "title": "easiest-solution-just-return-true",
                "content": "```\\n\\n//Just return true;\\n//\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n//Just return true;\\n//\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2170816,
                "title": "java-intuitive-solution",
                "content": "```\\nclass Solution {\\n    \\n    public boolean stoneGame(int[] piles) {\\n       // Calculate total sum. \\n       int totalSum = Arrays.stream(piles).sum();\\n       int[][] dp = new int[piles.length][piles.length];\\n       for (int[] arr: dp) {\\n           Arrays.fill(arr, -1);\\n       } \\n       // We will try to maximize Alice Sum. \\n       int sum = stoneGame(0, piles.length - 1, piles, dp);\\n       // Subtract Alice Maximized Sum from total Sum to get Bob\\'s Sum and determine the result appropriately.\\n       return sum > (totalSum - sum) ? true : false;\\n    }\\n    \\n    public int stoneGame(int i, int j, int[] piles, int[][] dp) {\\n       int sum = 0;\\n       if (i < j) {\\n          if (dp[i][j] != -1) {\\n              return dp[i][j];\\n          }\\n          // If Alice chooses i, Bob can choose i + 1 or j.\\n          // If Bob chooses i + 1, In the next round Alice can choose i + 2 or j.\\n          // If Bob chooses j, In the next round  Alice can choose i + 1  or j -1.\\n          int sum1 =  piles[i] + Math.max(stoneGame(i + 2, j, piles, dp),stoneGame(i + 1, j - 1, piles, dp));\\n          // If Alice chooses j, Bob can choose i or j - 1.\\n          // If Bob chooses i, In the next round Alice can choose i + 1 or j - 1.\\n          // If Bob chooses j - 1, In the next round  Alice can choose i  or j -2. \\n          int sum2 =  piles[j] + Math.max(stoneGame(i, j - 2, piles, dp),stoneGame(i + 1, j - 1, piles, dp)) ;\\n          sum =  Math.max(sum1, sum2);\\n          dp[i][j] = sum; \\n       }\\n       return sum; \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public boolean stoneGame(int[] piles) {\\n       // Calculate total sum. \\n       int totalSum = Arrays.stream(piles).sum();\\n       int[][] dp = new int[piles.length][piles.length];\\n       for (int[] arr: dp) {\\n           Arrays.fill(arr, -1);\\n       } \\n       // We will try to maximize Alice Sum. \\n       int sum = stoneGame(0, piles.length - 1, piles, dp);\\n       // Subtract Alice Maximized Sum from total Sum to get Bob\\'s Sum and determine the result appropriately.\\n       return sum > (totalSum - sum) ? true : false;\\n    }\\n    \\n    public int stoneGame(int i, int j, int[] piles, int[][] dp) {\\n       int sum = 0;\\n       if (i < j) {\\n          if (dp[i][j] != -1) {\\n              return dp[i][j];\\n          }\\n          // If Alice chooses i, Bob can choose i + 1 or j.\\n          // If Bob chooses i + 1, In the next round Alice can choose i + 2 or j.\\n          // If Bob chooses j, In the next round  Alice can choose i + 1  or j -1.\\n          int sum1 =  piles[i] + Math.max(stoneGame(i + 2, j, piles, dp),stoneGame(i + 1, j - 1, piles, dp));\\n          // If Alice chooses j, Bob can choose i or j - 1.\\n          // If Bob chooses i, In the next round Alice can choose i + 1 or j - 1.\\n          // If Bob chooses j - 1, In the next round  Alice can choose i  or j -2. \\n          int sum2 =  piles[j] + Math.max(stoneGame(i, j - 2, piles, dp),stoneGame(i + 1, j - 1, piles, dp)) ;\\n          sum =  Math.max(sum1, sum2);\\n          dp[i][j] = sum; \\n       }\\n       return sum; \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986337,
                "title": "dp-recursive-c-explained-in-detail-with-commments",
                "content": "O(1) : return true. alice always wins\\nalice either picks only from even no oile, or odd no pile.\\nand for sure total stones in either even pile or odd pile  is greater than other bec total stones are odd.\\n\\nbut if total stones were not odd then what?\\nhence u should know how to do it with do also in generalised way.\\n\\n```\\nclass Solution {\\n    vector<int> piles;\\n   int  dp[501][501];\\n    \\npublic:\\n    bool stoneGame(vector<int>& p) {\\n        memset(dp,-1 , sizeof(dp));\\n        piles= p;\\n     int sum=0;\\n        for(auto x: piles)\\n            sum+=x;\\n        int alice = dfs(0, piles.size()-1);\\n        int bob = sum- alice;\\n        if( alice > bob)\\n            return true;\\n        else \\n            return false;\\n        \\n    }\\n    int dfs(int  l ,int r) // return the max that alcie can pick from array l,r\\n    {\\n        if( l > r) // array finished alice cant get anything from here\\n            return 0;\\n        if(dp[l][r] != -1)\\n            return dp[l][r] ;\\n        // given only even piles to start from\\n        // ots alice turn if no of piles are even\\n        int count = r-l+1;\\n        int turn =false;\\n        int left=0, right=0;\\n        if( count % 2 ==0)// alice turn\\n        {\\n            // pick from left\\n            left = piles[l] + dfs(l+1, r);\\n            right = piles[r] + dfs(l,r-1);\\n            return dp[l][r]= max(left, right); // return the best alice gets from l,r array\\n        }\\n        else // its bob turn. this chance wont contribute anything to  alice total picks\\n        {\\n            left=0 + dfs(l+1, r); // bob picks the leftmost. this chance contributed nothing to alice picks hence adding 0\\n            right = 0 + dfs(l, r-1); // bob picks the rightmost\\n            return dp[l][r]= min(left, right); // bob is playing hence he will do best that alice can pick as less stones as possible\\n            // note: used min func there\\n                        \\n        }\\n        return 0; // just for sake of returning \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    vector<int> piles;\\n   int  dp[501][501];\\n    \\npublic:\\n    bool stoneGame(vector<int>& p) {\\n        memset(dp,-1 , sizeof(dp));\\n        piles= p;\\n     int sum=0;\\n        for(auto x: piles)\\n            sum+=x;\\n        int alice = dfs(0, piles.size()-1);\\n        int bob = sum- alice;\\n        if( alice > bob)\\n            return true;\\n        else \\n            return false;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1956577,
                "title": "just-return-true",
                "content": "```java\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840662,
                "title": "runtime-3ms-intuitive-solution-easy-to-understand",
                "content": "The solution is simple, it is adding maximum piles from any side. \\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int i=0,j=piles.size()-1;\\n        long long int alice=0,bobs=0;\\n        while(i<j){\\n            if(piles[i]>piles[j]){\\n                alice+=piles[i];\\n                bobs+=piles[j];\\n            }\\n            else{\\n                bobs+=piles[i];\\n                alice+=piles[j];\\n            }\\n            i++;\\n            j--;\\n        }\\n        return alice>bobs;\\n    }\\n};\\n```\\n\\n**Upvote it, if you like the solution.**\\nIf you dislike the solution than please let me know the reason in comment section.",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int i=0,j=piles.size()-1;\\n        long long int alice=0,bobs=0;\\n        while(i<j){\\n            if(piles[i]>piles[j]){\\n                alice+=piles[i];\\n                bobs+=piles[j];\\n            }\\n            else{\\n                bobs+=piles[i];\\n                alice+=piles[j];\\n            }\\n            i++;\\n            j--;\\n        }\\n        return alice>bobs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801625,
                "title": "c-very-easy-recursive-memoization",
                "content": "\\tint dp[501][501];\\t\\n    int solve(vector<int> &arr,int i,int j){\\n        if(i>j) return 0;\\n        if(i==j){\\n            return dp[i][j]=arr[i];\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        return dp[i][j]=max(solve(arr,i+1,j)+arr[i],solve(arr,i,j-1)+arr[j]);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int sum=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<piles.size();i++) sum+=piles[i];\\n        int a=solve(piles,0,piles.size()-1);\\n        int b=sum-a;\\n        return a>b;\\n        \\n    }\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "\\tint dp[501][501];\\t\\n    int solve(vector<int> &arr,int i,int j){\\n        if(i>j) return 0;\\n        if(i==j){\\n            return dp[i][j]=arr[i];\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        return dp[i][j]=max(solve(arr,i+1,j)+arr[i],solve(arr,i,j-1)+arr[j]);\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int sum=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<piles.size();i++) sum+=piles[i];\\n        int a=solve(piles,0,piles.size()-1);\\n        int b=sum-a;\\n        return a>b;\\n        \\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1783310,
                "title": "100-faster-alice-always-wins-but-why-full-explanation-and-solution",
                "content": "We need to carefully assess the given conditions.\\n\\n**1)** **Even number of piles:** That means, each player will get equal number of piles. So basically, **the number of turns = the number of piles**.\\n**2)** **Total stones are odd:** The total stones in all the piles combined will always be odd. What does that signify? If you carefully observe, this means that a tie can never happen, since the distribution of stones cannot be evenly done. One will always have more stones than the other person.\\n\\n**What does the question ask us to do?**\\nThe question says, whether there exists a way in which alice wins. In easier words, out of all the possible combinations in which the game can be played, if there is even one possibility, where alice can win, then we need to return true.\\n\\nThere might be many possibilities of a single game, and in those possibilities, there can be many of the possibilities where alice wins. But  **what is the most optimal way in which we can push the game towards the direction where alice wins?**\\n\\nThis can happen in the case where, when it\\'s alice\\'s turn, she chooses the pile with maximum number of stones and when it\\'s bob\\'s turn, he chooses the index with the minimum number of stones. This way of playing can happen in every game. So now what can happen? Either both the people end up with same number of stones, or alice gets more stones since she always chose the maximum stones pile and bob chose the minimum stones pile.\\n\\nNow here comes the role of odd number of total stones. Since the total stones are odd, alice and bob can\\'t have equal number of stones. This leaves us with only one possibility:  **ALICE ALWAYS WINS!**\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        bool status = true;\\n        int i=0, j=n-1, alice=0, bob=0; // Keep two pointers, one at the start and one at the end\\n        while(n)\\n        {\\n            if(status)\\n            {\\n                status = false;\\n                if(piles[i]>piles[j])\\n                {\\n                    alice = alice + piles[i];\\n                    i++; // If we choose the first index, move the pointer forward\\n                }\\n                else\\n                {\\n                    alice = alice + piles[j];\\n                    j--; // If we choose the last index, move the pointer backwards\\n                }\\n            }\\n            else\\n            {\\n                status = true;\\n                if(piles[i]<piles[j])\\n                {\\n                    bob = bob + piles[i];\\n                    i++;// If we choose the first index, move the pointer forward\\n                }\\n                else\\n                {\\n                    bob = bob + piles[j];\\n                    j--;// If we choose the last index, move the pointer backwards\\n                }\\n            }\\n            n--;\\n        }\\n        if(alice>bob)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nSince we already know that Alice always wins, we can also **return true**, and the code works!\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n\\treturn true;\\n   }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        bool status = true;\\n        int i=0, j=n-1, alice=0, bob=0; // Keep two pointers, one at the start and one at the end\\n        while(n)\\n        {\\n            if(status)\\n            {\\n                status = false;\\n                if(piles[i]>piles[j])\\n                {\\n                    alice = alice + piles[i];\\n                    i++; // If we choose the first index, move the pointer forward\\n                }\\n                else\\n                {\\n                    alice = alice + piles[j];\\n                    j--; // If we choose the last index, move the pointer backwards\\n                }\\n            }\\n            else\\n            {\\n                status = true;\\n                if(piles[i]<piles[j])\\n                {\\n                    bob = bob + piles[i];\\n                    i++;// If we choose the first index, move the pointer forward\\n                }\\n                else\\n                {\\n                    bob = bob + piles[j];\\n                    j--;// If we choose the last index, move the pointer backwards\\n                }\\n            }\\n            n--;\\n        }\\n        if(alice>bob)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n\\treturn true;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708830,
                "title": "c-o-n-time-complexity-o-1-space-greedy-faster-than-100",
                "content": "The approach is simple . As Alice will always have the chance to choose the best one out because she will be the first one to start the game , therefore she will always win the game in every condition . So , you can direct return true if you want :-\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        \\n        return true ; \\n    }\\n};\\n```\\nNow if we talk about the approach , then we just need to compare the summation of the stones at even and odd indexes . \\nIf the summation of stones at even indexes is greater , then Alice will always pick the stones from even index after which Bob will only have the option to choose the best one out of both the left and right remaining odd indexes and vice versa . Hence , Alice wins everytime !\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size() ; \\n        if(n == 2) return true ; \\n        \\n        int even = 0 ; \\n        int odd = 0 ; \\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            if(i % 2 == 0)\\n            {\\n                even += piles[i] ; \\n            }\\n            else odd += piles[i] ; \\n        }\\n        int l = 0 ; \\n        int r = n-1 ; \\n        int s1 = 0 ; \\n        int s2 = 0 ; \\n        int turn = 0 ; \\n        if(even > odd)\\n        {\\n            while(l <= r)\\n            {\\n                if(turn == 0)\\n                {\\n                    if(l % 2 == 0) \\n                    {\\n                        s1 += piles[l] ; \\n                        l++ ; \\n                    }\\n                    else \\n                    {\\n                        s1 += piles[r] ; \\n                        r-- ; \\n                    }\\n                    turn = 1 ; \\n                }\\n                else\\n                {\\n                    if(piles[l] >= piles[r]) \\n                    {\\n                        s2 += piles[l] ; \\n                        l++ ; \\n                    }\\n                    else\\n                    {\\n                        s2 += piles[r] ; \\n                        r-- ; \\n                    }\\n                    turn = 0 ; \\n                }\\n            }\\n            if(s1 > s2) return true ; \\n            else return false ; \\n        }\\n        else\\n        {\\n            while(l <= r)\\n            {\\n                if(turn == 0)\\n                {\\n                    if(l % 2 != 0) \\n                    {\\n                        s1 += piles[l] ; \\n                        l++ ; \\n                    }\\n                    else \\n                    {\\n                        s1 += piles[r] ; \\n                        r-- ; \\n                    }\\n                    turn = 1 ; \\n                }\\n                else\\n                {\\n                    if(piles[l] >= piles[r]) \\n                    {\\n                        s2 += piles[l] ; \\n                        l++ ; \\n                    }\\n                    else\\n                    {\\n                        s2 += piles[r] ; \\n                        r-- ; \\n                    }\\n                    turn = 0 ; \\n                }\\n            }\\n            if(s1 > s2) return true ; \\n            else return false ; \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        \\n        return true ; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size() ; \\n        if(n == 2) return true ; \\n        \\n        int even = 0 ; \\n        int odd = 0 ; \\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            if(i % 2 == 0)\\n            {\\n                even += piles[i] ; \\n            }\\n            else odd += piles[i] ; \\n        }\\n        int l = 0 ; \\n        int r = n-1 ; \\n        int s1 = 0 ; \\n        int s2 = 0 ; \\n        int turn = 0 ; \\n        if(even > odd)\\n        {\\n            while(l <= r)\\n            {\\n                if(turn == 0)\\n                {\\n                    if(l % 2 == 0) \\n                    {\\n                        s1 += piles[l] ; \\n                        l++ ; \\n                    }\\n                    else \\n                    {\\n                        s1 += piles[r] ; \\n                        r-- ; \\n                    }\\n                    turn = 1 ; \\n                }\\n                else\\n                {\\n                    if(piles[l] >= piles[r]) \\n                    {\\n                        s2 += piles[l] ; \\n                        l++ ; \\n                    }\\n                    else\\n                    {\\n                        s2 += piles[r] ; \\n                        r-- ; \\n                    }\\n                    turn = 0 ; \\n                }\\n            }\\n            if(s1 > s2) return true ; \\n            else return false ; \\n        }\\n        else\\n        {\\n            while(l <= r)\\n            {\\n                if(turn == 0)\\n                {\\n                    if(l % 2 != 0) \\n                    {\\n                        s1 += piles[l] ; \\n                        l++ ; \\n                    }\\n                    else \\n                    {\\n                        s1 += piles[r] ; \\n                        r-- ; \\n                    }\\n                    turn = 1 ; \\n                }\\n                else\\n                {\\n                    if(piles[l] >= piles[r]) \\n                    {\\n                        s2 += piles[l] ; \\n                        l++ ; \\n                    }\\n                    else\\n                    {\\n                        s2 += piles[r] ; \\n                        r-- ; \\n                    }\\n                    turn = 0 ; \\n                }\\n            }\\n            if(s1 > s2) return true ; \\n            else return false ; \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601337,
                "title": "one-line-code-simple-logic-question-based-answer-no-dpp-no-recursion",
                "content": "```\\n TRY TO UNDERSTAND THIS PART OF LINE AND THINK IN A DIFFERENT WAY :: AT THE FIRST I THOUGHT WE NEED TO DO SO MUCH STUFF BUT WHEN I READ THE QUESTION CAREFULLY \\n AND TRIED TO UNDERSTAND THIS THEY SAID THEY ARE PLAYING OPTIMALLY THAT MEANS !\\n\\n ALEX IS TRYING HIS BEST TO WIN HIS GAME AND SIMILARY BOB IS ALSO TRYING HIS BEST TO WIN THIS GAME SO WE CAN SAY EASILY EVERY TIME ALEX TRIES HIS BEST TO WIN THIS GAME \\n \\n AND I THINK MY APPROACH IS DIFFERENT FROM OTHERS FROM OTHER CODERS BUT AS OURSELVES TRY TO THINK THAT WHEN WE PLAY GAME WHY WE WILL CHOOSE WRONG STEP TO  LOOSE OURSELVES SO THINK DIFFERENT BE THE ONE \\n \\n THIS SIDE MOHIT\\n Happy Coding !!!\\n \\nAssuming Alice and Bob play optimally, return true if Alice wins the game, or false if Bob wins.\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) \\n    {\\n        return true;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n TRY TO UNDERSTAND THIS PART OF LINE AND THINK IN A DIFFERENT WAY :: AT THE FIRST I THOUGHT WE NEED TO DO SO MUCH STUFF BUT WHEN I READ THE QUESTION CAREFULLY \\n AND TRIED TO UNDERSTAND THIS THEY SAID THEY ARE PLAYING OPTIMALLY THAT MEANS !\\n\\n ALEX IS TRYING HIS BEST TO WIN HIS GAME AND SIMILARY BOB IS ALSO TRYING HIS BEST TO WIN THIS GAME SO WE CAN SAY EASILY EVERY TIME ALEX TRIES HIS BEST TO WIN THIS GAME \\n \\n AND I THINK MY APPROACH IS DIFFERENT FROM OTHERS FROM OTHER CODERS BUT AS OURSELVES TRY TO THINK THAT WHEN WE PLAY GAME WHY WE WILL CHOOSE WRONG STEP TO  LOOSE OURSELVES SO THINK DIFFERENT BE THE ONE \\n \\n THIS SIDE MOHIT\\n Happy Coding !!!\\n \\nAssuming Alice and Bob play optimally, return true if Alice wins the game, or false if Bob wins.\\n```\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) \\n    {\\n        return true;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543215,
                "title": "c-very-easy-approach-using-memoization",
                "content": "```\\nclass Solution {\\n    int dp[501][501];\\n    int game(int i,int j,vector<int> &piles){\\n        if(i+1==j) return max(piles[i],piles[j]);\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int choosefromfirst = piles[i] + min(game(i+1,j-1,piles),game(i+2,j,piles));\\n        int choosefromlast = piles[j] + min(game(i+1,j-1,piles),game(i,j-2,piles));\\n        return dp[i][j] = max(choosefromfirst,choosefromlast);\\n    }\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        int totalsum = accumulate(piles.begin(),piles.end(),0);\\n        int aliceres = game(0,piles.size()-1,piles);\\n        return (totalsum-aliceres < aliceres);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    int dp[501][501];\\n    int game(int i,int j,vector<int> &piles){\\n        if(i+1==j) return max(piles[i],piles[j]);\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int choosefromfirst = piles[i] + min(game(i+1,j-1,piles),game(i+2,j,piles));\\n        int choosefromlast = piles[j] + min(game(i+1,j-1,piles),game(i,j-2,piles));\\n        return dp[i][j] = max(choosefromfirst,choosefromlast);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1484895,
                "title": "explaining-my-dp-approach-c-32-ms",
                "content": "In this problem we not only have to think about maximizing our score, but we should in a way also think about somehow minimzing the opponent\\'s score. At the end of the game, I do not want to end up maximizing my score, but my primary goal is just to have a score greater than my opponent that\\'s it.\\n\\nSo as mentioned I could pick up from the begining or the end. \\n\\nThe most fundamental subproblem that we could think of is ranges or segment of arrays.  It is because the problem kind of gives us a sense that we are wanting to shorten our range each time.\\n\\nSo why not build up  upon a solution, based on the lenght of ranges. \\n\\nLet dp(i) (j) represent Alice\\'s total score at the end of the game, if we were given the array [i....j] and not the entire array.\\n\\nSo dp(i)(i) ---> would represent the answer for all 1 length subarrays, \\n\\ndp(i) (i) , for all i E [0,n-1] = piles[i] \\nbecause if we only had one element so Alice would have picked it.\\n\\ndp(i) (i+1), for all i E [ 0, n-2] = max(piles[i], piles[i+1] )\\n\\nbecause if we only had two elements ,Alice would have picked the maximum out of the two.\\n\\n\\t\\nLet\\'s say Alice is doing a critical choice --> he has two choices,  pick the element at the beginging from the range that is availabe to him, or pick the element at the end.\\n\\nNow, his opponent also might have gone through this critical choice isn\\'t it.\\n\\nThough we are considering the fact Alice starts the game, but then in the middle of any general kth turn ,where k>=1,\\nk here represents the number of times Alice has picked up an element till now. \\nStill, we can say Alice would get a chance after Bob has picked up, because it\\'s a cyclic turnwise game that\\'s happening.\\n\\nWhen Bob was doing his picking he might have thought two things, I should give Alice a decision segment from where Alice should somehow be able to form minimum total sum, and then also I should pick a number that benefits me also.\\n\\nSo via. all the above talking we can write a dp equation like-->\\n\\nif Alice is choosing piles(i) for this current turn, then Bob might have given him min (dp(i+1 ) ( j-1 ) , dp (i+2 ) (j ) );\\nif Alice is choosing piles (j) for this current turn, then Bob might have given him min( dp(i+1) (j-1), dp(i) (j-2) );\\n\\ncase 1= piles (i )  + min( dp(i+1) (j-1) , dp(i+2 ) (j) )\\n\\ncase 2 = piles (j )  + min ( dp(i+1 ) (j-1) , dp(i) (j-2) );\\n\\nthus dp (i ) (j) = max ( case 1 , case 2);\\n\\nAnswer = dp(0) (n-1);\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        \\n        \\n        int n=piles.size();\\n        \\n        int dp[n][n];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i][i]=piles[i];\\n        }\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            dp[i][i+1]= max(piles[i],piles[i+1]);\\n        }\\n        \\n        for(int len=3;len<=n;len++)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                int j= len + i -1;\\n                \\n                if(i>=j || j>=n || i>=n) continue;\\n                \\n                int op1= piles[i] + min({ dp[i+1][j-1], dp[i+2][j]});\\n                \\n                int op2= piles[j] + min({dp[i+1][j-1], dp[i][j-2]});\\n                \\n                dp[i][j]= max(op1,op2);\\n                \\n            }\\n        }\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<n;i++) sum+=piles[i];\\n        \\n        int alice_score= dp[0][n-1];\\n        \\n        int bob_score= sum- alice_score;\\n        \\n        // cout<<alice_score;\\n        \\n        \\n        return alice_score>=bob_score;\\n       \\n        \\n      \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        \\n        \\n        int n=piles.size();\\n        \\n        int dp[n][n];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i][i]=piles[i];\\n        }\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            dp[i][i+1]= max(piles[i],piles[i+1]);\\n        }\\n        \\n        for(int len=3;len<=n;len++)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                int j= len + i -1;\\n                \\n                if(i>=j || j>=n || i>=n) continue;\\n                \\n                int op1= piles[i] + min({ dp[i+1][j-1], dp[i+2][j]});\\n                \\n                int op2= piles[j] + min({dp[i+1][j-1], dp[i][j-2]});\\n                \\n                dp[i][j]= max(op1,op2);\\n                \\n            }\\n        }\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<n;i++) sum+=piles[i];\\n        \\n        int alice_score= dp[0][n-1];\\n        \\n        int bob_score= sum- alice_score;\\n        \\n        // cout<<alice_score;\\n        \\n        \\n        return alice_score>=bob_score;\\n       \\n        \\n      \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1386181,
                "title": "stone-game-solution-java",
                "content": "```\\npublic boolean stoneGame(int[] piles) {\\n        int n = piles.length;\\n        int sumAlex=0;\\n        int sumLee = 0;\\n        Arrays.sort(piles);\\n        for(int i=0;i<n;i++){     \\n            if(i%2==0){\\n                sumLee += piles[i];\\n            } \\n            else{\\n                sumAlex += piles[i];\\n            }\\n            \\n        }\\n        if(sumAlex>sumLee){\\n            return true;\\n        }\\n        else{\\n         return false;   \\n        }\\n        \\n        \\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean stoneGame(int[] piles) {\\n        int n = piles.length;\\n        int sumAlex=0;\\n        int sumLee = 0;\\n        Arrays.sort(piles);\\n        for(int i=0;i<n;i++){     \\n            if(i%2==0){\\n                sumLee += piles[i];\\n            } \\n            else{\\n                sumAlex += piles[i];\\n            }\\n            \\n        }\\n        if(sumAlex>sumLee){\\n            return true;\\n        }\\n        else{\\n         return false;   \\n        }\\n        \\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1385464,
                "title": "c-easy-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int> &piles, int left, int right, vector<vector<int>> &dp) {\\n        if(left >= right) {\\n            return 0;\\n        }\\n        \\n        if(dp[left][right] != -1) return dp[left][right]; \\n        \\n        // if alex chose left\\n        // than lee can choose either left + 1 or right\\n        // so Alex next can either be from left+2 or right-1 (we are taking min because both players are playing optimally so ofcourse lee is going to choose the max one and we are going to get the min one);\\n        int choose_left = piles[left] + min(helper(piles, left+2, right, dp), helper(piles, left, right-1, dp));\\n        \\n        // if alex choose right\\n        // than lee can choose left or right-1\\n        // so Alez next can start from left + 1 or right-2 (taking min same reason as above) \\n        int choose_right = piles[right] + min(helper(piles, left, right-2, dp), helper(piles, left+1, right, dp));\\n            \\n        // we have to get max we can get by wither choosing left or right\\n        return dp[left][right] = max(choose_left, choose_right);\\n    }\\n    \\n    \\n    \\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        int sum = accumulate(piles.begin(), piles.end(), 0);\\n        return helper(piles, 0, n - 1, dp) > sum/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int> &piles, int left, int right, vector<vector<int>> &dp) {\\n        if(left >= right) {\\n            return 0;\\n        }\\n        \\n        if(dp[left][right] != -1) return dp[left][right]; \\n        \\n        // if alex chose left\\n        // than lee can choose either left + 1 or right\\n        // so Alex next can either be from left+2 or right-1 (we are taking min because both players are playing optimally so ofcourse lee is going to choose the max one and we are going to get the min one);\\n        int choose_left = piles[left] + min(helper(piles, left+2, right, dp), helper(piles, left, right-1, dp));\\n        \\n        // if alex choose right\\n        // than lee can choose left or right-1\\n        // so Alez next can start from left + 1 or right-2 (taking min same reason as above) \\n        int choose_right = piles[right] + min(helper(piles, left, right-2, dp), helper(piles, left+1, right, dp));\\n            \\n        // we have to get max we can get by wither choosing left or right\\n        return dp[left][right] = max(choose_left, choose_right);\\n    }\\n    \\n    \\n    \\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        int sum = accumulate(piles.begin(), piles.end(), 0);\\n        return helper(piles, 0, n - 1, dp) > sum/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385158,
                "title": "java-solution",
                "content": "Alice will always win the game as they are playing optimally to  win the game, so, there is no chance that Lee can win the game, so we can simply return true, other solution can be we can solve it using dp, dp solution is posted in stone VII problem\\n```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385137,
                "title": "java-easy-dp-tabulation-gap-strategy",
                "content": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n         int n = piles.length;\\n         int dp[][] = new int[n][n];\\n         for(int g = 0 ; g < n;g++){\\n           for(int i = 0,j = g;j < n ;i++,j ++){\\n             if(g == 0){\\n               dp[i][j] = piles[i];\\n             }\\n             else if(g == 1){\\n               dp[i][j] = Math.max(piles[i],piles[j]);\\n             }\\n             else{\\n               int val1 = piles[i] + Math.min(dp[i + 2][j],dp[i + 1][j - 1]);\\n               int val2 = piles[j] + Math.min(dp[i + 1][j - 1],dp[i][j - 2]);\\n               dp[i][j] = Math.max(val1,val2);\\n             }\\n           }\\n         }\\n      int Asum = 0;\\n      for(int val : piles){\\n        Asum += val;\\n      }\\n      int Alex = dp[0][n - 1];\\n      int Lee = Asum - Alex;\\n      if(Alex  > Lee) return true;\\n      return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n         int n = piles.length;\\n         int dp[][] = new int[n][n];\\n         for(int g = 0 ; g < n;g++){\\n           for(int i = 0,j = g;j < n ;i++,j ++){\\n             if(g == 0){\\n               dp[i][j] = piles[i];\\n             }\\n             else if(g == 1){\\n               dp[i][j] = Math.max(piles[i],piles[j]);\\n             }\\n             else{\\n               int val1 = piles[i] + Math.min(dp[i + 2][j],dp[i + 1][j - 1]);\\n               int val2 = piles[j] + Math.min(dp[i + 1][j - 1],dp[i][j - 2]);\\n               dp[i][j] = Math.max(val1,val2);\\n             }\\n           }\\n         }\\n      int Asum = 0;\\n      for(int val : piles){\\n        Asum += val;\\n      }\\n      int Alex = dp[0][n - 1];\\n      int Lee = Asum - Alex;\\n      if(Alex  > Lee) return true;\\n      return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384502,
                "title": "c-explained-solution",
                "content": "The sum of the piles in the odd indices can never be equal to the sum of the even indices, because the total number of stones is odd, so there are no ties.\\nSo Alex can choose to take all the piles in the even indices or all the piles in the odd indices, therefore he always can win.\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279947,
                "title": "c-solution-with-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>& p,int i,int n,int f,vector<vector<int>> &dp)\\n    {\\n        if(i>n)\\n            return(0);\\n        if(dp[i][n]!=-1)\\n            return(dp[i][n]);\\n        if(f==0)\\n        return(dp[i][n]=max(p[i]+check(p,i+1,n,1,dp),p[n]+check(p,i,n-1,1,dp)));\\n     return(dp[i][n]=max(check(p,i+1,n,0,dp),check(p,i,n-1,0,dp)));\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        int s=check(piles,0,n-1,0,dp);\\n        return(accumulate(piles.begin(),piles.end(),0)-s<s);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>& p,int i,int n,int f,vector<vector<int>> &dp)\\n    {\\n        if(i>n)\\n            return(0);\\n        if(dp[i][n]!=-1)\\n            return(dp[i][n]);\\n        if(f==0)\\n        return(dp[i][n]=max(p[i]+check(p,i+1,n,1,dp),p[n]+check(p,i,n-1,1,dp)));\\n     return(dp[i][n]=max(check(p,i+1,n,0,dp),check(p,i,n-1,0,dp)));\\n    }\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        int s=check(piles,0,n-1,0,dp);\\n        return(accumulate(piles.begin(),piles.end(),0)-s<s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266484,
                "title": "stone-game-simple-2-pointer-approach-solution",
                "content": "/*class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        int a = 0 ;\\n        int f = 0 , l = n - 1;\\n        while(f <= l){\\n            if(f <= l && piles[f] >= piles[l]){\\n                a += piles[f];\\n                f++;\\n                if(f <=l && piles[f] >= piles[l]){\\n                    l--;\\n                }\\n                else f++;\\n            }\\n            else{\\n                a += piles[l];\\n                l--;\\n                if(f <=l && piles[f] >= piles[l]){\\n                    l--;\\n                }\\n                else f++;\\n            }\\n        }\\n        int sum = 0;\\n        for(int i : piles){\\n            sum += i;\\n        }\\n        if(a > sum - a) return true;\\n        else return false;\\n    }\\n};*/",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        int a = 0 ;\\n        int f = 0 , l = n - 1;\\n        while(f <= l){\\n            if(f <= l && piles[f] >= piles[l]){\\n                a += piles[f];\\n                f++;\\n                if(f <=l && piles[f] >= piles[l]){\\n                    l--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1266200,
                "title": "java-100-faster-easy-2-pointer-solution-for-stone-game",
                "content": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        \\n        int i=0, j=piles.length-1; // two pointers\\n        int turnofalex = 1, turnoflee = 0;\\n        int sumx=0, sumy=0; // sumx is Alex\\'s score, sumy is lee\\'s score\\n        \\n        while(i<j)\\n        {\\n            if(turnofalex==1) // alex\\'s turn, score should be max\\n            {\\n                if((piles[i]+piles[j-1]) >= (piles[i+1]+piles[j])) \\n                {\\n                    sumx = sumx+piles[i]+piles[j-1];\\n                    i++;\\n                    turnofalex = 0;\\n                    turnoflee = 1;\\n                }       \\n                else\\n                {\\n                    sumx = sumx+piles[i+1]+piles[j];\\n                    j--;\\n                    turnofalex = 0;\\n                    turnoflee = 1;                    \\n                }\\n            }\\n            else // lee\\'s turn, score should be min\\n            {\\n                if((piles[i]+piles[j-1]) < (piles[i+1]+piles[j])) \\n                {\\n                    sumy+=piles[i]+piles[j-1];\\n                    i++;\\n                    turnofalex = 1;\\n                    turnoflee = 0;                    \\n                }       \\n                else\\n                {\\n                    sumy+=piles[i+1]+piles[j];\\n                    j--;\\n                    turnofalex = 1;\\n                    turnoflee = 0;                    \\n                }\\n            }\\n            if(i==j)\\n                break;\\n        }\\n        \\n        if(sumx>sumy)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        \\n        int i=0, j=piles.length-1; // two pointers\\n        int turnofalex = 1, turnoflee = 0;\\n        int sumx=0, sumy=0; // sumx is Alex\\'s score, sumy is lee\\'s score\\n        \\n        while(i<j)\\n        {\\n            if(turnofalex==1) // alex\\'s turn, score should be max\\n            {\\n                if((piles[i]+piles[j-1]) >= (piles[i+1]+piles[j])) \\n                {\\n                    sumx = sumx+piles[i]+piles[j-1];\\n                    i++;\\n                    turnofalex = 0;\\n                    turnoflee = 1;\\n                }       \\n                else\\n                {\\n                    sumx = sumx+piles[i+1]+piles[j];\\n                    j--;\\n                    turnofalex = 0;\\n                    turnoflee = 1;                    \\n                }\\n            }\\n            else // lee\\'s turn, score should be min\\n            {\\n                if((piles[i]+piles[j-1]) < (piles[i+1]+piles[j])) \\n                {\\n                    sumy+=piles[i]+piles[j-1];\\n                    i++;\\n                    turnofalex = 1;\\n                    turnoflee = 0;                    \\n                }       \\n                else\\n                {\\n                    sumy+=piles[i+1]+piles[j];\\n                    j--;\\n                    turnofalex = 1;\\n                    turnoflee = 0;                    \\n                }\\n            }\\n            if(i==j)\\n                break;\\n        }\\n        \\n        if(sumx>sumy)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259023,
                "title": "my-simple-c-solution-faster-than-100-simple-greedy-soln-works-here",
                "content": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        \\n        int alex=0;\\n        int lee=0;\\n        int i=0,j=piles.size()-1;\\n        while(i<j)\\n        {\\n            int x=piles[i];\\n            int y=piles[j];\\n            if(x>=y)\\n            {\\n                alex+=x;  \\n                lee+=y;\\n            }\\n            else\\n            {\\n                alex+=y;\\n                lee+=x;\\n            }\\n            i++;\\n            j--;\\n        }\\n        if(alex>lee) return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        \\n        int alex=0;\\n        int lee=0;\\n        int i=0,j=piles.size()-1;\\n        while(i<j)\\n        {\\n            int x=piles[i];\\n            int y=piles[j];\\n            if(x>=y)\\n            {\\n                alex+=x;  \\n                lee+=y;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1255018,
                "title": "c-dynamic-programming-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<vector<int>> dpAlex(n, vector<int>(n, 0));\\n        vector<vector<int>> dpLee(n, vector<int>(n, 0));\\n        \\n        \\n        dpAlex[n-1][n-1] = piles[n-1];\\n        dpLee[n-1][n-1] = -piles[n-1];\\n        \\n        dpAlex[0][0] = piles[0];\\n        \\n        dpLee[0][0] = -piles[0];\\n        //B to T\\n        //L to R\\n        //only the upper triangular matrix\\n        \\n        for(int i = n-2; i>=0;i--){\\n            for(int j =i; j<n ; j++){\\n                if(i == 0 && j == 0){\\n                    continue;\\n                }\\n                dpAlex[i][j] = max(piles[i] + dpLee[i+1][j], piles[j] + dpLee[i][j-1]);\\n                dpLee[i][j] = min(-piles[i] + dpAlex[i+1][j], -piles[j] + dpAlex[i][j-1]);\\n            }\\n        }\\n        return dpAlex[0][n-1] > 0? true: false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size();\\n        vector<vector<int>> dpAlex(n, vector<int>(n, 0));\\n        vector<vector<int>> dpLee(n, vector<int>(n, 0));\\n        \\n        \\n        dpAlex[n-1][n-1] = piles[n-1];\\n        dpLee[n-1][n-1] = -piles[n-1];\\n        \\n        dpAlex[0][0] = piles[0];\\n        \\n        dpLee[0][0] = -piles[0];\\n        //B to T\\n        //L to R\\n        //only the upper triangular matrix\\n        \\n        for(int i = n-2; i>=0;i--){\\n            for(int j =i; j<n ; j++){\\n                if(i == 0 && j == 0){\\n                    continue;\\n                }\\n                dpAlex[i][j] = max(piles[i] + dpLee[i+1][j], piles[j] + dpLee[i][j-1]);\\n                dpLee[i][j] = min(-piles[i] + dpAlex[i+1][j], -piles[j] + dpAlex[i][j-1]);\\n            }\\n        }\\n        return dpAlex[0][n-1] > 0? true: false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253004,
                "title": "1-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) \\n    {\\n        return true;\\n    }\\n};\\n```\\n\\nALEX ALWAYS WINS\\n\\nSince the total sum is odd it means either the sum of all odd elements is greater than even elements or vice versa.\\nAlex can always select in a way that ensures he get all alternating piles\\nIf he starts from the 1st pile he can get all piles at odd place.\\nIf he starts from the last pile he can get all piles at even places\\n\\nSo depending on which is more he will start from beginning or end and win.\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) \\n    {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208279,
                "title": "stone-game-recurstion-python",
                "content": "#### Python solution  using recursion \\n\\n            \\n            def abhi(s,e):\\n\\t\\t\\t\\tif s==e:\\n\\t\\t\\t\\t\\treturn piles[s]\\n\\t\\t\\t\\telif e==s+1:\\n\\t\\t\\t\\t\\treturn max(piles[s],piles[e])\\n            \\n\\t\\t\\t\\telif dp[s][e]!= -1:\\n\\t\\t\\t\\t\\treturn dp[s][e]\\n            \\n\\t\\t\\t\\tdp[s][e] =max( piles[s]+min(  abhi(s+2,e), abhi(s+1,e-1)) , piles[e]+min(abhi(s+1,e-1), abhi(s,e-2))   )\\n            \\n\\t\\t\\t\\treturn dp[s][e]\\n        \\n        dp=[ [-1 for i in range(len(piles)+1) ]  for j in range(len(piles)+1)] \\n        a= abhi(0,len(piles)-1)\\n        b=sum(piles)\\n        \\n        return a>a-b\\n\\t\\t\\n\\t\\thowever if both player are playing optimally you can just return True becaus alice will always win if they do the best so whoever starts the game will win.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "#### Python solution  using recursion \\n\\n            \\n            def abhi(s,e):\\n\\t\\t\\t\\tif s==e:\\n\\t\\t\\t\\t\\treturn piles[s]\\n\\t\\t\\t\\telif e==s+1:\\n\\t\\t\\t\\t\\treturn max(piles[s],piles[e])\\n            \\n\\t\\t\\t\\telif dp[s][e]!= -1:\\n\\t\\t\\t\\t\\treturn dp[s][e]\\n            \\n\\t\\t\\t\\tdp[s][e] =max( piles[s]+min(  abhi(s+2,e), abhi(s+1,e-1)) , piles[e]+min(abhi(s+1,e-1), abhi(s,e-2))   )\\n            \\n\\t\\t\\t\\treturn dp[s][e]\\n        \\n        dp=[ [-1 for i in range(len(piles)+1) ]  for j in range(len(piles)+1)] \\n        a= abhi(0,len(piles)-1)\\n        b=sum(piles)\\n        \\n        return a>a-b\\n\\t\\t\\n\\t\\thowever if both player are playing optimally you can just return True becaus alice will always win if they do the best so whoever starts the game will win.",
                "codeTag": "Python3"
            },
            {
                "id": 1196323,
                "title": "c-dp-memozized-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int recurs(vector<int>& arr,int start,int end)\\n    {\\n        if(start>=end)\\n        {\\n            return 0;\\n        }\\n        \\n        if(dp[start][end]!=0)\\n        {\\n            return dp[start][end];\\n        }\\n        \\nreturn dp[start][end]=max(max(arr[start]+recurs(arr,start+2,end),arr[start]+recurs(arr,start+1,end-1)),max(arr[end]+recurs(arr,start,end-2),arr[end]+recurs(arr,start+1,end-1)));\\n        \\n        \\n    }\\n        \\n        \\n    \\n    \\n    \\n    \\n    \\n    bool stoneGame(vector<int>& piles) {\\n        \\n    int sum=0;\\n    \\n        for(int i=0;i<piles.size();i++)\\n        {\\n            sum+=piles[i];\\n        }\\n        \\n        int k=recurs(piles,0,piles.size()-1);\\n        cout<<k;\\n        if(sum-k<k)\\n        {\\n            return 1;\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int recurs(vector<int>& arr,int start,int end)\\n    {\\n        if(start>=end)\\n        {\\n            return 0;\\n        }\\n        \\n        if(dp[start][end]!=0)\\n        {\\n            return dp[start][end];\\n        }\\n        \\nreturn dp[start][end]=max(max(arr[start]+recurs(arr,start+2,end),arr[start]+recurs(arr,start+1,end-1)),max(arr[end]+recurs(arr,start,end-2),arr[end]+recurs(arr,start+1,end-1)));\\n        \\n        \\n    }\\n        \\n        \\n    \\n    \\n    \\n    \\n    \\n    bool stoneGame(vector<int>& piles) {\\n        \\n    int sum=0;\\n    \\n        for(int i=0;i<piles.size();i++)\\n        {\\n            sum+=piles[i];\\n        }\\n        \\n        int k=recurs(piles,0,piles.size()-1);\\n        cout<<k;\\n        if(sum-k<k)\\n        {\\n            return 1;\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1158606,
                "title": "python3-solution-without-dp-beats-99-8-solutions",
                "content": "Simple Python3 solution without Dynamic Programming. \\nConsidering that both the players only take optimal decisions so, to make the choices element the player will look at not only the max element they can choose but also if the other element that they encounter won\\'t be too less that it overturns the advantage gained by choosing current element.\\nHere is an example that explains my thoughts:\\nSuppose the given array is [3,7,5,3] and alex gets to choose the first element, \\n1. Now if Alex picks the 3 at start then the remaining array will be [7,5,3].\\n2. Now comes Lee, Lee will obviously choose the initial 7, the array will now be [5,3].\\n3. Now Alex will choose 5 and Lee will go with 3, causing the victory of Lee.\\n4. Now everything about this makes sense except for the blatant fact the Alex\\'s choice wasn\\'t optimal, if he would have known what\\'s the next element would would be then he would have chosen the 3 at last(not the 3 at begining).\\n5. As by choosing the 3 at last he leaves Lee with array [3,7,5]. \\n6. So the logic we can formulate here is that if Alex chooses first elements then he leaves Lee with the choice of choosing from 2nd element and last element, whereas if Alex chooses Last elements then he leaves Lee with 1st element and 2nd last element.\\n7. For the choice to be optimal Alex need to choose the max of (sum of 1st and 2nd last element, sum of 2nd element and last element).\\n8. Here is the python code for this analysis.\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        alex=0\\n        \\n        while(piles):\\n            alex+=abs(piles[0]+piles[-2] - piles[-1]+piles[1])\\n            piles=piles[2:-2]\\n            \\n        if alex>0:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        alex=0\\n        \\n        while(piles):\\n            alex+=abs(piles[0]+piles[-2] - piles[-1]+piles[1])\\n            piles=piles[2:-2]\\n            \\n        if alex>0:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972898,
                "title": "java-short-and-crisp-dfs-memoization-5-lines-dp-with-detailed-explanation",
                "content": "**DFS+Memoization** \\n Here as both players play optimally and as they will be switching,so at every instance we try to find maximum possible score and **add** it to score if it is Player1 or **subtract** if it is Player2.\\n **ALGO:**\\n**->** At each chance we  pick maximum stones by selecting from start or from end and passing it to next player.**Note**: if only one stone left,then you have no other way but to pick it and game over.\\n**->** DFS will be called even no.of times for Player1 and odd no.of times for Player2,So value of picked stone will get added for Player1 and subtracted for Player2. \\n**->** By doing this we are essentially finding difference of maximum scores of both players.\\nIf Difference of max scores of Player1 & 2 > ZERO, return TRUE. Else FALSE.\\n**Example:**\\n [1,2,3,4]\\n1-dfs([2,3,4])\\n .......1-(2-dfs(3,4))\\n ..............1-(2-(3-dfs(4)))\\n ....................1-(2-(3-(4)))=1-2+3-4=**score_P1(1+3)** - **score_P2(2+4)**=-2\\nSimilarly at each step we will get two chances to pick from start /  end and then we add stone_value if it is Player1 or subtract if it is Player2.\\n \\n```\\nclass Solution {\\n    HashMap<String,Integer> map=new HashMap();\\n    public boolean stoneGame(int[] piles) {\\n        return dfs(piles,0,piles.length-1)>0;\\n    }\\n    private int dfs(int[] piles,int start,int end){\\n        //Only one stone left\\n        if(start==end)return piles[start];\\n        String key=start+\" \"+end;\\n        if(map.containsKey(key)) return map.get(key);\\n\\t\\t/*Choose the better option,either picking from start or end*/\\n        int val = Math.max(piles[start]-dfs(piles,start+1,end),\\n                          piles[end]-dfs(piles,start,end-1));\\n        map.put(key,val);\\n        return val;\\n    }\\n}\\n```\\n**DP**\\nWe pre-caluculate all possibiites from length of window=1(only one stone), then try to find answers for increasing windows (from 2 to piles.length).\\n```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        int n=piles.length;\\n        if(n==1) return true;\\n        Pair[][] memo=new Pair[n][n];\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++){\\n                memo[i][j]=new Pair();\\n\\t\\t\\t\\t/*If only one stone left,then current player picks it \\n\\t\\t\\t\\tand other player wont get any.GAME OVER.*/\\n                if(i==j) memo[i][j].first=piles[i];\\n            }\\n        }\\n        for(int len=2;len<=n;len++){\\n            for(int start=0,end=start+len-1;end<n;start++,end++){\\n\\t\\t\\t/*Choose the better option,either picking from start or end.\\n\\t\\t\\tAs players alternately select,if a current player selects now then he will become\\n\\t\\t\\tsecond player to choose from remaining stones.*/\\n                if(piles[start]+memo[start+1][end].second>piles[end]+memo[start][end-1].second){\\n                    memo[start][end].first=piles[start]+memo[start+1][end].second;\\n                    memo[start][end].second=memo[start+1][end].first;\\n                }\\n                else{\\n                    memo[start][end].first=piles[end]+memo[start][end-1].second;\\n                    memo[start][end].second=memo[start][end-1].first;\\n                }\\n            }\\n        }\\n        return memo[0][n-1].first>memo[0][n-1].second;\\n    }\\n}\\nclass Pair{\\n    int first=0,second=0;\\n    public String toString(){\\n        return first+\" \"+second;\\n    }\\n}\\n```\\nSimilar questions\\n**Stones_Game4:**\\nhttps://leetcode.com/problems/stone-game-iv/discuss/974415/Java-5-lines-of-code-or-3-Approaches-or-DFS%2BMemoization-or-DP-or-with-explanation.\\n**Stones_Game3:**\\nhttps://leetcode.com/problems/stone-game-iii/discuss/974109/Java-5-lines-of-code-or-*-DP-O(N)-TimeO(1)-Space-*-or-DFS%2BMemoization\\n**Stone_Game2:**\\nhttps://leetcode.com/problems/stone-game-ii/discuss/973053/Java-short-and-crisp-or-DFS%2BMemoization-or-with-intuition",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    HashMap<String,Integer> map=new HashMap();\\n    public boolean stoneGame(int[] piles) {\\n        return dfs(piles,0,piles.length-1)>0;\\n    }\\n    private int dfs(int[] piles,int start,int end){\\n        //Only one stone left\\n        if(start==end)return piles[start];\\n        String key=start+\" \"+end;\\n        if(map.containsKey(key)) return map.get(key);\\n\\t\\t/*Choose the better option,either picking from start or end*/\\n        int val = Math.max(piles[start]-dfs(piles,start+1,end),\\n                          piles[end]-dfs(piles,start,end-1));\\n        map.put(key,val);\\n        return val;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        int n=piles.length;\\n        if(n==1) return true;\\n        Pair[][] memo=new Pair[n][n];\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++){\\n                memo[i][j]=new Pair();\\n\\t\\t\\t\\t/*If only one stone left,then current player picks it \\n\\t\\t\\t\\tand other player wont get any.GAME OVER.*/\\n                if(i==j) memo[i][j].first=piles[i];\\n            }\\n        }\\n        for(int len=2;len<=n;len++){\\n            for(int start=0,end=start+len-1;end<n;start++,end++){\\n\\t\\t\\t/*Choose the better option,either picking from start or end.\\n\\t\\t\\tAs players alternately select,if a current player selects now then he will become\\n\\t\\t\\tsecond player to choose from remaining stones.*/\\n                if(piles[start]+memo[start+1][end].second>piles[end]+memo[start][end-1].second){\\n                    memo[start][end].first=piles[start]+memo[start+1][end].second;\\n                    memo[start][end].second=memo[start+1][end].first;\\n                }\\n                else{\\n                    memo[start][end].first=piles[end]+memo[start][end-1].second;\\n                    memo[start][end].second=memo[start][end-1].first;\\n                }\\n            }\\n        }\\n        return memo[0][n-1].first>memo[0][n-1].second;\\n    }\\n}\\nclass Pair{\\n    int first=0,second=0;\\n    public String toString(){\\n        return first+\" \"+second;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957282,
                "title": "python-o-n-iteration-solution-no-need-dp-or-math",
                "content": "DP too complex\\nMath too tricky\\n\\nI think the purpose of this question is only looking for a simple iteration solution.\\n\\n```\\n        def helper(s):\\n            return 0 if not s else max(s[0],s[-1])\\n        \\n        alex = 0\\n        lee = 0\\n        while piles:\\n            temp = helper(piles)\\n            alex += temp\\n            piles.pop(piles.index(temp))\\n            temp = helper(piles)\\n            lee += temp\\n        return alex > lee\\n```\\n\\nRuntime: 24 ms, faster than 75.00% of Python online submissions for Stone Game.\\nMemory Usage: 13.4 MB, less than 73.91% of Python online submissions for Stone Game.",
                "solutionTags": [],
                "code": "```\\n        def helper(s):\\n            return 0 if not s else max(s[0],s[-1])\\n        \\n        alex = 0\\n        lee = 0\\n        while piles:\\n            temp = helper(piles)\\n            alex += temp\\n            piles.pop(piles.index(temp))\\n            temp = helper(piles)\\n            lee += temp\\n        return alex > lee\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 940359,
                "title": "answer-is-always-true-so-just-return-true",
                "content": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 901421,
                "title": "always-true",
                "content": "\\'\\'\\'\\n    bool stoneGame(vector<int>& piles){\\n        // As total sum of all stones is odd\\n        // so game can be played in such a way that Alex always wins\\n        return true;\\n    }\\n\\t\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n    bool stoneGame(vector<int>& piles){\\n        // As total sum of all stones is odd\\n        // so game can be played in such a way that Alex always wins\\n        return true;\\n    }\\n\\t\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 841760,
                "title": "c-bottom-up-dp",
                "content": "```\\ntypedef pair<int,int> pii;\\nbool stoneGame(vector<int>& piles) {\\n\\tint n = piles.size();\\n\\tint totalStones = accumulate(piles.begin(), piles.end(), 0);\\n\\tvector<vector<pii>> dp(n, vector<pii>(n, {0,0}));\\n\\n\\tfor(int i = 0; i < n; i++) dp[i][i] = {piles[i], 0};\\n\\n\\tfor(int len = 1; len < n; len++) {\\n\\t\\tfor(int i = 0; i < n-len; i++) {\\n\\t\\t\\tint x = i;\\n\\t\\t\\tint y = i+len;\\n\\t\\t\\tif(dp[x+1][y].second+piles[x] > dp[x][y-1].second+piles[y]) {\\n\\t\\t\\t\\tdp[x][y].first = dp[x+1][y].second+piles[x];\\n\\t\\t\\t\\tdp[x][y].second = dp[x+1][y].first;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdp[x][y].first = dp[x][y-1].second+piles[y];\\n\\t\\t\\t\\tdp[x][y].second = dp[x][y-1].first;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[0][n-1].first > totalStones/2;\\n}  \\n```",
                "solutionTags": [],
                "code": "```\\ntypedef pair<int,int> pii;\\nbool stoneGame(vector<int>& piles) {\\n\\tint n = piles.size();\\n\\tint totalStones = accumulate(piles.begin(), piles.end(), 0);\\n\\tvector<vector<pii>> dp(n, vector<pii>(n, {0,0}));\\n\\n\\tfor(int i = 0; i < n; i++) dp[i][i] = {piles[i], 0};\\n\\n\\tfor(int len = 1; len < n; len++) {\\n\\t\\tfor(int i = 0; i < n-len; i++) {\\n\\t\\t\\tint x = i;\\n\\t\\t\\tint y = i+len;\\n\\t\\t\\tif(dp[x+1][y].second+piles[x] > dp[x][y-1].second+piles[y]) {\\n\\t\\t\\t\\tdp[x][y].first = dp[x+1][y].second+piles[x];\\n\\t\\t\\t\\tdp[x][y].second = dp[x+1][y].first;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdp[x][y].first = dp[x][y-1].second+piles[y];\\n\\t\\t\\t\\tdp[x][y].second = dp[x][y-1].first;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[0][n-1].first > totalStones/2;\\n}  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 781703,
                "title": "cpp14-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size() ; \\n        int dp[n][n][2] ; \\n        memset(dp , 0 , sizeof dp) ; \\n        for(int len = 1 ; len <= n ; ++len){\\n            for(int i = 0;  i <= n - len  ; ++i){\\n                int j = i + len - 1;  \\n               // cout << \" i \" << i << \" j \" << j << endl ; \\n                if(i == j){\\n                    dp[i][j][0] = piles[i] ; \\n                    dp[i][j][1] = 0 ; \\n                }\\n                else{\\n                    int left = piles[i] + dp[i+1][j][1] ; \\n                    int right = piles[j] + dp[i][j-1][1] ; \\n                    if(left > right){\\n                        dp[i][j][0] = left ; \\n                        dp[i][j][1] = dp[i+1][j][0] ; \\n                    }\\n                    else {\\n                        dp[i][j][0] = right ; \\n                        dp[i][j][1] = dp[i][j-1][0] ; \\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        int res = dp[0][n-1][0] ; \\n        int foo = dp[0][n-1][1] ; \\n        int sum = 0 ; \\n        for(auto x : piles) sum+=x ; \\n        int req = sum / 2 ; ++req ; \\n        if(res >= req) return 1; \\n        return 0 ; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n = piles.size() ; \\n        int dp[n][n][2] ; \\n        memset(dp , 0 , sizeof dp) ; \\n        for(int len = 1 ; len <= n ; ++len){\\n            for(int i = 0;  i <= n - len  ; ++i){\\n                int j = i + len - 1;  \\n               // cout << \" i \" << i << \" j \" << j << endl ; \\n                if(i == j){\\n                    dp[i][j][0] = piles[i] ; \\n                    dp[i][j][1] = 0 ; \\n                }\\n                else{\\n                    int left = piles[i] + dp[i+1][j][1] ; \\n                    int right = piles[j] + dp[i][j-1][1] ; \\n                    if(left > right){\\n                        dp[i][j][0] = left ; \\n                        dp[i][j][1] = dp[i+1][j][0] ; \\n                    }\\n                    else {\\n                        dp[i][j][0] = right ; \\n                        dp[i][j][1] = dp[i][j-1][0] ; \\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        int res = dp[0][n-1][0] ; \\n        int foo = dp[0][n-1][1] ; \\n        int sum = 0 ; \\n        for(auto x : piles) sum+=x ; \\n        int req = sum / 2 ; ++req ; \\n        if(res >= req) return 1; \\n        return 0 ; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 741240,
                "title": "clean-cpp-dp",
                "content": "```class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        // dp[i][j] is the maximum value that the first player could get,\\n        // given the sub arr of piles from i to j\\n        vector<vector<int>> dp(piles.size(), vector<int>(piles.size(), 0));\\n        \\n        for (int i = 0; i < piles.size(); ++i) {\\n            dp[i][i] = piles[i];\\n        }\\n        \\n        for (int left = piles.size() - 1; left >= 0; --left) {\\n            for (int right = left + 1; right < piles.size(); ++right) {\\n                int pick_left = piles[left] - dp[left + 1][right];\\n                int pick_right = piles[right] - dp[left][right - 1];\\n                dp[left][right] = max(pick_left, pick_right);\\n            }\\n        }\\n        \\n        return dp[0][piles.size() - 1] > 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        // dp[i][j] is the maximum value that the first player could get,\\n        // given the sub arr of piles from i to j\\n        vector<vector<int>> dp(piles.size(), vector<int>(piles.size(), 0));\\n        \\n        for (int i = 0; i < piles.size(); ++i) {\\n            dp[i][i] = piles[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 734419,
                "title": "cpp-one-line-code",
                "content": "if the no. of piles is even then answer will always be true.\\ncase 1 (piles.size()=2)\\n\\tAlice can choose either of two so alice win.\\ncase 2 (piles.size()=4)\\n\\tif you analyse the chances Alice can take you will see alice would always win.\\n\\tsuppose if Alice choose the 1st then she can choose 3rd\\n\\tor if Alice choose 4th then she can always choose 2nd \\n\\tand either of this combination will have maximum value.\\n\\twe can extend this pattern further then we will get two types of overall move like 1st 3rd 5th ... and 2nd 4th 6th ... so one of them will always be greater than other.\\n\\tso directly returning true will suffice.\\n```\\n bool stoneGame(vector<int>& piles) {\\n\\treturn true;\\n}\\n```\\n\\t",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n bool stoneGame(vector<int>& piles) {\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 718032,
                "title": "c-straightforward-dp-solution",
                "content": "The solution is for odd length of array. Please go refer to @lee215 arcticle why we only take odd into account.\\nFirst, we define Alex wins Lee amount of piles from i to j as `dp\\u1D62,\\u2C7C`. Subprobelm would be subarrary issue[1].\\nEach `dp\\u1D62,\\u1D62` means only have piles[i] for guessing[2] or initiation.\\nBecause, both of players play **optimally**, the opponent will also try to gain as more as possible piles at next round.\\nSo the transition formula `dp(i,j) ={all your can possible get} - {opponent can get}` [3]. What you can gain from piles[i] to piles[j] potentially is sum of piles(0,j)  minus sum of piles(0,i-1), and your opponent would try to lower your amount of piles. and recurrence formula would be `min(dp(i+1,j) , dp(i,j-1))`, since opponent can only pick up head or tail of array. Either i\\'s next step `i+1` or `j-1`. So Alex at i to j can gain number of piles as `dp(i,j) = sum of (i,j) - min(dp(i+1,j), dp(i,j-1))`\\n```\\ni = 1,\\nj = 3\\n[5,3,4,5]   -> [5,8,12,17]\\n   i   j\\nsum of (i,j) would be  17 - 5 = 12 (3+4+5)\\n```\\n\\nFinally, if dp(o,n-1) is larger than piles owned by opponents which can interpret as `sum(o,n-1) - {alex wins}`. Then, Alex wins, and it is our finally original problem[4]. The solution follows the description and instruction. \\n```\\nbool stoneGame(vector<int>& piles) {\\n    int n = piles.size();\\n\\n    // dp(i,j) means from i to j alex gain how many piles from the game\\n    vector<int> presum(n+1, 0);\\n    for(int i=0; i < n; ++i)\\n        presum[i+1] = presum[i] + piles[i];\\n    vector<vector<int>> dp(n,vector<int>(n,0));\\n    for(int i=0; i < n; ++i) {\\n        dp[i][i] = piles[i];\\n    }\\n\\n    for(int l=0;  l < n-1; ++l) {\\n        for(int r=l+1; r < n; ++r) {\\n            int sum = presum[r+1] - presum[l];\\n            dp[l][r] = sum - min(dp[l+1][r], dp[l][r-1]);\\n        }\\n    }\\n    return dp[0][n-1] > presum[n] - dp[0][n-1];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ni = 1,\\nj = 3\\n[5,3,4,5]   -> [5,8,12,17]\\n   i   j\\nsum of (i,j) would be  17 - 5 = 12 (3+4+5)\\n```\n```\\nbool stoneGame(vector<int>& piles) {\\n    int n = piles.size();\\n\\n    // dp(i,j) means from i to j alex gain how many piles from the game\\n    vector<int> presum(n+1, 0);\\n    for(int i=0; i < n; ++i)\\n        presum[i+1] = presum[i] + piles[i];\\n    vector<vector<int>> dp(n,vector<int>(n,0));\\n    for(int i=0; i < n; ++i) {\\n        dp[i][i] = piles[i];\\n    }\\n\\n    for(int l=0;  l < n-1; ++l) {\\n        for(int r=l+1; r < n; ++r) {\\n            int sum = presum[r+1] - presum[l];\\n            dp[l][r] = sum - min(dp[l+1][r], dp[l][r-1]);\\n        }\\n    }\\n    return dp[0][n-1] > presum[n] - dp[0][n-1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 717090,
                "title": "java-simple-dp",
                "content": "dp[i][j] means step i, with left array starts at index j;\\n```\\n    public boolean stoneGame(int[] ps) {\\n        int n = ps.length, dp[][] = new int[n + 1][n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= n - i; j++) {\\n                dp[i][j] = Math.max(ps[j] - dp[i - 1][j + 1], ps[j + i - 1] - dp[i - 1][j]);\\n            }\\n        }\\n        return dp[n][0] > 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean stoneGame(int[] ps) {\\n        int n = ps.length, dp[][] = new int[n + 1][n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= n - i; j++) {\\n                dp[i][j] = Math.max(ps[j] - dp[i - 1][j + 1], ps[j + i - 1] - dp[i - 1][j]);\\n            }\\n        }\\n        return dp[n][0] > 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 706734,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis:**\\n\\n[\\uD83C\\uDFA8 The **ART** of dynamic programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities considered via top-down brute-force selecting the max of taking the first/last stones recursively\\n2. **R**emember previous subproblems\\' optimal solutions using a memo\\n3. **T**urn the top-down memoized solution upside-down for a bottom-up iterative solution\\n\\n**Note:** Prerequisites to properly understanding this solution are a handful of [game theory](https://en.wikipedia.org/wiki/Game_theory) concepts:\\n* [Zero-sum game](https://en.wikipedia.org/wiki/Zero-sum_game)\\n* [Minimax (in Zero-sum games)](https://en.wikipedia.org/wiki/Minimax#In_zero-sum_games)\\n* [Nash Equilibrium](https://en.wikipedia.org/wiki/Nash_equilibrium)\\n\\n---\\n\\n**Solution 1: Top-Down Brute-Force** (TLE)\\n\\n*Javascript*\\n```\\nlet stoneGame = A => {\\n    let N = A.length;\\n    let go = (i = 0, j = N - 1) => {\\n        if (i == j)\\n            return A[i]; // first == last \\uD83D\\uDED1\\n        return Math.max(A[i] - go(i + 1, j), A[j] - go(i, j - 1)); // max(first, last) \\uD83C\\uDFAF\\n    };\\n    return 0 < go();\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    VI A;\\n    int go(int i, int j) {\\n        if (i == j)\\n            return A[i]; // first == last \\uD83D\\uDED1\\n        return max(A[i] - go(i + 1, j), A[j] - go(i, j - 1)); // max(first, last) \\uD83C\\uDFAF\\n    }\\npublic:\\n    bool stoneGame(VI& A_) {\\n        A = A_;\\n        return 0 < go(0, int(A.size()) - 1);\\n    }\\n};\\n```\\n\\n---\\n\\n**Solution 2: Top-Down with Memo** (AC)\\n\\n*Javascript*\\n```\\nlet stoneGame = A => {\\n    let N = A.length;\\n    let m = [...Array(N)].map(_ => Array(N).fill(0));\\n    let go = (i = 0, j = N - 1) => {\\n        if (m[i][j])\\n            return m[i][j]; // memo \\uD83E\\uDD14\\n        if (i == j)\\n            return m[i][j] = A[i]; // first == last \\uD83D\\uDED1 \\n        let ans = m[i][j] = Math.max(A[i] - go(i + 1, j), A[j] - go(i, j - 1)); // max(first, last) \\uD83C\\uDFAF\\n        return ans;\\n    };\\n    return 0 < go();\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, unordered_map<int, int>>;\\n    VI A;\\n    Map m;\\n    int go(int i, int j) {\\n        if (m[i][j])\\n            return m[i][j]; // memo \\uD83E\\uDD14\\n        if (i == j)\\n            return m[i][j] = A[i]; // first == last \\uD83D\\uDED1\\n        return m[i][j] = max(A[i] - go(i + 1, j), A[j] - go(i, j - 1)); // max(first, last) \\uD83C\\uDFAF\\n    }\\npublic:\\n    bool stoneGame(VI& A_) {\\n        A = A_;\\n        return 0 < go(0, int(A.size()) - 1);\\n    }\\n};\\n```\\n\\n---\\n\\n**Solution 3: Bottom-Up** (AC)\\n\\n*Javascript*\\n```\\nlet stoneGame = A => {\\n    let N = A.length;\\n    let dp = [...Array(N)].map(_ => Array(N).fill(0)); // memo \\uD83E\\uDD14\\n    for (let i = N - 1; 0 <= i; --i)\\n        dp[i][i] = A[i]; // first == last \\uD83D\\uDED1\\n    for (let i = N - 1; 0 <= i; --i) // i-th first stone\\n        for (let j = i + 1; j < N; ++j) // j-th last stone\\n            dp[i][j] = Math.max(dp[i][i] - dp[i + 1][j], dp[j][j] - dp[i][j - 1]); // max(first, last) \\uD83C\\uDFAF \\n    return 0 < dp[0][N - 1];\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {    \\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    bool stoneGame(VI& A) {\\n        int N = A.size();\\n        VVI dp(N, VI(N)); // memo \\uD83E\\uDD14\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            dp[i][i] = A[i]; // first == last \\uD83D\\uDED1\\n        for (auto i{ N - 1 }; 0 <= i; --i) // i-th first stone\\n            for (auto j = i + 1; j < N; ++j) // j-th last stone\\n                dp[i][j] = max(dp[i][i] - dp[i + 1][j], dp[j][j] - dp[i][j - 1]); // max(first, last) \\uD83C\\uDFAF\\n        return dp[0][N - 1];\\n    }\\n};\\n```\\n\\n---\\n\\n**Solution 4: Bottom-Up - Optimized** (AC)\\n\\nWe don\\'t need to fill in and use the base case values `dp[i][i]` and `dp[j][j]`.  Instead we can direcly use `A[i]` and `A[j]` correspondingly in the recurrence relation.\\n\\n*Javascript*\\n```\\nlet stoneGame = A => {\\n    let N = A.length;\\n    let dp = [...Array(N)].map(_ => Array(N).fill(0)); // memo \\uD83E\\uDD14\\n    for (let i = N - 1; 0 <= i; --i) // i-th first stone\\n        for (let j = i + 1; j < N; ++j) // j-th last stone\\n            dp[i][j] = Math.max(A[i] - dp[i + 1][j], A[j] - dp[i][j - 1]); // max(first, last) \\uD83C\\uDFAF \\n    return 0 < dp[0][N - 1];\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    bool stoneGame(VI& A) {\\n        int N = A.size();\\n        VVI dp(N, VI(N)); // memo \\uD83E\\uDD14\\n        for (auto i{ N - 1 }; 0 <= i; --i) // i-th first stone\\n            for (auto j = i + 1; j < N; ++j) // j-th last stone\\n                dp[i][j] = max(A[i] - dp[i + 1][j], A[j] - dp[i][j - 1]); // max(first, last) \\uD83C\\uDFAF\\n        return dp[0][N - 1];\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nlet stoneGame = A => {\\n    let N = A.length;\\n    let go = (i = 0, j = N - 1) => {\\n        if (i == j)\\n            return A[i]; // first == last \\uD83D\\uDED1\\n        return Math.max(A[i] - go(i + 1, j), A[j] - go(i, j - 1)); // max(first, last) \\uD83C\\uDFAF\\n    };\\n    return 0 < go();\\n};\\n```\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    VI A;\\n    int go(int i, int j) {\\n        if (i == j)\\n            return A[i]; // first == last \\uD83D\\uDED1\\n        return max(A[i] - go(i + 1, j), A[j] - go(i, j - 1)); // max(first, last) \\uD83C\\uDFAF\\n    }\\npublic:\\n    bool stoneGame(VI& A_) {\\n        A = A_;\\n        return 0 < go(0, int(A.size()) - 1);\\n    }\\n};\\n```\n```\\nlet stoneGame = A => {\\n    let N = A.length;\\n    let m = [...Array(N)].map(_ => Array(N).fill(0));\\n    let go = (i = 0, j = N - 1) => {\\n        if (m[i][j])\\n            return m[i][j]; // memo \\uD83E\\uDD14\\n        if (i == j)\\n            return m[i][j] = A[i]; // first == last \\uD83D\\uDED1 \\n        let ans = m[i][j] = Math.max(A[i] - go(i + 1, j), A[j] - go(i, j - 1)); // max(first, last) \\uD83C\\uDFAF\\n        return ans;\\n    };\\n    return 0 < go();\\n};\\n```\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, unordered_map<int, int>>;\\n    VI A;\\n    Map m;\\n    int go(int i, int j) {\\n        if (m[i][j])\\n            return m[i][j]; // memo \\uD83E\\uDD14\\n        if (i == j)\\n            return m[i][j] = A[i]; // first == last \\uD83D\\uDED1\\n        return m[i][j] = max(A[i] - go(i + 1, j), A[j] - go(i, j - 1)); // max(first, last) \\uD83C\\uDFAF\\n    }\\npublic:\\n    bool stoneGame(VI& A_) {\\n        A = A_;\\n        return 0 < go(0, int(A.size()) - 1);\\n    }\\n};\\n```\n```\\nlet stoneGame = A => {\\n    let N = A.length;\\n    let dp = [...Array(N)].map(_ => Array(N).fill(0)); // memo \\uD83E\\uDD14\\n    for (let i = N - 1; 0 <= i; --i)\\n        dp[i][i] = A[i]; // first == last \\uD83D\\uDED1\\n    for (let i = N - 1; 0 <= i; --i) // i-th first stone\\n        for (let j = i + 1; j < N; ++j) // j-th last stone\\n            dp[i][j] = Math.max(dp[i][i] - dp[i + 1][j], dp[j][j] - dp[i][j - 1]); // max(first, last) \\uD83C\\uDFAF \\n    return 0 < dp[0][N - 1];\\n};\\n```\n```\\nclass Solution {    \\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    bool stoneGame(VI& A) {\\n        int N = A.size();\\n        VVI dp(N, VI(N)); // memo \\uD83E\\uDD14\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            dp[i][i] = A[i]; // first == last \\uD83D\\uDED1\\n        for (auto i{ N - 1 }; 0 <= i; --i) // i-th first stone\\n            for (auto j = i + 1; j < N; ++j) // j-th last stone\\n                dp[i][j] = max(dp[i][i] - dp[i + 1][j], dp[j][j] - dp[i][j - 1]); // max(first, last) \\uD83C\\uDFAF\\n        return dp[0][N - 1];\\n    }\\n};\\n```\n```\\nlet stoneGame = A => {\\n    let N = A.length;\\n    let dp = [...Array(N)].map(_ => Array(N).fill(0)); // memo \\uD83E\\uDD14\\n    for (let i = N - 1; 0 <= i; --i) // i-th first stone\\n        for (let j = i + 1; j < N; ++j) // j-th last stone\\n            dp[i][j] = Math.max(A[i] - dp[i + 1][j], A[j] - dp[i][j - 1]); // max(first, last) \\uD83C\\uDFAF \\n    return 0 < dp[0][N - 1];\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    bool stoneGame(VI& A) {\\n        int N = A.size();\\n        VVI dp(N, VI(N)); // memo \\uD83E\\uDD14\\n        for (auto i{ N - 1 }; 0 <= i; --i) // i-th first stone\\n            for (auto j = i + 1; j < N; ++j) // j-th last stone\\n                dp[i][j] = max(A[i] - dp[i + 1][j], A[j] - dp[i][j - 1]); // max(first, last) \\uD83C\\uDFAF\\n        return dp[0][N - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599608,
                "title": "c-generalised-dp-solution",
                "content": "Clearly explained here: https://www.youtube.com/watch?v=WxpIHvsu1RI\\nLogic implemented in C++:\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& a) {\\n        int n = a.size();\\n        // Each pair denotes (Alex\\'s score, Lee\\'s score) so far\\n        pair<int, int> dp[n][n];\\n        // Fill grid diagonally first (first turn)\\n        for(int i = 0; i < n; ++i){\\n            dp[i][i].first = a[i];\\n            dp[i][i].second = 0;\\n        }\\n        for(int turn = 2; turn <= n; ++turn){\\n        // dp[i][j] = scores of players if stones from a[i, j] were\\n        // available for playing\\n            for(int i = 0; i <= n - turn; ++i){\\n                int j = i + turn - 1;\\n                int pickLeft = a[i] + dp[i+1][j].second, pickRight = a[j] + dp[i][j-1].second;\\n                dp[i][j].first = max(pickLeft, pickRight);\\n                if(dp[i][j].first == pickLeft) dp[i][j].second = dp[i+1][j].first;\\n                else dp[i][j].second = dp[i][j-1].first;\\n            }\\n        }\\n        // Check if first player scored more\\n        return dp[0][n-1].first > dp[0][n-1].second;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& a) {\\n        int n = a.size();\\n        // Each pair denotes (Alex\\'s score, Lee\\'s score) so far\\n        pair<int, int> dp[n][n];\\n        // Fill grid diagonally first (first turn)\\n        for(int i = 0; i < n; ++i){\\n            dp[i][i].first = a[i];\\n            dp[i][i].second = 0;\\n        }\\n        for(int turn = 2; turn <= n; ++turn){\\n        // dp[i][j] = scores of players if stones from a[i, j] were\\n        // available for playing\\n            for(int i = 0; i <= n - turn; ++i){\\n                int j = i + turn - 1;\\n                int pickLeft = a[i] + dp[i+1][j].second, pickRight = a[j] + dp[i][j-1].second;\\n                dp[i][j].first = max(pickLeft, pickRight);\\n                if(dp[i][j].first == pickLeft) dp[i][j].second = dp[i+1][j].first;\\n                else dp[i][j].second = dp[i][j-1].first;\\n            }\\n        }\\n        // Check if first player scored more\\n        return dp[0][n-1].first > dp[0][n-1].second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 587951,
                "title": "concise-java-dp-code-explained-in-detail-with-comments",
                "content": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        int n = piles.length;\\n        int [][] dp = new int[n][n];\\n        /* prefill wher start and end == zero */\\n        for(int i=0;i<n;i++) dp[i][i] = piles[i];\\n        \\n        for(int d =1; d<n; d++){ /* d > 0 as we prefilled */\\n            for(int i= 0; i <n-d; i++){ /* start */\\n                dp[i][i+d] = Math.max(\\n       /* left choosen*/    piles[i] - dp[i+1][i+d], \\n       /* right choosen */  piles[i+d] - dp[i][i+d-1]); \\n            }\\n        }\\n    /* this will handle even when the no of piles are odd */\\n    /* example array : 5,3,4,5 \\n               index : 0,1,2,3        \\n            so if 0 to 2 that is 5,3,4 only exists than\\n            #if we choose 0 the oponent gets to choose from 1th index to 2nd index\\n                piles[i]- piles[i+1][i+d] (i+1 as we choose left and increment one index, i+d is where the array ends)\\n            \\n            #if we choose 2 then oponent gets gets to choose from 0th to 1st index \\n                piles[i+d]- piles[i][i+d-1] (i+d-1 as we choose last and so start to one index less than end)\\n    \\n    i --> indicates start of array\\n    i+d --> indicates end of array\\n    */\\n        return dp[0][n-1] >0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        int n = piles.length;\\n        int [][] dp = new int[n][n];\\n        /* prefill wher start and end == zero */\\n        for(int i=0;i<n;i++) dp[i][i] = piles[i];\\n        \\n        for(int d =1; d<n; d++){ /* d > 0 as we prefilled */\\n            for(int i= 0; i <n-d; i++){ /* start */\\n                dp[i][i+d] = Math.max(\\n       /* left choosen*/    piles[i] - dp[i+1][i+d], \\n       /* right choosen */  piles[i+d] - dp[i][i+d-1]); \\n            }\\n        }\\n    /* this will handle even when the no of piles are odd */\\n    /* example array : 5,3,4,5 \\n               index : 0,1,2,3        \\n            so if 0 to 2 that is 5,3,4 only exists than\\n            #if we choose 0 the oponent gets to choose from 1th index to 2nd index\\n                piles[i]- piles[i+1][i+d] (i+1 as we choose left and increment one index, i+d is where the array ends)\\n            \\n            #if we choose 2 then oponent gets gets to choose from 0th to 1st index \\n                piles[i+d]- piles[i][i+d-1] (i+d-1 as we choose last and so start to one index less than end)\\n    \\n    i --> indicates start of array\\n    i+d --> indicates end of array\\n    */\\n        return dp[0][n-1] >0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575179,
                "title": "java-dfs-with-memoization",
                "content": "```java\\n    public boolean stoneGame(int[] piles) {\\n        if(piles == null || piles.length == 0) {\\n            return true;\\n        }\\n        int n = piles.length;\\n        int[][] dp = new int[n][n];\\n\\n        return dfs(0, piles.length-1, piles, dp) > 0;\\n    }\\n\\n    /**\\n     * return the relative value Alice score - Bob score\\n     * @param l\\n     * @param r\\n     * @param piles\\n     * @return\\n     */\\n    private int dfs(int l, int r, int[] piles, int[][] dp) {\\n        if(dp[l][r] != 0) {\\n            return dp[l][r];\\n        }\\n        if(l>r) {\\n            return 0;\\n        }\\n        if(l == r) {\\n            return piles[l];\\n        }\\n\\n        // take either left or right\\n        // take left\\n        int ans1 = piles[l] - dfs(l+1, r, piles, dp);\\n        // take right\\n        int ans2 = piles[r] - dfs(l, r-1, piles, dp);\\n        return dp[l][r] = Math.max(ans1, ans2);\\n    }\\n```\\n\\n\\n\\nbottomup dp\\n\\n\\n```java\\n    public boolean stoneGame(int[] piles) {\\n        int n = piles.length;\\n        int[][] dp = new int[n][n];\\n\\n\\n        // initial state\\n        // bottom up, the optimal is covered in the sub optimal matrix.\\n        // init, where left == right, the player can get all the points..\\n        for(int i=0;i<n;i++) {\\n            dp[i][i] = piles[i];\\n        }\\n        for(int len = 2;len<= n;len++) {\\n            for(int i=0;i+len-1 < n;i++) {\\n                int j = i + len-1;\\n                dp[i][j] = Math.max(piles[i] - dp[i+1][j], piles[j] - dp[i][j-1]);\\n            }\\n        }\\n        return dp[0][n-1] > 0; \\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public boolean stoneGame(int[] piles) {\\n        if(piles == null || piles.length == 0) {\\n            return true;\\n        }\\n        int n = piles.length;\\n        int[][] dp = new int[n][n];\\n\\n        return dfs(0, piles.length-1, piles, dp) > 0;\\n    }\\n\\n    /**\\n     * return the relative value Alice score - Bob score\\n     * @param l\\n     * @param r\\n     * @param piles\\n     * @return\\n     */\\n    private int dfs(int l, int r, int[] piles, int[][] dp) {\\n        if(dp[l][r] != 0) {\\n            return dp[l][r];\\n        }\\n        if(l>r) {\\n            return 0;\\n        }\\n        if(l == r) {\\n            return piles[l];\\n        }\\n\\n        // take either left or right\\n        // take left\\n        int ans1 = piles[l] - dfs(l+1, r, piles, dp);\\n        // take right\\n        int ans2 = piles[r] - dfs(l, r-1, piles, dp);\\n        return dp[l][r] = Math.max(ans1, ans2);\\n    }\\n```\n```java\\n    public boolean stoneGame(int[] piles) {\\n        int n = piles.length;\\n        int[][] dp = new int[n][n];\\n\\n\\n        // initial state\\n        // bottom up, the optimal is covered in the sub optimal matrix.\\n        // init, where left == right, the player can get all the points..\\n        for(int i=0;i<n;i++) {\\n            dp[i][i] = piles[i];\\n        }\\n        for(int len = 2;len<= n;len++) {\\n            for(int i=0;i+len-1 < n;i++) {\\n                int j = i + len-1;\\n                dp[i][j] = Math.max(piles[i] - dp[i+1][j], piles[j] - dp[i][j-1]);\\n            }\\n        }\\n        return dp[0][n-1] > 0; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 383835,
                "title": "python-dp",
                "content": "1. chose left\\n2. chose right\\n```\\nclass Solution:\\n    def stoneGame(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        n = len(piles)\\n        dp = [[0]*n for _ in range(n)]\\n        for i in range(n-1,-1,-1):\\n            for j in range(i,n):\\n                if (n - (j-i+1) ) % 2 == 0:\\n                    dp[i][j] = max((dp[i][j-1] if j > 0 else 0)+piles[j],(dp[i+1][j] if i < n-1 else 0 )+piles[i])\\n                else:\\n                    dp[i][j] = min((dp[i][j-1] if j > 0 else 0)-piles[j],(dp[i+1][j] if i < n-1 else 0 )-piles[i])\\n              \\n        return dp[0][-1] > 0\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        n = len(piles)\\n        dp = [[0]*n for _ in range(n)]\\n        for i in range(n-1,-1,-1):\\n            for j in range(i,n):\\n                if (n - (j-i+1) ) % 2 == 0:\\n                    dp[i][j] = max((dp[i][j-1] if j > 0 else 0)+piles[j],(dp[i+1][j] if i < n-1 else 0 )+piles[i])\\n                else:\\n                    dp[i][j] = min((dp[i][j-1] if j > 0 else 0)-piles[j],(dp[i+1][j] if i < n-1 else 0 )-piles[i])\\n              \\n        return dp[0][-1] > 0\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 368423,
                "title": "c-solution-using-deque-faster-than-100-submissions",
                "content": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int alex = 0, lee = 0;\\n        deque <int> d;\\n        for(int i=0;i<piles.size();i++)\\n            d.push_back(piles[i]);\\n        \\n        for(int i=0;i<d.size();i++) {\\n            alex += max(d.front(), d.back());\\n            lee += min(d.front(), d.back());\\n            d.pop_front();\\n            d.pop_back();\\n        }\\n        if(alex > lee)\\n            return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int alex = 0, lee = 0;\\n        deque <int> d;\\n        for(int i=0;i<piles.size();i++)\\n            d.push_back(piles[i]);\\n        \\n        for(int i=0;i<d.size();i++) {\\n            alex += max(d.front(), d.back());\\n            lee += min(d.front(), d.back());\\n            d.pop_front();\\n            d.pop_back();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 348958,
                "title": "one-line-solution",
                "content": "A solution is, return true. Why? We can prove by induction.  General idea, we revome 2 elements of a vector, the base case is a vector with 2 elements and Alex always win. So, for a vector with size multiple of 2 Alex win again, because he chooses the major element of the two elements removed.\\n\\n```\\nExample: v = [1,2,3,4,5,6] => (3 sub-problems) \\n\\t=> [1,2,3,4],  (3 sub-problems)\\n\\t\\t\\t=> [2,3], [1,2], [3,4] (Alex always wins)\\n\\t=>[3,4,5,6 ], (3 sub-problems)\\n\\t\\t\\t=>[3,4], [4,5], [5,6] (Alex always wins)\\n\\t=>[2,3,4,5]\\n\\t\\t\\t=>[2,3],[3,4],[4,5] (Alex always wins)\\n```\\n\\t\\t\\t\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nExample: v = [1,2,3,4,5,6] => (3 sub-problems) \\n\\t=> [1,2,3,4],  (3 sub-problems)\\n\\t\\t\\t=> [2,3], [1,2], [3,4] (Alex always wins)\\n\\t=>[3,4,5,6 ], (3 sub-problems)\\n\\t\\t\\t=>[3,4], [4,5], [5,6] (Alex always wins)\\n\\t=>[2,3,4,5]\\n\\t\\t\\t=>[2,3],[3,4],[4,5] (Alex always wins)\\n```\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296782,
                "title": "dp-o-n-2-and-trick-o-1-with-explanation",
                "content": "DP method: some code maybe redundant\\n```\\nclass Solution(object):\\ndef stoneGame(self, piles):\\n\"\"\"\\n:type piles: List[int]\\n:rtype: bool\\n\"\"\"\\nif len(piles)==2:\\n\\treturn True\\n#define the check interval when going through the pile\\nto_add = 3\\n#first compute the situation where only two stones are left to pick\\nsmaller = [max(piles[i],piles[i+1]) for i in range(len(piles)-1)]\\n#further compute situation where only 4,6,8.... stones are left to pick\\nwhile to_add < len(piles):\\n\\ts1 = []\\n\\t\\tfor i in range(len(piles)-to_add):\\n#the opponent plays optimally, so when caculating n+2 stones when we have the\\n#solution for n stones, we take the first stone and add its value to the minimum of\\n#the next 2 opitmal solution to get candidate one\\n#then add the value of the stone \\'to_add\\' step further to the minimum of the value\\n#of its previous two optimal solution to get candidate two\\n#the solution for the current size is the max of the two candidates\\n#for example we have [3,4,5,6], the solution for size2 is [4,5,6]\\n#we take the max(3+min(5,6),6+min(4,5)) to get the size4 solution\\n\\t\\tcand1 = piles[i]+min(smaller[i+1],smaller[i+2])\\n\\t\\tcand2 = piles[i+to_add]+min(smaller[i],smaller[i+1])\\n\\t\\tans = max(cand1,cand2)\\n\\t\\ts1.append(ans)\\n\\tto_add+=2\\n\\tsmaller = s1\\n#return true if our optimal solution is bigger than the value left\\nreturn smaller[0]>=sum(piles)-smaller[0]\\n```\\n\\nTrick: return True\\nAs you may notice, the DP solution above compute the optimal solution,\\nwhich is the maximum value we can get. However we do not need to get the maximum value to win the game.\\nIn this case, there are even number of stones,which means the index of the two stones on the ends are 1 odd and 1 even. Since we get to pick first, if we pick the last one(which has a index of odd number), we leave the opponent with two stones with even number to choose from.So no matter which one he picks, we get to choose a stone with odd index again.\\nSame for the case if we choose the first one(we then get to pick all the stones with even index). So we only need to check the sum of stones with even index and odd index and pick the larger one to win.\\nWait, we don\\'t need to know what stones to pick to win. we only need to know whether we can win, and it\\'s a fact that either sum of even index is larger or sum of odd index is larger.\\nHence we know we can always check the sum and win base on the result.\\nSo simply return True",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\ndef stoneGame(self, piles):\\n\"\"\"\\n:type piles: List[int]\\n:rtype: bool\\n\"\"\"\\nif len(piles)==2:\\n\\treturn True\\n#define the check interval when going through the pile\\nto_add = 3\\n#first compute the situation where only two stones are left to pick\\nsmaller = [max(piles[i],piles[i+1]) for i in range(len(piles)-1)]\\n#further compute situation where only 4,6,8.... stones are left to pick\\nwhile to_add < len(piles):\\n\\ts1 = []\\n\\t\\tfor i in range(len(piles)-to_add):\\n#the opponent plays optimally, so when caculating n+2 stones when we have the\\n#solution for n stones, we take the first stone and add its value to the minimum of\\n#the next 2 opitmal solution to get candidate one\\n#then add the value of the stone \\'to_add\\' step further to the minimum of the value\\n#of its previous two optimal solution to get candidate two\\n#the solution for the current size is the max of the two candidates\\n#for example we have [3,4,5,6], the solution for size2 is [4,5,6]\\n#we take the max(3+min(5,6),6+min(4,5)) to get the size4 solution\\n\\t\\tcand1 = piles[i]+min(smaller[i+1],smaller[i+2])\\n\\t\\tcand2 = piles[i+to_add]+min(smaller[i],smaller[i+1])\\n\\t\\tans = max(cand1,cand2)\\n\\t\\ts1.append(ans)\\n\\tto_add+=2\\n\\tsmaller = s1\\n#return true if our optimal solution is bigger than the value left\\nreturn smaller[0]>=sum(piles)-smaller[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 288976,
                "title": "python3-beat-100-simple-and-clear-no-dp",
                "content": "both players will pick the largest value of the remaining list\\n1. you are given [5,3,4,5]\\n sort all the piles, so that it has an increaseing or decreasing order, for example [5,5,4,3]\\n2. if start with the player A,  definitely he will select the largest, which is 5[index =1], then player B select the second largest, which is 5, [index =2],\\n\\n3. then the index of piles selected by player A is : 1,3,5,7,9,...\\nthen the index of piles selected by player B is : 2,4,6,8,10,...\\n\\njust sum up the piles picked by player A and player B\\uFF0Cand by comparison you my see who wins.\\n\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        piles.sort()\\n        piles = piles[::-1]\\n        sum1 = 0\\n        i =0\\n        while i <len(piles):\\n            sum1 += piles[i]\\n            i+=2\\n        if sum1*2 > sum(piles):\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        piles.sort()\\n        piles = piles[::-1]\\n        sum1 = 0\\n        i =0\\n        while i <len(piles):\\n            sum1 += piles[i]\\n            i+=2\\n        if sum1*2 > sum(piles):\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252097,
                "title": "python-minimax-template",
                "content": "```\\n\"\"\"\\nminimax problem\\n\\nscore = score_Alex - score_Lee\\nif score > 0, alex win\\nis score < 0, lee win\\n\\nTo win, alex want to maximize score, lee minimize score.\\n\"\"\"\\nMAXINT = float(\\'inf\\')\\nMININT = float(\\'-inf\\')\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        # maxScore = {} # (i,j) -> maxScore\\n        # minScore = {} # (i,j) -> minScore\\n        N = len(piles)\\n        maxScore = [[float(MININT)] * N for _ in range(N)]\\n        minScore = [[float(MAXINT)] * N for _ in range(N)]\\n        \\n        def miniMaxScore(i, j, wantMax=True):\\n            if i > j: return 0\\n            if wantMax:\\n                if maxScore[i][j] != MININT: return maxScore[i][j]\\n                maxScore[i][j] = max(\\n                    piles[i] + miniMaxScore(i + 1, j, False),\\n                    piles[j] + miniMaxScore(i, j - 1, False),\\n                )\\n                return maxScore[i][j]\\n            else:\\n                if minScore[i][j] != MAXINT: return minScore[i][j]\\n                minScore[i][j] = min(\\n                    -piles[i] + miniMaxScore(i + 1, j, True),\\n                    -piles[j] + miniMaxScore(i, j - 1, True),\\n                )\\n                return minScore[i][j]\\n        return miniMaxScore(0, N - 1) > 0\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\nminimax problem\\n\\nscore = score_Alex - score_Lee\\nif score > 0, alex win\\nis score < 0, lee win\\n\\nTo win, alex want to maximize score, lee minimize score.\\n\"\"\"\\nMAXINT = float(\\'inf\\')\\nMININT = float(\\'-inf\\')\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        # maxScore = {} # (i,j) -> maxScore\\n        # minScore = {} # (i,j) -> minScore\\n        N = len(piles)\\n        maxScore = [[float(MININT)] * N for _ in range(N)]\\n        minScore = [[float(MAXINT)] * N for _ in range(N)]\\n        \\n        def miniMaxScore(i, j, wantMax=True):\\n            if i > j: return 0\\n            if wantMax:\\n                if maxScore[i][j] != MININT: return maxScore[i][j]\\n                maxScore[i][j] = max(\\n                    piles[i] + miniMaxScore(i + 1, j, False),\\n                    piles[j] + miniMaxScore(i, j - 1, False),\\n                )\\n                return maxScore[i][j]\\n            else:\\n                if minScore[i][j] != MAXINT: return minScore[i][j]\\n                minScore[i][j] = min(\\n                    -piles[i] + miniMaxScore(i + 1, j, True),\\n                    -piles[j] + miniMaxScore(i, j - 1, True),\\n                )\\n                return minScore[i][j]\\n        return miniMaxScore(0, N - 1) > 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 218258,
                "title": "easy-c-recursive-memoization-solution-o-n-2",
                "content": "For each recursion, the 4 possibility are evaluated:\\n- Both Alex and Lee get the leftmost piles\\n- Both Alex and Lee get the right piles\\n- Alex take left, Lee take right\\n- Alex take right, Lee take left\\n\\nThe conditions are in OR. Only a full run on all combination of start/end is necessary, The results are memoized and reused for the subsequent calls:\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGameRec(vector<int>& piles, int start, int end, int alexScore, int leeScore, vector<vector<int>>& cache)\\n    {\\n        if (start > end)\\n           return alexScore > leeScore;\\n        \\n        if(cache[start][end] >= 0)\\n            return cache[start][end] == 1;\\n        \\n        bool res = (stoneGameRec(piles, start + 2, end, alexScore + piles[start], leeScore + piles[start + 1], cache) ||\\n                    stoneGameRec(piles, start, end - 2, alexScore + piles[end], leeScore + piles[end - 1], cache) ||\\n                    stoneGameRec(piles, start + 1, end - 1, alexScore + piles[start], leeScore + piles[end], cache) ||\\n                    stoneGameRec(piles, start + 1, end - 1, alexScore + piles[end], leeScore + piles[start], cache));\\n        \\n        cache[start][end] = res;\\n        \\n        return res;\\n    }\\n    \\n    bool stoneGame(vector<int>& piles)\\n    {\\n        if (piles.empty())\\n            return false;\\n        \\n        vector<vector<int>> cache(piles.size(), vector<int>(piles.size(), -1));\\n        \\n        return stoneGameRec(piles, 0, piles.size() - 1, 0, 0, cache);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGameRec(vector<int>& piles, int start, int end, int alexScore, int leeScore, vector<vector<int>>& cache)\\n    {\\n        if (start > end)\\n           return alexScore > leeScore;\\n        \\n        if(cache[start][end] >= 0)\\n            return cache[start][end] == 1;\\n        \\n        bool res = (stoneGameRec(piles, start + 2, end, alexScore + piles[start], leeScore + piles[start + 1], cache) ||\\n                    stoneGameRec(piles, start, end - 2, alexScore + piles[end], leeScore + piles[end - 1], cache) ||\\n                    stoneGameRec(piles, start + 1, end - 1, alexScore + piles[start], leeScore + piles[end], cache) ||\\n                    stoneGameRec(piles, start + 1, end - 1, alexScore + piles[end], leeScore + piles[start], cache));\\n        \\n        cache[start][end] = res;\\n        \\n        return res;\\n    }\\n    \\n    bool stoneGame(vector<int>& piles)\\n    {\\n        if (piles.empty())\\n            return false;\\n        \\n        vector<vector<int>> cache(piles.size(), vector<int>(piles.size(), -1));\\n        \\n        return stoneGameRec(piles, 0, piles.size() - 1, 0, 0, cache);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 217567,
                "title": "intuitive-dp-solution-with-clear-explanation",
                "content": "```\\nclass Solution {\\n    //dp[i][j] = max number of coins alex has if game is played on piles[i...j]\\n    // Alex has two choices:\\n    // 1. Select leftmost : if he selects leftmost then he has to take optimal choice from dp[i+1...j]\\n    //  2. Select rigtmost : if he select rightmost then he has to take optimal choice from dp[i... j - 1]\\n    //   3. he takes maximimum of both the choices\\n    //     base case:\\n    // if one pile ---> alext takes it\\n    //     if two piles --> alex select max from two\\n    public boolean stoneGame(int[] piles) {\\n        int totalCoins = 0;\\n        for(int onePile : piles) {\\n            totalCoins += onePile;\\n        }\\n        \\n        int dp[][] = new int[piles.length][piles.length];\\n        \\n        for(int k = 0; k < piles.length; k++) {\\n            int i = 0;\\n            for(int j = k; j < piles.length; j++) {\\n                //System.out.println(i + \" \" + j);\\n                if(i == j) dp[i][j] = piles[i];\\n                else if(i == j + 1) dp[i][j] = Math.max(piles[i], piles[j + 1]);\\n                else dp[i][j] = Math.max(piles[i] + dp[i + 1][j], piles[j] + dp[i][j - 1]);\\n                i++;\\n            }\\n        }\\n        return totalCoins / 2 < dp[0][piles.length - 1] ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //dp[i][j] = max number of coins alex has if game is played on piles[i...j]\\n    // Alex has two choices:\\n    // 1. Select leftmost : if he selects leftmost then he has to take optimal choice from dp[i+1...j]\\n    //  2. Select rigtmost : if he select rightmost then he has to take optimal choice from dp[i... j - 1]\\n    //   3. he takes maximimum of both the choices\\n    //     base case:\\n    // if one pile ---> alext takes it\\n    //     if two piles --> alex select max from two\\n    public boolean stoneGame(int[] piles) {\\n        int totalCoins = 0;\\n        for(int onePile : piles) {\\n            totalCoins += onePile;\\n        }\\n        \\n        int dp[][] = new int[piles.length][piles.length];\\n        \\n        for(int k = 0; k < piles.length; k++) {\\n            int i = 0;\\n            for(int j = k; j < piles.length; j++) {\\n                //System.out.println(i + \" \" + j);\\n                if(i == j) dp[i][j] = piles[i];\\n                else if(i == j + 1) dp[i][j] = Math.max(piles[i], piles[j + 1]);\\n                else dp[i][j] = Math.max(piles[i] + dp[i + 1][j], piles[j] + dp[i][j - 1]);\\n                i++;\\n            }\\n        }\\n        return totalCoins / 2 < dp[0][piles.length - 1] ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213801,
                "title": "c-1-line-fastest-solution-alive-hacked-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201060,
                "title": "c-dp-solution",
                "content": "```\\nint min(int a, int b) {\\n\\treturn a < b ? a : b;\\n}\\n//dp[i][j]+min(d[i][j-1],d[i+1][j])=sum[i][j]\\nbool stoneGame(int* piles, int pilesSize) {\\n    int **d = (int **)malloc(sizeof(int *)*pilesSize);\\n    int **sum = (int **)malloc(sizeof(int *)*pilesSize);\\n    for(int i=0;i<pilesSize;++i){\\n        d[i] = (int *)malloc(sizeof(int)*pilesSize);\\n        sum[i] = (int *)malloc(sizeof(int)*pilesSize);\\n        for(int j=0;j<pilesSize;++j){\\n            if(i==j){\\n                d[i][j]=piles[i];\\n                sum[i][j]=piles[i];\\n            }\\n        }\\n    }\\n    int j;\\n    for(int l=2;l<=pilesSize;++l){\\n        for(int i=0;i<=pilesSize-l;++i){\\n            j=i+l-1;\\n            sum[i][j] = sum[i][j-1]+piles[j];\\n            d[i][j] = sum[i][j]-min(d[i][j-1],d[i+1][j]);\\n        }\\n    }\\n    bool result = (d[0][pilesSize - 1]*2 > sum[0][pilesSize-1]);\\n    for(int i=0;i<pilesSize;++i){\\n        free(d[i]);\\n        free(sum[i]);\\n    }\\n    free(d);\\n    free(sum);\\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint min(int a, int b) {\\n\\treturn a < b ? a : b;\\n}\\n//dp[i][j]+min(d[i][j-1],d[i+1][j])=sum[i][j]\\nbool stoneGame(int* piles, int pilesSize) {\\n    int **d = (int **)malloc(sizeof(int *)*pilesSize);\\n    int **sum = (int **)malloc(sizeof(int *)*pilesSize);\\n    for(int i=0;i<pilesSize;++i){\\n        d[i] = (int *)malloc(sizeof(int)*pilesSize);\\n        sum[i] = (int *)malloc(sizeof(int)*pilesSize);\\n        for(int j=0;j<pilesSize;++j){\\n            if(i==j){\\n                d[i][j]=piles[i];\\n                sum[i][j]=piles[i];\\n            }\\n        }\\n    }\\n    int j;\\n    for(int l=2;l<=pilesSize;++l){\\n        for(int i=0;i<=pilesSize-l;++i){\\n            j=i+l-1;\\n            sum[i][j] = sum[i][j-1]+piles[j];\\n            d[i][j] = sum[i][j]-min(d[i][j-1],d[i+1][j]);\\n        }\\n    }\\n    bool result = (d[0][pilesSize - 1]*2 > sum[0][pilesSize-1]);\\n    for(int i=0;i<pilesSize;++i){\\n        free(d[i]);\\n        free(sum[i]);\\n    }\\n    free(d);\\n    free(sum);\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197290,
                "title": "does-this-make-sense",
                "content": "```\\ndef stoneGame(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        alex = 0\\n        other = 0\\n        start, end = 0 , len(piles) -1\\n        \\n        while start < end:\\n            \\n            alex += max(piles[start], piles[end])\\n            other += min(piles[start], piles[end])\\n            \\n            start += 1\\n            end -=1\\n        return alex > other\\n        ```",
                "solutionTags": [],
                "code": "```\\ndef stoneGame(self, piles):\\n        \"\"\"\\n        :type piles: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        alex = 0\\n        other = 0\\n        start, end = 0 , len(piles) -1\\n        \\n        while start < end:\\n            \\n            alex += max(piles[start], piles[end])\\n            other += min(piles[start], piles[end])\\n            \\n            start += 1\\n            end -=1\\n        return alex > other\\n        ```",
                "codeTag": "Python3"
            },
            {
                "id": 188113,
                "title": "fundamental-concept-is-wrong-leads-to-1-line-solution-in-o-1-time",
                "content": "There is a fundamental problem in this question. \n\nIf Alice and Bob both play optimally and Alice goes first, Alice will alwasys win!!\n\nTherefore, doing this will passs all test cases: \n\n```\nclass Solution {\npublic:\n\n    bool stoneGame(vector<int>& piles) {\n        \n        return true;\n     }\n};\n```\n\n\nThough this is my recursion solution (will return TLE in large testcases)\n\n\n```\nclass Solution {\npublic:\n    int sumA, sumB;\n    int f;\n    int maxE(int a, int b){\n        if(a>b)\n            return a;\n        else return b;\n    }\n   int minE(int a, int b){\n       if(a<b)\n            return a;\n        else return b;\n   }\n    int findA(vector<int> p, int s, int e){\n        int sum;\n        if(s+1 ==e){\n            if(max(p[s], p[e]) > sumA)\n                sumA = max(p[s], p[e]);\n            \n            return min(p[s], p[e]);\n           \n        }\n        int val = 0;\n        val = max(p[s] + findB(p, s+1, e), p[e] + findB(p, s, e-1));\n        sum = 0;\n        for(int i = s; i<=e; i++){\n            sum = sum + p[i];\n        }\n\n        if(val > sumA)\n            sumA = val;\n      \n        return sum - val;\n        \n    }\n    int findB(vector<int> p, int s, int e){\n        int sum;\n        if(s+1 ==e){\n            if(max(p[s], p[e]) > sumB)\n                sumB = max(p[s], p[e]);\n            return min(p[s], p[e]);\n           \n        }\n        int val=0;\n        val = max(p[s] + findA(p, s+1, e), p[e] + findA(p, s, e-1));\n        \n         sum = 0;\n        for(int i = s; i<=e; i++){\n            sum = sum + p[i];\n        }\n      \n          if(val > sumB)\n            sumB = val;\n  \n        return sum - val;\n    }\n    bool stoneGame(vector<int>& piles) {\n        \n       // return true;\n        \n        if(piles.size()<= 2)\n            return true;\n        \n        if(piles.size()%2!=0)\n            return true;\n        int i;\n        sumA = sumB = 0;\n        int val = findA(piles, 0, piles.size()-1);\n        \n\n        if(sumA >= sumB)\n            return true;\n        else return false;\n        \n     }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n\n    bool stoneGame(vector<int>& piles) {\n        \n        return true;\n     }\n};\n```\n```\nclass Solution {\npublic:\n    int sumA, sumB;\n    int f;\n    int maxE(int a, int b){\n        if(a>b)\n            return a;\n        else return b;\n    }\n   int minE(int a, int b){\n       if(a<b)\n            return a;\n        else return b;\n   }\n    int findA(vector<int> p, int s, int e){\n        int sum;\n        if(s+1 ==e){\n            if(max(p[s], p[e]) > sumA)\n                sumA = max(p[s], p[e]);\n            \n            return min(p[s], p[e]);\n           \n        }\n        int val = 0;\n        val = max(p[s] + findB(p, s+1, e), p[e] + findB(p, s, e-1));\n        sum = 0;\n        for(int i = s; i<=e; i++){\n            sum = sum + p[i];\n        }\n\n        if(val > sumA)\n            sumA = val;\n      \n        return sum - val;\n        \n    }\n    int findB(vector<int> p, int s, int e){\n        int sum;\n        if(s+1 ==e){\n            if(max(p[s], p[e]) > sumB)\n                sumB = max(p[s], p[e]);\n            return min(p[s], p[e]);\n           \n        }\n        int val=0;\n        val = max(p[s] + findA(p, s+1, e), p[e] + findA(p, s, e-1));\n        \n         sum = 0;\n        for(int i = s; i<=e; i++){\n            sum = sum + p[i];\n        }\n      \n          if(val > sumB)\n            sumB = val;\n  \n        return sum - val;\n    }\n    bool stoneGame(vector<int>& piles) {\n        \n       // return true;\n        \n        if(piles.size()<= 2)\n            return true;\n        \n        if(piles.size()%2!=0)\n            return true;\n        int i;\n        sumA = sumB = 0;\n        int val = findA(piles, 0, piles.size()-1);\n        \n\n        if(sumA >= sumB)\n            return true;\n        else return false;\n        \n     }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 155257,
                "title": "logical-thinking-with-clear-code",
                "content": "The solution below is the same as the one of **486. Predict the Winner**. \\nLink:  https://leetcode.com/problems/predict-the-winner/discuss/155217/Logical-Thinking-with-Clear-Java-Code\\n\\n**Logical Thinking**\\nIf we regard possible selecting range as **state**,\\n`state[i][j]` as the max score the 1st player can get selecting from nums[i, j)\\n**goal**: return true if `state[0][n - 1] >= totalScores - state[0][n - 1] `\\n**state transition**:\\n```\\n        max scores 1st can get = \\n            max(nums[i] + min(max scores 1st can get next round),\\n                nums[j - 1] + min(max scores 1st can get next round))\\n        * Please note that for the next round we take \\'min\\' for the 2nd player plays to maximize his score.\\n\\t\\t\\t\\t\\n        if 1st picks nums[i], 2nd can pick from [i + 1, j)\\n                             if 2nd picks nums[i + 1], 1st can pick  from nums[i + 2, j)\\n                             if 2nd picks nums[j - 1], 1st can pick from nums[i + 1, j - 1)\\n        if 1st picks nums[j - 1], 2nd can pick from [i, j - 1)\\n                             if 2nd picks nums[i], 1st picks from nums[i + 1, j - 1)\\n                             if 2nd picks nums[j - 2], 1st picks from nums[i, j - 2)\\n\\n```\\nWe utilize **memorization** to avoid duplicate calculations.\\n\\n**Clear Java Code**\\n```\\n    int[][] memo; // -1 if unvisited, 0 if false, 1 if true\\n\\n    public boolean stoneGame(int[] piles) {\\n\\n        int sum = 0, n = piles.length;\\n        initMemo(n);\\n        for (int num : piles)\\n            sum += num;\\n        int playerOneScore = getMaxScore(piles, 0, n);\\n\\n        return playerOneScore >= sum - playerOneScore;\\n    }\\n\\n    private void initMemo(int n) {\\n\\n        memo = new int[n + 1][n + 1];\\n        for (int i = 0; i < n + 1; i++) {\\n            for (int j = 0; j < n + 1; j++) {\\n                memo[i][j] = -1;\\n            }\\n        }\\n    }\\n\\n    private int getMaxScore(int[] piles, int i, int j) {\\n\\n        if (i >= j) {\\n            return 0;\\n        }\\n        if (i + 1 == j) {\\n            return piles[i];\\n        }\\n        if (memo[i][j] != -1) {\\n            return memo[i][j];\\n        }\\n\\n        int result = Math.max(piles[i] + Math.min(getMaxScore(piles, i + 2, j), getMaxScore(piles, i + 1, j - 1)),\\n                piles[j - 1] + Math.min(getMaxScore(piles, i, j - 2), getMaxScore(piles, i + 1, j - 1)));\\n        memo[i][j] = result;\\n\\n        return result;\\n    }\\n```\\n**I would appreciate your VOTE UP ;)**\\n",
                "solutionTags": [],
                "code": "```\\n        max scores 1st can get = \\n            max(nums[i] + min(max scores 1st can get next round),\\n                nums[j - 1] + min(max scores 1st can get next round))\\n        * Please note that for the next round we take \\'min\\' for the 2nd player plays to maximize his score.\\n\\t\\t\\t\\t\\n        if 1st picks nums[i], 2nd can pick from [i + 1, j)\\n                             if 2nd picks nums[i + 1], 1st can pick  from nums[i + 2, j)\\n                             if 2nd picks nums[j - 1], 1st can pick from nums[i + 1, j - 1)\\n        if 1st picks nums[j - 1], 2nd can pick from [i, j - 1)\\n                             if 2nd picks nums[i], 1st picks from nums[i + 1, j - 1)\\n                             if 2nd picks nums[j - 2], 1st picks from nums[i, j - 2)\\n\\n```\n```\\n    int[][] memo; // -1 if unvisited, 0 if false, 1 if true\\n\\n    public boolean stoneGame(int[] piles) {\\n\\n        int sum = 0, n = piles.length;\\n        initMemo(n);\\n        for (int num : piles)\\n            sum += num;\\n        int playerOneScore = getMaxScore(piles, 0, n);\\n\\n        return playerOneScore >= sum - playerOneScore;\\n    }\\n\\n    private void initMemo(int n) {\\n\\n        memo = new int[n + 1][n + 1];\\n        for (int i = 0; i < n + 1; i++) {\\n            for (int j = 0; j < n + 1; j++) {\\n                memo[i][j] = -1;\\n            }\\n        }\\n    }\\n\\n    private int getMaxScore(int[] piles, int i, int j) {\\n\\n        if (i >= j) {\\n            return 0;\\n        }\\n        if (i + 1 == j) {\\n            return piles[i];\\n        }\\n        if (memo[i][j] != -1) {\\n            return memo[i][j];\\n        }\\n\\n        int result = Math.max(piles[i] + Math.min(getMaxScore(piles, i + 2, j), getMaxScore(piles, i + 1, j - 1)),\\n                piles[j - 1] + Math.min(getMaxScore(piles, i, j - 2), getMaxScore(piles, i + 1, j - 1)));\\n        memo[i][j] = result;\\n\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 155242,
                "title": "java-memorization-search",
                "content": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        Integer[][] memo = new Integer[piles.length][piles.length];\\n        int max = dfs(piles, 0, piles.length - 1, memo);\\n        \\n        return memo[0][piles.length - 1] > 0;\\n    }\\n    \\n    \\n    \\n    private int dfs(int[] piles, int i, int j, Integer[][] memo) {\\n        if (i > j)  return 0;\\n        if (memo[i][j] != null) return memo[i][j];\\n        \\n        memo[i][j] = Math.max(piles[i] - dfs(piles, i + 1, j, memo), piles[j] - dfs(piles, i, j - 1, memo));\\n        return memo[i][j];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        Integer[][] memo = new Integer[piles.length][piles.length];\\n        int max = dfs(piles, 0, piles.length - 1, memo);\\n        \\n        return memo[0][piles.length - 1] > 0;\\n    }\\n    \\n    \\n    \\n    private int dfs(int[] piles, int i, int j, Integer[][] memo) {\\n        if (i > j)  return 0;\\n        if (memo[i][j] != null) return memo[i][j];\\n        \\n        memo[i][j] = Math.max(piles[i] - dfs(piles, i + 1, j, memo), piles[j] - dfs(piles, i, j - 1, memo));\\n        return memo[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881169,
                "title": "100-beat-simple",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        //start->end\\n        int alice=0;\\n        for(int i=0; i<piles.length; i+=2){\\n            alice+=piles[i];\\n        }\\n        int bob=0;\\n        for(int i=1; i<piles.length; i+=2){\\n            bob+=piles[i];\\n        }\\n\\n        //end->start\\n        int alice1=0;\\n        for(int i=piles.length-1; i>=0 ; i-=2){\\n            alice1+=piles[i];\\n        }\\n        int bob1=0;\\n        for(int i=piles.length-2; i>=0 ; i-=2){\\n            bob1+=piles[i];\\n        } \\n   \\n        return alice>bob || alice1>bob1;  \\n  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        //start->end\\n        int alice=0;\\n        for(int i=0; i<piles.length; i+=2){\\n            alice+=piles[i];\\n        }\\n        int bob=0;\\n        for(int i=1; i<piles.length; i+=2){\\n            bob+=piles[i];\\n        }\\n\\n        //end->start\\n        int alice1=0;\\n        for(int i=piles.length-1; i>=0 ; i-=2){\\n            alice1+=piles[i];\\n        }\\n        int bob1=0;\\n        for(int i=piles.length-2; i>=0 ; i-=2){\\n            bob1+=piles[i];\\n        } \\n   \\n        return alice>bob || alice1>bob1;  \\n  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828784,
                "title": "c-solution-dynamic-programming-clean-simple-code",
                "content": "# Code\\n```\\nclass Solution {\\n    int solve(vector<int>& piles,int i,int j,bool f,vector<vector<int>> &dp){\\n        if(i>j)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        if(f)\\n            return dp[i][j]=max(piles[i]+solve(piles,i+1,j,!f,dp),piles[j]+solve(piles,i,j-1,!f,dp));\\n        \\n        return dp[i][j]=min(solve(piles,i+1,j,!f,dp)-piles[i],solve(piles,i,j-1,!f,dp)-piles[j]);\\n    }\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return solve(piles,0,n-1,1,dp)>0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int solve(vector<int>& piles,int i,int j,bool f,vector<vector<int>> &dp){\\n        if(i>j)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        if(f)\\n            return dp[i][j]=max(piles[i]+solve(piles,i+1,j,!f,dp),piles[j]+solve(piles,i,j-1,!f,dp));\\n        \\n        return dp[i][j]=min(solve(piles,i+1,j,!f,dp)-piles[i],solve(piles,i,j-1,!f,dp)-piles[j]);\\n    }\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return solve(piles,0,n-1,1,dp)>0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755852,
                "title": "just-1-line-code-runtime-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704111,
                "title": "easy-solution-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        int a = 0;\\n        int b = 0;\\n        int n = piles.length;\\n        for(int i = 0; i < n/2; i++) {\\n            int min = piles[i];\\n            int max = piles[n-1-i];\\n            a += Math.max(max, min);\\n            b += Math.min(max, min);\\n        }\\n        return a>b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        int a = 0;\\n        int b = 0;\\n        int n = piles.length;\\n        for(int i = 0; i < n/2; i++) {\\n            int min = piles[i];\\n            int max = piles[n-1-i];\\n            a += Math.max(max, min);\\n            b += Math.min(max, min);\\n        }\\n        return a>b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638300,
                "title": "what-the-hell-beats-100-code-easy-explanation",
                "content": "see alice is so smart, he knows the way to take so that bob will always lose...\\n\\n\\nfor eg, \\nin test case\\n3,7,2,3\\nalice will pick the 3 on the right instead of the 3 on thr left at start, why so?????\\n\\nbecause if she picks a 3 from the left, bob will pick the 7 in the next move in which bob will win\\n\\nso alice will always pick the path , in which bob looses\\n\\nthe winner was decided in the first move itself, the code is just for clarification\\n\\nyou could simply return true; \\n\\n# Code\\n```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return helper3(piles);\\n    }\\n    public boolean helper3(int[] piles) {\\n        int stonesBob = 0;\\n        int stonesAlice = 0;\\n        int i = 0, j = piles.length - 1;\\n        while (i < j) {\\n            if (piles[i] > piles[j]) {\\n                stonesAlice += piles[i];\\n                stonesBob += piles[j];\\n                i++;\\n                j--;\\n            } else {\\n                stonesAlice += piles[j];\\n                stonesBob += piles[i];\\n                i++;\\n                j--;\\n            }\\n        }\\n        if (stonesAlice > stonesBob) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        return helper3(piles);\\n    }\\n    public boolean helper3(int[] piles) {\\n        int stonesBob = 0;\\n        int stonesAlice = 0;\\n        int i = 0, j = piles.length - 1;\\n        while (i < j) {\\n            if (piles[i] > piles[j]) {\\n                stonesAlice += piles[i];\\n                stonesBob += piles[j];\\n                i++;\\n                j--;\\n            } else {\\n                stonesAlice += piles[j];\\n                stonesBob += piles[i];\\n                i++;\\n                j--;\\n            }\\n        }\\n        if (stonesAlice > stonesBob) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572441,
                "title": "classic-easy-memo-style",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def stoneGame(self, nums: List[int]) -> bool:\\n\\n\\n        dp = {}\\n        def dfs(l,r,alic_turn):\\n\\n            if (l,r,alic_turn) in dp:\\n                return dp[(l,r,alic_turn)]\\n                \\n            if l >= r:\\n                return 0\\n\\n            a = 0\\n            b = 0\\n            if alic_turn:\\n                # alic takes from front or from back, \\n                # whatever one leads to a better score thats why max()\\n                a = max(dfs(l,r-1, not alic_turn)+nums[r] , dfs(l+1,r, not alic_turn)+nums[l])\\n            else:\\n                # bob takes from front or from back, \\n                # whatever one leads to a better score  \\n                b = max(dfs(l,r-1, not alic_turn) +nums[r], dfs(l+1,r, not alic_turn)+nums[l])\\n            \\n\\n            dp[(l,r,alic_turn)]  = a > b\\n            return a > b\\n\\n\\n        return  dfs(0,len(nums)-1,True)\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, nums: List[int]) -> bool:\\n\\n\\n        dp = {}\\n        def dfs(l,r,alic_turn):\\n\\n            if (l,r,alic_turn) in dp:\\n                return dp[(l,r,alic_turn)]\\n                \\n            if l >= r:\\n                return 0\\n\\n            a = 0\\n            b = 0\\n            if alic_turn:\\n                # alic takes from front or from back, \\n                # whatever one leads to a better score thats why max()\\n                a = max(dfs(l,r-1, not alic_turn)+nums[r] , dfs(l+1,r, not alic_turn)+nums[l])\\n            else:\\n                # bob takes from front or from back, \\n                # whatever one leads to a better score  \\n                b = max(dfs(l,r-1, not alic_turn) +nums[r], dfs(l+1,r, not alic_turn)+nums[l])\\n            \\n\\n            dp[(l,r,alic_turn)]  = a > b\\n            return a > b\\n\\n\\n        return  dfs(0,len(nums)-1,True)\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571966,
                "title": "o-1-time-solution-p",
                "content": "# Intuition\\nAlice always wins.\\n\\n# Code\\n```\\nfunc stoneGame(piles []int) bool {\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc stoneGame(piles []int) bool {\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565279,
                "title": "python-3-dp",
                "content": "# Intuition\\ndp\\n\\n# Approach\\ndp\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n^2)\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n\\n        n: int = len(piles)\\n        first: List[List[int]] = [[0] * n for _ in range(n)]\\n        second: List[List[int]] = [[0] * n for _ in range(n)]\\n        for j in range(n):\\n            first[j][j] = piles[j]\\n            for i in range(j - 1, -1, -1):\\n                first[i][j] = max(piles[i] + second[i + 1][j], piles[j] + second[i][j - 1])\\n                second[i][j] = min(first[i + 1][j], first[i][j - 1])\\n        \\n        return first[n-1][n-1] > second[n-1][n-1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n\\n        n: int = len(piles)\\n        first: List[List[int]] = [[0] * n for _ in range(n)]\\n        second: List[List[int]] = [[0] * n for _ in range(n)]\\n        for j in range(n):\\n            first[j][j] = piles[j]\\n            for i in range(j - 1, -1, -1):\\n                first[i][j] = max(piles[i] + second[i + 1][j], piles[j] + second[i][j - 1])\\n                second[i][j] = min(first[i + 1][j], first[i][j - 1])\\n        \\n        return first[n-1][n-1] > second[n-1][n-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563672,
                "title": "simple-check-for-even-or-odd-faster",
                "content": "To determine whether Alice or Bob will win the game, we need to analyze the game\\'s strategy and consider the initial configuration of piles.\\n\\nLet\\'s consider an example to illustrate the strategy:\\n\\nPiles: [5, 3, 4, 5]\\n\\nAlice starts the game, and the total number of stones across all piles is 17, which is an odd number.\\n\\nAt each turn, a player can choose to take the entire pile of stones from either the beginning or the end of the row. Both players aim to maximize the total number of stones they collect.\\n\\nAlice has the first move, so she has the opportunity to establish an advantage over Bob.\\n\\nAlice\\'s strategy:\\nAlice wants to ensure that the total number of stones she collects is greater than or equal to the total number of stones Bob collects.\\n\\nTo achieve this, Alice can adopt the following approach:\\n\\n1. Alice selects the first pile with 5 stones from the beginning.\\n   Piles: [3, 4, 5]\\n\\n2. Bob is now forced to choose either the first pile (3 stones) or the last pile (5 stones).\\n   Bob chooses the last pile.\\n   Piles: [3, 4]\\n\\n3. Alice now has two options: either the first pile (3 stones) or the last pile (4 stones).\\n   Alice chooses the last pile.\\n   Piles: [3]\\n\\n4. Bob has only one option left, which is the first pile with 3 stones.\\n   Piles: []\\n\\nAt this point, no piles remain, and the game is over. Alice collected a total of 9 stones, while Bob collected 8 stones.\\n\\nSince Alice has more stones than Bob, she wins the game.\\n\\nIn general, Alice can use a strategy known as \"greedy strategy\" to ensure victory. She aims to maximize the number of stones she collects at each turn, forcing Bob to settle for fewer stones.\\n\\nTherefore, given that Alice plays optimally, she will win the game if and only if the initial total number of stones across all piles is odd.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=piles[i];\\n        }\\n        if(sum%2==0) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        int n=piles.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=piles[i];\\n        }\\n        if(sum%2==0) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530758,
                "title": "always-true-stone-game-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/6de4dd90-8837-4eca-a560-bd1384f947a9_1684239785.8552122.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508578,
                "title": "easy-dp-solution-java-recursion-memorization",
                "content": "```\\nclass Solution {\\n    int[] nums;\\n    Boolean[][] dp;\\n    public boolean stoneGame(int[] piles) {\\n        this.nums = piles;\\n        this.dp = new Boolean[piles.length][piles.length];\\n        return helper(0, piles.length - 1, 0, 0, true);\\n    }\\n    public boolean helper(int i, int j, int count1, int count2, boolean turn) {\\n        if(i > j) {\\n            if(count1 > count2) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n        if(dp[i][j] != null) return dp[i][j];\\n        boolean take = false;\\n        if(turn) {\\n            take = helper(i + 1, j, count1 + nums[i], count2, false) || helper(i, j - 1, count1 + nums[j], count2, false);\\n        } else {\\n            take = helper(i + 1, j, count1, count2  + nums[i], true) || helper(i, j - 1, count1, count2 + nums[j], true);\\n        }\\n        return dp[i][j] = take;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int[] nums;\\n    Boolean[][] dp;\\n    public boolean stoneGame(int[] piles) {\\n        this.nums = piles;\\n        this.dp = new Boolean[piles.length][piles.length];\\n        return helper(0, piles.length - 1, 0, 0, true);\\n    }\\n    public boolean helper(int i, int j, int count1, int count2, boolean turn) {\\n        if(i > j) {\\n            if(count1 > count2) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n        if(dp[i][j] != null) return dp[i][j];\\n        boolean take = false;\\n        if(turn) {\\n            take = helper(i + 1, j, count1 + nums[i], count2, false) || helper(i, j - 1, count1 + nums[j], count2, false);\\n        } else {\\n            take = helper(i + 1, j, count1, count2  + nums[i], true) || helper(i, j - 1, count1, count2 + nums[j], true);\\n        }\\n        return dp[i][j] = take;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419295,
                "title": "simple-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        int aliceStones =0;\\n        int bobStones = 0;\\n\\n        LinkedList<Integer> list = new LinkedList<>();\\n        for (int i: piles){\\n            list.add (i);\\n        }\\n\\n        for (int round=0; round < piles.length /2; round++){\\n            int first = list.get(0);\\n            int last = list.get(list.size()-1);\\n\\n            aliceStones += Math.max (first, last);\\n            bobStones += Math.min (first, last);   \\n            \\n            list.removeFirst();\\n            list.removeLast();\\n        }\\n        \\n        return aliceStones > bobStones;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean stoneGame(int[] piles) {\\n        int aliceStones =0;\\n        int bobStones = 0;\\n\\n        LinkedList<Integer> list = new LinkedList<>();\\n        for (int i: piles){\\n            list.add (i);\\n        }\\n\\n        for (int round=0; round < piles.length /2; round++){\\n            int first = list.get(0);\\n            int last = list.get(list.size()-1);\\n\\n            aliceStones += Math.max (first, last);\\n            bobStones += Math.min (first, last);   \\n            \\n            list.removeFirst();\\n            list.removeLast();\\n        }\\n        \\n        return aliceStones > bobStones;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566897,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1565768,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1572939,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1569412,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1565761,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1570009,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1566297,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1570427,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1569636,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1568105,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1566897,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1565768,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1572939,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1569412,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1565761,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1570009,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1566297,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1570427,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1569636,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1568105,
                "content": [
                    {
                        "username": "qqdipps",
                        "content": "Does Alex always go first?\\nCan he count the stones in all the piles before he starts?\\nCan he plan ahead?\\n\\ngiven that there is an odd number of stones and even number of piles and there will always be a winner and players will play optimally and the assumptive answers to the questions above is ALEX WILL ALWAYS WIN so KISS (keep it simple silly) and return true."
                    },
                    {
                        "username": "TheInfamousTony",
                        "content": "who\\'s alex? btw good explanation"
                    },
                    {
                        "username": "Hai_dee",
                        "content": "I finally came up with a dynamic programming solution, and was suspicious that I never did find an example of player 1 losing. So I put \"return True\" in and submitted, hoping it\\'d pop up with an example my code was wrong. i.e. where player 2 wins. Yeah, lol."
                    },
                    {
                        "username": "confused-coder",
                        "content": "Lmao I wrote a 30 line code before realising and returned true"
                    },
                    {
                        "username": "surajdesai",
                        "content": "just \\n\\nreturn true;\\nridiculous"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "[@AbhayDutt](/AbhayDutt)  Meanwhile idecoded an hour and then tried doing return true after reading this comment . Boom subbmitted. I feel sorry for myself now"
                    },
                    {
                        "username": "AbhayDutt",
                        "content": "i thought you were trolling,but..........."
                    },
                    {
                        "username": "_zgsdr",
                        "content": "For any case, Alex will win \\nbecause:\\nFirstly, we can divide the stones by their index(odd,even)\\nlike 5,4,5,3\\nso the total value of stones with even index is :  sumEven :5 + 5 = 10\\nthe total value of stones with odd index is : sumOdd: 4 + 3\\n\\nnote\"The total number of stones is odd, so there are no ties.\"\\nso sumEven will not be equal with sumOdd\\nBecase Alex chooses stone first \\nso if sumEven > sumOdd\\nthen he can always choose stones with even index\\nif sumEven < sumOdd\\nthen he can always choose stones with odd index\\nso, Alex will always win this game \\n\\nwe only need to return true."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "Who is Alex LMAO :)"
                    },
                    {
                        "username": "Hexadecimal",
                        "content": "If sum of odd indices is greater, he chooses the last one first, and no matter what the opponent chooses, he always take the next available pile with odd index, and vice versa. Either way he wins."
                    },
                    {
                        "username": "Tee-Jay",
                        "content": "We are given that :\\n1) the number of piles is always even.\\n2) Alex always moves first\\n3) The total number of stones is odd, therefore, impossiblity of a tie\\n\\ngiven that alex always move first, alex is able to make certain that she always choses iether the odd indices or even indices, for example:\\n\\n\\ta b c d e f (letters represent piles)\\n\\t0 1 2 3 4 5 (indices)\\nalex can chose iether a or f \\nsay alex chooses \\'a\\' \\nlee is left with b c d e f\\ndoesnt matter what lee chooses now , alex will always have the option to choose c or e in the next turn\\n\\nthus by this logic we can make sure that alex is able to choose iether odd or even index piles EVERYTIME\\n\\ntherefore,alex simply makes sure that she chooses whichever indices\\' sum is max (odd idices or even indices).\\n\\nHence proved that when alex plays optimally, she always wins"
                    },
                    {
                        "username": "AceAceIce",
                        "content": "This question should ask you if there is chance Alex loss the game. \\n\\nFor example, [3,7,2,3] Alex pick 3, Lee pick 7, Alex pick 3 then Alex will lost. The question will become medium level???"
                    },
                    {
                        "username": "madhavsinghabcde",
                        "content": "[@vmikael](/vmikael) thanks, u cleared my confusion!!! :)\\n"
                    },
                    {
                        "username": "SwapnilJain",
                        "content": "This should be added to the question. "
                    },
                    {
                        "username": "vmikael",
                        "content": "The thing is: Alex plays OPTIMALLY, so he will pick the 3 at the end, leaving [3, 7, 2]. Next round Alex will take 7."
                    },
                    {
                        "username": "shaykhjake",
                        "content": "If you just want points, simply return true, because the challenge is making bad assumptions. With as many as 500 piles and 500 stones in each pile, there is simply no way that Alex will know if he should play odd or even. The best that he and Lee can do is compare the first pile with the last pile, and this is the method that is implied in challenge specs. However, this will lead you to wrong answers from time to time.\\n\\nBased on the way the code is set up, Alex will always win (as noted by many others), because apparetnly he\\'s like Rainman and can count all of the stones in all of the piles and know which path to choose. Such a game is incredibly stupid, and nobody would play it in real life.\\n\\nIf you are trying to truly challenge yourself, skip this problem and move on to something else."
                    },
                    {
                        "username": "mehvix",
                        "content": "This is the penultimate greedy problem -- the skill lies with being able to recognize and understand why it is the case that, if playing optimally, Alice cannot loose. The argument that \\'Alice isn\\'t rainman and couldn\\'t do the the mental math and thus we can\\'t assume is playing optimally\\' is facile. "
                    },
                    {
                        "username": "charliemsk",
                        "content": "I totally agree. I think it should be played as compare first vs last. Also agree it is incredibly stupid. "
                    },
                    {
                        "username": "LakshmiPandey",
                        "content": "Alex will always win ,,,\\nas the given sum(piles) will always be odd(given in the question)\\nO(1)"
                    },
                    {
                        "username": "toberich",
                        "content": "duplicate to Predict the Winner 486"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I thought so to, but it isn\\'t exactly, the input is larger here, so my code from there gives TLE here. Also here you can just always return true, whereas in that problem there are cases where you should return false. "
                    },
                    {
                        "username": "RedHessian",
                        "content": "Funny how this problem got downvoted and the 486 didn\\'t, simply because \"the game would be stupid irl\""
                    }
                ]
            },
            {
                "id": 1787095,
                "content": [
                    {
                        "username": "Muliya_Dev",
                        "content": "##### this question is a test for leetcode complexity distribution chart :)"
                    },
                    {
                        "username": "ashish39",
                        "content": "I dont know why lee is at all playing this game, is he dumb??"
                    },
                    {
                        "username": "sudshek",
                        "content": "I returned true and it got accepted. Since alex gets to play first , he chooses the most optimal way to play the game and out of the two players the only one who gets to win is Alex. Correct me if I am wrong!"
                    },
                    {
                        "username": "saikat93ify",
                        "content": "I have written an editorial of this problem [here](http://qr.ae/TUIWOE). "
                    },
                    {
                        "username": "user9811l",
                        "content": "for case 3,7,2,3 how does alex wins can somebody explain?"
                    },
                    {
                        "username": "cpt_mikhnovsky",
                        "content": "Alice picks the last 3, Bob has [3,7,2] to choose from. No matter what Bob picks, Alice will take 7 and win 10 to 5."
                    },
                    {
                        "username": "umairabid",
                        "content": "If alex plays first and always play optimally she is going to take the best available which means she will always maintain highest score than Lee no matter what, so just return the damn true"
                    },
                    {
                        "username": "Sweet-XYZ",
                        "content": "When I first saw the problem, \\nI was like \"Wait a second, can Alex ever lose if he can start first? But that would be too easy.\"\\nThen I suddenly noticed the contributor\\'s name ----- \"lee215\".\\nYep! I just returned true without hasitating. lol\\n"
                    },
                    {
                        "username": "alexinnkennu",
                        "content": "if the lee play optimally, why he choses the small one?"
                    },
                    {
                        "username": "user7290uq",
                        "content": "If taking the larger pile will expose a \\'huge\\' pile for Bob to take, Alice should instead choose the smaller pile that exposes a small pile to Bob. Example: [1, 4, 7, 3], Alice should choose 1 and not 3."
                    },
                    {
                        "username": "leetNinjaX",
                        "content": "So Alex can pick all odd stones or all even stones if he goes first. Hence he can alway at least draw the game if he starts first. But, we are given that sum of all stones is odd, hence just return true. \\n\\nYou should also refer to https://articles.leetcode.com/coins-in-line/ for better version of question."
                    },
                    {
                        "username": "ashmit007",
                        "content": "Just two word\\n`return True`\\nThat\\'s it"
                    }
                ]
            },
            {
                "id": 1573759,
                "content": [
                    {
                        "username": "Muliya_Dev",
                        "content": "##### this question is a test for leetcode complexity distribution chart :)"
                    },
                    {
                        "username": "ashish39",
                        "content": "I dont know why lee is at all playing this game, is he dumb??"
                    },
                    {
                        "username": "sudshek",
                        "content": "I returned true and it got accepted. Since alex gets to play first , he chooses the most optimal way to play the game and out of the two players the only one who gets to win is Alex. Correct me if I am wrong!"
                    },
                    {
                        "username": "saikat93ify",
                        "content": "I have written an editorial of this problem [here](http://qr.ae/TUIWOE). "
                    },
                    {
                        "username": "user9811l",
                        "content": "for case 3,7,2,3 how does alex wins can somebody explain?"
                    },
                    {
                        "username": "cpt_mikhnovsky",
                        "content": "Alice picks the last 3, Bob has [3,7,2] to choose from. No matter what Bob picks, Alice will take 7 and win 10 to 5."
                    },
                    {
                        "username": "umairabid",
                        "content": "If alex plays first and always play optimally she is going to take the best available which means she will always maintain highest score than Lee no matter what, so just return the damn true"
                    },
                    {
                        "username": "Sweet-XYZ",
                        "content": "When I first saw the problem, \\nI was like \"Wait a second, can Alex ever lose if he can start first? But that would be too easy.\"\\nThen I suddenly noticed the contributor\\'s name ----- \"lee215\".\\nYep! I just returned true without hasitating. lol\\n"
                    },
                    {
                        "username": "alexinnkennu",
                        "content": "if the lee play optimally, why he choses the small one?"
                    },
                    {
                        "username": "user7290uq",
                        "content": "If taking the larger pile will expose a \\'huge\\' pile for Bob to take, Alice should instead choose the smaller pile that exposes a small pile to Bob. Example: [1, 4, 7, 3], Alice should choose 1 and not 3."
                    },
                    {
                        "username": "leetNinjaX",
                        "content": "So Alex can pick all odd stones or all even stones if he goes first. Hence he can alway at least draw the game if he starts first. But, we are given that sum of all stones is odd, hence just return true. \\n\\nYou should also refer to https://articles.leetcode.com/coins-in-line/ for better version of question."
                    },
                    {
                        "username": "ashmit007",
                        "content": "Just two word\\n`return True`\\nThat\\'s it"
                    }
                ]
            },
            {
                "id": 1572473,
                "content": [
                    {
                        "username": "Muliya_Dev",
                        "content": "##### this question is a test for leetcode complexity distribution chart :)"
                    },
                    {
                        "username": "ashish39",
                        "content": "I dont know why lee is at all playing this game, is he dumb??"
                    },
                    {
                        "username": "sudshek",
                        "content": "I returned true and it got accepted. Since alex gets to play first , he chooses the most optimal way to play the game and out of the two players the only one who gets to win is Alex. Correct me if I am wrong!"
                    },
                    {
                        "username": "saikat93ify",
                        "content": "I have written an editorial of this problem [here](http://qr.ae/TUIWOE). "
                    },
                    {
                        "username": "user9811l",
                        "content": "for case 3,7,2,3 how does alex wins can somebody explain?"
                    },
                    {
                        "username": "cpt_mikhnovsky",
                        "content": "Alice picks the last 3, Bob has [3,7,2] to choose from. No matter what Bob picks, Alice will take 7 and win 10 to 5."
                    },
                    {
                        "username": "umairabid",
                        "content": "If alex plays first and always play optimally she is going to take the best available which means she will always maintain highest score than Lee no matter what, so just return the damn true"
                    },
                    {
                        "username": "Sweet-XYZ",
                        "content": "When I first saw the problem, \\nI was like \"Wait a second, can Alex ever lose if he can start first? But that would be too easy.\"\\nThen I suddenly noticed the contributor\\'s name ----- \"lee215\".\\nYep! I just returned true without hasitating. lol\\n"
                    },
                    {
                        "username": "alexinnkennu",
                        "content": "if the lee play optimally, why he choses the small one?"
                    },
                    {
                        "username": "user7290uq",
                        "content": "If taking the larger pile will expose a \\'huge\\' pile for Bob to take, Alice should instead choose the smaller pile that exposes a small pile to Bob. Example: [1, 4, 7, 3], Alice should choose 1 and not 3."
                    },
                    {
                        "username": "leetNinjaX",
                        "content": "So Alex can pick all odd stones or all even stones if he goes first. Hence he can alway at least draw the game if he starts first. But, we are given that sum of all stones is odd, hence just return true. \\n\\nYou should also refer to https://articles.leetcode.com/coins-in-line/ for better version of question."
                    },
                    {
                        "username": "ashmit007",
                        "content": "Just two word\\n`return True`\\nThat\\'s it"
                    }
                ]
            },
            {
                "id": 1569266,
                "content": [
                    {
                        "username": "Muliya_Dev",
                        "content": "##### this question is a test for leetcode complexity distribution chart :)"
                    },
                    {
                        "username": "ashish39",
                        "content": "I dont know why lee is at all playing this game, is he dumb??"
                    },
                    {
                        "username": "sudshek",
                        "content": "I returned true and it got accepted. Since alex gets to play first , he chooses the most optimal way to play the game and out of the two players the only one who gets to win is Alex. Correct me if I am wrong!"
                    },
                    {
                        "username": "saikat93ify",
                        "content": "I have written an editorial of this problem [here](http://qr.ae/TUIWOE). "
                    },
                    {
                        "username": "user9811l",
                        "content": "for case 3,7,2,3 how does alex wins can somebody explain?"
                    },
                    {
                        "username": "cpt_mikhnovsky",
                        "content": "Alice picks the last 3, Bob has [3,7,2] to choose from. No matter what Bob picks, Alice will take 7 and win 10 to 5."
                    },
                    {
                        "username": "umairabid",
                        "content": "If alex plays first and always play optimally she is going to take the best available which means she will always maintain highest score than Lee no matter what, so just return the damn true"
                    },
                    {
                        "username": "Sweet-XYZ",
                        "content": "When I first saw the problem, \\nI was like \"Wait a second, can Alex ever lose if he can start first? But that would be too easy.\"\\nThen I suddenly noticed the contributor\\'s name ----- \"lee215\".\\nYep! I just returned true without hasitating. lol\\n"
                    },
                    {
                        "username": "alexinnkennu",
                        "content": "if the lee play optimally, why he choses the small one?"
                    },
                    {
                        "username": "user7290uq",
                        "content": "If taking the larger pile will expose a \\'huge\\' pile for Bob to take, Alice should instead choose the smaller pile that exposes a small pile to Bob. Example: [1, 4, 7, 3], Alice should choose 1 and not 3."
                    },
                    {
                        "username": "leetNinjaX",
                        "content": "So Alex can pick all odd stones or all even stones if he goes first. Hence he can alway at least draw the game if he starts first. But, we are given that sum of all stones is odd, hence just return true. \\n\\nYou should also refer to https://articles.leetcode.com/coins-in-line/ for better version of question."
                    },
                    {
                        "username": "ashmit007",
                        "content": "Just two word\\n`return True`\\nThat\\'s it"
                    }
                ]
            },
            {
                "id": 1575051,
                "content": [
                    {
                        "username": "Muliya_Dev",
                        "content": "##### this question is a test for leetcode complexity distribution chart :)"
                    },
                    {
                        "username": "ashish39",
                        "content": "I dont know why lee is at all playing this game, is he dumb??"
                    },
                    {
                        "username": "sudshek",
                        "content": "I returned true and it got accepted. Since alex gets to play first , he chooses the most optimal way to play the game and out of the two players the only one who gets to win is Alex. Correct me if I am wrong!"
                    },
                    {
                        "username": "saikat93ify",
                        "content": "I have written an editorial of this problem [here](http://qr.ae/TUIWOE). "
                    },
                    {
                        "username": "user9811l",
                        "content": "for case 3,7,2,3 how does alex wins can somebody explain?"
                    },
                    {
                        "username": "cpt_mikhnovsky",
                        "content": "Alice picks the last 3, Bob has [3,7,2] to choose from. No matter what Bob picks, Alice will take 7 and win 10 to 5."
                    },
                    {
                        "username": "umairabid",
                        "content": "If alex plays first and always play optimally she is going to take the best available which means she will always maintain highest score than Lee no matter what, so just return the damn true"
                    },
                    {
                        "username": "Sweet-XYZ",
                        "content": "When I first saw the problem, \\nI was like \"Wait a second, can Alex ever lose if he can start first? But that would be too easy.\"\\nThen I suddenly noticed the contributor\\'s name ----- \"lee215\".\\nYep! I just returned true without hasitating. lol\\n"
                    },
                    {
                        "username": "alexinnkennu",
                        "content": "if the lee play optimally, why he choses the small one?"
                    },
                    {
                        "username": "user7290uq",
                        "content": "If taking the larger pile will expose a \\'huge\\' pile for Bob to take, Alice should instead choose the smaller pile that exposes a small pile to Bob. Example: [1, 4, 7, 3], Alice should choose 1 and not 3."
                    },
                    {
                        "username": "leetNinjaX",
                        "content": "So Alex can pick all odd stones or all even stones if he goes first. Hence he can alway at least draw the game if he starts first. But, we are given that sum of all stones is odd, hence just return true. \\n\\nYou should also refer to https://articles.leetcode.com/coins-in-line/ for better version of question."
                    },
                    {
                        "username": "ashmit007",
                        "content": "Just two word\\n`return True`\\nThat\\'s it"
                    }
                ]
            },
            {
                "id": 1575409,
                "content": [
                    {
                        "username": "Muliya_Dev",
                        "content": "##### this question is a test for leetcode complexity distribution chart :)"
                    },
                    {
                        "username": "ashish39",
                        "content": "I dont know why lee is at all playing this game, is he dumb??"
                    },
                    {
                        "username": "sudshek",
                        "content": "I returned true and it got accepted. Since alex gets to play first , he chooses the most optimal way to play the game and out of the two players the only one who gets to win is Alex. Correct me if I am wrong!"
                    },
                    {
                        "username": "saikat93ify",
                        "content": "I have written an editorial of this problem [here](http://qr.ae/TUIWOE). "
                    },
                    {
                        "username": "user9811l",
                        "content": "for case 3,7,2,3 how does alex wins can somebody explain?"
                    },
                    {
                        "username": "cpt_mikhnovsky",
                        "content": "Alice picks the last 3, Bob has [3,7,2] to choose from. No matter what Bob picks, Alice will take 7 and win 10 to 5."
                    },
                    {
                        "username": "umairabid",
                        "content": "If alex plays first and always play optimally she is going to take the best available which means she will always maintain highest score than Lee no matter what, so just return the damn true"
                    },
                    {
                        "username": "Sweet-XYZ",
                        "content": "When I first saw the problem, \\nI was like \"Wait a second, can Alex ever lose if he can start first? But that would be too easy.\"\\nThen I suddenly noticed the contributor\\'s name ----- \"lee215\".\\nYep! I just returned true without hasitating. lol\\n"
                    },
                    {
                        "username": "alexinnkennu",
                        "content": "if the lee play optimally, why he choses the small one?"
                    },
                    {
                        "username": "user7290uq",
                        "content": "If taking the larger pile will expose a \\'huge\\' pile for Bob to take, Alice should instead choose the smaller pile that exposes a small pile to Bob. Example: [1, 4, 7, 3], Alice should choose 1 and not 3."
                    },
                    {
                        "username": "leetNinjaX",
                        "content": "So Alex can pick all odd stones or all even stones if he goes first. Hence he can alway at least draw the game if he starts first. But, we are given that sum of all stones is odd, hence just return true. \\n\\nYou should also refer to https://articles.leetcode.com/coins-in-line/ for better version of question."
                    },
                    {
                        "username": "ashmit007",
                        "content": "Just two word\\n`return True`\\nThat\\'s it"
                    }
                ]
            },
            {
                "id": 1572395,
                "content": [
                    {
                        "username": "Muliya_Dev",
                        "content": "##### this question is a test for leetcode complexity distribution chart :)"
                    },
                    {
                        "username": "ashish39",
                        "content": "I dont know why lee is at all playing this game, is he dumb??"
                    },
                    {
                        "username": "sudshek",
                        "content": "I returned true and it got accepted. Since alex gets to play first , he chooses the most optimal way to play the game and out of the two players the only one who gets to win is Alex. Correct me if I am wrong!"
                    },
                    {
                        "username": "saikat93ify",
                        "content": "I have written an editorial of this problem [here](http://qr.ae/TUIWOE). "
                    },
                    {
                        "username": "user9811l",
                        "content": "for case 3,7,2,3 how does alex wins can somebody explain?"
                    },
                    {
                        "username": "cpt_mikhnovsky",
                        "content": "Alice picks the last 3, Bob has [3,7,2] to choose from. No matter what Bob picks, Alice will take 7 and win 10 to 5."
                    },
                    {
                        "username": "umairabid",
                        "content": "If alex plays first and always play optimally she is going to take the best available which means she will always maintain highest score than Lee no matter what, so just return the damn true"
                    },
                    {
                        "username": "Sweet-XYZ",
                        "content": "When I first saw the problem, \\nI was like \"Wait a second, can Alex ever lose if he can start first? But that would be too easy.\"\\nThen I suddenly noticed the contributor\\'s name ----- \"lee215\".\\nYep! I just returned true without hasitating. lol\\n"
                    },
                    {
                        "username": "alexinnkennu",
                        "content": "if the lee play optimally, why he choses the small one?"
                    },
                    {
                        "username": "user7290uq",
                        "content": "If taking the larger pile will expose a \\'huge\\' pile for Bob to take, Alice should instead choose the smaller pile that exposes a small pile to Bob. Example: [1, 4, 7, 3], Alice should choose 1 and not 3."
                    },
                    {
                        "username": "leetNinjaX",
                        "content": "So Alex can pick all odd stones or all even stones if he goes first. Hence he can alway at least draw the game if he starts first. But, we are given that sum of all stones is odd, hence just return true. \\n\\nYou should also refer to https://articles.leetcode.com/coins-in-line/ for better version of question."
                    },
                    {
                        "username": "ashmit007",
                        "content": "Just two word\\n`return True`\\nThat\\'s it"
                    }
                ]
            },
            {
                "id": 1572182,
                "content": [
                    {
                        "username": "Muliya_Dev",
                        "content": "##### this question is a test for leetcode complexity distribution chart :)"
                    },
                    {
                        "username": "ashish39",
                        "content": "I dont know why lee is at all playing this game, is he dumb??"
                    },
                    {
                        "username": "sudshek",
                        "content": "I returned true and it got accepted. Since alex gets to play first , he chooses the most optimal way to play the game and out of the two players the only one who gets to win is Alex. Correct me if I am wrong!"
                    },
                    {
                        "username": "saikat93ify",
                        "content": "I have written an editorial of this problem [here](http://qr.ae/TUIWOE). "
                    },
                    {
                        "username": "user9811l",
                        "content": "for case 3,7,2,3 how does alex wins can somebody explain?"
                    },
                    {
                        "username": "cpt_mikhnovsky",
                        "content": "Alice picks the last 3, Bob has [3,7,2] to choose from. No matter what Bob picks, Alice will take 7 and win 10 to 5."
                    },
                    {
                        "username": "umairabid",
                        "content": "If alex plays first and always play optimally she is going to take the best available which means she will always maintain highest score than Lee no matter what, so just return the damn true"
                    },
                    {
                        "username": "Sweet-XYZ",
                        "content": "When I first saw the problem, \\nI was like \"Wait a second, can Alex ever lose if he can start first? But that would be too easy.\"\\nThen I suddenly noticed the contributor\\'s name ----- \"lee215\".\\nYep! I just returned true without hasitating. lol\\n"
                    },
                    {
                        "username": "alexinnkennu",
                        "content": "if the lee play optimally, why he choses the small one?"
                    },
                    {
                        "username": "user7290uq",
                        "content": "If taking the larger pile will expose a \\'huge\\' pile for Bob to take, Alice should instead choose the smaller pile that exposes a small pile to Bob. Example: [1, 4, 7, 3], Alice should choose 1 and not 3."
                    },
                    {
                        "username": "leetNinjaX",
                        "content": "So Alex can pick all odd stones or all even stones if he goes first. Hence he can alway at least draw the game if he starts first. But, we are given that sum of all stones is odd, hence just return true. \\n\\nYou should also refer to https://articles.leetcode.com/coins-in-line/ for better version of question."
                    },
                    {
                        "username": "ashmit007",
                        "content": "Just two word\\n`return True`\\nThat\\'s it"
                    }
                ]
            },
            {
                "id": 1572054,
                "content": [
                    {
                        "username": "Muliya_Dev",
                        "content": "##### this question is a test for leetcode complexity distribution chart :)"
                    },
                    {
                        "username": "ashish39",
                        "content": "I dont know why lee is at all playing this game, is he dumb??"
                    },
                    {
                        "username": "sudshek",
                        "content": "I returned true and it got accepted. Since alex gets to play first , he chooses the most optimal way to play the game and out of the two players the only one who gets to win is Alex. Correct me if I am wrong!"
                    },
                    {
                        "username": "saikat93ify",
                        "content": "I have written an editorial of this problem [here](http://qr.ae/TUIWOE). "
                    },
                    {
                        "username": "user9811l",
                        "content": "for case 3,7,2,3 how does alex wins can somebody explain?"
                    },
                    {
                        "username": "cpt_mikhnovsky",
                        "content": "Alice picks the last 3, Bob has [3,7,2] to choose from. No matter what Bob picks, Alice will take 7 and win 10 to 5."
                    },
                    {
                        "username": "umairabid",
                        "content": "If alex plays first and always play optimally she is going to take the best available which means she will always maintain highest score than Lee no matter what, so just return the damn true"
                    },
                    {
                        "username": "Sweet-XYZ",
                        "content": "When I first saw the problem, \\nI was like \"Wait a second, can Alex ever lose if he can start first? But that would be too easy.\"\\nThen I suddenly noticed the contributor\\'s name ----- \"lee215\".\\nYep! I just returned true without hasitating. lol\\n"
                    },
                    {
                        "username": "alexinnkennu",
                        "content": "if the lee play optimally, why he choses the small one?"
                    },
                    {
                        "username": "user7290uq",
                        "content": "If taking the larger pile will expose a \\'huge\\' pile for Bob to take, Alice should instead choose the smaller pile that exposes a small pile to Bob. Example: [1, 4, 7, 3], Alice should choose 1 and not 3."
                    },
                    {
                        "username": "leetNinjaX",
                        "content": "So Alex can pick all odd stones or all even stones if he goes first. Hence he can alway at least draw the game if he starts first. But, we are given that sum of all stones is odd, hence just return true. \\n\\nYou should also refer to https://articles.leetcode.com/coins-in-line/ for better version of question."
                    },
                    {
                        "username": "ashmit007",
                        "content": "Just two word\\n`return True`\\nThat\\'s it"
                    }
                ]
            },
            {
                "id": 1568104,
                "content": [
                    {
                        "username": "Muliya_Dev",
                        "content": "##### this question is a test for leetcode complexity distribution chart :)"
                    },
                    {
                        "username": "ashish39",
                        "content": "I dont know why lee is at all playing this game, is he dumb??"
                    },
                    {
                        "username": "sudshek",
                        "content": "I returned true and it got accepted. Since alex gets to play first , he chooses the most optimal way to play the game and out of the two players the only one who gets to win is Alex. Correct me if I am wrong!"
                    },
                    {
                        "username": "saikat93ify",
                        "content": "I have written an editorial of this problem [here](http://qr.ae/TUIWOE). "
                    },
                    {
                        "username": "user9811l",
                        "content": "for case 3,7,2,3 how does alex wins can somebody explain?"
                    },
                    {
                        "username": "cpt_mikhnovsky",
                        "content": "Alice picks the last 3, Bob has [3,7,2] to choose from. No matter what Bob picks, Alice will take 7 and win 10 to 5."
                    },
                    {
                        "username": "umairabid",
                        "content": "If alex plays first and always play optimally she is going to take the best available which means she will always maintain highest score than Lee no matter what, so just return the damn true"
                    },
                    {
                        "username": "Sweet-XYZ",
                        "content": "When I first saw the problem, \\nI was like \"Wait a second, can Alex ever lose if he can start first? But that would be too easy.\"\\nThen I suddenly noticed the contributor\\'s name ----- \"lee215\".\\nYep! I just returned true without hasitating. lol\\n"
                    },
                    {
                        "username": "alexinnkennu",
                        "content": "if the lee play optimally, why he choses the small one?"
                    },
                    {
                        "username": "user7290uq",
                        "content": "If taking the larger pile will expose a \\'huge\\' pile for Bob to take, Alice should instead choose the smaller pile that exposes a small pile to Bob. Example: [1, 4, 7, 3], Alice should choose 1 and not 3."
                    },
                    {
                        "username": "leetNinjaX",
                        "content": "So Alex can pick all odd stones or all even stones if he goes first. Hence he can alway at least draw the game if he starts first. But, we are given that sum of all stones is odd, hence just return true. \\n\\nYou should also refer to https://articles.leetcode.com/coins-in-line/ for better version of question."
                    },
                    {
                        "username": "ashmit007",
                        "content": "Just two word\\n`return True`\\nThat\\'s it"
                    }
                ]
            },
            {
                "id": 1568743,
                "content": [
                    {
                        "username": "Ravi_mishra2001",
                        "content": "return true;"
                    },
                    {
                        "username": "deleted_user",
                        "content": "bois the ans will always be true ...heheheehhe\\nbcoz  if lets say u know the sum of all odd positions elements is more than even or visecersa u can pick only odd positions elements and force him to take even ..ex: 1 3 2 1\\nhere odd positions sum is more so initially you take 3rd index element which is at odd place then u see oponent has two choises but the elements are at even position so lets say he takes 2(at 2index) now u take 3 and only 1 is left ..hence u win guys......Lol"
                    },
                    {
                        "username": "f767475251",
                        "content": "Alex is going to win any way.\\nSo,\\n![image](https://assets.leetcode.com/users/images/2b2b1bec-bd67-4edc-b5b2-661f5d6e77ac_1628180404.9940305.png)\\n"
                    },
                    {
                        "username": "manishkhakhal",
                        "content": "Just return true bro."
                    },
                    {
                        "username": "Milanjakhotra1234",
                        "content": "return true;\\n"
                    },
                    {
                        "username": "hawkman76",
                        "content": "just return true;"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "`piles.length` is **even**, Alice starts first, both play optimally - both Alice and Bob have the same number of moves, so Alice will never lose\\n"
                    },
                    {
                        "username": "magikarfound_123",
                        "content": "Don\\'t look at approaches. upon analyzing this question from trial and error, it\\'s clear that bob has negative iq and alice is a grifter . the grifter always wins"
                    },
                    {
                        "username": "shivam060pansy",
                        "content": "In the second example, why didnt the bob win?\\n`First alice will pick 3. `\\nRemaining stones = [7,2,3]\\nBob can pick from beginning or from end. `He will pick 7 ofcourse.`\\n`At this point, alice=3 and Bob=7`\\nif alice takes 3, her total becomes 6.\\nBob will be left to pick 2 and his total will become 9.\\n`At the end, bob = 9 and alice = 6.`\\nClearly Bob wins. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Why does Bob like this game?"
                    }
                ]
            },
            {
                "id": 1570470,
                "content": [
                    {
                        "username": "Ravi_mishra2001",
                        "content": "return true;"
                    },
                    {
                        "username": "deleted_user",
                        "content": "bois the ans will always be true ...heheheehhe\\nbcoz  if lets say u know the sum of all odd positions elements is more than even or visecersa u can pick only odd positions elements and force him to take even ..ex: 1 3 2 1\\nhere odd positions sum is more so initially you take 3rd index element which is at odd place then u see oponent has two choises but the elements are at even position so lets say he takes 2(at 2index) now u take 3 and only 1 is left ..hence u win guys......Lol"
                    },
                    {
                        "username": "f767475251",
                        "content": "Alex is going to win any way.\\nSo,\\n![image](https://assets.leetcode.com/users/images/2b2b1bec-bd67-4edc-b5b2-661f5d6e77ac_1628180404.9940305.png)\\n"
                    },
                    {
                        "username": "manishkhakhal",
                        "content": "Just return true bro."
                    },
                    {
                        "username": "Milanjakhotra1234",
                        "content": "return true;\\n"
                    },
                    {
                        "username": "hawkman76",
                        "content": "just return true;"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "`piles.length` is **even**, Alice starts first, both play optimally - both Alice and Bob have the same number of moves, so Alice will never lose\\n"
                    },
                    {
                        "username": "magikarfound_123",
                        "content": "Don\\'t look at approaches. upon analyzing this question from trial and error, it\\'s clear that bob has negative iq and alice is a grifter . the grifter always wins"
                    },
                    {
                        "username": "shivam060pansy",
                        "content": "In the second example, why didnt the bob win?\\n`First alice will pick 3. `\\nRemaining stones = [7,2,3]\\nBob can pick from beginning or from end. `He will pick 7 ofcourse.`\\n`At this point, alice=3 and Bob=7`\\nif alice takes 3, her total becomes 6.\\nBob will be left to pick 2 and his total will become 9.\\n`At the end, bob = 9 and alice = 6.`\\nClearly Bob wins. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Why does Bob like this game?"
                    }
                ]
            },
            {
                "id": 1575617,
                "content": [
                    {
                        "username": "Ravi_mishra2001",
                        "content": "return true;"
                    },
                    {
                        "username": "deleted_user",
                        "content": "bois the ans will always be true ...heheheehhe\\nbcoz  if lets say u know the sum of all odd positions elements is more than even or visecersa u can pick only odd positions elements and force him to take even ..ex: 1 3 2 1\\nhere odd positions sum is more so initially you take 3rd index element which is at odd place then u see oponent has two choises but the elements are at even position so lets say he takes 2(at 2index) now u take 3 and only 1 is left ..hence u win guys......Lol"
                    },
                    {
                        "username": "f767475251",
                        "content": "Alex is going to win any way.\\nSo,\\n![image](https://assets.leetcode.com/users/images/2b2b1bec-bd67-4edc-b5b2-661f5d6e77ac_1628180404.9940305.png)\\n"
                    },
                    {
                        "username": "manishkhakhal",
                        "content": "Just return true bro."
                    },
                    {
                        "username": "Milanjakhotra1234",
                        "content": "return true;\\n"
                    },
                    {
                        "username": "hawkman76",
                        "content": "just return true;"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "`piles.length` is **even**, Alice starts first, both play optimally - both Alice and Bob have the same number of moves, so Alice will never lose\\n"
                    },
                    {
                        "username": "magikarfound_123",
                        "content": "Don\\'t look at approaches. upon analyzing this question from trial and error, it\\'s clear that bob has negative iq and alice is a grifter . the grifter always wins"
                    },
                    {
                        "username": "shivam060pansy",
                        "content": "In the second example, why didnt the bob win?\\n`First alice will pick 3. `\\nRemaining stones = [7,2,3]\\nBob can pick from beginning or from end. `He will pick 7 ofcourse.`\\n`At this point, alice=3 and Bob=7`\\nif alice takes 3, her total becomes 6.\\nBob will be left to pick 2 and his total will become 9.\\n`At the end, bob = 9 and alice = 6.`\\nClearly Bob wins. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Why does Bob like this game?"
                    }
                ]
            },
            {
                "id": 1575615,
                "content": [
                    {
                        "username": "Ravi_mishra2001",
                        "content": "return true;"
                    },
                    {
                        "username": "deleted_user",
                        "content": "bois the ans will always be true ...heheheehhe\\nbcoz  if lets say u know the sum of all odd positions elements is more than even or visecersa u can pick only odd positions elements and force him to take even ..ex: 1 3 2 1\\nhere odd positions sum is more so initially you take 3rd index element which is at odd place then u see oponent has two choises but the elements are at even position so lets say he takes 2(at 2index) now u take 3 and only 1 is left ..hence u win guys......Lol"
                    },
                    {
                        "username": "f767475251",
                        "content": "Alex is going to win any way.\\nSo,\\n![image](https://assets.leetcode.com/users/images/2b2b1bec-bd67-4edc-b5b2-661f5d6e77ac_1628180404.9940305.png)\\n"
                    },
                    {
                        "username": "manishkhakhal",
                        "content": "Just return true bro."
                    },
                    {
                        "username": "Milanjakhotra1234",
                        "content": "return true;\\n"
                    },
                    {
                        "username": "hawkman76",
                        "content": "just return true;"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "`piles.length` is **even**, Alice starts first, both play optimally - both Alice and Bob have the same number of moves, so Alice will never lose\\n"
                    },
                    {
                        "username": "magikarfound_123",
                        "content": "Don\\'t look at approaches. upon analyzing this question from trial and error, it\\'s clear that bob has negative iq and alice is a grifter . the grifter always wins"
                    },
                    {
                        "username": "shivam060pansy",
                        "content": "In the second example, why didnt the bob win?\\n`First alice will pick 3. `\\nRemaining stones = [7,2,3]\\nBob can pick from beginning or from end. `He will pick 7 ofcourse.`\\n`At this point, alice=3 and Bob=7`\\nif alice takes 3, her total becomes 6.\\nBob will be left to pick 2 and his total will become 9.\\n`At the end, bob = 9 and alice = 6.`\\nClearly Bob wins. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Why does Bob like this game?"
                    }
                ]
            },
            {
                "id": 1575614,
                "content": [
                    {
                        "username": "Ravi_mishra2001",
                        "content": "return true;"
                    },
                    {
                        "username": "deleted_user",
                        "content": "bois the ans will always be true ...heheheehhe\\nbcoz  if lets say u know the sum of all odd positions elements is more than even or visecersa u can pick only odd positions elements and force him to take even ..ex: 1 3 2 1\\nhere odd positions sum is more so initially you take 3rd index element which is at odd place then u see oponent has two choises but the elements are at even position so lets say he takes 2(at 2index) now u take 3 and only 1 is left ..hence u win guys......Lol"
                    },
                    {
                        "username": "f767475251",
                        "content": "Alex is going to win any way.\\nSo,\\n![image](https://assets.leetcode.com/users/images/2b2b1bec-bd67-4edc-b5b2-661f5d6e77ac_1628180404.9940305.png)\\n"
                    },
                    {
                        "username": "manishkhakhal",
                        "content": "Just return true bro."
                    },
                    {
                        "username": "Milanjakhotra1234",
                        "content": "return true;\\n"
                    },
                    {
                        "username": "hawkman76",
                        "content": "just return true;"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "`piles.length` is **even**, Alice starts first, both play optimally - both Alice and Bob have the same number of moves, so Alice will never lose\\n"
                    },
                    {
                        "username": "magikarfound_123",
                        "content": "Don\\'t look at approaches. upon analyzing this question from trial and error, it\\'s clear that bob has negative iq and alice is a grifter . the grifter always wins"
                    },
                    {
                        "username": "shivam060pansy",
                        "content": "In the second example, why didnt the bob win?\\n`First alice will pick 3. `\\nRemaining stones = [7,2,3]\\nBob can pick from beginning or from end. `He will pick 7 ofcourse.`\\n`At this point, alice=3 and Bob=7`\\nif alice takes 3, her total becomes 6.\\nBob will be left to pick 2 and his total will become 9.\\n`At the end, bob = 9 and alice = 6.`\\nClearly Bob wins. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Why does Bob like this game?"
                    }
                ]
            },
            {
                "id": 1575364,
                "content": [
                    {
                        "username": "Ravi_mishra2001",
                        "content": "return true;"
                    },
                    {
                        "username": "deleted_user",
                        "content": "bois the ans will always be true ...heheheehhe\\nbcoz  if lets say u know the sum of all odd positions elements is more than even or visecersa u can pick only odd positions elements and force him to take even ..ex: 1 3 2 1\\nhere odd positions sum is more so initially you take 3rd index element which is at odd place then u see oponent has two choises but the elements are at even position so lets say he takes 2(at 2index) now u take 3 and only 1 is left ..hence u win guys......Lol"
                    },
                    {
                        "username": "f767475251",
                        "content": "Alex is going to win any way.\\nSo,\\n![image](https://assets.leetcode.com/users/images/2b2b1bec-bd67-4edc-b5b2-661f5d6e77ac_1628180404.9940305.png)\\n"
                    },
                    {
                        "username": "manishkhakhal",
                        "content": "Just return true bro."
                    },
                    {
                        "username": "Milanjakhotra1234",
                        "content": "return true;\\n"
                    },
                    {
                        "username": "hawkman76",
                        "content": "just return true;"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "`piles.length` is **even**, Alice starts first, both play optimally - both Alice and Bob have the same number of moves, so Alice will never lose\\n"
                    },
                    {
                        "username": "magikarfound_123",
                        "content": "Don\\'t look at approaches. upon analyzing this question from trial and error, it\\'s clear that bob has negative iq and alice is a grifter . the grifter always wins"
                    },
                    {
                        "username": "shivam060pansy",
                        "content": "In the second example, why didnt the bob win?\\n`First alice will pick 3. `\\nRemaining stones = [7,2,3]\\nBob can pick from beginning or from end. `He will pick 7 ofcourse.`\\n`At this point, alice=3 and Bob=7`\\nif alice takes 3, her total becomes 6.\\nBob will be left to pick 2 and his total will become 9.\\n`At the end, bob = 9 and alice = 6.`\\nClearly Bob wins. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Why does Bob like this game?"
                    }
                ]
            },
            {
                "id": 2053587,
                "content": [
                    {
                        "username": "Ravi_mishra2001",
                        "content": "return true;"
                    },
                    {
                        "username": "deleted_user",
                        "content": "bois the ans will always be true ...heheheehhe\\nbcoz  if lets say u know the sum of all odd positions elements is more than even or visecersa u can pick only odd positions elements and force him to take even ..ex: 1 3 2 1\\nhere odd positions sum is more so initially you take 3rd index element which is at odd place then u see oponent has two choises but the elements are at even position so lets say he takes 2(at 2index) now u take 3 and only 1 is left ..hence u win guys......Lol"
                    },
                    {
                        "username": "f767475251",
                        "content": "Alex is going to win any way.\\nSo,\\n![image](https://assets.leetcode.com/users/images/2b2b1bec-bd67-4edc-b5b2-661f5d6e77ac_1628180404.9940305.png)\\n"
                    },
                    {
                        "username": "manishkhakhal",
                        "content": "Just return true bro."
                    },
                    {
                        "username": "Milanjakhotra1234",
                        "content": "return true;\\n"
                    },
                    {
                        "username": "hawkman76",
                        "content": "just return true;"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "`piles.length` is **even**, Alice starts first, both play optimally - both Alice and Bob have the same number of moves, so Alice will never lose\\n"
                    },
                    {
                        "username": "magikarfound_123",
                        "content": "Don\\'t look at approaches. upon analyzing this question from trial and error, it\\'s clear that bob has negative iq and alice is a grifter . the grifter always wins"
                    },
                    {
                        "username": "shivam060pansy",
                        "content": "In the second example, why didnt the bob win?\\n`First alice will pick 3. `\\nRemaining stones = [7,2,3]\\nBob can pick from beginning or from end. `He will pick 7 ofcourse.`\\n`At this point, alice=3 and Bob=7`\\nif alice takes 3, her total becomes 6.\\nBob will be left to pick 2 and his total will become 9.\\n`At the end, bob = 9 and alice = 6.`\\nClearly Bob wins. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Why does Bob like this game?"
                    }
                ]
            },
            {
                "id": 2047978,
                "content": [
                    {
                        "username": "Ravi_mishra2001",
                        "content": "return true;"
                    },
                    {
                        "username": "deleted_user",
                        "content": "bois the ans will always be true ...heheheehhe\\nbcoz  if lets say u know the sum of all odd positions elements is more than even or visecersa u can pick only odd positions elements and force him to take even ..ex: 1 3 2 1\\nhere odd positions sum is more so initially you take 3rd index element which is at odd place then u see oponent has two choises but the elements are at even position so lets say he takes 2(at 2index) now u take 3 and only 1 is left ..hence u win guys......Lol"
                    },
                    {
                        "username": "f767475251",
                        "content": "Alex is going to win any way.\\nSo,\\n![image](https://assets.leetcode.com/users/images/2b2b1bec-bd67-4edc-b5b2-661f5d6e77ac_1628180404.9940305.png)\\n"
                    },
                    {
                        "username": "manishkhakhal",
                        "content": "Just return true bro."
                    },
                    {
                        "username": "Milanjakhotra1234",
                        "content": "return true;\\n"
                    },
                    {
                        "username": "hawkman76",
                        "content": "just return true;"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "`piles.length` is **even**, Alice starts first, both play optimally - both Alice and Bob have the same number of moves, so Alice will never lose\\n"
                    },
                    {
                        "username": "magikarfound_123",
                        "content": "Don\\'t look at approaches. upon analyzing this question from trial and error, it\\'s clear that bob has negative iq and alice is a grifter . the grifter always wins"
                    },
                    {
                        "username": "shivam060pansy",
                        "content": "In the second example, why didnt the bob win?\\n`First alice will pick 3. `\\nRemaining stones = [7,2,3]\\nBob can pick from beginning or from end. `He will pick 7 ofcourse.`\\n`At this point, alice=3 and Bob=7`\\nif alice takes 3, her total becomes 6.\\nBob will be left to pick 2 and his total will become 9.\\n`At the end, bob = 9 and alice = 6.`\\nClearly Bob wins. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Why does Bob like this game?"
                    }
                ]
            },
            {
                "id": 2045540,
                "content": [
                    {
                        "username": "Ravi_mishra2001",
                        "content": "return true;"
                    },
                    {
                        "username": "deleted_user",
                        "content": "bois the ans will always be true ...heheheehhe\\nbcoz  if lets say u know the sum of all odd positions elements is more than even or visecersa u can pick only odd positions elements and force him to take even ..ex: 1 3 2 1\\nhere odd positions sum is more so initially you take 3rd index element which is at odd place then u see oponent has two choises but the elements are at even position so lets say he takes 2(at 2index) now u take 3 and only 1 is left ..hence u win guys......Lol"
                    },
                    {
                        "username": "f767475251",
                        "content": "Alex is going to win any way.\\nSo,\\n![image](https://assets.leetcode.com/users/images/2b2b1bec-bd67-4edc-b5b2-661f5d6e77ac_1628180404.9940305.png)\\n"
                    },
                    {
                        "username": "manishkhakhal",
                        "content": "Just return true bro."
                    },
                    {
                        "username": "Milanjakhotra1234",
                        "content": "return true;\\n"
                    },
                    {
                        "username": "hawkman76",
                        "content": "just return true;"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "`piles.length` is **even**, Alice starts first, both play optimally - both Alice and Bob have the same number of moves, so Alice will never lose\\n"
                    },
                    {
                        "username": "magikarfound_123",
                        "content": "Don\\'t look at approaches. upon analyzing this question from trial and error, it\\'s clear that bob has negative iq and alice is a grifter . the grifter always wins"
                    },
                    {
                        "username": "shivam060pansy",
                        "content": "In the second example, why didnt the bob win?\\n`First alice will pick 3. `\\nRemaining stones = [7,2,3]\\nBob can pick from beginning or from end. `He will pick 7 ofcourse.`\\n`At this point, alice=3 and Bob=7`\\nif alice takes 3, her total becomes 6.\\nBob will be left to pick 2 and his total will become 9.\\n`At the end, bob = 9 and alice = 6.`\\nClearly Bob wins. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Why does Bob like this game?"
                    }
                ]
            },
            {
                "id": 2033799,
                "content": [
                    {
                        "username": "Ravi_mishra2001",
                        "content": "return true;"
                    },
                    {
                        "username": "deleted_user",
                        "content": "bois the ans will always be true ...heheheehhe\\nbcoz  if lets say u know the sum of all odd positions elements is more than even or visecersa u can pick only odd positions elements and force him to take even ..ex: 1 3 2 1\\nhere odd positions sum is more so initially you take 3rd index element which is at odd place then u see oponent has two choises but the elements are at even position so lets say he takes 2(at 2index) now u take 3 and only 1 is left ..hence u win guys......Lol"
                    },
                    {
                        "username": "f767475251",
                        "content": "Alex is going to win any way.\\nSo,\\n![image](https://assets.leetcode.com/users/images/2b2b1bec-bd67-4edc-b5b2-661f5d6e77ac_1628180404.9940305.png)\\n"
                    },
                    {
                        "username": "manishkhakhal",
                        "content": "Just return true bro."
                    },
                    {
                        "username": "Milanjakhotra1234",
                        "content": "return true;\\n"
                    },
                    {
                        "username": "hawkman76",
                        "content": "just return true;"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "`piles.length` is **even**, Alice starts first, both play optimally - both Alice and Bob have the same number of moves, so Alice will never lose\\n"
                    },
                    {
                        "username": "magikarfound_123",
                        "content": "Don\\'t look at approaches. upon analyzing this question from trial and error, it\\'s clear that bob has negative iq and alice is a grifter . the grifter always wins"
                    },
                    {
                        "username": "shivam060pansy",
                        "content": "In the second example, why didnt the bob win?\\n`First alice will pick 3. `\\nRemaining stones = [7,2,3]\\nBob can pick from beginning or from end. `He will pick 7 ofcourse.`\\n`At this point, alice=3 and Bob=7`\\nif alice takes 3, her total becomes 6.\\nBob will be left to pick 2 and his total will become 9.\\n`At the end, bob = 9 and alice = 6.`\\nClearly Bob wins. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Why does Bob like this game?"
                    }
                ]
            },
            {
                "id": 2022866,
                "content": [
                    {
                        "username": "parul_010",
                        "content": "they shud just remove the condition  \"There are an even number of piles \" cos if there are even numbers of piles index will be from even to odd and alice will always have the option to pick  from both even and odd index"
                    },
                    {
                        "username": "pvsalunkhe2003",
                        "content": "for the test case:\\npiles = [6,9,4,3,9,8]\\nalice should lose right?\\nReason:\\nIf alice picks 6 first then, a: 6 b:9 a:8 b:9 a:4 b:3 thus a = 6+8+4 < b= 9+9+3\\nIf alice picks 8 first then, a:8 b:9 a:6 b:9 a:4 b:3\\nthus a = 8+6+4 < 9+9+3\\nbut the answer is given that alice wins\\nPlease fix this testcase"
                    },
                    {
                        "username": "nancynguyen",
                        "content": "in example 2: If Alice starts by taking pile 3 (from the beginning), Bob will indeed take pile 7 then the output should be false? still don\\'t get it"
                    },
                    {
                        "username": "user8104ko",
                        "content": "The Answer is return true;"
                    },
                    {
                        "username": "user8104ko",
                        "content": "We need not write that entire code because the first person always going to take larger value and that process continue and automatically the first person  must got more score then always the first person wins (and In the Question they gave us Alice takes first)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};@ [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "divyan_2002",
                        "content": "class Solution {\\npublic:\\n    int dp[501][501];\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(piles,0,piles.size()-1,1);\\n        cout<<ans;\\n        return ans>0;\\n    }\\n    int solve(vector<int>& piles,int start,int end,int alice){\\n        if(end<start) return 0;//base case\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n        \\n        int takefirst = 0,takelast = 0;\\n\\n        if(alice==1){\\n            takefirst = piles[start] + solve(piles,start+1,end,0);\\n            takelast  = piles[end] + solve(piles,start,end-1,0);\\n            return dp[start][end] = max(takefirst,takelast);\\n        }\\n        else{\\n            takefirst = -piles[start] + solve(piles,start+1,end,1);\\n            takelast =  -piles[end] + solve(piles,start,end-1,1);\\n            return dp[start][end] = min(takefirst,takelast);\\n        }\\n    }\\n};\\nis this solution valid, I am passing all cases but since only returning a true is also doing  a job i want to know it is actually correct or not."
                    },
                    {
                        "username": "Kathy99",
                        "content": "A classic game theory problem with first-mover advantage. if both players are rational, the first player will always win. "
                    },
                    {
                        "username": "_quack_quack",
                        "content": "why this problem has equal dislikes??\\n"
                    }
                ]
            },
            {
                "id": 2015746,
                "content": [
                    {
                        "username": "parul_010",
                        "content": "they shud just remove the condition  \"There are an even number of piles \" cos if there are even numbers of piles index will be from even to odd and alice will always have the option to pick  from both even and odd index"
                    },
                    {
                        "username": "pvsalunkhe2003",
                        "content": "for the test case:\\npiles = [6,9,4,3,9,8]\\nalice should lose right?\\nReason:\\nIf alice picks 6 first then, a: 6 b:9 a:8 b:9 a:4 b:3 thus a = 6+8+4 < b= 9+9+3\\nIf alice picks 8 first then, a:8 b:9 a:6 b:9 a:4 b:3\\nthus a = 8+6+4 < 9+9+3\\nbut the answer is given that alice wins\\nPlease fix this testcase"
                    },
                    {
                        "username": "nancynguyen",
                        "content": "in example 2: If Alice starts by taking pile 3 (from the beginning), Bob will indeed take pile 7 then the output should be false? still don\\'t get it"
                    },
                    {
                        "username": "user8104ko",
                        "content": "The Answer is return true;"
                    },
                    {
                        "username": "user8104ko",
                        "content": "We need not write that entire code because the first person always going to take larger value and that process continue and automatically the first person  must got more score then always the first person wins (and In the Question they gave us Alice takes first)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};@ [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "divyan_2002",
                        "content": "class Solution {\\npublic:\\n    int dp[501][501];\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(piles,0,piles.size()-1,1);\\n        cout<<ans;\\n        return ans>0;\\n    }\\n    int solve(vector<int>& piles,int start,int end,int alice){\\n        if(end<start) return 0;//base case\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n        \\n        int takefirst = 0,takelast = 0;\\n\\n        if(alice==1){\\n            takefirst = piles[start] + solve(piles,start+1,end,0);\\n            takelast  = piles[end] + solve(piles,start,end-1,0);\\n            return dp[start][end] = max(takefirst,takelast);\\n        }\\n        else{\\n            takefirst = -piles[start] + solve(piles,start+1,end,1);\\n            takelast =  -piles[end] + solve(piles,start,end-1,1);\\n            return dp[start][end] = min(takefirst,takelast);\\n        }\\n    }\\n};\\nis this solution valid, I am passing all cases but since only returning a true is also doing  a job i want to know it is actually correct or not."
                    },
                    {
                        "username": "Kathy99",
                        "content": "A classic game theory problem with first-mover advantage. if both players are rational, the first player will always win. "
                    },
                    {
                        "username": "_quack_quack",
                        "content": "why this problem has equal dislikes??\\n"
                    }
                ]
            },
            {
                "id": 2014594,
                "content": [
                    {
                        "username": "parul_010",
                        "content": "they shud just remove the condition  \"There are an even number of piles \" cos if there are even numbers of piles index will be from even to odd and alice will always have the option to pick  from both even and odd index"
                    },
                    {
                        "username": "pvsalunkhe2003",
                        "content": "for the test case:\\npiles = [6,9,4,3,9,8]\\nalice should lose right?\\nReason:\\nIf alice picks 6 first then, a: 6 b:9 a:8 b:9 a:4 b:3 thus a = 6+8+4 < b= 9+9+3\\nIf alice picks 8 first then, a:8 b:9 a:6 b:9 a:4 b:3\\nthus a = 8+6+4 < 9+9+3\\nbut the answer is given that alice wins\\nPlease fix this testcase"
                    },
                    {
                        "username": "nancynguyen",
                        "content": "in example 2: If Alice starts by taking pile 3 (from the beginning), Bob will indeed take pile 7 then the output should be false? still don\\'t get it"
                    },
                    {
                        "username": "user8104ko",
                        "content": "The Answer is return true;"
                    },
                    {
                        "username": "user8104ko",
                        "content": "We need not write that entire code because the first person always going to take larger value and that process continue and automatically the first person  must got more score then always the first person wins (and In the Question they gave us Alice takes first)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};@ [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "divyan_2002",
                        "content": "class Solution {\\npublic:\\n    int dp[501][501];\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(piles,0,piles.size()-1,1);\\n        cout<<ans;\\n        return ans>0;\\n    }\\n    int solve(vector<int>& piles,int start,int end,int alice){\\n        if(end<start) return 0;//base case\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n        \\n        int takefirst = 0,takelast = 0;\\n\\n        if(alice==1){\\n            takefirst = piles[start] + solve(piles,start+1,end,0);\\n            takelast  = piles[end] + solve(piles,start,end-1,0);\\n            return dp[start][end] = max(takefirst,takelast);\\n        }\\n        else{\\n            takefirst = -piles[start] + solve(piles,start+1,end,1);\\n            takelast =  -piles[end] + solve(piles,start,end-1,1);\\n            return dp[start][end] = min(takefirst,takelast);\\n        }\\n    }\\n};\\nis this solution valid, I am passing all cases but since only returning a true is also doing  a job i want to know it is actually correct or not."
                    },
                    {
                        "username": "Kathy99",
                        "content": "A classic game theory problem with first-mover advantage. if both players are rational, the first player will always win. "
                    },
                    {
                        "username": "_quack_quack",
                        "content": "why this problem has equal dislikes??\\n"
                    }
                ]
            },
            {
                "id": 2010838,
                "content": [
                    {
                        "username": "parul_010",
                        "content": "they shud just remove the condition  \"There are an even number of piles \" cos if there are even numbers of piles index will be from even to odd and alice will always have the option to pick  from both even and odd index"
                    },
                    {
                        "username": "pvsalunkhe2003",
                        "content": "for the test case:\\npiles = [6,9,4,3,9,8]\\nalice should lose right?\\nReason:\\nIf alice picks 6 first then, a: 6 b:9 a:8 b:9 a:4 b:3 thus a = 6+8+4 < b= 9+9+3\\nIf alice picks 8 first then, a:8 b:9 a:6 b:9 a:4 b:3\\nthus a = 8+6+4 < 9+9+3\\nbut the answer is given that alice wins\\nPlease fix this testcase"
                    },
                    {
                        "username": "nancynguyen",
                        "content": "in example 2: If Alice starts by taking pile 3 (from the beginning), Bob will indeed take pile 7 then the output should be false? still don\\'t get it"
                    },
                    {
                        "username": "user8104ko",
                        "content": "The Answer is return true;"
                    },
                    {
                        "username": "user8104ko",
                        "content": "We need not write that entire code because the first person always going to take larger value and that process continue and automatically the first person  must got more score then always the first person wins (and In the Question they gave us Alice takes first)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};@ [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "divyan_2002",
                        "content": "class Solution {\\npublic:\\n    int dp[501][501];\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(piles,0,piles.size()-1,1);\\n        cout<<ans;\\n        return ans>0;\\n    }\\n    int solve(vector<int>& piles,int start,int end,int alice){\\n        if(end<start) return 0;//base case\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n        \\n        int takefirst = 0,takelast = 0;\\n\\n        if(alice==1){\\n            takefirst = piles[start] + solve(piles,start+1,end,0);\\n            takelast  = piles[end] + solve(piles,start,end-1,0);\\n            return dp[start][end] = max(takefirst,takelast);\\n        }\\n        else{\\n            takefirst = -piles[start] + solve(piles,start+1,end,1);\\n            takelast =  -piles[end] + solve(piles,start,end-1,1);\\n            return dp[start][end] = min(takefirst,takelast);\\n        }\\n    }\\n};\\nis this solution valid, I am passing all cases but since only returning a true is also doing  a job i want to know it is actually correct or not."
                    },
                    {
                        "username": "Kathy99",
                        "content": "A classic game theory problem with first-mover advantage. if both players are rational, the first player will always win. "
                    },
                    {
                        "username": "_quack_quack",
                        "content": "why this problem has equal dislikes??\\n"
                    }
                ]
            },
            {
                "id": 2010837,
                "content": [
                    {
                        "username": "parul_010",
                        "content": "they shud just remove the condition  \"There are an even number of piles \" cos if there are even numbers of piles index will be from even to odd and alice will always have the option to pick  from both even and odd index"
                    },
                    {
                        "username": "pvsalunkhe2003",
                        "content": "for the test case:\\npiles = [6,9,4,3,9,8]\\nalice should lose right?\\nReason:\\nIf alice picks 6 first then, a: 6 b:9 a:8 b:9 a:4 b:3 thus a = 6+8+4 < b= 9+9+3\\nIf alice picks 8 first then, a:8 b:9 a:6 b:9 a:4 b:3\\nthus a = 8+6+4 < 9+9+3\\nbut the answer is given that alice wins\\nPlease fix this testcase"
                    },
                    {
                        "username": "nancynguyen",
                        "content": "in example 2: If Alice starts by taking pile 3 (from the beginning), Bob will indeed take pile 7 then the output should be false? still don\\'t get it"
                    },
                    {
                        "username": "user8104ko",
                        "content": "The Answer is return true;"
                    },
                    {
                        "username": "user8104ko",
                        "content": "We need not write that entire code because the first person always going to take larger value and that process continue and automatically the first person  must got more score then always the first person wins (and In the Question they gave us Alice takes first)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};@ [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "divyan_2002",
                        "content": "class Solution {\\npublic:\\n    int dp[501][501];\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(piles,0,piles.size()-1,1);\\n        cout<<ans;\\n        return ans>0;\\n    }\\n    int solve(vector<int>& piles,int start,int end,int alice){\\n        if(end<start) return 0;//base case\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n        \\n        int takefirst = 0,takelast = 0;\\n\\n        if(alice==1){\\n            takefirst = piles[start] + solve(piles,start+1,end,0);\\n            takelast  = piles[end] + solve(piles,start,end-1,0);\\n            return dp[start][end] = max(takefirst,takelast);\\n        }\\n        else{\\n            takefirst = -piles[start] + solve(piles,start+1,end,1);\\n            takelast =  -piles[end] + solve(piles,start,end-1,1);\\n            return dp[start][end] = min(takefirst,takelast);\\n        }\\n    }\\n};\\nis this solution valid, I am passing all cases but since only returning a true is also doing  a job i want to know it is actually correct or not."
                    },
                    {
                        "username": "Kathy99",
                        "content": "A classic game theory problem with first-mover advantage. if both players are rational, the first player will always win. "
                    },
                    {
                        "username": "_quack_quack",
                        "content": "why this problem has equal dislikes??\\n"
                    }
                ]
            },
            {
                "id": 1980454,
                "content": [
                    {
                        "username": "parul_010",
                        "content": "they shud just remove the condition  \"There are an even number of piles \" cos if there are even numbers of piles index will be from even to odd and alice will always have the option to pick  from both even and odd index"
                    },
                    {
                        "username": "pvsalunkhe2003",
                        "content": "for the test case:\\npiles = [6,9,4,3,9,8]\\nalice should lose right?\\nReason:\\nIf alice picks 6 first then, a: 6 b:9 a:8 b:9 a:4 b:3 thus a = 6+8+4 < b= 9+9+3\\nIf alice picks 8 first then, a:8 b:9 a:6 b:9 a:4 b:3\\nthus a = 8+6+4 < 9+9+3\\nbut the answer is given that alice wins\\nPlease fix this testcase"
                    },
                    {
                        "username": "nancynguyen",
                        "content": "in example 2: If Alice starts by taking pile 3 (from the beginning), Bob will indeed take pile 7 then the output should be false? still don\\'t get it"
                    },
                    {
                        "username": "user8104ko",
                        "content": "The Answer is return true;"
                    },
                    {
                        "username": "user8104ko",
                        "content": "We need not write that entire code because the first person always going to take larger value and that process continue and automatically the first person  must got more score then always the first person wins (and In the Question they gave us Alice takes first)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};@ [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "divyan_2002",
                        "content": "class Solution {\\npublic:\\n    int dp[501][501];\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(piles,0,piles.size()-1,1);\\n        cout<<ans;\\n        return ans>0;\\n    }\\n    int solve(vector<int>& piles,int start,int end,int alice){\\n        if(end<start) return 0;//base case\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n        \\n        int takefirst = 0,takelast = 0;\\n\\n        if(alice==1){\\n            takefirst = piles[start] + solve(piles,start+1,end,0);\\n            takelast  = piles[end] + solve(piles,start,end-1,0);\\n            return dp[start][end] = max(takefirst,takelast);\\n        }\\n        else{\\n            takefirst = -piles[start] + solve(piles,start+1,end,1);\\n            takelast =  -piles[end] + solve(piles,start,end-1,1);\\n            return dp[start][end] = min(takefirst,takelast);\\n        }\\n    }\\n};\\nis this solution valid, I am passing all cases but since only returning a true is also doing  a job i want to know it is actually correct or not."
                    },
                    {
                        "username": "Kathy99",
                        "content": "A classic game theory problem with first-mover advantage. if both players are rational, the first player will always win. "
                    },
                    {
                        "username": "_quack_quack",
                        "content": "why this problem has equal dislikes??\\n"
                    }
                ]
            },
            {
                "id": 1980451,
                "content": [
                    {
                        "username": "parul_010",
                        "content": "they shud just remove the condition  \"There are an even number of piles \" cos if there are even numbers of piles index will be from even to odd and alice will always have the option to pick  from both even and odd index"
                    },
                    {
                        "username": "pvsalunkhe2003",
                        "content": "for the test case:\\npiles = [6,9,4,3,9,8]\\nalice should lose right?\\nReason:\\nIf alice picks 6 first then, a: 6 b:9 a:8 b:9 a:4 b:3 thus a = 6+8+4 < b= 9+9+3\\nIf alice picks 8 first then, a:8 b:9 a:6 b:9 a:4 b:3\\nthus a = 8+6+4 < 9+9+3\\nbut the answer is given that alice wins\\nPlease fix this testcase"
                    },
                    {
                        "username": "nancynguyen",
                        "content": "in example 2: If Alice starts by taking pile 3 (from the beginning), Bob will indeed take pile 7 then the output should be false? still don\\'t get it"
                    },
                    {
                        "username": "user8104ko",
                        "content": "The Answer is return true;"
                    },
                    {
                        "username": "user8104ko",
                        "content": "We need not write that entire code because the first person always going to take larger value and that process continue and automatically the first person  must got more score then always the first person wins (and In the Question they gave us Alice takes first)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};@ [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "divyan_2002",
                        "content": "class Solution {\\npublic:\\n    int dp[501][501];\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(piles,0,piles.size()-1,1);\\n        cout<<ans;\\n        return ans>0;\\n    }\\n    int solve(vector<int>& piles,int start,int end,int alice){\\n        if(end<start) return 0;//base case\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n        \\n        int takefirst = 0,takelast = 0;\\n\\n        if(alice==1){\\n            takefirst = piles[start] + solve(piles,start+1,end,0);\\n            takelast  = piles[end] + solve(piles,start,end-1,0);\\n            return dp[start][end] = max(takefirst,takelast);\\n        }\\n        else{\\n            takefirst = -piles[start] + solve(piles,start+1,end,1);\\n            takelast =  -piles[end] + solve(piles,start,end-1,1);\\n            return dp[start][end] = min(takefirst,takelast);\\n        }\\n    }\\n};\\nis this solution valid, I am passing all cases but since only returning a true is also doing  a job i want to know it is actually correct or not."
                    },
                    {
                        "username": "Kathy99",
                        "content": "A classic game theory problem with first-mover advantage. if both players are rational, the first player will always win. "
                    },
                    {
                        "username": "_quack_quack",
                        "content": "why this problem has equal dislikes??\\n"
                    }
                ]
            },
            {
                "id": 1973899,
                "content": [
                    {
                        "username": "parul_010",
                        "content": "they shud just remove the condition  \"There are an even number of piles \" cos if there are even numbers of piles index will be from even to odd and alice will always have the option to pick  from both even and odd index"
                    },
                    {
                        "username": "pvsalunkhe2003",
                        "content": "for the test case:\\npiles = [6,9,4,3,9,8]\\nalice should lose right?\\nReason:\\nIf alice picks 6 first then, a: 6 b:9 a:8 b:9 a:4 b:3 thus a = 6+8+4 < b= 9+9+3\\nIf alice picks 8 first then, a:8 b:9 a:6 b:9 a:4 b:3\\nthus a = 8+6+4 < 9+9+3\\nbut the answer is given that alice wins\\nPlease fix this testcase"
                    },
                    {
                        "username": "nancynguyen",
                        "content": "in example 2: If Alice starts by taking pile 3 (from the beginning), Bob will indeed take pile 7 then the output should be false? still don\\'t get it"
                    },
                    {
                        "username": "user8104ko",
                        "content": "The Answer is return true;"
                    },
                    {
                        "username": "user8104ko",
                        "content": "We need not write that entire code because the first person always going to take larger value and that process continue and automatically the first person  must got more score then always the first person wins (and In the Question they gave us Alice takes first)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};@ [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "divyan_2002",
                        "content": "class Solution {\\npublic:\\n    int dp[501][501];\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(piles,0,piles.size()-1,1);\\n        cout<<ans;\\n        return ans>0;\\n    }\\n    int solve(vector<int>& piles,int start,int end,int alice){\\n        if(end<start) return 0;//base case\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n        \\n        int takefirst = 0,takelast = 0;\\n\\n        if(alice==1){\\n            takefirst = piles[start] + solve(piles,start+1,end,0);\\n            takelast  = piles[end] + solve(piles,start,end-1,0);\\n            return dp[start][end] = max(takefirst,takelast);\\n        }\\n        else{\\n            takefirst = -piles[start] + solve(piles,start+1,end,1);\\n            takelast =  -piles[end] + solve(piles,start,end-1,1);\\n            return dp[start][end] = min(takefirst,takelast);\\n        }\\n    }\\n};\\nis this solution valid, I am passing all cases but since only returning a true is also doing  a job i want to know it is actually correct or not."
                    },
                    {
                        "username": "Kathy99",
                        "content": "A classic game theory problem with first-mover advantage. if both players are rational, the first player will always win. "
                    },
                    {
                        "username": "_quack_quack",
                        "content": "why this problem has equal dislikes??\\n"
                    }
                ]
            },
            {
                "id": 1959234,
                "content": [
                    {
                        "username": "parul_010",
                        "content": "they shud just remove the condition  \"There are an even number of piles \" cos if there are even numbers of piles index will be from even to odd and alice will always have the option to pick  from both even and odd index"
                    },
                    {
                        "username": "pvsalunkhe2003",
                        "content": "for the test case:\\npiles = [6,9,4,3,9,8]\\nalice should lose right?\\nReason:\\nIf alice picks 6 first then, a: 6 b:9 a:8 b:9 a:4 b:3 thus a = 6+8+4 < b= 9+9+3\\nIf alice picks 8 first then, a:8 b:9 a:6 b:9 a:4 b:3\\nthus a = 8+6+4 < 9+9+3\\nbut the answer is given that alice wins\\nPlease fix this testcase"
                    },
                    {
                        "username": "nancynguyen",
                        "content": "in example 2: If Alice starts by taking pile 3 (from the beginning), Bob will indeed take pile 7 then the output should be false? still don\\'t get it"
                    },
                    {
                        "username": "user8104ko",
                        "content": "The Answer is return true;"
                    },
                    {
                        "username": "user8104ko",
                        "content": "We need not write that entire code because the first person always going to take larger value and that process continue and automatically the first person  must got more score then always the first person wins (and In the Question they gave us Alice takes first)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};@ [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "divyan_2002",
                        "content": "class Solution {\\npublic:\\n    int dp[501][501];\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(piles,0,piles.size()-1,1);\\n        cout<<ans;\\n        return ans>0;\\n    }\\n    int solve(vector<int>& piles,int start,int end,int alice){\\n        if(end<start) return 0;//base case\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n        \\n        int takefirst = 0,takelast = 0;\\n\\n        if(alice==1){\\n            takefirst = piles[start] + solve(piles,start+1,end,0);\\n            takelast  = piles[end] + solve(piles,start,end-1,0);\\n            return dp[start][end] = max(takefirst,takelast);\\n        }\\n        else{\\n            takefirst = -piles[start] + solve(piles,start+1,end,1);\\n            takelast =  -piles[end] + solve(piles,start,end-1,1);\\n            return dp[start][end] = min(takefirst,takelast);\\n        }\\n    }\\n};\\nis this solution valid, I am passing all cases but since only returning a true is also doing  a job i want to know it is actually correct or not."
                    },
                    {
                        "username": "Kathy99",
                        "content": "A classic game theory problem with first-mover advantage. if both players are rational, the first player will always win. "
                    },
                    {
                        "username": "_quack_quack",
                        "content": "why this problem has equal dislikes??\\n"
                    }
                ]
            },
            {
                "id": 1936980,
                "content": [
                    {
                        "username": "parul_010",
                        "content": "they shud just remove the condition  \"There are an even number of piles \" cos if there are even numbers of piles index will be from even to odd and alice will always have the option to pick  from both even and odd index"
                    },
                    {
                        "username": "pvsalunkhe2003",
                        "content": "for the test case:\\npiles = [6,9,4,3,9,8]\\nalice should lose right?\\nReason:\\nIf alice picks 6 first then, a: 6 b:9 a:8 b:9 a:4 b:3 thus a = 6+8+4 < b= 9+9+3\\nIf alice picks 8 first then, a:8 b:9 a:6 b:9 a:4 b:3\\nthus a = 8+6+4 < 9+9+3\\nbut the answer is given that alice wins\\nPlease fix this testcase"
                    },
                    {
                        "username": "nancynguyen",
                        "content": "in example 2: If Alice starts by taking pile 3 (from the beginning), Bob will indeed take pile 7 then the output should be false? still don\\'t get it"
                    },
                    {
                        "username": "user8104ko",
                        "content": "The Answer is return true;"
                    },
                    {
                        "username": "user8104ko",
                        "content": "We need not write that entire code because the first person always going to take larger value and that process continue and automatically the first person  must got more score then always the first person wins (and In the Question they gave us Alice takes first)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};@ [leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Just return true only. My solution got accecpted. I don\\'t know how.\\nclass Solution {\\npublic:\\n    bool stoneGame(vector<int>& piles) {\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "divyan_2002",
                        "content": "class Solution {\\npublic:\\n    int dp[501][501];\\n    bool stoneGame(vector<int>& piles) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(piles,0,piles.size()-1,1);\\n        cout<<ans;\\n        return ans>0;\\n    }\\n    int solve(vector<int>& piles,int start,int end,int alice){\\n        if(end<start) return 0;//base case\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n        \\n        int takefirst = 0,takelast = 0;\\n\\n        if(alice==1){\\n            takefirst = piles[start] + solve(piles,start+1,end,0);\\n            takelast  = piles[end] + solve(piles,start,end-1,0);\\n            return dp[start][end] = max(takefirst,takelast);\\n        }\\n        else{\\n            takefirst = -piles[start] + solve(piles,start+1,end,1);\\n            takelast =  -piles[end] + solve(piles,start,end-1,1);\\n            return dp[start][end] = min(takefirst,takelast);\\n        }\\n    }\\n};\\nis this solution valid, I am passing all cases but since only returning a true is also doing  a job i want to know it is actually correct or not."
                    },
                    {
                        "username": "Kathy99",
                        "content": "A classic game theory problem with first-mover advantage. if both players are rational, the first player will always win. "
                    },
                    {
                        "username": "_quack_quack",
                        "content": "why this problem has equal dislikes??\\n"
                    }
                ]
            },
            {
                "id": 1929482,
                "content": [
                    {
                        "username": "AbhayDutt",
                        "content": "is this question made to troll us???"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "this should be in easy questions\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "lol... return true got accepted!!"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if i was given this in an interview ... would \\'return True\\' be a pass or fail "
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "For all those people who are satisfied with returning \"True\" always without even thinking of a DP Solution, below are some great follow-up questions\\nWhat if piles size can be odd?\\nWhat if we want to know exactly the difference in scores?"
                    },
                    {
                        "username": "charonme",
                        "content": "for a similar, but slightly harder problem see https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "I coded the soln for 35 minutes and then saw that mathematical soln only returned true !! Lol , but seriously that maths soln was unintuitive for person who solved this for 1st time!!!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "whenever we have to find if player starting first wins or looses and you are not concerned about its score\\nyou can use this greedy approach\\n\\nfind the sums from left and right for first player for alternate elements\\ndo the same for second player accordingly\\n\\nyou will have max score for player 1 when he chooses from left end and when he chooses from right hand\\n\\ncompare it with the max score that second player can make\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "isn\\'t it same as predict the winner???"
                    },
                    {
                        "username": "irishabh90",
                        "content": "Why so discrimination against Bob?"
                    }
                ]
            },
            {
                "id": 1908347,
                "content": [
                    {
                        "username": "AbhayDutt",
                        "content": "is this question made to troll us???"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "this should be in easy questions\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "lol... return true got accepted!!"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if i was given this in an interview ... would \\'return True\\' be a pass or fail "
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "For all those people who are satisfied with returning \"True\" always without even thinking of a DP Solution, below are some great follow-up questions\\nWhat if piles size can be odd?\\nWhat if we want to know exactly the difference in scores?"
                    },
                    {
                        "username": "charonme",
                        "content": "for a similar, but slightly harder problem see https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "I coded the soln for 35 minutes and then saw that mathematical soln only returned true !! Lol , but seriously that maths soln was unintuitive for person who solved this for 1st time!!!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "whenever we have to find if player starting first wins or looses and you are not concerned about its score\\nyou can use this greedy approach\\n\\nfind the sums from left and right for first player for alternate elements\\ndo the same for second player accordingly\\n\\nyou will have max score for player 1 when he chooses from left end and when he chooses from right hand\\n\\ncompare it with the max score that second player can make\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "isn\\'t it same as predict the winner???"
                    },
                    {
                        "username": "irishabh90",
                        "content": "Why so discrimination against Bob?"
                    }
                ]
            },
            {
                "id": 1907265,
                "content": [
                    {
                        "username": "AbhayDutt",
                        "content": "is this question made to troll us???"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "this should be in easy questions\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "lol... return true got accepted!!"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if i was given this in an interview ... would \\'return True\\' be a pass or fail "
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "For all those people who are satisfied with returning \"True\" always without even thinking of a DP Solution, below are some great follow-up questions\\nWhat if piles size can be odd?\\nWhat if we want to know exactly the difference in scores?"
                    },
                    {
                        "username": "charonme",
                        "content": "for a similar, but slightly harder problem see https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "I coded the soln for 35 minutes and then saw that mathematical soln only returned true !! Lol , but seriously that maths soln was unintuitive for person who solved this for 1st time!!!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "whenever we have to find if player starting first wins or looses and you are not concerned about its score\\nyou can use this greedy approach\\n\\nfind the sums from left and right for first player for alternate elements\\ndo the same for second player accordingly\\n\\nyou will have max score for player 1 when he chooses from left end and when he chooses from right hand\\n\\ncompare it with the max score that second player can make\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "isn\\'t it same as predict the winner???"
                    },
                    {
                        "username": "irishabh90",
                        "content": "Why so discrimination against Bob?"
                    }
                ]
            },
            {
                "id": 1907185,
                "content": [
                    {
                        "username": "AbhayDutt",
                        "content": "is this question made to troll us???"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "this should be in easy questions\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "lol... return true got accepted!!"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if i was given this in an interview ... would \\'return True\\' be a pass or fail "
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "For all those people who are satisfied with returning \"True\" always without even thinking of a DP Solution, below are some great follow-up questions\\nWhat if piles size can be odd?\\nWhat if we want to know exactly the difference in scores?"
                    },
                    {
                        "username": "charonme",
                        "content": "for a similar, but slightly harder problem see https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "I coded the soln for 35 minutes and then saw that mathematical soln only returned true !! Lol , but seriously that maths soln was unintuitive for person who solved this for 1st time!!!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "whenever we have to find if player starting first wins or looses and you are not concerned about its score\\nyou can use this greedy approach\\n\\nfind the sums from left and right for first player for alternate elements\\ndo the same for second player accordingly\\n\\nyou will have max score for player 1 when he chooses from left end and when he chooses from right hand\\n\\ncompare it with the max score that second player can make\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "isn\\'t it same as predict the winner???"
                    },
                    {
                        "username": "irishabh90",
                        "content": "Why so discrimination against Bob?"
                    }
                ]
            },
            {
                "id": 1906971,
                "content": [
                    {
                        "username": "AbhayDutt",
                        "content": "is this question made to troll us???"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "this should be in easy questions\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "lol... return true got accepted!!"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if i was given this in an interview ... would \\'return True\\' be a pass or fail "
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "For all those people who are satisfied with returning \"True\" always without even thinking of a DP Solution, below are some great follow-up questions\\nWhat if piles size can be odd?\\nWhat if we want to know exactly the difference in scores?"
                    },
                    {
                        "username": "charonme",
                        "content": "for a similar, but slightly harder problem see https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "I coded the soln for 35 minutes and then saw that mathematical soln only returned true !! Lol , but seriously that maths soln was unintuitive for person who solved this for 1st time!!!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "whenever we have to find if player starting first wins or looses and you are not concerned about its score\\nyou can use this greedy approach\\n\\nfind the sums from left and right for first player for alternate elements\\ndo the same for second player accordingly\\n\\nyou will have max score for player 1 when he chooses from left end and when he chooses from right hand\\n\\ncompare it with the max score that second player can make\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "isn\\'t it same as predict the winner???"
                    },
                    {
                        "username": "irishabh90",
                        "content": "Why so discrimination against Bob?"
                    }
                ]
            },
            {
                "id": 1906960,
                "content": [
                    {
                        "username": "AbhayDutt",
                        "content": "is this question made to troll us???"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "this should be in easy questions\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "lol... return true got accepted!!"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if i was given this in an interview ... would \\'return True\\' be a pass or fail "
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "For all those people who are satisfied with returning \"True\" always without even thinking of a DP Solution, below are some great follow-up questions\\nWhat if piles size can be odd?\\nWhat if we want to know exactly the difference in scores?"
                    },
                    {
                        "username": "charonme",
                        "content": "for a similar, but slightly harder problem see https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "I coded the soln for 35 minutes and then saw that mathematical soln only returned true !! Lol , but seriously that maths soln was unintuitive for person who solved this for 1st time!!!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "whenever we have to find if player starting first wins or looses and you are not concerned about its score\\nyou can use this greedy approach\\n\\nfind the sums from left and right for first player for alternate elements\\ndo the same for second player accordingly\\n\\nyou will have max score for player 1 when he chooses from left end and when he chooses from right hand\\n\\ncompare it with the max score that second player can make\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "isn\\'t it same as predict the winner???"
                    },
                    {
                        "username": "irishabh90",
                        "content": "Why so discrimination against Bob?"
                    }
                ]
            },
            {
                "id": 1906278,
                "content": [
                    {
                        "username": "AbhayDutt",
                        "content": "is this question made to troll us???"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "this should be in easy questions\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "lol... return true got accepted!!"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if i was given this in an interview ... would \\'return True\\' be a pass or fail "
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "For all those people who are satisfied with returning \"True\" always without even thinking of a DP Solution, below are some great follow-up questions\\nWhat if piles size can be odd?\\nWhat if we want to know exactly the difference in scores?"
                    },
                    {
                        "username": "charonme",
                        "content": "for a similar, but slightly harder problem see https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "I coded the soln for 35 minutes and then saw that mathematical soln only returned true !! Lol , but seriously that maths soln was unintuitive for person who solved this for 1st time!!!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "whenever we have to find if player starting first wins or looses and you are not concerned about its score\\nyou can use this greedy approach\\n\\nfind the sums from left and right for first player for alternate elements\\ndo the same for second player accordingly\\n\\nyou will have max score for player 1 when he chooses from left end and when he chooses from right hand\\n\\ncompare it with the max score that second player can make\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "isn\\'t it same as predict the winner???"
                    },
                    {
                        "username": "irishabh90",
                        "content": "Why so discrimination against Bob?"
                    }
                ]
            },
            {
                "id": 1906132,
                "content": [
                    {
                        "username": "AbhayDutt",
                        "content": "is this question made to troll us???"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "this should be in easy questions\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "lol... return true got accepted!!"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if i was given this in an interview ... would \\'return True\\' be a pass or fail "
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "For all those people who are satisfied with returning \"True\" always without even thinking of a DP Solution, below are some great follow-up questions\\nWhat if piles size can be odd?\\nWhat if we want to know exactly the difference in scores?"
                    },
                    {
                        "username": "charonme",
                        "content": "for a similar, but slightly harder problem see https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "I coded the soln for 35 minutes and then saw that mathematical soln only returned true !! Lol , but seriously that maths soln was unintuitive for person who solved this for 1st time!!!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "whenever we have to find if player starting first wins or looses and you are not concerned about its score\\nyou can use this greedy approach\\n\\nfind the sums from left and right for first player for alternate elements\\ndo the same for second player accordingly\\n\\nyou will have max score for player 1 when he chooses from left end and when he chooses from right hand\\n\\ncompare it with the max score that second player can make\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "isn\\'t it same as predict the winner???"
                    },
                    {
                        "username": "irishabh90",
                        "content": "Why so discrimination against Bob?"
                    }
                ]
            },
            {
                "id": 1905758,
                "content": [
                    {
                        "username": "AbhayDutt",
                        "content": "is this question made to troll us???"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "this should be in easy questions\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "lol... return true got accepted!!"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if i was given this in an interview ... would \\'return True\\' be a pass or fail "
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "For all those people who are satisfied with returning \"True\" always without even thinking of a DP Solution, below are some great follow-up questions\\nWhat if piles size can be odd?\\nWhat if we want to know exactly the difference in scores?"
                    },
                    {
                        "username": "charonme",
                        "content": "for a similar, but slightly harder problem see https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "I coded the soln for 35 minutes and then saw that mathematical soln only returned true !! Lol , but seriously that maths soln was unintuitive for person who solved this for 1st time!!!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "whenever we have to find if player starting first wins or looses and you are not concerned about its score\\nyou can use this greedy approach\\n\\nfind the sums from left and right for first player for alternate elements\\ndo the same for second player accordingly\\n\\nyou will have max score for player 1 when he chooses from left end and when he chooses from right hand\\n\\ncompare it with the max score that second player can make\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "isn\\'t it same as predict the winner???"
                    },
                    {
                        "username": "irishabh90",
                        "content": "Why so discrimination against Bob?"
                    }
                ]
            },
            {
                "id": 1905217,
                "content": [
                    {
                        "username": "AbhayDutt",
                        "content": "is this question made to troll us???"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "this should be in easy questions\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "lol... return true got accepted!!"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if i was given this in an interview ... would \\'return True\\' be a pass or fail "
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "For all those people who are satisfied with returning \"True\" always without even thinking of a DP Solution, below are some great follow-up questions\\nWhat if piles size can be odd?\\nWhat if we want to know exactly the difference in scores?"
                    },
                    {
                        "username": "charonme",
                        "content": "for a similar, but slightly harder problem see https://leetcode.com/problems/add-two-integers/"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "I coded the soln for 35 minutes and then saw that mathematical soln only returned true !! Lol , but seriously that maths soln was unintuitive for person who solved this for 1st time!!!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "whenever we have to find if player starting first wins or looses and you are not concerned about its score\\nyou can use this greedy approach\\n\\nfind the sums from left and right for first player for alternate elements\\ndo the same for second player accordingly\\n\\nyou will have max score for player 1 when he chooses from left end and when he chooses from right hand\\n\\ncompare it with the max score that second player can make\\n"
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "isn\\'t it same as predict the winner???"
                    },
                    {
                        "username": "irishabh90",
                        "content": "Why so discrimination against Bob?"
                    }
                ]
            },
            {
                "id": 1810969,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Alice will always win."
                    },
                    {
                        "username": "sepetovskidamjan",
                        "content": "This question is broken if you just return true it solves the problem, I think it is not a good question to spend your time on, someone needs to tell the devs to look at the question."
                    },
                    {
                        "username": "Dew_ansh",
                        "content": "just have to return true if both players are playing optimally player going first will always win.LOL"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "zaheer__zk",
                        "content": "This is a same question as cses problem set.\\n\\ncheck my answer that I have added"
                    },
                    {
                        "username": "topswe",
                        "content": "    # sum(piles) is odd. => NO TIES...\\n    # len(piles) is even => each takes len(piles)//2 piles\\n    # since Alice goes first, she will always pick the greater size piles and WIN"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "nought0",
                        "content": "\\xA0return true; \\n"
                    },
                    {
                        "username": "b3anMachine",
                        "content": "Pretty sure these comment sections were never meant to be riddled with personal solutions..."
                    },
                    {
                        "username": "mritunjoyhalder79",
                        "content": "The answer will always be True. If Alex starts from first he will cover all the stones in even places. If he starts from last he will cover the all stones in even places. So whoever starts first he will win as he can choose from any end.\\nThe answer will always be TRUE"
                    }
                ]
            },
            {
                "id": 1796038,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Alice will always win."
                    },
                    {
                        "username": "sepetovskidamjan",
                        "content": "This question is broken if you just return true it solves the problem, I think it is not a good question to spend your time on, someone needs to tell the devs to look at the question."
                    },
                    {
                        "username": "Dew_ansh",
                        "content": "just have to return true if both players are playing optimally player going first will always win.LOL"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "zaheer__zk",
                        "content": "This is a same question as cses problem set.\\n\\ncheck my answer that I have added"
                    },
                    {
                        "username": "topswe",
                        "content": "    # sum(piles) is odd. => NO TIES...\\n    # len(piles) is even => each takes len(piles)//2 piles\\n    # since Alice goes first, she will always pick the greater size piles and WIN"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "nought0",
                        "content": "\\xA0return true; \\n"
                    },
                    {
                        "username": "b3anMachine",
                        "content": "Pretty sure these comment sections were never meant to be riddled with personal solutions..."
                    },
                    {
                        "username": "mritunjoyhalder79",
                        "content": "The answer will always be True. If Alex starts from first he will cover all the stones in even places. If he starts from last he will cover the all stones in even places. So whoever starts first he will win as he can choose from any end.\\nThe answer will always be TRUE"
                    }
                ]
            },
            {
                "id": 1777425,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Alice will always win."
                    },
                    {
                        "username": "sepetovskidamjan",
                        "content": "This question is broken if you just return true it solves the problem, I think it is not a good question to spend your time on, someone needs to tell the devs to look at the question."
                    },
                    {
                        "username": "Dew_ansh",
                        "content": "just have to return true if both players are playing optimally player going first will always win.LOL"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "zaheer__zk",
                        "content": "This is a same question as cses problem set.\\n\\ncheck my answer that I have added"
                    },
                    {
                        "username": "topswe",
                        "content": "    # sum(piles) is odd. => NO TIES...\\n    # len(piles) is even => each takes len(piles)//2 piles\\n    # since Alice goes first, she will always pick the greater size piles and WIN"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "nought0",
                        "content": "\\xA0return true; \\n"
                    },
                    {
                        "username": "b3anMachine",
                        "content": "Pretty sure these comment sections were never meant to be riddled with personal solutions..."
                    },
                    {
                        "username": "mritunjoyhalder79",
                        "content": "The answer will always be True. If Alex starts from first he will cover all the stones in even places. If he starts from last he will cover the all stones in even places. So whoever starts first he will win as he can choose from any end.\\nThe answer will always be TRUE"
                    }
                ]
            },
            {
                "id": 1724073,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Alice will always win."
                    },
                    {
                        "username": "sepetovskidamjan",
                        "content": "This question is broken if you just return true it solves the problem, I think it is not a good question to spend your time on, someone needs to tell the devs to look at the question."
                    },
                    {
                        "username": "Dew_ansh",
                        "content": "just have to return true if both players are playing optimally player going first will always win.LOL"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "zaheer__zk",
                        "content": "This is a same question as cses problem set.\\n\\ncheck my answer that I have added"
                    },
                    {
                        "username": "topswe",
                        "content": "    # sum(piles) is odd. => NO TIES...\\n    # len(piles) is even => each takes len(piles)//2 piles\\n    # since Alice goes first, she will always pick the greater size piles and WIN"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "nought0",
                        "content": "\\xA0return true; \\n"
                    },
                    {
                        "username": "b3anMachine",
                        "content": "Pretty sure these comment sections were never meant to be riddled with personal solutions..."
                    },
                    {
                        "username": "mritunjoyhalder79",
                        "content": "The answer will always be True. If Alex starts from first he will cover all the stones in even places. If he starts from last he will cover the all stones in even places. So whoever starts first he will win as he can choose from any end.\\nThe answer will always be TRUE"
                    }
                ]
            },
            {
                "id": 1719173,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Alice will always win."
                    },
                    {
                        "username": "sepetovskidamjan",
                        "content": "This question is broken if you just return true it solves the problem, I think it is not a good question to spend your time on, someone needs to tell the devs to look at the question."
                    },
                    {
                        "username": "Dew_ansh",
                        "content": "just have to return true if both players are playing optimally player going first will always win.LOL"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "zaheer__zk",
                        "content": "This is a same question as cses problem set.\\n\\ncheck my answer that I have added"
                    },
                    {
                        "username": "topswe",
                        "content": "    # sum(piles) is odd. => NO TIES...\\n    # len(piles) is even => each takes len(piles)//2 piles\\n    # since Alice goes first, she will always pick the greater size piles and WIN"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "nought0",
                        "content": "\\xA0return true; \\n"
                    },
                    {
                        "username": "b3anMachine",
                        "content": "Pretty sure these comment sections were never meant to be riddled with personal solutions..."
                    },
                    {
                        "username": "mritunjoyhalder79",
                        "content": "The answer will always be True. If Alex starts from first he will cover all the stones in even places. If he starts from last he will cover the all stones in even places. So whoever starts first he will win as he can choose from any end.\\nThe answer will always be TRUE"
                    }
                ]
            },
            {
                "id": 1684214,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Alice will always win."
                    },
                    {
                        "username": "sepetovskidamjan",
                        "content": "This question is broken if you just return true it solves the problem, I think it is not a good question to spend your time on, someone needs to tell the devs to look at the question."
                    },
                    {
                        "username": "Dew_ansh",
                        "content": "just have to return true if both players are playing optimally player going first will always win.LOL"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "zaheer__zk",
                        "content": "This is a same question as cses problem set.\\n\\ncheck my answer that I have added"
                    },
                    {
                        "username": "topswe",
                        "content": "    # sum(piles) is odd. => NO TIES...\\n    # len(piles) is even => each takes len(piles)//2 piles\\n    # since Alice goes first, she will always pick the greater size piles and WIN"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "nought0",
                        "content": "\\xA0return true; \\n"
                    },
                    {
                        "username": "b3anMachine",
                        "content": "Pretty sure these comment sections were never meant to be riddled with personal solutions..."
                    },
                    {
                        "username": "mritunjoyhalder79",
                        "content": "The answer will always be True. If Alex starts from first he will cover all the stones in even places. If he starts from last he will cover the all stones in even places. So whoever starts first he will win as he can choose from any end.\\nThe answer will always be TRUE"
                    }
                ]
            },
            {
                "id": 1629592,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Alice will always win."
                    },
                    {
                        "username": "sepetovskidamjan",
                        "content": "This question is broken if you just return true it solves the problem, I think it is not a good question to spend your time on, someone needs to tell the devs to look at the question."
                    },
                    {
                        "username": "Dew_ansh",
                        "content": "just have to return true if both players are playing optimally player going first will always win.LOL"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "zaheer__zk",
                        "content": "This is a same question as cses problem set.\\n\\ncheck my answer that I have added"
                    },
                    {
                        "username": "topswe",
                        "content": "    # sum(piles) is odd. => NO TIES...\\n    # len(piles) is even => each takes len(piles)//2 piles\\n    # since Alice goes first, she will always pick the greater size piles and WIN"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "nought0",
                        "content": "\\xA0return true; \\n"
                    },
                    {
                        "username": "b3anMachine",
                        "content": "Pretty sure these comment sections were never meant to be riddled with personal solutions..."
                    },
                    {
                        "username": "mritunjoyhalder79",
                        "content": "The answer will always be True. If Alex starts from first he will cover all the stones in even places. If he starts from last he will cover the all stones in even places. So whoever starts first he will win as he can choose from any end.\\nThe answer will always be TRUE"
                    }
                ]
            },
            {
                "id": 1575280,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Alice will always win."
                    },
                    {
                        "username": "sepetovskidamjan",
                        "content": "This question is broken if you just return true it solves the problem, I think it is not a good question to spend your time on, someone needs to tell the devs to look at the question."
                    },
                    {
                        "username": "Dew_ansh",
                        "content": "just have to return true if both players are playing optimally player going first will always win.LOL"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "zaheer__zk",
                        "content": "This is a same question as cses problem set.\\n\\ncheck my answer that I have added"
                    },
                    {
                        "username": "topswe",
                        "content": "    # sum(piles) is odd. => NO TIES...\\n    # len(piles) is even => each takes len(piles)//2 piles\\n    # since Alice goes first, she will always pick the greater size piles and WIN"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "nought0",
                        "content": "\\xA0return true; \\n"
                    },
                    {
                        "username": "b3anMachine",
                        "content": "Pretty sure these comment sections were never meant to be riddled with personal solutions..."
                    },
                    {
                        "username": "mritunjoyhalder79",
                        "content": "The answer will always be True. If Alex starts from first he will cover all the stones in even places. If he starts from last he will cover the all stones in even places. So whoever starts first he will win as he can choose from any end.\\nThe answer will always be TRUE"
                    }
                ]
            },
            {
                "id": 1575031,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Alice will always win."
                    },
                    {
                        "username": "sepetovskidamjan",
                        "content": "This question is broken if you just return true it solves the problem, I think it is not a good question to spend your time on, someone needs to tell the devs to look at the question."
                    },
                    {
                        "username": "Dew_ansh",
                        "content": "just have to return true if both players are playing optimally player going first will always win.LOL"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "zaheer__zk",
                        "content": "This is a same question as cses problem set.\\n\\ncheck my answer that I have added"
                    },
                    {
                        "username": "topswe",
                        "content": "    # sum(piles) is odd. => NO TIES...\\n    # len(piles) is even => each takes len(piles)//2 piles\\n    # since Alice goes first, she will always pick the greater size piles and WIN"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "nought0",
                        "content": "\\xA0return true; \\n"
                    },
                    {
                        "username": "b3anMachine",
                        "content": "Pretty sure these comment sections were never meant to be riddled with personal solutions..."
                    },
                    {
                        "username": "mritunjoyhalder79",
                        "content": "The answer will always be True. If Alex starts from first he will cover all the stones in even places. If he starts from last he will cover the all stones in even places. So whoever starts first he will win as he can choose from any end.\\nThe answer will always be TRUE"
                    }
                ]
            },
            {
                "id": 1574888,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Alice will always win."
                    },
                    {
                        "username": "sepetovskidamjan",
                        "content": "This question is broken if you just return true it solves the problem, I think it is not a good question to spend your time on, someone needs to tell the devs to look at the question."
                    },
                    {
                        "username": "Dew_ansh",
                        "content": "just have to return true if both players are playing optimally player going first will always win.LOL"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "zaheer__zk",
                        "content": "This is a same question as cses problem set.\\n\\ncheck my answer that I have added"
                    },
                    {
                        "username": "topswe",
                        "content": "    # sum(piles) is odd. => NO TIES...\\n    # len(piles) is even => each takes len(piles)//2 piles\\n    # since Alice goes first, she will always pick the greater size piles and WIN"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    class Pair {\\n        int fir, sec;\\n        Pair(int fir, int sec) {\\n            this.fir = fir;\\n            this.sec = sec;\\n        }\\n    }\\n    public boolean stoneGame(int[] piles) {\\n            int n = piles.length;\\n        // \\u521D\\u59CB\\u5316 dp \\u6570\\u7EC4\\n        Pair[][] dp = new Pair[n][n];\\n        for (int i = 0; i < n; i++) \\n            for (int j = i; j < n; j++)\\n                dp[i][j] = new Pair(0, 0);\\n        // \\u586B\\u5165 base case\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i].fir = piles[i];\\n            dp[i][i].sec = 0;\\n        }\\n\\n        // \\u5012\\u7740\\u904D\\u5386\\u6570\\u7EC4\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = i + 1; j < n; j++) {\\n                // \\u5148\\u624B\\u9009\\u62E9\\u6700\\u5DE6\\u8FB9\\u6216\\u6700\\u53F3\\u8FB9\\u7684\\u5206\\u6570\\n                int left = piles[i] + dp[i+1][j].sec;\\n                int right = piles[j] + dp[i][j-1].sec;\\n                // \\u5957\\u7528\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n                // \\u5148\\u624B\\u80AF\\u5B9A\\u4F1A\\u9009\\u62E9\\u66F4\\u5927\\u7684\\u7ED3\\u679C\\uFF0C\\u540E\\u624B\\u7684\\u9009\\u62E9\\u968F\\u4E4B\\u6539\\u53D8\\n                if (left > right) {\\n                    dp[i][j].fir = left;\\n                    dp[i][j].sec = dp[i+1][j].fir;\\n                } else {\\n                    dp[i][j].fir = right;\\n                    dp[i][j].sec = dp[i][j-1].fir;\\n                }\\n            }\\n        }\\n        Pair res = dp[0][n-1];\\n        return res.fir - res.sec > 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "nought0",
                        "content": "\\xA0return true; \\n"
                    },
                    {
                        "username": "b3anMachine",
                        "content": "Pretty sure these comment sections were never meant to be riddled with personal solutions..."
                    },
                    {
                        "username": "mritunjoyhalder79",
                        "content": "The answer will always be True. If Alex starts from first he will cover all the stones in even places. If he starts from last he will cover the all stones in even places. So whoever starts first he will win as he can choose from any end.\\nThe answer will always be TRUE"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Score Words Formed by Letters",
        "question_content": "<p>Given a list of <code>words</code>, list of&nbsp; single&nbsp;<code>letters</code> (might be repeating)&nbsp;and <code>score</code>&nbsp;of every character.</p>\n\n<p>Return the maximum score of <strong>any</strong> valid set of words formed by using the given letters (<code>words[i]</code> cannot be used two&nbsp;or more times).</p>\n\n<p>It is not necessary to use all characters in <code>letters</code> and each letter can only be used once. Score of letters&nbsp;<code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, <code>&#39;c&#39;</code>, ... ,<code>&#39;z&#39;</code> is given by&nbsp;<code>score[0]</code>, <code>score[1]</code>, ... , <code>score[25]</code> respectively.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;dog&quot;,&quot;cat&quot;,&quot;dad&quot;,&quot;good&quot;], letters = [&quot;a&quot;,&quot;a&quot;,&quot;c&quot;,&quot;d&quot;,&quot;d&quot;,&quot;d&quot;,&quot;g&quot;,&quot;o&quot;,&quot;o&quot;], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]\n<strong>Output:</strong> 23\n<strong>Explanation:</strong>\nScore  a=1, c=9, d=5, g=3, o=2\nGiven letters, we can form the words &quot;dad&quot; (5+1+5) and &quot;good&quot; (3+2+2+5) with a score of 23.\nWords &quot;dad&quot; and &quot;dog&quot; only get a score of 21.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;xxxz&quot;,&quot;ax&quot;,&quot;bx&quot;,&quot;cx&quot;], letters = [&quot;z&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;x&quot;,&quot;x&quot;,&quot;x&quot;], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]\n<strong>Output:</strong> 27\n<strong>Explanation:</strong>\nScore  a=4, b=4, c=4, x=5, z=10\nGiven letters, we can form the words &quot;ax&quot; (4+5), &quot;bx&quot; (4+5) and &quot;cx&quot; (4+5) with a score of 27.\nWord &quot;xxxz&quot; only get a score of 25.</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;leetcode&quot;], letters = [&quot;l&quot;,&quot;e&quot;,&quot;t&quot;,&quot;c&quot;,&quot;o&quot;,&quot;d&quot;], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong>\nLetter &quot;e&quot; can only be used once.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 14</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 15</code></li>\n\t<li><code>1 &lt;= letters.length &lt;= 100</code></li>\n\t<li><code>letters[i].length == 1</code></li>\n\t<li><code>score.length ==&nbsp;26</code></li>\n\t<li><code>0 &lt;= score[i] &lt;= 10</code></li>\n\t<li><code>words[i]</code>, <code>letters[i]</code>&nbsp;contains only lower case English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 425129,
                "title": "java-backtrack-similar-to-78-subsets-1ms-beats-100",
                "content": "Similar to 78. Subsets, use backtrack to solve the problem.\\n```java\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        if (words == null || words.length == 0 || letters == null || letters.length == 0 || score == null || score.length == 0) return 0;\\n        int[] count = new int[score.length];\\n        for (char ch : letters) {\\n            count[ch - \\'a\\']++;\\n        }\\n        int res = backtrack(words, count, score, 0);\\n        return res;\\n    }\\n    int backtrack(String[] words, int[] count, int[] score, int index) {\\n        int max = 0;\\n        for (int i = index; i < words.length; i++) {\\n            int res = 0;\\n            boolean isValid = true;\\n            for (char ch : words[i].toCharArray()) {\\n                count[ch - \\'a\\']--;\\n                res += score[ch - \\'a\\'];\\n                if (count[ch - \\'a\\'] < 0) isValid = false;\\n            }\\n            if (isValid) {\\n                res += backtrack(words, count, score, i + 1);\\n                max = Math.max(res, max);\\n            }\\n            for (char ch : words[i].toCharArray()) {\\n                count[ch - \\'a\\']++;\\n                res = 0;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        if (words == null || words.length == 0 || letters == null || letters.length == 0 || score == null || score.length == 0) return 0;\\n        int[] count = new int[score.length];\\n        for (char ch : letters) {\\n            count[ch - \\'a\\']++;\\n        }\\n        int res = backtrack(words, count, score, 0);\\n        return res;\\n    }\\n    int backtrack(String[] words, int[] count, int[] score, int index) {\\n        int max = 0;\\n        for (int i = index; i < words.length; i++) {\\n            int res = 0;\\n            boolean isValid = true;\\n            for (char ch : words[i].toCharArray()) {\\n                count[ch - \\'a\\']--;\\n                res += score[ch - \\'a\\'];\\n                if (count[ch - \\'a\\'] < 0) isValid = false;\\n            }\\n            if (isValid) {\\n                res += backtrack(words, count, score, i + 1);\\n                max = Math.max(res, max);\\n            }\\n            for (char ch : words[i].toCharArray()) {\\n                count[ch - \\'a\\']++;\\n                res = 0;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425411,
                "title": "python-dfs-pruning",
                "content": "This problem is about finding a combination that the combination of the `words` whose total letter consumptions are restricted by `letters` (covert to a character counter) that achieved the highest score.\\nSo we can use DFS here to search all valid combinations and find out the highest score. To reduce the search space, we can prune the branch and backtrack when current branch is no longer valid or can\\'t reach the current highest score.\\n\\nEach time, we search from index `i` and all the rest node `words[i:]` are potential candidates to DFS.\\nSuppose in one of DFS branch, we pass `words[i:j]` and check the node `words[j]`. If `words[j]`\\'s letter consumption doesn\\'t exceed the current `letters` restriction, we are good to add its score and keep DFS from `j+1`.\\nWe can check this by `if all(n <= letters.get(c,0) for c,n in Counter(words[j]).items())`\\nAnd when we DFS from `words[j]`, we also need to reduce `letters` resource by `words[j]`\\'s letter consumption. Or we can pass a new counter argument to DFS as `new_letter = {c:n-Counter(words[j]).get(c,0) for c,n in letter.items()}`\\n\\nTo improve performance, we can precomputer each word\\'s letter counter and its score:\\n```\\nwords_score = [sum(score[ord(c)-ord(\\'a\\')] for c in word) for word in words]\\nwords_counter = [collections.Counter(word) for word in words]\\n```\\nAnd we can also prune the branch once `curr_score + sum(words_score[i:]) <= self.max_score` as there is no possibility for current branch exceeding the maximum score so far. We are also precompute a suffix sum array to avoid calculating `sum(words_score[i:]` each time. But I save it here as the `words.length <= 15`.\\n\\n```\\nclass Solution():\\n    def maxScoreWords(self, words, letters, score):\\n        self.max_score = 0\\n        words_score = [sum(score[ord(c)-ord(\\'a\\')] for c in word) for word in words]\\n        words_counter = [collections.Counter(word) for word in words]\\n        \\n        def dfs(i, curr_score, counter):\\n            if curr_score + sum(words_score[i:]) <= self.max_score:\\n                return\\n            self.max_score = max(self.max_score, curr_score)\\n            for j, wcnt in enumerate(words_counter[i:], i):\\n                if all(n <= counter.get(c,0) for c,n in wcnt.items()):\\n                    dfs(j+1, curr_score+words_score[j], counter-wcnt)\\n        \\n        dfs(0, 0, collections.Counter(letters))\\n        return self.max_score\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nwords_score = [sum(score[ord(c)-ord(\\'a\\')] for c in word) for word in words]\\nwords_counter = [collections.Counter(word) for word in words]\\n```\n```\\nclass Solution():\\n    def maxScoreWords(self, words, letters, score):\\n        self.max_score = 0\\n        words_score = [sum(score[ord(c)-ord(\\'a\\')] for c in word) for word in words]\\n        words_counter = [collections.Counter(word) for word in words]\\n        \\n        def dfs(i, curr_score, counter):\\n            if curr_score + sum(words_score[i:]) <= self.max_score:\\n                return\\n            self.max_score = max(self.max_score, curr_score)\\n            for j, wcnt in enumerate(words_counter[i:], i):\\n                if all(n <= counter.get(c,0) for c,n in wcnt.items()):\\n                    dfs(j+1, curr_score+words_score[j], counter-wcnt)\\n        \\n        dfs(0, 0, collections.Counter(letters))\\n        return self.max_score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104062,
                "title": "c-code-both-rercursion-and-dp",
                "content": "Well I have solved this question by considering it a variation of 0/1 knapsack. I will be explaing my approach but firstly obesrve the constraints. Since the size of words array and letters array is small, we can use recursion only. Once we have thought of a recursive approach, we can simply use memotization to store the values of the recursive function for a set of parameters to prevent repeated calculations. \\n\\nIn general to easily use dp, we just have to write a successful recursive approach. Once we have a recursive solution, we can check what all functionparameters are changing, when we are calling that function again. After identification of these changing parameter, use an  n-dimensional array/ unordered_map to store the result for these values.the dimension of the array to be used is equal to the number of changing parameters.\\n\\nSimilarity between knapsack and this question:\\nKnapsack\\n1. We had to choose some objects from a set of objects\\n2. We had restrictions on the overall weight\\n3. We recived a score for every object we chose following the constraint\\n\\nThis Problem\\n1. We had to choose words from an array of words\\n2. We have restrictions for using only the letters given in the letters vector\\n3. We recieve a score for every letter we use if we make a word following the constraint\\n\\nNow for any single word, we  have 2 choices\\n1. Select it (get reward, reduce the letter vector)\\n2. Pass and move on\\n\\nSo we can simply apply a recursive code like this:\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<string>& words, int curr, vector<char> letters, vector<int>& score){\\n\\t\\t//base case: there is no element\\n        if(curr<0)return 0;\\n\\t\\t//using unordered_maps as they have better time complexity than normal  map by a factor of log(N)\\n        unordered_map<char, int>curr_dict, curr_word, remaining;\\n\\t\\t//converting the  current word in consideration and the letter vector in key value format:\\n\\t\\t// where keys are alphabets and values are their frequency\\n        for(int i=0;i<letters.size();i++){\\n            curr_dict[letters[i]]++;\\n        }\\n        for(int i=0;i<words[curr].size();i++){\\n            curr_word[words[curr][i]]++;\\n        }\\t\\t\\n        vector<char>lettersr;\\n        remaining=curr_dict;\\n        int flag=1;\\n\\t\\t//checking if curr_word can be constructed using the letters vectorby comparing frequency of alphabets\\n        for(auto temp:curr_word){\\n            if(curr_dict[temp.first]<temp.second){\\n                flag=0;\\n                break;\\n            }\\n            remaining[temp.first]-=temp.second;\\n        }\\n\\t\\t//if the current word cannot be constructed, we will simply pass it\\n        if(flag==0){\\n            return helper(words, curr-1, letters, score);\\n        }\\n\\t\\t//now comes the case where the current word can be constructed. We have 2 options either construct the\\n\\t\\t//word(receive some score, and reduce the letters vector) or simply pass it\\n\\t\\t//calculating the score received for constructing the word\\n        int curr_score=0;\\n        for(int i=0;i<words[curr].size();i++){\\n            curr_score+=score[words[curr][i]-\\'a\\'];\\n        }\\n\\t\\t//creating a new vector after reducing the alphabets used for making the current word\\n        for(auto temp:remaining){\\n            for(int i=0;i<temp.second;i++)\\n                lettersr.emplace_back(temp.first);\\n        }\\n\\t\\t//calling on the next wor with reduced letters vector and adding the score \\n        int ans2=helper(words, curr-1, lettersr, score)+curr_score;        \\n\\t\\t//returning the maximum value for the two options we had if current wor can be constructed\\n        return max(helper(words, curr-1, letters, score), ans2);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n\\t\\t//will iterate from last element to first.\\n        return helper(words, words.size()-1, letters, score);        \\n    }\\n};\\n```\\nNow to go to memotization part.\\nNote Many people have used various memotizartion techniques but I decided to use nested unordered_maps.\\nFor those who dont know what this is, you can consider it as a 2d unordered_map\\nHowever a better way of understanding will be considering to have multiple unordered_maps and each of them linked to a paricular integer. \\nNow How to memotise using the letters vector as it is a changing parameter in recursion(discussed above).\\nWe can make a string after sorting the letters vector. This will fit in the nested unordered_map and help us to memotise easily.\\n```\\nclass Solution {\\npublic:\\n\\t//nested unordered_map for dp\\n    unordered_map<int, unordered_map<string, int>>dp;\\n    int helper(vector<string>& words, int curr, vector<char> letters, vector<int>& score, string memory){\\n        if(curr<0)return 0;\\n        if(dp[curr][memory]!=0)return dp[curr][memory];\\n        unordered_map<char, int>curr_dict, curr_word, remaining;\\n        vector<char>lettersr;\\n        for(int i=0;i<letters.size();i++){\\n            curr_dict[letters[i]]++;\\n        }\\n        for(int i=0;i<words[curr].size();i++){\\n            curr_word[words[curr][i]]++;\\n        }\\n        remaining=curr_dict;\\n        int flag=1;\\n        for(auto temp:curr_word){\\n            // cout<<temp.first<<\" \"<<temp.second<<endl;\\n            if(curr_dict[temp.first]<temp.second){\\n                flag=0;\\n                break;\\n            }\\n            remaining[temp.first]-=temp.second;\\n        }\\n\\t\\t// generating the string from vectors a is if we pass the current word, b is if we use the current word.\\n\\t\\t//Converting to strings and sorting increasing time complexity but will still be better for higher constraints \\n\\t\\t//than recursion(exponential). Converting to strings will help us use the unorered_map to memotise\\n        string a=\"\", b=\"\";\\n        for(int i=0;i<letters.size();i++){\\n            a+=letters[i];\\n        }\\n        for(int i=0;i<remaining.size();i++){\\n            b+=remaining[i];\\n        }\\n        sort(a.begin(), a.end());\\n        sort(b.begin(), b.end());\\n        if(flag==0){\\n            return helper(words, curr-1, letters, score, a);\\n        }\\n        int curr_score=0;\\n        for(int i=0;i<words[curr].size();i++){\\n            curr_score+=score[words[curr][i]-\\'a\\'];\\n        }\\n        for(auto temp:remaining){\\n            for(int i=0;i<temp.second;i++)\\n                lettersr.emplace_back(temp.first);\\n        }\\n        int ans2=helper(words, curr-1, lettersr, score, b)+curr_score;        \\n        return max(helper(words, curr-1, letters, score, a), ans2);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        string a=\"\";\\n        for(int i=0;i<letters.size();i++){\\n            a+=letters[i];\\n        }\\n        sort(a.begin(), a.end());\\n        return helper(words, words.size()-1, letters, score,a);        \\n    }\\n};\\n```\\nNote the 2nd code is almost the same as the 1st code. The only difference is the memotisation part.\\nHope you understood the solutions. If you have any doubts, do comment. Please Upvote :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<string>& words, int curr, vector<char> letters, vector<int>& score){\\n\\t\\t//base case: there is no element\\n        if(curr<0)return 0;\\n\\t\\t//using unordered_maps as they have better time complexity than normal  map by a factor of log(N)\\n        unordered_map<char, int>curr_dict, curr_word, remaining;\\n\\t\\t//converting the  current word in consideration and the letter vector in key value format:\\n\\t\\t// where keys are alphabets and values are their frequency\\n        for(int i=0;i<letters.size();i++){\\n            curr_dict[letters[i]]++;\\n        }\\n        for(int i=0;i<words[curr].size();i++){\\n            curr_word[words[curr][i]]++;\\n        }\\t\\t\\n        vector<char>lettersr;\\n        remaining=curr_dict;\\n        int flag=1;\\n\\t\\t//checking if curr_word can be constructed using the letters vectorby comparing frequency of alphabets\\n        for(auto temp:curr_word){\\n            if(curr_dict[temp.first]<temp.second){\\n                flag=0;\\n                break;\\n            }\\n            remaining[temp.first]-=temp.second;\\n        }\\n\\t\\t//if the current word cannot be constructed, we will simply pass it\\n        if(flag==0){\\n            return helper(words, curr-1, letters, score);\\n        }\\n\\t\\t//now comes the case where the current word can be constructed. We have 2 options either construct the\\n\\t\\t//word(receive some score, and reduce the letters vector) or simply pass it\\n\\t\\t//calculating the score received for constructing the word\\n        int curr_score=0;\\n        for(int i=0;i<words[curr].size();i++){\\n            curr_score+=score[words[curr][i]-\\'a\\'];\\n        }\\n\\t\\t//creating a new vector after reducing the alphabets used for making the current word\\n        for(auto temp:remaining){\\n            for(int i=0;i<temp.second;i++)\\n                lettersr.emplace_back(temp.first);\\n        }\\n\\t\\t//calling on the next wor with reduced letters vector and adding the score \\n        int ans2=helper(words, curr-1, lettersr, score)+curr_score;        \\n\\t\\t//returning the maximum value for the two options we had if current wor can be constructed\\n        return max(helper(words, curr-1, letters, score), ans2);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n\\t\\t//will iterate from last element to first.\\n        return helper(words, words.size()-1, letters, score);        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\t//nested unordered_map for dp\\n    unordered_map<int, unordered_map<string, int>>dp;\\n    int helper(vector<string>& words, int curr, vector<char> letters, vector<int>& score, string memory){\\n        if(curr<0)return 0;\\n        if(dp[curr][memory]!=0)return dp[curr][memory];\\n        unordered_map<char, int>curr_dict, curr_word, remaining;\\n        vector<char>lettersr;\\n        for(int i=0;i<letters.size();i++){\\n            curr_dict[letters[i]]++;\\n        }\\n        for(int i=0;i<words[curr].size();i++){\\n            curr_word[words[curr][i]]++;\\n        }\\n        remaining=curr_dict;\\n        int flag=1;\\n        for(auto temp:curr_word){\\n            // cout<<temp.first<<\" \"<<temp.second<<endl;\\n            if(curr_dict[temp.first]<temp.second){\\n                flag=0;\\n                break;\\n            }\\n            remaining[temp.first]-=temp.second;\\n        }\\n\\t\\t// generating the string from vectors a is if we pass the current word, b is if we use the current word.\\n\\t\\t//Converting to strings and sorting increasing time complexity but will still be better for higher constraints \\n\\t\\t//than recursion(exponential). Converting to strings will help us use the unorered_map to memotise\\n        string a=\"\", b=\"\";\\n        for(int i=0;i<letters.size();i++){\\n            a+=letters[i];\\n        }\\n        for(int i=0;i<remaining.size();i++){\\n            b+=remaining[i];\\n        }\\n        sort(a.begin(), a.end());\\n        sort(b.begin(), b.end());\\n        if(flag==0){\\n            return helper(words, curr-1, letters, score, a);\\n        }\\n        int curr_score=0;\\n        for(int i=0;i<words[curr].size();i++){\\n            curr_score+=score[words[curr][i]-\\'a\\'];\\n        }\\n        for(auto temp:remaining){\\n            for(int i=0;i<temp.second;i++)\\n                lettersr.emplace_back(temp.first);\\n        }\\n        int ans2=helper(words, curr-1, lettersr, score, b)+curr_score;        \\n        return max(helper(words, curr-1, letters, score, a), ans2);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        string a=\"\";\\n        for(int i=0;i<letters.size();i++){\\n            a+=letters[i];\\n        }\\n        sort(a.begin(), a.end());\\n        return helper(words, words.size()-1, letters, score,a);        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 426045,
                "title": "c-dfs-optional-memo",
                "content": "Since the number of words is limited to 14, we can just try all combinations. We just need a good way to keep track of used letter, and we use a 26-element array with letter counts for that.\\n\\n#### DFS no Memo\\n```\\nint dfs(vector<string>& ws, vector<int> &cnt, vector<int> &score, int i) {\\n    if (i >= ws.size()) return 0;\\n    auto skipGain = dfs(ws, cnt, score, i + 1), gain = 0, formed = 1;\\n    vector<int> cnt1(begin(cnt), end(cnt));\\n    for (auto ch : ws[i]) {\\n        if (--cnt1[ch - \\'a\\'] < 0) formed = 0;\\n        gain += score[ch - \\'a\\'];\\n    }\\n    return max(skipGain, formed ? \\n        gain + dfs(ws, cnt1, score, i + 1) : 0);\\n}\\nint maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n    vector<int> cnt(26);\\n    for (auto ch : letters) ++cnt[ch - \\'a\\'];\\n    return dfs(words, cnt, score, 0);\\n}\\n```\\n#### Additional considerations\\nIf words can be very long, we can also use a 26-element array with letter counts for words. \\n\\nIf the number of letters and words is high, we can add memoisation. For that we can memoise based on selected words. We can also memoise on the remaining letters, but we may need to also store the current index `i`.",
                "solutionTags": [],
                "code": "```\\nint dfs(vector<string>& ws, vector<int> &cnt, vector<int> &score, int i) {\\n    if (i >= ws.size()) return 0;\\n    auto skipGain = dfs(ws, cnt, score, i + 1), gain = 0, formed = 1;\\n    vector<int> cnt1(begin(cnt), end(cnt));\\n    for (auto ch : ws[i]) {\\n        if (--cnt1[ch - \\'a\\'] < 0) formed = 0;\\n        gain += score[ch - \\'a\\'];\\n    }\\n    return max(skipGain, formed ? \\n        gain + dfs(ws, cnt1, score, i + 1) : 0);\\n}\\nint maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n    vector<int> cnt(26);\\n    for (auto ch : letters) ++cnt[ch - \\'a\\'];\\n    return dfs(words, cnt, score, 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 883660,
                "title": "java-backtracking-full-search-top-down-memoization-and-bottom-up-dp",
                "content": "In the full search, each word is traversed, and it branches into the two cases where the word is included if the letter count is enough or not.\\n\\n![image](https://assets.leetcode.com/users/images/a96c7227-345d-4f65-91e5-0eb67e6c9c31_1602083859.969682.png)\\n\\nAnd, in the phase of backtrack, the maximum value between the values coming up from the sub-branches is adopted.\\n\\n![image](https://assets.leetcode.com/users/images/f2773bd0-15d5-454b-8950-471cf5c86d17_1602084085.3222568.png)\\n\\nSo, the code is as follows.\\n```\\npublic int maxScoreWords(String[] words, char[] letters, int[] score) {\\n   int[] letterCounts = new int[26];\\n   for (char letter : letters)\\n       letterCounts[letter - \\'a\\']++;\\n\\n   return backtrack(words, 0, letterCounts, score);\\n}\\n\\nprivate int backtrack(String[] words, int start, int[] letterCounts, int[] score) {\\n   if (start == words.length)\\n       return 0;\\n\\n   int currScore = 0;\\n   int wordScore = 0;\\n   int[] nextCounts = letterCounts.clone();\\n   for (int i = 0; i < words[start].length(); ++i) {\\n       int idx = words[start].charAt(i) - \\'a\\';\\n       if (nextCounts[idx] == 0) {\\n           wordScore = -1;\\n           break;\\n       }\\n       wordScore += score[idx];\\n       nextCounts[idx]--;\\n   }\\n\\n   if (wordScore > 0)\\n       currScore = backtrack(words, start + 1, nextCounts, score) + wordScore;\\n   currScore = Math.max(currScore, backtrack(words, start + 1, letterCounts, score));\\n\\n   return currScore;\\n}\\n```\\n\\nThen, let\\'s apply memoization now.\\nAs you can see from the picture above, if two nodes which searches the same word with the same letter counts, they are the same sub-problem. So, let\\'s make the memoization key from the word index and letter counts. Since the letter count ranges from 0 to 10, we can create a 26-digit string using 0-9 and \\'a\\'.\\n\\n```\\npublic int maxScoreWords(String[] words, char[] letters, int[] score) {\\n   int[] letterCounts = new int[26];\\n   for (char letter : letters)\\n       letterCounts[letter - \\'a\\']++;\\n\\n   return backtrack(words, 0, letterCounts, score, new HashMap<>());\\n}\\n\\nprivate int backtrack(String[] words, int start, int[] letterCounts, int[] score, Map<String, Integer> memo) {\\n   if (start == words.length)\\n       return 0;\\n   String key = getKey(letterCounts, start);\\n   if (memo.containsKey(key))\\n       return memo.get(key);\\n\\n   int currScore = 0;\\n   int wordScore = 0;\\n   int[] nextCounts = letterCounts.clone();\\n   for (int i = 0; i < words[start].length(); ++i) {\\n       int idx = words[start].charAt(i) - \\'a\\';\\n       if (nextCounts[idx] == 0) {\\n           wordScore = -1;\\n           break;\\n       }\\n       wordScore += score[idx];\\n       nextCounts[idx]--;\\n   }\\n\\n   if (wordScore > 0)\\n       currScore = backtrack(words, start + 1, nextCounts, score, memo) + wordScore;\\n   currScore = Math.max(currScore, backtrack(words, start + 1, letterCounts, score, memo));\\n   memo.put(key, currScore);\\n\\n   return currScore;\\n}\\n\\nprivate String getKey(int[] letterCounts, int idx) {\\n   StringBuilder sb = new StringBuilder();\\n   for (int i = 0; i < 26; ++i)\\n       sb.append((letterCounts[i] < 10) ? letterCounts[i] : \\'a\\');\\n   sb.append(\\',\\');\\n   sb.append(idx);\\n   return sb.toString();\\n}\\n```\\n\\nSince the probability of matching the keys is quite low, in fact, the hit-ratio of memoization seems to be very low.\\nAnyway, let\\'s rewrite it as a bottom-up tabulation DP. Actually, this problem looks very similar to the 0-1 knapsack problem. The only difference is that there are letter counts instead of the total weight limit. So, we need to serialize letter counts just like when creating a memoization key. And because the table is very sparse, let\\'s only solve the valid cases rather than unconditionally solve all.\\nSo, Map is used instead of 2D array.\\n\\n```\\npublic int maxScoreWords(String[] words, char[] letters, int[] score) {\\n   int[] letterCounts = new int[26];\\n   for (char letter : letters)\\n       letterCounts[letter - \\'a\\']++;\\n\\n   int res = 0;\\n   Map<String, Integer> dp = new HashMap<>();\\n   dp.put(getKey(letterCounts), 0);\\n\\n   for (String word : words) {\\n       for (Map.Entry<String, Integer> entry : new ArrayList<>(dp.entrySet())) {\\n           letterCounts = getLetterCounts(entry.getKey());\\n           int totalScore = entry.getValue();\\n           for (int i = 0; i < word.length(); ++i) {\\n               int idx = word.charAt(i) - \\'a\\';\\n               if (letterCounts[idx] == 0) {\\n                   totalScore = -1;\\n                   break;\\n               }\\n               totalScore += score[idx];\\n               letterCounts[idx]--;\\n           }\\n\\n           if (totalScore >= 0) {\\n               String key = getKey(letterCounts);\\n               res = Math.max(res, totalScore);\\n               dp.put(key, Math.max(dp.getOrDefault(key, 0), totalScore));\\n           }\\n       }\\n   }\\n   return res;\\n}\\n\\nprivate String getKey(int[] letterCounts) {\\n   StringBuilder sb = new StringBuilder();\\n   for (int i = 0; i < 26; ++i)\\n       sb.append((letterCounts[i] < 10) ? letterCounts[i] : \\'a\\');\\n   return sb.toString();\\n}\\n\\nprivate int[] getLetterCounts(String key) {\\n   int[] letterCounts = new int[26];\\n   for (int i = 0; i < 26; ++i) {\\n       int count = key.charAt(i) - \\'0\\';\\n       letterCounts[i] = (count < 0 || count > 9) ? 10 : count;\\n   }\\n   return letterCounts;\\n}\\n```\\n\\nVisualizing the above code is as follows.\\n\\n![image](https://assets.leetcode.com/users/images/79f8faef-9772-45a3-a1d8-b0bf9238b2aa_1602085363.6752236.png)\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic int maxScoreWords(String[] words, char[] letters, int[] score) {\\n   int[] letterCounts = new int[26];\\n   for (char letter : letters)\\n       letterCounts[letter - \\'a\\']++;\\n\\n   return backtrack(words, 0, letterCounts, score);\\n}\\n\\nprivate int backtrack(String[] words, int start, int[] letterCounts, int[] score) {\\n   if (start == words.length)\\n       return 0;\\n\\n   int currScore = 0;\\n   int wordScore = 0;\\n   int[] nextCounts = letterCounts.clone();\\n   for (int i = 0; i < words[start].length(); ++i) {\\n       int idx = words[start].charAt(i) - \\'a\\';\\n       if (nextCounts[idx] == 0) {\\n           wordScore = -1;\\n           break;\\n       }\\n       wordScore += score[idx];\\n       nextCounts[idx]--;\\n   }\\n\\n   if (wordScore > 0)\\n       currScore = backtrack(words, start + 1, nextCounts, score) + wordScore;\\n   currScore = Math.max(currScore, backtrack(words, start + 1, letterCounts, score));\\n\\n   return currScore;\\n}\\n```\n```\\npublic int maxScoreWords(String[] words, char[] letters, int[] score) {\\n   int[] letterCounts = new int[26];\\n   for (char letter : letters)\\n       letterCounts[letter - \\'a\\']++;\\n\\n   return backtrack(words, 0, letterCounts, score, new HashMap<>());\\n}\\n\\nprivate int backtrack(String[] words, int start, int[] letterCounts, int[] score, Map<String, Integer> memo) {\\n   if (start == words.length)\\n       return 0;\\n   String key = getKey(letterCounts, start);\\n   if (memo.containsKey(key))\\n       return memo.get(key);\\n\\n   int currScore = 0;\\n   int wordScore = 0;\\n   int[] nextCounts = letterCounts.clone();\\n   for (int i = 0; i < words[start].length(); ++i) {\\n       int idx = words[start].charAt(i) - \\'a\\';\\n       if (nextCounts[idx] == 0) {\\n           wordScore = -1;\\n           break;\\n       }\\n       wordScore += score[idx];\\n       nextCounts[idx]--;\\n   }\\n\\n   if (wordScore > 0)\\n       currScore = backtrack(words, start + 1, nextCounts, score, memo) + wordScore;\\n   currScore = Math.max(currScore, backtrack(words, start + 1, letterCounts, score, memo));\\n   memo.put(key, currScore);\\n\\n   return currScore;\\n}\\n\\nprivate String getKey(int[] letterCounts, int idx) {\\n   StringBuilder sb = new StringBuilder();\\n   for (int i = 0; i < 26; ++i)\\n       sb.append((letterCounts[i] < 10) ? letterCounts[i] : \\'a\\');\\n   sb.append(\\',\\');\\n   sb.append(idx);\\n   return sb.toString();\\n}\\n```\n```\\npublic int maxScoreWords(String[] words, char[] letters, int[] score) {\\n   int[] letterCounts = new int[26];\\n   for (char letter : letters)\\n       letterCounts[letter - \\'a\\']++;\\n\\n   int res = 0;\\n   Map<String, Integer> dp = new HashMap<>();\\n   dp.put(getKey(letterCounts), 0);\\n\\n   for (String word : words) {\\n       for (Map.Entry<String, Integer> entry : new ArrayList<>(dp.entrySet())) {\\n           letterCounts = getLetterCounts(entry.getKey());\\n           int totalScore = entry.getValue();\\n           for (int i = 0; i < word.length(); ++i) {\\n               int idx = word.charAt(i) - \\'a\\';\\n               if (letterCounts[idx] == 0) {\\n                   totalScore = -1;\\n                   break;\\n               }\\n               totalScore += score[idx];\\n               letterCounts[idx]--;\\n           }\\n\\n           if (totalScore >= 0) {\\n               String key = getKey(letterCounts);\\n               res = Math.max(res, totalScore);\\n               dp.put(key, Math.max(dp.getOrDefault(key, 0), totalScore));\\n           }\\n       }\\n   }\\n   return res;\\n}\\n\\nprivate String getKey(int[] letterCounts) {\\n   StringBuilder sb = new StringBuilder();\\n   for (int i = 0; i < 26; ++i)\\n       sb.append((letterCounts[i] < 10) ? letterCounts[i] : \\'a\\');\\n   return sb.toString();\\n}\\n\\nprivate int[] getLetterCounts(String key) {\\n   int[] letterCounts = new int[26];\\n   for (int i = 0; i < 26; ++i) {\\n       int count = key.charAt(i) - \\'0\\';\\n       letterCounts[i] = (count < 0 || count > 9) ? 10 : count;\\n   }\\n   return letterCounts;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 425104,
                "title": "detailed-explanation-using-recursion",
                "content": "# Intuition\\n* Since the number of words is quite less (14), we can just generate all the subsets. Let\\'s call a subset valid if all the words in that subset can be formed by using the given letters. It is clear that we need to maximize the score of valid subsets. To do this, we generate all subsets, and check if it is valid. If it is, we find its score and update the global maxima.\\n\\n* To generate the subsets, we create a function call `generate_subset(words, n)`  which generate all the subsets of the vector `words`.  To quickly recap, we have 2 choices for the last element, either to take it or to leave it. We store this choice in an array called `taken` where `taken[i]` represent that the `i-th` element was taken in our journey. We then recurse for the remaining elements.\\n\\n* When `n` becomes zero, it means we cannot make any more choices. So now, we traverse our `taken` array to find out the elements in this subset. Then we count the frequency of each letter in this subset. If the frequency of each letter is under the provided limit, it means it is a valid subet. Hence, we find the score of this subset and update the maxima.\\n\\n```cpp\\nclass Solution\\n{\\npublic:\\n    vector<bool> taken;\\n    vector<int> count;\\n    vector<int> score;\\n    int max_sum = 0;\\n    \\n    void update_score(vector<string>& words);\\n    void generate_subset(vector<string>& words, int n);\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score);\\n};\\n\\nvoid Solution :: generate_subset(vector<string>& words, int n)\\n{\\n    if(n == 0)\\n    {\\n        update_score(words);\\n        return;\\n    }\\n    \\n    taken[n-1] = true;\\n    generate_subset(words, n-1);\\n    \\n    taken[n-1] = false;\\n    generate_subset(words, n-1);\\n}\\n\\nvoid Solution :: update_score(vector<string>& words)\\n{\\n    int current_score = 0;\\n    vector<int> freq(26, 0);\\n    \\n    for(int i = 0; i < words.size(); i++)\\n    {\\n        if(taken[i])\\n        {\\n            for(auto ele : words[i])\\n            {\\n                int ind = ele - \\'a\\';\\n                current_score += score[ind];\\n                freq[ind]++;\\n                \\n                if(freq[ind] > count[ind])\\n                      return;\\n            }\\n        }\\n    }\\n                      \\n    max_sum = max(max_sum, current_score);\\n}\\n                      \\nint Solution :: maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score)\\n{\\n    taken.resize(words.size(), false);\\n    count.resize(26, 0);\\n    this->score = score;\\n    \\n    for(auto ele : letters)\\n        count[ele - \\'a\\']++;\\n    \\n    int n = words.size();\\n    generate_subset(words, n);\\n    \\n    return max_sum;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution\\n{\\npublic:\\n    vector<bool> taken;\\n    vector<int> count;\\n    vector<int> score;\\n    int max_sum = 0;\\n    \\n    void update_score(vector<string>& words);\\n    void generate_subset(vector<string>& words, int n);\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score);\\n};\\n\\nvoid Solution :: generate_subset(vector<string>& words, int n)\\n{\\n    if(n == 0)\\n    {\\n        update_score(words);\\n        return;\\n    }\\n    \\n    taken[n-1] = true;\\n    generate_subset(words, n-1);\\n    \\n    taken[n-1] = false;\\n    generate_subset(words, n-1);\\n}\\n\\nvoid Solution :: update_score(vector<string>& words)\\n{\\n    int current_score = 0;\\n    vector<int> freq(26, 0);\\n    \\n    for(int i = 0; i < words.size(); i++)\\n    {\\n        if(taken[i])\\n        {\\n            for(auto ele : words[i])\\n            {\\n                int ind = ele - \\'a\\';\\n                current_score += score[ind];\\n                freq[ind]++;\\n                \\n                if(freq[ind] > count[ind])\\n                      return;\\n            }\\n        }\\n    }\\n                      \\n    max_sum = max(max_sum, current_score);\\n}\\n                      \\nint Solution :: maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score)\\n{\\n    taken.resize(words.size(), false);\\n    count.resize(26, 0);\\n    this->score = score;\\n    \\n    for(auto ele : letters)\\n        count[ele - \\'a\\']++;\\n    \\n    int n = words.size();\\n    generate_subset(words, n);\\n    \\n    return max_sum;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425454,
                "title": "a-variant-of-the-classic-knapsack-problem",
                "content": "If the current set `L` of letters is sufficient to build the current word `W`, `dp[W][L] = max(scoreOf(W) + dp[W\\'][L\\'], dp[W\\'][L]` where `W\\'` is the next word in the list and `L\\'` is `L-W`. On the other hand, if the number of a character in `W` is more than that in `L`, we move on to the next word `W\\'`, `dp[W][L] = dp[W\\'][L]`.\\n\\nWhen there is no more word, which is the base case, we can just return `0`.\\n\\n**Python**:\\n```\\nimport collections\\n\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        def solve(idx, counter):\\n            if idx == len(words):\\n                return 0\\n\\n            wc = collections.Counter(words[idx])\\n            if all(counter[key] >= wc[key] for key in wc):\\n                ans = max(sum(score[ord(c)-ord(\\'a\\')] for c in words[idx]) + solve(idx+1, counter-wc), solve(idx+1, counter))\\n            else:\\n                ans = solve(idx+1, counter) \\n                \\n            return ans\\n        \\n        return solve(0, collections.Counter(letters))\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\n\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        def solve(idx, counter):\\n            if idx == len(words):\\n                return 0\\n\\n            wc = collections.Counter(words[idx])\\n            if all(counter[key] >= wc[key] for key in wc):\\n                ans = max(sum(score[ord(c)-ord(\\'a\\')] for c in words[idx]) + solve(idx+1, counter-wc), solve(idx+1, counter))\\n            else:\\n                ans = solve(idx+1, counter) \\n                \\n            return ans\\n        \\n        return solve(0, collections.Counter(letters))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425264,
                "title": "c-straightforward-backtracking",
                "content": "\\n```\\nclass Solution {\\n    int ans = 0;\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> count(26, 0), used(26, 0);\\n        for (auto & c : letters) {\\n            count[c-\\'a\\']++;\\n        }\\n        backtrack(words, score, count, used, 0, 0);\\n        return ans;\\n    }\\n    void backtrack(vector<string>& words, vector<int>& score, vector<int> &count, vector<int> &used, int pos, int reward) {\\n        for (int i = 0; i < 26; ++i) {\\n            if (used[i] > count[i])\\n                return;\\n        }\\n        ans = max(reward, ans);\\n        for (int i = pos; i < words.size(); ++i) {\\n            for (auto & c : words[i]) {\\n                used[c-\\'a\\']++;\\n                reward += score[c-\\'a\\'];\\n            }\\n            backtrack(words, score, count, used, i+1, reward);\\n            for (auto & c : words[i]) {\\n                used[c-\\'a\\']--;\\n                reward -= score[c-\\'a\\'];\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> count(26, 0), used(26, 0);\\n        for (auto & c : letters) {\\n            count[c-\\'a\\']++;\\n        }\\n        backtrack(words, score, count, used, 0, 0);\\n        return ans;\\n    }\\n    void backtrack(vector<string>& words, vector<int>& score, vector<int> &count, vector<int> &used, int pos, int reward) {\\n        for (int i = 0; i < 26; ++i) {\\n            if (used[i] > count[i])\\n                return;\\n        }\\n        ans = max(reward, ans);\\n        for (int i = pos; i < words.size(); ++i) {\\n            for (auto & c : words[i]) {\\n                used[c-\\'a\\']++;\\n                reward += score[c-\\'a\\'];\\n            }\\n            backtrack(words, score, count, used, i+1, reward);\\n            for (auto & c : words[i]) {\\n                used[c-\\'a\\']--;\\n                reward -= score[c-\\'a\\'];\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570331,
                "title": "c-full-readable-code",
                "content": "**Please do  Upvote  if you like it**\\n```\\nclass Solution {\\npublic:\\n    int dp[15][32768];\\n    bool canMake(string &s,unordered_map<char,int> &m)\\n    {\\n        unordered_map<char,int> n=m;\\n        for(auto i: s)\\n        {\\n            if(n[i]<=0)\\n                return false;\\n            n[i]--;\\n        }\\n        return true;\\n    }\\n    int find(string &s,unordered_map<char,int> &m,vector<int>&score)\\n    {\\n        int ans=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            m[s[i]]--;\\n            ans+=score[s[i]-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    void undochange(string &s,unordered_map<char,int> &m)\\n    {\\n        for(int i=0;i<s.length();i++)\\n        {\\n            m[s[i]]++;\\n            \\n        }\\n    }\\n    int sol(vector<string>& words, unordered_map<char,int> &m, vector<int>& score,int curr,int mask)\\n    {\\n        if(curr>=words.size())\\n        {\\n            return 0;\\n        }\\n        if(dp[curr][mask]!=-1)\\n            return dp[curr][mask];\\n        \\n        int ans=0;\\n        for(int i=curr;i<words.size();i++)\\n        {\\n            if(canMake(words[i],m))\\n            {\\n                int s=find(words[i],m,score);\\n                int op1=s+sol(words,m,score,i+1,(1<<i)|mask);\\n                ans=max(ans,op1);\\n                undochange(words[i],m);\\n            }\\n            \\n        }\\n        return dp[curr][mask]=  ans;\\n        \\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        unordered_map<char,int> m;\\n        for(int i=0;i<letters.size();i++)\\n        {\\n            m[letters[i]]++;\\n        }\\n        return sol(words,m,score,0,0);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[15][32768];\\n    bool canMake(string &s,unordered_map<char,int> &m)\\n    {\\n        unordered_map<char,int> n=m;\\n        for(auto i: s)\\n        {\\n            if(n[i]<=0)\\n                return false;\\n            n[i]--;\\n        }\\n        return true;\\n    }\\n    int find(string &s,unordered_map<char,int> &m,vector<int>&score)\\n    {\\n        int ans=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            m[s[i]]--;\\n            ans+=score[s[i]-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    void undochange(string &s,unordered_map<char,int> &m)\\n    {\\n        for(int i=0;i<s.length();i++)\\n        {\\n            m[s[i]]++;\\n            \\n        }\\n    }\\n    int sol(vector<string>& words, unordered_map<char,int> &m, vector<int>& score,int curr,int mask)\\n    {\\n        if(curr>=words.size())\\n        {\\n            return 0;\\n        }\\n        if(dp[curr][mask]!=-1)\\n            return dp[curr][mask];\\n        \\n        int ans=0;\\n        for(int i=curr;i<words.size();i++)\\n        {\\n            if(canMake(words[i],m))\\n            {\\n                int s=find(words[i],m,score);\\n                int op1=s+sol(words,m,score,i+1,(1<<i)|mask);\\n                ans=max(ans,op1);\\n                undochange(words[i],m);\\n            }\\n            \\n        }\\n        return dp[curr][mask]=  ans;\\n        \\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        unordered_map<char,int> m;\\n        for(int i=0;i<letters.size();i++)\\n        {\\n            m[letters[i]]++;\\n        }\\n        return sol(words,m,score,0,0);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425211,
                "title": "java-bit-manipulation-solution-clean-code-5ms-beat-100",
                "content": "**Explain:** \\n- The idea is simple, just try all possible combination of 0/1 (0 means don\\'t feed this word, 1 means feed this word) by using Bit manipulation algorithm, then get the totalScore of each combination, compare the totalScore with maxScore.\\n- It takes 2^14 for combination, |words.length| = 14, each of combination, each combination, we check 14\\\\*15 times.\\n\\n**Time complexity**: O(15\\\\*14\\\\*2^14), but we do some prunes, so it process within 5ms \\n\\n**Java**\\n```java\\nclass Solution {\\n    int getBit(int x, int k) {\\n        return (x >> k) & 1;\\n    }\\n\\n    boolean canFeed(String word, int[] cnt) {\\n        for (int i = 0; i < word.length(); i++) {\\n            if (cnt[word.charAt(i) - \\'a\\']-- <= 0) // prune\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int cnt[] = new int[26];\\n        for (char c : letters) cnt[c - \\'a\\']++;\\n\\n        int n = words.length;\\n        int[] scores = new int[n]; // Calculate the score of each word\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < words[i].length(); j++)\\n                scores[i] += score[words[i].charAt(j) - \\'a\\'];\\n        }\\n\\n        int cntClone[] = new int[26];\\n        int maxScore = 0, bound = (int) Math.pow(2, n);\\n        for (int i = 0; i <= bound; i++) { // O(15 * 14 * 2^14)\\n            System.arraycopy(cnt, 0, cntClone, 0, 26);\\n            int totalScore = 0;\\n            for (int j = 0; j < n; j++) { // O(15 * 14)\\n                if (getBit(i, j) == 1) { // prune a haft of the number of combinations\\n                    if (canFeed(words[j], cntClone)) { // O(15)\\n                        totalScore += scores[j];\\n                    } else {\\n                        break; // prune\\n                    }\\n                }\\n            }\\n            maxScore = Math.max(maxScore, totalScore);\\n        }\\n\\n        return maxScore;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    int getBit(int x, int k) {\\n        return (x >> k) & 1;\\n    }\\n\\n    boolean canFeed(String word, int[] cnt) {\\n        for (int i = 0; i < word.length(); i++) {\\n            if (cnt[word.charAt(i) - \\'a\\']-- <= 0) // prune\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int cnt[] = new int[26];\\n        for (char c : letters) cnt[c - \\'a\\']++;\\n\\n        int n = words.length;\\n        int[] scores = new int[n]; // Calculate the score of each word\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < words[i].length(); j++)\\n                scores[i] += score[words[i].charAt(j) - \\'a\\'];\\n        }\\n\\n        int cntClone[] = new int[26];\\n        int maxScore = 0, bound = (int) Math.pow(2, n);\\n        for (int i = 0; i <= bound; i++) { // O(15 * 14 * 2^14)\\n            System.arraycopy(cnt, 0, cntClone, 0, 26);\\n            int totalScore = 0;\\n            for (int j = 0; j < n; j++) { // O(15 * 14)\\n                if (getBit(i, j) == 1) { // prune a haft of the number of combinations\\n                    if (canFeed(words[j], cntClone)) { // O(15)\\n                        totalScore += scores[j];\\n                    } else {\\n                        break; // prune\\n                    }\\n                }\\n            }\\n            maxScore = Math.max(maxScore, totalScore);\\n        }\\n\\n        return maxScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670377,
                "title": "python-3-10-lines-recursion-t-m-97-98",
                "content": "```\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n\\n        f, ans = lambda x : sum(score[ord(c) - 97] for c in x), 0\\n\\n        def dfs(words,letters, tally):\\n            nonlocal ans\\n            \\n            for i in range(len(words)):\\n                cWord=Counter(words[i])\\n\\t\\t\\t\\t\\n                if all(letters[c] >= cWord[c] for c in cWord):\\n                    dfs(words[i+1:], letters - cWord, tally + f(words[i]))\\n\\n            ans = max(ans,tally)\\n            return ans\\n\\n        return dfs(words, Counter(letters), 0)\\n```\\n[https://leetcode.com/submissions/detail/816809852/ ](http://)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n\\n        f, ans = lambda x : sum(score[ord(c) - 97] for c in x), 0\\n\\n        def dfs(words,letters, tally):\\n            nonlocal ans\\n            \\n            for i in range(len(words)):\\n                cWord=Counter(words[i])\\n\\t\\t\\t\\t\\n                if all(letters[c] >= cWord[c] for c in cWord):\\n                    dfs(words[i+1:], letters - cWord, tally + f(words[i]))\\n\\n            ans = max(ans,tally)\\n            return ans\\n\\n        return dfs(words, Counter(letters), 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480201,
                "title": "a-good-naming-convention-makes-code-explanatory-itself-have-a-look",
                "content": "At a first glance after solving this question, I have gone through comment section and read the codes. But the solution code makes problem more hard than the actual problem. This question is as simple as that : \\nFor each i-th we have two option\\n1. whether i can use it to maximize my score only if it\\'s violate the remaining frequencies of characters\\n2. Or i have always a option to ignore it and let the letters add for next word\\n\\nThis intution work because the constraints on *words.length* too tight. So we can go for all possible subsets.\\n\\n# Note :\\nI didn\\'t do anything except followed some right naming convention. And now code is  just like read the paragraph.\\n\\n```\\nclass Solution {\\n\\n    private int solve(String []words, int i, int [] cntLetter, int []score) {\\n        if (i == words.length) {\\n            return 0;\\n        }\\n\\n        int []newCnt = cntLetter.clone();\\n\\n        //  Will tell that whether we can take current word or not\\n        boolean ableToForm = true;\\n\\n        //  If we\\'ll be able to take this word then what will be the score\\n        int formedValue = 0;\\n\\n        for (int j = 0; j < words[i].length() &&  ableToForm; j++) {\\n            ableToForm = ableToForm && (--newCnt[words[i].charAt(j) - \\'a\\'] >= 0);\\n            formedValue += score[words[i].charAt(j) - \\'a\\'];\\n        }\\n\\n\\n        //  We have 2 choice for any i-th\\n        int take = 0, ignore = 0;\\n\\n        // Either I can take it.\\n        if (ableToForm) {\\n            take = formedValue + solve(words, i + 1, newCnt, score);\\n        }\\n\\n        //  Or I will have always a way to ignore it.\\n        ignore = solve(words, i + 1, cntLetter, score);\\n        return Math.max(take, ignore);\\n    }\\n\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int []cntLetter = new int[26];\\n        for (char letter : letters) {\\n            cntLetter[letter - \\'a\\']++;\\n        }\\n        return solve(words, 0, cntLetter, score);\\n    }\\n}\\n```\\n\\nUpvote if it helps you.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    private int solve(String []words, int i, int [] cntLetter, int []score) {\\n        if (i == words.length) {\\n            return 0;\\n        }\\n\\n        int []newCnt = cntLetter.clone();\\n\\n        //  Will tell that whether we can take current word or not\\n        boolean ableToForm = true;\\n\\n        //  If we\\'ll be able to take this word then what will be the score\\n        int formedValue = 0;\\n\\n        for (int j = 0; j < words[i].length() &&  ableToForm; j++) {\\n            ableToForm = ableToForm && (--newCnt[words[i].charAt(j) - \\'a\\'] >= 0);\\n            formedValue += score[words[i].charAt(j) - \\'a\\'];\\n        }\\n\\n\\n        //  We have 2 choice for any i-th\\n        int take = 0, ignore = 0;\\n\\n        // Either I can take it.\\n        if (ableToForm) {\\n            take = formedValue + solve(words, i + 1, newCnt, score);\\n        }\\n\\n        //  Or I will have always a way to ignore it.\\n        ignore = solve(words, i + 1, cntLetter, score);\\n        return Math.max(take, ignore);\\n    }\\n\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int []cntLetter = new int[26];\\n        for (char letter : letters) {\\n            cntLetter[letter - \\'a\\']++;\\n        }\\n        return solve(words, 0, cntLetter, score);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425531,
                "title": "python-dp-on-count-of-rest-usable-letters",
                "content": "dp(wIdx,lettercnt) stands for the max score we can obtain, given the word indexs before or equal to \"wIdx\", with count of rest usable letters being \"lettercnt\".\\nFor each word at index \"wIdx\", we can choose to use it or not use it. Choose whichever produces max score.\\n\\n```\\nimport functools\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        lettercnt=[0]*26\\n        for l in letters:\\n            lettercnt[ord(l)-ord(\\'a\\')]+=1\\n            \\n        @functools.lru_cache(None)\\n        def dp(wIdx,lettercnt):\\n            if wIdx>=len(words):\\n                return 0\\n            lettercnt2=list(lettercnt)\\n            res=0\\n            for c in words[wIdx]:\\n                k=ord(c)-ord(\\'a\\')\\n                if lettercnt2[k]:\\n                    lettercnt2[k]-=1\\n                    res+=score[k]\\n                else:\\n                    res=0\\n                    break\\n            if res:\\n                res+=dp(wIdx+1, tuple(lettercnt2))\\n            return max(res,dp(wIdx+1,lettercnt))\\n        return dp(0, tuple(lettercnt))\\n```",
                "solutionTags": [],
                "code": "```\\nimport functools\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        lettercnt=[0]*26\\n        for l in letters:\\n            lettercnt[ord(l)-ord(\\'a\\')]+=1\\n            \\n        @functools.lru_cache(None)\\n        def dp(wIdx,lettercnt):\\n            if wIdx>=len(words):\\n                return 0\\n            lettercnt2=list(lettercnt)\\n            res=0\\n            for c in words[wIdx]:\\n                k=ord(c)-ord(\\'a\\')\\n                if lettercnt2[k]:\\n                    lettercnt2[k]-=1\\n                    res+=score[k]\\n                else:\\n                    res=0\\n                    break\\n            if res:\\n                res+=dp(wIdx+1, tuple(lettercnt2))\\n            return max(res,dp(wIdx+1,lettercnt))\\n        return dp(0, tuple(lettercnt))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354166,
                "title": "easiest-solution-to-understand-100-runtime-32-ms-python-explanation-and-comments",
                "content": "\\n        \\n  \\n        \\n        # This problem is quite similiar to classic dp problems\\n        # where we have two options \\n        # 1. = choose that word if possible ( if it is following all conditions ) and go forward \\n        # 2. = If not possible to choose just go forward\\n        \\n        # return maximum of all options you choosed .\\n        \\n        \\n        def abhi(n,letter):\\n            \\n            if n==len(words):return 0\\n            \\n            ans =0 # thie will calculate score of current word\\n            \\n            copy = letter \\n            \\n            for i in words[n]:\\n                \\n                if i not in copy:return abhi(n+1, letter) # if this word has a letter which is not\\n                # available just move forward \\n                \\n                copy = copy.replace(i,\\'\\',1)\\n                \\n                ans+= score[ord(i)-97]\\n                \\n            # if the current word has all its letter available on letter\\n            \\n            return max( abhi(n+1, letter) , ans+abhi(n+1, copy))\\n            #      max(not choosing , choosing that word) # two choices\\n            \\n        return abhi(0,\\'\\'.join(letters))\\n\\n\\nif you like solution and it helps you **Kindly upvote !!**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n        \\n  \\n        \\n        # This problem is quite similiar to classic dp problems\\n        # where we have two options \\n        # 1. = choose that word if possible ( if it is following all conditions ) and go forward \\n        # 2. = If not possible to choose just go forward\\n        \\n        # return maximum of all options you choosed .\\n        \\n        \\n        def abhi(n,letter):\\n            \\n            if n==len(words):return 0\\n            \\n            ans =0 # thie will calculate score of current word\\n            \\n            copy = letter \\n            \\n            for i in words[n]:\\n                \\n                if i not in copy:return abhi(n+1, letter) # if this word has a letter which is not\\n                # available just move forward \\n                \\n                copy = copy.replace(i,\\'\\',1)\\n                \\n                ans+= score[ord(i)-97]\\n                \\n            # if the current word has all its letter available on letter\\n            \\n            return max( abhi(n+1, letter) , ans+abhi(n+1, copy))\\n            #      max(not choosing , choosing that word) # two choices\\n            \\n        return abhi(0,\\'\\'.join(letters))\\n\\n\\nif you like solution and it helps you **Kindly upvote !!**",
                "codeTag": "Java"
            },
            {
                "id": 425216,
                "title": "simple-11-lines-python-dfs-with-counter",
                "content": "\\'\\'\\'\\nfrom collections import Counter\\nclass Solution:\\n\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        self.ans=0\\n        count=Counter(letters)    \\n        word_score={word:sum(score[ord(c)-97] for c in word) for word in words}\\n        def dfs(words,count,curS):\\n            self.ans=max(self.ans,curS) \\n            for i in range(len(words)):\\n                cword=Counter(words[i])\\n                if all(count[c]>=cword[c] for c in cword):\\n                    dfs(words[i+1:],count-cword,curS+word_score[words[i]])\\n        dfs(words,count,0)\\n        return self.ans\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        self.ans=0\\n        count=Counter(letters)    \\n        word_score={word:sum(score[ord(c)-97] for c in word) for word in words}",
                "codeTag": "Java"
            },
            {
                "id": 2401314,
                "title": "c-easy-recursive-code-knapsack-variation",
                "content": "```\\nclass Solution {\\npublic://ignore my bad english...i hope it is gonna help\\n    bool check(string s,vector<int> freq){ //function to check whether do we have enough frequency to include this string or not.\\n        for(int i=0;i<s.size();i++){\\n           if(freq[s[i]-\\'a\\']==0) return false; //not having the enough frequency to include this string\\n            freq[s[i]-\\'a\\']--;\\n        }\\n        return true;//we have enough frequency of every letter.\\n    }\\n    int solve(vector<string>& words,vector<int>& freq,vector<int>& score,int i){\\n        if(i==words.size()) return 0;//return 0 when we reach at the end.\\n\\n        int ans=0;//initialy we have 0 score.\\n        \\n        ans=max(ans,solve(words,freq,score,i+1));//we try to skip the current string so that we can maximize our answer\\n\\n        if(check(words[i],freq)){//if enough letters is present in the string we can try to take the score of the current string \\n            vector<int>dummy_freq=freq;//dummy freq vector to store frequency of remaining letters.\\n            int curr_score=0;\\n            for(int j=0;j<words[i].size();j++){\\n                curr_score+=score[words[i][j]-\\'a\\'];// here we add the score of the particular letters which is present in the string\\n                dummy_freq[words[i][j]-\\'a\\']--;//decrease the freq of every letter of the current string.\\n            }\\n            ans=max(ans,curr_score+solve(words,dummy_freq,score,i+1));//here we update our freq vector to dummy_freq which we get after decreasing the frequency of letters which is present in current string.\\n        }\\n            \\n        return ans;\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n       vector<int>freq(26,0);\\n        for(int i=0;i<letters.size();i++){\\n            freq[letters[i]-\\'a\\']++;//storing freq of all the letters\\n        }\\n        return solve(words,freq,score,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic://ignore my bad english...i hope it is gonna help\\n    bool check(string s,vector<int> freq){ //function to check whether do we have enough frequency to include this string or not.\\n        for(int i=0;i<s.size();i++){\\n           if(freq[s[i]-\\'a\\']==0) return false; //not having the enough frequency to include this string\\n            freq[s[i]-\\'a\\']--;\\n        }\\n        return true;//we have enough frequency of every letter.\\n    }\\n    int solve(vector<string>& words,vector<int>& freq,vector<int>& score,int i){\\n        if(i==words.size()) return 0;//return 0 when we reach at the end.\\n\\n        int ans=0;//initialy we have 0 score.\\n        \\n        ans=max(ans,solve(words,freq,score,i+1));//we try to skip the current string so that we can maximize our answer\\n\\n        if(check(words[i],freq)){//if enough letters is present in the string we can try to take the score of the current string \\n            vector<int>dummy_freq=freq;//dummy freq vector to store frequency of remaining letters.\\n            int curr_score=0;\\n            for(int j=0;j<words[i].size();j++){\\n                curr_score+=score[words[i][j]-\\'a\\'];// here we add the score of the particular letters which is present in the string\\n                dummy_freq[words[i][j]-\\'a\\']--;//decrease the freq of every letter of the current string.\\n            }\\n            ans=max(ans,curr_score+solve(words,dummy_freq,score,i+1));//here we update our freq vector to dummy_freq which we get after decreasing the frequency of letters which is present in current string.\\n        }\\n            \\n        return ans;\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n       vector<int>freq(26,0);\\n        for(int i=0;i<letters.size();i++){\\n            freq[letters[i]-\\'a\\']++;//storing freq of all the letters\\n        }\\n        return solve(words,freq,score,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182341,
                "title": "easy-java-solution-with-comments-recursion-and-backtracking",
                "content": "```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        \\n        int[] farr = new int[26];\\n        for(char ch : letters) farr[ch - \\'a\\']++;\\n        \\n        return solve(words,farr,score,0);\\n    }\\n    \\n    public int solve(String[] words, int[] farr, int[] score, int idx){\\n        if(idx == words.length) return 0;\\n        \\n        int sno = solve(words,farr,score,idx + 1);\\n        int sword = 0;\\n        boolean flag = true;\\n        String word = words[idx];\\n        int syes = 0;\\n        for(int i = 0; i < word.length(); ++i){\\n            char ch = word.charAt(i);\\n            \\n            if(farr[ch-\\'a\\'] == 0) flag = false; // not possible to include word\\n            \\n            farr[ch-\\'a\\']--;//  decrease the frequency\\n            sword += score[ch-\\'a\\']; // increase the particular word score\\n        }\\n        \\n        if(flag) syes = sword+ solve(words,farr,score,idx+1);\\n        \\n        for(int i =0; i < word.length(); ++i){\\n            char ch = word.charAt(i);\\n            farr[ch-\\'a\\']++;// backtrack and undo the changes\\n        }\\n        \\n        return Math.max(syes,sno); // find the max score\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        \\n        int[] farr = new int[26];\\n        for(char ch : letters) farr[ch - \\'a\\']++;\\n        \\n        return solve(words,farr,score,0);\\n    }\\n    \\n    public int solve(String[] words, int[] farr, int[] score, int idx){\\n        if(idx == words.length) return 0;\\n        \\n        int sno = solve(words,farr,score,idx + 1);\\n        int sword = 0;\\n        boolean flag = true;\\n        String word = words[idx];\\n        int syes = 0;\\n        for(int i = 0; i < word.length(); ++i){\\n            char ch = word.charAt(i);\\n            \\n            if(farr[ch-\\'a\\'] == 0) flag = false; // not possible to include word\\n            \\n            farr[ch-\\'a\\']--;//  decrease the frequency\\n            sword += score[ch-\\'a\\']; // increase the particular word score\\n        }\\n        \\n        if(flag) syes = sword+ solve(words,farr,score,idx+1);\\n        \\n        for(int i =0; i < word.length(); ++i){\\n            char ch = word.charAt(i);\\n            farr[ch-\\'a\\']++;// backtrack and undo the changes\\n        }\\n        \\n        return Math.max(syes,sno); // find the max score\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310554,
                "title": "2ms-98-faster-c-short-sweet-code",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,vector<int> &v,vector<int> &score,int &ans,int sum,vector<string> &words){\\n        ans = max(ans,sum);\\n        if(i>=n)return;\\n        vector<int> tmp = v;\\n        int j=0,sum1=0;\\n        for(j = 0; j < words[i].length(); j++){\\n            tmp[words[i][j]-\\'a\\']--;\\n            sum1 += score[words[i][j]-\\'a\\'];\\n            if(tmp[words[i][j]-\\'a\\']<0)break;\\n        }\\n        if(j==words[i].length()){\\n            solve(i+1,n,tmp,score,ans,sum+sum1,words);\\n        }\\n        solve(i+1,n,v,score,ans,sum,words);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> v(26,0);\\n        for(auto &i: letters){\\n            v[i-\\'a\\']++;\\n        }\\n        int ans = 0,n=words.size();\\n        solve(0,n,v,score,ans,0,words);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,vector<int> &v,vector<int> &score,int &ans,int sum,vector<string> &words){\\n        ans = max(ans,sum);\\n        if(i>=n)return;\\n        vector<int> tmp = v;\\n        int j=0,sum1=0;\\n        for(j = 0; j < words[i].length(); j++){\\n            tmp[words[i][j]-\\'a\\']--;\\n            sum1 += score[words[i][j]-\\'a\\'];\\n            if(tmp[words[i][j]-\\'a\\']<0)break;\\n        }\\n        if(j==words[i].length()){\\n            solve(i+1,n,tmp,score,ans,sum+sum1,words);\\n        }\\n        solve(i+1,n,v,score,ans,sum,words);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> v(26,0);\\n        for(auto &i: letters){\\n            v[i-\\'a\\']++;\\n        }\\n        int ans = 0,n=words.size();\\n        solve(0,n,v,score,ans,0,words);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532956,
                "title": "java-easy-understandable",
                "content": "```\\nclass Solution {\\n\\tpublic int maxScoreWords(String[] arr, char[] letters, int[] score) {\\n\\t\\tint[] freq = new int[26];\\n\\t\\tfor (int i = 0; i < letters.length; i++) {\\n\\t\\t\\tfreq[letters[i] - \\'a\\']++;\\n\\t\\t}\\n\\n\\t\\tint ans = helper(arr, freq, score, 0);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tpublic int helper(String[] arr, int[] temp, int[] score, int index) {\\n\\t\\tif (index == arr.length) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint ans1 = helper(arr, temp, score, index + 1);\\n\\t\\tint ans2 = 0;\\n\\t\\tboolean flag = true;\\n\\t\\tint maximumScore = 0;\\n\\t\\tfor (int i = 0; i < arr[index].length(); i++) {\\n\\t\\t\\tchar ch = arr[index].charAt(i);\\n\\t\\t\\tif (temp[ch - \\'a\\'] <= 0) {\\n\\t\\t\\t\\tflag = false;\\n\\t\\t\\t}\\n\\t\\t\\ttemp[ch - \\'a\\']--;\\n\\t\\t\\tmaximumScore += score[ch - \\'a\\'];\\n\\t\\t}\\n\\n\\t\\tif (flag) {\\n\\t\\t\\tans2 = maximumScore + helper(arr, temp, score, index + 1);\\n\\t\\t}\\n\\t\\tint n = arr[index].length();\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tchar ch = arr[index].charAt(i);\\n\\t\\t\\ttemp[ch - \\'a\\']++;\\n\\t\\t}\\n\\t\\treturn Math.max(ans1, ans2);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int maxScoreWords(String[] arr, char[] letters, int[] score) {\\n\\t\\tint[] freq = new int[26];\\n\\t\\tfor (int i = 0; i < letters.length; i++) {\\n\\t\\t\\tfreq[letters[i] - \\'a\\']++;\\n\\t\\t}\\n\\n\\t\\tint ans = helper(arr, freq, score, 0);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tpublic int helper(String[] arr, int[] temp, int[] score, int index) {\\n\\t\\tif (index == arr.length) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint ans1 = helper(arr, temp, score, index + 1);\\n\\t\\tint ans2 = 0;\\n\\t\\tboolean flag = true;\\n\\t\\tint maximumScore = 0;\\n\\t\\tfor (int i = 0; i < arr[index].length(); i++) {\\n\\t\\t\\tchar ch = arr[index].charAt(i);\\n\\t\\t\\tif (temp[ch - \\'a\\'] <= 0) {\\n\\t\\t\\t\\tflag = false;\\n\\t\\t\\t}\\n\\t\\t\\ttemp[ch - \\'a\\']--;\\n\\t\\t\\tmaximumScore += score[ch - \\'a\\'];\\n\\t\\t}\\n\\n\\t\\tif (flag) {\\n\\t\\t\\tans2 = maximumScore + helper(arr, temp, score, index + 1);\\n\\t\\t}\\n\\t\\tint n = arr[index].length();\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tchar ch = arr[index].charAt(i);\\n\\t\\t\\ttemp[ch - \\'a\\']++;\\n\\t\\t}\\n\\t\\treturn Math.max(ans1, ans2);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603848,
                "title": "c-solution-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    int total_score(string &s, vector<int> &count, vector<int> &score) {\\n        int ans = 0;\\n        for(auto it:s) {\\n            if(count[it-\\'a\\'] == 0) return INT_MIN;\\n            ans += score[it-\\'a\\'];\\n            count[it-\\'a\\']--;\\n        }\\n        return ans;\\n    }\\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        int n = words.size();\\n        vector<int> count(26,0);\\n        for(auto it:letters) count[it-\\'a\\']++;\\n        int res = INT_MIN;\\n        for(int i=0; i<(1<<n); i++) // check for each subset\\n        {\\n            vector<int> tmp = count;\\n            int ans = 0;\\n            for(int j=0; j<n; j++) \\n            {\\n                if(i & (1<<j)) // if the element is part of above subset then add score of that word to total score\\n                {\\n                    int curr_score = total_score(words[j], tmp, score);\\n                    if(curr_score != INT_MIN) ans += curr_score;\\n                    else ans = INT_MIN;\\n                }\\n            }\\n            res = max(res, ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int total_score(string &s, vector<int> &count, vector<int> &score) {\\n        int ans = 0;\\n        for(auto it:s) {\\n            if(count[it-\\'a\\'] == 0) return INT_MIN;\\n            ans += score[it-\\'a\\'];\\n            count[it-\\'a\\']--;\\n        }\\n        return ans;\\n    }\\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        int n = words.size();\\n        vector<int> count(26,0);\\n        for(auto it:letters) count[it-\\'a\\']++;\\n        int res = INT_MIN;\\n        for(int i=0; i<(1<<n); i++) // check for each subset\\n        {\\n            vector<int> tmp = count;\\n            int ans = 0;\\n            for(int j=0; j<n; j++) \\n            {\\n                if(i & (1<<j)) // if the element is part of above subset then add score of that word to total score\\n                {\\n                    int curr_score = total_score(words[j], tmp, score);\\n                    if(curr_score != INT_MIN) ans += curr_score;\\n                    else ans = INT_MIN;\\n                }\\n            }\\n            res = max(res, ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027431,
                "title": "c-solution-100-faster-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n   int solve(vector<string>& words, vector<int>& freq, vector<int>& score, int idx){\\n       if(idx==words.size())\\n           return 0;\\n       //if we don\\'t include word at index \\'idx\\'\\n       int sNo=solve(words,freq,score,idx+1);\\n       \\n       //if we include word at index \\'idx\\'\\n       int sYes=0;\\n       int scoreOfWord=0;\\n       int flag=1; \\n       //calculate below\\n       for(int i=0;i<words[idx].length();i++){\\n           char c=words[idx][i];\\n           \\n           if(freq[c-\\'a\\']==0)  //char \\'c\\' not left in freq\\n               flag=0;\\n           freq[c-\\'a\\']--;\\n           scoreOfWord+=score[c-\\'a\\'];\\n       }\\n       \\n       if(flag==1){\\n           sYes=scoreOfWord+solve(words,freq,score,idx+1);\\n       } \\n       //restore the freq array \\n       for(int i=0;i<words[idx].length();i++){\\n           char c=words[idx][i];\\n           freq[c-\\'a\\']++;\\n           \\n       }\\n       return max(sNo,sYes);\\n       \\n   }\\n    \\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int>freq(26,0);\\n        for(int i=0;i<letters.size();i++){\\n            freq[letters[i]-\\'a\\']++;\\n        }\\n        return solve(words,freq,score,0);\\n        \\n    }\\n};``\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int solve(vector<string>& words, vector<int>& freq, vector<int>& score, int idx){\\n       if(idx==words.size())\\n           return 0;\\n       //if we don\\'t include word at index \\'idx\\'\\n       int sNo=solve(words,freq,score,idx+1);\\n       \\n       //if we include word at index \\'idx\\'\\n       int sYes=0;\\n       int scoreOfWord=0;\\n       int flag=1; \\n       //calculate below\\n       for(int i=0;i<words[idx].length();i++){\\n           char c=words[idx][i];\\n           \\n           if(freq[c-\\'a\\']==0)  //char \\'c\\' not left in freq\\n               flag=0;\\n           freq[c-\\'a\\']--;\\n           scoreOfWord+=score[c-\\'a\\'];\\n       }\\n       \\n       if(flag==1){\\n           sYes=scoreOfWord+solve(words,freq,score,idx+1);\\n       } \\n       //restore the freq array \\n       for(int i=0;i<words[idx].length();i++){\\n           char c=words[idx][i];\\n           freq[c-\\'a\\']++;\\n           \\n       }\\n       return max(sNo,sYes);\\n       \\n   }\\n    \\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int>freq(26,0);\\n        for(int i=0;i<letters.size();i++){\\n            freq[letters[i]-\\'a\\']++;\\n        }\\n        return solve(words,freq,score,0);\\n        \\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505887,
                "title": "c-memory-efficient-simple-bitmasking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        int ans=0;\\n        vector<int> cnt(26);\\n        fill(cnt.begin(),cnt.end(),0);\\n        for(auto x:letters)cnt[x-\\'a\\']++;\\n        int n=words.size();\\n        int lim=(1<<n);\\n        for(int mask=0;mask<lim;mask++){\\n            int res=0;\\n            vector<int> tcnt=cnt;\\n            int flag=0;\\n            for(int pos=n-1;pos>=0;pos--){\\n                if((mask>>pos)&1){\\n                    string s=words[pos];\\n                    for(int i=0;i<s.size();i++){\\n                        tcnt[s[i]-\\'a\\']--;\\n                        if(tcnt[s[i]-\\'a\\']<0){\\n                            flag=1;\\n                            break;\\n                        }\\n                        else res+=score[s[i]-\\'a\\'];\\n                    }\\n                }\\n                if(flag==1)break;\\n            }\\n            if(flag==0)ans=max(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        int ans=0;\\n        vector<int> cnt(26);\\n        fill(cnt.begin(),cnt.end(),0);\\n        for(auto x:letters)cnt[x-\\'a\\']++;\\n        int n=words.size();\\n        int lim=(1<<n);\\n        for(int mask=0;mask<lim;mask++){\\n            int res=0;\\n            vector<int> tcnt=cnt;\\n            int flag=0;\\n            for(int pos=n-1;pos>=0;pos--){\\n                if((mask>>pos)&1){\\n                    string s=words[pos];\\n                    for(int i=0;i<s.size();i++){\\n                        tcnt[s[i]-\\'a\\']--;\\n                        if(tcnt[s[i]-\\'a\\']<0){\\n                            flag=1;\\n                            break;\\n                        }\\n                        else res+=score[s[i]-\\'a\\'];\\n                    }\\n                }\\n                if(flag==1)break;\\n            }\\n            if(flag==0)ans=max(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425352,
                "title": "simple-dp-commented-solution-using-inclusion-exclusion-memoization-using-hashmap",
                "content": "We try including the string if possible and exclude it too.\\nWhile including the string we keep track of the characters we had seen in a temp array. We see if we can include it by comparing the frequencies of the characters in the freq and temp arrays. If we can include the current string we update the frequency array and call on the remaing array of words from i + 1. After returning from the remaining array we again update freq back to its original state.\\n```\\nclass Solution {\\n    \\n    public static int func(String[] words, int n, int i, int[] freq, int[] score, ArrayList<HashMap<String, Integer>> dp){\\n        \\n        if(i == n) return 0;\\n        \\n        /* memoize using the configuration of the freq array */\\n        StringBuilder sb = new StringBuilder();\\n        for(int j = 0; j < 26; j++){\\n            if(freq[j] != 0) sb.append(Integer.toString(freq[j]) + (char)(j + 97));\\n        }\\n        \\n        String t = sb.toString();\\n        \\n        /* memoization */\\n        if(dp.get(i).containsKey(t)) return dp.get(i).get(t);\\n        \\n        /* try excluding the current word */\\n        int p1 = func(words, n, i + 1, freq, score, dp);\\n        \\n        /* if we want to include the current word */\\n        int p2 = 0;\\n        \\n        /* temp array stores the freq of characters which are there in current word */\\n        /* meanwhile the loop will check if it is possible to include the current string */\\n        int[] temp = new int[26];\\n        int flag = 0;\\n        for(int j = 0; j < words[i].length(); j++){\\n            int curr = (int)words[i].charAt(j) - 97;\\n            temp[curr] ++;\\n            if(temp[curr] > freq[curr]){\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        \\n        if(flag == 0){\\n            \\n            /* if we can include the current word */\\n            int currScore = 0;\\n            \\n            /* update freq array */\\n            for(int j = 0; j < 26; j++){\\n                freq[j] -= temp[j];\\n                currScore += temp[j] * score[j];\\n            }\\n                             \\n            /* call on remaining array */\\n            p2 = currScore + func(words, n, i + 1, freq, score, dp);\\n            \\n            /* update freq array back to its original state */\\n            for(int j = 0; j < 26; j++) freq[j] += temp[j];\\n        }\\n        \\n        /* return max of both the possibilities */\\n        int ans = Math.max(p1, p2);\\n        dp.get(i).put(t, ans);\\n        return ans;\\n    }\\n    \\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        \\n        int n = words.length;\\n        if(n == 0) return 0;\\n        int m = letters.length;\\n        if(m == 0) return 0;\\n        \\n        int[] freq = new int[26];\\n        for(int i = 0; i < m; i++) freq[(int)letters[i] - 97] ++;\\n        \\n        ArrayList<HashMap<String, Integer>> dp = new ArrayList<>();\\n        for(int i = 0; i < n; i++) dp.add(new HashMap<>());\\n        \\n        return func(words, n, 0, freq, score, dp);\\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n    \\n    public static int func(String[] words, int n, int i, int[] freq, int[] score, ArrayList<HashMap<String, Integer>> dp){\\n        \\n        if(i == n) return 0;\\n        \\n        /* memoize using the configuration of the freq array */\\n        StringBuilder sb = new StringBuilder();\\n        for(int j = 0; j < 26; j++){\\n            if(freq[j] != 0) sb.append(Integer.toString(freq[j]) + (char)(j + 97));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1589780,
                "title": "c-generate-all-combinations-with-bit-mask-20ms",
                "content": "Number of words is only 14 so we can check for best answer from all possible subsets\\n```\\n    int calcScore(string &word, vector<int>&mp, vector<int>&score){\\n        int scre = 0;\\n        for(char c: word){\\n            if(mp[c-\\'a\\']==0) return INT_MIN;\\n            mp[c-\\'a\\']--;\\n            scre+=score[c-\\'a\\'];\\n        }\\n        return scre;\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        int res = 0, temp, n = words.size();\\n        vector<int>mp(26);\\n        for(char c: letters) mp[c-\\'a\\']++;\\n        for(int mask = 0; mask<(1<<n); mask++){//generating all combinations\\n            temp = 0;\\n            vector<int>tmp = mp;//O(26)\\n            for(int i=0; i<n; i++){\\n                if(mask & 1<<i){//ith word is chosen\\n                    temp+=calcScore(words[i], tmp, score);\\n                    if(temp<0) break;\\n                }\\n            }\\n            res = max(res, temp);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bitmask"
                ],
                "code": "```\\n    int calcScore(string &word, vector<int>&mp, vector<int>&score){\\n        int scre = 0;\\n        for(char c: word){\\n            if(mp[c-\\'a\\']==0) return INT_MIN;\\n            mp[c-\\'a\\']--;\\n            scre+=score[c-\\'a\\'];\\n        }\\n        return scre;\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        int res = 0, temp, n = words.size();\\n        vector<int>mp(26);\\n        for(char c: letters) mp[c-\\'a\\']++;\\n        for(int mask = 0; mask<(1<<n); mask++){//generating all combinations\\n            temp = 0;\\n            vector<int>tmp = mp;//O(26)\\n            for(int i=0; i<n; i++){\\n                if(mask & 1<<i){//ith word is chosen\\n                    temp+=calcScore(words[i], tmp, score);\\n                    if(temp<0) break;\\n                }\\n            }\\n            res = max(res, temp);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1525491,
                "title": "bitmask-dp-java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    // time : O((2 ^ N) * N * (max word length))\\n    // space : O(1)\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n\\t    // frequency of available letters\\n        int[] freq = new int[26];\\n\\t\\t// frequency of letters in our set of words\\n        int[] temp = new int[26];\\n        \\n        for (char c : letters) {\\n            freq[c - \\'a\\']++;\\n        }\\n        int n = words.length;\\n        int res = 0;\\n        for (int mask = 0; mask < 1 << n; mask++) { // for each possible set of words\\n            for (int i = 0; i < 26; i++) {\\n                temp[i] = 0;\\n            }\\n            int totalScore = 0;\\n            for (int i = 0; i < n; i++) {\\n                if ((mask & (1 << i)) >= 1) {\\n                    for (char c : words[i].toCharArray()) {\\n                        temp[c - \\'a\\']++;\\n                        totalScore += score[c - \\'a\\'];\\n                    }\\n                }\\n            }\\n\\t\\t\\t// if such a set of words is possible to form, minimize the score\\n            if (satisfies(freq, temp) && totalScore > res) {\\n                res = totalScore;\\n            }\\n        }\\n        return res;\\n    }\\n    private static boolean satisfies(int[] freq, int[] temp) {\\n        for (int i = 0; i < 26; i++) {\\n            if (freq[i] < temp[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\nIf you like the solution, please Upvote \\uD83D\\uDC4D!!\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // time : O((2 ^ N) * N * (max word length))\\n    // space : O(1)\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n\\t    // frequency of available letters\\n        int[] freq = new int[26];\\n\\t\\t// frequency of letters in our set of words\\n        int[] temp = new int[26];\\n        \\n        for (char c : letters) {\\n            freq[c - \\'a\\']++;\\n        }\\n        int n = words.length;\\n        int res = 0;\\n        for (int mask = 0; mask < 1 << n; mask++) { // for each possible set of words\\n            for (int i = 0; i < 26; i++) {\\n                temp[i] = 0;\\n            }\\n            int totalScore = 0;\\n            for (int i = 0; i < n; i++) {\\n                if ((mask & (1 << i)) >= 1) {\\n                    for (char c : words[i].toCharArray()) {\\n                        temp[c - \\'a\\']++;\\n                        totalScore += score[c - \\'a\\'];\\n                    }\\n                }\\n            }\\n\\t\\t\\t// if such a set of words is possible to form, minimize the score\\n            if (satisfies(freq, temp) && totalScore > res) {\\n                res = totalScore;\\n            }\\n        }\\n        return res;\\n    }\\n    private static boolean satisfies(int[] freq, int[] temp) {\\n        for (int i = 0; i < 26; i++) {\\n            if (freq[i] < temp[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200409,
                "title": "knapsack-and-backtracking-simple-solution",
                "content": "# Intuition\\nThis problem is based on classical knapsack problem,where we have two choices to either take the current string and add (if it possible) or reject this current index and go to next index.\\n\\n# Approach\\nHere we take the index and findGain of that string and add to take part of our choice and rest part is basically taken care by our recursion\\nOr else we just go to the next index if that index is not situable for our answer.\\n\\nThe important thing is to revive the changes for the map done is take part ,so bassically store the current map to another map and then backtract to the original value;\\n\\n........................Please vote me if it is helpful ..............\\n# Complexity\\n- Time complexity:O(N);\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint findGain(string p,vector<char>& letters, vector<int>& score,map<int,int>& mp){\\n    int gain=0;\\n    int flag=0;\\n    for(auto it:p){\\n  if(mp[it]>0){\\n      gain+=score[it-\\'a\\'];\\n      mp[it]--;\\n  }else{\\n      flag=1;\\n      break;\\n  }\\n    }\\nif(flag){\\n    return 0;\\n}\\nreturn gain;\\n}\\n\\nint solve(int idx,vector<string>& words, vector<char>& letters, vector<int>& score,map<int,int>& mp){\\nif(idx>=words.size()){\\n    return 0;\\n}\\n\\nint notTake=solve(idx+1,words,letters,score,mp);\\nmap<int,int> p=mp;\\nint take=findGain(words[idx],letters,score,mp)+solve(idx+1,words,letters,score,mp);\\nmp=p;\\nreturn max(take,notTake);\\n\\n}\\n\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        map<int,int> mp;\\n        for(auto it:letters){\\n            mp[it]++;\\n        }\\n       return solve(0,words,letters,score,mp);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint findGain(string p,vector<char>& letters, vector<int>& score,map<int,int>& mp){\\n    int gain=0;\\n    int flag=0;\\n    for(auto it:p){\\n  if(mp[it]>0){\\n      gain+=score[it-\\'a\\'];\\n      mp[it]--;\\n  }else{\\n      flag=1;\\n      break;\\n  }\\n    }\\nif(flag){\\n    return 0;\\n}\\nreturn gain;\\n}\\n\\nint solve(int idx,vector<string>& words, vector<char>& letters, vector<int>& score,map<int,int>& mp){\\nif(idx>=words.size()){\\n    return 0;\\n}\\n\\nint notTake=solve(idx+1,words,letters,score,mp);\\nmap<int,int> p=mp;\\nint take=findGain(words[idx],letters,score,mp)+solve(idx+1,words,letters,score,mp);\\nmp=p;\\nreturn max(take,notTake);\\n\\n}\\n\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        map<int,int> mp;\\n        for(auto it:letters){\\n            mp[it]++;\\n        }\\n       return solve(0,words,letters,score,mp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074606,
                "title": "python-solution-beats-98-commented-code-w-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought is to use a backtracking approach to solve this problem. We can check all possible combinations of words and check if they can be made with the given letters and what the score would be.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI will use a backtracking approach where I will start with the first word and check if it can be made with the given letters. If it can, I will add the score of the word to the current sum and move on to the next word. If it can\\'t, I will skip the word and move on to the next one. I will also keep track of the count of each letter in the letters list to check if the current word can be made. I will also keep track of the maximum score that can be achieved and return that at the end.\\n# Complexity\\n- Time complexity: O$$(2^N * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        def backtrack(index, letter_count, curr_sum):\\n            # if index is past the length of words array\\n            # then return the current sum\\n            if index == len(words):\\n                self.ans = max(self.ans, curr_sum)\\n                return\\n            \\n            # the current word\\n            word = words[index]\\n            \\n            # create a new letter count array\\n            # as we need to restore the old \\n            # letter count\\n            temp = letter_count[:]\\n            \\n            # find the sum of the current word\\n            # if the current word can be made\\n            # using the current letter count\\n            curr_word_sum = 0\\n            valid = True\\n            for c in word:\\n                if letter_count[ord(c)-97] == 0:\\n                    valid = False\\n                    break\\n                curr_word_sum += score[ord(c)-97]\\n                letter_count[ord(c)-97] -= 1\\n            \\n            # if the current word can be made\\n            # then check if the current word with\\n            # the current sum can give a better\\n            # result\\n            if valid:\\n                backtrack(index+1, letter_count, curr_sum+curr_word_sum)\\n            \\n            # reset the letter count\\n            letter_count = temp[:]\\n            \\n            # skip the current word\\n            backtrack(index+1, letter_count, curr_sum)\\n        \\n        \\n        # create an array to store the \\n        # count of each letter\\n        letter_count = [0]*26\\n        for c in letters:\\n            letter_count[ord(c)-97] += 1\\n        \\n        self.ans = 0\\n        backtrack(0, letter_count, 0)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        def backtrack(index, letter_count, curr_sum):\\n            # if index is past the length of words array\\n            # then return the current sum\\n            if index == len(words):\\n                self.ans = max(self.ans, curr_sum)\\n                return\\n            \\n            # the current word\\n            word = words[index]\\n            \\n            # create a new letter count array\\n            # as we need to restore the old \\n            # letter count\\n            temp = letter_count[:]\\n            \\n            # find the sum of the current word\\n            # if the current word can be made\\n            # using the current letter count\\n            curr_word_sum = 0\\n            valid = True\\n            for c in word:\\n                if letter_count[ord(c)-97] == 0:\\n                    valid = False\\n                    break\\n                curr_word_sum += score[ord(c)-97]\\n                letter_count[ord(c)-97] -= 1\\n            \\n            # if the current word can be made\\n            # then check if the current word with\\n            # the current sum can give a better\\n            # result\\n            if valid:\\n                backtrack(index+1, letter_count, curr_sum+curr_word_sum)\\n            \\n            # reset the letter count\\n            letter_count = temp[:]\\n            \\n            # skip the current word\\n            backtrack(index+1, letter_count, curr_sum)\\n        \\n        \\n        # create an array to store the \\n        # count of each letter\\n        letter_count = [0]*26\\n        for c in letters:\\n            letter_count[ord(c)-97] += 1\\n        \\n        self.ans = 0\\n        backtrack(0, letter_count, 0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942893,
                "title": "javascript-0-1-knapsack-variation",
                "content": "```\\nvar maxScoreWords = function (words, letters, score) {\\n  return getMaxScore(0, words, letters, score);\\n};\\n\\nconst getMaxScore = (index, words, letters, scores) => {\\n  if (index >= words.length) return 0;\\n\\n  let consider = 0;\\n  if (isValidWord(words[index], letters)) {\\n    const tempLetters = [...letters];\\n    words[index]\\n      .split(\"\")\\n      .forEach((letter) => tempLetters.splice(tempLetters.indexOf(letter), 1));\\n    consider =\\n      getScore(words[index], scores) +\\n      getMaxScore(index + 1, words, tempLetters, scores);\\n  }\\n\\n  const dontConsider = getMaxScore(index + 1, words, letters, scores);\\n\\n  return Math.max(consider, dontConsider);\\n};\\n\\nconst isValidWord = (word, letters) => {\\n  let temp = [...letters];\\n  return word.split(\"\").every((letter) => {\\n    const res = temp.includes(letter);\\n    temp.splice(temp.indexOf(letter), 1);\\n    return res;\\n  });\\n};\\n\\nconst getScore = (word, scores) => {\\n  return word.split(\"\").reduce((sum, _, i) => {\\n    const index = word.charCodeAt(i) - 96;\\n    sum += scores[index - 1];\\n    return sum;\\n  }, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nvar maxScoreWords = function (words, letters, score) {\\n  return getMaxScore(0, words, letters, score);\\n};\\n\\nconst getMaxScore = (index, words, letters, scores) => {\\n  if (index >= words.length) return 0;\\n\\n  let consider = 0;\\n  if (isValidWord(words[index], letters)) {\\n    const tempLetters = [...letters];\\n    words[index]\\n      .split(\"\")\\n      .forEach((letter) => tempLetters.splice(tempLetters.indexOf(letter), 1));\\n    consider =\\n      getScore(words[index], scores) +\\n      getMaxScore(index + 1, words, tempLetters, scores);\\n  }\\n\\n  const dontConsider = getMaxScore(index + 1, words, letters, scores);\\n\\n  return Math.max(consider, dontConsider);\\n};\\n\\nconst isValidWord = (word, letters) => {\\n  let temp = [...letters];\\n  return word.split(\"\").every((letter) => {\\n    const res = temp.includes(letter);\\n    temp.splice(temp.indexOf(letter), 1);\\n    return res;\\n  });\\n};\\n\\nconst getScore = (word, scores) => {\\n  return word.split(\"\").reduce((sum, _, i) => {\\n    const index = word.charCodeAt(i) - 96;\\n    sum += scores[index - 1];\\n    return sum;\\n  }, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 425098,
                "title": "java-backtrack-solution",
                "content": "```\\nclass Solution {\\n    int max = 0;\\n    \\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int[] allow = new int[26];\\n        for (char c : letters) allow[c - \\'a\\']++;\\n        \\n        int[][] count = new int[words.length][26];\\n        int wordScore[] = new int[words.length];\\n        for (int i = 0; i < words.length; i++) {\\n            for (int j = 0; j < words[i].length(); j++) {\\n                count[i][words[i].charAt(j) - \\'a\\']++;\\n                wordScore[i] += score[words[i].charAt(j) - \\'a\\'];\\n            }\\n        }\\n        \\n        backtrack(words, 0, 0, count, allow, wordScore);\\n        return max;\\n    }\\n    \\n    private void backtrack(String[] words, int pos, int s, int[][] count, int[] allow, int[] wordScore) {\\n        max = Math.max(max, s);\\n        \\n        for (int i = pos; i < words.length; i++) {\\n            boolean skip = false;\\n            for (int j = 0; j < 26 && !skip; j++) {\\n                if (count[i][j] > allow[j]) skip = true;\\n            }\\n            if (skip) continue;\\n            \\n            for (int j = 0; j < 26; j++) allow[j] -= count[i][j];\\n            backtrack(words, i+1, s + wordScore[i], count, allow, wordScore);\\n            for (int j = 0; j < 26; j++) allow[j] += count[i][j];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    \\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int[] allow = new int[26];\\n        for (char c : letters) allow[c - \\'a\\']++;\\n        \\n        int[][] count = new int[words.length][26];\\n        int wordScore[] = new int[words.length];\\n        for (int i = 0; i < words.length; i++) {\\n            for (int j = 0; j < words[i].length(); j++) {\\n                count[i][words[i].charAt(j) - \\'a\\']++;\\n                wordScore[i] += score[words[i].charAt(j) - \\'a\\'];\\n            }\\n        }\\n        \\n        backtrack(words, 0, 0, count, allow, wordScore);\\n        return max;\\n    }\\n    \\n    private void backtrack(String[] words, int pos, int s, int[][] count, int[] allow, int[] wordScore) {\\n        max = Math.max(max, s);\\n        \\n        for (int i = pos; i < words.length; i++) {\\n            boolean skip = false;\\n            for (int j = 0; j < 26 && !skip; j++) {\\n                if (count[i][j] > allow[j]) skip = true;\\n            }\\n            if (skip) continue;\\n            \\n            for (int j = 0; j < 26; j++) allow[j] -= count[i][j];\\n            backtrack(words, i+1, s + wordScore[i], count, allow, wordScore);\\n            for (int j = 0; j < 26; j++) allow[j] += count[i][j];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846519,
                "title": "python-short-easy-6-lines-counter",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        \\n        def bckt(i, counts):\\n            if i == len(words): return 0\\n            word = Counter(words[i])\\n            if word == word & counts:\\n                curr = sum([score[ord(c) - ord(\"a\")] * word[c] for c in word])\\n                return max(curr + bckt(i + 1 , counts - word), bckt(i + 1, counts))\\n            return bckt(i + 1, counts)\\n\\n        return bckt(0, Counter(letters))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Backtracking",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        \\n        def bckt(i, counts):\\n            if i == len(words): return 0\\n            word = Counter(words[i])\\n            if word == word & counts:\\n                curr = sum([score[ord(c) - ord(\"a\")] * word[c] for c in word])\\n                return max(curr + bckt(i + 1 , counts - word), bckt(i + 1, counts))\\n            return bckt(i + 1, counts)\\n\\n        return bckt(0, Counter(letters))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565009,
                "title": "dp-c-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<string> &words,vector<int> &scr,vector<int> &cnt,int s,int &n,int &ans,int k){\\n        if(s==n){\\n            ans = max(ans,k);\\n            return;\\n        }\\n        vector<int> tmp = cnt;\\n        solve(words,scr,cnt,s+1,n,ans,k);\\n        bool a = true;\\n        int scor = 0;\\n        for(auto &i: words[s]){\\n            tmp[i-\\'a\\']--;\\n            scor += scr[i-\\'a\\'];\\n            if(tmp[i-\\'a\\']<0){a = false;break;}\\n        }\\n        if(a) solve(words,scr,tmp,s+1,n,ans,k+scor);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> cnt(26,0);\\n        for(auto &i: letters){\\n            cnt[i-\\'a\\']++;\\n        }\\n        int ans = 0;\\n        int n = words.size();\\n        solve(words,score,cnt,0,n,ans,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<string> &words,vector<int> &scr,vector<int> &cnt,int s,int &n,int &ans,int k){\\n        if(s==n){\\n            ans = max(ans,k);\\n            return;\\n        }\\n        vector<int> tmp = cnt;\\n        solve(words,scr,cnt,s+1,n,ans,k);\\n        bool a = true;\\n        int scor = 0;\\n        for(auto &i: words[s]){\\n            tmp[i-\\'a\\']--;\\n            scor += scr[i-\\'a\\'];\\n            if(tmp[i-\\'a\\']<0){a = false;break;}\\n        }\\n        if(a) solve(words,scr,tmp,s+1,n,ans,k+scor);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> cnt(26,0);\\n        for(auto &i: letters){\\n            cnt[i-\\'a\\']++;\\n        }\\n        int ans = 0;\\n        int n = words.size();\\n        solve(words,score,cnt,0,n,ans,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731271,
                "title": "best-solution-simple-backtracking-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MIN;\\nunordered_map<char,int>val;\\nunordered_map<char,int>freq;\\nint maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) \\n{\\n\\t//getting the freq of all the avail char\\'s\\n\\tfor(int i=0;i<(letters.size());i++)\\n\\t{\\n\\t\\tchar ch = letters[i];\\n\\t\\tfreq[ch]++;\\n\\t}\\n\\t//getting the val of all the alphabets\\n\\tfor(int i=0;i<(score.size());i++)\\n\\t{\\n\\t\\tchar ch = \\'a\\' + i;\\n\\t\\tval[ch] = score[i];\\n\\t}\\n\\tint idx=0;\\n\\tstring temp=\"\";\\n\\tfun(idx,temp,words,letters,score);\\n\\treturn ans;\\n}\\nvoid fun(int idx,string &temp,vector<string>&words,vector<char>&letters,vector<int>&score)\\n{\\n\\t//trying to get all the subsets of the given words array\\n\\t//ans then trying to make the ans\\n\\tif(idx >= words.size())\\n\\t{\\n\\t\\t//try to make the ans with the help of val and freq map\\n\\t\\tunordered_map<char,int>temp_freq;\\n\\t\\tfor(int i=0;i<temp.length();i++)\\n\\t\\t{\\n\\t\\t\\tchar ch = temp[i];\\n\\t\\t\\ttemp_freq[ch]++;\\n\\t\\t\\t\\n\\t\\t\\tif(temp_freq[ch] > freq[ch])\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint sum=0;\\n\\t\\tfor(auto it=temp_freq.begin();it!=temp_freq.end();it++)\\n\\t\\t{\\n\\t\\t    sum = sum + (it->second * val[it->first]);\\t\\n\\t\\t}\\n\\t\\tif(sum > ans)\\n\\t\\tans=sum;\\n\\t\\treturn;\\n\\t}\\n\\tstring prvstr=temp;\\n\\t\\n\\ttemp=temp+words[idx];\\n\\tfun(idx+1,temp,words,letters,score);\\n\\t\\n\\ttemp=prvstr;\\n\\tfun(idx+1,temp,words,letters,score);\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MIN;\\nunordered_map<char,int>val;\\nunordered_map<char,int>freq;\\nint maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) \\n{\\n\\t//getting the freq of all the avail char\\'s\\n\\tfor(int i=0;i<(letters.size());i++)\\n\\t{\\n\\t\\tchar ch = letters[i];\\n\\t\\tfreq[ch]++;\\n\\t}\\n\\t//getting the val of all the alphabets\\n\\tfor(int i=0;i<(score.size());i++)\\n\\t{\\n\\t\\tchar ch = \\'a\\' + i;\\n\\t\\tval[ch] = score[i];\\n\\t}\\n\\tint idx=0;\\n\\tstring temp=\"\";\\n\\tfun(idx,temp,words,letters,score);\\n\\treturn ans;\\n}\\nvoid fun(int idx,string &temp,vector<string>&words,vector<char>&letters,vector<int>&score)\\n{\\n\\t//trying to get all the subsets of the given words array\\n\\t//ans then trying to make the ans\\n\\tif(idx >= words.size())\\n\\t{\\n\\t\\t//try to make the ans with the help of val and freq map\\n\\t\\tunordered_map<char,int>temp_freq;\\n\\t\\tfor(int i=0;i<temp.length();i++)\\n\\t\\t{\\n\\t\\t\\tchar ch = temp[i];\\n\\t\\t\\ttemp_freq[ch]++;\\n\\t\\t\\t\\n\\t\\t\\tif(temp_freq[ch] > freq[ch])\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint sum=0;\\n\\t\\tfor(auto it=temp_freq.begin();it!=temp_freq.end();it++)\\n\\t\\t{\\n\\t\\t    sum = sum + (it->second * val[it->first]);\\t\\n\\t\\t}\\n\\t\\tif(sum > ans)\\n\\t\\tans=sum;\\n\\t\\treturn;\\n\\t}\\n\\tstring prvstr=temp;\\n\\t\\n\\ttemp=temp+words[idx];\\n\\tfun(idx+1,temp,words,letters,score);\\n\\t\\n\\ttemp=prvstr;\\n\\tfun(idx+1,temp,words,letters,score);\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669939,
                "title": "dp-based-simple-c-solution-backtracking-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    bool ispossible(string s,map<char,int>m)\\n    {\\n        for(auto it:s)\\n        {\\n            if(m[it]==0)\\n                return false;\\n            m[it]--;\\n        }\\n        return true;\\n    }\\n    void add(map<char,int>&m,string s)\\n    {\\n        for(auto it:s)\\n            m[it]++;\\n    }\\n    void remove(map<char,int>&m,string s)\\n    {\\n        for(auto it:s)\\n            m[it]--;\\n    }\\n    int findscore(vector<int>&score,string s)\\n    {\\n        int cunt=0;\\n        for(auto it:s)\\n        {\\n            cunt+=score[it-\\'a\\'];\\n        }\\n        return cunt;\\n    }\\n    \\n    void rundfs(vector<string>& words,map<char,int>&m, vector<int>& score,int &maxscore,int currentscore,int s)\\n    {\\n        if(s==words.size())\\n        {\\n            maxscore=max(maxscore,currentscore);\\n            return;\\n        }\\n        if(ispossible(words[s],m))\\n        {\\n            remove(m,words[s]);\\n            rundfs(words,m,score,maxscore,currentscore+findscore(score,words[s]),s+1);\\n            add(m,words[s]);\\n        }\\n        \\n        rundfs(words,m,score,maxscore,currentscore,s+1);\\n        return;\\n        \\n    }\\n    \\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        map<char,int>m;\\n        for(auto it:letters)\\n            m[it]++;\\n    \\n        int maxscore=INT_MIN;\\n        rundfs(words,m,score,maxscore,0,0);\\n        return maxscore;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ispossible(string s,map<char,int>m)\\n    {\\n        for(auto it:s)\\n        {\\n            if(m[it]==0)\\n                return false;\\n            m[it]--;\\n        }\\n        return true;\\n    }\\n    void add(map<char,int>&m,string s)\\n    {\\n        for(auto it:s)\\n            m[it]++;\\n    }\\n    void remove(map<char,int>&m,string s)\\n    {\\n        for(auto it:s)\\n            m[it]--;\\n    }\\n    int findscore(vector<int>&score,string s)\\n    {\\n        int cunt=0;\\n        for(auto it:s)\\n        {\\n            cunt+=score[it-\\'a\\'];\\n        }\\n        return cunt;\\n    }\\n    \\n    void rundfs(vector<string>& words,map<char,int>&m, vector<int>& score,int &maxscore,int currentscore,int s)\\n    {\\n        if(s==words.size())\\n        {\\n            maxscore=max(maxscore,currentscore);\\n            return;\\n        }\\n        if(ispossible(words[s],m))\\n        {\\n            remove(m,words[s]);\\n            rundfs(words,m,score,maxscore,currentscore+findscore(score,words[s]),s+1);\\n            add(m,words[s]);\\n        }\\n        \\n        rundfs(words,m,score,maxscore,currentscore,s+1);\\n        return;\\n        \\n    }\\n    \\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        map<char,int>m;\\n        for(auto it:letters)\\n            m[it]++;\\n    \\n        int maxscore=INT_MIN;\\n        rundfs(words,m,score,maxscore,0,0);\\n        return maxscore;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663178,
                "title": "best-solution-only-one-extra-function-simple-backtracking-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int n,vector<string>&w,unordered_map<char,int>&m,vector<int>&score){\\n         if(n<0) return 0;\\n         bool flag=true;\\n         int sr=0;\\n         for(auto x:w[n]){\\n             if(!m[x]) flag=false;\\n                 m[x]--;sr+=score[x-\\'a\\'];\\n         }\\n         int a=0,b=0;\\n         if(flag) a=sr+solve(n-1,w,m,score);\\n         for(auto x:w[n]) m[x]++;\\n         b=solve(n-1,w,m,score);\\n         return max(a,b);    \\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        unordered_map<char,int>m;\\n        for(auto x: letters) m[x]++;\\n        return solve(words.size()-1,words,m,score);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n,vector<string>&w,unordered_map<char,int>&m,vector<int>&score){\\n         if(n<0) return 0;\\n         bool flag=true;\\n         int sr=0;\\n         for(auto x:w[n]){\\n             if(!m[x]) flag=false;\\n                 m[x]--;sr+=score[x-\\'a\\'];\\n         }\\n         int a=0,b=0;\\n         if(flag) a=sr+solve(n-1,w,m,score);\\n         for(auto x:w[n]) m[x]++;\\n         b=solve(n-1,w,m,score);\\n         return max(a,b);    \\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        unordered_map<char,int>m;\\n        for(auto x: letters) m[x]++;\\n        return solve(words.size()-1,words,m,score);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477451,
                "title": "backtraking-cpp-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n       \\n    bool isavailable(string word,unordered_map<char,int>m){\\n        for(auto ele:word){\\n            if(m[ele]<1)return false;\\n            m[ele]--;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    int func(int i,vector<string>&words,vector<int>&score,unordered_map<char,int>&m){\\n       \\n        if(i==words.size())return 0;\\n        \\n        int a=0,b=0;\\n        if(isavailable(words[i],m)){\\n            int sum=0;\\n            for(auto ele:words[i]){\\n                m[ele]--;\\n                sum+=score[ele-\\'a\\'];\\n            }\\n            a=sum+func(i+1,words,score,m);\\n            \\n            for(auto ele:words[i]){\\n                m[ele]++;\\n                sum+=score[ele-\\'a\\'];\\n            }\\n        }\\n        \\n        b=func(i+1,words,score,m);\\n        \\n        return max(a,b);\\n        \\n    }\\n    \\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        \\n        unordered_map<char,int>m;\\n        for(auto ele:letters){\\n            m[ele]++;\\n        }\\n        \\n        return func(0,words,score,m);\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n       \\n    bool isavailable(string word,unordered_map<char,int>m){\\n        for(auto ele:word){\\n            if(m[ele]<1)return false;\\n            m[ele]--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2355334,
                "title": "c-backtracking-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int res=0;\\n    void backtrack(vector<string>& words,vector<int>& score,vector<int>&count,vector<int>& used,int idx,int curr_res)\\n    {\\n        for(int i=0;i<26;i++)\\n        {\\n            if(used[i]>count[i])\\n                return;\\n        }\\n        res=max(res,curr_res);\\n        for(int i=idx;i<words.size();i++)\\n        {\\n            for(auto &ch:words[i])\\n            {\\n                used[ch-\\'a\\']++;\\n                curr_res+=score[ch-\\'a\\'];\\n            }\\n            backtrack(words,score,count,used,i+1,curr_res);\\n            for(auto &ch:words[i])\\n            {\\n                used[ch-\\'a\\']--;\\n                curr_res-=score[ch-\\'a\\'];\\n            }\\n        }\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score)\\n    {\\n        vector<int> count(26,0),used(26,0);\\n        for(auto &ch:letters)\\n        {\\n            count[ch-\\'a\\']++;\\n        }\\n        backtrack(words,score,count,used,0,0);\\n        return res;\\n    }\\n};\\n\\n//If you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    int res=0;\\n    void backtrack(vector<string>& words,vector<int>& score,vector<int>&count,vector<int>& used,int idx,int curr_res)\\n    {\\n        for(int i=0;i<26;i++)\\n        {\\n            if(used[i]>count[i])\\n                return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2278445,
                "title": "ez-c-solution-backtracking-23-ms-explained-with-comments",
                "content": "**Approach : **\\n\\nWhile doing this problem 2 conditions arise : \\n1. We will consider the current word and add its score to answer\\n2. We will NOT consider the current word and move to the next word.\\n\\nAt the end we find the maximum of both.\\n\\n```\\nclass Solution {\\npublic:\\n    int calc(vector<string>& words,map<char,int>&m,vector<int>& score,int i){ \\n        int maxi=0;\\n        if(i==words.size())\\n            return 0;\\n        map<char,int>m1=m;//Creating a duplicate in case the given word does not satisfy our answer\\n        int c=0;//Store the score\\n        for(int j=0;j<words[i].length();j++){\\n            if(m1.find(words[i][j])==m1.end()||m1[words[i][j]]==0){//If frequency of the letter reduces to zero or that letter is not present in our hashMap            \\n                c=-1;\\n                break;\\n            }\\n            c+=score[words[i][j]-\\'a\\'];\\n            m1[words[i][j]]--;\\n        }        \\n        if(c!=-1)           \\n          maxi=c+(calc(words,m1,score,i+1));//We are considering the current word and adding it to our answer\\n        return max(maxi,calc(words,m,score,i+1));//FInding tha maximum between when we consider the current word and when we DONT consider current word\\n        \\n}\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        map<char,int>m;       \\n        for(auto i:letters)\\n            m[i]++;\\n        return calc(words,m,score,0);   \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calc(vector<string>& words,map<char,int>&m,vector<int>& score,int i){ \\n        int maxi=0;\\n        if(i==words.size())\\n            return 0;\\n        map<char,int>m1=m;//Creating a duplicate in case the given word does not satisfy our answer\\n        int c=0;//Store the score\\n        for(int j=0;j<words[i].length();j++){\\n            if(m1.find(words[i][j])==m1.end()||m1[words[i][j]]==0){//If frequency of the letter reduces to zero or that letter is not present in our hashMap            \\n                c=-1;\\n                break;\\n            }\\n            c+=score[words[i][j]-\\'a\\'];\\n            m1[words[i][j]]--;\\n        }        \\n        if(c!=-1)           \\n          maxi=c+(calc(words,m1,score,i+1));//We are considering the current word and adding it to our answer\\n        return max(maxi,calc(words,m,score,i+1));//FInding tha maximum between when we consider the current word and when we DONT consider current word\\n        \\n}\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        map<char,int>m;       \\n        for(auto i:letters)\\n            m[i]++;\\n        return calc(words,m,score,0);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229451,
                "title": "java-1ms-98-recursive-powerset-solution-with-pruning",
                "content": "**Intuition**: We can try all of the combinations but stop as soon as we use more characters than we are permitted.  Powersets can be generated by starting with the just one set as the input - the empty set.  Then, for each element of the base set, we take each input set and create two new sets from it (each ending up as an input set to the next iteration).  One of the new sets is the input set plus the current element of the base set.  The other is the input set unchanged.  That is, we start with a set of sets consisting of just the empty set.  For each element of the base set, we keep the input set but also create a version of each where we add the base element.  This can be handled recursively, so we can generate the powerset of all input words through recursion.  And since in our recursion, we only ever add words, if we use up too many characters, we can stop, allowing us to prune our powerset search.\\n\\n**Helper Class**: We can encapsulate score computation and addition of frequencies from combining words into a `WordFreq` class.  We do not need to actually track the words concatenated together, just the resulting sums of frequencies, and we can have some convenience methods to add frequencies, compute scores, etc.  This class should handle the \"empty set\" case, that is a frequency array of all zeros corrresponding to no words selected.\\n\\n**An `int[] max` Hack**: We track our maximum value in an `int[1]` which allows us to modify it, but keep passing it as a method argument.  This avoids creating state in the Solution class, which really ought to be stateless.\\n\\n**Java Code**:\\n```\\nclass Solution {\\n\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        final WordFreq[] freqs = new WordFreq[words.length];\\n        for (int i = 0; i < words.length; ++i) {\\n            freqs[i] = new WordFreq(words[i]);\\n        }\\n        final int[] letterFreqs = new int[26];\\n        for (char ch : letters) {\\n            letterFreqs[ch - \\'a\\']++;\\n        }\\n        // Now we can look at the power set, but we need not continue if we are at score -1 (violation).\\n        final int[] max = new int[1];\\n        traversePowersetForMaxScore(new WordFreq(\"\"), freqs, 0, letterFreqs, score, max);\\n        return max[0];\\n    }\\n\\n    private void traversePowersetForMaxScore(WordFreq wf, WordFreq[] freqs, int i, int[] lfreqs, int[] scoring, int[] max) {\\n        if (i >= freqs.length) {\\n            return;\\n        }\\n        final int ip1 = i + 1;\\n        // Powerset Fork A: DO NOT add element i and continue at i + 1:\\n        traversePowersetForMaxScore(wf, freqs, ip1, lfreqs, scoring, max);\\n        // Powerset Fork B: DO add element i, provisionally continue if valid.\\n        final WordFreq next = wf.adding(freqs[i]);\\n        final int score = next.score(lfreqs, scoring);\\n        // Do not continue Powerset Fork B if score < 0.\\n        if (score >= 0) {\\n            // Have we seen our max score so far?  If so, update it!\\n            if (score > max[0]) {\\n                max[0] = score;\\n            }\\n            // Continue Powerset Fork B at i + 1:\\n            traversePowersetForMaxScore(next, freqs, ip1, lfreqs, scoring, max);\\n        }\\n    }\\n\\n    static class WordFreq {\\n\\n        final int[] freq;\\n\\n        public WordFreq(String word) {\\n            this(new int[26]);\\n            for (int i = 0; i < word.length(); ++i) {\\n                this.freq[word.charAt(i) - \\'a\\']++;\\n            }\\n        }\\n\\n        private WordFreq(int[] freq) {\\n            this.freq = freq;\\n        }\\n\\n        public WordFreq adding(final WordFreq wf) {\\n            final int[] freq = Arrays.copyOf(this.freq, 26);\\n            for (int i = 0; i < 26; ++i) {\\n                freq[i] += wf.freq[i];\\n            }\\n            return new WordFreq(freq);\\n        }\\n\\n        public int score(final int[] letterFreqs, final int[] scoring) {\\n            int score = 0;\\n            for (int i = 0; i < 26; ++i) {\\n                if (this.freq[i] > letterFreqs[i]) {\\n                    return -1;\\n                }\\n                score += (this.freq[i] * scoring[i]);\\n            }\\n            return score;\\n        }\\n\\n    }\\n\\n}\\n```\\n\\n**Complexity**: Let W be the number of words.  Space is O(2^W) in the worst case (for potentially 2^W WordFreq instances).  Time is also O(2^W) in the worst case.\\n\\n**Runtime**: ~1ms / beats 98% as of July, 2022.\\n\\n**Standard Plea**: If this was helpful, or even if it wasn\\'t a waste of your time, I\\'d **greatly appreciate your upvote**.  And if you didn\\'t find it helpful, or think it could be better, I\\'d **love to hear your constructive criticism**!  It helps me write better solutions.  Thanks for your time, and happy coding!",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        final WordFreq[] freqs = new WordFreq[words.length];\\n        for (int i = 0; i < words.length; ++i) {\\n            freqs[i] = new WordFreq(words[i]);\\n        }\\n        final int[] letterFreqs = new int[26];\\n        for (char ch : letters) {\\n            letterFreqs[ch - \\'a\\']++;\\n        }\\n        // Now we can look at the power set, but we need not continue if we are at score -1 (violation).\\n        final int[] max = new int[1];\\n        traversePowersetForMaxScore(new WordFreq(\"\"), freqs, 0, letterFreqs, score, max);\\n        return max[0];\\n    }\\n\\n    private void traversePowersetForMaxScore(WordFreq wf, WordFreq[] freqs, int i, int[] lfreqs, int[] scoring, int[] max) {\\n        if (i >= freqs.length) {\\n            return;\\n        }\\n        final int ip1 = i + 1;\\n        // Powerset Fork A: DO NOT add element i and continue at i + 1:\\n        traversePowersetForMaxScore(wf, freqs, ip1, lfreqs, scoring, max);\\n        // Powerset Fork B: DO add element i, provisionally continue if valid.\\n        final WordFreq next = wf.adding(freqs[i]);\\n        final int score = next.score(lfreqs, scoring);\\n        // Do not continue Powerset Fork B if score < 0.\\n        if (score >= 0) {\\n            // Have we seen our max score so far?  If so, update it!\\n            if (score > max[0]) {\\n                max[0] = score;\\n            }\\n            // Continue Powerset Fork B at i + 1:\\n            traversePowersetForMaxScore(next, freqs, ip1, lfreqs, scoring, max);\\n        }\\n    }\\n\\n    static class WordFreq {\\n\\n        final int[] freq;\\n\\n        public WordFreq(String word) {\\n            this(new int[26]);\\n            for (int i = 0; i < word.length(); ++i) {\\n                this.freq[word.charAt(i) - \\'a\\']++;\\n            }\\n        }\\n\\n        private WordFreq(int[] freq) {\\n            this.freq = freq;\\n        }\\n\\n        public WordFreq adding(final WordFreq wf) {\\n            final int[] freq = Arrays.copyOf(this.freq, 26);\\n            for (int i = 0; i < 26; ++i) {\\n                freq[i] += wf.freq[i];\\n            }\\n            return new WordFreq(freq);\\n        }\\n\\n        public int score(final int[] letterFreqs, final int[] scoring) {\\n            int score = 0;\\n            for (int i = 0; i < 26; ++i) {\\n                if (this.freq[i] > letterFreqs[i]) {\\n                    return -1;\\n                }\\n                score += (this.freq[i] * scoring[i]);\\n            }\\n            return score;\\n        }\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950229,
                "title": "easy-cpp-brute-force-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void f(vector<string>& words, vector<int>& score, vector<int> freq, int i, int cur_score){\\n\\t//if our cotrol reaches to end just take the maximum and store it in ans\\n        if(i == words.size()){\\n            ans = max(ans, cur_score);\\n            return;\\n        }\\n\\t\\t//current word = words[i]\\n        string cw = words[i];\\n\\t\\t//ok will denote that wheter we are able to form this current word with the remaining letters\\n        bool ok = true;\\n        int cs = 0;\\n\\t\\t//store the current freq in another vector as we will need it on a function call where we are not considering the current word\\n        vector<int> curfrq = freq; \\n\\t\\t//This loop will check if we are able to form current word with the remaining frequencies and accordingly count the score\\n        for(int i=0; i<cw.size(); ++i){\\n\\t\\t//if we have ran out of frequency then we cannot form this word so toggle ok to false\\n            if(freq[cw[i] - \\'a\\'] <= 0){\\n                ok = false;\\n                break;\\n            }\\n\\t\\t\\t//else count the resultant score and decrease the frequency of current character as we have used it.\\n            cs += score[cw[i] - \\'a\\'];\\n            freq[cw[i] - \\'a\\']--;\\n        }\\n\\t\\t//if we can form this word then prooceed to check another word and add this word\\'s score to  the current score, remember to pass the updated frequency vector as we have considered this word\\n        if(ok) f(words, score, freq, i+1, cs + cur_score);\\n\\t\\t//also we will proceed without considering this word, in this case, there will be no change in cur_score and freq thats why we maintained the copy of freq in curfrq, remember ?\\n        f(words, score, curfrq, i+1, cur_score);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> freq(26, 0);\\n\\t\\t//store the frequency of all the letters present in letters vector\\n        for(auto& it: letters) freq[it - \\'a\\']++;\\n        f(words, score, freq, 0, 0);\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int ans = 0;\\n    void f(vector<string>& words, vector<int>& score, vector<int> freq, int i, int cur_score){\\n\\t//if our cotrol reaches to end just take the maximum and store it in ans\\n        if(i == words.size()){\\n            ans = max(ans, cur_score);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1666949,
                "title": "java-backtracking-1ms-beats-100",
                "content": "```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int[] freq = new int[26];\\n        for (char ch : letters) {\\n            freq[ch - \\'a\\']++;\\n        }\\n        return max (words,score,freq,0);\\n    }\\n    int max (String[] words,int[] score,int[] freq,int ind) {\\n        if (ind == words.length)\\n            return 0;\\n        int sn = 0 + max (words,score,freq,ind + 1);\\n        \\n        String wd = words[ind];\\n        int sum = 0;\\n        boolean flag = true;\\n        for (int i = 0;i < wd.length();i++) {\\n            char ch = wd.charAt (i);\\n            if (freq[ch - \\'a\\'] == 0)\\n                flag = false;\\n            freq[ch - \\'a\\']--;\\n            sum += score[ch - \\'a\\'];\\n        }\\n        int sy = 0;\\n        if (flag) \\n            sy = sum + max (words,score,freq,ind + 1);\\n        for (int i = 0;i < wd.length();i++) {\\n            char ch = wd.charAt (i);\\n            freq[ch - \\'a\\']++;\\n        }\\n        return Math.max (sn,sy);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int[] freq = new int[26];\\n        for (char ch : letters) {\\n            freq[ch - \\'a\\']++;\\n        }\\n        return max (words,score,freq,0);\\n    }\\n    int max (String[] words,int[] score,int[] freq,int ind) {\\n        if (ind == words.length)\\n            return 0;\\n        int sn = 0 + max (words,score,freq,ind + 1);\\n        \\n        String wd = words[ind];\\n        int sum = 0;\\n        boolean flag = true;\\n        for (int i = 0;i < wd.length();i++) {\\n            char ch = wd.charAt (i);\\n            if (freq[ch - \\'a\\'] == 0)\\n                flag = false;\\n            freq[ch - \\'a\\']--;\\n            sum += score[ch - \\'a\\'];\\n        }\\n        int sy = 0;\\n        if (flag) \\n            sy = sum + max (words,score,freq,ind + 1);\\n        for (int i = 0;i < wd.length();i++) {\\n            char ch = wd.charAt (i);\\n            freq[ch - \\'a\\']++;\\n        }\\n        return Math.max (sn,sy);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654640,
                "title": "c-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<string>&words, vector<int>& fre, vector<int>&score, int idx){\\n        if(idx>=words.size()) return 0;\\n        \\n        int NotInclude = solve(words, fre, score, idx+1); \\n        \\n        int scr = 0;\\n        bool flag = true;\\n        for(int i=0; i<words[idx].size(); i++){\\n            char ch = words[idx][i];\\n            \\n            if(fre[ch - \\'a\\'] == 0) flag = false;\\n            \\n            fre[ch - \\'a\\']--;\\n            \\n            scr += score[ch - \\'a\\'];\\n        }\\n         int Include = 0;\\n        \\n         if(flag)   { \\n                        Include += scr + solve(words,fre,score,idx+1);\\n         }\\n        \\n         for(int i=0; i<words[idx].size(); i++)\\n         {\\n            char ch = words[idx][i];\\n             fre[ch - \\'a\\']++;\\n         }\\n        \\n        \\n        return max(Include, NotInclude);\\n        \\n    }\\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> fre(26,0);\\n        map<char,int> mp;\\n        for(char ch : letters) mp[ch]++;\\n        \\n        for(auto it = mp.begin(); it!=mp.end(); it++){\\n            char ch = it->first;\\n            fre[ch - \\'a\\'] = it->second;\\n        }\\n        \\n         return solve(words,fre,score,0);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int solve(vector<string>&words, vector<int>& fre, vector<int>&score, int idx){\\n        if(idx>=words.size()) return 0;\\n        \\n        int NotInclude = solve(words, fre, score, idx+1); \\n        \\n        int scr = 0;\\n        bool flag = true;\\n        for(int i=0; i<words[idx].size(); i++){\\n            char ch = words[idx][i];\\n            \\n            if(fre[ch - \\'a\\'] == 0) flag = false;\\n            \\n            fre[ch - \\'a\\']--;\\n            \\n            scr += score[ch - \\'a\\'];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1593279,
                "title": "understand-it-as-01-knapsack-problem",
                "content": "There\\'s two skills I use here.\\n<br>\\n\\n**01 Knapsack problem**\\nThis problem has given a list of letters, and it limit the letter amount of selected words can not exceed to the letters list.\\nTherefore it can be derived into a 01 Knapsack problem.\\n\\nThat\\'s why we can use DFS to divide and conquer this problem.\\n\\nPlease see the following 01 Knapsack problem introduction.\\nhttps://en.wikipedia.org/wiki/Knapsack_problem\\n<br>\\n\\n**Memorziation by Bit Manipulation**\\nOwing to the words.size() is between 1 to 14, it small than the integer bits.\\n\\nWe utilize the thought to declare a vector to momerize the stage result.\\nEvery bit is corresponding to a word\\'s index, so each bits combination will represent to a unique word combination.\\n<br>\\n\\nThe following is my implment.\\n\\n```\\nclass Solution {\\n\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> weight(26);\\n        vector<int> cache(1 << words.size(), UNINTIALIZED);\\n\\n        for (auto ch : letters)\\n            ++weight[ch - \\'a\\'];\\n\\n        return pick(0, 0, weight, cache, words, score);\\n    }\\n\\nprivate:\\n    const int UNINTIALIZED = -1;\\n    \\n    int pick(int flag, int i, vector<int>& original, vector<int>& cache, const vector<string>& words, const vector<int>& score) {\\n        if (i >= words.size()) return 0;\\n        \\n        const int TAKE = flag | (1<<i);\\n        const int SKIP = flag;\\n\\n        if (cache[TAKE] != UNINTIALIZED) {\\n            return cache[TAKE];\\n        }\\n        \\n        int taken = 0;\\n        vector<int> remain(begin(original), end(original));\\n        for (auto ch : words[i]) {\\n            if (--remain[ch - \\'a\\'] < 0) {\\n                //invalid case, skip it.\\n                return pick(SKIP, i+1, original, cache, words, score);\\n            }\\n            taken += score[ch - \\'a\\'];\\n        }\\n\\n        return cache[TAKE] = max(taken + pick(TAKE, i+1, remain, cache, words, score), pick(SKIP, i+1, original, cache, words, score));\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> weight(26);\\n        vector<int> cache(1 << words.size(), UNINTIALIZED);\\n\\n        for (auto ch : letters)\\n            ++weight[ch - \\'a\\'];\\n\\n        return pick(0, 0, weight, cache, words, score);\\n    }\\n\\nprivate:\\n    const int UNINTIALIZED = -1;\\n    \\n    int pick(int flag, int i, vector<int>& original, vector<int>& cache, const vector<string>& words, const vector<int>& score) {\\n        if (i >= words.size()) return 0;\\n        \\n        const int TAKE = flag | (1<<i);\\n        const int SKIP = flag;\\n\\n        if (cache[TAKE] != UNINTIALIZED) {\\n            return cache[TAKE];\\n        }\\n        \\n        int taken = 0;\\n        vector<int> remain(begin(original), end(original));\\n        for (auto ch : words[i]) {\\n            if (--remain[ch - \\'a\\'] < 0) {\\n                //invalid case, skip it.\\n                return pick(SKIP, i+1, original, cache, words, score);\\n            }\\n            taken += score[ch - \\'a\\'];\\n        }\\n\\n        return cache[TAKE] = max(taken + pick(TAKE, i+1, remain, cache, words, score), pick(SKIP, i+1, original, cache, words, score));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521036,
                "title": "javascript-bitmask-108ms",
                "content": "```\\nconst maxScoreWords = (words, letters, score) => {\\n    let cnt = Array(26).fill(0), n = words.length, res = 0;\\n    for (const c of letters) cnt[c.charCodeAt() - 97]++;\\n    outer:\\n    for (let i = 0; i < 1 << n; i++) {\\n        let ncnt = Array(26).fill(0), sum = 0;\\n        for (let j = 0; j < n; j++) {\\n            if (i & (1 << j)) {\\n                for (const c of words[j]) ncnt[c.charCodeAt() - 97]++;\\n            }\\n        }\\n        for (let j = 0; j < 26; j++) {\\n            if (ncnt[j] > cnt[j]) continue outer;\\n            sum += ncnt[j] * score[j];\\n        }\\n        res = Math.max(res, sum);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bitmask"
                ],
                "code": "```\\nconst maxScoreWords = (words, letters, score) => {\\n    let cnt = Array(26).fill(0), n = words.length, res = 0;\\n    for (const c of letters) cnt[c.charCodeAt() - 97]++;\\n    outer:\\n    for (let i = 0; i < 1 << n; i++) {\\n        let ncnt = Array(26).fill(0), sum = 0;\\n        for (let j = 0; j < n; j++) {\\n            if (i & (1 << j)) {\\n                for (const c of words[j]) ncnt[c.charCodeAt() - 97]++;\\n            }\\n        }\\n        for (let j = 0; j < 26; j++) {\\n            if (ncnt[j] > cnt[j]) continue outer;\\n            sum += ncnt[j] * score[j];\\n        }\\n        res = Math.max(res, sum);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1396327,
                "title": "java-backtracking",
                "content": "Actually not difficult. \\n```\\nclass Solution {\\n    int max = 0;\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int[] freq = new int[26];\\n        for (char c : letters) freq[c - \\'a\\']++;\\n        \\n        //int max = 0;\\n        int[] vis = new int[words.length];\\n        dfs(0, 0, words, freq, score);\\n        return max;\\n    }\\n    \\n    private void dfs(int idx, int scores, String[] words, int[] freq, int[] score) {\\n        //System.out.println(Arrays.toString(vis));\\n        for (int num : freq) {\\n            if (num < 0) return;\\n        }\\n        max = Math.max(scores, max);\\n        for (int i = idx; i < words.length; i++) { // subset question\\n        \\n            String word = words[i];  // take ith word\\n            int tmp = 0; // should use tmp for sake of backtrack\\n            for (char c : word.toCharArray()) {\\n                freq[c - \\'a\\']--;\\n                tmp += score[c - \\'a\\'];\\n            }\\n            dfs(i + 1, scores + tmp, words, freq, score); // i + 1, not idx + 1\\n            \\n            // backtrack\\n            for (char c : word.toCharArray()) {\\n                freq[c - \\'a\\']++;\\n            }\\n            \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int[] freq = new int[26];\\n        for (char c : letters) freq[c - \\'a\\']++;\\n        \\n        //int max = 0;\\n        int[] vis = new int[words.length];\\n        dfs(0, 0, words, freq, score);\\n        return max;\\n    }\\n    \\n    private void dfs(int idx, int scores, String[] words, int[] freq, int[] score) {\\n        //System.out.println(Arrays.toString(vis));\\n        for (int num : freq) {\\n            if (num < 0) return;\\n        }\\n        max = Math.max(scores, max);\\n        for (int i = idx; i < words.length; i++) { // subset question\\n        \\n            String word = words[i];  // take ith word\\n            int tmp = 0; // should use tmp for sake of backtrack\\n            for (char c : word.toCharArray()) {\\n                freq[c - \\'a\\']--;\\n                tmp += score[c - \\'a\\'];\\n            }\\n            dfs(i + 1, scores + tmp, words, freq, score); // i + 1, not idx + 1\\n            \\n            // backtrack\\n            for (char c : word.toCharArray()) {\\n                freq[c - \\'a\\']++;\\n            }\\n            \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229630,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int>points;\\n    vector<int>chars;\\n    \\n    bool possible(string s)\\n    {\\n        vector<int>temp(26,0);\\n        for(auto c:s)\\n            temp[c-\\'a\\']++;\\n        for(int i=0;i<26;i++)\\n            if(chars[i]<temp[i])\\n                return false;\\n        return true;\\n    }\\n    \\n    void use_it(string s)\\n    {\\n        for(auto c:s)\\n            chars[c-\\'a\\']--;\\n    }\\n    \\n    void back_track(string s)\\n    {\\n        for(auto c:s)\\n            chars[c-\\'a\\']++;\\n    }\\n    \\n    int msw(int i,vector<string>& words)\\n    {\\n        int res=0;\\n        for(int j=i;j<words.size();j++)\\n        {\\n            if(possible(words[j]))\\n            {\\n                use_it(words[j]);\\n                res=max(res,points[words[j]]+msw(j+1,words));\\n                back_track(words[j]);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) \\n    {\\n        for(auto w:words)\\n        {\\n            int p=0;\\n            for(auto c:w)\\n                p+=score[c-\\'a\\'];\\n            points[w]=p;\\n        }\\n        chars.resize(26,0);\\n        for(auto c:letters)\\n            chars[c-\\'a\\']++;\\n        return msw(0,words);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int>points;\\n    vector<int>chars;\\n    \\n    bool possible(string s)\\n    {\\n        vector<int>temp(26,0);\\n        for(auto c:s)\\n            temp[c-\\'a\\']++;\\n        for(int i=0;i<26;i++)\\n            if(chars[i]<temp[i])\\n                return false;\\n        return true;\\n    }\\n    \\n    void use_it(string s)\\n    {\\n        for(auto c:s)\\n            chars[c-\\'a\\']--;\\n    }\\n    \\n    void back_track(string s)\\n    {\\n        for(auto c:s)\\n            chars[c-\\'a\\']++;\\n    }\\n    \\n    int msw(int i,vector<string>& words)\\n    {\\n        int res=0;\\n        for(int j=i;j<words.size();j++)\\n        {\\n            if(possible(words[j]))\\n            {\\n                use_it(words[j]);\\n                res=max(res,points[words[j]]+msw(j+1,words));\\n                back_track(words[j]);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) \\n    {\\n        for(auto w:words)\\n        {\\n            int p=0;\\n            for(auto c:w)\\n                p+=score[c-\\'a\\'];\\n            points[w]=p;\\n        }\\n        chars.resize(26,0);\\n        for(auto c:letters)\\n            chars[c-\\'a\\']++;\\n        return msw(0,words);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193986,
                "title": "c-solution-faster-than-100-95-less-space-using-recursion-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int res = 0;  // result (max words score)\\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& scores) {\\n        // count frequency of each letter \\n        vector<int> l(26, 0);\\n        for(int i=0; i<letters.size(); i++){\\n            l[letters[i] - \\'a\\']++;\\n        }\\n        \\n        find(words, l, scores, 0, 0);\\n        return res;\\n    }\\n    \\n    void find(vector<string>& w, vector<int>& l, vector<int>& s, int index, int temp){\\n        if(index == w.size()){\\n            res = max(res, temp);\\n            return;\\n        }\\n    \\n        // word not selected\\n        find(w, l, s, index+1, temp);\\n        \\n        // word selected\\n        string st = w[index];\\n        int score = 0;\\n        bool flag = true;\\n        \\n        for(int i=0; i<st.size(); i++){\\n            if(l[st[i] - \\'a\\'] == 0) flag = false;\\n            \\n            l[st[i] - \\'a\\']--;\\n            score += s[st[i] - \\'a\\'];\\n        }\\n        \\n        if(flag){\\n            find(w, l, s, index+1, score + temp);\\n        }\\n        \\n        for(int i=0; i<st.size(); i++){\\n            l[st[i] - \\'a\\']++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int res = 0;  // result (max words score)\\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& scores) {\\n        // count frequency of each letter \\n        vector<int> l(26, 0);\\n        for(int i=0; i<letters.size(); i++){\\n            l[letters[i] - \\'a\\']++;\\n        }\\n        \\n        find(words, l, scores, 0, 0);\\n        return res;\\n    }\\n    \\n    void find(vector<string>& w, vector<int>& l, vector<int>& s, int index, int temp){\\n        if(index == w.size()){\\n            res = max(res, temp);\\n            return;\\n        }\\n    \\n        // word not selected\\n        find(w, l, s, index+1, temp);\\n        \\n        // word selected\\n        string st = w[index];\\n        int score = 0;\\n        bool flag = true;\\n        \\n        for(int i=0; i<st.size(); i++){\\n            if(l[st[i] - \\'a\\'] == 0) flag = false;\\n            \\n            l[st[i] - \\'a\\']--;\\n            score += s[st[i] - \\'a\\'];\\n        }\\n        \\n        if(flag){\\n            find(w, l, s, index+1, score + temp);\\n        }\\n        \\n        for(int i=0; i<st.size(); i++){\\n            l[st[i] - \\'a\\']++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944032,
                "title": "java-backtracking-1ms-faster-than-95-solutions",
                "content": "**Kindly upvote this post if you find this solution useful.**\\n\\n```\\n private int ans = 0;\\n    String[] words;\\n    int[] score;\\n\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int freq[] = new int[26];\\n        this.words = words;\\n        this.score = score;\\n        for (char ch : letters) freq[ch - \\'a\\']++;\\n        helper(0, freq, 0);\\n        return ans;\\n    }\\n\\n    void helper(int index, int[] letters, int sum) {\\n        if (index == words.length) {\\n            ans = Math.max(ans, sum);\\n            return;\\n        }\\n        int flag = 0;\\n        int freq[] = new int[26];\\n        int tempScore = 0;\\n        for (char ch : words[index].toCharArray()) {\\n            freq[ch - \\'a\\']++;\\n            tempScore += score[ch - \\'a\\'];\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            if (freq[i] > letters[i]) {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag == 0) {\\n            for (int i = 0; i < 26; i++) letters[i] -= freq[i];\\n            helper(index + 1, letters, sum + tempScore);\\n            for (int i = 0; i < 26; i++) letters[i] += freq[i];\\n        }\\n        helper(index + 1, letters, sum);\\n    }\\n",
                "solutionTags": [],
                "code": "**Kindly upvote this post if you find this solution useful.**\\n\\n```\\n private int ans = 0;\\n    String[] words;\\n    int[] score;\\n\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int freq[] = new int[26];\\n        this.words = words;\\n        this.score = score;\\n        for (char ch : letters) freq[ch - \\'a\\']++;\\n        helper(0, freq, 0);\\n        return ans;\\n    }\\n\\n    void helper(int index, int[] letters, int sum) {\\n        if (index == words.length) {\\n            ans = Math.max(ans, sum);\\n            return;\\n        }\\n        int flag = 0;\\n        int freq[] = new int[26];\\n        int tempScore = 0;\\n        for (char ch : words[index].toCharArray()) {\\n            freq[ch - \\'a\\']++;\\n            tempScore += score[ch - \\'a\\'];\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            if (freq[i] > letters[i]) {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag == 0) {\\n            for (int i = 0; i < 26; i++) letters[i] -= freq[i];\\n            helper(index + 1, letters, sum + tempScore);\\n            for (int i = 0; i < 26; i++) letters[i] += freq[i];\\n        }\\n        helper(index + 1, letters, sum);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 930220,
                "title": "python-counter-dp-bitmask",
                "content": "Thought process:\\n1. Problem state: selected words\\n2. Check constraints - length of word list is within reasonable range to use bitmask + DP. Otherwise we must use recursion.\\n3. collections.Counter is a handy class in Python that simplifies a lot of boilerplate code.\\n\\n```\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        word_counters = [collections.Counter(w) for w in words]\\n        letters = collections.Counter(letters)\\n        n = 1<<len(words)\\n        dp = [-1]*n\\n        dp[0] = 0\\n        for mask in range(n):\\n            if dp[mask] == -1: continue\\n            # Calculate used letters\\n            c = collections.Counter()\\n            for j in range(len(words)):\\n                if mask & (1<<j) == 0: continue\\n                c += word_counters[j]\\n            left = letters - c \\n            for j in range(len(words)):\\n                if mask & (1<<j) != 0: continue\\n                if word_counters[j] - left: continue # not enough letters\\n                dp[mask|(1<<j)] = max(dp[mask|(1<<j)], dp[mask] + sum(score[ord(ch)-ord(\\'a\\')] for ch in words[j]))\\n        return max(dp)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        word_counters = [collections.Counter(w) for w in words]\\n        letters = collections.Counter(letters)\\n        n = 1<<len(words)\\n        dp = [-1]*n\\n        dp[0] = 0\\n        for mask in range(n):\\n            if dp[mask] == -1: continue\\n            # Calculate used letters\\n            c = collections.Counter()\\n            for j in range(len(words)):\\n                if mask & (1<<j) == 0: continue\\n                c += word_counters[j]\\n            left = letters - c \\n            for j in range(len(words)):\\n                if mask & (1<<j) != 0: continue\\n                if word_counters[j] - left: continue # not enough letters\\n                dp[mask|(1<<j)] = max(dp[mask|(1<<j)], dp[mask] + sum(score[ord(ch)-ord(\\'a\\')] for ch in words[j]))\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918318,
                "title": "short-python-solution-97",
                "content": "```\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        def dp(i,L):\\n            if i == len(words): return 0\\n            ans = 0\\n            M = L\\n            for l in words[i]:\\n                if l not in M: return dp(i+1,L)\\n                M = M.replace(l,\"\",1)\\n                ans += score[ord(l) - 97]\\n            return max(dp(i + 1, L), ans + dp(i + 1, M))\\n        return dp(0, \"\".join(letters))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        def dp(i,L):\\n            if i == len(words): return 0\\n            ans = 0\\n            M = L\\n            for l in words[i]:\\n                if l not in M: return dp(i+1,L)\\n                M = M.replace(l,\"\",1)\\n                ans += score[ord(l) - 97]\\n            return max(dp(i + 1, L), ans + dp(i + 1, M))\\n        return dp(0, \"\".join(letters))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 681628,
                "title": "c-simple-backtracking",
                "content": "```\\nclass Solution {\\n    unordered_map<char,int>score_map;\\n    int ans=0;\\npublic:\\nvoid helpme(vector<string>&words,int pos,unordered_map<char,int>u,int score)\\n    {   \\n        if(pos==words.size())\\n        {\\n           ans=max(ans,score);\\n            return;\\n        }\\n        helpme(words,pos+1,u,score);\\n       int i;\\n       for(i=0;i<words[pos].size();i++)\\n       {\\n           u[words[pos][i]]--;\\n           if(u[words[pos][i]]<0)return;\\n           score+=score_map[words[pos][i]];\\n       }\\n    helpme(words,pos+1,u,score);\\n        \\n}\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        unordered_map<char,int>u;\\n        int i;\\n        for(i=0;i<letters.size();i++)\\n        {\\n            u[letters[i]]++;\\n        }\\n        for(i=0;i<26;i++)\\n        {\\n            score_map[\\'a\\'+i]=score[i];\\n        }\\n        helpme(words,0,u,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_map<char,int>score_map;\\n    int ans=0;\\npublic:\\nvoid helpme(vector<string>&words,int pos,unordered_map<char,int>u,int score)\\n    {   \\n        if(pos==words.size())\\n        {\\n           ans=max(ans,score);\\n            return;\\n        }\\n        helpme(words,pos+1,u,score);\\n       int i;\\n       for(i=0;i<words[pos].size();i++)\\n       {\\n           u[words[pos][i]]--;\\n           if(u[words[pos][i]]<0)return;\\n           score+=score_map[words[pos][i]];\\n       }\\n    helpme(words,pos+1,u,score);\\n        \\n}\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        unordered_map<char,int>u;\\n        int i;\\n        for(i=0;i<letters.size();i++)\\n        {\\n            u[letters[i]]++;\\n        }\\n        for(i=0;i<26;i++)\\n        {\\n            score_map[\\'a\\'+i]=score[i];\\n        }\\n        helpme(words,0,u,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 619717,
                "title": "c-o-2-wlist-sizeof-word-dp-solution-faster-than-56",
                "content": "```\\nvector<vector<int>> memo;\\nint dp(int mask,int i,vector<string>& words, vector<int>& score,vector<int> count)\\n{\\n\\tif(i>=words.size())\\n\\t\\treturn 0;\\n\\tif(memo[mask][i]!=-1)\\n\\t\\treturn memo[mask][i];\\n\\tint q=dp(mask,i+1,words,score,count);\\n\\tstring s=words[i];\\n\\tint val=0;bool flag=true;\\n\\tfor(char x: s)\\n\\t{\\n\\t\\tif(count[x-\\'a\\']>0)\\n\\t\\t{\\n\\t\\t\\tval+=score[x-\\'a\\'];\\n\\t\\t\\tcount[x-\\'a\\']--;\\n\\t\\t}\\n\\t\\telse flag=false;\\n\\t}\\n\\tif(flag)\\n\\t\\tq=max(q,val+dp(mask|1<<i,i+1,words,score,count));\\n\\treturn memo[mask][i] = q;\\n}\\nint maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) \\n{\\n    vector<int> count;\\n\\tint allmask=(1<<words.size())-1;\\n\\tcount.resize(26,0);\\n\\tfor(char x:letters)\\n\\t\\tcount[x-\\'a\\']++;\\n\\tmemo.resize(allmask,vector<int>(letters.size(),-1));\\n\\treturn dp(0,0,words,score,count);\\n\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nvector<vector<int>> memo;\\nint dp(int mask,int i,vector<string>& words, vector<int>& score,vector<int> count)\\n{\\n\\tif(i>=words.size())\\n\\t\\treturn 0;\\n\\tif(memo[mask][i]!=-1)\\n\\t\\treturn memo[mask][i];\\n\\tint q=dp(mask,i+1,words,score,count);\\n\\tstring s=words[i];\\n\\tint val=0;bool flag=true;\\n\\tfor(char x: s)\\n\\t{\\n\\t\\tif(count[x-\\'a\\']>0)\\n\\t\\t{\\n\\t\\t\\tval+=score[x-\\'a\\'];\\n\\t\\t\\tcount[x-\\'a\\']--;\\n\\t\\t}\\n\\t\\telse flag=false;\\n\\t}\\n\\tif(flag)\\n\\t\\tq=max(q,val+dp(mask|1<<i,i+1,words,score,count));\\n\\treturn memo[mask][i] = q;\\n}\\nint maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) \\n{\\n    vector<int> count;\\n\\tint allmask=(1<<words.size())-1;\\n\\tcount.resize(26,0);\\n\\tfor(char x:letters)\\n\\t\\tcount[x-\\'a\\']++;\\n\\tmemo.resize(allmask,vector<int>(letters.size(),-1));\\n\\treturn dp(0,0,words,score,count);\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 429059,
                "title": "python-using-recursion",
                "content": "```\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        word_scores = []\\n        for word in words:\\n            s = 0\\n            for c in word:\\n                s += score[ord(c)-ord(\\'a\\')]\\n            word_scores.append(s)\\n        \\n        def find_max_score(words_left,letters_left,curr_score):\\n            if words_left==len(words):\\n                return curr_score\\n            else:\\n                score_without = find_max_score(words_left+1,letters_left.copy(),curr_score)\\n                word_ok = True\\n                for c in words[words_left]:\\n                    if c in letters_left:\\n                        letters_left.remove(c)\\n                    else:\\n                        word_ok = False\\n                if not word_ok:\\n                    return score_without\\n                else:\\n                    return max(score_without, find_max_score(words_left+1,letters_left.copy(),curr_score+word_scores[words_left]))\\n        \\n        return find_max_score(0,letters,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        word_scores = []\\n        for word in words:\\n            s = 0\\n            for c in word:\\n                s += score[ord(c)-ord(\\'a\\')]\\n            word_scores.append(s)\\n        \\n        def find_max_score(words_left,letters_left,curr_score):\\n            if words_left==len(words):\\n                return curr_score\\n            else:\\n                score_without = find_max_score(words_left+1,letters_left.copy(),curr_score)\\n                word_ok = True\\n                for c in words[words_left]:\\n                    if c in letters_left:\\n                        letters_left.remove(c)\\n                    else:\\n                        word_ok = False\\n                if not word_ok:\\n                    return score_without\\n                else:\\n                    return max(score_without, find_max_score(words_left+1,letters_left.copy(),curr_score+word_scores[words_left]))\\n        \\n        return find_max_score(0,letters,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 426874,
                "title": "try-all-combinations-of-words-and-choose-max-score-for-the-valid-case",
                "content": "```csharp\\npublic int MaxScoreWords(string[] words, char[] letters, int[] score)\\n{\\n\\tint result = 0;\\n\\n\\tint[] lettersFrequency = new int[26];\\n\\tforeach (char c in letters)\\n\\t{\\n\\t\\tlettersFrequency[c - \\'a\\']++;\\n\\t}\\n\\n\\tfor (int k = 1; k < (1 << words.Length); k++)\\n\\t{\\n\\t\\tint[] currentFrequency = new int[26];\\n\\t\\tint sum = 0;\\n\\n\\t\\tfor (int i = 0; i < words.Length; i++)\\n\\t\\t{\\n\\t\\t\\tif ((k & (1 << i)) != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tforeach (char c in words[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcurrentFrequency[c - \\'a\\']++;\\n\\t\\t\\t\\t\\tsum += score[c - \\'a\\'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tbool isValid = true;\\n\\t\\tfor (int i = 0; i < 26; i++)\\n\\t\\t{\\n\\t\\t\\tif (currentFrequency[i] > lettersFrequency[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tisValid = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (isValid)\\n\\t\\t{\\n\\t\\t\\tresult = Math.Max(result, sum);\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MaxScoreWords(string[] words, char[] letters, int[] score)\\n{\\n\\tint result = 0;\\n\\n\\tint[] lettersFrequency = new int[26];\\n\\tforeach (char c in letters)\\n\\t{\\n\\t\\tlettersFrequency[c - \\'a\\']++;\\n\\t}\\n\\n\\tfor (int k = 1; k < (1 << words.Length); k++)\\n\\t{\\n\\t\\tint[] currentFrequency = new int[26];\\n\\t\\tint sum = 0;\\n\\n\\t\\tfor (int i = 0; i < words.Length; i++)\\n\\t\\t{\\n\\t\\t\\tif ((k & (1 << i)) != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tforeach (char c in words[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcurrentFrequency[c - \\'a\\']++;\\n\\t\\t\\t\\t\\tsum += score[c - \\'a\\'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tbool isValid = true;\\n\\t\\tfor (int i = 0; i < 26; i++)\\n\\t\\t{\\n\\t\\t\\tif (currentFrequency[i] > lettersFrequency[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tisValid = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (isValid)\\n\\t\\t{\\n\\t\\t\\tresult = Math.Max(result, sum);\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 426291,
                "title": "two-python-solutions-with-explanations",
                "content": "**Video Explanations**\\nhttps://www.youtube.com/watch?v=p5g92xBccAw\\n\\n**Solution 1**\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        def letterScore(c):\\n            return score[ord(c) - ord(\\'a\\')]\\n        \\n        def helper(i, remaining, scoreSoFar):\\n            if not remaining or i == len(words):\\n                return scoreSoFar\\n            # choices\\n            # 1. skip words[i]\\n            res = helper(i + 1, remaining, scoreSoFar)\\n            \\n            # 2. take words[i] if possible\\n            cw = Counter(words[i])\\n            if not (cw - remaining):\\n                res = max(res, helper(i + 1, remaining - cw, scoreSoFar + sum(map(letterScore, words[i]))))\\n            return res\\n        \\n        return helper(0, Counter(letters), 0)\\n```\\n\\n**Solution 2**\\n```\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        def letterScore(c):\\n            return score[ord(c) - ord(\\'a\\')]\\n        \\n        def getCountLetters(lst):\\n            counter = [0 for _ in range(26)]\\n            for c in lst:\\n                counter[ord(c) - ord(\\'a\\')] += 1\\n            return counter \\n        \\n        def substract(count1, count2): # returns a pair Boolean (whether count2 is included in count 1), counter of the remaining of count1 after removing count2 occ\\n            for i in range(26):\\n                if count1[i] < count2[i]:\\n                    return False, count1\\n                count1[i] -= count2[i]    \\n            return True, count1\\n        \\n        def helper(i, remaining, scoreSoFar):\\n            if not remaining or i == len(words):\\n                return scoreSoFar\\n        \\n\\t\\t\\t# choices\\n            # 1. skip words[i]\\n            res = helper(i + 1, remaining, scoreSoFar)\\n            \\n            # 2. take words[i] if possible\\n            cw = getCountLetters(words[i])\\n            canBeTaken, remainingLetters = substract(remaining.copy(), cw)\\n            if canBeTaken:\\n                res = max(res, helper(i + 1, remainingLetters, scoreSoFar + sum(map(letterScore, words[i]))))\\n            return res\\n        \\n        return helper(0, getCountLetters(letters), 0)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        def letterScore(c):\\n            return score[ord(c) - ord(\\'a\\')]\\n        \\n        def helper(i, remaining, scoreSoFar):\\n            if not remaining or i == len(words):\\n                return scoreSoFar\\n            # choices\\n            # 1. skip words[i]\\n            res = helper(i + 1, remaining, scoreSoFar)\\n            \\n            # 2. take words[i] if possible\\n            cw = Counter(words[i])\\n            if not (cw - remaining):\\n                res = max(res, helper(i + 1, remaining - cw, scoreSoFar + sum(map(letterScore, words[i]))))\\n            return res\\n        \\n        return helper(0, Counter(letters), 0)\\n```\n```\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        def letterScore(c):\\n            return score[ord(c) - ord(\\'a\\')]\\n        \\n        def getCountLetters(lst):\\n            counter = [0 for _ in range(26)]\\n            for c in lst:\\n                counter[ord(c) - ord(\\'a\\')] += 1\\n            return counter \\n        \\n        def substract(count1, count2): # returns a pair Boolean (whether count2 is included in count 1), counter of the remaining of count1 after removing count2 occ\\n            for i in range(26):\\n                if count1[i] < count2[i]:\\n                    return False, count1\\n                count1[i] -= count2[i]    \\n            return True, count1\\n        \\n        def helper(i, remaining, scoreSoFar):\\n            if not remaining or i == len(words):\\n                return scoreSoFar\\n        \\n\\t\\t\\t# choices\\n            # 1. skip words[i]\\n            res = helper(i + 1, remaining, scoreSoFar)\\n            \\n            # 2. take words[i] if possible\\n            cw = getCountLetters(words[i])\\n            canBeTaken, remainingLetters = substract(remaining.copy(), cw)\\n            if canBeTaken:\\n                res = max(res, helper(i + 1, remainingLetters, scoreSoFar + sum(map(letterScore, words[i]))))\\n            return res\\n        \\n        return helper(0, getCountLetters(letters), 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 426161,
                "title": "c-0-ms-dfs",
                "content": "1. filter out words that originally exceeds the # of chars allowed;\\n2. DFS has two option, use it or not. If use it, we should make sure it won\\'t use more than left letters.\\n3. update the res to max score we can get so far.\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> allLetters(26);\\n        for(char c: letters) {\\n            ++allLetters[c-\\'a\\'];\\n        }\\n        \\n        vector<string> left;\\n        for(string s: words) {\\n            vector<int> v = getV(s);\\n            if(valid(v, allLetters)) {\\n                lettersCount.push_back(v);\\n                wordScore.push_back(getScore(v, score));\\n                left.push_back(s);\\n            }\\n        }\\n        \\n        dfs(0, left, allLetters, 0);\\n        return res;\\n    }\\n    \\n    void dfs(int start, vector<string>& words, vector<int> validCount, int score) {\\n        if(start == words.size())\\n            return;\\n        \\n        //option 1, we can skip it\\n        dfs(start+1, words, validCount, score);\\n        \\n        //option 2, we choose it, but it has to be not exceeding letter left\\n        vector<int> v = lettersCount[start];\\n        \\n        for(int i = 0; i < 26; ++i) {\\n            if((validCount[i] -= v[i]) < 0) {\\n                return;\\n            }\\n        }\\n        score += wordScore[start];\\n        res = max(res, score);\\n        dfs(start+1, words, validCount, score);\\n    }\\n    \\n    vector<int> getV(string& s) {\\n        vector<int> res(26);\\n        for(char c: s) {\\n            ++res[c-\\'a\\'];\\n        }\\n        return res;\\n    }\\n    \\n    bool valid(vector<int>& v, vector<int>& base) {\\n        for(int i = 0; i < 26; ++i) {\\n            if(v[i] > base[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    int getScore(vector<int>& v, vector<int>& score) {\\n        int res = 0;\\n        for(int i = 0; i < 26; ++i) {\\n            res += score[i] * v[i];\\n        }\\n        return res;\\n    }\\nprivate:\\n\\n    vector<int> wordScore;\\n    vector<vector<int>> lettersCount;\\n    int res = 0;\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> allLetters(26);\\n        for(char c: letters) {\\n            ++allLetters[c-\\'a\\'];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 425279,
                "title": "python3-a-concise-8-line-recursive-solution",
                "content": "First, let\\'s define a function `sf` which maps a word to its score. With such mapping, we can loop through `words`. At each `word`, if `word` can be expressed by available `letters`, we compare the score with `word` against without `word`. Otherwise, we simply move on to next `word`. An 8-line implementation in Python is as below. \\n```\\nfrom collections import Counter \\n\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        sf = lambda w: sum(map(lambda c: score[ord(c)-97], list(w)))\\n        \\n        def maxscore(words, count):\\n            if len(words) == 0: return 0 #base case \\n            if all(words[0].count(i) <= count.get(i, 0) for i in set(words[0])): \\n                return max(sf(words[0]) + maxscore(words[1:], count - Counter(words[0])), maxscore(words[1:], count))\\n            else: \\n                return maxscore(words[1:], count)\\n        \\n        return maxscore(words, Counter(letters))\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nfrom collections import Counter \\n\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        sf = lambda w: sum(map(lambda c: score[ord(c)-97], list(w)))\\n        \\n        def maxscore(words, count):\\n            if len(words) == 0: return 0 #base case \\n            if all(words[0].count(i) <= count.get(i, 0) for i in set(words[0])): \\n                return max(sf(words[0]) + maxscore(words[1:], count - Counter(words[0])), maxscore(words[1:], count))\\n            else: \\n                return maxscore(words[1:], count)\\n        \\n        return maxscore(words, Counter(letters))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425213,
                "title": "python-backtracing",
                "content": "```\\ndef maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n\\tc = collections.Counter(letters)\\n\\tself.res = 0\\n\\tdef bt(i, cnt, scores):\\n\\t\\tif i == len(words):\\n\\t\\t\\tself.res = max(self.res, scores)\\n\\t\\t\\treturn\\n\\t\\tbt(i+1, cnt, scores)\\n\\t\\tcur = collections.Counter(words[i])\\n\\t\\tif all(cur[k] <= cnt[k] for k in cur):\\n\\t\\t\\tcur_score = sum(score[ord(c) - ord(\\'a\\')] for c in words[i])\\n\\t\\t\\tbt(i+1, cnt-cur, scores + cur_score)\\n\\tbt(0, c, 0)\\n\\treturn self.res\\n```\\n\\nanother implementation:\\n```\\ndef maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n\\tdef bt(i, cnt):\\n\\t\\tres = 0\\n\\t\\tfor j in range(i, len(words)):\\n\\t\\t\\tcur = collections.Counter(words[j])\\n\\t\\t\\tif all(cur[k] <= cnt[k] for k in cur):\\n\\t\\t\\t\\tcur_score = sum(score[ord(c) - ord(\\'a\\')] for c in words[j])\\n\\t\\t\\t\\tres = max(res, cur_score + bt(j+1, cnt-cur))\\n\\t\\treturn res\\n\\tc = collections.Counter(letters)\\n\\treturn bt(0, c)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n\\tc = collections.Counter(letters)\\n\\tself.res = 0\\n\\tdef bt(i, cnt, scores):\\n\\t\\tif i == len(words):\\n\\t\\t\\tself.res = max(self.res, scores)\\n\\t\\t\\treturn\\n\\t\\tbt(i+1, cnt, scores)\\n\\t\\tcur = collections.Counter(words[i])\\n\\t\\tif all(cur[k] <= cnt[k] for k in cur):\\n\\t\\t\\tcur_score = sum(score[ord(c) - ord(\\'a\\')] for c in words[i])\\n\\t\\t\\tbt(i+1, cnt-cur, scores + cur_score)\\n\\tbt(0, c, 0)\\n\\treturn self.res\\n```\n```\\ndef maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n\\tdef bt(i, cnt):\\n\\t\\tres = 0\\n\\t\\tfor j in range(i, len(words)):\\n\\t\\t\\tcur = collections.Counter(words[j])\\n\\t\\t\\tif all(cur[k] <= cnt[k] for k in cur):\\n\\t\\t\\t\\tcur_score = sum(score[ord(c) - ord(\\'a\\')] for c in words[j])\\n\\t\\t\\t\\tres = max(res, cur_score + bt(j+1, cnt-cur))\\n\\t\\treturn res\\n\\tc = collections.Counter(letters)\\n\\treturn bt(0, c)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4009267,
                "title": "simple-straight-forward-method-backtracking-java",
                "content": "# Example\\nInput: words = [\"dog\",\"cat\",\"dad\",\"good\"], letters = [\"a\",\"a\",\"c\",\"d\",\"d\",\"d\",\"g\",\"o\",\"o\"], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]\\nOutput: 23\\nExplanation:\\nScore  a=1, c=9, d=5, g=3, o=2\\nGiven letters, we can form the words \"dad\" (5+1+5) and \"good\" (3+2+2+5) with a score of 23.\\nWords \"dad\" and \"dog\" only get a score of 21.\\n**small explanation**\\nwe can form words \"dog\",\"dad\",\"good\" but not \"cat\" because \\'t\\' is not available in letters[]\\namong those words the maximum score we can get by forming \"dad\" and \"good\" which needs\\nd-3,a-1,g-1,o-2 ,score=23\\namong 1-a,9-c,5-d,3-g,2-o\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition is straight forward because the words length is given too small. so use backtracking.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, find the frequency of each letter given in letters[] array.\\nEvery word has two choices -> include it or exclude it\\nWe can include a word only when all letters are available, So check is it valid to include current word using isValid() method by passing the words[i](current word),arr[](availability of letters)\\n**If the current word is valid to include**\\n\\nsince the current word is valid to include find the score that we get by including it.\\nBy including the current word(words[i]), the availability of each letter of word will decrease by 1.\\nCall to next word(words[i+1]) by adding score.\\nThe backtracking step is restoring the availability(frequency) of all the letters of words[i]\\n**If the current word is not valid to include**\\nif the current word is not valid to include(the availability of letters are insufficient to form the current word(words[i])), simply call to next word(words[i+1])\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    static int maxScore=0;\\n    public static boolean isValid(String s,int arr[])\\n    {\\n        int a[]=new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            a[s.charAt(i)-97]++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(arr[i]<a[i])\\n            return false;\\n        }\\n        return true;\\n    }\\n    public static int getScore(String s,int arr[],int score[])\\n    {\\n        int a=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            a+=score[s.charAt(i)-97];\\n            arr[s.charAt(i)-97]--;\\n        }\\n        return a;\\n    }\\n    public static void restore(String s,int arr[])\\n    {\\n        for(int i=0;i<s.length();i++)\\n        {\\n            arr[s.charAt(i)-97]++;\\n        }\\n    }\\n    public static void findMaxScore(String words[],int arr[],int score[],int i,int currScore)\\n    {\\n        if(i==words.length)\\n        {\\n            maxScore=Math.max(maxScore,currScore);\\n            return;\\n        }\\n        if(isValid(words[i],arr))//include\\n        {\\n            int s=getScore(words[i],arr,score);\\n            findMaxScore(words,arr,score,i+1,currScore+s);\\n            restore(words[i],arr);\\n        }\\n        findMaxScore(words,arr,score,i+1,currScore);\\n    }\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        maxScore=0;\\n        int arr[]=new int[26];\\n        for(int i=0;i<letters.length;i++)\\n        {\\n            arr[letters[i]-97]++;\\n        }\\n        findMaxScore(words,arr,score,0,0);\\n        return maxScore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    static int maxScore=0;\\n    public static boolean isValid(String s,int arr[])\\n    {\\n        int a[]=new int[26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            a[s.charAt(i)-97]++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(arr[i]<a[i])\\n            return false;\\n        }\\n        return true;\\n    }\\n    public static int getScore(String s,int arr[],int score[])\\n    {\\n        int a=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            a+=score[s.charAt(i)-97];\\n            arr[s.charAt(i)-97]--;\\n        }\\n        return a;\\n    }\\n    public static void restore(String s,int arr[])\\n    {\\n        for(int i=0;i<s.length();i++)\\n        {\\n            arr[s.charAt(i)-97]++;\\n        }\\n    }\\n    public static void findMaxScore(String words[],int arr[],int score[],int i,int currScore)\\n    {\\n        if(i==words.length)\\n        {\\n            maxScore=Math.max(maxScore,currScore);\\n            return;\\n        }\\n        if(isValid(words[i],arr))//include\\n        {\\n            int s=getScore(words[i],arr,score);\\n            findMaxScore(words,arr,score,i+1,currScore+s);\\n            restore(words[i],arr);\\n        }\\n        findMaxScore(words,arr,score,i+1,currScore);\\n    }\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        maxScore=0;\\n        int arr[]=new int[26];\\n        for(int i=0;i<letters.length;i++)\\n        {\\n            arr[letters[i]-97]++;\\n        }\\n        findMaxScore(words,arr,score,0,0);\\n        return maxScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833763,
                "title": "solved-using-python-counters",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs the hint suggests, there are few enough ```words``` that we can exhaustively enumerate its possible subsets, scoring each and keeping track of the maximum score.  This implies that we will calculate attributes of each one of the ```words``` multiple times during the recursive depth-first traversal of the space of subsets, so it may be desirable to calculate these once, up front.  The attributes of each word are (1) What is the score for the word and (2) what does the word \"cost\" in terms of consuming the ```letters```.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince the attributes both depend on the number and indentity of the letters making up each word, we will use one of my favorite Python constructs, the ```Counter``` (see https://docs.python.org/3/library/collections.html#collections.Counter).  \\n\\nFirst, we calculate the score for each of the ```words``` by mapping the ```scoreWord``` method over them.  We also calculate, using several ```Counter```s, the number of each character in both ```letters``` and each of the ```words```.\\n\\nNext, we perform a recursive depth-first search over the possible subsets of ```words```, using ```Counter```s several ways:  First, we determine whether the remaining ```letters``` can cover the next word being considered with the method ```is_enough```.  Then, for the recursion, part of the state is the number of unconsumed ```letters```, which get decremented for the word we are trying.  We can do this very conveniently with ```Counter```s using their ```update``` and ```subtract``` methods.   \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time for the first part of the program, which ```map```s over ```letters``` and ```words```, is proportional to the number and length of ```words```.  The time for the second part, enumerating and scoring the subsets of ```words```, is proportional to the number of subsets, which is 2 ^ |words|, which dominates the time, so the overall time complexity is $$O(2^n)$$; as noted in the hint, this is acceptable since $$n$$ is limited to 16.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe storage used, besides the arguments and the return value, consists mainly of a number of ```Counters```; each consists of up to 26 letter:count pairs, so the overall storage is $$O(1)$$.\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        self.words = words\\n        self.word_scores = list( map( lambda word: self.scoreWord( word, score ), words ) )\\n        self.word_letter_counts = list( map( Counter, words ) )\\n        maxScore = self.maxScoreRec( 0, Counter( letters ) )    # First arg. is index into \"words\"\\n        return maxScore\\n\\n    def maxScoreRec( self, index, letter_counter ):\\n        result = 0\\n        if index == len( self.words ):\\n            result = 0\\n        else:\\n            # Try skipping \"words[index]\"\\n            result = max( result, self.maxScoreRec( index + 1, letter_counter ) )\\n            # Try using \"words[index]\"\\n            if self.enough_letters( letter_counter, self.word_letter_counts[ index ] ):\\n                self.subtract_count( letter_counter, self.word_letter_counts[ index ] )\\n                result = max( result, \\n                              self.word_scores[ index ] +\\n                              self.maxScoreRec( index + 1, letter_counter ) )\\n                self.add_count( letter_counter, self.word_letter_counts[ index ] )\\n        return result\\n\\n    def scoreWord( self, word, score ):\\n        return sum( map( lambda letter: score[ ord( letter ) - ord( \\'a\\' ) ], word ) )\\n\\n    def enough_letters( self, letter_counter, word_letter_count ):\\n        for letter in word_letter_count:\\n            if letter_counter[ letter ] < word_letter_count[ letter ]:\\n                return False\\n        return True\\n\\n    def subtract_count( self, letter_counter, word_letter_count ):\\n        letter_counter.subtract( word_letter_count )\\n\\n    def add_count( self, letter_counter, word_letter_count ):\\n        letter_counter.update( word_letter_count )\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```words```\n```words```\n```letters```\n```Counter```\n```words```\n```scoreWord```\n```Counter```\n```letters```\n```words```\n```words```\n```Counter```\n```letters```\n```is_enough```\n```letters```\n```Counter```\n```update```\n```subtract```\n```map```\n```letters```\n```words```\n```words```\n```words```\n```Counters```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        self.words = words\\n        self.word_scores = list( map( lambda word: self.scoreWord( word, score ), words ) )\\n        self.word_letter_counts = list( map( Counter, words ) )\\n        maxScore = self.maxScoreRec( 0, Counter( letters ) )    # First arg. is index into \"words\"\\n        return maxScore\\n\\n    def maxScoreRec( self, index, letter_counter ):\\n        result = 0\\n        if index == len( self.words ):\\n            result = 0\\n        else:\\n            # Try skipping \"words[index]\"\\n            result = max( result, self.maxScoreRec( index + 1, letter_counter ) )\\n            # Try using \"words[index]\"\\n            if self.enough_letters( letter_counter, self.word_letter_counts[ index ] ):\\n                self.subtract_count( letter_counter, self.word_letter_counts[ index ] )\\n                result = max( result, \\n                              self.word_scores[ index ] +\\n                              self.maxScoreRec( index + 1, letter_counter ) )\\n                self.add_count( letter_counter, self.word_letter_counts[ index ] )\\n        return result\\n\\n    def scoreWord( self, word, score ):\\n        return sum( map( lambda letter: score[ ord( letter ) - ord( \\'a\\' ) ], word ) )\\n\\n    def enough_letters( self, letter_counter, word_letter_count ):\\n        for letter in word_letter_count:\\n            if letter_counter[ letter ] < word_letter_count[ letter ]:\\n                return False\\n        return True\\n\\n    def subtract_count( self, letter_counter, word_letter_count ):\\n        letter_counter.subtract( word_letter_count )\\n\\n    def add_count( self, letter_counter, word_letter_count ):\\n        letter_counter.update( word_letter_count )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513368,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int possible(string &s, unordered_map<char, int>& map, vector<int>& score ){\\n        int sc=0;\\n        for(char c: s){\\n            if(map.count(c)){\\n                if(map[c]>0){\\n                    sc+=score[c-\\'a\\'];\\n                    map[c]--;\\n                }else{\\n                    return 0;\\n                }\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        return sc;\\n    }\\n    void helper(int i, vector<string>& words, vector<int>& score, unordered_map<char, int> map, int val){\\n        if(i==words.size()){\\n            ans=max(ans, val);\\n            return;\\n        }\\n        helper(i+1, words, score, map, val);\\n        \\n        int s=possible(words[i], map, score);\\n        if(s>0){\\n            helper(i+1, words, score, map, val+s);\\n        }\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        unordered_map<char, int> map;\\n        for(char c: letters){\\n            map[c]++;\\n        }\\n        helper(0,words,score,map, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int possible(string &s, unordered_map<char, int>& map, vector<int>& score ){\\n        int sc=0;\\n        for(char c: s){\\n            if(map.count(c)){\\n                if(map[c]>0){\\n                    sc+=score[c-\\'a\\'];\\n                    map[c]--;\\n                }else{\\n                    return 0;\\n                }\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        return sc;\\n    }\\n    void helper(int i, vector<string>& words, vector<int>& score, unordered_map<char, int> map, int val){\\n        if(i==words.size()){\\n            ans=max(ans, val);\\n            return;\\n        }\\n        helper(i+1, words, score, map, val);\\n        \\n        int s=possible(words[i], map, score);\\n        if(s>0){\\n            helper(i+1, words, score, map, val+s);\\n        }\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        unordered_map<char, int> map;\\n        for(char c: letters){\\n            map[c]++;\\n        }\\n        helper(0,words,score,map, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978110,
                "title": "backtrack-code-and-9-liner-code-explained",
                "content": "# Explanation:\\n```\\n/*\\n\\nwe will check for all words (from 0 to n-1)\\nfor every Index we have 2 choises\\n    --can we consider our current index\\n            --> if we consider to choose current index we need\\n                to update letters and check for next index\\n    --should we skip and check for next\\n            --> if we consider to skip letters will not get\\n                updated simply check for next\\n\\n*/\\n```\\n\\n# Backtrack Code\\n```\\n//    dic    - A dictionary/list that will keep current count or letters\\n//    total  - keep record to MAX\\n//    ind    - index\\n//    mydict - count of letter at the beginning\\n\\ndef maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n    self.maxx = 0\\n    def f(ind,dic,total):\\n        if ind == len(words):return\\n        for i in range(ind,len(words)):\\n            state = True\\n            res = 0\\n            // check if we can create the word\\n            for each in words[i]:\\n                if each in dic:\\n                    dic[each] -= 1\\n                    res += score[ord(each)-97]\\n                    if dic[each]<0:\\n                        state = False\\n                else:\\n                    state = False\\n            // if state = True we can create and check for next\\n            if state:\\n                self.maxx = max(self.maxx,total+res)\\n                // check for next index i.e currentInd = i so i+1\\n                f(i+1,dic,total+res)\\n            // if we dont pick we need back our deleted letters\\n            // adding in the deleted letters\\n            for each in words[i]:\\n                if each in dic:\\n                    dic[each] += 1\\n    mydic = {}\\n    for each in letters:\\n        if each in mydic:\\n            mydic[each] += 1\\n        else:\\n            mydic[each] = 1\\n    f(0,mydic,0)\\n    return self.maxx\\n```\\n# Simplyfing Code\\n```\\n\\n# Rather than creating dictionary we will update the letter itself\\n# Convert letters from LIST->STRING\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        def f(ind,letterS):\\n            if ind == len(words):return 0\\n            // we will create a copy so we dont need to add again\\n            copy = letterS\\n            res = 0\\n            for each in words[ind]:\\n                // if current letter is not in copy\\n                // we cannot create this word so skip\\n                if each not in copy:return f(ind+1,letterS)\\n                res += score[ord(each)-97]\\n                copy = copy.replace(each,\\'\\',1)\\n            // if we reach this point\\n            // then we have 2 choice to pick or notPick\\n            //              notPick        pick\\n            //                \\u25BC              \\u25BC\\n            return max(f(ind+1,letterS),res + f(ind+1,copy))\\n        return f(0,\\'\\'.join(letters))\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\nwe will check for all words (from 0 to n-1)\\nfor every Index we have 2 choises\\n    --can we consider our current index\\n            --> if we consider to choose current index we need\\n                to update letters and check for next index\\n    --should we skip and check for next\\n            --> if we consider to skip letters will not get\\n                updated simply check for next\\n\\n*/\\n```\n```\\n//    dic    - A dictionary/list that will keep current count or letters\\n//    total  - keep record to MAX\\n//    ind    - index\\n//    mydict - count of letter at the beginning\\n\\ndef maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n    self.maxx = 0\\n    def f(ind,dic,total):\\n        if ind == len(words):return\\n        for i in range(ind,len(words)):\\n            state = True\\n            res = 0\\n            // check if we can create the word\\n            for each in words[i]:\\n                if each in dic:\\n                    dic[each] -= 1\\n                    res += score[ord(each)-97]\\n                    if dic[each]<0:\\n                        state = False\\n                else:\\n                    state = False\\n            // if state = True we can create and check for next\\n            if state:\\n                self.maxx = max(self.maxx,total+res)\\n                // check for next index i.e currentInd = i so i+1\\n                f(i+1,dic,total+res)\\n            // if we dont pick we need back our deleted letters\\n            // adding in the deleted letters\\n            for each in words[i]:\\n                if each in dic:\\n                    dic[each] += 1\\n    mydic = {}\\n    for each in letters:\\n        if each in mydic:\\n            mydic[each] += 1\\n        else:\\n            mydic[each] = 1\\n    f(0,mydic,0)\\n    return self.maxx\\n```\n```\\n\\n# Rather than creating dictionary we will update the letter itself\\n# Convert letters from LIST->STRING\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        def f(ind,letterS):\\n            if ind == len(words):return 0\\n            // we will create a copy so we dont need to add again\\n            copy = letterS\\n            res = 0\\n            for each in words[ind]:\\n                // if current letter is not in copy\\n                // we cannot create this word so skip\\n                if each not in copy:return f(ind+1,letterS)\\n                res += score[ord(each)-97]\\n                copy = copy.replace(each,\\'\\',1)\\n            // if we reach this point\\n            // then we have 2 choice to pick or notPick\\n            //              notPick        pick\\n            //                \\u25BC              \\u25BC\\n            return max(f(ind+1,letterS),res + f(ind+1,copy))\\n        return f(0,\\'\\'.join(letters))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720114,
                "title": "c-dp-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, unordered_map<string, int>>dp;\\n    int helper(vector<string>& words, int curr, vector<char> letters, vector<int>& score, string memory){\\n        if(curr<0)return 0;\\n        if(dp[curr][memory]!=0)return dp[curr][memory];\\n        unordered_map<char, int>curr_dict, curr_word, remaining;\\n        vector<char>lettersr;\\n        for(int i=0;i<letters.size();i++){\\n            curr_dict[letters[i]]++;\\n        }\\n        for(int i=0;i<words[curr].size();i++){\\n            curr_word[words[curr][i]]++;\\n        }\\n        remaining=curr_dict;\\n        int flag=1;\\n        for(auto temp:curr_word){\\n            if(curr_dict[temp.first]<temp.second){\\n                flag=0;\\n                break;\\n            }\\n            remaining[temp.first]-=temp.second;\\n        }\\n        string a=\"\", b=\"\";\\n        for(int i=0;i<letters.size();i++){\\n            a+=letters[i];\\n        }\\n        for(int i=0;i<remaining.size();i++){\\n            b+=remaining[i];\\n        }\\n        sort(a.begin(), a.end());\\n        sort(b.begin(), b.end());\\n        if(flag==0){\\n            return helper(words, curr-1, letters, score, a);\\n        }\\n        int curr_score=0;\\n        for(int i=0;i<words[curr].size();i++){\\n            curr_score+=score[words[curr][i]-\\'a\\'];\\n        }\\n        for(auto temp:remaining){\\n            for(int i=0;i<temp.second;i++)\\n                lettersr.emplace_back(temp.first);\\n        }\\n        int ans2=helper(words, curr-1, lettersr, score, b)+curr_score;        \\n        return max(helper(words, curr-1, letters, score, a), ans2);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        string a=\"\";\\n        for(int i=0;i<letters.size();i++){\\n            a+=letters[i];\\n        }\\n        sort(a.begin(), a.end());\\n        return helper(words, words.size()-1, letters, score,a);        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, unordered_map<string, int>>dp;\\n    int helper(vector<string>& words, int curr, vector<char> letters, vector<int>& score, string memory){\\n        if(curr<0)return 0;\\n        if(dp[curr][memory]!=0)return dp[curr][memory];\\n        unordered_map<char, int>curr_dict, curr_word, remaining;\\n        vector<char>lettersr;\\n        for(int i=0;i<letters.size();i++){\\n            curr_dict[letters[i]]++;\\n        }\\n        for(int i=0;i<words[curr].size();i++){\\n            curr_word[words[curr][i]]++;\\n        }\\n        remaining=curr_dict;\\n        int flag=1;\\n        for(auto temp:curr_word){\\n            if(curr_dict[temp.first]<temp.second){\\n                flag=0;\\n                break;\\n            }\\n            remaining[temp.first]-=temp.second;\\n        }\\n        string a=\"\", b=\"\";\\n        for(int i=0;i<letters.size();i++){\\n            a+=letters[i];\\n        }\\n        for(int i=0;i<remaining.size();i++){\\n            b+=remaining[i];\\n        }\\n        sort(a.begin(), a.end());\\n        sort(b.begin(), b.end());\\n        if(flag==0){\\n            return helper(words, curr-1, letters, score, a);\\n        }\\n        int curr_score=0;\\n        for(int i=0;i<words[curr].size();i++){\\n            curr_score+=score[words[curr][i]-\\'a\\'];\\n        }\\n        for(auto temp:remaining){\\n            for(int i=0;i<temp.second;i++)\\n                lettersr.emplace_back(temp.first);\\n        }\\n        int ans2=helper(words, curr-1, lettersr, score, b)+curr_score;        \\n        return max(helper(words, curr-1, letters, score, a), ans2);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        string a=\"\";\\n        for(int i=0;i<letters.size();i++){\\n            a+=letters[i];\\n        }\\n        sort(a.begin(), a.end());\\n        return helper(words, words.size()-1, letters, score,a);        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562770,
                "title": "java-solution-brute-force-approach-explained",
                "content": "\\n```\\nclass Solution {\\n    \\n    static List<List<Pair>> combinations;\\n    static List<Pair> allPairs;\\n    \\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int[] points = new int[words.length];\\n        //scores of each word\\n        List<Pair> list = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n            for (int j = 0; j < words[i].length(); j++) {\\n                int index = words[i].charAt(j) - 97;\\n                points[i] += score[index];\\n            }\\n            Pair pair = new Pair(words[i], points[i]);\\n            list.add(pair);\\n        }\\n        allPairs = list;\\n        combinations = new ArrayList<>();\\n\\t\\t//using the loop below to find all combinations of words and different size of these combinations\\n        for (int i = 0; i < list.size(); i++) {\\n            findCombination(i, new ArrayList<>());\\n        }\\n\\n        int[] finalScores = new int[combinations.size()];\\n        for (int k = 0; k < combinations.size(); k++) {\\n            String lettersString = new String(letters);\\n            String lettersCheck = new String(letters);\\n            List<Pair> listTemp = combinations.get(k);\\n            int scoreFinal = 0;\\n\\t\\t\\t//finding score of each combination\\n            for (int i = 0; i < listTemp.size(); i++) {\\n                Pair pair = listTemp.get(i);\\n                boolean fullyContains = true;\\n                lettersCheck = new String(lettersString);\\n                for (int j = 0; j < pair.word.length(); j++) {\\n                    if (!lettersCheck.contains(pair.word.charAt(j) + \"\")) {\\n                        fullyContains = false;\\n                        break;\\n                    }\\n                    lettersCheck = lettersCheck.replaceFirst(pair.word.charAt(j) + \"\", \"\");\\n                }\\n                if (!fullyContains) {\\n                    continue;\\n                }\\n                for (int j = 0; j < pair.word.length(); j++) {\\n                    lettersString = lettersString.replaceFirst(pair.word.charAt(j) + \"\", \"\");\\n                }\\n                scoreFinal += pair.score;\\n            }\\n            finalScores[k] = scoreFinal;\\n        }\\n\\n        int max = 0;\\n\\t\\t//finding max score out of all scores of combinations\\n        for (int i = 0; i < finalScores.length; i++) {\\n            if (max < finalScores[i]) {\\n                max = finalScores[i];\\n            }\\n        }\\n        return max;\\n    }\\n    //use this method to find different combinations of words starting from idxStart\\n    private void findCombination(int idxStart, List<Pair> list) {\\n        if (idxStart >= allPairs.size()) {\\n            combinations.add(new ArrayList<>(list));\\n            return;\\n        }\\n        list.add(allPairs.get(idxStart));\\n        for (int i = idxStart + 1; i <= allPairs.size(); i++) {\\n            findCombination(i, list);\\n        }\\n        list.remove(list.size() - 1);\\n    }\\n    \\n    class Pair {\\n        String word;\\n        int score;\\n\\n        public Pair(String word, int score) {\\n            this.word = word;\\n            this.score = score;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    static List<List<Pair>> combinations;\\n    static List<Pair> allPairs;\\n    \\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int[] points = new int[words.length];\\n        //scores of each word\\n        List<Pair> list = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n            for (int j = 0; j < words[i].length(); j++) {\\n                int index = words[i].charAt(j) - 97;\\n                points[i] += score[index];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2518242,
                "title": "bitmask-iterative-method",
                "content": "According to the constraints of this question we can solve this by recursive method considering all combinations ..for this thing which is considering all combinations i have used bitmask iterative method 1001 will mean we are taking words[0] and words[3] in our final answer ..the time complex of this sol will be close to 2^15 at max n is 15 which easily passes \\n```\\nclass Solution {\\npublic:\\n    \\n    bool isvalid(int maxfreq[26],vector<string>&words,int i,int temp[26]){\\n        int cnt=0;\\n        \\n        while(i!=0){\\n            if(i&1){\\n                string s=words[cnt];\\n                for(int j=0;j<s.length();j++){\\n                    temp[s[j]-\\'a\\']++;\\n                }\\n                \\n            }\\n            i=i>>1;\\n            cnt++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(maxfreq[i]<temp[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int calc(vector<int>&score,int temp[26]){\\n        int ans=0;\\n        for(int i=0;i<26;i++){\\n            int no=temp[i];\\n            ans+=(no*score[i]);\\n        }\\n        return ans;\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& let, vector<int>& score) {\\n        int maxfreq[26]={0};\\n        for(int i=0;i<let.size();i++){\\n            maxfreq[let[i]-\\'a\\']++;\\n        }\\n        int n=words.size();\\n        n=pow(2,n)-1;\\n        int maxno=0;\\n        for(int i=0;i<=n;i++){\\n            int temp[26]={0};\\n            if(isvalid(maxfreq,words,i,temp)==false){\\n                continue;\\n            }\\n            \\n            maxno=max(maxno,calc(score,temp));\\n        }\\n        return maxno;\\n    }\\n};\\n```\\nlet me know if any part of the code is not clear \\nupvote if helpful :)\\n",
                "solutionTags": [
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isvalid(int maxfreq[26],vector<string>&words,int i,int temp[26]){\\n        int cnt=0;\\n        \\n        while(i!=0){\\n            if(i&1){\\n                string s=words[cnt];\\n                for(int j=0;j<s.length();j++){\\n                    temp[s[j]-\\'a\\']++;\\n                }\\n                \\n            }\\n            i=i>>1;\\n            cnt++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(maxfreq[i]<temp[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int calc(vector<int>&score,int temp[26]){\\n        int ans=0;\\n        for(int i=0;i<26;i++){\\n            int no=temp[i];\\n            ans+=(no*score[i]);\\n        }\\n        return ans;\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& let, vector<int>& score) {\\n        int maxfreq[26]={0};\\n        for(int i=0;i<let.size();i++){\\n            maxfreq[let[i]-\\'a\\']++;\\n        }\\n        int n=words.size();\\n        n=pow(2,n)-1;\\n        int maxno=0;\\n        for(int i=0;i<=n;i++){\\n            int temp[26]={0};\\n            if(isvalid(maxfreq,words,i,temp)==false){\\n                continue;\\n            }\\n            \\n            maxno=max(maxno,calc(score,temp));\\n        }\\n        return maxno;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344542,
                "title": "c-backtracking-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int backtrack(vector<string>& words, vector<int>& ch, vector<int>& score, int ind){\\n        if(ind>=words.size()){ return 0; }\\n        int gainIfSkipped=backtrack(words,ch,score,ind+1);  // If the word is not included in result\\n        int gain=0, wordsFormed=1;   // Assumming the word has sufficient letters left\\n        vector<int> tempCh(begin(ch), end(ch));  // Temporary count of letters (some of them will be used for making the current word.\\n        for(auto i:words[ind]){\\n            if(--tempCh[i-\\'a\\']<0){ wordsFormed=0; }   // If letters are not enough, current word can\\'t be formed\\n            gain+=score[i-\\'a\\'];   // Score will be added to current gain \\n        }\\n\\t\\t// Now we the maximum value between the gain if current word was skipped and the gain if current word is considered  \\n        return max(gainIfSkipped, wordsFormed ?  gain + backtrack(words, tempCh, score, ind + 1) : 0);\\n    }\\n\\t\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> ch(26);\\n        for(auto i:letters){ ++ch[i-\\'a\\']; }\\n        return backtrack(words,ch,score,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int backtrack(vector<string>& words, vector<int>& ch, vector<int>& score, int ind){\\n        if(ind>=words.size()){ return 0; }\\n        int gainIfSkipped=backtrack(words,ch,score,ind+1);  // If the word is not included in result\\n        int gain=0, wordsFormed=1;   // Assumming the word has sufficient letters left\\n        vector<int> tempCh(begin(ch), end(ch));  // Temporary count of letters (some of them will be used for making the current word.\\n        for(auto i:words[ind]){\\n            if(--tempCh[i-\\'a\\']<0){ wordsFormed=0; }   // If letters are not enough, current word can\\'t be formed\\n            gain+=score[i-\\'a\\'];   // Score will be added to current gain \\n        }\\n\\t\\t// Now we the maximum value between the gain if current word was skipped and the gain if current word is considered  \\n        return max(gainIfSkipped, wordsFormed ?  gain + backtrack(words, tempCh, score, ind + 1) : 0);\\n    }\\n\\t\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> ch(26);\\n        for(auto i:letters){ ++ch[i-\\'a\\']; }\\n        return backtrack(words,ch,score,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342487,
                "title": "c-knapsack-inclusion-exclusion-principle-recursion",
                "content": "\\tclass Solution {   \\n\\tpublic:\\n\\n\\t\\tint MaximumScore(int i , vector<string>& words , vector<int>& char_score , vector<int> char_freq){\\n\\t\\t\\tif(i == words.size()){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint excluding  = MaximumScore(i + 1 , words , char_score , char_freq);\\n\\n\\t\\t\\tint score = 0;\\n\\t\\t\\tfor(auto it : words[i]){\\n\\t\\t\\t\\tif(char_freq[it - \\'a\\'] > 0){\\n\\t\\t\\t\\t\\tscore += char_score[it - \\'a\\'];\\n\\t\\t\\t\\t\\tchar_freq[it - \\'a\\']--;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tscore = 0;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint including = MaximumScore(i + 1 , words , char_score , char_freq) + score; \\n\\t\\t\\treturn max(including , excluding);\\n\\t\\t}\\n\\n\\t\\tint maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n\\n\\t\\t\\t vector<int> char_score(26) , char_freq(26);\\n\\n\\t\\t\\t for(auto i : letters){\\n\\t\\t\\t\\t char_score[i - \\'a\\'] = score[i - \\'a\\'];\\n\\t\\t\\t\\t char_freq[i - \\'a\\']++;\\n\\t\\t\\t }\\n\\n\\t\\t\\t return MaximumScore(0 , words ,  char_score ,  char_freq);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {   \\n\\tpublic:\\n\\n\\t\\tint MaximumScore(int i , vector<string>& words , vector<int>& char_score , vector<int> char_freq){\\n\\t\\t\\tif(i == words.size()){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2323719,
                "title": "java-solution-with-comment",
                "content": "```\\n public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n            \\n        int[] lettersCount = new int[26];\\n        for(char ch : letters){\\n            lettersCount[ch-\\'a\\']++;\\n        }\\n        return maxScoreWordsHelper(words,lettersCount, score,0 );\\n    }\\n    \\n    private int maxScoreWordsHelper(String[] words, int[] lettersCount,int[] score, int idx){\\n            \\n            if(idx == words.length){\\n                return 0;\\n            }\\n        \\n            // Not including the word\\n            int noWordScore = 0 + maxScoreWordsHelper(words, lettersCount, score, idx+1);\\n        \\n            // Score on including the word\\n        \\n            String word = words[idx];\\n            int wordScore = 0;\\n            boolean validFlag = true;\\n            //Calculating score and check if the word is valid\\n        \\n            for(char ch : word.toCharArray()){\\n                \\n                \\n                if(lettersCount[ch-\\'a\\'] == 0){\\n                    validFlag = false;\\n                }\\n                lettersCount[ch-\\'a\\']--;\\n                wordScore = wordScore + score[ch-\\'a\\'];\\n            }\\n            int addingWordScore = 0;\\n            \\n            // Considering the word only if it\\'s valid word, else skip\\n            if(validFlag){\\n               addingWordScore =  wordScore + maxScoreWordsHelper(words, lettersCount, score, idx+1);\\n            }\\n        \\n             for(char ch : word.toCharArray()){\\n                lettersCount[ch-\\'a\\']++;\\n            }\\n                \\n            return Math.max(noWordScore, addingWordScore);\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n            \\n        int[] lettersCount = new int[26];\\n        for(char ch : letters){\\n            lettersCount[ch-\\'a\\']++;\\n        }\\n        return maxScoreWordsHelper(words,lettersCount, score,0 );\\n    }\\n    \\n    private int maxScoreWordsHelper(String[] words, int[] lettersCount,int[] score, int idx){\\n            \\n            if(idx == words.length){\\n                return 0;\\n            }\\n        \\n            // Not including the word\\n            int noWordScore = 0 + maxScoreWordsHelper(words, lettersCount, score, idx+1);\\n        \\n            // Score on including the word\\n        \\n            String word = words[idx];\\n            int wordScore = 0;\\n            boolean validFlag = true;\\n            //Calculating score and check if the word is valid\\n        \\n            for(char ch : word.toCharArray()){\\n                \\n                \\n                if(lettersCount[ch-\\'a\\'] == 0){\\n                    validFlag = false;\\n                }\\n                lettersCount[ch-\\'a\\']--;\\n                wordScore = wordScore + score[ch-\\'a\\'];\\n            }\\n            int addingWordScore = 0;\\n            \\n            // Considering the word only if it\\'s valid word, else skip\\n            if(validFlag){\\n               addingWordScore =  wordScore + maxScoreWordsHelper(words, lettersCount, score, idx+1);\\n            }\\n        \\n             for(char ch : word.toCharArray()){\\n                lettersCount[ch-\\'a\\']++;\\n            }\\n                \\n            return Math.max(noWordScore, addingWordScore);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2303351,
                "title": "75-tc-and-78-sc-easy-python-solution",
                "content": "```\\ndef maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n\\tdef solve(i, d):\\n\\t\\tif(i == len(words)): return 0\\n\\t\\tt = solve(i+1, d)\\n\\t\\tcurr_count = Counter(words[i])\\n\\t\\tfor c in curr_count:\\n\\t\\t\\tif(c not in d or curr_count[c] > d[c]):\\n\\t\\t\\t\\treturn t\\n\\t\\tnew_d = d.copy()\\n\\t\\ty = 0\\n\\t\\tfor c in curr_count:\\n\\t\\t\\tnew_d[c] -= curr_count[c]\\n\\t\\t\\ty += curr_count[c] * score[ord(c)-97]\\n\\t\\tt = max(t, solve(i+1, new_d) + y)\\n\\t\\treturn t\\n\\n\\tdic = Counter(letters)   \\n\\treturn solve(0, dic)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\ndef maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n\\tdef solve(i, d):\\n\\t\\tif(i == len(words)): return 0\\n\\t\\tt = solve(i+1, d)\\n\\t\\tcurr_count = Counter(words[i])\\n\\t\\tfor c in curr_count:\\n\\t\\t\\tif(c not in d or curr_count[c] > d[c]):\\n\\t\\t\\t\\treturn t\\n\\t\\tnew_d = d.copy()\\n\\t\\ty = 0\\n\\t\\tfor c in curr_count:\\n\\t\\t\\tnew_d[c] -= curr_count[c]\\n\\t\\t\\ty += curr_count[c] * score[ord(c)-97]\\n\\t\\tt = max(t, solve(i+1, new_d) + y)\\n\\t\\treturn t\\n\\n\\tdic = Counter(letters)   \\n\\treturn solve(0, dic)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2291339,
                "title": "detailed-explanation-using-bitmask-c-bitmask",
                "content": "class Solution {\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        \\n        int n = words.size();\\n        int m = letters.size();\\n        vector<int> f(26);  // frequency array for keeping the count of letters\\n        \\n        for( auto c : letters) // for(int i=0;i<letters.size();i++) cin acting as letters[i]\\n            f[c-\\'a\\']++; // increasing the frequency of letter c\\n        \\n        int ans = 0;\\n        // iterate over all possible combinations of words we can take using bitmask (subsets)\\n        for(int mask=0; mask <(1<<n); mask++) // 1<<n = 2^n\\n        {\\n            vector<int> freq = f;\\n            int temp = 0; // total score of current subset \\n            // if mask = 5 it means 5 = 101 in binary then subset contains words[0] and words[2]\\n            bool can_form = true;\\n            for(int b = 0; b<n; b++)\\n            {\\n                if((1<<b) & mask)\\n                {\\n                    for(char c : words[b])\\n                    {\\n                        if(freq[c-\\'a\\'] == 0)\\n                        {\\n                            can_form = false; // if frequency is not sufficients to make that word\\n                            break;            // make can_form = 0\\n                        }\\n                        freq[c-\\'a\\']--;\\n                        temp += score[c-\\'a\\']; // temp score if it is possible to maake word from the particular mask\\n                    }\\n                }\\n                if(!form) // if cannot be made break;\\n                    break;\\n            }\\n            // if current bitmask is possible update the answer\\n            if(can_form)\\n                ans = max(ans, temp);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        \\n        int n = words.size();\\n        int m = letters.size();\\n        vector<int> f(26);  // frequency array for keeping the count of letters\\n        \\n        for( auto c : letters) // for(int i=0;i<letters.size();i++) cin acting as letters[i]\\n            f[c-\\'a\\']++; // increasing the frequency of letter c\\n        \\n        int ans = 0;\\n        // iterate over all possible combinations of words we can take using bitmask (subsets)\\n        for(int mask=0; mask <(1<<n); mask++) // 1<<n = 2^n\\n        {\\n            vector<int> freq = f;\\n            int temp = 0; // total score of current subset \\n            // if mask = 5 it means 5 = 101 in binary then subset contains words[0] and words[2]\\n            bool can_form = true;\\n            for(int b = 0; b<n; b++)\\n            {\\n                if((1<<b) & mask)\\n                {\\n                    for(char c : words[b])\\n                    {\\n                        if(freq[c-\\'a\\'] == 0)\\n                        {\\n                            can_form = false; // if frequency is not sufficients to make that word\\n                            break;            // make can_form = 0\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 2275757,
                "title": "maximum-score-words-formed-by-letters",
                "content": "```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int [] frequency = new int[26];\\n        for(int i = 0;i<letters.length;i++){\\n            frequency[letters[i]-\\'a\\']++;\\n        }\\n        int result = backtrack(words,frequency,score,0);\\n        return result;\\n        \\n        \\n    }\\n    public static int backtrack(String[] words, int[] frr, int[] score,int idx){\\n        if(idx == words.length){\\n            return 0;\\n        }\\n        int scoreOfaWord =0;\\n        int no = backtrack(words,frr,score,idx+1);\\n        boolean isValid = true;\\n        for(int i =0;i<words[idx].length();i++){\\n            char ch = words[idx].charAt(i);\\n            if(frr[ch-\\'a\\']<=0){\\n                isValid = false;\\n            }\\n            frr[ch-\\'a\\']--;\\n            scoreOfaWord += score[ch-\\'a\\'];\\n            \\n        }\\n        int yes =0;\\n        if(isValid){\\n            yes = scoreOfaWord + backtrack(words,frr,score,idx+1);\\n        }\\n        for(int i =0;i<words[idx].length();i++){\\n            frr[words[idx].charAt(i)-\\'a\\']++;\\n        }\\n        return Math.max(no,yes);\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int [] frequency = new int[26];\\n        for(int i = 0;i<letters.length;i++){\\n            frequency[letters[i]-\\'a\\']++;\\n        }\\n        int result = backtrack(words,frequency,score,0);\\n        return result;\\n        \\n        \\n    }\\n    public static int backtrack(String[] words, int[] frr, int[] score,int idx){\\n        if(idx == words.length){\\n            return 0;\\n        }\\n        int scoreOfaWord =0;\\n        int no = backtrack(words,frr,score,idx+1);\\n        boolean isValid = true;\\n        for(int i =0;i<words[idx].length();i++){\\n            char ch = words[idx].charAt(i);\\n            if(frr[ch-\\'a\\']<=0){\\n                isValid = false;\\n            }\\n            frr[ch-\\'a\\']--;\\n            scoreOfaWord += score[ch-\\'a\\'];\\n            \\n        }\\n        int yes =0;\\n        if(isValid){\\n            yes = scoreOfaWord + backtrack(words,frr,score,idx+1);\\n        }\\n        for(int i =0;i<words[idx].length();i++){\\n            frr[words[idx].charAt(i)-\\'a\\']++;\\n        }\\n        return Math.max(no,yes);\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178199,
                "title": "c-clean-and-concise-backtrack",
                "content": "```\\n// See What I did Basically is , let me explain you in points.... \\n// 1. I have Precomputed all the score values of all the words and stored in my val vector so that i don\\'t need to do that again again.\\n// 2. I have also marked frequency of all the characters in map seen1 so that if in any case my value of that particular letter exceed the limit value then i Should Return and Backtrack.\\n// 3. Base Case would be all my string which are valid there is no size criteia nothing so i should all the string\\n// also i need to return when ind==n that after computing the last index value.\\n// 4. In Backtracking part i m storing my value in ans variable the value for corresponding word and in backtracking i m subtracting that part of value from it as well popping it out from vector strings\\n// 5. At last i m storing max. possible value in max1 and finally returing it. \\nclass Solution {\\npublic:\\n    int max1 = 0;\\n    vector<int>val;\\n    map<char,int>seen1;\\n    void solve(int ind , vector<string>&vec , int n , vector<string>& words, vector<char>& letters, vector<int>& score , int ans)\\n    {\\n        if(ind<=n)\\n        {\\n            map<char,int>seen;\\n \\n            for(int i = 0 ; i < vec.size() ; i++)\\n            {\\n                for(int j = 0 ; j < vec[i].size() ; j++)\\n                {\\n                    seen[vec[i][j]]++;\\n                    if(seen[vec[i][j]] > seen1[vec[i][j]])\\n                    {\\n                        return;\\n                    }\\n                }\\n            }\\n            max1 = max(max1 , ans);\\n            if(ind==n)\\n            {\\n                return;\\n            }\\n        }\\n        for(int i = ind ; i < n ; i++)\\n        {\\n            ans+=val[i];\\n            vec.push_back(words[i]);\\n            solve(i+1,vec,n,words,letters,score,ans);\\n            ans-=val[i];\\n            vec.pop_back();\\n        }\\n        return;\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n       vector<string>vec;\\n        int n = words.size();\\n        for(int i = 0 ; i < words.size() ; i++)\\n        {\\n            int sum = 0;\\n            for(int j = 0 ; j < words[i].size() ; j++)\\n            {\\n                int y = words[i][j] - 97;\\n                sum+=score[y];\\n            }\\n            val.push_back(sum);\\n        }\\n        for(int i = 0 ; i < letters.size() ; i++)\\n        {\\n            seen1[letters[i]]++;\\n        }\\n        int ans = 0;\\n        solve(0,vec,n,words,letters,score,ans);\\n        return max1;\\n    }\\n};\\n```\\n**Please Upvote the Solution.. And your any query plz Comment Down i will be happy to respond it well.\\uD83D\\uDE0A**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n// See What I did Basically is , let me explain you in points.... \\n// 1. I have Precomputed all the score values of all the words and stored in my val vector so that i don\\'t need to do that again again.\\n// 2. I have also marked frequency of all the characters in map seen1 so that if in any case my value of that particular letter exceed the limit value then i Should Return and Backtrack.\\n// 3. Base Case would be all my string which are valid there is no size criteia nothing so i should all the string\\n// also i need to return when ind==n that after computing the last index value.\\n// 4. In Backtracking part i m storing my value in ans variable the value for corresponding word and in backtracking i m subtracting that part of value from it as well popping it out from vector strings\\n// 5. At last i m storing max. possible value in max1 and finally returing it. \\nclass Solution {\\npublic:\\n    int max1 = 0;\\n    vector<int>val;\\n    map<char,int>seen1;\\n    void solve(int ind , vector<string>&vec , int n , vector<string>& words, vector<char>& letters, vector<int>& score , int ans)\\n    {\\n        if(ind<=n)\\n        {\\n            map<char,int>seen;\\n \\n            for(int i = 0 ; i < vec.size() ; i++)\\n            {\\n                for(int j = 0 ; j < vec[i].size() ; j++)\\n                {\\n                    seen[vec[i][j]]++;\\n                    if(seen[vec[i][j]] > seen1[vec[i][j]])\\n                    {\\n                        return;\\n                    }\\n                }\\n            }\\n            max1 = max(max1 , ans);\\n            if(ind==n)\\n            {\\n                return;\\n            }\\n        }\\n        for(int i = ind ; i < n ; i++)\\n        {\\n            ans+=val[i];\\n            vec.push_back(words[i]);\\n            solve(i+1,vec,n,words,letters,score,ans);\\n            ans-=val[i];\\n            vec.pop_back();\\n        }\\n        return;\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n       vector<string>vec;\\n        int n = words.size();\\n        for(int i = 0 ; i < words.size() ; i++)\\n        {\\n            int sum = 0;\\n            for(int j = 0 ; j < words[i].size() ; j++)\\n            {\\n                int y = words[i][j] - 97;\\n                sum+=score[y];\\n            }\\n            val.push_back(sum);\\n        }\\n        for(int i = 0 ; i < letters.size() ; i++)\\n        {\\n            seen1[letters[i]]++;\\n        }\\n        int ans = 0;\\n        solve(0,vec,n,words,letters,score,ans);\\n        return max1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097092,
                "title": "c-recursive-solution-with-explanation",
                "content": "class Solution {\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n     \\n\\t\\t// creating a frequency array to store frequency of every letter\\n        vector<int> freq(26, 0);\\n\\n        for(auto &i : letters)\\n            freq[i - \\'a\\']++;\\n        \\n        return maxScoreWords(words, score, freq, 0, 0);     \\n    }\\n    \\n    int maxScoreWords(vector<string> &words, vector<int> &score, vector<int> freq, int i, int tmp)\\n    {\\n\\t\\t// if array is finished simply return the score made till now\\n        if(i == words.size())\\n            return tmp;\\n        \\n\\t\\t// Recursive call to get the score if curr word is not included\\n        int ans = maxScoreWords(words, score, freq, i + 1, tmp);\\n        \\n\\t\\t// Checking if curr word can be included?\\n\\t\\t// if in any case frequency of any letter is 0 then we can\\'t include this word\\n        int tp = 0, n = words[i].size(), j;\\n        for(j = 0; j < n; j++)\\n        {\\n            if(!freq[words[i][j] - \\'a\\'])\\n                break;\\n            \\n            freq[words[i][j] - \\'a\\']--, tp += score[words[i][j] - \\'a\\'];\\n        }\\n     \\n\\t\\t // if j == n then it means the whole word is traversed and there was sufficient frequency of every letter to include this word\\n        if(j == n)\\n\\t\\t\\t// taking the maximum of previous ans without including the curr word and with including the curr word\\n            ans = max(maxScoreWords(words, score, freq, i + 1, tmp + tp), ans);\\n    \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n     \\n\\t\\t// creating a frequency array to store frequency of every letter\\n        vector<int> freq(26, 0);\\n\\n        for(auto &i : letters)\\n            freq[i - \\'a\\']++;\\n        \\n        return maxScoreWords(words, score, freq, 0, 0);     \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2031791,
                "title": "lucid-recursion-with-explained-analogy-to-classic-0-1-knapsack",
                "content": "Understand that this problem is simply a **twisted form of 0/1 Knapsack**. I\\'ve commented this code heavily so as to get a clear picture of every step as a beginner.\\nHope it helps :)\\nAlso, do **upvote** and comment incase you liked it and have some suggestions\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // This problem is fundamentally 0/1 Knapsack with a constraint that we can\\'t choose a word that can\\'t be \\'recovered\\' from our \\'dictionary\\'\\n    int maxScore(vector<string> words,map<char,int> &m,vector<int> score,int ind,int score_till_now)\\n    {\\n        if(ind==words.size())\\n            return score_till_now; // If we reach end of words array then return the score we\\'ve accumulated till now\\n        \\n        int c=0,i;\\n        map<char,int> dummy; // Create a dummy map that simply copies the key,value pair from our \\'current\\' map and then checks whether we actually have the luxury of choosing the current word we\\'re at?\\n        for(auto itr:m)\\n            dummy[itr.first]=itr.second;\\n        for(i=0;i<words[ind].size();i++)\\n        {\\n            char ch=words[ind][i];\\n            if(dummy[ch]<=0)\\n            {\\n                c=1;\\n                break;\\n            }\\n            dummy[ch]--;\\n        }\\n        if(c==1) // This indicates that we don\\'t have the luxury to \\'recover\\' letters from our \\'dictionary\\' and therefore move forward for the next word. Remember that this is analogous to not being able to select an item because it weight exists our current knapsack capacity in the classic 0/1 Knapsack\\n            return maxScore(words,m,score,ind+1,score_till_now);\\n        \\n//If we reach here, it indicates that we have the luxury to choose the current word.\\n        int dummy_score=score_till_now;\\n        for(auto itr:m)\\n            dummy[itr.first]=itr.second;\\n//Say we choose the current word, then our map would change accordingly and hence we created a dummy map to note down the changes\\n        for(i=0;i<words[ind].size();i++)\\n        {\\n            char ch=words[ind][i];\\n            dummy[ch]--;\\n            dummy_score+=score[ch-\\'a\\'];\\n        }\\n//This is analogous to exploring both the paths by choosing and not choosing the current bag and returning the maximum of the two results in 0/1 Knapsack\\nreturn max(maxScore(words,m,score,ind+1,score_till_now),maxScore(words,dummy,score,ind+1,dummy_score));\\n    }\\n    \\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        map<char,int> m;\\n        int i;\\n        for(i=0;i<letters.size();i++)\\n            m[letters[i]]++; // Create a map of available characters of our \"dictionary\"\\n        return maxScore(words,m,score,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // This problem is fundamentally 0/1 Knapsack with a constraint that we can\\'t choose a word that can\\'t be \\'recovered\\' from our \\'dictionary\\'\\n    int maxScore(vector<string> words,map<char,int> &m,vector<int> score,int ind,int score_till_now)\\n    {\\n        if(ind==words.size())\\n            return score_till_now; // If we reach end of words array then return the score we\\'ve accumulated till now\\n        \\n        int c=0,i;\\n        map<char,int> dummy; // Create a dummy map that simply copies the key,value pair from our \\'current\\' map and then checks whether we actually have the luxury of choosing the current word we\\'re at?\\n        for(auto itr:m)\\n            dummy[itr.first]=itr.second;\\n        for(i=0;i<words[ind].size();i++)\\n        {\\n            char ch=words[ind][i];\\n            if(dummy[ch]<=0)\\n            {\\n                c=1;\\n                break;\\n            }\\n            dummy[ch]--;\\n        }\\n        if(c==1) // This indicates that we don\\'t have the luxury to \\'recover\\' letters from our \\'dictionary\\' and therefore move forward for the next word. Remember that this is analogous to not being able to select an item because it weight exists our current knapsack capacity in the classic 0/1 Knapsack\\n            return maxScore(words,m,score,ind+1,score_till_now);\\n        \\n//If we reach here, it indicates that we have the luxury to choose the current word.\\n        int dummy_score=score_till_now;\\n        for(auto itr:m)\\n            dummy[itr.first]=itr.second;\\n//Say we choose the current word, then our map would change accordingly and hence we created a dummy map to note down the changes\\n        for(i=0;i<words[ind].size();i++)\\n        {\\n            char ch=words[ind][i];\\n            dummy[ch]--;\\n            dummy_score+=score[ch-\\'a\\'];\\n        }\\n//This is analogous to exploring both the paths by choosing and not choosing the current bag and returning the maximum of the two results in 0/1 Knapsack\\nreturn max(maxScore(words,m,score,ind+1,score_till_now),maxScore(words,dummy,score,ind+1,dummy_score));\\n    }\\n    \\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        map<char,int> m;\\n        int i;\\n        for(i=0;i<letters.size();i++)\\n            m[letters[i]]++; // Create a map of available characters of our \"dictionary\"\\n        return maxScore(words,m,score,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1872958,
                "title": "simple-solution-in-java-concise-and-elegant-backtracking",
                "content": "```\\nclass Solution {\\n    private int ans;\\n    private int[] score;\\n    \\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        // For each word, we will have two option, either to include it or not \\n        \\n        this.score = score;\\n        this.ans = 0;\\n        int[] count = new int[26];\\n        for(char c : letters){\\n            count[c-\\'a\\']++;\\n        }\\n        \\n        find(0, words, count, 0);\\n        return ans;\\n    }\\n    \\n    private void find(int index, String[] words, int[] count, int currScore){\\n        if(index == words.length){\\n            this.ans = Math.max(ans, currScore);\\n            return;\\n        }\\n        \\n        int[] newCount = includeCurrentPossibleOrNot(words[index], count);\\n        if(newCount.length != 0){ // Current word can be made from the count array \\n            find(index+1, words, newCount, currScore + findScore(words[index]));\\n        }\\n        \\n        find(index+1, words, count, currScore);\\n    }\\n    \\n    private int[] includeCurrentPossibleOrNot(String word, int[] count){\\n        int[] count1 = new int[26];\\n        \\n        for(int i=0; i<word.length(); i++){\\n            count1[word.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        for(int i=0; i<26; i++){\\n            if(count1[i] <= count[i]){\\n                count1[i] = count[i] - count1[i];\\n            }else return new int[]{};\\n        }\\n        \\n        return count1;\\n    }\\n    \\n    private int findScore(String word){\\n        int wordScore = 0;\\n        \\n        for(int i=0; i<word.length(); i++){\\n            wordScore += this.score[word.charAt(i)-\\'a\\'];\\n        }\\n        \\n        return wordScore;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int ans;\\n    private int[] score;\\n    \\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        // For each word, we will have two option, either to include it or not \\n        \\n        this.score = score;\\n        this.ans = 0;\\n        int[] count = new int[26];\\n        for(char c : letters){\\n            count[c-\\'a\\']++;\\n        }\\n        \\n        find(0, words, count, 0);\\n        return ans;\\n    }\\n    \\n    private void find(int index, String[] words, int[] count, int currScore){\\n        if(index == words.length){\\n            this.ans = Math.max(ans, currScore);\\n            return;\\n        }\\n        \\n        int[] newCount = includeCurrentPossibleOrNot(words[index], count);\\n        if(newCount.length != 0){ // Current word can be made from the count array \\n            find(index+1, words, newCount, currScore + findScore(words[index]));\\n        }\\n        \\n        find(index+1, words, count, currScore);\\n    }\\n    \\n    private int[] includeCurrentPossibleOrNot(String word, int[] count){\\n        int[] count1 = new int[26];\\n        \\n        for(int i=0; i<word.length(); i++){\\n            count1[word.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        for(int i=0; i<26; i++){\\n            if(count1[i] <= count[i]){\\n                count1[i] = count[i] - count1[i];\\n            }else return new int[]{};\\n        }\\n        \\n        return count1;\\n    }\\n    \\n    private int findScore(String word){\\n        int wordScore = 0;\\n        \\n        for(int i=0; i<word.length(); i++){\\n            wordScore += this.score[word.charAt(i)-\\'a\\'];\\n        }\\n        \\n        return wordScore;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824878,
                "title": "c-recursion",
                "content": "Since Constraints are small `1 <= words.length <= 14` && `1 <= words[i].length <= 15`, we actually do not need memo, simple recursion will work. Make choice for every word in `words`.\\n```\\nclass Solution {\\npublic:\\n    int find(vector<string>& words, vector<int> nums, vector<int>& score,int in){\\n        if(in>=words.size()) return 0;\\n        int re = find(words,nums,score,in+1);\\n        bool st = 1; int k = 0;\\n        string &s = words[in];\\n        for (auto ch : s) {\\n           if (--nums[ch - \\'a\\'] < 0) st = 0;\\n           k += score[ch - \\'a\\'];\\n        }\\n        if(st) re=max(re,k+find(words,nums,score,in+1));\\n        return re;\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> nums(26,0);\\n        for(int i = 0; i<letters.size();++i) nums[letters[i]-\\'a\\']++;\\n        return find(words,nums,score,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<string>& words, vector<int> nums, vector<int>& score,int in){\\n        if(in>=words.size()) return 0;\\n        int re = find(words,nums,score,in+1);\\n        bool st = 1; int k = 0;\\n        string &s = words[in];\\n        for (auto ch : s) {\\n           if (--nums[ch - \\'a\\'] < 0) st = 0;\\n           k += score[ch - \\'a\\'];\\n        }\\n        if(st) re=max(re,k+find(words,nums,score,in+1));\\n        return re;\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> nums(26,0);\\n        for(int i = 0; i<letters.size();++i) nums[letters[i]-\\'a\\']++;\\n        return find(words,nums,score,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780029,
                "title": "c-two-approaches-recursion-bitmask",
                "content": "**Approach 1 : Recursion**\\n\\n**We can use Recursion to find all subsets of the word Array and then do calculations on the set of subsets.**\\n\\n```\\nclass Solution {\\npublic:\\n    void recur(vector<string>&words,int idx,vector<string>ds,vector<int>&freq,vector<vector<string>>&ans)\\n    {\\n       \\n        if(!ds.empty())\\n        ans.push_back(ds);\\n        \\n        for(int i=idx;i<words.size();i++)\\n        {\\n            ds.push_back(words[i]);\\n            recur(words,i+1,ds,freq,ans);\\n            ds.pop_back();\\n        }\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        \\n        int n=words.size();\\n        vector<string>ds;\\n        vector<int>freq(n+1,0);\\n        vector<vector<string>>ans;\\n        recur(words,0,ds,freq,ans);\\n        \\n        map<char,int>mappings,required;\\n        char ch=\\'a\\';\\n        for(auto i:score)\\n            mappings[ch++]=i;\\n        for(auto i:letters)\\n            required[i]++;\\n        \\n        \\n        // for(auto i:required)\\n        // {\\n        //     cout<<i.first<<\" \"<<i.second<<endl;\\n        // }\\n        int result=0;\\n        for(auto i:ans)\\n        {\\n           map<char,int>have;\\n           int sum=0;\\n           vector<string>res=i;\\n           for(auto it:res)\\n           {\\n              // cout<<it<<\" \";\\n               string temp=it;\\n               for(auto it2:temp)\\n                   have[it2]++;\\n           }\\n           \\n           for(auto it:have)\\n           {\\n               if(required[it.first]<it.second){\\n                   goto brk;\\n               }\\n               sum+=(mappings[it.first]*it.second);\\n           }\\n            \\n          \\n           result=max(result,sum);\\n           brk:;\\n        }\\n        return result;\\n        \\n    }\\n};\\n```\\n\\n**Approach 2 : Bitmasking**\\n\\n**We can use bitmasking technique to find the subsets \\nor Power set of the set Words, remaining calculations remain\\nthe same.**\\n\\n```\\nclass Solution {\\npublic:\\n   \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        \\n        int n=words.size();\\n        \\n        vector<vector<string>>ans;\\n        \\n        \\n        for(int i=0;i<pow(2,n);i++)\\n        {\\n            string curr=\"\";\\n            vector<string>temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                curr=\"\";\\n                if(i&(1<<j)){\\n                    \\n                    curr+=words[j];\\n                    temp.push_back(curr);\\n                }\\n                \\n            }\\n           // cout<<curr<<endl;\\n            ans.push_back(temp);\\n        }\\n        \\n        \\n        map<char,int>mappings,required;\\n        char ch=\\'a\\';\\n        for(auto i:score)\\n            mappings[ch++]=i;\\n        for(auto i:letters)\\n            required[i]++;\\n        \\n        \\n      \\n        int result=0;\\n        for(auto i:ans)\\n        {\\n           map<char,int>have;\\n           int sum=0;\\n           vector<string>res=i;\\n           for(auto it:res)\\n           {\\n              // cout<<it<<\" \";\\n               string temp=it;\\n               for(auto it2:temp)\\n                   have[it2]++;\\n           }\\n           \\n           for(auto it:have)\\n           {\\n               if(required[it.first]<it.second){\\n                   goto brk;\\n               }\\n               sum+=(mappings[it.first]*it.second);\\n           }\\n            \\n          \\n           result=max(result,sum);\\n           brk:;\\n        }\\n        return result;\\n        \\n    }\\n};\\n```\\n\\n**Time Complexity : O ( 2^n  ) for both apporaches**\\n\\n**Pls upvote if you found helpful.\\nDo Comment down your doubts.**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recur(vector<string>&words,int idx,vector<string>ds,vector<int>&freq,vector<vector<string>>&ans)\\n    {\\n       \\n        if(!ds.empty())\\n        ans.push_back(ds);\\n        \\n        for(int i=idx;i<words.size();i++)\\n        {\\n            ds.push_back(words[i]);\\n            recur(words,i+1,ds,freq,ans);\\n            ds.pop_back();\\n        }\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        \\n        int n=words.size();\\n        vector<string>ds;\\n        vector<int>freq(n+1,0);\\n        vector<vector<string>>ans;\\n        recur(words,0,ds,freq,ans);\\n        \\n        map<char,int>mappings,required;\\n        char ch=\\'a\\';\\n        for(auto i:score)\\n            mappings[ch++]=i;\\n        for(auto i:letters)\\n            required[i]++;\\n        \\n        \\n        // for(auto i:required)\\n        // {\\n        //     cout<<i.first<<\" \"<<i.second<<endl;\\n        // }\\n        int result=0;\\n        for(auto i:ans)\\n        {\\n           map<char,int>have;\\n           int sum=0;\\n           vector<string>res=i;\\n           for(auto it:res)\\n           {\\n              // cout<<it<<\" \";\\n               string temp=it;\\n               for(auto it2:temp)\\n                   have[it2]++;\\n           }\\n           \\n           for(auto it:have)\\n           {\\n               if(required[it.first]<it.second){\\n                   goto brk;\\n               }\\n               sum+=(mappings[it.first]*it.second);\\n           }\\n            \\n          \\n           result=max(result,sum);\\n           brk:;\\n        }\\n        return result;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n   \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        \\n        int n=words.size();\\n        \\n        vector<vector<string>>ans;\\n        \\n        \\n        for(int i=0;i<pow(2,n);i++)\\n        {\\n            string curr=\"\";\\n            vector<string>temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                curr=\"\";\\n                if(i&(1<<j)){\\n                    \\n                    curr+=words[j];\\n                    temp.push_back(curr);\\n                }\\n                \\n            }\\n           // cout<<curr<<endl;\\n            ans.push_back(temp);\\n        }\\n        \\n        \\n        map<char,int>mappings,required;\\n        char ch=\\'a\\';\\n        for(auto i:score)\\n            mappings[ch++]=i;\\n        for(auto i:letters)\\n            required[i]++;\\n        \\n        \\n      \\n        int result=0;\\n        for(auto i:ans)\\n        {\\n           map<char,int>have;\\n           int sum=0;\\n           vector<string>res=i;\\n           for(auto it:res)\\n           {\\n              // cout<<it<<\" \";\\n               string temp=it;\\n               for(auto it2:temp)\\n                   have[it2]++;\\n           }\\n           \\n           for(auto it:have)\\n           {\\n               if(required[it.first]<it.second){\\n                   goto brk;\\n               }\\n               sum+=(mappings[it.first]*it.second);\\n           }\\n            \\n          \\n           result=max(result,sum);\\n           brk:;\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1735970,
                "title": "c-backtracking-line-by-line-code-explanation-with-logic",
                "content": "- goal is to make subset using given words such that all words has a score, we need to find subset with maximum sum of these scores, but we have to follow few conditions:\\n-- letter[] tells how many time chars can be used in subset\\n-- for example : \\'d\\' frequency is 3 in letters[],\\n-- so that we can use only those words having in subset such freq. of d in the subset is also three\\n-- example: [dog, dad] <- one \\'d\\' in dog and two \\'d\\'s in dad which is equal to three \\'d\\'s\\n-- we can not execeed frequency of the char in our subset, it should be <= frequency(ch);\\n- every word has two options either to contribute in the current call or do not contribute \\n- to access each we will need a variable idx = 0; idx+1 on each call untill all words are consumed\\n- we will take current word and we will keep decreasing frequencies of each char in that word\\n- incase if any of the char has frequency <= 0 this mean we cannot use that word; because to make any word frequency of any char >= 1\\n- for each chars of the current word, we have some scores, we keep adding this scores\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int helper(vector<string>& words, int* fmap, vector<int>& score, int idx){\\n        \\n        if(idx == words.size()){ // all words checked/consumed\\n            return 0;\\n        }        \\n        \\n        // now each words has to option (n^2), to contribute in current call or not\\n        \\n        // no contribution call\\n        \\n        int noContribScore = helper(words, fmap, score, idx+1); // idx+1 to look for other word\\n        \\n        string currentWord = words[idx];\\n        int currentWordScore = 0;\\n        \\n        bool can_we_use_currentWord = true; // considering;\\n        \\n        for(auto x : currentWord){\\n            char currentChar = x; \\n            \\n            \\n            if(fmap[currentChar - \\'a\\'] <= 0){\\n                // we can not use that word \\n                // considering \"dog\" and \"good\"\\n                // frq of \\'o\\' is 2\\n                // o -> 1 after dog\\n                // 0 -> 0 after using first \\'o\\' of \"good\";\\n                // we can not use \"dog\" and \"good\" together\\n                can_we_use_currentWord = false;\\n            }\\n            \\n            // take current character, reduce its frequency\\n            // dog -> 1:d -> 0:d, then o, then g\\n            fmap[currentChar - \\'a\\'] -=1; // \\n            currentWordScore += score[currentChar-\\'a\\']; // add score of current char, for \\'d\\' 5\\n            \\n        }\\n        \\n        int contribScore = 0;\\n        \\n        if(can_we_use_currentWord == true){ // yes we can use current word\\n            // add its score   \\n            contribScore = currentWordScore + helper(words, fmap, score, idx+1);\\n        }\\n        \\n        // backtrack, undo our selections\\n        \\n        for(auto x : currentWord){\\n            fmap[x - \\'a\\']+=1;\\n        }\\n        \\n        return max(contribScore, noContribScore);\\n    }\\n\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        int fmap[26] = {0}; // to store frequency of each chars\\n        \\n        for(auto x : letters){\\n            fmap[x-\\'a\\']++; // d : 3, g : 1, o : 2, c : 1\\n        }\\n        \\n        return helper(words, fmap, score, 0);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(vector<string>& words, int* fmap, vector<int>& score, int idx){\\n        \\n        if(idx == words.size()){ // all words checked/consumed\\n            return 0;\\n        }        \\n        \\n        // now each words has to option (n^2), to contribute in current call or not\\n        \\n        // no contribution call\\n        \\n        int noContribScore = helper(words, fmap, score, idx+1); // idx+1 to look for other word\\n        \\n        string currentWord = words[idx];\\n        int currentWordScore = 0;\\n        \\n        bool can_we_use_currentWord = true; // considering;\\n        \\n        for(auto x : currentWord){\\n            char currentChar = x; \\n            \\n            \\n            if(fmap[currentChar - \\'a\\'] <= 0){\\n                // we can not use that word \\n                // considering \"dog\" and \"good\"\\n                // frq of \\'o\\' is 2\\n                // o -> 1 after dog\\n                // 0 -> 0 after using first \\'o\\' of \"good\";\\n                // we can not use \"dog\" and \"good\" together\\n                can_we_use_currentWord = false;\\n            }\\n            \\n            // take current character, reduce its frequency\\n            // dog -> 1:d -> 0:d, then o, then g\\n            fmap[currentChar - \\'a\\'] -=1; // \\n            currentWordScore += score[currentChar-\\'a\\']; // add score of current char, for \\'d\\' 5\\n            \\n        }\\n        \\n        int contribScore = 0;\\n        \\n        if(can_we_use_currentWord == true){ // yes we can use current word\\n            // add its score   \\n            contribScore = currentWordScore + helper(words, fmap, score, idx+1);\\n        }\\n        \\n        // backtrack, undo our selections\\n        \\n        for(auto x : currentWord){\\n            fmap[x - \\'a\\']+=1;\\n        }\\n        \\n        return max(contribScore, noContribScore);\\n    }\\n\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        int fmap[26] = {0}; // to store frequency of each chars\\n        \\n        for(auto x : letters){\\n            fmap[x-\\'a\\']++; // d : 3, g : 1, o : 2, c : 1\\n        }\\n        \\n        return helper(words, fmap, score, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718247,
                "title": "c-dfs-dfs-memoization-efficient",
                "content": "Here is the simple DFS code.\\n\\n```\\nclass Solution {\\npublic:\\n    int res;\\n    void maxScore(vector<string>& words, int i, vector<int>& count, vector<int>& score, int curr) {\\n        if(i == words.size()) {\\n            res = max(res, curr);\\n            return;\\n        }    \\n        \\n        vector<int> temp = count;\\n        int scr = 0;\\n        bool flag = true;\\n        for(auto x : words[i]) {\\n            if(temp[x-\\'a\\'] == 0) {flag = false; break;}\\n            temp[x-\\'a\\']--;\\n            scr += score[x-\\'a\\'];\\n        }\\n        \\n        maxScore(words, i+1, count, score, curr);\\n        if(flag) maxScore(words, i+1, temp, score, curr+scr);\\n    }\\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        res = INT_MIN;\\n        vector<int> count(26, 0);\\n        for(auto x : letters) {\\n            count[x-\\'a\\']++;\\n        }\\n        maxScore(words, 0, count, score, 0);\\n        return res;\\n    }\\n};\\n```\\n\\nBut what if the constraints are high? Well, I though of the approach for such scenario. Let me know if this code will be efficeint for large test cases. \\n\\n```\\nclass Solution {\\npublic:\\n    int res;\\n    unordered_set<string> s;\\n    void maxScore(vector<string>& words, int i, vector<int>& count, vector<int>& score, int curr, string str) {\\n        if(i == words.size()) {\\n            res = max(res, curr);\\n            return;\\n        }    \\n        \\n        sort(str.begin(), str.end());\\n        if(s.find(str) != s.end()) return;\\n        string s1 = str;\\n        \\n        vector<int> temp = count;\\n        int scr = 0;\\n        bool flag = true;\\n        for(auto x : words[i]) {\\n            if(temp[x-\\'a\\'] == 0) flag = false;\\n            temp[x-\\'a\\']--;\\n            scr += score[x-\\'a\\'];\\n            s1 += x;\\n        }\\n        \\n        maxScore(words, i+1, count, score, curr, str);\\n        if(flag) maxScore(words, i+1, temp, score, curr+scr, s1);\\n        \\n        s.insert(str);\\n    }\\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        res = INT_MIN;\\n        vector<int> count(26, 0);\\n        for(auto x : letters) {\\n            count[x-\\'a\\']++;\\n        }\\n        maxScore(words, 0, count, score, 0, \"\");\\n        return res;\\n    }\\n};\\n```\\n\\nHere we are keeping track of the words that we have used till now.",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res;\\n    void maxScore(vector<string>& words, int i, vector<int>& count, vector<int>& score, int curr) {\\n        if(i == words.size()) {\\n            res = max(res, curr);\\n            return;\\n        }    \\n        \\n        vector<int> temp = count;\\n        int scr = 0;\\n        bool flag = true;\\n        for(auto x : words[i]) {\\n            if(temp[x-\\'a\\'] == 0) {flag = false; break;}\\n            temp[x-\\'a\\']--;\\n            scr += score[x-\\'a\\'];\\n        }\\n        \\n        maxScore(words, i+1, count, score, curr);\\n        if(flag) maxScore(words, i+1, temp, score, curr+scr);\\n    }\\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        res = INT_MIN;\\n        vector<int> count(26, 0);\\n        for(auto x : letters) {\\n            count[x-\\'a\\']++;\\n        }\\n        maxScore(words, 0, count, score, 0);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int res;\\n    unordered_set<string> s;\\n    void maxScore(vector<string>& words, int i, vector<int>& count, vector<int>& score, int curr, string str) {\\n        if(i == words.size()) {\\n            res = max(res, curr);\\n            return;\\n        }    \\n        \\n        sort(str.begin(), str.end());\\n        if(s.find(str) != s.end()) return;\\n        string s1 = str;\\n        \\n        vector<int> temp = count;\\n        int scr = 0;\\n        bool flag = true;\\n        for(auto x : words[i]) {\\n            if(temp[x-\\'a\\'] == 0) flag = false;\\n            temp[x-\\'a\\']--;\\n            scr += score[x-\\'a\\'];\\n            s1 += x;\\n        }\\n        \\n        maxScore(words, i+1, count, score, curr, str);\\n        if(flag) maxScore(words, i+1, temp, score, curr+scr, s1);\\n        \\n        s.insert(str);\\n    }\\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        res = INT_MIN;\\n        vector<int> count(26, 0);\\n        for(auto x : letters) {\\n            count[x-\\'a\\']++;\\n        }\\n        maxScore(words, 0, count, score, 0, \"\");\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664250,
                "title": "c-bitmasking-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // Check that set is valid or not\\n    bool valid(vector<string> &cur,vector<int> freq){\\n        for(auto &word : cur){\\n            for(auto &ch : word){\\n                if(freq[ch - \\'a\\'] <= 0){ // If we are out of characters then return false\\n                    return 0;\\n                }\\n                // Reduce the frequency by 1\\n                freq[ch - \\'a\\']--;\\n            }\\n        }\\n        return 1;\\n    }\\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        // storing frequencies\\n        vector<int> freq(26,0);\\n        for(auto &ch : letters){\\n            freq[ch - \\'a\\']++;\\n        }\\n        \\n        int n = words.size();\\n        int max_score = 0;\\n        \\n        // Using Bitmasking Approach to try out all possible sets because 1 <= n <= 14\\n        for(int i=0;i<(1<<n);i++){\\n            vector<string> cur; \\n            for(int j=0;j<n;j++){\\n                // Include that word in current set\\n                if(i&(1<<j)){\\n                    cur.push_back(words[j]);\\n                }\\n            }\\n            if(cur.size() == 0) continue;\\n            // If set is valid then compute the current score\\n            if(valid(cur,freq)){\\n                int cur_score = 0;\\n                for(auto &word : cur){\\n                    for(auto &ch : word){\\n                        cur_score += score[ch - \\'a\\'];\\n                    }\\n                }\\n                max_score = max(max_score,cur_score);\\n            }\\n        }\\n        return max_score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Check that set is valid or not\\n    bool valid(vector<string> &cur,vector<int> freq){\\n        for(auto &word : cur){\\n            for(auto &ch : word){\\n                if(freq[ch - \\'a\\'] <= 0){ // If we are out of characters then return false\\n                    return 0;\\n                }\\n                // Reduce the frequency by 1\\n                freq[ch - \\'a\\']--;\\n            }\\n        }\\n        return 1;\\n    }\\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        // storing frequencies\\n        vector<int> freq(26,0);\\n        for(auto &ch : letters){\\n            freq[ch - \\'a\\']++;\\n        }\\n        \\n        int n = words.size();\\n        int max_score = 0;\\n        \\n        // Using Bitmasking Approach to try out all possible sets because 1 <= n <= 14\\n        for(int i=0;i<(1<<n);i++){\\n            vector<string> cur; \\n            for(int j=0;j<n;j++){\\n                // Include that word in current set\\n                if(i&(1<<j)){\\n                    cur.push_back(words[j]);\\n                }\\n            }\\n            if(cur.size() == 0) continue;\\n            // If set is valid then compute the current score\\n            if(valid(cur,freq)){\\n                int cur_score = 0;\\n                for(auto &word : cur){\\n                    for(auto &ch : word){\\n                        cur_score += score[ch - \\'a\\'];\\n                    }\\n                }\\n                max_score = max(max_score,cur_score);\\n            }\\n        }\\n        return max_score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612965,
                "title": "c-backtracking-recursion-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string,int> mp;\\n    int ans=0;\\n    \\n    bool check(string a,vector<int> count){\\n        for(int i=0;i<a.length();i++){\\n            if(count[a[i]-\\'a\\']>0) --count[a[i]-\\'a\\'];\\n            else return false;\\n        }\\n        return true;\\n    }\\n    \\n    void giveAns(vector<string>& words,int start,vector<int> count,int sum){\\n        if(sum>ans) ans=sum;\\n        if(start>=words.size()){\\n            if(sum>ans) ans=sum;\\n            return;\\n        }\\n        for(int i=start;i<words.size();i++){\\n            if(check(words[i],count)){\\n                vector<int> temp=count;\\n                for(int j=0;j<words[i].length();j++) temp[words[i][j]-\\'a\\']--;\\n                giveAns(words,i+1,temp,sum+mp[words[i]]);\\n            }\\n        }\\n    }\\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> count(26,0);\\n        for(int i=0;i<letters.size();i++) count[letters[i]-\\'a\\']++;\\n        for(int i=0;i<words.size();i++){\\n            int sum=0;\\n            for(int j=0;j<words[i].length();j++){\\n                sum+=score[words[i][j]-\\'a\\'];\\n            }\\n            mp[words[i]]=sum;\\n        }\\n        giveAns(words,0,count,0);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    unordered_map<string,int> mp;\\n    int ans=0;\\n    \\n    bool check(string a,vector<int> count){\\n        for(int i=0;i<a.length();i++){\\n            if(count[a[i]-\\'a\\']>0) --count[a[i]-\\'a\\'];\\n            else return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1607603,
                "title": "recursive-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<string>words, int i, unordered_map<char, int>u, vector<int>score)\\n    {\\n        if(i == words.size()) return 0;\\n        \\n        int res = 0;\\n        for(int c=i;c<words.size();++c)\\n        {\\n            unordered_map<char, int>temp = u;\\n            int temp_sum = 0;\\n            int not_i = 0;\\n            for(int j=0;j<words[c].size();++j)\\n            {\\n                if(temp[words[c][j]] > 0)\\n                {\\n                    temp_sum += score[words[c][j] - \\'a\\'];\\n                    temp[words[c][j]]--;\\n                }\\n                else{\\n                    not_i = 1;\\n                    break;\\n                }\\n            }\\n            if(not_i == 0)\\n            {\\n                res = max(res, temp_sum + solve(words, c+1, temp, score));\\n            }\\n        }\\n        return res;\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        unordered_map<char, int>u;\\n        \\n        for(auto i : letters)\\n        {\\n            u[i]++;\\n        }\\n        return solve(words, 0, u, score);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<string>words, int i, unordered_map<char, int>u, vector<int>score)\\n    {\\n        if(i == words.size()) return 0;\\n        \\n        int res = 0;\\n        for(int c=i;c<words.size();++c)\\n        {\\n            unordered_map<char, int>temp = u;\\n            int temp_sum = 0;\\n            int not_i = 0;\\n            for(int j=0;j<words[c].size();++j)\\n            {\\n                if(temp[words[c][j]] > 0)\\n                {\\n                    temp_sum += score[words[c][j] - \\'a\\'];\\n                    temp[words[c][j]]--;\\n                }\\n                else{\\n                    not_i = 1;\\n                    break;\\n                }\\n            }\\n            if(not_i == 0)\\n            {\\n                res = max(res, temp_sum + solve(words, c+1, temp, score));\\n            }\\n        }\\n        return res;\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        unordered_map<char, int>u;\\n        \\n        for(auto i : letters)\\n        {\\n            u[i]++;\\n        }\\n        return solve(words, 0, u, score);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583181,
                "title": "c-recursion",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<int>freq;\\npublic:\\n    int isPossible(vector<int> &freq,vector<int> &score, string s){\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(freq[s[i]-\\'a\\']==0)\\n                return -1;\\n            \\n            freq[s[i]-\\'a\\']--;\\n            sum+=score[s[i]-\\'a\\'];\\n        }\\n        \\n        return sum;\\n         \\n    }\\n    int recur(vector<string>& words, vector<int>& freq,vector<int>& score, int index)\\n    {\\n        if(index>=words.size())\\n            return 0;\\n        \\n        int sum=0;\\n        vector<int> temp_freq = freq;\\n        int a = isPossible(freq,score, words[index]);\\n        \\n        if(a!=-1)\\n        {\\n            sum=max(sum, a + recur(words, freq, score, index+1));\\n            sum=max(sum,  recur(words, temp_freq, score, index+1));\\n        }\\n        else\\n            sum = max(sum,recur(words, temp_freq, score, index+1));\\n        \\n        return sum;\\n        \\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n       \\n        int ans=0;\\n        \\n        for(int i=0;i<26;i++)\\n            freq.push_back(0);\\n        \\n        for(int i=0;i<letters.size();i++)\\n            freq[letters[i]-\\'a\\']++;\\n        \\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            vector<int> fre=freq;\\n            int a = isPossible(fre,score,words[i]);\\n            if(a !=-1) ans= max(ans,a + recur(words, fre, score, i+1));\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int>freq;\\npublic:\\n    int isPossible(vector<int> &freq,vector<int> &score, string s){\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(freq[s[i]-\\'a\\']==0)\\n                return -1;\\n            \\n            freq[s[i]-\\'a\\']--;\\n            sum+=score[s[i]-\\'a\\'];\\n        }\\n        \\n        return sum;\\n         \\n    }\\n    int recur(vector<string>& words, vector<int>& freq,vector<int>& score, int index)\\n    {\\n        if(index>=words.size())\\n            return 0;\\n        \\n        int sum=0;\\n        vector<int> temp_freq = freq;\\n        int a = isPossible(freq,score, words[index]);\\n        \\n        if(a!=-1)\\n        {\\n            sum=max(sum, a + recur(words, freq, score, index+1));\\n            sum=max(sum,  recur(words, temp_freq, score, index+1));\\n        }\\n        else\\n            sum = max(sum,recur(words, temp_freq, score, index+1));\\n        \\n        return sum;\\n        \\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n       \\n        int ans=0;\\n        \\n        for(int i=0;i<26;i++)\\n            freq.push_back(0);\\n        \\n        for(int i=0;i<letters.size();i++)\\n            freq[letters[i]-\\'a\\']++;\\n        \\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            vector<int> fre=freq;\\n            int a = isPossible(fre,score,words[i]);\\n            if(a !=-1) ans= max(ans,a + recur(words, fre, score, i+1));\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578943,
                "title": "java-recursion-and-backtracking-beats-100",
                "content": "For each word, if there is no enough letters left, just skip; if there are enough letters to form it, then try taking and not taking the word. Brute force method but works. Need memoization to work with a longer list of words.\\n\\n```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int[][] wordsLetterCounts = new int[words.length][26];\\n        int[] letterCounts = new int[26];\\n        \\n        for (int i = 0; i < words.length; i++){\\n            String w = words[i];\\n            for (int j = 0; j < w.length(); j++){\\n                wordsLetterCounts[i][w.charAt(j) - \\'a\\']++;\\n            }\\n        }\\n        \\n        for (char c:letters){\\n            letterCounts[c - \\'a\\']++;\\n        }\\n        \\n        return dfs(wordsLetterCounts, letterCounts, score, 0);\\n    }\\n    \\n    private int dfs(int[][] wordsLetterCounts, int[] letterCounts, int[] score, int idx){\\n        \\n        if (idx >= wordsLetterCounts.length){\\n            return 0;\\n        }\\n        \\n        int[] requiredLetters = wordsLetterCounts[idx];\\n        int ret = 0;\\n        for (int i = 0; i < 26; i++){\\n            if (requiredLetters[i] > letterCounts[i]){\\n                ret = dfs(wordsLetterCounts, letterCounts, score, idx + 1);  //Unable to take\\n                return ret;\\n            }\\n        }\\n        \\n        int scoreInc = 0;\\n        for (int i = 0; i < 26; i++){\\n            letterCounts[i] -= requiredLetters[i];\\n            scoreInc += requiredLetters[i] * score[i];\\n        }\\n        \\n        int taken = dfs(wordsLetterCounts, letterCounts, score, idx + 1) + scoreInc;\\n        \\n        for (int i = 0; i < 26; i++){\\n            letterCounts[i] += requiredLetters[i];\\n        }\\n        int notTaken = dfs(wordsLetterCounts, letterCounts, score, idx + 1);\\n        \\n        ret = taken > notTaken?taken:notTaken;\\n\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int[][] wordsLetterCounts = new int[words.length][26];\\n        int[] letterCounts = new int[26];\\n        \\n        for (int i = 0; i < words.length; i++){\\n            String w = words[i];\\n            for (int j = 0; j < w.length(); j++){\\n                wordsLetterCounts[i][w.charAt(j) - \\'a\\']++;\\n            }\\n        }\\n        \\n        for (char c:letters){\\n            letterCounts[c - \\'a\\']++;\\n        }\\n        \\n        return dfs(wordsLetterCounts, letterCounts, score, 0);\\n    }\\n    \\n    private int dfs(int[][] wordsLetterCounts, int[] letterCounts, int[] score, int idx){\\n        \\n        if (idx >= wordsLetterCounts.length){\\n            return 0;\\n        }\\n        \\n        int[] requiredLetters = wordsLetterCounts[idx];\\n        int ret = 0;\\n        for (int i = 0; i < 26; i++){\\n            if (requiredLetters[i] > letterCounts[i]){\\n                ret = dfs(wordsLetterCounts, letterCounts, score, idx + 1);  //Unable to take\\n                return ret;\\n            }\\n        }\\n        \\n        int scoreInc = 0;\\n        for (int i = 0; i < 26; i++){\\n            letterCounts[i] -= requiredLetters[i];\\n            scoreInc += requiredLetters[i] * score[i];\\n        }\\n        \\n        int taken = dfs(wordsLetterCounts, letterCounts, score, idx + 1) + scoreInc;\\n        \\n        for (int i = 0; i < 26; i++){\\n            letterCounts[i] += requiredLetters[i];\\n        }\\n        int notTaken = dfs(wordsLetterCounts, letterCounts, score, idx + 1);\\n        \\n        ret = taken > notTaken?taken:notTaken;\\n\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531243,
                "title": "easy-backtracking-solution-1ms-95-faster",
                "content": "```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int[] freq_map = new int[26];\\n        for (char ch : letters) \\n            freq_map[ch - \\'a\\']++;\\n        return max_score(words, 0, freq_map, score);\\n    }\\n\\n    private int max_score(String[] words, int idx, int[] freq_map, int[] score) {\\n        if (idx >= words.length) return 0;\\n        int excluded = max_score(words, idx + 1, freq_map, score);\\n\\n        String curr_word = words[idx];\\n        int curr_word_score = 0;\\n        int i = 0;\\n        while (i < curr_word.length()) {\\n            char ch = curr_word.charAt(i);\\n            if (freq_map[ch - \\'a\\'] == 0) {\\n                increase_freq(freq_map, curr_word, --i); // backtracking (if not included)\\n                return excluded;\\n            }\\n            curr_word_score += score[ch - \\'a\\'];\\n            freq_map[ch - \\'a\\']--;\\n            i++;\\n        }\\n        int included = max_score(words, idx + 1, freq_map, score) + curr_word_score;\\n        increase_freq(freq_map, curr_word, --i); // backtracking\\n        return Math.max(excluded, included);\\n    }\\n\\n    private void increase_freq(int[] freq_map, String word, int idx) {\\n        while (idx >= 0) {\\n            freq_map[word.charAt(idx) - \\'a\\']++;\\n            idx--;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int[] freq_map = new int[26];\\n        for (char ch : letters) \\n            freq_map[ch - \\'a\\']++;\\n        return max_score(words, 0, freq_map, score);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1502515,
                "title": "cpp-backtrack-analogy-to-knapsack-problem",
                "content": "class Solution {\\npublic:\\n\\n    int dp(vector<string>& words, vector<int> cnt,vector<int>& score, int idx,int ans){\\n        if(idx < 0) return ans;\\n        int sc = 0;\\n        for(char c : words[idx]) {\\n            sc += score[c-\\'a\\'];\\n        }\\n        // leave it\\n        int leave = dp(words,cnt,score,idx-1,ans);\\n        //take it\\n        bool flag = true;\\n        for(char c : words[idx]){\\n            cnt[c-\\'a\\']--;\\n            if(cnt[c-\\'a\\'] < 0) flag = false;\\n        }\\n        int take = 0;\\n        if(flag) take = dp(words,cnt,score,idx-1,ans+sc);\\n        return max(leave,take);\\n        \\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> value ;\\n        for(string s : words){\\n            int fre = 0;\\n            for(char c : s){\\n                fre += score[c-\\'a\\'];\\n            }\\n            value.push_back(fre);\\n        }\\n        vector<int> cnt(26,0);\\n        for(char c : letters) cnt[c-\\'a\\']++;\\n        //from now on it will be simillar to knapsack problem\\n        // we have to maximize the value with the constraint that letters should not be overflowed\\n        return dp(words,cnt,score,words.size()-1,0);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int dp(vector<string>& words, vector<int> cnt,vector<int>& score, int idx,int ans){\\n        if(idx < 0) return ans;\\n        int sc = 0;\\n        for(char c : words[idx]) {\\n            sc += score[c-\\'a\\'];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1384633,
                "title": "java-fast-soluton",
                "content": "```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n               \\n    \\n        int[] farr = new int[score.length];\\n\\t\\tfor (char ch : letters) {\\n\\t\\t\\tfarr[ch - \\'a\\']++;\\n\\t\\t}\\n     return solution(words,farr,score,0);\\n    }\\n    \\n    \\n\\tpublic static int solution(String[] words, int[] farr, int[] score, int idx) {\\n\\t   if(idx==words.length){\\n\\t        return 0;\\n\\t   } \\n\\t    \\n\\t   int sno = 0 + solution(words,farr,score,idx+1);\\n\\t    \\n\\t    String word=words[idx];\\n\\t    int sword=0;\\n\\t    boolean flag=true;\\n\\t    for(int i=0; i<word.length(); i++){\\n\\t        char ch= word.charAt(i);\\n\\t        \\n\\t        if(farr[ch-\\'a\\']==0){\\n\\t            flag=false;\\n\\t            \\n\\t        }\\n\\t        farr[ch-\\'a\\']--;\\n\\t        sword+=score[ch-\\'a\\'];\\n\\t    }\\n\\t    \\n\\t    int syes=0;\\n\\t    if(flag)  syes=sword+ solution(words,farr,score,idx+1);\\n\\t    \\n\\t    for(int i=0; i<word.length(); i++){\\n\\t        char ch= word.charAt(i);\\n\\t        farr[ch-\\'a\\']++;\\n\\t    }\\n\\t    \\n\\t\\treturn Math.max(sno,syes);\\n\\t}\\n\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n               \\n    \\n        int[] farr = new int[score.length];\\n\\t\\tfor (char ch : letters) {\\n\\t\\t\\tfarr[ch - \\'a\\']++;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1365594,
                "title": "c-bitmasking-with-readable-code",
                "content": "```C++\\nint maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& scores) {\\n      int mx_score = 0;\\n      int n = words.size();\\n      int occ[26] = {0};\\n      for (auto &ch: letters) {\\n        occ[ch - \\'a\\']++;\\n      }\\n      \\n      auto is_valid = [&] (vector<string> &subs) {\\n        int curr_occ[26] = {0};\\n        for (auto &word: subs) {\\n          for (auto &ch: word) {\\n            curr_occ[ch - \\'a\\']++;\\n          }\\n        }\\n        for (int i = 0; i < 26; i++) {\\n          if (curr_occ[i] > occ[i]) return false;\\n        }\\n        return true;\\n      };\\n      \\n      auto score = [&] (vector<string> &subs) {\\n        int ans = 0;\\n        for (auto &word: subs) {\\n          for (auto &ch: word) ans += scores[ch - \\'a\\'];\\n        }\\n        return ans;\\n      };\\n      \\n      for (int mask = 0; mask < (1 << n); mask++) {\\n        vector<string> subs;\\n        for (int i = 0; i < n; i++) {\\n          if (mask & (1 << i))\\n            subs.push_back(words[i]);\\n        }\\n        if (!is_valid(subs)) continue;\\n        mx_score = max(mx_score, score(subs));\\n      }\\n      \\n      return mx_score;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```C++\\nint maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& scores) {\\n      int mx_score = 0;\\n      int n = words.size();\\n      int occ[26] = {0};\\n      for (auto &ch: letters) {\\n        occ[ch - \\'a\\']++;\\n      }\\n      \\n      auto is_valid = [&] (vector<string> &subs) {\\n        int curr_occ[26] = {0};\\n        for (auto &word: subs) {\\n          for (auto &ch: word) {\\n            curr_occ[ch - \\'a\\']++;\\n          }\\n        }\\n        for (int i = 0; i < 26; i++) {\\n          if (curr_occ[i] > occ[i]) return false;\\n        }\\n        return true;\\n      };\\n      \\n      auto score = [&] (vector<string> &subs) {\\n        int ans = 0;\\n        for (auto &word: subs) {\\n          for (auto &ch: word) ans += scores[ch - \\'a\\'];\\n        }\\n        return ans;\\n      };\\n      \\n      for (int mask = 0; mask < (1 << n); mask++) {\\n        vector<string> subs;\\n        for (int i = 0; i < n; i++) {\\n          if (mask & (1 << i))\\n            subs.push_back(words[i]);\\n        }\\n        if (!is_valid(subs)) continue;\\n        mx_score = max(mx_score, score(subs));\\n      }\\n      \\n      return mx_score;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1337831,
                "title": "simple-bitmasking",
                "content": "Simple bitmasking:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        \\n        int n=words.size();\\n        \\n        int charfreq[26];// store the frequency of each character in letters array\\n    \\n        memset(charfreq,0,sizeof charfreq);\\n        \\n        for(int i=0;i<letters.size();i++){\\n            charfreq[letters[i]-\\'a\\']++;\\n        }\\n        \\n        int ans=0;\\n        \\n        int val[n+1]; // Stores the score of individual word in words array.\\n        \\n        memset(val,0,sizeof val);\\n        \\n        for(int i=0;i<n;i++){\\n            int scor=0;\\n            for(int j=0;j<words[i].size();j++){\\n                scor+=score[words[i][j]-\\'a\\'];\\n            }\\n            val[i]=scor;\\n        }\\n        \\n        // Iterate over every subset and check if that subset of words is possible to take or not\\n        // A subset of words will only be possible if the frequency of every character in that subset of           //words is less than the original frequency of characters present in \\'letters\\' array\\n        \\n        for(int mask=0;mask<(1<<n);mask++){\\n            int freq[26];\\n            memset(freq,0,sizeof freq);\\n            for(int i=0;i<n;i++){\\n                if(mask&(1<<i)){\\n                    for(int j=0;j<words[i].size();j++){\\n                        freq[words[i][j]-\\'a\\']++;\\n                    }\\n                }\\n            }\\n            int flag=1;\\n            for(int i=0;i<26;i++){\\n                if(freq[i]>charfreq[i]){\\n                    flag=0;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                int sum=0;\\n                     for(int i=0;i<n;i++){\\n                         if(mask&(1<<i)){\\n                             sum+=val[i];\\n                         }\\n                     }\\n\\n                     ans=max(ans,sum);\\n                 }\\n            \\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        \\n        int n=words.size();\\n        \\n        int charfreq[26];// store the frequency of each character in letters array\\n    \\n        memset(charfreq,0,sizeof charfreq);\\n        \\n        for(int i=0;i<letters.size();i++){\\n            charfreq[letters[i]-\\'a\\']++;\\n        }\\n        \\n        int ans=0;\\n        \\n        int val[n+1]; // Stores the score of individual word in words array.\\n        \\n        memset(val,0,sizeof val);\\n        \\n        for(int i=0;i<n;i++){\\n            int scor=0;\\n            for(int j=0;j<words[i].size();j++){\\n                scor+=score[words[i][j]-\\'a\\'];\\n            }\\n            val[i]=scor;\\n        }\\n        \\n        // Iterate over every subset and check if that subset of words is possible to take or not\\n        // A subset of words will only be possible if the frequency of every character in that subset of           //words is less than the original frequency of characters present in \\'letters\\' array\\n        \\n        for(int mask=0;mask<(1<<n);mask++){\\n            int freq[26];\\n            memset(freq,0,sizeof freq);\\n            for(int i=0;i<n;i++){\\n                if(mask&(1<<i)){\\n                    for(int j=0;j<words[i].size();j++){\\n                        freq[words[i][j]-\\'a\\']++;\\n                    }\\n                }\\n            }\\n            int flag=1;\\n            for(int i=0;i<26;i++){\\n                if(freq[i]>charfreq[i]){\\n                    flag=0;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                int sum=0;\\n                     for(int i=0;i<n;i++){\\n                         if(mask&(1<<i)){\\n                             sum+=val[i];\\n                         }\\n                     }\\n\\n                     ans=max(ans,sum);\\n                 }\\n            \\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312755,
                "title": "c-count-frequency-and-backtrack",
                "content": "##### Steps\\n* Since its given that every `letter` can only be used once, therefore we store frequency of each letter\\n* if we\\'re at ith index in words array, that means we\\'re currently checking if `words[i]` can be formed or not\\n* to check if a word can be formed or not we traverse through the word and decrease the frequency of chars encountered\\n* if at any point of time frequency count of any char becomes less than 0, it means that sufficient letters are not present to form word\\n* if sufficient letters are provided then we move forward in this path\\n* at the end we backtrack, i.e. we increase the letter count, i.e. frequency which we reduced while traversing the word so that it can be reused for next word\\n\\n##### Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<string>&words, vector<int>count, vector<int>&score, int idx) {\\n        int currMax = 0;\\n        for(int i = idx; i < words.size(); i++) {\\n            bool ok = true;\\n            int curr = 0;\\n            for(auto& c : words[i]) {\\n                count[c - \\'a\\']--;\\n                curr += score[c - \\'a\\'];\\n                if(count[c - \\'a\\'] < 0)\\n                    ok = false;\\n            }\\n            if(ok) {\\n                curr += dfs(words, count, score, i + 1);\\n                currMax = max(currMax, curr);\\n            }\\n            \\n            for(auto& c : words[i])\\n                ++count[c - \\'a\\'];\\n        }\\n        return currMax;\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int>count(26);\\n        for(auto& letter : letters)\\n            ++count[letter - \\'a\\'];\\n        return dfs(words, count, score, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<string>&words, vector<int>count, vector<int>&score, int idx) {\\n        int currMax = 0;\\n        for(int i = idx; i < words.size(); i++) {\\n            bool ok = true;\\n            int curr = 0;\\n            for(auto& c : words[i]) {\\n                count[c - \\'a\\']--;\\n                curr += score[c - \\'a\\'];\\n                if(count[c - \\'a\\'] < 0)\\n                    ok = false;\\n            }\\n            if(ok) {\\n                curr += dfs(words, count, score, i + 1);\\n                currMax = max(currMax, curr);\\n            }\\n            \\n            for(auto& c : words[i])\\n                ++count[c - \\'a\\'];\\n        }\\n        return currMax;\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int>count(26);\\n        for(auto& letter : letters)\\n            ++count[letter - \\'a\\'];\\n        return dfs(words, count, score, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306088,
                "title": "1255-find-all-combinations-of-strings-if-valid-inside-letters-find-max-score-return",
                "content": "---\\n\\nIntially it will look like a lot of work, not easy.\\nIt is a lot of implemenation, but we slowly feel it is easy in the end.\\nFinally `takeOrNot` logic is the code to generate all combinations possible.\\n\\n---\\n\\n**Algo**\\n- This is full of implemenation\\n- `takeOrNot` logic - Code is to general all combinations of strings\\n  - Example:\\n    - [\\'a\\', \\'bc\\'. \\'d\\']\\n    - then our combinations might\\n      - `take a, dont take a`\\n        - in each of above case, `take bc, dont take bc`\\n          - again, in each of above case, `take d, dont take d`\\n  - so we might get empty string when we dont take anything \\'\\', or `a`, `abc`, `bc` ... also `abcd`, etc\\n- Now for each combination, check the number chars required\\n  - if we have enough chars in `letters`, then its a good combination, calc score\\n  - return max of all those good combinations\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar maxScoreWords = function(words, letters, score) {\\n    // unique chars\\n    let set = new Set();\\n    for (let w of words)\\n        for (let c of w)\\n            set.add(c)\\n\\n    // score of unique chars\\n    let map = new Map();\\n    for (let c of set)\\n        map.set(c, score[c.charCodeAt() - \\'a\\'.charCodeAt()])\\n\\n    // letter count\\n    let map_letters = new Map();\\n    for (let c of letters)\\n        map_letters.set(c, map_letters.has(c) ? map_letters.get(c) + 1 : 1);\\n\\n    // score of words\\n    let SW = [];\\n    for (let w of words) {\\n        let s = 0;\\n        for (let c of w)\\n            s += map.get(c)\\n        SW.push(s)\\n    }\\n\\n    const sortStr = (s) => s.split(\"\").sort().join(\"\")\\n    const combineStrings_fromArrayAndIndexes = (A, I) => I.reduce((s, i) => (s + A[i]), \\'\\')\\n    const getFreqMapFromStr = (s) => s.split(\"\").reduce((m, c) => (m.set(c, m.has(c) ? m.get(c) + 1 : 1), m), new Map())\\n    const isMapSubOfAnotherMap = (m1, m2) => {\\n        for (let [c, count] of m1)\\n            if (!m2.has(c) || count > m2.get(c))\\n                return false\\n        return true\\n    }\\n\\n    let max1 = -Infinity;\\n    const takeOrNot = (i, take, indexes, A, n) => {\\n        if (i === n) {\\n            if (isMapSubOfAnotherMap(\\n                    getFreqMapFromStr(\\n                        combineStrings_fromArrayAndIndexes(words, indexes)\\n                    ),\\n                    map_letters\\n                )) {\\n                let mm = indexes.reduce((sum, i) => sum + SW[i], 0)\\n                max1 = Math.max(max1, mm);\\n            }\\n            return\\n        }\\n        takeOrNot(i + 1, take, indexes, A, n)\\n        takeOrNot(i + 1, take, [...indexes, i], A, n);\\n    }\\n    takeOrNot(0, true, [], SW, SW.length);\\n    return max1;\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxScoreWords = function(words, letters, score) {\\n    // unique chars\\n    let set = new Set();\\n    for (let w of words)\\n        for (let c of w)\\n            set.add(c)\\n\\n    // score of unique chars\\n    let map = new Map();\\n    for (let c of set)\\n        map.set(c, score[c.charCodeAt() - \\'a\\'.charCodeAt()])\\n\\n    // letter count\\n    let map_letters = new Map();\\n    for (let c of letters)\\n        map_letters.set(c, map_letters.has(c) ? map_letters.get(c) + 1 : 1);\\n\\n    // score of words\\n    let SW = [];\\n    for (let w of words) {\\n        let s = 0;\\n        for (let c of w)\\n            s += map.get(c)\\n        SW.push(s)\\n    }\\n\\n    const sortStr = (s) => s.split(\"\").sort().join(\"\")\\n    const combineStrings_fromArrayAndIndexes = (A, I) => I.reduce((s, i) => (s + A[i]), \\'\\')\\n    const getFreqMapFromStr = (s) => s.split(\"\").reduce((m, c) => (m.set(c, m.has(c) ? m.get(c) + 1 : 1), m), new Map())\\n    const isMapSubOfAnotherMap = (m1, m2) => {\\n        for (let [c, count] of m1)\\n            if (!m2.has(c) || count > m2.get(c))\\n                return false\\n        return true\\n    }\\n\\n    let max1 = -Infinity;\\n    const takeOrNot = (i, take, indexes, A, n) => {\\n        if (i === n) {\\n            if (isMapSubOfAnotherMap(\\n                    getFreqMapFromStr(\\n                        combineStrings_fromArrayAndIndexes(words, indexes)\\n                    ),\\n                    map_letters\\n                )) {\\n                let mm = indexes.reduce((sum, i) => sum + SW[i], 0)\\n                max1 = Math.max(max1, mm);\\n            }\\n            return\\n        }\\n        takeOrNot(i + 1, take, indexes, A, n)\\n        takeOrNot(i + 1, take, [...indexes, i], A, n);\\n    }\\n    takeOrNot(0, true, [], SW, SW.length);\\n    return max1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1281468,
                "title": "c-backtracking-recursion-100-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n int getmax(vector<string>& wd,vector<int>& v,vector<int>& sc,int i){\\n         if(i==wd.size()){\\n             return 0;\\n         }\\n         int ansn = getmax(wd,v,sc,i+1);\\n         \\n         int score = 0;\\n         string str = wd[i];\\n         bool flag = true;\\n         \\n         for(int i=0;i<str.size();i++){\\n             v[str[i]-\\'a\\']--;\\n             score += sc[str[i]-\\'a\\'];\\n             if(v[str[i]-\\'a\\']<0){\\n                 flag = false;\\n             }\\n         }\\n         \\n         int ansy = 0;\\n         if(flag){\\n             ansy = score + getmax(wd,v,sc,i+1); \\n         }\\n         \\n         for(int i=0;i<str.size();i++){\\n             v[str[i]-\\'a\\']++;\\n         }\\n         return max(ansn,ansy);\\n     }\\n    \\n    \\n     int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> v(26,0);\\n        for(int i=0;i<letters.size();i++){\\n           v[letters[i]-\\'a\\']++;\\n        }   \\n        return getmax(words,v,score,0);\\n     }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int getmax(vector<string>& wd,vector<int>& v,vector<int>& sc,int i){\\n         if(i==wd.size()){\\n             return 0;\\n         }\\n         int ansn = getmax(wd,v,sc,i+1);\\n         \\n         int score = 0;\\n         string str = wd[i];\\n         bool flag = true;\\n         \\n         for(int i=0;i<str.size();i++){\\n             v[str[i]-\\'a\\']--;\\n             score += sc[str[i]-\\'a\\'];\\n             if(v[str[i]-\\'a\\']<0){\\n                 flag = false;\\n             }\\n         }\\n         \\n         int ansy = 0;\\n         if(flag){\\n             ansy = score + getmax(wd,v,sc,i+1); \\n         }\\n         \\n         for(int i=0;i<str.size();i++){\\n             v[str[i]-\\'a\\']++;\\n         }\\n         return max(ansn,ansy);\\n     }\\n    \\n    \\n     int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> v(26,0);\\n        for(int i=0;i<letters.size();i++){\\n           v[letters[i]-\\'a\\']++;\\n        }   \\n        return getmax(words,v,score,0);\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215108,
                "title": "c-easy-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // letters is basically frequency array \\n    int solution(vector<string>& words, vector<int>& letters, vector<int>& score,int idx)\\n    {\\n        if(idx == words.size())\\n        {\\n            return 0;\\n        }\\n        // 1 case: when we are not including the word \\n        int sno = 0 + solution(words,letters,score,idx+1);\\n\\n        //2 case: when we are including the word \\n        int sword = 0;\\n        string word = words[idx];\\n        bool flag = true;\\n\\n        for(int i = 0; i < word.length(); i++)\\n        {\\n            if(letters[word[i]-\\'a\\'] == 0)     // frequency of the particular word \\n            {\\n                flag = false;\\n            }\\n            letters[word[i]-\\'a\\']--;\\n            sword += score[word[i]-\\'a\\'];\\n        }\\n        int syes = 0;\\n        if(flag) // if we can include the particular word\\n        {\\n            syes = sword + solution(words,letters,score,idx+1);\\n        }\\n        \\n        // after making the call we need to restore the frequency of the word in the letter array\\n\\n        for(int i = 0; i < word.length(); i++)\\n        {\\n            letters[word[i]-\\'a\\']++;\\n        }\\n\\n        return max(syes,sno);\\n    }\\n\\n\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score)\\n    {\\n        vector<int> freq(26,0);\\n\\n        for(int i = 0; i < letters.size(); i++)\\n        {\\n            freq[letters[i]-\\'a\\']++;\\n        }\\n\\n\\n        return solution(words,freq,score,0);     \\n    }\\n}; \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // letters is basically frequency array \\n    int solution(vector<string>& words, vector<int>& letters, vector<int>& score,int idx)\\n    {\\n        if(idx == words.size())\\n        {\\n            return 0;\\n        }\\n        // 1 case: when we are not including the word \\n        int sno = 0 + solution(words,letters,score,idx+1);\\n\\n        //2 case: when we are including the word \\n        int sword = 0;\\n        string word = words[idx];\\n        bool flag = true;\\n\\n        for(int i = 0; i < word.length(); i++)\\n        {\\n            if(letters[word[i]-\\'a\\'] == 0)     // frequency of the particular word \\n            {\\n                flag = false;\\n            }\\n            letters[word[i]-\\'a\\']--;\\n            sword += score[word[i]-\\'a\\'];\\n        }\\n        int syes = 0;\\n        if(flag) // if we can include the particular word\\n        {\\n            syes = sword + solution(words,letters,score,idx+1);\\n        }\\n        \\n        // after making the call we need to restore the frequency of the word in the letter array\\n\\n        for(int i = 0; i < word.length(); i++)\\n        {\\n            letters[word[i]-\\'a\\']++;\\n        }\\n\\n        return max(syes,sno);\\n    }\\n\\n\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score)\\n    {\\n        vector<int> freq(26,0);\\n\\n        for(int i = 0; i < letters.size(); i++)\\n        {\\n            freq[letters[i]-\\'a\\']++;\\n        }\\n\\n\\n        return solution(words,freq,score,0);     \\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1177488,
                "title": "using-knapsack-java-solution",
                "content": "\\n```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        \\n        int[] freq = new int[26];\\n        \\n        for(int i=0;i<letters.length;i++){\\n            freq[letters[i] - \\'a\\']++;\\n        }\\n        \\n        return solve(words, freq, score, words.length);\\n        \\n    }\\n    \\n    public int solve(String[] words, int[] freq, int[] score, int n){\\n        if(n == 0) return 0;\\n        \\n        if(canTake(words[n-1], freq)){\\n            int[] arr = new int[26];\\n            for(int i=0;i<26;i++)\\n                arr[i] = freq[i];\\n            \\n            int temp = 0;\\n            \\n            for(int i=0;i<words[n-1].length();i++){\\n                arr[words[n-1].charAt(i) - \\'a\\']--;\\n                temp += score[words[n-1].charAt(i) - \\'a\\'];\\n            }\\n            \\n            return Math.max(solve(words, arr, score, n-1) + temp, solve(words, freq, score, n-1));\\n        } else{\\n            return solve(words, freq, score, n-1);\\n        }\\n        \\n        \\n    }\\n    \\n    public boolean canTake(String s1, int[] freq){\\n        int[] temp = new int[26];\\n        \\n        for(int i=0;i<s1.length();i++)\\n            temp[s1.charAt(i) - \\'a\\']++;\\n        \\n        for(int i=0;i<temp.length;i++){\\n            if(temp[i] > freq[i]) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        \\n        int[] freq = new int[26];\\n        \\n        for(int i=0;i<letters.length;i++){\\n            freq[letters[i] - \\'a\\']++;\\n        }\\n        \\n        return solve(words, freq, score, words.length);\\n        \\n    }\\n    \\n    public int solve(String[] words, int[] freq, int[] score, int n){\\n        if(n == 0) return 0;\\n        \\n        if(canTake(words[n-1], freq)){\\n            int[] arr = new int[26];\\n            for(int i=0;i<26;i++)\\n                arr[i] = freq[i];\\n            \\n            int temp = 0;\\n            \\n            for(int i=0;i<words[n-1].length();i++){\\n                arr[words[n-1].charAt(i) - \\'a\\']--;\\n                temp += score[words[n-1].charAt(i) - \\'a\\'];\\n            }\\n            \\n            return Math.max(solve(words, arr, score, n-1) + temp, solve(words, freq, score, n-1));\\n        } else{\\n            return solve(words, freq, score, n-1);\\n        }\\n        \\n        \\n    }\\n    \\n    public boolean canTake(String s1, int[] freq){\\n        int[] temp = new int[26];\\n        \\n        for(int i=0;i<s1.length();i++)\\n            temp[s1.charAt(i) - \\'a\\']++;\\n        \\n        for(int i=0;i<temp.length;i++){\\n            if(temp[i] > freq[i]) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157663,
                "title": "recursion-and-maximum-value-returning",
                "content": "```\\nclass Solution:\\n    def maxScoreWords(self, words, letters, score):\\n        dic = {}\\n        for i in letters:\\n            if(i not in dic):\\n                dic[i] = 1\\n            else:\\n                dic[i] += 1\\n        N = len(words)\\n        max_ = 0\\n        def is_valid(wds, ditc):\\n            for i in wds:\\n                if(i not in ditc or ditc[i] <= 0):\\n                    return False\\n                else:\\n                    ditc[i] -= 1\\n            return True\\n        def add(wds):\\n            ssum = 0\\n            for i in wds:\\n                ssum += score[ord(i) - 97]\\n            return ssum\\n        def rec(sum_, idx, dc):\\n            if(idx == N):\\n                return sum_ \\n            for i in range(idx, N):\\n                main = dict(dc)\\n                #print(\"Before: \",words[i], dc, main)\\n                if(is_valid(words[i], dict(dc))):\\n                    for ind in words[i]:\\n                        dc[ind] -= 1\\n                    #print(\"aftore: \",words[i], dc, main)\\n                    m1 = rec(sum_ + add(words[i]), i+1, dc)\\n                    m2 = rec(sum_, i+1, main)\\n                    return max(m1, m2)\\n            return sum_\\n        return rec(0, 0, dict(dic))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxScoreWords(self, words, letters, score):\\n        dic = {}\\n        for i in letters:\\n            if(i not in dic):\\n                dic[i] = 1\\n            else:\\n                dic[i] += 1\\n        N = len(words)\\n        max_ = 0\\n        def is_valid(wds, ditc):\\n            for i in wds:\\n                if(i not in ditc or ditc[i] <= 0):\\n                    return False\\n                else:\\n                    ditc[i] -= 1\\n            return True\\n        def add(wds):\\n            ssum = 0\\n            for i in wds:\\n                ssum += score[ord(i) - 97]\\n            return ssum\\n        def rec(sum_, idx, dc):\\n            if(idx == N):\\n                return sum_ \\n            for i in range(idx, N):\\n                main = dict(dc)\\n                #print(\"Before: \",words[i], dc, main)\\n                if(is_valid(words[i], dict(dc))):\\n                    for ind in words[i]:\\n                        dc[ind] -= 1\\n                    #print(\"aftore: \",words[i], dc, main)\\n                    m1 = rec(sum_ + add(words[i]), i+1, dc)\\n                    m2 = rec(sum_, i+1, main)\\n                    return max(m1, m2)\\n            return sum_\\n        return rec(0, 0, dict(dic))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136819,
                "title": "java-0ms-100-faster-easy-backtracking-approach",
                "content": "```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        //farr is the frequency array of the letters\\n        int[] farr=new int[score.length];\\n        \\n        for(char ch:letters){\\n            farr[ch-\\'a\\']++;\\n        }\\n        return maxScore(words,score,farr,0);\\n    }\\n    public static int maxScore(String[] words,int[] score,int[] farr,int idx){\\n        if(idx==words.length){\\n            return 0;\\n        }\\n        //word is not include in the subset\\n        int f1=maxScore(words,score,farr,idx+1);\\n        String word=words[idx];\\n        int wscore=0;\\n        boolean flag=true;\\n        //checking the word is valid to come in subset or not\\n        //and count its score\\n        for(int i=0;i<word.length();i++){\\n            char ch=word.charAt(i);\\n            if(farr[ch-\\'a\\']==0){\\n                flag=false;\\n            }\\n            farr[ch-\\'a\\']--;\\n            wscore+=score[ch-\\'a\\'];\\n        }\\n        int f2=0;\\n        //if flag is true then word is valid so we include it in the subset and \\n        //add its score\\n        if(flag){\\n            f2=wscore+maxScore(words,score,farr,idx+1);\\n        }\\n        //backtracking \\n          for(int i=0;i<word.length();i++){\\n            char ch=word.charAt(i); \\n            farr[ch-\\'a\\']++;  \\n        }\\n       return Math.max(f1,f2); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        //farr is the frequency array of the letters\\n        int[] farr=new int[score.length];\\n        \\n        for(char ch:letters){\\n            farr[ch-\\'a\\']++;\\n        }\\n        return maxScore(words,score,farr,0);\\n    }\\n    public static int maxScore(String[] words,int[] score,int[] farr,int idx){\\n        if(idx==words.length){\\n            return 0;\\n        }\\n        //word is not include in the subset\\n        int f1=maxScore(words,score,farr,idx+1);\\n        String word=words[idx];\\n        int wscore=0;\\n        boolean flag=true;\\n        //checking the word is valid to come in subset or not\\n        //and count its score\\n        for(int i=0;i<word.length();i++){\\n            char ch=word.charAt(i);\\n            if(farr[ch-\\'a\\']==0){\\n                flag=false;\\n            }\\n            farr[ch-\\'a\\']--;\\n            wscore+=score[ch-\\'a\\'];\\n        }\\n        int f2=0;\\n        //if flag is true then word is valid so we include it in the subset and \\n        //add its score\\n        if(flag){\\n            f2=wscore+maxScore(words,score,farr,idx+1);\\n        }\\n        //backtracking \\n          for(int i=0;i<word.length();i++){\\n            char ch=word.charAt(i); \\n            farr[ch-\\'a\\']++;  \\n        }\\n       return Math.max(f1,f2); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959988,
                "title": "modularized-clean-readable-backtracking-solution",
                "content": "```\\nclass Solution {\\n  int backtrack(vector<string>::iterator cur, vector<string>::iterator last,\\n\\t\\t\\t\\tvector<int>& letters_remain, unordered_map<string,int>& word_score) {\\n    if (cur == last) return 0;\\n    int ans = 0;\\n    if (enough_letters(*cur, letters_remain)) { // O(c)\\n      remove_letters(*cur, letters_remain);\\n      ans = backtrack(cur + 1, last, letters_remain, word_score) + word_score[*cur];\\n      add_letters(*cur, letters_remain);\\n    }\\n    return max(ans, backtrack(cur+1, last, letters_remain, word_score));\\n  }\\n  \\n  // linear in length of words\\n  unordered_map<string, int> word_scores(vector<string>& words, \\n                                        vector<int>& score) {\\n    unordered_map<string, int> ws;\\n    for (string& word : words) if (!ws.count(word)) {\\n      for (char c : word) ws[word] += score[c - \\'a\\'];\\n    }\\n    return ws;\\n  }\\n  \\n  // linear in letters\\n  vector<int> count_letters(vector<char>& letters) {\\n    vector<int> counts(128, 0);\\n    for (char c : letters) counts[c]++;\\n    return counts;\\n  }\\n  \\n  // linear in str\\n  bool enough_letters(string& str, vector<int>& count) {\\n    remove_letters(str, count);\\n    bool enough = all_of(count.begin(), count.end(), [](int k){return k>=0;});\\n    add_letters(str, count);\\n    return enough;\\n  }\\n  \\n  // linear in str\\n  void remove_letters(string& str, vector<int>& count) {\\n    for (char c : str) count[c]--;\\n  }\\n  \\n  // linear in str\\n  void add_letters(string& str, vector<int>& count) {\\n    for (char c : str) count[c]++;\\n  }\\n  \\npublic:\\n  // Complexity: O(2^W * w + wW + L) = O(w * 2^W + L)\\n  // Space: O(wW + W) = O(W(w+1)) = O(Ww)\\n  // W = size of words\\n  // w = max length of a word (words[i])\\n  // L = length of letters\\n  int maxScoreWords(vector<string>& words, vector<char>& letters, \\n                    vector<int>& score) {\\n    unordered_map<string, int> word_scores_ = word_scores(words, score);\\n    vector<int> letter_counts = count_letters(letters);\\n    return backtrack(words.begin(), words.end(), letter_counts, word_scores_);\\n  }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  int backtrack(vector<string>::iterator cur, vector<string>::iterator last,\\n\\t\\t\\t\\tvector<int>& letters_remain, unordered_map<string,int>& word_score) {\\n    if (cur == last) return 0;\\n    int ans = 0;\\n    if (enough_letters(*cur, letters_remain)) { // O(c)\\n      remove_letters(*cur, letters_remain);\\n      ans = backtrack(cur + 1, last, letters_remain, word_score) + word_score[*cur];\\n      add_letters(*cur, letters_remain);\\n    }\\n    return max(ans, backtrack(cur+1, last, letters_remain, word_score));\\n  }\\n  \\n  // linear in length of words\\n  unordered_map<string, int> word_scores(vector<string>& words, \\n                                        vector<int>& score) {\\n    unordered_map<string, int> ws;\\n    for (string& word : words) if (!ws.count(word)) {\\n      for (char c : word) ws[word] += score[c - \\'a\\'];\\n    }\\n    return ws;\\n  }\\n  \\n  // linear in letters\\n  vector<int> count_letters(vector<char>& letters) {\\n    vector<int> counts(128, 0);\\n    for (char c : letters) counts[c]++;\\n    return counts;\\n  }\\n  \\n  // linear in str\\n  bool enough_letters(string& str, vector<int>& count) {\\n    remove_letters(str, count);\\n    bool enough = all_of(count.begin(), count.end(), [](int k){return k>=0;});\\n    add_letters(str, count);\\n    return enough;\\n  }\\n  \\n  // linear in str\\n  void remove_letters(string& str, vector<int>& count) {\\n    for (char c : str) count[c]--;\\n  }\\n  \\n  // linear in str\\n  void add_letters(string& str, vector<int>& count) {\\n    for (char c : str) count[c]++;\\n  }\\n  \\npublic:\\n  // Complexity: O(2^W * w + wW + L) = O(w * 2^W + L)\\n  // Space: O(wW + W) = O(W(w+1)) = O(Ww)\\n  // W = size of words\\n  // w = max length of a word (words[i])\\n  // L = length of letters\\n  int maxScoreWords(vector<string>& words, vector<char>& letters, \\n                    vector<int>& score) {\\n    unordered_map<string, int> word_scores_ = word_scores(words, score);\\n    vector<int> letter_counts = count_letters(letters);\\n    return backtrack(words.begin(), words.end(), letter_counts, word_scores_);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889766,
                "title": "simple-python-backtracking-solution",
                "content": "**There are two choices for each word, take it or don\\'t take**\\n```\\nclass Solution:\\n\\tdef maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n\\t\\t\\n\\t\\tdef foo(i, words, counts, score, profit):\\n\\t\\t\\tnonlocal res\\n\\t\\t\\t\\n\\t\\t\\tif i==len(words):\\n\\t\\t\\t\\tres = max(res, profit)\\n\\t\\t\\t\\treturn\\n\\t\\t\\t\\n            # if possible take the word at index i\\n\\t\\t\\tif all(counts[w] >= words[i][w] for w in words[i].keys()):\\n\\t\\t\\t\\ts = 0\\n\\t\\t\\t\\tfor w in words[i].keys():\\n\\t\\t\\t\\t\\tcounts[w] -= words[i][w]\\n\\t\\t\\t\\t\\ts += words[i][w] * score[ord(w)-ord(\\'a\\')]\\n\\n\\t\\t\\t\\tfoo(i+1, words, counts, score, profit+s)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor w in words[i].keys():                    \\n\\t\\t\\t\\t\\tcounts[w] += words[i][w]\\n\\t\\t\\t\\n            # go deep without taking the word at index i\\n\\t\\t\\tfoo(i+1, words, counts, score, profit)\\n\\t\\t\\t\\t\\t\\n\\t\\tres = 0\\n\\t\\twords = [collections.Counter(word) for word in words]\\n\\t\\tcounts = collections.Counter(letters)\\n        profit = 0\\n\\t\\tfoo(0, words, counts, score, profit)\\n\\t\\treturn res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n\\tdef maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n\\t\\t\\n\\t\\tdef foo(i, words, counts, score, profit):\\n\\t\\t\\tnonlocal res\\n\\t\\t\\t\\n\\t\\t\\tif i==len(words):\\n\\t\\t\\t\\tres = max(res, profit)\\n\\t\\t\\t\\treturn\\n\\t\\t\\t\\n            # if possible take the word at index i\\n\\t\\t\\tif all(counts[w] >= words[i][w] for w in words[i].keys()):\\n\\t\\t\\t\\ts = 0\\n\\t\\t\\t\\tfor w in words[i].keys():\\n\\t\\t\\t\\t\\tcounts[w] -= words[i][w]\\n\\t\\t\\t\\t\\ts += words[i][w] * score[ord(w)-ord(\\'a\\')]\\n\\n\\t\\t\\t\\tfoo(i+1, words, counts, score, profit+s)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor w in words[i].keys():                    \\n\\t\\t\\t\\t\\tcounts[w] += words[i][w]\\n\\t\\t\\t\\n            # go deep without taking the word at index i\\n\\t\\t\\tfoo(i+1, words, counts, score, profit)\\n\\t\\t\\t\\t\\t\\n\\t\\tres = 0\\n\\t\\twords = [collections.Counter(word) for word in words]\\n\\t\\tcounts = collections.Counter(letters)\\n        profit = 0\\n\\t\\tfoo(0, words, counts, score, profit)\\n\\t\\treturn res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 656436,
                "title": "simple-java-recursive-approach-beats-95-runtime-and-100-memory",
                "content": "```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int[] freq = new int[26];\\n        for(char letter : letters)\\n            freq[letter-\\'a\\']++;\\n        \\n        return maxScoreWords(words, 0, freq, score);\\n        \\n    }\\n    \\n    int getScore(String word, int[] freq, int[] score) {\\n        int sum=0;\\n        for(int i =0 ; i< word.length() ; i++) {\\n            if(freq[word.charAt(i) -\\'a\\'] == 0)\\n                return -1;\\n            else {\\n                freq[word.charAt(i) -\\'a\\']--;\\n                sum+=score[word.charAt(i)-\\'a\\'];\\n            }\\n        }\\n        return sum;\\n    }\\n    \\n    int maxScoreWords(String[] words, int i,  int[] freq, int[] score) {\\n        if(i == words.length)\\n            return 0;\\n        int[] uFreq = new int[26];\\n        for(int j=0 ; j < 26 ; j++) {\\n            uFreq[j]=freq[j];\\n        }\\n        \\n        int cScore = getScore(words[i], uFreq, score);\\n        \\n        if(cScore == -1) {\\n            return maxScoreWords(words, i+1, freq, score);       \\n        } else {\\n            return Math.max(maxScoreWords(words, i+1, freq, score), cScore +maxScoreWords(words, i+1, uFreq, score));\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int[] freq = new int[26];\\n        for(char letter : letters)\\n            freq[letter-\\'a\\']++;\\n        \\n        return maxScoreWords(words, 0, freq, score);\\n        \\n    }\\n    \\n    int getScore(String word, int[] freq, int[] score) {\\n        int sum=0;\\n        for(int i =0 ; i< word.length() ; i++) {\\n            if(freq[word.charAt(i) -\\'a\\'] == 0)\\n                return -1;\\n            else {\\n                freq[word.charAt(i) -\\'a\\']--;\\n                sum+=score[word.charAt(i)-\\'a\\'];\\n            }\\n        }\\n        return sum;\\n    }\\n    \\n    int maxScoreWords(String[] words, int i,  int[] freq, int[] score) {\\n        if(i == words.length)\\n            return 0;\\n        int[] uFreq = new int[26];\\n        for(int j=0 ; j < 26 ; j++) {\\n            uFreq[j]=freq[j];\\n        }\\n        \\n        int cScore = getScore(words[i], uFreq, score);\\n        \\n        if(cScore == -1) {\\n            return maxScoreWords(words, i+1, freq, score);       \\n        } else {\\n            return Math.max(maxScoreWords(words, i+1, freq, score), cScore +maxScoreWords(words, i+1, uFreq, score));\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606015,
                "title": "simple-python-recursion-solution-with-comments",
                "content": "```\\nclass Solution(object):\\n    def maxScoreWords(self, words, letters, score):\\n        \"\"\"\\n        :type words: List[str]\\n        :type letters: List[str]\\n        :type score: List[int]\\n        :rtype: int\\n        \"\"\"\\n        total={} # store frequency of all characters in letters\\n        for i in letters:\\n            if i in total:\\n                total[i]+=1\\n            else:\\n                total[i]=1\\n        a=[] # stores freqency of all charcters in words\\n        for i in words:\\n            d={}\\n            for j in i:\\n                if j in d:\\n                    d[j]+=1\\n                else:\\n                    d[j]=1\\n            a.append(d)\\n        def sol (count,n):\\n            if n==-1:\\n                return 0\\n            if sum(count.values())==0:\\n                return 0\\n            pos=1 # to check if adding current element is possible or not\\n            for i in a[n]:\\n                if i in count:\\n                    if count[i]<a[n][i]:\\n                        pos=0\\n                        break\\n                else:\\n                    pos=0 \\n                    break\\n            if pos==0:\\n                return sol(count,n-1)\\n            else:\\n                x=dict(count)\\n                s=0\\n                for i in a[n]:\\n                    s+=a[n][i]*score[ord(i)-97] # calculate score by adding current string\\n                    x[i]-=a[n][i] # uptade the count\\n                return max(sol(count,n-1),sol(x,n-1)+s)\\n        ans=sol(total,len(a)-1)\\n        return (ans)\\n\\t\\t```\\n\\t\\tconcept is same as classic knapsack problem",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxScoreWords(self, words, letters, score):\\n        \"\"\"\\n        :type words: List[str]\\n        :type letters: List[str]\\n        :type score: List[int]\\n        :rtype: int\\n        \"\"\"\\n        total={} # store frequency of all characters in letters\\n        for i in letters:\\n            if i in total:\\n                total[i]+=1\\n            else:\\n                total[i]=1\\n        a=[] # stores freqency of all charcters in words\\n        for i in words:\\n            d={}\\n            for j in i:\\n                if j in d:\\n                    d[j]+=1\\n                else:\\n                    d[j]=1\\n            a.append(d)\\n        def sol (count,n):\\n            if n==-1:\\n                return 0\\n            if sum(count.values())==0:\\n                return 0\\n            pos=1 # to check if adding current element is possible or not\\n            for i in a[n]:\\n                if i in count:\\n                    if count[i]<a[n][i]:\\n                        pos=0\\n                        break\\n                else:\\n                    pos=0 \\n                    break\\n            if pos==0:\\n                return sol(count,n-1)\\n            else:\\n                x=dict(count)\\n                s=0\\n                for i in a[n]:\\n                    s+=a[n][i]*score[ord(i)-97] # calculate score by adding current string\\n                    x[i]-=a[n][i] # uptade the count\\n                return max(sol(count,n-1),sol(x,n-1)+s)\\n        ans=sol(total,len(a)-1)\\n        return (ans)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 582688,
                "title": "simple-java-solution-using-backtracking",
                "content": "```\\nclass Solution {\\n    int res = 0;\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int[] table = new int[26];\\n        for(char c : letters)\\n            table[c - \\'a\\']++;\\n        \\n        \\n        helper(words, score, table, table, 0, 0);\\n        \\n        return res;\\n    }\\n    \\n    public void helper(String[] words, int[] score, int[] table, int[] curr, int i, int currScore){\\n        res = Math.max(res, currScore);\\n        \\n        for(; i < words.length; i++){\\n            String word = words[i];\\n            int[] temp = new int[26];\\n            int val = currScore;\\n            for(int j = 0; j < 26; j++){\\n                temp[j] = curr[j];\\n            }\\n            boolean flag = true;\\n            for(char c : word.toCharArray()){\\n                if(temp[c - \\'a\\'] == 0){\\n                    flag = false;\\n                    break;\\n                }\\n                temp[c - \\'a\\']--;\\n                val += score[c - \\'a\\'];\\n            }\\n            if(!flag)\\n                continue;\\n            helper(words, score, table, temp, i + 1, val);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int[] table = new int[26];\\n        for(char c : letters)\\n            table[c - \\'a\\']++;\\n        \\n        \\n        helper(words, score, table, table, 0, 0);\\n        \\n        return res;\\n    }\\n    \\n    public void helper(String[] words, int[] score, int[] table, int[] curr, int i, int currScore){\\n        res = Math.max(res, currScore);\\n        \\n        for(; i < words.length; i++){\\n            String word = words[i];\\n            int[] temp = new int[26];\\n            int val = currScore;\\n            for(int j = 0; j < 26; j++){\\n                temp[j] = curr[j];\\n            }\\n            boolean flag = true;\\n            for(char c : word.toCharArray()){\\n                if(temp[c - \\'a\\'] == 0){\\n                    flag = false;\\n                    break;\\n                }\\n                temp[c - \\'a\\']--;\\n                val += score[c - \\'a\\'];\\n            }\\n            if(!flag)\\n                continue;\\n            helper(words, score, table, temp, i + 1, val);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566208,
                "title": "simple-c-code-dfs-beating-93",
                "content": "```\\nint maxScoreWords_(vector<vector<int>>& wordCnt, vector<int>& wordVal, int* charCnt, int sIdx) {\\n\\n\\tif (sIdx >= wordCnt.size()) return 0;\\n\\n\\tint maxVal = 0;\\n\\n\\tfor (int i = sIdx; i < wordCnt.size(); ++i) {\\n\\t\\tbool check = true;\\n\\t\\tfor (int j = 0; j < 26; ++j) {\\n\\t\\t\\tif (wordCnt[i][j] > charCnt[j]) {\\n\\t\\t\\t\\tcheck = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (check) {\\n\\t\\t\\tfor (int j = 0; j < 26; ++j) charCnt[j] -= wordCnt[i][j];\\n\\t\\t\\tmaxVal = max(maxVal, wordVal[i] + maxScoreWords_(wordCnt, wordVal, charCnt, i + 1));\\n\\t\\t\\tfor (int j = 0; j < 26; ++j) charCnt[j] += wordCnt[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxVal;\\n}\\n\\nint maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n\\n\\tvector<int> wordVal(words.size(), 0);\\n\\tvector<vector<int>> wordCnt(words.size(), vector<int>(26, 0));\\n\\tfor (int i = 0; i < words.size(); ++i) {\\n\\t\\tfor (char&c : words[i]) {\\n\\t\\t\\twordVal[i] += score[c - \\'a\\'];\\n\\t\\t\\twordCnt[i][c - \\'a\\']++;\\n\\t\\t}\\n\\t}\\n\\tint charCnt[26] = {0};\\n\\tfor (char& letter : letters) ++charCnt[letter - \\'a\\'];\\n\\n\\treturn maxScoreWords_(wordCnt, wordVal, charCnt, 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxScoreWords_(vector<vector<int>>& wordCnt, vector<int>& wordVal, int* charCnt, int sIdx) {\\n\\n\\tif (sIdx >= wordCnt.size()) return 0;\\n\\n\\tint maxVal = 0;\\n\\n\\tfor (int i = sIdx; i < wordCnt.size(); ++i) {\\n\\t\\tbool check = true;\\n\\t\\tfor (int j = 0; j < 26; ++j) {\\n\\t\\t\\tif (wordCnt[i][j] > charCnt[j]) {\\n\\t\\t\\t\\tcheck = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (check) {\\n\\t\\t\\tfor (int j = 0; j < 26; ++j) charCnt[j] -= wordCnt[i][j];\\n\\t\\t\\tmaxVal = max(maxVal, wordVal[i] + maxScoreWords_(wordCnt, wordVal, charCnt, i + 1));\\n\\t\\t\\tfor (int j = 0; j < 26; ++j) charCnt[j] += wordCnt[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxVal;\\n}\\n\\nint maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n\\n\\tvector<int> wordVal(words.size(), 0);\\n\\tvector<vector<int>> wordCnt(words.size(), vector<int>(26, 0));\\n\\tfor (int i = 0; i < words.size(); ++i) {\\n\\t\\tfor (char&c : words[i]) {\\n\\t\\t\\twordVal[i] += score[c - \\'a\\'];\\n\\t\\t\\twordCnt[i][c - \\'a\\']++;\\n\\t\\t}\\n\\t}\\n\\tint charCnt[26] = {0};\\n\\tfor (char& letter : letters) ++charCnt[letter - \\'a\\'];\\n\\n\\treturn maxScoreWords_(wordCnt, wordVal, charCnt, 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 473569,
                "title": "java-2ms-100-memory-easy-to-read-explained-with-comments",
                "content": "```\\npublic int maxScoreWords(String[] words, char[] letters, int[] score) {\\n\\n\\t\\t// sorting with decreasing order of score of word\\n\\t\\tComparator<String> cmp = new Comparator<String>() {\\n\\t\\t\\tpublic int compare(String obj1, String obj2) {\\n\\t\\t\\t\\treturn calc_score(obj2, score) - calc_score(obj1, score);\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\tArrays.sort(words, cmp);\\n\\t\\tint[] char_count = new int[26];\\n\\n\\t\\tfor (char ch : letters)\\n\\t\\t\\tchar_count[ch - \\'a\\']++;\\n\\n\\t\\treturn maxScore(words, char_count, score, 0);\\n\\t}\\n\\n\\tprivate int maxScore(String[] words, int[] letters, int[] score, int vidx) {\\n\\t\\tif (vidx == words.length || !chars_left(letters))\\n\\t\\t\\treturn 0;\\n\\t\\tint rv = 0;\\n\\t\\tif (isPossible(words[vidx], letters)) {\\n\\t\\t\\tapply(words[vidx], letters);\\n\\t\\t\\trv = calc_score(words[vidx], score) + maxScore(words, letters, score, vidx + 1);\\n\\t\\t\\tremove(words[vidx], letters);\\n\\t\\t}\\n\\t\\trv = Math.max(rv, maxScore(words, letters, score, vidx + 1));\\n\\n\\t\\treturn rv;\\n\\t}\\n\\n\\t// utility function to check weather it is possible to form the word or not.\\n\\tpublic boolean isPossible(String word, int[] chars) {\\n\\t\\tapply(word, chars);\\n\\t\\tboolean isPossible = true;\\n\\t\\tfor (int val : chars) {\\n\\t\\t\\tif (val < 0)\\n\\t\\t\\t\\tisPossible = false;\\n\\t\\t}\\n\\t\\tremove(word, chars);\\n\\n\\t\\treturn isPossible;\\n\\t}\\n\\n\\t// function to calculate the score of a given word\\n\\tpublic int calc_score(String word, int[] score) {\\n\\t\\tint sc = 0;\\n\\n\\t\\tfor (int i = 0; i < word.length(); ++i) {\\n\\t\\t\\tsc += score[word.charAt(i) - \\'a\\'];\\n\\t\\t}\\n\\n\\t\\treturn sc;\\n\\t}\\n\\n\\t// utility function to check if there are any more characters\\n\\tpublic boolean chars_left(int[] letters) {\\n\\t\\tfor (int val : letters)\\n\\t\\t\\tif (val > 0)\\n\\t\\t\\t\\treturn true;\\n\\t\\treturn false;\\n\\t}\\n\\n\\t// using the character to form words\\n\\tprivate void remove(String word, int[] chars) {\\n\\t\\tfor (int i = 0; i < word.length(); ++i) {\\n\\t\\t\\tchars[word.charAt(i) - \\'a\\']++;\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// removing the effect of usd word\\n\\tprivate void apply(String word, int[] chars) {\\n\\t\\tfor (int i = 0; i < word.length(); ++i) {\\n\\t\\t\\tchars[word.charAt(i) - \\'a\\']--;\\n\\t\\t}\\n\\t}\\n```\\n\\nresults can be cached using bit masking to improve the search time.",
                "solutionTags": [],
                "code": "```\\npublic int maxScoreWords(String[] words, char[] letters, int[] score) {\\n\\n\\t\\t// sorting with decreasing order of score of word\\n\\t\\tComparator<String> cmp = new Comparator<String>() {\\n\\t\\t\\tpublic int compare(String obj1, String obj2) {\\n\\t\\t\\t\\treturn calc_score(obj2, score) - calc_score(obj1, score);\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\tArrays.sort(words, cmp);\\n\\t\\tint[] char_count = new int[26];\\n\\n\\t\\tfor (char ch : letters)\\n\\t\\t\\tchar_count[ch - \\'a\\']++;\\n\\n\\t\\treturn maxScore(words, char_count, score, 0);\\n\\t}\\n\\n\\tprivate int maxScore(String[] words, int[] letters, int[] score, int vidx) {\\n\\t\\tif (vidx == words.length || !chars_left(letters))\\n\\t\\t\\treturn 0;\\n\\t\\tint rv = 0;\\n\\t\\tif (isPossible(words[vidx], letters)) {\\n\\t\\t\\tapply(words[vidx], letters);\\n\\t\\t\\trv = calc_score(words[vidx], score) + maxScore(words, letters, score, vidx + 1);\\n\\t\\t\\tremove(words[vidx], letters);\\n\\t\\t}\\n\\t\\trv = Math.max(rv, maxScore(words, letters, score, vidx + 1));\\n\\n\\t\\treturn rv;\\n\\t}\\n\\n\\t// utility function to check weather it is possible to form the word or not.\\n\\tpublic boolean isPossible(String word, int[] chars) {\\n\\t\\tapply(word, chars);\\n\\t\\tboolean isPossible = true;\\n\\t\\tfor (int val : chars) {\\n\\t\\t\\tif (val < 0)\\n\\t\\t\\t\\tisPossible = false;\\n\\t\\t}\\n\\t\\tremove(word, chars);\\n\\n\\t\\treturn isPossible;\\n\\t}\\n\\n\\t// function to calculate the score of a given word\\n\\tpublic int calc_score(String word, int[] score) {\\n\\t\\tint sc = 0;\\n\\n\\t\\tfor (int i = 0; i < word.length(); ++i) {\\n\\t\\t\\tsc += score[word.charAt(i) - \\'a\\'];\\n\\t\\t}\\n\\n\\t\\treturn sc;\\n\\t}\\n\\n\\t// utility function to check if there are any more characters\\n\\tpublic boolean chars_left(int[] letters) {\\n\\t\\tfor (int val : letters)\\n\\t\\t\\tif (val > 0)\\n\\t\\t\\t\\treturn true;\\n\\t\\treturn false;\\n\\t}\\n\\n\\t// using the character to form words\\n\\tprivate void remove(String word, int[] chars) {\\n\\t\\tfor (int i = 0; i < word.length(); ++i) {\\n\\t\\t\\tchars[word.charAt(i) - \\'a\\']++;\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// removing the effect of usd word\\n\\tprivate void apply(String word, int[] chars) {\\n\\t\\tfor (int i = 0; i < word.length(); ++i) {\\n\\t\\t\\tchars[word.charAt(i) - \\'a\\']--;\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 466457,
                "title": "c-bit-masking",
                "content": "```\\nclass Solution {\\n    unordered_map<char, int > mp1,mp2;\\n    int cal(string s,  vector<int>& score) {\\n        int ans = 0;\\n        for(int i=0;i<s.size();i++) {\\n            if(mp2[s[i]]) {\\n                mp2[s[i]]--;\\n                ans+=score[s[i]-\\'a\\'];\\n            } else {\\n                ans=0;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        if(words.empty() || letters.empty() || score.empty()) return 0;\\n        for(int i = 0; i < letters.size(); i++) {\\n            mp1[letters[i]]++;\\n            mp2[letters[i]]++;\\n        }\\n        \\n        int ans = 0;\\n        int len = words.size();\\n        int mask = (1<<len) - 1;\\n        \\n        for(int i=0;i<=mask;i++) {\\n            int val = 0;\\n            for(int j=0;j<len;j++) {\\n                if(i &(1<<j)) {\\n                    val += cal(words[j], score);\\n                }\\n            }\\n            ans = max(ans,val);\\n            mp2 = mp1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_map<char, int > mp1,mp2;\\n    int cal(string s,  vector<int>& score) {\\n        int ans = 0;\\n        for(int i=0;i<s.size();i++) {\\n            if(mp2[s[i]]) {\\n                mp2[s[i]]--;\\n                ans+=score[s[i]-\\'a\\'];\\n            } else {\\n                ans=0;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        if(words.empty() || letters.empty() || score.empty()) return 0;\\n        for(int i = 0; i < letters.size(); i++) {\\n            mp1[letters[i]]++;\\n            mp2[letters[i]]++;\\n        }\\n        \\n        int ans = 0;\\n        int len = words.size();\\n        int mask = (1<<len) - 1;\\n        \\n        for(int i=0;i<=mask;i++) {\\n            int val = 0;\\n            for(int j=0;j<len;j++) {\\n                if(i &(1<<j)) {\\n                    val += cal(words[j], score);\\n                }\\n            }\\n            ans = max(ans,val);\\n            mp2 = mp1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451438,
                "title": "another-java-solution-2-n-k",
                "content": "```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        \\n        if( words == null || letters == null || score == null ) return 0;\\n        if( words.length == 0 || letters.length == 0 || score.length == 0) return 0;\\n        int[] freq = new int[26];\\n        for(Character c : letters) {\\n            freq[c-\\'a\\']++;\\n        }\\n        return process(words, 0, score,freq);        \\n    }\\n    \\n    \\n    private int process(String[] words, int index,  int[] score, int[] freq ){\\n        if(index == words.length) return 0;\\n\\n        int val=0;\\n        if( !can_accommodate(freq, words[index]) ){\\n            val = process( words, index+1, score,freq);\\n        }else{\\n            int without = process(words, index+1, score, freq);\\n            val = try_accommodate(freq, words[index], score) +   process(words, index+1, score, freq);\\n            update_freq(freq, words[index]);\\n            val = Math.max(val, without);\\n        }    \\n        return val;    \\n    }  \\n    private void update_freq(int[] freq, String str){\\n        for(Character c : str.toCharArray()){\\n            freq[c-\\'a\\']++;\\n        }\\n    }\\n    private boolean can_accommodate(int[] freq, String str){\\n        int[] tmp = new int[26];\\n        for(Character c : str.toCharArray()) {\\n            tmp[c-\\'a\\']++;\\n        }\\n        for(Character c : str.toCharArray()){\\n            if(freq[c-\\'a\\']==0 || tmp[c-\\'a\\'] > freq[c-\\'a\\'] ) return false;\\n        }\\n        return true;\\n    }\\n    \\n    private int try_accommodate(int[] freq, String str, int[] score) {\\n        int acc = 0;\\n        for(Character c : str.toCharArray()){\\n            acc += score[c-\\'a\\'];\\n            freq[c-\\'a\\']--;\\n        }\\n        return acc;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        \\n        if( words == null || letters == null || score == null ) return 0;\\n        if( words.length == 0 || letters.length == 0 || score.length == 0) return 0;\\n        int[] freq = new int[26];\\n        for(Character c : letters) {\\n            freq[c-\\'a\\']++;\\n        }\\n        return process(words, 0, score,freq);        \\n    }\\n    \\n    \\n    private int process(String[] words, int index,  int[] score, int[] freq ){\\n        if(index == words.length) return 0;\\n\\n        int val=0;\\n        if( !can_accommodate(freq, words[index]) ){\\n            val = process( words, index+1, score,freq);\\n        }else{\\n            int without = process(words, index+1, score, freq);\\n            val = try_accommodate(freq, words[index], score) +   process(words, index+1, score, freq);\\n            update_freq(freq, words[index]);\\n            val = Math.max(val, without);\\n        }    \\n        return val;    \\n    }  \\n    private void update_freq(int[] freq, String str){\\n        for(Character c : str.toCharArray()){\\n            freq[c-\\'a\\']++;\\n        }\\n    }\\n    private boolean can_accommodate(int[] freq, String str){\\n        int[] tmp = new int[26];\\n        for(Character c : str.toCharArray()) {\\n            tmp[c-\\'a\\']++;\\n        }\\n        for(Character c : str.toCharArray()){\\n            if(freq[c-\\'a\\']==0 || tmp[c-\\'a\\'] > freq[c-\\'a\\'] ) return false;\\n        }\\n        return true;\\n    }\\n    \\n    private int try_accommodate(int[] freq, String str, int[] score) {\\n        int acc = 0;\\n        for(Character c : str.toCharArray()){\\n            acc += score[c-\\'a\\'];\\n            freq[c-\\'a\\']--;\\n        }\\n        return acc;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443954,
                "title": "c-bruteforce",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        int max_ans = 0;\\n        int n = words.size();\\n        \\n        int letr[26] = {0};\\n        \\n        for(int i=0;i<letters.size();i++)\\n            letr[letters[i]-\\'a\\']++;\\n        \\n        for(int i=0;i<(1<<n);i++){\\n            \\n            int req[26] = {0};\\n            int lans = 0;\\n            \\n            for(int j=0;j<n;j++){\\n                if(i&(1<<j))\\n                {\\n                    for(int k=0;k<words[j].size();k++)\\n                        req[words[j][k]-\\'a\\']++;\\n                }\\n            }\\n            for(int j=0;j<26;j++){\\n                if(letr[j] >= req[j] )\\n                    lans += score[j]*req[j];\\n                else\\n                    lans = -9999999;\\n            }\\n            max_ans = max(max_ans,lans);\\n        }\\n        return max_ans;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        int max_ans = 0;\\n        int n = words.size();\\n        \\n        int letr[26] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 441893,
                "title": "dfs-backtracking-java",
                "content": "```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c: letters){\\n            map.put(c, map.getOrDefault(c, 0)+1);\\n        }\\n        \\n        return findMaxScore(words, map, score, 0);\\n    }\\n    \\n    \\n    public int findMaxScore(String[] words, Map<Character, Integer> map, int[] score, int index){\\n        \\n        if(index>=words.length){\\n            return 0;\\n        }\\n        \\n        int res = 0;\\n        \\n        boolean isvalid = true;\\n        int temp = 0;\\n        for(int i=0;i<words[index].length();i++){\\n            char c = words[index].charAt(i);\\n            temp += score[c-\\'a\\'];\\n            map.put(c, map.getOrDefault(c, 0)-1);\\n            if(map.get(c)<0){\\n                isvalid = false;\\n            }\\n        }\\n        \\n        if(isvalid){\\n            int next_max = findMaxScore(words, map, score, index+1);\\n            res = Math.max(next_max+temp, res);\\n        }\\n        for(int i=0;i<words[index].length();i++){\\n            char c = words[index].charAt(i);\\n            map.put(c, map.getOrDefault(c, 0)+1);\\n        }\\n        \\n        int next_max = findMaxScore(words, map, score, index+1);\\n        res = Math.max(next_max, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c: letters){\\n            map.put(c, map.getOrDefault(c, 0)+1);\\n        }\\n        \\n        return findMaxScore(words, map, score, 0);\\n    }\\n    \\n    \\n    public int findMaxScore(String[] words, Map<Character, Integer> map, int[] score, int index){\\n        \\n        if(index>=words.length){\\n            return 0;\\n        }\\n        \\n        int res = 0;\\n        \\n        boolean isvalid = true;\\n        int temp = 0;\\n        for(int i=0;i<words[index].length();i++){\\n            char c = words[index].charAt(i);\\n            temp += score[c-\\'a\\'];\\n            map.put(c, map.getOrDefault(c, 0)-1);\\n            if(map.get(c)<0){\\n                isvalid = false;\\n            }\\n        }\\n        \\n        if(isvalid){\\n            int next_max = findMaxScore(words, map, score, index+1);\\n            res = Math.max(next_max+temp, res);\\n        }\\n        for(int i=0;i<words[index].length();i++){\\n            char c = words[index].charAt(i);\\n            map.put(c, map.getOrDefault(c, 0)+1);\\n        }\\n        \\n        int next_max = findMaxScore(words, map, score, index+1);\\n        res = Math.max(next_max, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439598,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int MaxScoreWords(string[] words, char[] letters, int[] score) \\n    {\\n        var allFreq = GetFreq(new string(letters));\\n        var wordToFreq = new Dictionary<string, int[]>();\\n        foreach(var word in words) wordToFreq[word] = GetFreq(word);\\n        int maxScore = 0, len = 100; \\n        var dp = new List<int[]>[len];\\n        dp[0] = new List<int[]>(){new int[26]};\\n        foreach(var word in words)\\n        {\\n            for(int i = len - 1 - word.Length; i >= 0; i--)\\n            {\\n                if(dp[i] != null)\\n                {\\n                    foreach(var currFreq in dp[i])\\n                    {\\n                        var newFreq = AddCharFreq(currFreq, wordToFreq[word]);\\n                        if(IsGreaterOrEqueal(allFreq, newFreq))\\n                        {\\n                            var newIndex = newFreq.Sum();\\n                            if(dp[newIndex] == null)\\n                                dp[newIndex] = new List<int[]>();\\n                            dp[newIndex].Add(newFreq);\\n                            maxScore = Math.Max(maxScore, GetScore(newFreq, score));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return maxScore;\\n    }\\n    \\n    private int GetScore(int[] freq, int[] score)\\n    {\\n        var result = 0;\\n        for(int i = 0; i < 26; i++)\\n            result += freq[i] * score[i];\\n        return result;\\n    }\\n    \\n    private int[] GetFreq(string word)\\n    {\\n        var result = new int[26];\\n            foreach(var ch in word)\\n                result[ch - \\'a\\']++;\\n        return result;\\n    }\\n    \\n    private int[] AddCharFreq(int[] f1, int[] f2)\\n    {\\n        var result = new int[26];\\n        for(int i = 0; i < 26; i++)\\n            result[i] = f1[i] + f2[i];\\n        return result;\\n    }\\n    \\n    private bool IsGreaterOrEqueal(int[] f1, int[] f2)\\n    {\\n        for(int i = 0; i < 26; i++)\\n            if(f1[i] < f2[i])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int MaxScoreWords(string[] words, char[] letters, int[] score) \\n    {\\n        var allFreq = GetFreq(new string(letters));\\n        var wordToFreq = new Dictionary<string, int[]>();\\n        foreach(var word in words) wordToFreq[word] = GetFreq(word);\\n        int maxScore = 0, len = 100; \\n        var dp = new List<int[]>[len];\\n        dp[0] = new List<int[]>(){new int[26]};\\n        foreach(var word in words)\\n        {\\n            for(int i = len - 1 - word.Length; i >= 0; i--)\\n            {\\n                if(dp[i] != null)\\n                {\\n                    foreach(var currFreq in dp[i])\\n                    {\\n                        var newFreq = AddCharFreq(currFreq, wordToFreq[word]);\\n                        if(IsGreaterOrEqueal(allFreq, newFreq))\\n                        {\\n                            var newIndex = newFreq.Sum();\\n                            if(dp[newIndex] == null)\\n                                dp[newIndex] = new List<int[]>();\\n                            dp[newIndex].Add(newFreq);\\n                            maxScore = Math.Max(maxScore, GetScore(newFreq, score));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return maxScore;\\n    }\\n    \\n    private int GetScore(int[] freq, int[] score)\\n    {\\n        var result = 0;\\n        for(int i = 0; i < 26; i++)\\n            result += freq[i] * score[i];\\n        return result;\\n    }\\n    \\n    private int[] GetFreq(string word)\\n    {\\n        var result = new int[26];\\n            foreach(var ch in word)\\n                result[ch - \\'a\\']++;\\n        return result;\\n    }\\n    \\n    private int[] AddCharFreq(int[] f1, int[] f2)\\n    {\\n        var result = new int[26];\\n        for(int i = 0; i < 26; i++)\\n            result[i] = f1[i] + f2[i];\\n        return result;\\n    }\\n    \\n    private bool IsGreaterOrEqueal(int[] f1, int[] f2)\\n    {\\n        for(int i = 0; i < 26; i++)\\n            if(f1[i] < f2[i])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427867,
                "title": "kotlin-solution",
                "content": "```\\nimport kotlin.math.max\\n\\nclass Solution {\\n     fun maxScoreWords(words: Array<String>, letters: CharArray, score: IntArray): Int {\\n        var remaining = IntArray(28) { 0 }\\n        for (i in 0 until letters.size)\\n            remaining[letters[i] - \\'a\\']++\\n        return solve(0, words, remaining, score, 0)\\n    }\\n\\n    private fun solve(index: Int, words: Array<String>, remaining: IntArray, score: IntArray, totalSum: Int): Int {\\n        if (index == words.size) return totalSum\\n        var _totalSum = totalSum\\n\\n        var notApplicable = false\\n        var skipCurrent = solve(index + 1, words, remaining, score, totalSum)\\n        for (i in 0 until words[index].length) {\\n            remaining[words[index][i] - \\'a\\']--\\n            _totalSum += score[words[index][i] - \\'a\\']\\n        }\\n        for (i in 0 until remaining.size)\\n            if (remaining[i] < 0)\\n                notApplicable = true\\n       \\n         var withCurrent = 0\\n         if (!notApplicable)\\n         withCurrent = solve(index + 1, words, remaining, score, _totalSum)\\n        for (i in 0 until words[index].length) {\\n            remaining[words[index][i] - \\'a\\']++\\n                 _totalSum -= score[words[index][i] - \\'a\\']\\n        }\\n\\n\\n        return max(withCurrent, skipCurrent)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nimport kotlin.math.max\\n\\nclass Solution {\\n     fun maxScoreWords(words: Array<String>, letters: CharArray, score: IntArray): Int {\\n        var remaining = IntArray(28) { 0 }\\n        for (i in 0 until letters.size)\\n            remaining[letters[i] - \\'a\\']++\\n        return solve(0, words, remaining, score, 0)\\n    }\\n\\n    private fun solve(index: Int, words: Array<String>, remaining: IntArray, score: IntArray, totalSum: Int): Int {\\n        if (index == words.size) return totalSum\\n        var _totalSum = totalSum\\n\\n        var notApplicable = false\\n        var skipCurrent = solve(index + 1, words, remaining, score, totalSum)\\n        for (i in 0 until words[index].length) {\\n            remaining[words[index][i] - \\'a\\']--\\n            _totalSum += score[words[index][i] - \\'a\\']\\n        }\\n        for (i in 0 until remaining.size)\\n            if (remaining[i] < 0)\\n                notApplicable = true\\n       \\n         var withCurrent = 0\\n         if (!notApplicable)\\n         withCurrent = solve(index + 1, words, remaining, score, _totalSum)\\n        for (i in 0 until words[index].length) {\\n            remaining[words[index][i] - \\'a\\']++\\n                 _totalSum -= score[words[index][i] - \\'a\\']\\n        }\\n\\n\\n        return max(withCurrent, skipCurrent)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427745,
                "title": "c-backtrack",
                "content": "I think this idea is similar to [this question](https://leetcode.com/problems/subsets/). It finds out all the situations and then choose the largest score.\\n```cpp\\nclass Solution {\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        int res=0;\\n        char ch[128]={};\\n        for(char c:letters) ch[c]++;\\n        dfs(res, 0, words, ch, score, 0);\\n        return res;\\n    }\\n    void dfs(int &res, int tmpres, vector<string> &word, char (&ch)[128], vector<int> &score, int start){\\n        res = max(res, tmpres);\\n        for(int i = start; i < word.size(); i++){\\n            bool flag=true;\\n            int score_i = 0;\\n            for(int j = 0; j < word[i].size(); j++){\\n                score_i += score[word[i][j]-\\'a\\'];\\n                if(ch[word[i][j]]--<=0) flag=false;\\n            }\\n            if(flag)\\n                dfs(res, tmpres+score_i, word, ch, score, i+1);\\n            for(int j = 0; j < word[i].size(); j++){\\n                ch[word[i][j]]++;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        int res=0;\\n        char ch[128]={};\\n        for(char c:letters) ch[c]++;\\n        dfs(res, 0, words, ch, score, 0);\\n        return res;\\n    }\\n    void dfs(int &res, int tmpres, vector<string> &word, char (&ch)[128], vector<int> &score, int start){\\n        res = max(res, tmpres);\\n        for(int i = start; i < word.size(); i++){\\n            bool flag=true;\\n            int score_i = 0;\\n            for(int j = 0; j < word[i].size(); j++){\\n                score_i += score[word[i][j]-\\'a\\'];\\n                if(ch[word[i][j]]--<=0) flag=false;\\n            }\\n            if(flag)\\n                dfs(res, tmpres+score_i, word, ch, score, i+1);\\n            for(int j = 0; j < word[i].size(); j++){\\n                ch[word[i][j]]++;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427659,
                "title": "java-1ms-greedy",
                "content": "Just search one word by one word. \\n\\nRead the problem and you will find the words is a short Array, which means we can solve it with greedy method.\\n```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int[] count = new int[26];\\n        for(char c:letters) count[c-\\'a\\']++;\\n        return maxScoreWords(words,0,count,score);\\n    }\\n    \\n    public int maxScoreWords(String[] words,int start, int[] count, int[] score){\\n        if(start==words.length) return 0;\\n        int res = 0;\\n        loop1: for(int i=start;i<words.length;i++){\\n            int cur = 0;\\n            int[] countCopy = Arrays.copyOf(count,count.length);\\n            for(char c: words[i].toCharArray()){\\n                if(countCopy[c-\\'a\\']<=0) continue loop1;\\n                countCopy[c-\\'a\\']--;\\n                cur+=score[c-\\'a\\'];\\n            }\\n            cur+=maxScoreWords(words,i+1,countCopy,score);\\n            res = Math.max(res,cur);\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int[] count = new int[26];\\n        for(char c:letters) count[c-\\'a\\']++;\\n        return maxScoreWords(words,0,count,score);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 426253,
                "title": "concise-code-in-c-using-dfs-both-time-and-mem-beat-100",
                "content": "First, we count the freqency of letters for `words` and `letters`.\\nThen we use DFS which returns the maximum score.\\n`pos` represents the current index where we start to search.\\n\\n---\\n\\nTime Complexity: O(2^n), which is the number of subsets of `words`.\\nSpace Complexity: O(26 * n) = O(n).\\n\\n---\\n\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>> &cntW, vector<int> &cntL, vector<int> &score, int pos) {\\n        int res = 0;\\n        for (int i = pos; i < cntW.size(); i++) {\\n            int j = 0;\\n            for (; j < 26; j++)\\n                if (cntW[i][j] > cntL[j]) break;\\n            if (j == 26) {\\n                int tmp = 0;\\n                for (j = 0; j < 26; j++) {cntL[j] -= cntW[i][j]; tmp += cntW[i][j] * score[j];}\\n                res = max(res, tmp + dfs(cntW, cntL, score, i + 1));\\n                for (j = 0; j < 26; j++) cntL[j] += cntW[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        int n = words.size();\\n        vector<vector<int>> cntW(n, vector<int>(26, 0));\\n        vector<int> cntL(26, 0);\\n        for (int i = 0; i < n; i++)\\n            for (auto ch : words[i]) cntW[i][ch-\\'a\\']++;\\n        for (auto ch : letters) cntL[ch-\\'a\\']++;\\n        \\n        return dfs(cntW, cntL, score, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>> &cntW, vector<int> &cntL, vector<int> &score, int pos) {\\n        int res = 0;\\n        for (int i = pos; i < cntW.size(); i++) {\\n            int j = 0;\\n            for (; j < 26; j++)\\n                if (cntW[i][j] > cntL[j]) break;\\n            if (j == 26) {\\n                int tmp = 0;\\n                for (j = 0; j < 26; j++) {cntL[j] -= cntW[i][j]; tmp += cntW[i][j] * score[j];}\\n                res = max(res, tmp + dfs(cntW, cntL, score, i + 1));\\n                for (j = 0; j < 26; j++) cntL[j] += cntW[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        int n = words.size();\\n        vector<vector<int>> cntW(n, vector<int>(26, 0));\\n        vector<int> cntL(26, 0);\\n        for (int i = 0; i < n; i++)\\n            for (auto ch : words[i]) cntW[i][ch-\\'a\\']++;\\n        for (auto ch : letters) cntL[ch-\\'a\\']++;\\n        \\n        return dfs(cntW, cntL, score, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425680,
                "title": "this-is-a-multidimensional-knapsack",
                "content": "This problem is actually known in the literature as the multidimensional knapsack. Just as the name suggests, this is similar to a knapsack, but instead of each item adding its size in one dimension, it adds to multiple dimensions. We can imagine this as having multiple knapsacks and each item adds a certain amount to each one of the knapsacks (this article explains the problem and gives a heuristic https://medium.com/@piasekhgw/multidimensional-knapsack-problem-distributed-218ecf64b0a).\\n\\nNow, in our context, we have one knapsack for each letter, and the capacity of each knapsack is given by the frequency of the letter in the \"letters\" array. Furthermore, the capacity (frequency) of each knapsack is at most 100, and the number of items is at most 14. Hence, an \"extended\" version of the classical knapsack DP would be good enough!\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        # create knapsack capacities\\n        letter_count = Counter(letters)\\n        cap = [0 for _ in range(26)]\\n        for c in letter_count:\\n            cap[ord(c) - ord(\\'a\\')] = letter_count[c]\\n        \\n        DP = {}\\n        def knapsack(words, cap):\\n            nonlocal DP\\n            \\n            if len(words) == 0:\\n                return 0\\n            \\n            lcap = list(cap)\\n            lcap.append(len(words))\\n            currkey = tuple(tuple(lcap))\\n            if currkey in DP:\\n                return DP[currkey]\\n            \\n            currscore = 0\\n            wcount = Counter(words[0])\\n            item = [0 for _ in range(26)]\\n            for c in wcount:\\n                currscore += wcount[c] * score[ord(c) - ord(\\'a\\')]\\n                item[ord(c) - ord(\\'a\\')] = wcount[c]\\n            \\n            cap2 = list(cap)\\n            canFit = True\\n            for i in range(26):\\n                cap2[i] = cap[i] - item[i]\\n                if cap2[i] < 0:\\n                    canFit = False\\n            \\n            ans1 = knapsack(words[1:], cap)\\n            ans2 = 0\\n            if canFit:\\n                ans2 = currscore + knapsack(words[1:], cap2)\\n            \\n            DP[currkey] = max(ans1, ans2)\\n            return DP[currkey]\\n            \\n        return knapsack(words, cap)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        # create knapsack capacities\\n        letter_count = Counter(letters)\\n        cap = [0 for _ in range(26)]\\n        for c in letter_count:\\n            cap[ord(c) - ord(\\'a\\')] = letter_count[c]\\n        \\n        DP = {}\\n        def knapsack(words, cap):\\n            nonlocal DP\\n            \\n            if len(words) == 0:\\n                return 0\\n            \\n            lcap = list(cap)\\n            lcap.append(len(words))\\n            currkey = tuple(tuple(lcap))\\n            if currkey in DP:\\n                return DP[currkey]\\n            \\n            currscore = 0\\n            wcount = Counter(words[0])\\n            item = [0 for _ in range(26)]\\n            for c in wcount:\\n                currscore += wcount[c] * score[ord(c) - ord(\\'a\\')]\\n                item[ord(c) - ord(\\'a\\')] = wcount[c]\\n            \\n            cap2 = list(cap)\\n            canFit = True\\n            for i in range(26):\\n                cap2[i] = cap[i] - item[i]\\n                if cap2[i] < 0:\\n                    canFit = False\\n            \\n            ans1 = knapsack(words[1:], cap)\\n            ans2 = 0\\n            if canFit:\\n                ans2 = currscore + knapsack(words[1:], cap2)\\n            \\n            DP[currkey] = max(ans1, ans2)\\n            return DP[currkey]\\n            \\n        return knapsack(words, cap)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425656,
                "title": "c-concise-dfs",
                "content": "First, tally up the letters in `numLetters` and calculate the value of each word in `wordValue`.\\n\\nThe `dfs` function returns the best score that is possible from the given initial index `start`.\\n\\nIterate through all words from `words[start]` to the end. In each iteration, remove the letters in that word from pool of remaining letters `numLetters`. If at any point we dip below `0` for a given letter, we can\\'t take that path, so set the flag `canTake = false` to denote this. Then add those removed letters back in and continue with the next word.\\n\\n```cpp\\nint maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n\\tvector<int> numLetters(26), wordValue(words.size());\\n\\tfor (char c : letters) ++numLetters[c - \\'a\\'];\\n\\tfor (int i = 0; i < words.size(); i++)\\n\\t\\tfor (char c : words[i])\\n\\t\\t\\twordValue[i] += score[c - \\'a\\'];\\n\\treturn dfs(words, wordValue, numLetters, 0);\\n}\\n\\nint dfs(vector<string> &words, vector<int> &wordValue, vector<int> &numLetters, int start) {\\n\\tint res = 0;\\n\\tfor (int i = start; i < words.size(); i++) {\\n\\t\\tbool canTake = true;\\n\\t\\tfor (char c : words[i])\\n\\t\\t\\tif (--numLetters[c - \\'a\\'] < 0) \\n\\t\\t\\t\\tcanTake = false;\\n\\t\\tif (canTake)\\n\\t\\t\\tres = max(res, wordValue[i] + dfs(words, wordValue, numLetters, i + 1));\\n\\t\\tfor (char c : words[i])\\n\\t\\t\\t++numLetters[c - \\'a\\'];\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nint maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n\\tvector<int> numLetters(26), wordValue(words.size());\\n\\tfor (char c : letters) ++numLetters[c - \\'a\\'];\\n\\tfor (int i = 0; i < words.size(); i++)\\n\\t\\tfor (char c : words[i])\\n\\t\\t\\twordValue[i] += score[c - \\'a\\'];\\n\\treturn dfs(words, wordValue, numLetters, 0);\\n}\\n\\nint dfs(vector<string> &words, vector<int> &wordValue, vector<int> &numLetters, int start) {\\n\\tint res = 0;\\n\\tfor (int i = start; i < words.size(); i++) {\\n\\t\\tbool canTake = true;\\n\\t\\tfor (char c : words[i])\\n\\t\\t\\tif (--numLetters[c - \\'a\\'] < 0) \\n\\t\\t\\t\\tcanTake = false;\\n\\t\\tif (canTake)\\n\\t\\t\\tres = max(res, wordValue[i] + dfs(words, wordValue, numLetters, i + 1));\\n\\t\\tfor (char c : words[i])\\n\\t\\t\\t++numLetters[c - \\'a\\'];\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 425483,
                "title": "long-backtrack-javascript-solution-60-ms",
                "content": "For example:\\n```\\n[\"dog\",\"cat\",\"dad\",\"good\"]\\n[\"a\",\"a\",\"c\",\"d\",\"d\",\"d\",\"g\",\"o\",\"o\"]\\n[1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]\\n```\\n```\\nlettersCount (0-25 a-z):\\n[ 2, 0, 1, 3, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]\\nwordsLetters (0-25 a-z):\\n[ [ 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],\\n  [ 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 ],\\n  [ 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],\\n  [ 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] ]\\nvalidWords (cat is not valid):\\n[ { index: 0, score: 10 },\\n  { index: 2, score: 11 },\\n  { index: 3, score: 12 } ]\\n```\\nFull code:\\n```\\nvar maxScoreWords = function(words, letters, score) {\\n    var aCode = \"a\".charCodeAt();\\n    var lettersCount = new Array(26).fill(0);\\n    for (var i = 0; i < letters.length; i++) {\\n        lettersCount[letters[i].charCodeAt() - aCode]++;\\n    }\\n    \\n    var wordsLetters = new Array(words.length);\\n    for (var i = 0; i < words.length; i++) {\\n        wordsLetters[i] = new Array(26).fill(0);\\n        for (var j = 0; j < words[i].length; j++) {\\n            wordsLetters[i][words[i][j].charCodeAt() - aCode]++;\\n        }\\n    }\\n    \\n    var passed;\\n    var calcScore;\\n    var validWords = [];\\n    for (var i = 0; i < words.length; i++) {\\n        passed = true;\\n        calcScore = 0;\\n        \\n        for (var j = 0; j < wordsLetters[i].length; j++) {\\n            if (wordsLetters[i][j] === 0) {\\n                continue;\\n            }\\n            \\n            if (wordsLetters[i][j] > lettersCount[j]) {\\n                passed = false;\\n                break;\\n            }\\n            \\n            calcScore += wordsLetters[i][j] * score[j];\\n        }\\n        \\n        if (passed) {\\n            validWords.push({ index: i, score: calcScore });\\n        }\\n    }\\n    \\n    var backtrack = function(index) {\\n        var max = 0;\\n        \\n        for (var i = index; i < validWords.length; i++) {\\n            var res = validWords[i].score;\\n            var wordIndex = validWords[i].index;\\n            var valid = true;\\n            var to = 26;\\n            \\n            for (var j = 0; j < to; j++) {\\n                lettersCount[j] -= wordsLetters[wordIndex][j];\\n                if (lettersCount[j] < 0) {\\n                    valid = false;\\n                    to = j + 1;\\n                    break;\\n                }\\n            }\\n            \\n            if (valid) {\\n                res += backtrack(i + 1);\\n                max = Math.max(res, max);\\n            } else {\\n                res = 0;\\n            }\\n            \\n            for (var j = 0; j < to; j++) {\\n                lettersCount[j] += wordsLetters[wordIndex][j];\\n            }\\n        }\\n        \\n        return max;\\n    } \\n    \\n    return backtrack(0);\\n};\\n```\\nTested using:\\n```\\n[\"dog\",\"cat\",\"dad\",\"good\"]\\n[\"a\",\"a\",\"c\",\"d\",\"d\",\"d\",\"g\",\"o\",\"o\"]\\n[1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]\\n[\"xxxz\",\"ax\",\"bx\",\"cx\"]\\n[\"z\",\"a\",\"b\",\"c\",\"x\",\"x\",\"x\"]\\n[4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]\\n[\"leetcode\"]\\n[\"l\",\"e\",\"t\",\"c\",\"o\",\"d\"]\\n[0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]\\n[\"ac\",\"ca\",\"cc\",\"aa\",\"ac\",\"ac\",\"ca\",\"ca\",\"a\",\"c\",\"a\",\"a\",\"ac\",\"ac\"]\\n[\"a\",\"a\",\"c\",\"c\"]\\n[1,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n[\"ac\",\"ca\",\"cc\",\"aa\",\"ac\",\"ac\",\"ca\",\"ca\",\"a\",\"c\",\"a\",\"a\",\"ac\",\"ac\"]\\n[\"a\",\"a\",\"c\",\"c\",\"a\",\"a\",\"c\",\"c\",\"a\",\"a\",\"c\",\"c\",\"a\",\"a\",\"c\",\"c\",\"a\",\"a\",\"c\",\"c\",\"a\",\"a\",\"c\",\"c\",\"a\",\"a\",\"c\",\"c\",\"a\",\"a\",\"c\",\"c\"]\\n[1,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n```",
                "solutionTags": [],
                "code": "```\\n[\"dog\",\"cat\",\"dad\",\"good\"]\\n[\"a\",\"a\",\"c\",\"d\",\"d\",\"d\",\"g\",\"o\",\"o\"]\\n[1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]\\n```\n```\\nlettersCount (0-25 a-z):\\n[ 2, 0, 1, 3, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]\\nwordsLetters (0-25 a-z):\\n[ [ 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],\\n  [ 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 ],\\n  [ 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],\\n  [ 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] ]\\nvalidWords (cat is not valid):\\n[ { index: 0, score: 10 },\\n  { index: 2, score: 11 },\\n  { index: 3, score: 12 } ]\\n```\n```\\nvar maxScoreWords = function(words, letters, score) {\\n    var aCode = \"a\".charCodeAt();\\n    var lettersCount = new Array(26).fill(0);\\n    for (var i = 0; i < letters.length; i++) {\\n        lettersCount[letters[i].charCodeAt() - aCode]++;\\n    }\\n    \\n    var wordsLetters = new Array(words.length);\\n    for (var i = 0; i < words.length; i++) {\\n        wordsLetters[i] = new Array(26).fill(0);\\n        for (var j = 0; j < words[i].length; j++) {\\n            wordsLetters[i][words[i][j].charCodeAt() - aCode]++;\\n        }\\n    }\\n    \\n    var passed;\\n    var calcScore;\\n    var validWords = [];\\n    for (var i = 0; i < words.length; i++) {\\n        passed = true;\\n        calcScore = 0;\\n        \\n        for (var j = 0; j < wordsLetters[i].length; j++) {\\n            if (wordsLetters[i][j] === 0) {\\n                continue;\\n            }\\n            \\n            if (wordsLetters[i][j] > lettersCount[j]) {\\n                passed = false;\\n                break;\\n            }\\n            \\n            calcScore += wordsLetters[i][j] * score[j];\\n        }\\n        \\n        if (passed) {\\n            validWords.push({ index: i, score: calcScore });\\n        }\\n    }\\n    \\n    var backtrack = function(index) {\\n        var max = 0;\\n        \\n        for (var i = index; i < validWords.length; i++) {\\n            var res = validWords[i].score;\\n            var wordIndex = validWords[i].index;\\n            var valid = true;\\n            var to = 26;\\n            \\n            for (var j = 0; j < to; j++) {\\n                lettersCount[j] -= wordsLetters[wordIndex][j];\\n                if (lettersCount[j] < 0) {\\n                    valid = false;\\n                    to = j + 1;\\n                    break;\\n                }\\n            }\\n            \\n            if (valid) {\\n                res += backtrack(i + 1);\\n                max = Math.max(res, max);\\n            } else {\\n                res = 0;\\n            }\\n            \\n            for (var j = 0; j < to; j++) {\\n                lettersCount[j] += wordsLetters[wordIndex][j];\\n            }\\n        }\\n        \\n        return max;\\n    } \\n    \\n    return backtrack(0);\\n};\\n```\n```\\n[\"dog\",\"cat\",\"dad\",\"good\"]\\n[\"a\",\"a\",\"c\",\"d\",\"d\",\"d\",\"g\",\"o\",\"o\"]\\n[1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]\\n[\"xxxz\",\"ax\",\"bx\",\"cx\"]\\n[\"z\",\"a\",\"b\",\"c\",\"x\",\"x\",\"x\"]\\n[4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]\\n[\"leetcode\"]\\n[\"l\",\"e\",\"t\",\"c\",\"o\",\"d\"]\\n[0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]\\n[\"ac\",\"ca\",\"cc\",\"aa\",\"ac\",\"ac\",\"ca\",\"ca\",\"a\",\"c\",\"a\",\"a\",\"ac\",\"ac\"]\\n[\"a\",\"a\",\"c\",\"c\"]\\n[1,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n[\"ac\",\"ca\",\"cc\",\"aa\",\"ac\",\"ac\",\"ca\",\"ca\",\"a\",\"c\",\"a\",\"a\",\"ac\",\"ac\"]\\n[\"a\",\"a\",\"c\",\"c\",\"a\",\"a\",\"c\",\"c\",\"a\",\"a\",\"c\",\"c\",\"a\",\"a\",\"c\",\"c\",\"a\",\"a\",\"c\",\"c\",\"a\",\"a\",\"c\",\"c\",\"a\",\"a\",\"c\",\"c\",\"a\",\"a\",\"c\",\"c\"]\\n[1,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 425161,
                "title": "python-subsets-0-1-logic-with-pruning",
                "content": "The idea is very simple. Due to the small number of words, we can generate all possible subsets and calculate the score of each one.\\nPruning: In the process of generating a subset, if we find that adding the next word to the subset is not possible, because there are not enough letters left to add that word, then we dont follow that path any more.\\n```\\ndef maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        def subsets(i, cur, counts):\\n            if len(list(filter(lambda x: x < 0, counts.values()))) > 0: return\\n            if i == len(words):\\n                if not cur: return\\n                res[0] = max(res[0], sum(scores[w] for w in cur))\\n                return\\n            subsets(i+1, cur, counts)\\n            cur.append(words[i])\\n            counts.subtract(c[words[i]])\\n            subsets(i+1, cur, counts)\\n            cur.pop()\\n            counts.update(c[words[i]])\\n        c, scores = {}, {}\\n        for w in words:\\n            c[w] = Counter(w)\\n            scores[w] = sum(score[ord(k) - ord(\\'a\\')] * v for k,v in c[w].items())\\n        res = [0]\\n        subsets(0, [], Counter(letters))\\n        return res[0]\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        def subsets(i, cur, counts):\\n            if len(list(filter(lambda x: x < 0, counts.values()))) > 0: return\\n            if i == len(words):\\n                if not cur: return\\n                res[0] = max(res[0], sum(scores[w] for w in cur))\\n                return\\n            subsets(i+1, cur, counts)\\n            cur.append(words[i])\\n            counts.subtract(c[words[i]])\\n            subsets(i+1, cur, counts)\\n            cur.pop()\\n            counts.update(c[words[i]])\\n        c, scores = {}, {}\\n        for w in words:\\n            c[w] = Counter(w)\\n            scores[w] = sum(score[ord(k) - ord(\\'a\\')] * v for k,v in c[w].items())\\n        res = [0]\\n        subsets(0, [], Counter(letters))\\n        return res[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4098535,
                "title": "kotlin-recursive-with-memoization",
                "content": "# Code\\n```\\nclass Solution {\\n    lateinit var wordToScore: Map<String, Int>\\n    val dp = mutableMapOf<Set<Map.Entry<String, Int>>, Int>()\\n    \\n    fun maxScoreWords(words: Array<String>, letters: CharArray, score: IntArray): Int {\\n        wordToScore = buildWordScores(words, score)\\n        val wordToCount = words.groupingBy { it }.eachCount()\\n        val letterToCount = letters.asList().groupingBy { it }.eachCount()\\n\\n        return inner(wordToCount, letterToCount, 0)\\n    }\\n\\n    fun inner(wordToCount: Map<String, Int>, letterMap: Map<Char, Int>, tot: Int): Int {\\n        dp[wordToScore.entries]?.let {\\n           return it\\n        }\\n\\n        var newTot = tot\\n        wordToCount.forEach { entry ->\\n            if (entry.value > 0) {\\n                val word = entry.key\\n                val newMap = letterMap.toMutableMap()\\n                var canForm = true\\n\\n                for (c in word) {\\n                    if (newMap[c] ?: 0 <= 0) {\\n                        canForm = false\\n                        break\\n                    }\\n                    newMap[c] = (newMap[c] ?: 1) - 1\\n                }\\n                if (canForm) {\\n                    val newWordToCount = wordToCount.toMutableMap()\\n                    newWordToCount[word] = (wordToCount[word] ?: 1) - 1\\n                    newTot = maxOf(newTot, inner(newWordToCount, newMap, tot + wordToScore[word]!!))\\n                }\\n            }\\n        }\\n        dp[wordToCount.entries] = newTot\\n\\n        return newTot\\n    }\\n\\n    fun buildWordScores(words: Array<String>, score: IntArray): Map<String, Int> {\\n        val wordToScore = mutableMapOf<String, Int>()\\n\\n        words.forEach { word ->\\n            wordToScore[word] = word.map { score[it - \\'a\\'] }.sum()\\n        }\\n\\n        return wordToScore\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    lateinit var wordToScore: Map<String, Int>\\n    val dp = mutableMapOf<Set<Map.Entry<String, Int>>, Int>()\\n    \\n    fun maxScoreWords(words: Array<String>, letters: CharArray, score: IntArray): Int {\\n        wordToScore = buildWordScores(words, score)\\n        val wordToCount = words.groupingBy { it }.eachCount()\\n        val letterToCount = letters.asList().groupingBy { it }.eachCount()\\n\\n        return inner(wordToCount, letterToCount, 0)\\n    }\\n\\n    fun inner(wordToCount: Map<String, Int>, letterMap: Map<Char, Int>, tot: Int): Int {\\n        dp[wordToScore.entries]?.let {\\n           return it\\n        }\\n\\n        var newTot = tot\\n        wordToCount.forEach { entry ->\\n            if (entry.value > 0) {\\n                val word = entry.key\\n                val newMap = letterMap.toMutableMap()\\n                var canForm = true\\n\\n                for (c in word) {\\n                    if (newMap[c] ?: 0 <= 0) {\\n                        canForm = false\\n                        break\\n                    }\\n                    newMap[c] = (newMap[c] ?: 1) - 1\\n                }\\n                if (canForm) {\\n                    val newWordToCount = wordToCount.toMutableMap()\\n                    newWordToCount[word] = (wordToCount[word] ?: 1) - 1\\n                    newTot = maxOf(newTot, inner(newWordToCount, newMap, tot + wordToScore[word]!!))\\n                }\\n            }\\n        }\\n        dp[wordToCount.entries] = newTot\\n\\n        return newTot\\n    }\\n\\n    fun buildWordScores(words: Array<String>, score: IntArray): Map<String, Int> {\\n        val wordToScore = mutableMapOf<String, Int>()\\n\\n        words.forEach { word ->\\n            wordToScore[word] = word.map { score[it - \\'a\\'] }.sum()\\n        }\\n\\n        return wordToScore\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081280,
                "title": "easy-solution-in-c-using-backtracking-hash-map-and-simple-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<string> temp, unordered_map<int,pair<int,int>> mp){\\n        for(string word : temp){\\n            for(int i = 0; i<word.size(); i++){\\n                mp[word[i]-\\'a\\'].first--;\\n                if(mp[word[i]-\\'a\\'].first<0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void solve(vector<string>& words, vector<string>& temp, int i,unordered_map<int,pair<int,int>>& mp,int& ans){\\n        if(i>=words.size()){\\n            if(check(temp,mp)){\\n                int curr = 0;\\n                for(string word : temp){\\n                    for(int i = 0; i<word.size(); i++){\\n                        curr += mp[word[i]-\\'a\\'].second;\\n                    }\\n                }\\n                ans = max(ans,curr);\\n            }\\n            return;\\n        }\\n        temp.push_back(words[i]);\\n        solve(words,temp,i+1,mp,ans);\\n        temp.pop_back();\\n        solve(words,temp,i+1,mp,ans);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        unordered_map<int,pair<int,int>> mp;\\n        for(char letter : letters){\\n            mp[letter-\\'a\\'].first++;\\n        }\\n        for(int i = 0; i<score.size(); i++){\\n            if(mp.find(i)!=mp.end()){\\n                mp[i].second = score[i];\\n            }\\n        }\\n        int ans = 0;\\n        vector<string> temp;\\n        solve(words,temp,0,mp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<string> temp, unordered_map<int,pair<int,int>> mp){\\n        for(string word : temp){\\n            for(int i = 0; i<word.size(); i++){\\n                mp[word[i]-\\'a\\'].first--;\\n                if(mp[word[i]-\\'a\\'].first<0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void solve(vector<string>& words, vector<string>& temp, int i,unordered_map<int,pair<int,int>>& mp,int& ans){\\n        if(i>=words.size()){\\n            if(check(temp,mp)){\\n                int curr = 0;\\n                for(string word : temp){\\n                    for(int i = 0; i<word.size(); i++){\\n                        curr += mp[word[i]-\\'a\\'].second;\\n                    }\\n                }\\n                ans = max(ans,curr);\\n            }\\n            return;\\n        }\\n        temp.push_back(words[i]);\\n        solve(words,temp,i+1,mp,ans);\\n        temp.pop_back();\\n        solve(words,temp,i+1,mp,ans);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        unordered_map<int,pair<int,int>> mp;\\n        for(char letter : letters){\\n            mp[letter-\\'a\\'].first++;\\n        }\\n        for(int i = 0; i<score.size(); i++){\\n            if(mp.find(i)!=mp.end()){\\n                mp[i].second = score[i];\\n            }\\n        }\\n        int ans = 0;\\n        vector<string> temp;\\n        solve(words,temp,0,mp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080306,
                "title": "java-easy-to-understand-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry all combination of words and find out the score for the complete word string with given conditions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.created a function that creates a string with taking all possible words.\\n2.Itterate over the string and calculate the score.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nFor finding the combinations of the words : 2^N. \\nFor finding the score of the generated string : N. \\nTime Complexity O(N*2^N).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Integer ans = null; \\n    public void findAns(String str,int[] freq,int[] score){\\n        Integer tempAns = 0;\\n        for(int i = 0;i<str.length();i++){\\n            char c = str.charAt(i); \\n            if(freq[c-\\'a\\']>0){\\n                freq[c-\\'a\\']--;\\n                tempAns+=score[c-\\'a\\'];\\n            }else{\\n                 return;\\n            }\\n        }\\n        ans = Math.max(ans,tempAns);\\n        return;\\n    }\\n    public int[] clone(int[] freq){\\n        int[] ans = new int[freq.length]; \\n        for(int i = 0;i<freq.length;i++){\\n            ans[i] = freq[i];\\n        }\\n        return ans;\\n    }\\n    public void wordsChoice(int ind,String[] words,String wrdStr,int[] chrFreq,int[] score){\\n        if(ind == words.length){\\n            int[] narr = clone(chrFreq);\\n            findAns(wrdStr,narr,score);\\n        }\\n        if(ind>=words.length){\\n            return;\\n        }\\n        \\n        wordsChoice(ind+1,words,wrdStr+words[ind],chrFreq,score); \\n        wordsChoice(ind+1,words,wrdStr,chrFreq,score);\\n    }\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        HashMap<Character,Integer> chrFreq = new HashMap<>(); \\n        ans = 0;\\n        int[] freq = new int[26];\\n        for(Character s : letters){\\n            freq[s-\\'a\\']++;\\n            if(chrFreq.get(s) == null){\\n                chrFreq.put(s,1);\\n            }\\n            else{\\n                chrFreq.put(s,chrFreq.get(s)+1);\\n            }\\n        }\\n        for(int i : freq){\\n            System.out.print(i+\",\");\\n        }\\n        wordsChoice(0,words,\"\",freq,score);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Integer ans = null; \\n    public void findAns(String str,int[] freq,int[] score){\\n        Integer tempAns = 0;\\n        for(int i = 0;i<str.length();i++){\\n            char c = str.charAt(i); \\n            if(freq[c-\\'a\\']>0){\\n                freq[c-\\'a\\']--;\\n                tempAns+=score[c-\\'a\\'];\\n            }else{\\n                 return;\\n            }\\n        }\\n        ans = Math.max(ans,tempAns);\\n        return;\\n    }\\n    public int[] clone(int[] freq){\\n        int[] ans = new int[freq.length]; \\n        for(int i = 0;i<freq.length;i++){\\n            ans[i] = freq[i];\\n        }\\n        return ans;\\n    }\\n    public void wordsChoice(int ind,String[] words,String wrdStr,int[] chrFreq,int[] score){\\n        if(ind == words.length){\\n            int[] narr = clone(chrFreq);\\n            findAns(wrdStr,narr,score);\\n        }\\n        if(ind>=words.length){\\n            return;\\n        }\\n        \\n        wordsChoice(ind+1,words,wrdStr+words[ind],chrFreq,score); \\n        wordsChoice(ind+1,words,wrdStr,chrFreq,score);\\n    }\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        HashMap<Character,Integer> chrFreq = new HashMap<>(); \\n        ans = 0;\\n        int[] freq = new int[26];\\n        for(Character s : letters){\\n            freq[s-\\'a\\']++;\\n            if(chrFreq.get(s) == null){\\n                chrFreq.put(s,1);\\n            }\\n            else{\\n                chrFreq.put(s,chrFreq.get(s)+1);\\n            }\\n        }\\n        for(int i : freq){\\n            System.out.print(i+\",\");\\n        }\\n        wordsChoice(0,words,\"\",freq,score);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079855,
                "title": "no-dynamic-programming-clear-code-huihui",
                "content": "\\n# Approach \\nusing hashmap to count the characters taken till now \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*2^N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![doge.jpg](https://assets.leetcode.com/users/images/f2b65af8-6fa8-4991-aaec-0f29074be652_1695459698.8118584.jpeg)\\nUpvomte kar dena vmros\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canBtaken(string &s, unordered_map<char,int>&mp){\\n        unordered_map<char, int>curr;\\n        for(int i=0; i<s.size(); i++){\\n            curr[s[i]]++;\\n        }\\n        for(auto i: curr){\\n            if(i.second>mp[i.first]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void updateMap(unordered_map<char,int>&mp, string &s){\\n        for(int i=0; i<s.size(); i++){\\n            mp[s[i]]--;\\n        }\\n    }\\n    void fixMap(unordered_map<char,int>&mp, string &s){\\n        for(int i=0; i<s.size(); i++){\\n            mp[s[i]]++;\\n        }\\n    }\\n    int Score(string s, vector<int>& score){\\n        int sum=0;\\n        for(int i=0; i<s.size(); i++){\\n            sum=sum+score[s[i]-\\'a\\'];\\n        }\\n        return sum;\\n    }\\n    int f(vector<string>& words, vector<char>& letters, vector<int>& score, unordered_map<char, int>& mp, int idx){\\n        if(idx==words.size()) return 0;\\n        int take=INT_MIN, not_take=INT_MIN;\\n        if(canBtaken(words[idx], mp)){\\n            updateMap(mp, words[idx]);\\n            take=Score(words[idx], score)+f(words, letters, score, mp, idx+1);\\n            fixMap(mp, words[idx]);\\n            not_take=f(words, letters, score, mp, idx+1);\\n        }\\n        else{\\n            not_take=f(words, letters, score, mp, idx+1);\\n        }\\n        return max(take, not_take);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        unordered_map<char, int>mp;\\n\\n        for(int i=0; i<letters.size(); i++){\\n            mp[letters[i]]++;\\n        }\\n\\n        return f(words, letters, score, mp, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canBtaken(string &s, unordered_map<char,int>&mp){\\n        unordered_map<char, int>curr;\\n        for(int i=0; i<s.size(); i++){\\n            curr[s[i]]++;\\n        }\\n        for(auto i: curr){\\n            if(i.second>mp[i.first]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void updateMap(unordered_map<char,int>&mp, string &s){\\n        for(int i=0; i<s.size(); i++){\\n            mp[s[i]]--;\\n        }\\n    }\\n    void fixMap(unordered_map<char,int>&mp, string &s){\\n        for(int i=0; i<s.size(); i++){\\n            mp[s[i]]++;\\n        }\\n    }\\n    int Score(string s, vector<int>& score){\\n        int sum=0;\\n        for(int i=0; i<s.size(); i++){\\n            sum=sum+score[s[i]-\\'a\\'];\\n        }\\n        return sum;\\n    }\\n    int f(vector<string>& words, vector<char>& letters, vector<int>& score, unordered_map<char, int>& mp, int idx){\\n        if(idx==words.size()) return 0;\\n        int take=INT_MIN, not_take=INT_MIN;\\n        if(canBtaken(words[idx], mp)){\\n            updateMap(mp, words[idx]);\\n            take=Score(words[idx], score)+f(words, letters, score, mp, idx+1);\\n            fixMap(mp, words[idx]);\\n            not_take=f(words, letters, score, mp, idx+1);\\n        }\\n        else{\\n            not_take=f(words, letters, score, mp, idx+1);\\n        }\\n        return max(take, not_take);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        unordered_map<char, int>mp;\\n\\n        for(int i=0; i<letters.size(); i++){\\n            mp[letters[i]]++;\\n        }\\n\\n        return f(words, letters, score, mp, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058154,
                "title": "c-simple-and-intuitive",
                "content": "# Intuition\\nWe can just put the letters into a unoredered map and just do a normal backtracking since the constraints are low for this problem.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int goFind(int idx, vector<string> &words, vector<int> &score, unordered_map<char, int> &mp) {\\n        if(idx == words.size()) {\\n            return 0;\\n        } \\n\\n        int not_take = goFind(idx+1, words, score, mp);\\n        int take = 0;\\n        int flag = 0;\\n        int sum = 0;\\n        int i=0;\\n        for(;i<words[idx].length();i++) {\\n            if(mp[words[idx][i]] > 0) {\\n                mp[words[idx][i]]--;\\n                sum += score[words[idx][i]-\\'a\\'];\\n            }\\n            else {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if(flag == 0) {\\n            //We have successfully used the word and recursed for the next word.\\n            //Also we have backtracked the map so that we can look for other possible ways.\\n            take = sum + goFind(idx+1, words, score, mp);\\n            for(int j=0;j<words[idx].length();j++) {\\n                mp[words[idx][j]]++;\\n            }\\n        }\\n        else {\\n            //Since we have reduced we have to re-fill the occurrences again \\n            for(int j=0;j<i;j++) {\\n                mp[words[idx][j]]++;\\n            }\\n        }\\n        return max(take, not_take);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        unordered_map<char, int> mp;\\n        for(auto &letter:letters) {\\n            mp[letter]++;\\n        }\\n        return goFind(0, words, score, mp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int goFind(int idx, vector<string> &words, vector<int> &score, unordered_map<char, int> &mp) {\\n        if(idx == words.size()) {\\n            return 0;\\n        } \\n\\n        int not_take = goFind(idx+1, words, score, mp);\\n        int take = 0;\\n        int flag = 0;\\n        int sum = 0;\\n        int i=0;\\n        for(;i<words[idx].length();i++) {\\n            if(mp[words[idx][i]] > 0) {\\n                mp[words[idx][i]]--;\\n                sum += score[words[idx][i]-\\'a\\'];\\n            }\\n            else {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if(flag == 0) {\\n            //We have successfully used the word and recursed for the next word.\\n            //Also we have backtracked the map so that we can look for other possible ways.\\n            take = sum + goFind(idx+1, words, score, mp);\\n            for(int j=0;j<words[idx].length();j++) {\\n                mp[words[idx][j]]++;\\n            }\\n        }\\n        else {\\n            //Since we have reduced we have to re-fill the occurrences again \\n            for(int j=0;j<i;j++) {\\n                mp[words[idx][j]]++;\\n            }\\n        }\\n        return max(take, not_take);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        unordered_map<char, int> mp;\\n        for(auto &letter:letters) {\\n            mp[letter]++;\\n        }\\n        return goFind(0, words, score, mp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057887,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<string>& words,vector<int>&count,vector<int>& score,int i){\\n        vector<int>count1(26,0);\\n        for(int j = 0;j < words[i].length();j++)\\n            count1[words[i][j] - \\'a\\']++;\\n        for(int j = 0;j < words[i].length();j++){\\n            int a = words[i][j] - \\'a\\';\\n            if(count[a] < count1[a])\\n                return -1;\\n        }\\n        int ans = 0;\\n        for(int j = 0;j < words[i].length();j++){\\n            int a = words[i][j] - \\'a\\';\\n            ans += score[a];\\n            count[a]--;\\n        }\\n        return ans;\\n    }\\n    int solve(vector<string>& words,vector<int> count,vector<int>& score,int i){\\n        if(i >= words.size())\\n            return 0;\\n        int notTake = solve(words,count,score,i+1);\\n        int possible = helper(words,count,score,i);\\n        int take = 0;\\n        if(possible != -1){\\n            take = possible + solve(words,count,score,i+1);\\n        }\\n        return max(take,notTake);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> count(26,0);\\n        for(int i = 0;i < letters.size();i++)\\n            count[letters[i] - \\'a\\']++;\\n        return solve(words,count,score,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<string>& words,vector<int>&count,vector<int>& score,int i){\\n        vector<int>count1(26,0);\\n        for(int j = 0;j < words[i].length();j++)\\n            count1[words[i][j] - \\'a\\']++;\\n        for(int j = 0;j < words[i].length();j++){\\n            int a = words[i][j] - \\'a\\';\\n            if(count[a] < count1[a])\\n                return -1;\\n        }\\n        int ans = 0;\\n        for(int j = 0;j < words[i].length();j++){\\n            int a = words[i][j] - \\'a\\';\\n            ans += score[a];\\n            count[a]--;\\n        }\\n        return ans;\\n    }\\n    int solve(vector<string>& words,vector<int> count,vector<int>& score,int i){\\n        if(i >= words.size())\\n            return 0;\\n        int notTake = solve(words,count,score,i+1);\\n        int possible = helper(words,count,score,i);\\n        int take = 0;\\n        if(possible != -1){\\n            take = possible + solve(words,count,score,i+1);\\n        }\\n        return max(take,notTake);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> count(26,0);\\n        for(int i = 0;i < letters.size();i++)\\n            count[letters[i] - \\'a\\']++;\\n        return solve(words,count,score,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046346,
                "title": "easy-javascript-solution-takeornot",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {character[]} letters\\n * @param {number[]} score\\n * @return {number}\\n */\\nvar maxScoreWords = function(words, letters, score) {\\n    const freq = new Uint8Array(26);\\n    let max = 0;\\n    for (let i = 0; i < letters.length; i++) {\\n        ++freq[letters[i].charCodeAt(0) - 97];\\n    }\\n    takeOrNot(0, 0);\\n    return max;\\n\\n    function takeOrNot(wordIdx, score) {\\n        if (wordIdx === words.length) {\\n            return score > max && (max = score);\\n        }\\n        const wordScore = wordToScore(wordIdx);\\n        if (wordScore > 0) {\\n            takeOrNot(wordIdx+1, score + wordScore); // Take\\n            recoverFreq(wordIdx);\\n        }\\n        takeOrNot(wordIdx+1, score); // Not Take\\n    }\\n\\n    function wordToScore(wordIdx) {\\n        let sum = 0;\\n        for (let i = 0; i < words[wordIdx].length; i++) {\\n            const code = words[wordIdx].charCodeAt(i) - 97;\\n            if (freq[code] !== 0) {\\n                --freq[code];\\n                sum += score[code];\\n                continue;\\n            }\\n            for (let j = 0; j < i; j++) {\\n                ++freq[words[wordIdx].charCodeAt(j) - 97];\\n            }\\n            sum = 0;\\n            break;\\n        }\\n        return sum;\\n   }\\n\\n   function recoverFreq(wordIdx) {\\n        for (let i = 0; i < words[wordIdx].length; ++i) {\\n            ++freq[words[wordIdx].charCodeAt(i) - 97];\\n        }   \\n   }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {character[]} letters\\n * @param {number[]} score\\n * @return {number}\\n */\\nvar maxScoreWords = function(words, letters, score) {\\n    const freq = new Uint8Array(26);\\n    let max = 0;\\n    for (let i = 0; i < letters.length; i++) {\\n        ++freq[letters[i].charCodeAt(0) - 97];\\n    }\\n    takeOrNot(0, 0);\\n    return max;\\n\\n    function takeOrNot(wordIdx, score) {\\n        if (wordIdx === words.length) {\\n            return score > max && (max = score);\\n        }\\n        const wordScore = wordToScore(wordIdx);\\n        if (wordScore > 0) {\\n            takeOrNot(wordIdx+1, score + wordScore); // Take\\n            recoverFreq(wordIdx);\\n        }\\n        takeOrNot(wordIdx+1, score); // Not Take\\n    }\\n\\n    function wordToScore(wordIdx) {\\n        let sum = 0;\\n        for (let i = 0; i < words[wordIdx].length; i++) {\\n            const code = words[wordIdx].charCodeAt(i) - 97;\\n            if (freq[code] !== 0) {\\n                --freq[code];\\n                sum += score[code];\\n                continue;\\n            }\\n            for (let j = 0; j < i; j++) {\\n                ++freq[words[wordIdx].charCodeAt(j) - 97];\\n            }\\n            sum = 0;\\n            break;\\n        }\\n        return sum;\\n   }\\n\\n   function recoverFreq(wordIdx) {\\n        for (let i = 0; i < words[wordIdx].length; ++i) {\\n            ++freq[words[wordIdx].charCodeAt(i) - 97];\\n        }   \\n   }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4038267,
                "title": "0ms-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxScoreWords(vector<string>& w, vector<char>& l, vector<int>& s) {\\n        vector<int>f(26,0);\\n        for(auto c:l) f[c-\\'a\\']++;\\n        return msw(w,f,s,0);\\n    }\\n    private: int msw(vector<string>& w, vector<int>& lf, vector<int>& s,int curInd){\\n        if(curInd==w.size()) return 0;\\n        \\n        int notConsider=0+msw(w,lf,s,curInd+1);\\n        \\n        bool isPossibleToConsider=true;\\n        int letterScore=0;\\n        \\n        for(auto x:w[curInd]){\\n            if(lf[x-\\'a\\']==0) isPossibleToConsider=false;\\n            lf[x-\\'a\\']--;\\n            letterScore+=s[x-\\'a\\'];\\n        }\\n        \\n        int consider=0;\\n        if(isPossibleToConsider) \\n            consider=letterScore+msw(w,lf,s,curInd+1);\\n        \\n        for(auto x:w[curInd])  lf[x-\\'a\\']++;\\n            \\n        return max(notConsider,consider);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScoreWords(vector<string>& w, vector<char>& l, vector<int>& s) {\\n        vector<int>f(26,0);\\n        for(auto c:l) f[c-\\'a\\']++;\\n        return msw(w,f,s,0);\\n    }\\n    private: int msw(vector<string>& w, vector<int>& lf, vector<int>& s,int curInd){\\n        if(curInd==w.size()) return 0;\\n        \\n        int notConsider=0+msw(w,lf,s,curInd+1);\\n        \\n        bool isPossibleToConsider=true;\\n        int letterScore=0;\\n        \\n        for(auto x:w[curInd]){\\n            if(lf[x-\\'a\\']==0) isPossibleToConsider=false;\\n            lf[x-\\'a\\']--;\\n            letterScore+=s[x-\\'a\\'];\\n        }\\n        \\n        int consider=0;\\n        if(isPossibleToConsider) \\n            consider=letterScore+msw(w,lf,s,curInd+1);\\n        \\n        for(auto x:w[curInd])  lf[x-\\'a\\']++;\\n            \\n        return max(notConsider,consider);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018229,
                "title": "best-dp-solution-with-drawing-and-explanation-beats-100",
                "content": "\\n# Approach\\nFirstly we\\'ll create a map of frequency of characters in letters, we could\\'ve used unordered map too but I used vector.\\n\\nNow initialise our n = words.size() and ans = 0.\\nans stores our final answer.\\nCall our solve function.\\n\\n# How the function works - \\n- firstly we find maximum ans\\n- if our current index i >= n, it means we\\'ve reached end of words array so return\\n- create a copy of our map mp in a vector tempMap, this will be used to store the frequencies of character after we\\'ve made the first word\\n- Initialise j = 0, this will store the index of char of the current word that we\\'re processing.\\n- sum2 stores our score for the current word\\n- Traverse the length of word, find score, update the tempMap, if frequency of any character in tempMap goes below 0, it means that word can\\'t be made so break.\\n- After the for loop check if the word can be made, if our j == words[i].length it means word can be made, so now we add our sum2 to total sum i.e sum+sum2 and call the solve function with incremented index, i.e i+1 and our new tempMap\\n- The above call will return us the maximum ans when words[i] was considered but what if its not optimal to consider words[i].\\n- In that case we\\'ll call the solve function again with all parameters same as the original call except we increment the index by 1. \\n- Since at start of the function we\\'re having ans = max(ans, sum) we will have ans as the maximum score with all permutations.\\n\\n# I\\'ve solved the first testcase below for better understanding\\n\\n![image.png](https://assets.leetcode.com/users/images/33ab82b7-0bfd-4272-b72e-3d9f7bb22465_1694177204.7557333.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i, int& n, vector<int>& mp, vector<int>& score, int& ans, int sum, vector<string>& words){\\n        ans = max(ans, sum);\\n\\n        if(i >= n) return ;\\n\\n        vector<int> tempMap = mp;\\n\\n        int j = 0;\\n        int sum2 = 0;\\n\\n        for(j = 0; j < words[i].length(); j++){\\n            tempMap[words[i][j] - \\'a\\']--;\\n            sum2+= score[words[i][j] - \\'a\\'];\\n            if(tempMap[words[i][j]-\\'a\\'] < 0) break;\\n        }\\n\\n        if( j == words[i].length()){\\n            solve(i+1, n, tempMap, score, ans, sum + sum2, words);\\n        }\\n        solve(i+1, n, mp, score, ans, sum, words);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> mp(26, 0);\\n        for(char i : letters){\\n            mp[i - \\'a\\']++;\\n        }\\n        int ans = 0;\\n        int n = words.size();\\n        solve(0, n, mp, score, ans, 0, words);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i, int& n, vector<int>& mp, vector<int>& score, int& ans, int sum, vector<string>& words){\\n        ans = max(ans, sum);\\n\\n        if(i >= n) return ;\\n\\n        vector<int> tempMap = mp;\\n\\n        int j = 0;\\n        int sum2 = 0;\\n\\n        for(j = 0; j < words[i].length(); j++){\\n            tempMap[words[i][j] - \\'a\\']--;\\n            sum2+= score[words[i][j] - \\'a\\'];\\n            if(tempMap[words[i][j]-\\'a\\'] < 0) break;\\n        }\\n\\n        if( j == words[i].length()){\\n            solve(i+1, n, tempMap, score, ans, sum + sum2, words);\\n        }\\n        solve(i+1, n, mp, score, ans, sum, words);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> mp(26, 0);\\n        for(char i : letters){\\n            mp[i - \\'a\\']++;\\n        }\\n        int ans = 0;\\n        int n = words.size();\\n        solve(0, n, mp, score, ans, 0, words);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014877,
                "title": "bitmasking-solution-with-comments-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> freq(26, 0); // to store all the char available in letters array\\n        for(char ch: letters)\\n            freq[ch-\\'a\\']++;\\n\\n        int n = words.size();\\n        int maxScore = 0;\\n\\n        // using power set to generate all the subsets of vector words and\\n        // checking if it is possible to get that subset\\n        // If yes, then calculating the score corresponding to it & updating maxScore variable\\n        // else currScore = 0;\\n        for(int i = 0; i <= ((1<<n)-1); i++)\\n        {\\n            vector<int> temp = freq;\\n            int currScore = 0;\\n            bool flag = true;\\n            for(int bit = 0; bit<n; bit++)\\n            {\\n                if(i&(1<<bit))\\n                {\\n                    string s = words[bit];\\n                    for(int j = 0; j<s.length(); j++)\\n                    {\\n                        if(temp[s[j]-\\'a\\'] <= 0)\\n                        {\\n                            currScore = 0;\\n                            flag = false;\\n                            break;\\n                        }\\n                        temp[s[j]-\\'a\\']--;\\n                        currScore += score[s[j]-\\'a\\'];\\n                    }\\n                }\\n                if(flag == false) break;\\n            }\\n            maxScore = max(maxScore, currScore);\\n        }\\n        return maxScore;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> freq(26, 0); // to store all the char available in letters array\\n        for(char ch: letters)\\n            freq[ch-\\'a\\']++;\\n\\n        int n = words.size();\\n        int maxScore = 0;\\n\\n        // using power set to generate all the subsets of vector words and\\n        // checking if it is possible to get that subset\\n        // If yes, then calculating the score corresponding to it & updating maxScore variable\\n        // else currScore = 0;\\n        for(int i = 0; i <= ((1<<n)-1); i++)\\n        {\\n            vector<int> temp = freq;\\n            int currScore = 0;\\n            bool flag = true;\\n            for(int bit = 0; bit<n; bit++)\\n            {\\n                if(i&(1<<bit))\\n                {\\n                    string s = words[bit];\\n                    for(int j = 0; j<s.length(); j++)\\n                    {\\n                        if(temp[s[j]-\\'a\\'] <= 0)\\n                        {\\n                            currScore = 0;\\n                            flag = false;\\n                            break;\\n                        }\\n                        temp[s[j]-\\'a\\']--;\\n                        currScore += score[s[j]-\\'a\\'];\\n                    }\\n                }\\n                if(flag == false) break;\\n            }\\n            maxScore = max(maxScore, currScore);\\n        }\\n        return maxScore;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995940,
                "title": "clean-modular-c-code-backtracking-memo",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<char,int>m;\\n    unordered_map<char,int>s;\\n\\n    int isSet(int i, int mask){\\n        return (mask & (1<<i));\\n    }\\n\\n    void setBit(int i, int &mask){\\n        mask=(mask | (1<<i));\\n        return;\\n    }\\n\\n    void unsetbit(int i, int &mask){\\n        mask=(mask & ~(1<<i));\\n        return;\\n    }\\n\\n    int val(int mask, vector<string>&w){\\n        int ans=0;\\n        for(int i=0;i<w.size();i++){\\n            if(isSet(i,mask)){\\n                for(auto j:w[i]){\\n                    ans+=s[j];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    bool cantake(int ind, int mask, vector<string>&w){\\n        unordered_map<char,int>temp(m.begin(),m.end());\\n        for(int i=0;i<w.size();i++){\\n            if(isSet(i,mask)){\\n                for(auto j:w[i]){\\n                    temp[j]--;\\n                }\\n            }\\n        }\\n\\n        for(auto j:w[ind]){\\n            if(temp[j]==0)return false;\\n            temp[j]--;\\n        }\\n        return true;\\n    }\\n\\n    unordered_map<int,int>dp;\\n\\n    int f(int i, vector<string>&w, int mask){\\n        if(i==w.size()){\\n            return val(mask,w);\\n        }\\n\\n        if(dp.count(mask))return dp[mask];\\n\\n        //take\\n        int ans=0;\\n        if(cantake(i,mask,w)){\\n            setBit(i,mask);\\n            ans=max(ans,f(i+1,w,mask));\\n            unsetbit(i,mask);\\n        }\\n\\n        //nottake\\n        ans=max(ans,f(i+1,w,mask));\\n        return dp[mask]=ans;\\n\\n    }\\n\\n    int maxScoreWords(vector<string>& w, vector<char>& l, vector<int>& sc) {\\n        for(auto i:l)m[i]++;\\n        for(int i=0;i<26;i++)s[\\'a\\'+i]=sc[i];\\n\\n        return f(0,w,0);\\n\\n    }\\n};\\n```\\n\\n# **Please upvote if you like the solution.**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<char,int>m;\\n    unordered_map<char,int>s;\\n\\n    int isSet(int i, int mask){\\n        return (mask & (1<<i));\\n    }\\n\\n    void setBit(int i, int &mask){\\n        mask=(mask | (1<<i));\\n        return;\\n    }\\n\\n    void unsetbit(int i, int &mask){\\n        mask=(mask & ~(1<<i));\\n        return;\\n    }\\n\\n    int val(int mask, vector<string>&w){\\n        int ans=0;\\n        for(int i=0;i<w.size();i++){\\n            if(isSet(i,mask)){\\n                for(auto j:w[i]){\\n                    ans+=s[j];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    bool cantake(int ind, int mask, vector<string>&w){\\n        unordered_map<char,int>temp(m.begin(),m.end());\\n        for(int i=0;i<w.size();i++){\\n            if(isSet(i,mask)){\\n                for(auto j:w[i]){\\n                    temp[j]--;\\n                }\\n            }\\n        }\\n\\n        for(auto j:w[ind]){\\n            if(temp[j]==0)return false;\\n            temp[j]--;\\n        }\\n        return true;\\n    }\\n\\n    unordered_map<int,int>dp;\\n\\n    int f(int i, vector<string>&w, int mask){\\n        if(i==w.size()){\\n            return val(mask,w);\\n        }\\n\\n        if(dp.count(mask))return dp[mask];\\n\\n        //take\\n        int ans=0;\\n        if(cantake(i,mask,w)){\\n            setBit(i,mask);\\n            ans=max(ans,f(i+1,w,mask));\\n            unsetbit(i,mask);\\n        }\\n\\n        //nottake\\n        ans=max(ans,f(i+1,w,mask));\\n        return dp[mask]=ans;\\n\\n    }\\n\\n    int maxScoreWords(vector<string>& w, vector<char>& l, vector<int>& sc) {\\n        for(auto i:l)m[i]++;\\n        for(int i=0;i<26;i++)s[\\'a\\'+i]=sc[i];\\n\\n        return f(0,w,0);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975932,
                "title": "python-backtracking-concise-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxScoreWords(self, words, letters, score):\\n        \"\"\"\\n        :type words: List[str]\\n        :type letters: List[str]\\n        :type score: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        counter = Counter(letters)\\n        N = len(words)\\n\\n        def backtrack(start, letter_counter):\\n\\n            if start == N:\\n                return 0 #no more words are left so just return 0\\n\\n            res = 0    \\n            for i in range(start, N):\\n                letter_counter_copy = copy.deepcopy(letter_counter)\\n                word = words[i]\\n                word_score = 0\\n                word_writable = True\\n                for c in word:\\n                    if c in letter_counter_copy and letter_counter_copy[c] > 0:\\n                        letter_counter_copy[c] -= 1\\n                        word_score += score[ord(c) - ord(\\'a\\')]\\n                    else:\\n                        word_writable = False\\n                        break\\n                if word_writable:\\n                    res = max(res, backtrack(i+1, letter_counter_copy) + word_score)\\n\\n            return res\\n \\n        return backtrack(0, counter)\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxScoreWords(self, words, letters, score):\\n        \"\"\"\\n        :type words: List[str]\\n        :type letters: List[str]\\n        :type score: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        counter = Counter(letters)\\n        N = len(words)\\n\\n        def backtrack(start, letter_counter):\\n\\n            if start == N:\\n                return 0 #no more words are left so just return 0\\n\\n            res = 0    \\n            for i in range(start, N):\\n                letter_counter_copy = copy.deepcopy(letter_counter)\\n                word = words[i]\\n                word_score = 0\\n                word_writable = True\\n                for c in word:\\n                    if c in letter_counter_copy and letter_counter_copy[c] > 0:\\n                        letter_counter_copy[c] -= 1\\n                        word_score += score[ord(c) - ord(\\'a\\')]\\n                    else:\\n                        word_writable = False\\n                        break\\n                if word_writable:\\n                    res = max(res, backtrack(i+1, letter_counter_copy) + word_score)\\n\\n            return res\\n \\n        return backtrack(0, counter)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948954,
                "title": "recursive-solution-choose-or-unchoose",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n  int maxScoreWords(vector<string>& W, vector<char>& L, vector<int>& S) {\\n    map<char, int> F;\\n    for(int i = 0; i < L.size(); i++) {\\n      F[L[i]]++;\\n    }\\n    auto rec = [&] (auto&  slf, int j) -> int {\\n      if(j == W.size()) {\\n        return 0;\\n      }\\n      int res = 0;\\n      res = slf(slf, j + 1);\\n      map<char, int> tmp;\\n      for(char ch : W[j]) {\\n        tmp[ch]++;\\n      }\\n      bool ok = true;\\n      for(char ch : W[j]) {\\n        ok &= (F[ch] >= tmp[ch]);\\n      }\\n      if(ok)  {\\n        int tot = 0;\\n        for(char ch : W[j]) {\\n          F[ch]--;\\n          tot += S[ch - \\'a\\'];\\n        }\\n        res = max(res, slf(slf, j + 1) + tot);\\n        for(char ch : W[j]) {\\n          F[ch]++;\\n        }\\n      }\\n      return res;\\n    };\\n    return rec(rec, 0);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int maxScoreWords(vector<string>& W, vector<char>& L, vector<int>& S) {\\n    map<char, int> F;\\n    for(int i = 0; i < L.size(); i++) {\\n      F[L[i]]++;\\n    }\\n    auto rec = [&] (auto&  slf, int j) -> int {\\n      if(j == W.size()) {\\n        return 0;\\n      }\\n      int res = 0;\\n      res = slf(slf, j + 1);\\n      map<char, int> tmp;\\n      for(char ch : W[j]) {\\n        tmp[ch]++;\\n      }\\n      bool ok = true;\\n      for(char ch : W[j]) {\\n        ok &= (F[ch] >= tmp[ch]);\\n      }\\n      if(ok)  {\\n        int tot = 0;\\n        for(char ch : W[j]) {\\n          F[ch]--;\\n          tot += S[ch - \\'a\\'];\\n        }\\n        res = max(res, slf(slf, j + 1) + tot);\\n        for(char ch : W[j]) {\\n          F[ch]++;\\n        }\\n      }\\n      return res;\\n    };\\n    return rec(rec, 0);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948009,
                "title": "java-solution-beats-100",
                "content": "![image](https://assets.leetcode.com/users/images/da3a6d1c-0465-421e-b073-2325bee3935c_1692758061.007992.jpeg)\\n\\n```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n\\t // It stores the count of letters\\n        int count[] = new int[26];\\n        for(int i=0;i<letters.length;i++){\\n            count[letters[i]-\\'a\\']++;\\n        }\\n        return backtrack(0,words,score,count);\\n        \\n    }\\n    private int backtrack(int idx, String[] words,int[] score,int[] count){\\n        if(idx==words.length) return 0;\\n\\t\\t// we exclude current words and move to next index\\n        int exc = backtrack(idx+1,words,score,count);\\n         int sum = 0;\\n         int i=0;\\n\\t\\t // We check if all the letters of word are present in count array if not present then we will mark sum=0\\n        for(i=0;i<words[idx].length();i++){\\n            char c = words[idx].charAt(i);\\n            if(count[c-\\'a\\']>0){\\n                sum+=score[c-\\'a\\'];\\n                count[c-\\'a\\']--;\\n            }else{\\n                sum = 0;\\n                break;\\n            }\\n        }\\n        int inc = 0;\\n\\t\\t// If sum=0 then all the letters of word are not present in count and we will not move forward with this word \\n        if(sum!=0)\\n        inc = sum+backtrack(idx+1,words,score,count);\\n\\t\\t//we will backtrack and adds back all the letters in count \\n        for(int j=0;j<i;j++){\\n            char c = words[idx].charAt(j);\\n            count[c-\\'a\\']++;\\n        }\\n\\t\\t// return maximum \\n        return Math.max(inc,exc);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n\\t // It stores the count of letters\\n        int count[] = new int[26];\\n        for(int i=0;i<letters.length;i++){\\n            count[letters[i]-\\'a\\']++;\\n        }\\n        return backtrack(0,words,score,count);\\n        \\n    }\\n    private int backtrack(int idx, String[] words,int[] score,int[] count){\\n        if(idx==words.length) return 0;\\n\\t\\t// we exclude current words and move to next index\\n        int exc = backtrack(idx+1,words,score,count);\\n         int sum = 0;\\n         int i=0;\\n\\t\\t // We check if all the letters of word are present in count array if not present then we will mark sum=0\\n        for(i=0;i<words[idx].length();i++){\\n            char c = words[idx].charAt(i);\\n            if(count[c-\\'a\\']>0){\\n                sum+=score[c-\\'a\\'];\\n                count[c-\\'a\\']--;\\n            }else{\\n                sum = 0;\\n                break;\\n            }\\n        }\\n        int inc = 0;\\n\\t\\t// If sum=0 then all the letters of word are not present in count and we will not move forward with this word \\n        if(sum!=0)\\n        inc = sum+backtrack(idx+1,words,score,count);\\n\\t\\t//we will backtrack and adds back all the letters in count \\n        for(int j=0;j<i;j++){\\n            char c = words[idx].charAt(j);\\n            count[c-\\'a\\']++;\\n        }\\n\\t\\t// return maximum \\n        return Math.max(inc,exc);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947518,
                "title": "java-solution-using-recursion-and-backtracking-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        \\n        int[] farr = new int[26];\\n        for(char ch : letters) farr[ch - \\'a\\']++;\\n        \\n        return solve(words,farr,score,0);\\n    }\\n    \\n    public int solve(String[] words, int[] farr, int[] score, int idx){\\n        if(idx == words.length) return 0;\\n        \\n        //Calls without including ith word\\n        int sno = solve(words,farr,score,idx + 1);\\n\\n        //Calls including ith word with checking fequency of letter\\n        int sword = 0;\\n        boolean flag = true;\\n        String word = words[idx];\\n        int syes = 0;\\n        for(int i = 0; i < word.length(); ++i){\\n            char ch = word.charAt(i);\\n            \\n            if(farr[ch-\\'a\\'] == 0) flag = false; // not possible to include word\\n            \\n            farr[ch-\\'a\\']--;//  decrease the frequency\\n            sword += score[ch-\\'a\\']; // increase the particular word score\\n        }\\n        \\n        if(flag) syes = sword+ solve(words,farr,score,idx+1);\\n        \\n        for(int i =0; i < word.length(); ++i){\\n            char ch = word.charAt(i);\\n            farr[ch-\\'a\\']++;// backtrack and undo the changes\\n        }\\n        \\n        return Math.max(syes,sno); // find the max score\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        \\n        int[] farr = new int[26];\\n        for(char ch : letters) farr[ch - \\'a\\']++;\\n        \\n        return solve(words,farr,score,0);\\n    }\\n    \\n    public int solve(String[] words, int[] farr, int[] score, int idx){\\n        if(idx == words.length) return 0;\\n        \\n        //Calls without including ith word\\n        int sno = solve(words,farr,score,idx + 1);\\n\\n        //Calls including ith word with checking fequency of letter\\n        int sword = 0;\\n        boolean flag = true;\\n        String word = words[idx];\\n        int syes = 0;\\n        for(int i = 0; i < word.length(); ++i){\\n            char ch = word.charAt(i);\\n            \\n            if(farr[ch-\\'a\\'] == 0) flag = false; // not possible to include word\\n            \\n            farr[ch-\\'a\\']--;//  decrease the frequency\\n            sword += score[ch-\\'a\\']; // increase the particular word score\\n        }\\n        \\n        if(flag) syes = sword+ solve(words,farr,score,idx+1);\\n        \\n        for(int i =0; i < word.length(); ++i){\\n            char ch = word.charAt(i);\\n            farr[ch-\\'a\\']++;// backtrack and undo the changes\\n        }\\n        \\n        return Math.max(syes,sno); // find the max score\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945570,
                "title": "recursion-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        words = [Counter(w) for w in words]\\n        letters = Counter(letters)\\n        total = 0\\n        \\n        def dp(wrds, ltrs, deep):\\n            nonlocal total\\n            for i, w in enumerate(wrds):\\n                for l in w:\\n                    if l not in ltrs:\\n                        break\\n                    if ltrs[l] < w[l]:\\n                        break\\n                else:\\n                    sub_sum = sum([score[ord(l)-ord(\\'a\\')]*w[l] for l in w])\\n                    dp(wrds[i+1:], ltrs-wrds[i], deep+sub_sum)\\n            total = max(deep,total)\\n        dp(words, letters, 0)\\n        return total\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\\n        words = [Counter(w) for w in words]\\n        letters = Counter(letters)\\n        total = 0\\n        \\n        def dp(wrds, ltrs, deep):\\n            nonlocal total\\n            for i, w in enumerate(wrds):\\n                for l in w:\\n                    if l not in ltrs:\\n                        break\\n                    if ltrs[l] < w[l]:\\n                        break\\n                else:\\n                    sub_sum = sum([score[ord(l)-ord(\\'a\\')]*w[l] for l in w])\\n                    dp(wrds[i+1:], ltrs-wrds[i], deep+sub_sum)\\n            total = max(deep,total)\\n        dp(words, letters, 0)\\n        return total\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937995,
                "title": "easy-cpp-code-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(unordered_map<char,int> freq,string s){\\n        for(char c:s){\\n            freq[c]--;\\n            if(freq[c]<0)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n    void solve(int ind,vector<string>& words,unordered_map<char,int> freq , vector<int>& score,int cur, int & ans){\\n\\n        if(ind<0)\\n        {\\n            ans = max(ans,cur);\\n            return;\\n        }\\n\\n        solve(ind-1,words,freq,score,cur,ans);\\n\\n        if(check(freq,words[ind])){\\n            int sum = 0;\\n            for(char c:words[ind]){\\n                freq[c]--;\\n                sum += score[c-\\'a\\'];\\n            }\\n\\n            solve(ind-1,words,freq,score,cur+sum,ans);\\n            \\n        }\\n\\n\\n\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        int ans = 0;\\n        int n = words.size();\\n        unordered_map<char,int> freq;\\n        for(char c:letters){\\n            freq[c]++;\\n        }\\n        solve(n-1,words,freq,score,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(unordered_map<char,int> freq,string s){\\n        for(char c:s){\\n            freq[c]--;\\n            if(freq[c]<0)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n    void solve(int ind,vector<string>& words,unordered_map<char,int> freq , vector<int>& score,int cur, int & ans){\\n\\n        if(ind<0)\\n        {\\n            ans = max(ans,cur);\\n            return;\\n        }\\n\\n        solve(ind-1,words,freq,score,cur,ans);\\n\\n        if(check(freq,words[ind])){\\n            int sum = 0;\\n            for(char c:words[ind]){\\n                freq[c]--;\\n                sum += score[c-\\'a\\'];\\n            }\\n\\n            solve(ind-1,words,freq,score,cur+sum,ans);\\n            \\n        }\\n\\n\\n\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        int ans = 0;\\n        int n = words.size();\\n        unordered_map<char,int> freq;\\n        for(char c:letters){\\n            freq[c]++;\\n        }\\n        solve(n-1,words,freq,score,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927217,
                "title": "c-code-using-bitwise",
                "content": "## Code:\\n\\n```\\nclass Solution {\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& availableLetters, vector<int>& letterScores) {\\n        int numWords = words.size();\\n        vector<int> wordScores(numWords, 0);\\n\\n        // Calculate the score for each individual word\\n        for (int i = 0; i < numWords; ++i) {\\n            int wordScore = 0;\\n            for (char letter : words[i]) {\\n                wordScore += letterScores[letter - \\'a\\'];\\n            }\\n            wordScores[i] = wordScore;\\n        }\\n\\n        int maxScore = INT_MIN;\\n        // Create a map to store the frequency of characters in the available letters\\n        map<char, int> letterFrequency;\\n\\n        // Count the frequency of each character in the available letters\\n        for (char letter : availableLetters) {\\n            letterFrequency[letter]++;\\n        }\\n\\n        // Generate all possible subsets of words\\n        for (int subset = 0; subset < (1 << numWords); ++subset) {\\n            vector<pair<int, string>> selectedWords;\\n            // Choose words based on the current subset\\n            for (int i = 0; i < numWords; ++i) {\\n                if (subset & (1 << i)) {  // Check if the i-th bit is set in the binary representation of subset\\n                    selectedWords.push_back({i, words[i]});\\n                }\\n            }\\n\\n            map<char, int> availableLettersCopy = letterFrequency;\\n            int currentScore = 0;\\n            // Iterate through the selected words in the subset\\n            for (int i = 0; i < selectedWords.size(); ++i) {\\n                int invalidFlag = 0;\\n                // Check if the characters in the word are available in the available letters\\n                for (char letter : selectedWords[i].second) {\\n                    if (availableLettersCopy.find(letter) == availableLettersCopy.end() || availableLettersCopy[letter] <= 0) {\\n                        invalidFlag = 1;\\n                        break;\\n                    }\\n                    availableLettersCopy[letter]--;\\n                }\\n                if (invalidFlag) {\\n                    currentScore = INT_MIN;  // Invalid subset, set current score to minimum\\n                    break;\\n                } else {\\n                    currentScore += wordScores[selectedWords[i].first];  // Add score of valid word to current score\\n                }\\n            }\\n\\n            maxScore = max(currentScore, maxScore);  // Update the maximum score\\n        }\\n        return maxScore;  // Return the maximum achievable score\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& availableLetters, vector<int>& letterScores) {\\n        int numWords = words.size();\\n        vector<int> wordScores(numWords, 0);\\n\\n        // Calculate the score for each individual word\\n        for (int i = 0; i < numWords; ++i) {\\n            int wordScore = 0;\\n            for (char letter : words[i]) {\\n                wordScore += letterScores[letter - \\'a\\'];\\n            }\\n            wordScores[i] = wordScore;\\n        }\\n\\n        int maxScore = INT_MIN;\\n        // Create a map to store the frequency of characters in the available letters\\n        map<char, int> letterFrequency;\\n\\n        // Count the frequency of each character in the available letters\\n        for (char letter : availableLetters) {\\n            letterFrequency[letter]++;\\n        }\\n\\n        // Generate all possible subsets of words\\n        for (int subset = 0; subset < (1 << numWords); ++subset) {\\n            vector<pair<int, string>> selectedWords;\\n            // Choose words based on the current subset\\n            for (int i = 0; i < numWords; ++i) {\\n                if (subset & (1 << i)) {  // Check if the i-th bit is set in the binary representation of subset\\n                    selectedWords.push_back({i, words[i]});\\n                }\\n            }\\n\\n            map<char, int> availableLettersCopy = letterFrequency;\\n            int currentScore = 0;\\n            // Iterate through the selected words in the subset\\n            for (int i = 0; i < selectedWords.size(); ++i) {\\n                int invalidFlag = 0;\\n                // Check if the characters in the word are available in the available letters\\n                for (char letter : selectedWords[i].second) {\\n                    if (availableLettersCopy.find(letter) == availableLettersCopy.end() || availableLettersCopy[letter] <= 0) {\\n                        invalidFlag = 1;\\n                        break;\\n                    }\\n                    availableLettersCopy[letter]--;\\n                }\\n                if (invalidFlag) {\\n                    currentScore = INT_MIN;  // Invalid subset, set current score to minimum\\n                    break;\\n                } else {\\n                    currentScore += wordScores[selectedWords[i].first];  // Add score of valid word to current score\\n                }\\n            }\\n\\n            maxScore = max(currentScore, maxScore);  // Update the maximum score\\n        }\\n        return maxScore;  // Return the maximum achievable score\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904804,
                "title": "easy-c-solution-self-explanatory-code-readable-code",
                "content": "# Please Upvote\\u2705\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<string>& words, int idx, unordered_map<char,int>fre, vector<int>& score)\\n    {\\n        if(idx == words.size())\\n        {\\n            return 0;\\n        }\\n        int NotSelect = solve(words,idx+1,fre,score);\\n        string s = words[idx];\\n        int Wordscore = 0;\\n        bool flagIsSuffFreq = true;\\n        for(char ch:s){\\n            if(fre[ch] == 0){\\n                flagIsSuffFreq = false;\\n            }\\n            fre[ch]--;\\n            Wordscore += score[ch - \\'a\\'];\\n        }\\n        int select = 0;\\n        if(flagIsSuffFreq){\\n            select = Wordscore + solve(words,idx+1,fre,score);\\n        }\\n        \\n        return max(select,NotSelect);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        unordered_map<char,int>fre;\\n        for(char ch : letters)\\n        {\\n            fre[ch]++;\\n        }\\n        return solve(words,0,fre,score);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<string>& words, int idx, unordered_map<char,int>fre, vector<int>& score)\\n    {\\n        if(idx == words.size())\\n        {\\n            return 0;\\n        }\\n        int NotSelect = solve(words,idx+1,fre,score);\\n        string s = words[idx];\\n        int Wordscore = 0;\\n        bool flagIsSuffFreq = true;\\n        for(char ch:s){\\n            if(fre[ch] == 0){\\n                flagIsSuffFreq = false;\\n            }\\n            fre[ch]--;\\n            Wordscore += score[ch - \\'a\\'];\\n        }\\n        int select = 0;\\n        if(flagIsSuffFreq){\\n            select = Wordscore + solve(words,idx+1,fre,score);\\n        }\\n        \\n        return max(select,NotSelect);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        unordered_map<char,int>fre;\\n        for(char ch : letters)\\n        {\\n            fre[ch]++;\\n        }\\n        return solve(words,0,fre,score);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900133,
                "title": "simple-recursive-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int n;\\n\\n    int f(int i,vector<int> cnt,vector<string>& words,vector<int>& score) {\\n        n=words.size();\\n        if(i==n)\\n            return 0;\\n        int nt=f(i+1,cnt,words,score),t=0,tmp=0;\\n        vector<int> v=cnt;\\n        for(auto j:words[i])\\n        {\\n            tmp+=score[j-\\'a\\'];\\n            v[j-\\'a\\']--;\\n            if(v[j-\\'a\\']<0)\\n            {\\n                tmp=-1;\\n                break;\\n            }\\n        }\\n        if(tmp!=-1)\\n            t=tmp+f(i+1,v,words,score);\\n        return max(t,nt);\\n    }\\n\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> cnt(26);\\n        for(auto i:letters)\\n            cnt[i-\\'a\\']++;\\n        return f(0,cnt,words,score);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int n;\\n\\n    int f(int i,vector<int> cnt,vector<string>& words,vector<int>& score) {\\n        n=words.size();\\n        if(i==n)\\n            return 0;\\n        int nt=f(i+1,cnt,words,score),t=0,tmp=0;\\n        vector<int> v=cnt;\\n        for(auto j:words[i])\\n        {\\n            tmp+=score[j-\\'a\\'];\\n            v[j-\\'a\\']--;\\n            if(v[j-\\'a\\']<0)\\n            {\\n                tmp=-1;\\n                break;\\n            }\\n        }\\n        if(tmp!=-1)\\n            t=tmp+f(i+1,v,words,score);\\n        return max(t,nt);\\n    }\\n\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> cnt(26);\\n        for(auto i:letters)\\n            cnt[i-\\'a\\']++;\\n        return f(0,cnt,words,score);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884439,
                "title": "simple-recurrsion",
                "content": "# Intuition:\\nThe problem requires finding the maximum score that can be obtained by forming words from a given list of words, using a given set of letters and their corresponding scores. To maximize the score, we need to consider different combinations of words while respecting the availability of letters.\\n\\n# Approach:\\nFrequency Counting: We start by counting the frequency of each letter in the given set of letters.\\n\\nBacktracking with Recursion: We can approach this problem using backtracking with recursion. The basic idea is to iterate through the list of words and decide whether to include the current word or not. For each word, we have two choices: either use it and update the letter frequencies, or skip it and move to the next word.\\n\\nHelper Function: We define a recursive helper function that takes the following parameters:\\n\\nwords: The list of words.\\nfreq: The frequency of available letters.\\nscore: The score of each letter.\\ncurr_freq: The current frequency of letters being used.\\ni: The index of the word being considered.\\nIn the helper function:\\n\\nWe calculate the score for the current word by iterating through its characters, updating the letter frequencies and adding the corresponding scores.\\nIf we can use the current word (i.e., there are enough available letters), we have two options: include the word or skip it. We recursively call the helper function with updated parameters for both cases and return the maximum score.\\nIf we cannot use the current word, we simply skip it and move to the next word by recursively calling the helper function with the same parameters.\\nMain Function: The main maxScoreWords function initializes the frequency of available letters and calls the helper function to start the recursive process. It returns the maximum score obtained.\\n\\n# Complexity:\\n\\nTime Complexity: The time complexity of this approach depends on the number of words and the length of each word. In the worst case, where each word is considered both with and without using it, the time complexity can be exponential. However, due to backtracking and pruning, the actual time complexity is generally lower than the worst case.\\n\\nSpace Complexity: The space complexity mainly depends on the recursion depth and the additional data structures used for frequency counting and scores. It can be considered as linear in terms of the number of words and the number of distinct letters.\\nPlease note that this analysis provides a high-level overview and that the actual performance can vary based on factors such as the specific input data and the efficiency of the implementation.\\n\\n# Code\\n```\\nclass Solution {\\n    int helper(vector<string>& words, vector<int>& freq, vector<int>& score, vector<int> curr_freq, int i){\\n        if(i == words.size())return 0;\\n        vector<int> temp = curr_freq;\\n        bool flag = true;\\n        int scr = 0;\\n        for(char c : words[i]){\\n            temp[c - \\'a\\']++;\\n            scr += score[c - \\'a\\'];\\n            if(temp[c - \\'a\\'] > freq[c - \\'a\\']){\\n                flag = false;\\n                break;\\n            }\\n        }\\n        if(flag)return max(helper(words, freq, score, curr_freq, i + 1), scr + helper(words, freq, score, temp, i + 1));\\n        return helper(words, freq, score, curr_freq, i + 1);\\n    }\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> freq(26, 0);\\n        for(char c : letters){\\n            freq[c - \\'a\\']++;\\n        }\\n        vector<int> curr_freq(26, 0);\\n        return helper(words, freq, score, curr_freq, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int helper(vector<string>& words, vector<int>& freq, vector<int>& score, vector<int> curr_freq, int i){\\n        if(i == words.size())return 0;\\n        vector<int> temp = curr_freq;\\n        bool flag = true;\\n        int scr = 0;\\n        for(char c : words[i]){\\n            temp[c - \\'a\\']++;\\n            scr += score[c - \\'a\\'];\\n            if(temp[c - \\'a\\'] > freq[c - \\'a\\']){\\n                flag = false;\\n                break;\\n            }\\n        }\\n        if(flag)return max(helper(words, freq, score, curr_freq, i + 1), scr + helper(words, freq, score, temp, i + 1));\\n        return helper(words, freq, score, curr_freq, i + 1);\\n    }\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        vector<int> freq(26, 0);\\n        for(char c : letters){\\n            freq[c - \\'a\\']++;\\n        }\\n        vector<int> curr_freq(26, 0);\\n        return helper(words, freq, score, curr_freq, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880204,
                "title": "solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n   \\n   THIS IS A QUESTION OF DP , BUT THE MAIN THING IN THIS QUESTION IS TO APPLY MEMOISATION \\n\\n\\n   the main catch is how we can apply memoisation in this question to store the \\n   repetitive call , \\n\\n   first doing without memoistaion , we realised that , there is two variable thing\\n   index and frequency ; \\n\\n   // now frequency is array , but we can not take array as a key , so we will use\\n   // string here , this is the main catch ; \\n\\n*/ \\n\\n\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        \\n\\n        // since maximum score bhi nikalna ha , so ya toh greedy se hoga ; \\n        // ya dp se , \\n\\n        // but greedy se answer sahi nhi hoga , kyoki isme humein saare combination\\n        // dekhne padhenge ; \\n\\n\\n        int frequency[] = new int[26] ; \\n\\n \\n\\n        for( int i = 0 ; i < letters.length ; i++)\\n        {\\n            frequency[letters[i]-\\'a\\']++ ; \\n        }\\n\\n\\n      /*\\n            using of hashmap for memoisation and\\n\\n            using string(frquency array to string) as a key  is the main catch ; \\n\\n\\n      */\\n\\n      HashMap<Integer,HashMap<String,Integer>> map = new HashMap<>() ; \\n\\n\\n        return helper( words , 0 , frequency , score , map ) ; \\n        \\n\\n        \\n    }\\n    public int helper( String words[] , int index , int frequency[] , int score[],HashMap<Integer,HashMap<String,Integer>> map)\\n    {\\n\\n        if( index == words.length)\\n        {\\n            return 0 ; \\n        } \\n\\n\\n        StringBuilder str = new StringBuilder() ; \\n\\n        for( int i = 0 ; i < frequency.length ; i++)\\n        {\\n            str.append(frequency[i]+\"_\") ; \\n        }\\n\\n        String check = str. toString() ; \\n\\n        if( map.containsKey(index))\\n        {\\n            HashMap<String,Integer> map1 = map.get(index) ; \\n\\n\\n            if( map1.containsKey(check))\\n            return map1.get(check) ; \\n        }\\n\\n\\n          // now har index par 2 option hai \\n\\n          // lenge ya nhi , (aur lenge tab hi jab lena possible ho ) ; \\n\\n\\n        \\n\\n        // option-1 --------nahi lenge ; \\n\\n        int opt1 = helper(words , index+1 , frequency , score , map ) ; \\n\\n\\n\\n        // option2 - take , only take when it is possible ; \\n        boolean canTake = helper1( words[index] , frequency) ; \\n\\n        if( canTake == false)\\n        return opt1 ; \\n\\n        // update frequency array ; \\n\\n        String temp = words[index] ;\\n\\n        int tempScore = 0 ;  \\n\\n        for( int i = 0 ; i < temp.length() ; i++)\\n        {\\n            tempScore += score[temp.charAt(i) - \\'a\\'] ; \\n            frequency[temp.charAt(i) - \\'a\\']-- ; \\n        }\\n\\n\\n        int opt2 = helper( words , index+1 , frequency , score , map) + tempScore ; \\n\\n\\n        // now again udpate the frequency array while backtracking ; \\n\\n        for( int i = 0 ; i < temp.length() ; i++)\\n        {\\n            \\n            frequency[temp.charAt(i) - \\'a\\']++ ; \\n        }\\n\\n\\n        int answer = Math.max(opt1 , opt2) ; \\n\\n\\n         if( map.containsKey(index))\\n        {\\n            HashMap<String,Integer> map1 = map.get(index) ; \\n\\n\\n            map1.put(check, answer) ; \\n        }\\n        else\\n        {\\n            HashMap<String,Integer> map1 = new HashMap<>() ; \\n            map1.put(check, answer) ; \\n\\n            map.put(index , map1) ; \\n        }\\n\\n\\n        return answer ; \\n\\n\\n    }\\n    public boolean helper1( String s , int frequency[])\\n    {\\n        int temp[] = new int[26] ; \\n\\n\\n        for( int i = 0 ; i < s.length() ; i++)\\n        {\\n            temp[s.charAt(i)-\\'a\\']++ ; \\n        }\\n\\n        for( int i = 0 ; i < temp.length ; i++)\\n        {\\n            if( temp[i] > frequency[i])\\n            return false ; \\n        }\\n\\n\\n        return true; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n   \\n   THIS IS A QUESTION OF DP , BUT THE MAIN THING IN THIS QUESTION IS TO APPLY MEMOISATION \\n\\n\\n   the main catch is how we can apply memoisation in this question to store the \\n   repetitive call , \\n\\n   first doing without memoistaion , we realised that , there is two variable thing\\n   index and frequency ; \\n\\n   // now frequency is array , but we can not take array as a key , so we will use\\n   // string here , this is the main catch ; \\n\\n*/ \\n\\n\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        \\n\\n        // since maximum score bhi nikalna ha , so ya toh greedy se hoga ; \\n        // ya dp se , \\n\\n        // but greedy se answer sahi nhi hoga , kyoki isme humein saare combination\\n        // dekhne padhenge ; \\n\\n\\n        int frequency[] = new int[26] ; \\n\\n \\n\\n        for( int i = 0 ; i < letters.length ; i++)\\n        {\\n            frequency[letters[i]-\\'a\\']++ ; \\n        }\\n\\n\\n      /*\\n            using of hashmap for memoisation and\\n\\n            using string(frquency array to string) as a key  is the main catch ; \\n\\n\\n      */\\n\\n      HashMap<Integer,HashMap<String,Integer>> map = new HashMap<>() ; \\n\\n\\n        return helper( words , 0 , frequency , score , map ) ; \\n        \\n\\n        \\n    }\\n    public int helper( String words[] , int index , int frequency[] , int score[],HashMap<Integer,HashMap<String,Integer>> map)\\n    {\\n\\n        if( index == words.length)\\n        {\\n            return 0 ; \\n        } \\n\\n\\n        StringBuilder str = new StringBuilder() ; \\n\\n        for( int i = 0 ; i < frequency.length ; i++)\\n        {\\n            str.append(frequency[i]+\"_\") ; \\n        }\\n\\n        String check = str. toString() ; \\n\\n        if( map.containsKey(index))\\n        {\\n            HashMap<String,Integer> map1 = map.get(index) ; \\n\\n\\n            if( map1.containsKey(check))\\n            return map1.get(check) ; \\n        }\\n\\n\\n          // now har index par 2 option hai \\n\\n          // lenge ya nhi , (aur lenge tab hi jab lena possible ho ) ; \\n\\n\\n        \\n\\n        // option-1 --------nahi lenge ; \\n\\n        int opt1 = helper(words , index+1 , frequency , score , map ) ; \\n\\n\\n\\n        // option2 - take , only take when it is possible ; \\n        boolean canTake = helper1( words[index] , frequency) ; \\n\\n        if( canTake == false)\\n        return opt1 ; \\n\\n        // update frequency array ; \\n\\n        String temp = words[index] ;\\n\\n        int tempScore = 0 ;  \\n\\n        for( int i = 0 ; i < temp.length() ; i++)\\n        {\\n            tempScore += score[temp.charAt(i) - \\'a\\'] ; \\n            frequency[temp.charAt(i) - \\'a\\']-- ; \\n        }\\n\\n\\n        int opt2 = helper( words , index+1 , frequency , score , map) + tempScore ; \\n\\n\\n        // now again udpate the frequency array while backtracking ; \\n\\n        for( int i = 0 ; i < temp.length() ; i++)\\n        {\\n            \\n            frequency[temp.charAt(i) - \\'a\\']++ ; \\n        }\\n\\n\\n        int answer = Math.max(opt1 , opt2) ; \\n\\n\\n         if( map.containsKey(index))\\n        {\\n            HashMap<String,Integer> map1 = map.get(index) ; \\n\\n\\n            map1.put(check, answer) ; \\n        }\\n        else\\n        {\\n            HashMap<String,Integer> map1 = new HashMap<>() ; \\n            map1.put(check, answer) ; \\n\\n            map.put(index , map1) ; \\n        }\\n\\n\\n        return answer ; \\n\\n\\n    }\\n    public boolean helper1( String s , int frequency[])\\n    {\\n        int temp[] = new int[26] ; \\n\\n\\n        for( int i = 0 ; i < s.length() ; i++)\\n        {\\n            temp[s.charAt(i)-\\'a\\']++ ; \\n        }\\n\\n        for( int i = 0 ; i < temp.length ; i++)\\n        {\\n            if( temp[i] > frequency[i])\\n            return false ; \\n        }\\n\\n\\n        return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879148,
                "title": "rust-recursion-backtracking-beats-100",
                "content": "# Intuition\\n\\nJust,,,try every single possible combination.\\n\\n# Approach\\n\\nWe can use recursion to make the code a bit faster. For each recursion:\\n\\n1. Skip the current word, and recursively get the max score.\\n2. Check if there are enough letters left to pick the current word.\\n3. If the current word can be taken, take it and calculate the max score in this situation.\\n4. Compare two scores and return the largest one.\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```rust\\nconst ALP_LEN: usize = 26;\\n\\npub fn backtrack(\\n    words: &mut Vec<[usize; ALP_LEN]>,\\n    freq_map: &mut [usize; ALP_LEN],\\n    weight_map: &[usize; ALP_LEN],\\n) -> usize {\\n    if words.is_empty() { return usize::MIN; }\\n\\n    let word = words.pop().unwrap();\\n\\n    // not picking this word\\n    let mut ret = backtrack(words, freq_map, weight_map);\\n\\n    let is_avail = word.iter()\\n        .zip(freq_map.iter())\\n        .all(|(&e0, &e)| e0 <= e);\\n\\n    if is_avail {        \\n        // try picking this word\\n        for i in 0..ALP_LEN { freq_map[i] -= word[i]; }\\n\\n        let mut _ret = backtrack(words, freq_map, weight_map);\\n        for i in 0..ALP_LEN {\\n            _ret += word[i] * weight_map[i];\\n        }\\n        ret = ret.max(_ret);\\n\\n        for i in 0..ALP_LEN { freq_map[i] += word[i]; }\\n    }\\n\\n    words.push(word);\\n\\n    ret\\n}\\n\\npub fn to_freq_map(vec: Vec<usize>) -> [usize; ALP_LEN] {\\n    let mut ret = [usize::MIN; ALP_LEN];\\n    for e in vec { ret[e] += 1; }\\n    ret\\n}\\n\\nuse std::convert::TryInto;\\nimpl Solution {\\n    fn preproc(vec: Vec<String>) -> Vec<Vec<usize>> {\\n        vec.into_iter()\\n            .map(|s| s.chars()\\n                .map(|c| c as usize - \\'a\\' as usize)\\n                .collect::<Vec<_>>())\\n            .collect::<Vec<_>>()\\n    }\\n\\n    pub fn max_score_words(words: Vec<String>, letters: Vec<char>, score: Vec<i32>) -> i32 {\\n        let words = Self::preproc(words);\\n        let mut words = words.into_iter()\\n            .map(|v| to_freq_map(v))\\n            .collect::<Vec<_>>();\\n\\n        let letters = letters.into_iter()\\n            .map(|c| c as usize - \\'a\\' as usize)\\n            .collect::<Vec<_>>();\\n        let mut freq_map = to_freq_map(letters);\\n\\n        let weight_map: [usize; ALP_LEN] = score.into_iter()\\n            .map(|e| e as usize)\\n            .collect::<Vec<_>>()\\n            .try_into()\\n            .unwrap();\\n\\n        backtrack(&mut words, &mut freq_map, &weight_map) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Backtracking"
                ],
                "code": "```rust\\nconst ALP_LEN: usize = 26;\\n\\npub fn backtrack(\\n    words: &mut Vec<[usize; ALP_LEN]>,\\n    freq_map: &mut [usize; ALP_LEN],\\n    weight_map: &[usize; ALP_LEN],\\n) -> usize {\\n    if words.is_empty() { return usize::MIN; }\\n\\n    let word = words.pop().unwrap();\\n\\n    // not picking this word\\n    let mut ret = backtrack(words, freq_map, weight_map);\\n\\n    let is_avail = word.iter()\\n        .zip(freq_map.iter())\\n        .all(|(&e0, &e)| e0 <= e);\\n\\n    if is_avail {        \\n        // try picking this word\\n        for i in 0..ALP_LEN { freq_map[i] -= word[i]; }\\n\\n        let mut _ret = backtrack(words, freq_map, weight_map);\\n        for i in 0..ALP_LEN {\\n            _ret += word[i] * weight_map[i];\\n        }\\n        ret = ret.max(_ret);\\n\\n        for i in 0..ALP_LEN { freq_map[i] += word[i]; }\\n    }\\n\\n    words.push(word);\\n\\n    ret\\n}\\n\\npub fn to_freq_map(vec: Vec<usize>) -> [usize; ALP_LEN] {\\n    let mut ret = [usize::MIN; ALP_LEN];\\n    for e in vec { ret[e] += 1; }\\n    ret\\n}\\n\\nuse std::convert::TryInto;\\nimpl Solution {\\n    fn preproc(vec: Vec<String>) -> Vec<Vec<usize>> {\\n        vec.into_iter()\\n            .map(|s| s.chars()\\n                .map(|c| c as usize - \\'a\\' as usize)\\n                .collect::<Vec<_>>())\\n            .collect::<Vec<_>>()\\n    }\\n\\n    pub fn max_score_words(words: Vec<String>, letters: Vec<char>, score: Vec<i32>) -> i32 {\\n        let words = Self::preproc(words);\\n        let mut words = words.into_iter()\\n            .map(|v| to_freq_map(v))\\n            .collect::<Vec<_>>();\\n\\n        let letters = letters.into_iter()\\n            .map(|c| c as usize - \\'a\\' as usize)\\n            .collect::<Vec<_>>();\\n        let mut freq_map = to_freq_map(letters);\\n\\n        let weight_map: [usize; ALP_LEN] = score.into_iter()\\n            .map(|e| e as usize)\\n            .collect::<Vec<_>>()\\n            .try_into()\\n            .unwrap();\\n\\n        backtrack(&mut words, &mut freq_map, &weight_map) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3877624,
                "title": "easy-clean-and-concise-solution-beats-100",
                "content": "# Intuition:\\nThe problem is to find the maximum score that can be obtained by forming words from the given `words` vector using the provided `letters` and `score` vectors. The idea is to use backtracking with recursion to consider all possible combinations of including or excluding words from the `words` vector. For each word, we check if its letters can be formed using the available characters in the `letters` vector. If so, we add its score to the total score and continue with the next word. We repeat this process until all words are considered, and we backtrack to explore other possibilities.\\n\\n# Approach:\\nThe approach uses a recursive backtracking algorithm. For each word in the `words` vector, we check if its letters can be formed using the available characters in the `letters` vector. If so, we include the word and its score in the total score and continue with the next word. If not, we exclude the word and move to the next one. We keep track of the frequency of each character in the `letters` vector using a frequency array.\\n\\n# Complexity:\\n- Time complexity: O(2^N), where N is the number of words.\\n- Space complexity: The space complexity can be considered as O(N) due to the recursion stack.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int helper(int index, vector<string>& words, vector<int>& score, vector<int>& freq) {\\n    if (index >= words.size())\\n        return 0;\\n\\n    // Not taken\\n    int wordNotTaken = helper(index + 1, words, score, freq);\\n\\n    // Taken\\n    string ch = words[index];\\n    int wordTaken = 0;\\n    bool flag = true; // Flag to check if all letters in the word are available\\n\\n    for (char c : ch) {\\n      if(freq[c-\\'a\\']==0)\\n          flag=false;\\n        \\n      freq[c - \\'a\\']--;\\n      wordTaken += score[c - \\'a\\'];\\n    }\\n\\n    int totalScore = 0;\\n    if (flag) {\\n        totalScore += wordTaken + helper(index + 1, words, score, freq);\\n    }\\n\\n    // Backtrack\\n    for (char c : ch) {\\n        freq[c - \\'a\\']++;\\n    }\\n\\n    return max(totalScore, wordNotTaken);\\n}\\n\\nint maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n    vector<int> freq(26, 0); // Initialize a frequency array for characters\\n\\n    for (char c : letters) {\\n        freq[c - \\'a\\']++; // Count the frequency of each character\\n    }\\n\\n    return helper(0, words, score, freq);\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int helper(int index, vector<string>& words, vector<int>& score, vector<int>& freq) {\\n    if (index >= words.size())\\n        return 0;\\n\\n    // Not taken\\n    int wordNotTaken = helper(index + 1, words, score, freq);\\n\\n    // Taken\\n    string ch = words[index];\\n    int wordTaken = 0;\\n    bool flag = true; // Flag to check if all letters in the word are available\\n\\n    for (char c : ch) {\\n      if(freq[c-\\'a\\']==0)\\n          flag=false;\\n        \\n      freq[c - \\'a\\']--;\\n      wordTaken += score[c - \\'a\\'];\\n    }\\n\\n    int totalScore = 0;\\n    if (flag) {\\n        totalScore += wordTaken + helper(index + 1, words, score, freq);\\n    }\\n\\n    // Backtrack\\n    for (char c : ch) {\\n        freq[c - \\'a\\']++;\\n    }\\n\\n    return max(totalScore, wordNotTaken);\\n}\\n\\nint maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n    vector<int> freq(26, 0); // Initialize a frequency array for characters\\n\\n    for (char c : letters) {\\n        freq[c - \\'a\\']++; // Count the frequency of each character\\n    }\\n\\n    return helper(0, words, score, freq);\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871109,
                "title": "recursive-dp-map-bitmask-well-explained-easy-to-understand",
                "content": "## Intuition\\n\\nThe problem requires finding the maximum score that can be obtained by forming words from given letters, each with a corresponding score. To solve this, we can use a recursive approach along with dynamic programming. We\\'ll consider each word and two possibilities: including it in the formation or excluding it. We\\'ll keep track of the available characters and use the dynamic programming table to store intermediate results to avoid redundant calculations.\\n\\n## Approach\\n\\n1. Create a function `check` that takes a string `s` and a map `chr` representing available characters. Iterate through each character in `s`, decreasing the count of that character in `chr`. If the count becomes negative for any character, return `false`. Otherwise, return `true`.\\n\\n2. Create a function `func` that calculates the maximum score. It takes arguments `ind` (current index of the word), `mask` (a bitmask representing used words), `words` (list of words), `scr` (map of word scores), `chr` (map of available characters), and `dp` (dynamic programming table).\\n\\n    a. Base case: If `ind` is less than 0, return 0.\\n    \\n    b. If `dp[mask][ind]` is not -1, return `dp[mask][ind]`.\\n    \\n    c. Initialize `res` as the result of the recursive call `func(ind-1, mask, words, scr, chr, dp)`.\\n    \\n    d. Check if the current word can be formed using available characters using the `check` function.\\n    \\n        i. If possible, update the character counts, calculate the new score, and call the recursive function with the word included. Update `res` if the new score is greater.\\n        \\n        ii. Restore the character counts to their original state.\\n        \\n    e. Store `res` in `dp[mask][ind]` and return `res`.\\n\\n3. In the `maxScoreWords` function:\\n\\n    a. Initialize the score map `scr` by calculating the score of each word and storing it.\\n    \\n    b. Initialize the character count map `chr` based on the provided letters.\\n    \\n    c. Initialize the DP table `dp` with dimensions `(1 << 14) x 14` and set the initial mask to 0.\\n    \\n    d. Call the `func` function with appropriate arguments and return the result.\\n\\n## Time Complexity\\n$$O(2^N * N * L)$$\\n\\nThe recursive approach considers each word and its two possibilities (including or excluding it). For each word, the `check` function checks if it can be formed using available characters, which takes O(L) time, where L is the average length of the words.\\n\\n## Space Complexity\\n$$O(2^N * N)$$\\n\\nThe space complexity is dominated by the storage of the DP table `dp` with dimensions `(1 << 14) x 14`, which requires O(2^N * N) space. Additionally, space is used for the score map `scr` and character count map `chr`, both requiring O(N) space.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(string s,map<char,int> chr)\\n    {\\n        for(auto x:s)\\n        {\\n            chr[x]--;\\n            if(chr[x]<0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    int func(int ind,int mask,vector<string> &words,map<string,int> &scr, map<char,int> &chr,vector<vector<int>> &dp)\\n    {\\n        if(ind<0)\\n            return 0;\\n        if(dp[mask][ind]!=-1)\\n            return dp[mask][ind];\\n        int res = func(ind-1,mask,words,scr,chr,dp);\\n        if(check(words[ind],chr))\\n        {\\n            for(auto x:words[ind])\\n            {\\n                chr[x]--;\\n            }\\n            res = max(res,scr[words[ind]]+func(ind-1,mask|(1<<ind),words,scr,chr,dp));\\n            for(auto x:words[ind])\\n            {\\n                chr[x]++;\\n            }\\n        }\\n        return dp[mask][ind] = res;\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        map<string,int> scr;\\n        for(auto x:words)\\n        {\\n            int p = 0;\\n            for(auto ch:x)\\n            {\\n                p+=score[ch-\\'a\\'];\\n            }\\n            scr[x] = p;\\n        }\\n        map<char,int> chr;\\n        for(auto x:letters)\\n        {\\n            chr[x]++;\\n        }\\n        vector<vector<int>> dp(1<<14,vector<int>(14,-1));\\n        int mask = 0;\\n        return func(words.size()-1,mask,words,scr,chr,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string s,map<char,int> chr)\\n    {\\n        for(auto x:s)\\n        {\\n            chr[x]--;\\n            if(chr[x]<0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    int func(int ind,int mask,vector<string> &words,map<string,int> &scr, map<char,int> &chr,vector<vector<int>> &dp)\\n    {\\n        if(ind<0)\\n            return 0;\\n        if(dp[mask][ind]!=-1)\\n            return dp[mask][ind];\\n        int res = func(ind-1,mask,words,scr,chr,dp);\\n        if(check(words[ind],chr))\\n        {\\n            for(auto x:words[ind])\\n            {\\n                chr[x]--;\\n            }\\n            res = max(res,scr[words[ind]]+func(ind-1,mask|(1<<ind),words,scr,chr,dp));\\n            for(auto x:words[ind])\\n            {\\n                chr[x]++;\\n            }\\n        }\\n        return dp[mask][ind] = res;\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        map<string,int> scr;\\n        for(auto x:words)\\n        {\\n            int p = 0;\\n            for(auto ch:x)\\n            {\\n                p+=score[ch-\\'a\\'];\\n            }\\n            scr[x] = p;\\n        }\\n        map<char,int> chr;\\n        for(auto x:letters)\\n        {\\n            chr[x]++;\\n        }\\n        vector<vector<int>> dp(1<<14,vector<int>(14,-1));\\n        int mask = 0;\\n        return func(words.size()-1,mask,words,scr,chr,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863863,
                "title": "easy-2d-dp-solution-java",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int dp[][];\\n    boolean vis[][];\\n\\n    int solve(String words[], char letters[], int score[], int cur, int taken, int count[]) {\\n        int n = words.length;\\n\\n        if (cur >= n) {\\n            return 0;\\n        }\\n\\n        if (vis[cur][taken]) {\\n            return dp[cur][taken];\\n        }\\n\\n        int ans = 0;\\n\\n        // skip this one\\n        ans = solve(words, letters, score, cur + 1, taken, count.clone());\\n\\n        char cWord[] = words[cur].toCharArray();\\n\\n        boolean poss = true;\\n\\n        int curScore = 0;\\n\\n        for (int i = 0; i < cWord.length; i++) {\\n            int curLetter = cWord[i] - \\'a\\';\\n            if (count[curLetter] == 0) {\\n                poss = false;\\n                break;\\n            }\\n            curScore = curScore + score[curLetter];\\n            count[curLetter]--;\\n        }\\n\\n        if (poss) {\\n            ans = Math.max(ans, curScore + solve(words, letters, score, cur + 1, taken | (1 << cur), count.clone()));\\n        }\\n\\n        vis[cur][taken] = true;\\n        dp[cur][taken] = ans;\\n\\n        return ans;\\n    }\\n\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int count[] = new int[26];\\n\\n        for (int i = 0; i < letters.length; i++) {\\n            int cur = letters[i] - \\'a\\';\\n            count[cur]++;\\n        }\\n\\n        dp = new int[words.length + 1][1 << (words.length + 1)];\\n        vis = new boolean[words.length + 1][1 << (words.length + 1)];\\n\\n        return solve(words, letters, score, 0, 0, count);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int dp[][];\\n    boolean vis[][];\\n\\n    int solve(String words[], char letters[], int score[], int cur, int taken, int count[]) {\\n        int n = words.length;\\n\\n        if (cur >= n) {\\n            return 0;\\n        }\\n\\n        if (vis[cur][taken]) {\\n            return dp[cur][taken];\\n        }\\n\\n        int ans = 0;\\n\\n        // skip this one\\n        ans = solve(words, letters, score, cur + 1, taken, count.clone());\\n\\n        char cWord[] = words[cur].toCharArray();\\n\\n        boolean poss = true;\\n\\n        int curScore = 0;\\n\\n        for (int i = 0; i < cWord.length; i++) {\\n            int curLetter = cWord[i] - \\'a\\';\\n            if (count[curLetter] == 0) {\\n                poss = false;\\n                break;\\n            }\\n            curScore = curScore + score[curLetter];\\n            count[curLetter]--;\\n        }\\n\\n        if (poss) {\\n            ans = Math.max(ans, curScore + solve(words, letters, score, cur + 1, taken | (1 << cur), count.clone()));\\n        }\\n\\n        vis[cur][taken] = true;\\n        dp[cur][taken] = ans;\\n\\n        return ans;\\n    }\\n\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n        int count[] = new int[26];\\n\\n        for (int i = 0; i < letters.length; i++) {\\n            int cur = letters[i] - \\'a\\';\\n            count[cur]++;\\n        }\\n\\n        dp = new int[words.length + 1][1 << (words.length + 1)];\\n        vis = new boolean[words.length + 1][1 << (words.length + 1)];\\n\\n        return solve(words, letters, score, 0, 0, count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863481,
                "title": "c-easy-fast-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(string &str,unordered_map<char,int> &mp)\\n    {\\n        int ans=0;\\n        for(auto x:str)\\n        {\\n            ans+=mp[x];\\n        }\\n        return ans;\\n    }\\n    int solve(vector<string>& words,int idx,unordered_map<char,int> &mp,vector<int> cnt,vector<int> &dp)\\n    {\\n        if(idx==words.size())\\n        return 0;\\n\\n        int notpick=solve(words,idx+1,mp,cnt,dp);\\n        int pick=0;\\n        bool flag=true;\\n        vector<int> temp=cnt;\\n        for(int i=0;i<words[idx].length();i++)\\n        {\\n            if(temp[words[idx][i]-\\'a\\']==0)\\n            {\\n                flag=false;\\n                break;\\n            }\\n            else\\n            temp[words[idx][i]-\\'a\\']--;\\n        }\\n\\n        if(flag)\\n        {\\n            pick=helper(words[idx],mp)+solve(words,idx+1,mp,temp,dp);\\n        }\\n\\n        return dp[idx]=max(pick,notpick);\\n\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        unordered_map<char,int> mp;\\n        int n=words.size();\\n        vector<int> dp(n+1,-1);\\n        for(int i=0;i<score.size();i++)\\n        {\\n            mp[\\'a\\'+i]=score[i];\\n        }\\n        \\n        vector<int> cnt(26,0);\\n        for(int i=0;i<letters.size();i++)\\n        {\\n            cnt[letters[i]-\\'a\\']++;\\n        }\\n        \\n        return solve(words,0,mp,cnt,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(string &str,unordered_map<char,int> &mp)\\n    {\\n        int ans=0;\\n        for(auto x:str)\\n        {\\n            ans+=mp[x];\\n        }\\n        return ans;\\n    }\\n    int solve(vector<string>& words,int idx,unordered_map<char,int> &mp,vector<int> cnt,vector<int> &dp)\\n    {\\n        if(idx==words.size())\\n        return 0;\\n\\n        int notpick=solve(words,idx+1,mp,cnt,dp);\\n        int pick=0;\\n        bool flag=true;\\n        vector<int> temp=cnt;\\n        for(int i=0;i<words[idx].length();i++)\\n        {\\n            if(temp[words[idx][i]-\\'a\\']==0)\\n            {\\n                flag=false;\\n                break;\\n            }\\n            else\\n            temp[words[idx][i]-\\'a\\']--;\\n        }\\n\\n        if(flag)\\n        {\\n            pick=helper(words[idx],mp)+solve(words,idx+1,mp,temp,dp);\\n        }\\n\\n        return dp[idx]=max(pick,notpick);\\n\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        unordered_map<char,int> mp;\\n        int n=words.size();\\n        vector<int> dp(n+1,-1);\\n        for(int i=0;i<score.size();i++)\\n        {\\n            mp[\\'a\\'+i]=score[i];\\n        }\\n        \\n        vector<int> cnt(26,0);\\n        for(int i=0;i<letters.size();i++)\\n        {\\n            cnt[letters[i]-\\'a\\']++;\\n        }\\n        \\n        return solve(words,0,mp,cnt,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833773,
                "title": "kotlin-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    fun maxScoreWords(words: Array<String>, letters: CharArray, score: IntArray): Int {\\n        val freq = IntArray(26)\\n        for (c in letters) {\\n            freq[c - \\'a\\']++\\n        }\\n        return calculateMaxScoreWords(words, freq, score, 0)\\n    }\\n\\n    private fun calculateMaxScoreWords(\\n        words: Array<String>,\\n        freq: IntArray,\\n        score: IntArray,\\n        index: Int\\n    ): Int {\\n        if (index == words.size) {\\n            return 0\\n        }\\n        var maxScore = 0\\n        val newFreq = freq.clone()\\n        var curScore = 0\\n        var isValid = true\\n        for (c in words[index].toCharArray()) {\\n            val i = c - \\'a\\'\\n            if (newFreq[i] == 0) {\\n                isValid = false\\n                break\\n            }\\n            newFreq[i]--\\n            curScore += score[i]\\n        }\\n        if (isValid) {\\n            curScore += calculateMaxScoreWords(words, newFreq, score, index + 1)\\n            maxScore = Math.max(maxScore, curScore)\\n        }\\n        maxScore = Math.max(maxScore, calculateMaxScoreWords(words, freq, score, index + 1))\\n        return maxScore\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n\\n    fun maxScoreWords(words: Array<String>, letters: CharArray, score: IntArray): Int {\\n        val freq = IntArray(26)\\n        for (c in letters) {\\n            freq[c - \\'a\\']++\\n        }\\n        return calculateMaxScoreWords(words, freq, score, 0)\\n    }\\n\\n    private fun calculateMaxScoreWords(\\n        words: Array<String>,\\n        freq: IntArray,\\n        score: IntArray,\\n        index: Int\\n    ): Int {\\n        if (index == words.size) {\\n            return 0\\n        }\\n        var maxScore = 0\\n        val newFreq = freq.clone()\\n        var curScore = 0\\n        var isValid = true\\n        for (c in words[index].toCharArray()) {\\n            val i = c - \\'a\\'\\n            if (newFreq[i] == 0) {\\n                isValid = false\\n                break\\n            }\\n            newFreq[i]--\\n            curScore += score[i]\\n        }\\n        if (isValid) {\\n            curScore += calculateMaxScoreWords(words, newFreq, score, index + 1)\\n            maxScore = Math.max(maxScore, curScore)\\n        }\\n        maxScore = Math.max(maxScore, calculateMaxScoreWords(words, freq, score, index + 1))\\n        return maxScore\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813190,
                "title": "bitmask-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        int n = words.size();\\n        vector<int> charCount(26, 0);\\n        for(auto& c : letters){\\n            charCount[c-\\'a\\']++;\\n        }\\n        int mxScore =0;\\n        for(int i=1; i<(1<<n); i++){\\n            int currScore = 0;\\n            bool f = 0;\\n            vector<int> t = charCount;\\n            for(int j=0; j<n; j++){\\n               if(i&(1<<j)){\\n                 for(auto c : words[j]){\\n                     if(t[c-\\'a\\']==0){\\n                         f=1;\\n                         break;\\n                     }\\n                     t[c-\\'a\\']--;\\n                     currScore += score[c-\\'a\\'];\\n                 }\\n               }\\n               if(f) break;\\n            }\\n            if(f) continue;\\n\\n            mxScore = max(currScore, mxScore);\\n        }\\n        return mxScore;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        int n = words.size();\\n        vector<int> charCount(26, 0);\\n        for(auto& c : letters){\\n            charCount[c-\\'a\\']++;\\n        }\\n        int mxScore =0;\\n        for(int i=1; i<(1<<n); i++){\\n            int currScore = 0;\\n            bool f = 0;\\n            vector<int> t = charCount;\\n            for(int j=0; j<n; j++){\\n               if(i&(1<<j)){\\n                 for(auto c : words[j]){\\n                     if(t[c-\\'a\\']==0){\\n                         f=1;\\n                         break;\\n                     }\\n                     t[c-\\'a\\']--;\\n                     currScore += score[c-\\'a\\'];\\n                 }\\n               }\\n               if(f) break;\\n            }\\n            if(f) continue;\\n\\n            mxScore = max(currScore, mxScore);\\n        }\\n        return mxScore;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764610,
                "title": "in-c-combination-of-backtracking-recursion-and-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <vector>\\n#include <string>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        unordered_map<char, int> freq;\\n        for (char letter : letters) {\\n            freq[letter]++;\\n        }\\n        \\n        return dfs(words, score, freq, 0);\\n    }\\n    \\nprivate:\\n    int dfs(vector<string>& words, vector<int>& score, unordered_map<char, int>& freq, int index) {\\n        if (index == words.size()) {\\n            return 0;\\n        }\\n        \\n        int maxScore = 0;\\n        \\n        // Calculate the score if the current word can be formed\\n        int currScore = 0;\\n        unordered_map<char, int> tempFreq = freq;\\n        bool validWord = true;\\n        for (char letter : words[index]) {\\n            if (tempFreq[letter] <= 0) {\\n                validWord = false;\\n                break;\\n            }\\n            \\n            currScore += score[letter - \\'a\\'];\\n            tempFreq[letter]--;\\n        }\\n        \\n        // Recursively search for the next word\\n        if (validWord) {\\n            currScore += dfs(words, score, tempFreq, index + 1);\\n            maxScore = max(maxScore, currScore);\\n        }\\n        \\n        // Skip the current word and search for the next one\\n        maxScore = max(maxScore, dfs(words, score, freq, index + 1));\\n        \\n        return maxScore;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <vector>\\n#include <string>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        unordered_map<char, int> freq;\\n        for (char letter : letters) {\\n            freq[letter]++;\\n        }\\n        \\n        return dfs(words, score, freq, 0);\\n    }\\n    \\nprivate:\\n    int dfs(vector<string>& words, vector<int>& score, unordered_map<char, int>& freq, int index) {\\n        if (index == words.size()) {\\n            return 0;\\n        }\\n        \\n        int maxScore = 0;\\n        \\n        // Calculate the score if the current word can be formed\\n        int currScore = 0;\\n        unordered_map<char, int> tempFreq = freq;\\n        bool validWord = true;\\n        for (char letter : words[index]) {\\n            if (tempFreq[letter] <= 0) {\\n                validWord = false;\\n                break;\\n            }\\n            \\n            currScore += score[letter - \\'a\\'];\\n            tempFreq[letter]--;\\n        }\\n        \\n        // Recursively search for the next word\\n        if (validWord) {\\n            currScore += dfs(words, score, tempFreq, index + 1);\\n            maxScore = max(maxScore, currScore);\\n        }\\n        \\n        // Skip the current word and search for the next one\\n        maxScore = max(maxScore, dfs(words, score, freq, index + 1));\\n        \\n        return maxScore;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3744476,
                "title": "dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(const vector<string>& words, vector<int>& lettersCount, const vector<int>& score, int i, int tmpSum, int& ans) {\\n        if (i >= words.size()) {\\n            ans = max(tmpSum, ans);\\n            return;\\n        }\\n        vector<int> wordLettersCount(26, 0);\\n        bool match = true;\\n        for(const char& ch : words[i]) {\\n            wordLettersCount[ch-\\'a\\']++;\\n            if (wordLettersCount[ch-\\'a\\'] > lettersCount[ch-\\'a\\']) {\\n                match = false;\\n                break;\\n            }\\n        }\\n        if (match) {\\n            for(int i = 0; i < lettersCount.size(); i++) {\\n                lettersCount[i] -= wordLettersCount[i];\\n                tmpSum += wordLettersCount[i]*score[i];\\n            }\\n            dfs(words, lettersCount, score, i+1, tmpSum, ans);\\n            for(int i = 0; i < lettersCount.size(); i++) {\\n                lettersCount[i] += wordLettersCount[i];\\n                tmpSum -= wordLettersCount[i]*score[i];\\n            }\\n        }\\n        dfs(words, lettersCount, score, i+1, tmpSum, ans);\\n    }\\n\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        int ans = 0;\\n        vector<int> lettersCount(26, 0);\\n        for(int i = 0; i < letters.size(); i++) {\\n            lettersCount[letters[i]-\\'a\\']++;\\n        }\\n        dfs(words, lettersCount, score, 0, 0, ans);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(const vector<string>& words, vector<int>& lettersCount, const vector<int>& score, int i, int tmpSum, int& ans) {\\n        if (i >= words.size()) {\\n            ans = max(tmpSum, ans);\\n            return;\\n        }\\n        vector<int> wordLettersCount(26, 0);\\n        bool match = true;\\n        for(const char& ch : words[i]) {\\n            wordLettersCount[ch-\\'a\\']++;\\n            if (wordLettersCount[ch-\\'a\\'] > lettersCount[ch-\\'a\\']) {\\n                match = false;\\n                break;\\n            }\\n        }\\n        if (match) {\\n            for(int i = 0; i < lettersCount.size(); i++) {\\n                lettersCount[i] -= wordLettersCount[i];\\n                tmpSum += wordLettersCount[i]*score[i];\\n            }\\n            dfs(words, lettersCount, score, i+1, tmpSum, ans);\\n            for(int i = 0; i < lettersCount.size(); i++) {\\n                lettersCount[i] += wordLettersCount[i];\\n                tmpSum -= wordLettersCount[i]*score[i];\\n            }\\n        }\\n        dfs(words, lettersCount, score, i+1, tmpSum, ans);\\n    }\\n\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        int ans = 0;\\n        vector<int> lettersCount(26, 0);\\n        for(int i = 0; i < letters.size(); i++) {\\n            lettersCount[letters[i]-\\'a\\']++;\\n        }\\n        dfs(words, lettersCount, score, 0, 0, ans);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743665,
                "title": "java",
                "content": "# Intuition\\nBacktracking\\n\\n# Approach\\nSimpe backtracking.. If you want to use dp can use bitmask for words can use that for memoization.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n\\n        int mask = 0;\\n        int n = words.length;\\n        int[] freq = new int[26];\\n        for(int i=0;i<letters.length;i++){\\n            freq[letters[i]-\\'a\\']++;\\n        }\\n\\n       return  solve(0,n,freq,score,words);\\n    }\\n\\n    public int solve(int i,int n ,int[]freq,int[]score,String[]words){\\n\\n        if(i==n){\\n            return 0;\\n        }\\n\\n        int a = solve(i+1,n,freq,score,words);\\n\\n\\n\\n\\n        boolean canInclude=true;\\n\\n        int[]temp = new int[26];\\n\\n\\n        for(int j=0;j<words[i].length();j++){\\n            temp[words[i].charAt(j)-\\'a\\']++;\\n        }\\n\\n        for(int j=0;j<26;j++){\\n            if(temp[j]>freq[j]){\\n                canInclude=false;\\n            }\\n        }\\n\\n\\n\\n        int currentScore=0;\\n        int b=0;\\n\\n        if(canInclude){\\n            for(int j=0;j<26;j++){\\n                freq[j]=freq[j]-temp[j];\\n                currentScore +=score[j]*temp[j];\\n            }\\n            b = currentScore+solve(i+1,n,freq,score,words);\\n              for(int j=0;j<26;j++){\\n                freq[j]=freq[j]+temp[j];\\n            }\\n        }\\n\\n        return Math.max(a,b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScoreWords(String[] words, char[] letters, int[] score) {\\n\\n        int mask = 0;\\n        int n = words.length;\\n        int[] freq = new int[26];\\n        for(int i=0;i<letters.length;i++){\\n            freq[letters[i]-\\'a\\']++;\\n        }\\n\\n       return  solve(0,n,freq,score,words);\\n    }\\n\\n    public int solve(int i,int n ,int[]freq,int[]score,String[]words){\\n\\n        if(i==n){\\n            return 0;\\n        }\\n\\n        int a = solve(i+1,n,freq,score,words);\\n\\n\\n\\n\\n        boolean canInclude=true;\\n\\n        int[]temp = new int[26];\\n\\n\\n        for(int j=0;j<words[i].length();j++){\\n            temp[words[i].charAt(j)-\\'a\\']++;\\n        }\\n\\n        for(int j=0;j<26;j++){\\n            if(temp[j]>freq[j]){\\n                canInclude=false;\\n            }\\n        }\\n\\n\\n\\n        int currentScore=0;\\n        int b=0;\\n\\n        if(canInclude){\\n            for(int j=0;j<26;j++){\\n                freq[j]=freq[j]-temp[j];\\n                currentScore +=score[j]*temp[j];\\n            }\\n            b = currentScore+solve(i+1,n,freq,score,words);\\n              for(int j=0;j<26;j++){\\n                freq[j]=freq[j]+temp[j];\\n            }\\n        }\\n\\n        return Math.max(a,b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740698,
                "title": "easy-to-understand-c-beats-95-dp-iit-roorkee",
                "content": "# Approach\\nSimilar to approach we use in making maximum sum using Dynamic Programming we can solve using either way Bottom up and Top down\\n\\n# Complexity\\n- Time complexity: O(N*N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxi(vector<string>& w,vector<int>& v,vector<int>& s,int index)\\n    {\\n        if(index>=w.size())\\n        {\\n            return 0;\\n        }\\n        bool flag=0;\\n        vector<int>temp=v;\\n        int val=0;\\n        int ans1=INT_MIN;\\n        int ans2=INT_MIN;\\n        for(int i=0;i<w[index].size();i++)\\n        {\\n               temp[w[index][i]-\\'a\\']--;\\n               val+=s[w[index][i]-\\'a\\'];\\n               if(temp[w[index][i]-\\'a\\']<0)\\n               {\\n                   flag=1;\\n                   break;\\n               }\\n        }\\n        if(flag==0)\\n        {\\n            ans1=val+maxi(w,temp,s,index+1);\\n        }\\n        ans2=maxi(w,v,s,index+1);\\n        return max(ans1,ans2);\\n    }\\n    int maxScoreWords(vector<string>& w, vector<char>& l, vector<int>& s)\\n    {\\n        vector<int>v(26,0);\\n        for(int i=0;i<l.size();i++)\\n        {\\n            v[l[i]-\\'a\\']++;\\n        }\\n        return maxi(w,v,s,0);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi(vector<string>& w,vector<int>& v,vector<int>& s,int index)\\n    {\\n        if(index>=w.size())\\n        {\\n            return 0;\\n        }\\n        bool flag=0;\\n        vector<int>temp=v;\\n        int val=0;\\n        int ans1=INT_MIN;\\n        int ans2=INT_MIN;\\n        for(int i=0;i<w[index].size();i++)\\n        {\\n               temp[w[index][i]-\\'a\\']--;\\n               val+=s[w[index][i]-\\'a\\'];\\n               if(temp[w[index][i]-\\'a\\']<0)\\n               {\\n                   flag=1;\\n                   break;\\n               }\\n        }\\n        if(flag==0)\\n        {\\n            ans1=val+maxi(w,temp,s,index+1);\\n        }\\n        ans2=maxi(w,v,s,index+1);\\n        return max(ans1,ans2);\\n    }\\n    int maxScoreWords(vector<string>& w, vector<char>& l, vector<int>& s)\\n    {\\n        vector<int>v(26,0);\\n        for(int i=0;i<l.size();i++)\\n        {\\n            v[l[i]-\\'a\\']++;\\n        }\\n        return maxi(w,v,s,0);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740096,
                "title": "c-backtrack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(2 ^ {n \\\\times k})$$ where\\n- `n` is the total number of words\\n- `k` is the total length of the words\\nIn the worst case we need to iterate over all the characters in all words.\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int MaxScoreWords(string[] words, char[] letters, int[] score)\\n    {\\n        if (words.Length == 0 || letters.Length == 0 || score.Length == 0)\\n        {\\n            return 0;\\n        }\\n\\n        var count = new int[score.Length];\\n\\n        foreach (var ch in letters)\\n        {\\n            count[ch - \\'a\\']++;\\n        }\\n\\n        return backtrack(words, count, score, 0);\\n    }\\n\\n    private static int backtrack(IReadOnlyList<string> words, IList<int> count, IReadOnlyList<int> score, int index)\\n    {\\n        var max = 0;\\n\\n        for (var i = index; i < words.Count; i++)\\n        {\\n            var res = 0;\\n            var isValid = true;\\n            foreach (var ch in words[i])\\n            {\\n                count[ch - \\'a\\']--;\\n                res += score[ch - \\'a\\'];\\n                if (count[ch - \\'a\\'] < 0)\\n                {\\n                    isValid = false;\\n                }\\n            }\\n\\n            if (isValid)\\n            {\\n                res += backtrack(words, count, score, i + 1);\\n                max = Math.Max(res, max);\\n            }\\n\\n            foreach (var ch in words[i])\\n            {\\n                count[ch - \\'a\\']++;\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MaxScoreWords(string[] words, char[] letters, int[] score)\\n    {\\n        if (words.Length == 0 || letters.Length == 0 || score.Length == 0)\\n        {\\n            return 0;\\n        }\\n\\n        var count = new int[score.Length];\\n\\n        foreach (var ch in letters)\\n        {\\n            count[ch - \\'a\\']++;\\n        }\\n\\n        return backtrack(words, count, score, 0);\\n    }\\n\\n    private static int backtrack(IReadOnlyList<string> words, IList<int> count, IReadOnlyList<int> score, int index)\\n    {\\n        var max = 0;\\n\\n        for (var i = index; i < words.Count; i++)\\n        {\\n            var res = 0;\\n            var isValid = true;\\n            foreach (var ch in words[i])\\n            {\\n                count[ch - \\'a\\']--;\\n                res += score[ch - \\'a\\'];\\n                if (count[ch - \\'a\\'] < 0)\\n                {\\n                    isValid = false;\\n                }\\n            }\\n\\n            if (isValid)\\n            {\\n                res += backtrack(words, count, score, i + 1);\\n                max = Math.Max(res, max);\\n            }\\n\\n            foreach (var ch in words[i])\\n            {\\n                count[ch - \\'a\\']++;\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737564,
                "title": "recursion-memoization-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGo through simple recursion to take the word in your solution or not and if you can take it given the constraints of the letters then check if it better to take it or not then compute the answer.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)+Auxiliary Stack Space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int f(int i,map<char,int>mp,vector<int>& score,vector<string>& word,vector<int>dp){\\n        int n=word.size();\\n        if(i==n)return 0;\\n\\n        if(dp[i]!=-1)return dp[i];\\n\\n        int notTake=f(i+1,mp,score,word,dp);\\n\\n        int take=0;\\n        for(int j=0;j<word[i].length();j++){\\n            if(mp.find(word[i][j])!=mp.end()){\\n                mp[word[i][j]]-=1;\\n                if(mp[word[i][j]]==0)mp.erase(word[i][j]);\\n\\n                take+=score[word[i][j]-\\'a\\'];\\n            }\\n            else {\\n                take=0;\\n                break;\\n            }\\n        }\\n        if(take==0) return dp[i]=notTake;\\n        return dp[i]=max(notTake,take+f(i+1,mp,score,word,dp));\\n    }\\n    int maxScoreWords(vector<string>& word, vector<char>& letters, vector<int>& score) {\\n        map<char,int>mp;\\n        vector<int>dp(word.size(),-1);\\n        for(auto it:letters)mp[it]++;\\n        return f(0,mp,score,word,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int f(int i,map<char,int>mp,vector<int>& score,vector<string>& word,vector<int>dp){\\n        int n=word.size();\\n        if(i==n)return 0;\\n\\n        if(dp[i]!=-1)return dp[i];\\n\\n        int notTake=f(i+1,mp,score,word,dp);\\n\\n        int take=0;\\n        for(int j=0;j<word[i].length();j++){\\n            if(mp.find(word[i][j])!=mp.end()){\\n                mp[word[i][j]]-=1;\\n                if(mp[word[i][j]]==0)mp.erase(word[i][j]);\\n\\n                take+=score[word[i][j]-\\'a\\'];\\n            }\\n            else {\\n                take=0;\\n                break;\\n            }\\n        }\\n        if(take==0) return dp[i]=notTake;\\n        return dp[i]=max(notTake,take+f(i+1,mp,score,word,dp));\\n    }\\n    int maxScoreWords(vector<string>& word, vector<char>& letters, vector<int>& score) {\\n        map<char,int>mp;\\n        vector<int>dp(word.size(),-1);\\n        for(auto it:letters)mp[it]++;\\n        return f(0,mp,score,word,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1838709,
                "content": [
                    {
                        "username": "ala__",
                        "content": "any valid set of indices (words[i] cannot be used twice).\\n\\nbut if i != j, you can use both words[i] and words[j]."
                    },
                    {
                        "username": "Msey",
                        "content": "backtrack + memoization"
                    },
                    {
                        "username": "aditya_42",
                        "content": "dont even need memo"
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "It\\'s easy or medium problem. What is it doing in hard category? "
                    },
                    {
                        "username": "vik066",
                        "content": "Why is this problem solved by considering all possible subsequences of words and then finding the maximum score among them? Since the order of words matters, shouldn\\'t we aim to determine the maximum score among all permutations of subsequences? I\\'m finding this question a bit unclear, and I\\'m seeking a better understanding of the approach."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "can anyone tell the reason why calling notTake call after calling take call works,, while vice versa does not??  here is my code\\n\\nclass Solution {\\npublic:\\n    int solve(int n, map<char,int>&letter, vector<int>& price, vector<map<char,int>>&word, vector<int>& dp){\\n        if(n < 0)return 0;\\n         if(price[n] == -1)return 0;\\n        if(dp[n] != -1)return dp[n];\\n\\n        bool canTake = true;\\n        int take =0;\\n        map<char,int>mp = word[n];\\n        for(auto& it : mp){\\n            if(it.second > letter[it.first]){\\n                canTake = false;\\n                break;\\n            }\\n            else{\\n                letter[it.first] -= it.second;\\n            }\\n        }\\n        if(canTake){\\n            take = price[n] + solve(n-1, letter, price, word, dp);\\n        }\\n\\n        for(auto& it : mp){\\n            letter[it.first] += it.second;\\n        }\\n\\n//  WHEN I AM CALLING THIS BEFORE TAKE CALL,, IT IS NOT GIVING THE RIGHT ANS..\\n        int notTake = solve(n-1, letter, price, word, dp);\\n\\n        return dp[n] = max(take, notTake);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        map<char,int>letter;\\n        for(int i =0; i < letters.size(); i++){\\n            letter[letters[i]]++;\\n        }\\n\\n        int n = words.size();\\n        vector<map<char,int>>word(n);\\n        vector<int>price(n,0);\\n\\n        for(int i =0; i < n; i++){\\n            int sum =0;\\n            bool found = false;\\n            for(int j =0; j < words[i].length(); j++){\\n                word[i][words[i][j]]++;\\n                if(letter.find(words[i][j]) != letter.end()){\\n                    sum += score[words[i][j] - \\'a\\'];\\n                }\\n                else{\\n                    found = true;\\n                }\\n            }\\n            if(!found){\\n                price[i] = sum;\\n            }\\n            else{\\n                price[i] = -1;\\n            }\\n        }\\n        vector<int>dp(words.size()+1, -1);\\n        return solve(n-1, letter, price, word, dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "0/1 :/"
                    }
                ]
            },
            {
                "id": 1779056,
                "content": [
                    {
                        "username": "ala__",
                        "content": "any valid set of indices (words[i] cannot be used twice).\\n\\nbut if i != j, you can use both words[i] and words[j]."
                    },
                    {
                        "username": "Msey",
                        "content": "backtrack + memoization"
                    },
                    {
                        "username": "aditya_42",
                        "content": "dont even need memo"
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "It\\'s easy or medium problem. What is it doing in hard category? "
                    },
                    {
                        "username": "vik066",
                        "content": "Why is this problem solved by considering all possible subsequences of words and then finding the maximum score among them? Since the order of words matters, shouldn\\'t we aim to determine the maximum score among all permutations of subsequences? I\\'m finding this question a bit unclear, and I\\'m seeking a better understanding of the approach."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "can anyone tell the reason why calling notTake call after calling take call works,, while vice versa does not??  here is my code\\n\\nclass Solution {\\npublic:\\n    int solve(int n, map<char,int>&letter, vector<int>& price, vector<map<char,int>>&word, vector<int>& dp){\\n        if(n < 0)return 0;\\n         if(price[n] == -1)return 0;\\n        if(dp[n] != -1)return dp[n];\\n\\n        bool canTake = true;\\n        int take =0;\\n        map<char,int>mp = word[n];\\n        for(auto& it : mp){\\n            if(it.second > letter[it.first]){\\n                canTake = false;\\n                break;\\n            }\\n            else{\\n                letter[it.first] -= it.second;\\n            }\\n        }\\n        if(canTake){\\n            take = price[n] + solve(n-1, letter, price, word, dp);\\n        }\\n\\n        for(auto& it : mp){\\n            letter[it.first] += it.second;\\n        }\\n\\n//  WHEN I AM CALLING THIS BEFORE TAKE CALL,, IT IS NOT GIVING THE RIGHT ANS..\\n        int notTake = solve(n-1, letter, price, word, dp);\\n\\n        return dp[n] = max(take, notTake);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        map<char,int>letter;\\n        for(int i =0; i < letters.size(); i++){\\n            letter[letters[i]]++;\\n        }\\n\\n        int n = words.size();\\n        vector<map<char,int>>word(n);\\n        vector<int>price(n,0);\\n\\n        for(int i =0; i < n; i++){\\n            int sum =0;\\n            bool found = false;\\n            for(int j =0; j < words[i].length(); j++){\\n                word[i][words[i][j]]++;\\n                if(letter.find(words[i][j]) != letter.end()){\\n                    sum += score[words[i][j] - \\'a\\'];\\n                }\\n                else{\\n                    found = true;\\n                }\\n            }\\n            if(!found){\\n                price[i] = sum;\\n            }\\n            else{\\n                price[i] = -1;\\n            }\\n        }\\n        vector<int>dp(words.size()+1, -1);\\n        return solve(n-1, letter, price, word, dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "0/1 :/"
                    }
                ]
            },
            {
                "id": 2075417,
                "content": [
                    {
                        "username": "ala__",
                        "content": "any valid set of indices (words[i] cannot be used twice).\\n\\nbut if i != j, you can use both words[i] and words[j]."
                    },
                    {
                        "username": "Msey",
                        "content": "backtrack + memoization"
                    },
                    {
                        "username": "aditya_42",
                        "content": "dont even need memo"
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "It\\'s easy or medium problem. What is it doing in hard category? "
                    },
                    {
                        "username": "vik066",
                        "content": "Why is this problem solved by considering all possible subsequences of words and then finding the maximum score among them? Since the order of words matters, shouldn\\'t we aim to determine the maximum score among all permutations of subsequences? I\\'m finding this question a bit unclear, and I\\'m seeking a better understanding of the approach."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "can anyone tell the reason why calling notTake call after calling take call works,, while vice versa does not??  here is my code\\n\\nclass Solution {\\npublic:\\n    int solve(int n, map<char,int>&letter, vector<int>& price, vector<map<char,int>>&word, vector<int>& dp){\\n        if(n < 0)return 0;\\n         if(price[n] == -1)return 0;\\n        if(dp[n] != -1)return dp[n];\\n\\n        bool canTake = true;\\n        int take =0;\\n        map<char,int>mp = word[n];\\n        for(auto& it : mp){\\n            if(it.second > letter[it.first]){\\n                canTake = false;\\n                break;\\n            }\\n            else{\\n                letter[it.first] -= it.second;\\n            }\\n        }\\n        if(canTake){\\n            take = price[n] + solve(n-1, letter, price, word, dp);\\n        }\\n\\n        for(auto& it : mp){\\n            letter[it.first] += it.second;\\n        }\\n\\n//  WHEN I AM CALLING THIS BEFORE TAKE CALL,, IT IS NOT GIVING THE RIGHT ANS..\\n        int notTake = solve(n-1, letter, price, word, dp);\\n\\n        return dp[n] = max(take, notTake);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        map<char,int>letter;\\n        for(int i =0; i < letters.size(); i++){\\n            letter[letters[i]]++;\\n        }\\n\\n        int n = words.size();\\n        vector<map<char,int>>word(n);\\n        vector<int>price(n,0);\\n\\n        for(int i =0; i < n; i++){\\n            int sum =0;\\n            bool found = false;\\n            for(int j =0; j < words[i].length(); j++){\\n                word[i][words[i][j]]++;\\n                if(letter.find(words[i][j]) != letter.end()){\\n                    sum += score[words[i][j] - \\'a\\'];\\n                }\\n                else{\\n                    found = true;\\n                }\\n            }\\n            if(!found){\\n                price[i] = sum;\\n            }\\n            else{\\n                price[i] = -1;\\n            }\\n        }\\n        vector<int>dp(words.size()+1, -1);\\n        return solve(n-1, letter, price, word, dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "0/1 :/"
                    }
                ]
            },
            {
                "id": 2005353,
                "content": [
                    {
                        "username": "ala__",
                        "content": "any valid set of indices (words[i] cannot be used twice).\\n\\nbut if i != j, you can use both words[i] and words[j]."
                    },
                    {
                        "username": "Msey",
                        "content": "backtrack + memoization"
                    },
                    {
                        "username": "aditya_42",
                        "content": "dont even need memo"
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "It\\'s easy or medium problem. What is it doing in hard category? "
                    },
                    {
                        "username": "vik066",
                        "content": "Why is this problem solved by considering all possible subsequences of words and then finding the maximum score among them? Since the order of words matters, shouldn\\'t we aim to determine the maximum score among all permutations of subsequences? I\\'m finding this question a bit unclear, and I\\'m seeking a better understanding of the approach."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "can anyone tell the reason why calling notTake call after calling take call works,, while vice versa does not??  here is my code\\n\\nclass Solution {\\npublic:\\n    int solve(int n, map<char,int>&letter, vector<int>& price, vector<map<char,int>>&word, vector<int>& dp){\\n        if(n < 0)return 0;\\n         if(price[n] == -1)return 0;\\n        if(dp[n] != -1)return dp[n];\\n\\n        bool canTake = true;\\n        int take =0;\\n        map<char,int>mp = word[n];\\n        for(auto& it : mp){\\n            if(it.second > letter[it.first]){\\n                canTake = false;\\n                break;\\n            }\\n            else{\\n                letter[it.first] -= it.second;\\n            }\\n        }\\n        if(canTake){\\n            take = price[n] + solve(n-1, letter, price, word, dp);\\n        }\\n\\n        for(auto& it : mp){\\n            letter[it.first] += it.second;\\n        }\\n\\n//  WHEN I AM CALLING THIS BEFORE TAKE CALL,, IT IS NOT GIVING THE RIGHT ANS..\\n        int notTake = solve(n-1, letter, price, word, dp);\\n\\n        return dp[n] = max(take, notTake);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        map<char,int>letter;\\n        for(int i =0; i < letters.size(); i++){\\n            letter[letters[i]]++;\\n        }\\n\\n        int n = words.size();\\n        vector<map<char,int>>word(n);\\n        vector<int>price(n,0);\\n\\n        for(int i =0; i < n; i++){\\n            int sum =0;\\n            bool found = false;\\n            for(int j =0; j < words[i].length(); j++){\\n                word[i][words[i][j]]++;\\n                if(letter.find(words[i][j]) != letter.end()){\\n                    sum += score[words[i][j] - \\'a\\'];\\n                }\\n                else{\\n                    found = true;\\n                }\\n            }\\n            if(!found){\\n                price[i] = sum;\\n            }\\n            else{\\n                price[i] = -1;\\n            }\\n        }\\n        vector<int>dp(words.size()+1, -1);\\n        return solve(n-1, letter, price, word, dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "0/1 :/"
                    }
                ]
            },
            {
                "id": 1927538,
                "content": [
                    {
                        "username": "ala__",
                        "content": "any valid set of indices (words[i] cannot be used twice).\\n\\nbut if i != j, you can use both words[i] and words[j]."
                    },
                    {
                        "username": "Msey",
                        "content": "backtrack + memoization"
                    },
                    {
                        "username": "aditya_42",
                        "content": "dont even need memo"
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "It\\'s easy or medium problem. What is it doing in hard category? "
                    },
                    {
                        "username": "vik066",
                        "content": "Why is this problem solved by considering all possible subsequences of words and then finding the maximum score among them? Since the order of words matters, shouldn\\'t we aim to determine the maximum score among all permutations of subsequences? I\\'m finding this question a bit unclear, and I\\'m seeking a better understanding of the approach."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "can anyone tell the reason why calling notTake call after calling take call works,, while vice versa does not??  here is my code\\n\\nclass Solution {\\npublic:\\n    int solve(int n, map<char,int>&letter, vector<int>& price, vector<map<char,int>>&word, vector<int>& dp){\\n        if(n < 0)return 0;\\n         if(price[n] == -1)return 0;\\n        if(dp[n] != -1)return dp[n];\\n\\n        bool canTake = true;\\n        int take =0;\\n        map<char,int>mp = word[n];\\n        for(auto& it : mp){\\n            if(it.second > letter[it.first]){\\n                canTake = false;\\n                break;\\n            }\\n            else{\\n                letter[it.first] -= it.second;\\n            }\\n        }\\n        if(canTake){\\n            take = price[n] + solve(n-1, letter, price, word, dp);\\n        }\\n\\n        for(auto& it : mp){\\n            letter[it.first] += it.second;\\n        }\\n\\n//  WHEN I AM CALLING THIS BEFORE TAKE CALL,, IT IS NOT GIVING THE RIGHT ANS..\\n        int notTake = solve(n-1, letter, price, word, dp);\\n\\n        return dp[n] = max(take, notTake);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        map<char,int>letter;\\n        for(int i =0; i < letters.size(); i++){\\n            letter[letters[i]]++;\\n        }\\n\\n        int n = words.size();\\n        vector<map<char,int>>word(n);\\n        vector<int>price(n,0);\\n\\n        for(int i =0; i < n; i++){\\n            int sum =0;\\n            bool found = false;\\n            for(int j =0; j < words[i].length(); j++){\\n                word[i][words[i][j]]++;\\n                if(letter.find(words[i][j]) != letter.end()){\\n                    sum += score[words[i][j] - \\'a\\'];\\n                }\\n                else{\\n                    found = true;\\n                }\\n            }\\n            if(!found){\\n                price[i] = sum;\\n            }\\n            else{\\n                price[i] = -1;\\n            }\\n        }\\n        vector<int>dp(words.size()+1, -1);\\n        return solve(n-1, letter, price, word, dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "0/1 :/"
                    }
                ]
            },
            {
                "id": 1813437,
                "content": [
                    {
                        "username": "ala__",
                        "content": "any valid set of indices (words[i] cannot be used twice).\\n\\nbut if i != j, you can use both words[i] and words[j]."
                    },
                    {
                        "username": "Msey",
                        "content": "backtrack + memoization"
                    },
                    {
                        "username": "aditya_42",
                        "content": "dont even need memo"
                    },
                    {
                        "username": "Samuel-Aktar-Laskar",
                        "content": "It\\'s easy or medium problem. What is it doing in hard category? "
                    },
                    {
                        "username": "vik066",
                        "content": "Why is this problem solved by considering all possible subsequences of words and then finding the maximum score among them? Since the order of words matters, shouldn\\'t we aim to determine the maximum score among all permutations of subsequences? I\\'m finding this question a bit unclear, and I\\'m seeking a better understanding of the approach."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "can anyone tell the reason why calling notTake call after calling take call works,, while vice versa does not??  here is my code\\n\\nclass Solution {\\npublic:\\n    int solve(int n, map<char,int>&letter, vector<int>& price, vector<map<char,int>>&word, vector<int>& dp){\\n        if(n < 0)return 0;\\n         if(price[n] == -1)return 0;\\n        if(dp[n] != -1)return dp[n];\\n\\n        bool canTake = true;\\n        int take =0;\\n        map<char,int>mp = word[n];\\n        for(auto& it : mp){\\n            if(it.second > letter[it.first]){\\n                canTake = false;\\n                break;\\n            }\\n            else{\\n                letter[it.first] -= it.second;\\n            }\\n        }\\n        if(canTake){\\n            take = price[n] + solve(n-1, letter, price, word, dp);\\n        }\\n\\n        for(auto& it : mp){\\n            letter[it.first] += it.second;\\n        }\\n\\n//  WHEN I AM CALLING THIS BEFORE TAKE CALL,, IT IS NOT GIVING THE RIGHT ANS..\\n        int notTake = solve(n-1, letter, price, word, dp);\\n\\n        return dp[n] = max(take, notTake);\\n    }\\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\\n        map<char,int>letter;\\n        for(int i =0; i < letters.size(); i++){\\n            letter[letters[i]]++;\\n        }\\n\\n        int n = words.size();\\n        vector<map<char,int>>word(n);\\n        vector<int>price(n,0);\\n\\n        for(int i =0; i < n; i++){\\n            int sum =0;\\n            bool found = false;\\n            for(int j =0; j < words[i].length(); j++){\\n                word[i][words[i][j]]++;\\n                if(letter.find(words[i][j]) != letter.end()){\\n                    sum += score[words[i][j] - \\'a\\'];\\n                }\\n                else{\\n                    found = true;\\n                }\\n            }\\n            if(!found){\\n                price[i] = sum;\\n            }\\n            else{\\n                price[i] = -1;\\n            }\\n        }\\n        vector<int>dp(words.size()+1, -1);\\n        return solve(n-1, letter, price, word, dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "0/1 :/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Jump Game VI",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and an integer <code>k</code>.</p>\n\n<p>You are initially standing at index <code>0</code>. In one move, you can jump at most <code>k</code> steps forward without going outside the boundaries of the array. That is, you can jump from index <code>i</code> to any index in the range <code>[i + 1, min(n - 1, i + k)]</code> <strong>inclusive</strong>.</p>\n\n<p>You want to reach the last index of the array (index <code>n - 1</code>). Your <strong>score</strong> is the <strong>sum</strong> of all <code>nums[j]</code> for each index <code>j</code> you visited in the array.</p>\n\n<p>Return <em>the <strong>maximum score</strong> you can get</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [<u>1</u>,<u>-1</u>,-2,<u>4</u>,-7,<u>3</u>], k = 2\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> You can choose your jumps forming the subsequence [1,-1,4,3] (underlined above). The sum is 7.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [<u>10</u>,-5,-2,<u>4</u>,0,<u>3</u>], k = 3\n<strong>Output:</strong> 17\n<strong>Explanation:</strong> You can choose your jumps forming the subsequence [10,4,3] (underlined above). The sum is 17.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,-5,-20,4,-1,3,-6,-3], k = 2\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1260737,
                "title": "optimizations-from-brute-force-to-dynamic-programming-w-explanation",
                "content": "Most other posts have provided direct optimized solutions. In this post, I will try to explain the thought-process and how you can optimize from brute-force to dynamic-programming to optimized DP solution.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force)***\\n\\nLet\\'s start with doing just what the questions asks us. For any index *`i`* (such that *`i < n-1`*), we can jump atmost k-steps forward and we need to reach `n-1` index such that we maximise the sum of scores of intermediate jumps.\\n\\nFor all the indices, we will just try each jump of lengths from `1...k` and return the one which maximises the score at the end. Since we cannot go outside array bounds, we will return `nums[n-1]` (last index we can reach) when we reach `i >= n-1`. \\n\\n```\\nint maxResult(vector<int>& nums, int k, int i = 0) {\\n\\tif(i >= size(nums) - 1) return nums.back();\\n\\tint score = INT_MIN;\\n\\tfor(int j = 1; j <= k; j++) \\n\\t\\tscore = max(score, nums[i] + maxResult(nums, k, i + j));\\n\\treturn score;\\n}\\n```\\n\\n***Time Complexity :*** **`O(k^N)`**, where *`N`* is the size of array and *`k`* is max jump length. We have k choices at each index and we are trying out each choice everytime and recursing for remaining indices. So overall time complexity becomes *`k*k*k*...N times`* = *`O(k^N)`*\\n***Space Complexity :*** **`O(N)`**, required by the recursive stack.\\n\\n---\\n\\n\\u274C ***Solution - II (Dynamic Programming (Memoization)- Top-Down Approach)***\\n\\nIn the above brute force approach, **we are re-calculating for the same index multiple times**. But we can observe that the maximum score which we can obtain by starting from an index *`i`* will always remain the same. \\n\\nSo, instead of doing unnecessary repeated calculations, we can use **dynamic programming** to store the calculated results and directly return it whenever required in the future calculations. Here, we will maintain an dp array, where ***`dp[i]`* will denote the maximum score that we can obtain starting from `i`th index**. We will initialize *`dp[n-1] = nums[n-1]`* (since that\\'s the only score we can obtain starting at `n-1`th index) and rest of `dp[i]`  to *`-infinity`* denoting that they have not been computed yet.\\n\\nNow, for each *`i`*, we have the choice to make jumps of lengths *`1,2...k`* and we will store the maximum score in *`dp[i]`* after trying out  jump of each length. If *`dp[i]`* is already computed once, we will just return it without doing any re-computations.\\n\\n```\\nint maxResult(vector<int>& nums, int k) {\\n\\tvector<int> dp(size(nums), INT_MIN);\\n\\tdp.back() = nums.back();  // dp[n-1]=nums[n-1]\\n\\treturn solve(nums, dp, k, 0);\\n}\\n// recursive solver which finds max score to reach n-1 starting from ith index\\nint solve(vector<int>& nums, vector<int>& dp, int k, int i) {\\n\\tif(dp[i] != INT_MIN) return dp[i];   // already calculated result for index i\\n\\tfor(int j = 1; j <= k; j++)          // try jumps of all length and choose the one which maximises the score\\n\\t\\tif(i + j < size(nums))\\n\\t\\t\\tdp[i] = max(dp[i], nums[i] + solve(nums, dp, k, i + j));\\n\\treturn dp[i];\\n}\\n```\\n\\n***Time Complexity :*** **`O(k*N)`** For each index, we are trying out `k` jumps and storing the results to avoid future recomputations. Overall, the time complexity required is *`k+k+k...N times`* = `O(k*N)`\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u274C ***Solution - III (Dynamic Programming (Tabulation) - Bottom-Up Approach)***\\n\\nThe above solution still leads to **TLE** with the given constraints. Let\\'s see the iterative (bottom-up) version of the above code before moving to the optimized solution.\\n\\nHere, *`dp[i]`* denotes maximum achievable score to reach *`dp[i]`* starting from 0th index. We start with *`dp[0] = nums[0]`* and make our way till the end. Finally `dp[n-1]` will give the maximum score we can obtain starting from *`i=0`*.\\n\\n```\\nint maxResult(vector<int>& nums, int k) {\\n\\tvector<int> dp(size(nums), INT_MIN);\\n\\tdp[0] = nums[0];\\n\\tfor(int i = 1; i < size(nums); i++) \\n\\t\\tfor(int j = 1; j <= k && i - j >= 0; j++)      // try all jumps length\\n\\t\\t\\tdp[i] = max(dp[i], dp[i - j] + nums[i]);   // choose the jump from previous index which maximises score       \\n\\treturn dp.back();\\n}\\n```\\n\\n***Time Complexity :*** **`O(k*N)`** \\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Optimized Dynamic Programming)***\\n\\nIn the above dynamic programming approach, we can observe that in the equation *`dp[i] = max(dp[i], dp[i - j] + nums[i])`*, **we are always choosing the `dp[i-j]` which has the maximum score**. \\n\\nSo, instead of iterating `k` times, we can just store the maximum amongst the previous *`dp[i-1], dp[i-2], ...dp[i-k]`* and use it directly in the equation. For this, we can make use of a **multiset** to maintain the results of max score for previous k indices in a sorted order. That is, we are storing `dp[i-1], dp[i-2],..., dp[i-k]` in a sorted order in the multiset.\\n\\nWhenever we reach *`i > k`*, the `dp[i-k - 1]` will be useless to us, since there\\'s no way we can reach current index `i` from `i-k - 1`th index. So, we will just remove it from our set. Finally, the above equation - *`dp[i] = max(dp[i], dp[i - j] + nums[i])`*,  can now be solved in **`O(logk)`** instead of `O(k)`.\\n\\n```\\nint maxResult(vector<int>& nums, int k) {\\n\\tvector<int> dp(size(nums), INT_MIN);\\n    multiset<int> s ({ dp[0] = nums[0] });         // set dp[0] = nums[0] and insert it into set\\n\\tfor(int i = 1; i < size(nums); i++) {\\n        if(i > k) s.erase(s.find(dp[i - k - 1]));  // erase elements from which we cant jump to current index\\n        s.insert(dp[i] = *rbegin(s) + nums[i]);    // choose element with max score and jump from that to the current index\\n    }\\n\\treturn dp.back();\\n}\\n```\\n\\n***Time Complexity :*** **`O(N*log(k))`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (Further Optimized DP)***\\n\\nWe can maintain a simple double-side queue in a sorted order to reduce the max previous score lookup from `O(logk)` down to `O(1)`. Here we will store the indices instead of `dp[i]` in the queue.\\n\\nJust as in above approach, we will pop `i-k-1`th index from queue since it will be useless to us. Along with that, we will also pop those indices which will never have any chance of being chosen in the future. So for eg., if the score for current index - `dp[i]` is greater than some indices stored in the queue, it will always be optimal to choose `dp[i]` instead of those other indices. So, we will just pop those indices from queue since they won\\'t ever be used.\\n\\n```\\nint maxResult(vector<int>& nums, int k) {\\n\\tvector<int> dp(size(nums));\\n\\tdp[0] = nums[0];\\n\\tdeque<int> q{ 0 };\\n\\tfor(int i = 1; i < size(nums); i++) {\\n\\t\\tif(q.front() < i - k) q.pop_front();         // can\\'t reach current index from index stored in q     \\n\\t\\tdp[i] = nums[i] + dp[q.front()];             // update max score for current index\\n\\t\\twhile(!q.empty() && dp[q.back()] <= dp[i])   // pop indices which won\\'t be ever chosen in the future\\n\\t\\t    q.pop_back();\\n\\t\\tq.push_back(i);                              // insert current index\\n\\t}\\n\\treturn dp.back();\\n}\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(N)`** required for `dp` and `q`. You can optimize it down to `O(K)` if you use *`nums`* itself as the `dp` array (if you are allowed to modify the given input)\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxResult(vector<int>& nums, int k, int i = 0) {\\n\\tif(i >= size(nums) - 1) return nums.back();\\n\\tint score = INT_MIN;\\n\\tfor(int j = 1; j <= k; j++) \\n\\t\\tscore = max(score, nums[i] + maxResult(nums, k, i + j));\\n\\treturn score;\\n}\\n```\n```\\nint maxResult(vector<int>& nums, int k) {\\n\\tvector<int> dp(size(nums), INT_MIN);\\n\\tdp.back() = nums.back();  // dp[n-1]=nums[n-1]\\n\\treturn solve(nums, dp, k, 0);\\n}\\n// recursive solver which finds max score to reach n-1 starting from ith index\\nint solve(vector<int>& nums, vector<int>& dp, int k, int i) {\\n\\tif(dp[i] != INT_MIN) return dp[i];   // already calculated result for index i\\n\\tfor(int j = 1; j <= k; j++)          // try jumps of all length and choose the one which maximises the score\\n\\t\\tif(i + j < size(nums))\\n\\t\\t\\tdp[i] = max(dp[i], nums[i] + solve(nums, dp, k, i + j));\\n\\treturn dp[i];\\n}\\n```\n```\\nint maxResult(vector<int>& nums, int k) {\\n\\tvector<int> dp(size(nums), INT_MIN);\\n\\tdp[0] = nums[0];\\n\\tfor(int i = 1; i < size(nums); i++) \\n\\t\\tfor(int j = 1; j <= k && i - j >= 0; j++)      // try all jumps length\\n\\t\\t\\tdp[i] = max(dp[i], dp[i - j] + nums[i]);   // choose the jump from previous index which maximises score       \\n\\treturn dp.back();\\n}\\n```\n```\\nint maxResult(vector<int>& nums, int k) {\\n\\tvector<int> dp(size(nums), INT_MIN);\\n    multiset<int> s ({ dp[0] = nums[0] });         // set dp[0] = nums[0] and insert it into set\\n\\tfor(int i = 1; i < size(nums); i++) {\\n        if(i > k) s.erase(s.find(dp[i - k - 1]));  // erase elements from which we cant jump to current index\\n        s.insert(dp[i] = *rbegin(s) + nums[i]);    // choose element with max score and jump from that to the current index\\n    }\\n\\treturn dp.back();\\n}\\n```\n```\\nint maxResult(vector<int>& nums, int k) {\\n\\tvector<int> dp(size(nums));\\n\\tdp[0] = nums[0];\\n\\tdeque<int> q{ 0 };\\n\\tfor(int i = 1; i < size(nums); i++) {\\n\\t\\tif(q.front() < i - k) q.pop_front();         // can\\'t reach current index from index stored in q     \\n\\t\\tdp[i] = nums[i] + dp[q.front()];             // update max score for current index\\n\\t\\twhile(!q.empty() && dp[q.back()] <= dp[i])   // pop indices which won\\'t be ever chosen in the future\\n\\t\\t    q.pop_back();\\n\\t\\tq.push_back(i);                              // insert current index\\n\\t}\\n\\treturn dp.back();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1260843,
                "title": "c-java-python-dp-decreasing-deque-clean-concise-time-o-n-space-o-k",
                "content": "**\\u274C Approach 1: Naive Dynamic Programming (Time Limit Exceeded)**\\n- Let `dp[i]` is the maximum score we can get when ending at index `i`.\\n- Base case: `dp[0] = nums[0]`, we start at index `0`\\n- State transfer equation:\\n\\t-  If we have already computed `dp[0], dp[1], ..., dp[i-1]`, how can we compute `dp[i]`? \\n\\t- Since we can jump at most `k` steps, to arrive index `i`, we must jump from one of indices `[i-k, i-k+1, ..., i-1]`. \\n\\t- So `dp[i] = max(dp[i-k], dp[i-k+1], ..., dp[i-1]) + nums[i]`.\\n- Finally, `dp[n-1]` is the maximum score when reaching the last index of the array, index `n-1`.\\n\\n<iframe src=\"https://leetcode.com/playground/62A8EtEi/shared\" frameBorder=\"0\" width=\"100%\" height=\"280\"></iframe>\\n\\nComplexity:\\n- Time: `O(N * K)`, where `N <= 10^5` is number of elements in `nums`, `K <= 10^5` is the maximum steps that we can jump.\\n- Space: `O(N)`\\n\\n**Reuse `nums` to eliminate `dp` array (Space Optimized)**\\n<iframe src=\"https://leetcode.com/playground/HTWR7GX7/shared\" frameBorder=\"0\" width=\"100%\" height=\"280\"></iframe>\\n\\nComplexity:\\n- Time: `O(N * K)`, where `N <= 10^5` is number of elements in `nums`, `K <= 10^5` is the maximum steps that we can jump.\\n- Space: `O(1)`\\n\\n---\\n**\\u2714\\uFE0FApproach 2: Dynamic Programming + Decreasing Deque (Accepted)**\\n- We need a way to get a maximum value in range `[dp[i-k], dp[i-k+1], ..., dp[i-1]]` better than `O(K)` to avoid Time Limit Exceeded.\\n- This is the same with problem [239. Maximum in Sliding Window Size K](https://leetcode.com/problems/sliding-window-maximum/discuss/598751) problem.\\n- There are total 3 ways:\\n\\t- By using MaxHeap, it costs `O(logN)`\\n\\t- By using TreeMap, it costs `O(logK)`\\n\\t- By using Decreasing Deque, it costs `O(1)`\\n- To make this post short, I choose to use **Decreasing Deque** which is `O(1)`, for other ways please reference to this [239. Maximum in Sliding Window Size K](https://leetcode.com/problems/sliding-window-maximum/discuss/598751) post.\\n- In **Decreasing Deque** approach:\\n\\t- We used a `deque` to store **indices** of `nums` elements, elements is in decreasing order, the front is the maximum element.\\n\\t- When adding a new number `nums[i]`, we eliminate elements which is less or equal to `nums[i]` in `deque`, which will never be chosen in the future.\\n\\t- Push index of current `nums[i]` to back of the `deque`.\\n\\t- If the last element in `deque` is out of range `K` then remove it.\\n\\n<iframe src=\"https://leetcode.com/playground/WrSEPdvb/shared\" frameBorder=\"0\" width=\"100%\" height=\"400\"></iframe>\\n\\nComplexity:\\n- Time: `O(N)`, where `N <= 10^5` is number of elements in `nums`, `K <= 10^5` is the maximum steps that we can jump.\\n- Space: `O(K)`\\n\\nIf you have any questions, **feel free to comment** below, I will try my best to answer. If you think this post is useful, please **give it a vote**. Thank so much.",
                "solutionTags": [],
                "code": "**\\u274C Approach 1: Naive Dynamic Programming (Time Limit Exceeded)**\\n- Let `dp[i]` is the maximum score we can get when ending at index `i`.\\n- Base case: `dp[0] = nums[0]`, we start at index `0`\\n- State transfer equation:\\n\\t-  If we have already computed `dp[0], dp[1], ..., dp[i-1]`, how can we compute `dp[i]`? \\n\\t- Since we can jump at most `k` steps, to arrive index `i`, we must jump from one of indices `[i-k, i-k+1, ..., i-1]`. \\n\\t- So `dp[i] = max(dp[i-k], dp[i-k+1], ..., dp[i-1]) + nums[i]`.\\n- Finally, `dp[n-1]` is the maximum score when reaching the last index of the array, index `n-1`.\\n\\n<iframe src=\"https://leetcode.com/playground/62A8EtEi/shared\" frameBorder=\"0\" width=\"100%\" height=\"280\"></iframe>\\n\\nComplexity:\\n- Time: `O(N * K)`, where `N <= 10^5` is number of elements in `nums`, `K <= 10^5` is the maximum steps that we can jump.\\n- Space: `O(N)`\\n\\n**Reuse `nums` to eliminate `dp` array (Space Optimized)**\\n<iframe src=\"https://leetcode.com/playground/HTWR7GX7/shared\" frameBorder=\"0\" width=\"100%\" height=\"280\"></iframe>\\n\\nComplexity:\\n- Time: `O(N * K)`, where `N <= 10^5` is number of elements in `nums`, `K <= 10^5` is the maximum steps that we can jump.\\n- Space: `O(1)`\\n\\n---\\n**\\u2714\\uFE0FApproach 2: Dynamic Programming + Decreasing Deque (Accepted)**\\n- We need a way to get a maximum value in range `[dp[i-k], dp[i-k+1], ..., dp[i-1]]` better than `O(K)` to avoid Time Limit Exceeded.\\n- This is the same with problem [239. Maximum in Sliding Window Size K](https://leetcode.com/problems/sliding-window-maximum/discuss/598751) problem.\\n- There are total 3 ways:\\n\\t- By using MaxHeap, it costs `O(logN)`\\n\\t- By using TreeMap, it costs `O(logK)`\\n\\t- By using Decreasing Deque, it costs `O(1)`\\n- To make this post short, I choose to use **Decreasing Deque** which is `O(1)`, for other ways please reference to this [239. Maximum in Sliding Window Size K](https://leetcode.com/problems/sliding-window-maximum/discuss/598751) post.\\n- In **Decreasing Deque** approach:\\n\\t- We used a `deque` to store **indices** of `nums` elements, elements is in decreasing order, the front is the maximum element.\\n\\t- When adding a new number `nums[i]`, we eliminate elements which is less or equal to `nums[i]` in `deque`, which will never be chosen in the future.\\n\\t- Push index of current `nums[i]` to back of the `deque`.\\n\\t- If the last element in `deque` is out of range `K` then remove it.\\n\\n<iframe src=\"https://leetcode.com/playground/WrSEPdvb/shared\" frameBorder=\"0\" width=\"100%\" height=\"400\"></iframe>\\n\\nComplexity:\\n- Time: `O(N)`, where `N <= 10^5` is number of elements in `nums`, `K <= 10^5` is the maximum steps that we can jump.\\n- Space: `O(K)`\\n\\nIf you have any questions, **feel free to comment** below, I will try my best to answer. If you think this post is useful, please **give it a vote**. Thank so much.",
                "codeTag": "Unknown"
            },
            {
                "id": 978462,
                "title": "c-dp-monoqueue-o-n",
                "content": "**Observation**\\n\\nLet\\'s try to solve this from the end for better visualization (It can be solved both ways).\\nAt every index `i` we want to pick the maximum result from `i+1` to `i+k` and add `nums[i]` to it\\nA maxium from `i+1` to `i+k` can be found in `O(1)` time using a monoqueue. If monoqueue seems a little advanced you can even use a `multiset` to do the same thing sacrificing a little for time complexity `O(logk)` .\\n\\nNow all we need to do is use this monoqueue or multiset to get the maximum result of the next `k` indices and store it somewhere, we can use the input array itself as an auxillary array. \\nLet\\'s store only the indices in the monoqueue so that we can limit the monoqueue to have results only for the next `k` indices at max. With a `multiset` you\\'d store the actual values and delete the value for answer `[i+k]`.\\n\\nBest problem to solve to understand the workings of a monoqueue:\\n[239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)\\n\\n**Solution**\\n```c++\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k)\\n    {\\n        long curr=0;\\n        deque<int> dq;     \\t\\t// Monoqueue\\n\\t\\t\\n\\t\\t// Start answering the best possible results for index `i` from the back\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            curr=nums[i]+(dq.empty()?0:nums[dq.front()]);       // Get current best, the maximum result will be the first element in the monoqueue.\\n\\t\\t\\t\\n\\t\\t\\t// We remove all the smaller results greedily as they wont get used anyways (This helps the monoqueue to remain sorted)\\n            while(!dq.empty()&&curr>nums[dq.back()])\\n                dq.pop_back();\\t\\n            dq.push_back(i);              // Insert current index into the monoqueue\\n\\t\\t\\t\\n\\t\\t\\t// Erase all the indices in deque that are greater than or equal to i+k.\\n            if(dq.front()>=i+k)\\n                dq.pop_front();\\n            nums[i]=curr;               // Use input array as auxillary array to store the best results.\\n        }\\n        return curr;                           // `curr` would have the best or the maxium result to reach end from index 0.\\n    }\\n    \\n};\\n```\\n\\n**Complexity**\\nTime: `O(n)`.\\nSpace `O(n)`. Since the algorithm uses auxillary array, even though it\\'s the input itself. This can be reduced to `O(k)` if we simply store the `index` and `value` in the deque itself.",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k)\\n    {\\n        long curr=0;\\n        deque<int> dq;     \\t\\t// Monoqueue\\n\\t\\t\\n\\t\\t// Start answering the best possible results for index `i` from the back\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            curr=nums[i]+(dq.empty()?0:nums[dq.front()]);       // Get current best, the maximum result will be the first element in the monoqueue.\\n\\t\\t\\t\\n\\t\\t\\t// We remove all the smaller results greedily as they wont get used anyways (This helps the monoqueue to remain sorted)\\n            while(!dq.empty()&&curr>nums[dq.back()])\\n                dq.pop_back();\\t\\n            dq.push_back(i);              // Insert current index into the monoqueue\\n\\t\\t\\t\\n\\t\\t\\t// Erase all the indices in deque that are greater than or equal to i+k.\\n            if(dq.front()>=i+k)\\n                dq.pop_front();\\n            nums[i]=curr;               // Use input array as auxillary array to store the best results.\\n        }\\n        return curr;                           // `curr` would have the best or the maxium result to reach end from index 0.\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978497,
                "title": "python-dp-sliding-window-maximum-problem-combined",
                "content": "```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n            clearly it is a DP problem. dp[i] represents the maxScore if you are at that idx\\n            \\n                    dp[i] = nums[i] + max(dp[i-k], dp[i-k+1].............dp[i-1)\\n                there will be k combos to find the max of ^^^\\n                -so since all of those combos will add nums[i]\\n\\t\\t\\t\\t\\tbasically we just need to find the DP with the maxScore out of the k DPs before it\\n\\t\\t\\t\\t-so dp[i] will equal nums[i] + the DP with the maxScore out of the k DPs before it\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t-take this first test case as an example. let\\'s say we are on idx3, value of 4 in the nums array\\n\\t\\t\\t\\t-how do we find the best score at idx3? we have to take the max of the k DPs before it, k in this case is 3,\\n\\t\\t\\t\\t-so looking at the 3 DPs before idx3, we have the dp values of 10, 5, and 8, so we choose the max of those\\n\\t\\t\\t\\t\\twhich is 10 to add to our currNum, so 10+4 = 14, which becomes our dp[3]\\n\\t\\t\\n\\t\\t\\t\\tnums = [10,-5,-2,4,0,3], k = 3\\n\\t\\t\\t\\tdp   = [10,5,8,14,14,17]\\n                                                        \\n            -obviously we could have looped thru all the k previous DPs to figure out that 10 was the max out of 10, 5 and 8\\n\\t\\t\\tbut that is extremely inefficient\\n            -so we need to use a SLIDING WINDOW MAXIMUM algorithm wih deque!!!\\n\\t\\t\\t\\t-if you aren\\'t familiar with this algorithm, let me quickly explain as best as I can in easy terms\\n                -a deque is techncally a doubly-linkedlist, but don\\'t let that scare you\\n\\t\\t\\t\\t-we can just treat it like a list/array that can pop off from the beginning/end in O(1), that is why we use it\\n\\t\\t\\t\\t-in our scenario, our deque\\'s first element will ALWAYS hold the maxScore of the k DPs before idx i\\n            -each deque element will be a tuple (score, idx)\\n\\t\\t\\t-the deque should be thought of as a UTILITY tool that will help us maintain the max of the k DPs before our curr idx,\\n\\t\\t\\t\\tand the length of the deque will most times not even be the same length as the window of size k\\n\\t\\t\\t\\t-it serves solely to help store the maxScore of the k DPs before it at the first element. the rest of the elements in the\\n\\t\\t\\t\\tdeque are somewhat like a next in line type of thing.\\n\\t\\t\\t\\t-so in our earlier example when we were at idx3,\\n\\t\\t\\t\\t\\tour deque should have looked like this [(10,0),(8,2)], \\n\\t\\t\\t\\t\\tand then we could easily see that 10 is our maxScore from the k previous DPs, and we would add\\n\\t\\t\\t\\t\\t10 to our currNum of 4 at idx3 to become 14. you may be wondering why that deque did not have the\\n\\t\\t\\t\\t\\tscore of 5 included in it, but you will see later why the score of 5 gets removed from the deque\\n\\t\\t\\t\\t\\twhen we insert the score of 8\\n\\t\\t\\t-so how do we actually MAINTAIN this deque and keep the property where our first element is always\\n\\t\\t\\t\\tthe largest of the k DPs before our curr idx?\\n\\t\\t\\t\\t-when we insert into the deque, if the back/right side of the deque has elements smaller than the one we are about to insert,\\n\\t\\t\\t\\t\\tthen we need to keep popping it off, that way the larger value always bubbles left towards the first element,\\n\\t\\t\\t\\t\\t\\tthis is where our expression      while d and d[-1][0] < dp[i]: d.pop()       comes from\\n\\t\\t\\t\\t\\t\\t-take for example we just finished processing dp[3] which we found earlier to be 14,\\n\\t\\t\\t\\t\\t\\t\\tat this current moment our deque looks like this [(10,0),(8,2)]\\n\\t\\t\\t\\t\\t\\t-so if we were to insert 14, we would first need to pop off the 8, then since 14 is also greater than 10, the 10 gets\\n\\t\\t\\t\\t\\t\\t\\tpopped off. so now the new deque is just [(14,3)]\\n\\t\\t\\t\\t-we also have to keep in mind the case when our deque\\'s first element falls outside of the window of size k\\n\\t\\t\\t\\t\\t-since i do the dp logic/updating before the deque maintainence in each iteration of the loop,\\n\\t\\t\\t\\t\\t\\tif we are at idx4 in the loop then we are basically pre-computing the max of the k DPs for idx5,\\n\\t\\t\\t\\t\\t\\tand for idx5 we would only consider the DP idxs of 2, 3 and 4. so since we are still in the loop for idx4, and our k is 3,\\n\\t\\t\\t\\t\\t\\tif the deques first element is from idx1 or lower, then we need to delete it\\n\\t\\t\\t\\t\\t\\t\\twhich is where the i-k == d[0][1] expression comes from\\n            \\n            nums = [10,-5,-2,4,0,3], k = 3\\n            dp   = [10,5,8,14,14,17]\\n            \\n\\t\\t   this is what the deque looks likeat the beginning of each loop iteration\\n           deque =  [(10,0)]        idx1\\n\\t\\t\\t        [(10,0),(5,1)]  idx2\\n\\t\\t\\t\\t\\t[(10,0),(8,2)]  idx3  #here the 8 was larger than 5 so it popped off the 5\\n\\t\\t\\t\\t\\t[(14,3)]        idx4  #here the 14 was larger than 8 and 10 so both of those were popped off\\n\\t\\t\\t\\t\\t[(14,3),(14,4)] idx5\\n\\t\\t\"\"\"\\n\\t\\t\\n        dp = [0] * len(nums)\\n        dp[0] = nums[0]\\n        d = deque([(nums[0],0)])\\n        for i in range(1, len(nums)):\\n            dp[i] = nums[i] + d[0][0]\\n            \\n            while d and d[-1][0] < dp[i]:   # sliding window maximum variation\\n                d.pop()                     # sliding window maximum variation\\n            d.append((dp[i],i))             # sliding window maximum variation\\n            \\n            if i-k == d[0][1]:              # sliding window maximum variation\\n                d.popleft()                 # sliding window maximum variation\\n                \\n        return dp[-1]\\n            \\n        \\n        \\n       ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n            clearly it is a DP problem. dp[i] represents the maxScore if you are at that idx\\n            \\n                    dp[i] = nums[i] + max(dp[i-k], dp[i-k+1].............dp[i-1)\\n                there will be k combos to find the max of ^^^\\n                -so since all of those combos will add nums[i]\\n\\t\\t\\t\\t\\tbasically we just need to find the DP with the maxScore out of the k DPs before it\\n\\t\\t\\t\\t-so dp[i] will equal nums[i] + the DP with the maxScore out of the k DPs before it\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t-take this first test case as an example. let\\'s say we are on idx3, value of 4 in the nums array\\n\\t\\t\\t\\t-how do we find the best score at idx3? we have to take the max of the k DPs before it, k in this case is 3,\\n\\t\\t\\t\\t-so looking at the 3 DPs before idx3, we have the dp values of 10, 5, and 8, so we choose the max of those\\n\\t\\t\\t\\t\\twhich is 10 to add to our currNum, so 10+4 = 14, which becomes our dp[3]\\n\\t\\t\\n\\t\\t\\t\\tnums = [10,-5,-2,4,0,3], k = 3\\n\\t\\t\\t\\tdp   = [10,5,8,14,14,17]\\n                                                        \\n            -obviously we could have looped thru all the k previous DPs to figure out that 10 was the max out of 10, 5 and 8\\n\\t\\t\\tbut that is extremely inefficient\\n            -so we need to use a SLIDING WINDOW MAXIMUM algorithm wih deque!!!\\n\\t\\t\\t\\t-if you aren\\'t familiar with this algorithm, let me quickly explain as best as I can in easy terms\\n                -a deque is techncally a doubly-linkedlist, but don\\'t let that scare you\\n\\t\\t\\t\\t-we can just treat it like a list/array that can pop off from the beginning/end in O(1), that is why we use it\\n\\t\\t\\t\\t-in our scenario, our deque\\'s first element will ALWAYS hold the maxScore of the k DPs before idx i\\n            -each deque element will be a tuple (score, idx)\\n\\t\\t\\t-the deque should be thought of as a UTILITY tool that will help us maintain the max of the k DPs before our curr idx,\\n\\t\\t\\t\\tand the length of the deque will most times not even be the same length as the window of size k\\n\\t\\t\\t\\t-it serves solely to help store the maxScore of the k DPs before it at the first element. the rest of the elements in the\\n\\t\\t\\t\\tdeque are somewhat like a next in line type of thing.\\n\\t\\t\\t\\t-so in our earlier example when we were at idx3,\\n\\t\\t\\t\\t\\tour deque should have looked like this [(10,0),(8,2)], \\n\\t\\t\\t\\t\\tand then we could easily see that 10 is our maxScore from the k previous DPs, and we would add\\n\\t\\t\\t\\t\\t10 to our currNum of 4 at idx3 to become 14. you may be wondering why that deque did not have the\\n\\t\\t\\t\\t\\tscore of 5 included in it, but you will see later why the score of 5 gets removed from the deque\\n\\t\\t\\t\\t\\twhen we insert the score of 8\\n\\t\\t\\t-so how do we actually MAINTAIN this deque and keep the property where our first element is always\\n\\t\\t\\t\\tthe largest of the k DPs before our curr idx?\\n\\t\\t\\t\\t-when we insert into the deque, if the back/right side of the deque has elements smaller than the one we are about to insert,\\n\\t\\t\\t\\t\\tthen we need to keep popping it off, that way the larger value always bubbles left towards the first element,\\n\\t\\t\\t\\t\\t\\tthis is where our expression      while d and d[-1][0] < dp[i]: d.pop()       comes from\\n\\t\\t\\t\\t\\t\\t-take for example we just finished processing dp[3] which we found earlier to be 14,\\n\\t\\t\\t\\t\\t\\t\\tat this current moment our deque looks like this [(10,0),(8,2)]\\n\\t\\t\\t\\t\\t\\t-so if we were to insert 14, we would first need to pop off the 8, then since 14 is also greater than 10, the 10 gets\\n\\t\\t\\t\\t\\t\\t\\tpopped off. so now the new deque is just [(14,3)]\\n\\t\\t\\t\\t-we also have to keep in mind the case when our deque\\'s first element falls outside of the window of size k\\n\\t\\t\\t\\t\\t-since i do the dp logic/updating before the deque maintainence in each iteration of the loop,\\n\\t\\t\\t\\t\\t\\tif we are at idx4 in the loop then we are basically pre-computing the max of the k DPs for idx5,\\n\\t\\t\\t\\t\\t\\tand for idx5 we would only consider the DP idxs of 2, 3 and 4. so since we are still in the loop for idx4, and our k is 3,\\n\\t\\t\\t\\t\\t\\tif the deques first element is from idx1 or lower, then we need to delete it\\n\\t\\t\\t\\t\\t\\t\\twhich is where the i-k == d[0][1] expression comes from\\n            \\n            nums = [10,-5,-2,4,0,3], k = 3\\n            dp   = [10,5,8,14,14,17]\\n            \\n\\t\\t   this is what the deque looks likeat the beginning of each loop iteration\\n           deque =  [(10,0)]        idx1\\n\\t\\t\\t        [(10,0),(5,1)]  idx2\\n\\t\\t\\t\\t\\t[(10,0),(8,2)]  idx3  #here the 8 was larger than 5 so it popped off the 5\\n\\t\\t\\t\\t\\t[(14,3)]        idx4  #here the 14 was larger than 8 and 10 so both of those were popped off\\n\\t\\t\\t\\t\\t[(14,3),(14,4)] idx5\\n\\t\\t\"\"\"\\n\\t\\t\\n        dp = [0] * len(nums)\\n        dp[0] = nums[0]\\n        d = deque([(nums[0],0)])\\n        for i in range(1, len(nums)):\\n            dp[i] = nums[i] + d[0][0]\\n            \\n            while d and d[-1][0] < dp[i]:   # sliding window maximum variation\\n                d.pop()                     # sliding window maximum variation\\n            d.append((dp[i],i))             # sliding window maximum variation\\n            \\n            if i-k == d[0][1]:              # sliding window maximum variation\\n                d.popleft()                 # sliding window maximum variation\\n                \\n        return dp[-1]\\n            \\n        \\n        \\n       ```",
                "codeTag": "Java"
            },
            {
                "id": 1260736,
                "title": "jump-game-vi-optimizations-from-brute-force-to-dynamic-programming-w-explanation",
                "content": "Most other posts have provided direct optimized solutions. In this post, I will try to explain the thought-process and how you can optimize from brute-force to dynamic-programming to optimized DP solution.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force)***\\n\\nLet\\'s start with doing just what the questions asks us. For any index *`i`* (such that *`i < n-1`*), we can jump atmost k-steps forward and we need to reach `n-1` index such that we maximise the sum of scores of intermediate jumps.\\n\\nFor all the indices, we will just try each jump of lengths from `1...k` and return the one which maximises the score at the end. Since we cannot go outside array bounds, we will return `nums[n-1]` (last index we can reach) when we reach `i >= n-1`. \\n\\n```\\nint maxResult(vector<int>& nums, int k, int i = 0) {\\n\\tif(i >= size(nums) - 1) return nums.back();\\n\\tint score = INT_MIN;\\n\\tfor(int j = 1; j <= k; j++) \\n\\t\\tscore = max(score, nums[i] + maxResult(nums, k, i + j));\\n\\treturn score;\\n}\\n```\\n\\n***Time Complexity :*** **`O(k^N)`**, where *`N`* is the size of array and *`k`* is max jump length. We have k choices at each index and we are trying out each choice everytime and recursing for remaining indices. So overall time complexity becomes *`k*k*k*...N times`* = *`O(k^N)`*\\n***Space Complexity :*** **`O(N)`**, required by the recursive stack.\\n\\n---\\n\\n\\u274C ***Solution - II (Dynamic Programming (Memoization)- Top-Down Approach)***\\n\\nIn the above brute force approach, **we are re-calculating for the same index multiple times**. But we can observe that the maximum score which we can obtain by starting from an index *`i`* will always remain the same. \\n\\nSo, instead of doing unnecessary repeated calculations, we can use **dynamic programming** to store the calculated results and directly return it whenever required in the future calculations. Here, we will maintain an dp array, where ***`dp[i]`* will denote the maximum score that we can obtain starting from `i`th index**. We will initialize *`dp[n-1] = nums[n-1]`* (since that\\'s the only score we can obtain starting at `n-1`th index) and rest of `dp[i]`  to *`-infinity`* denoting that they have not been computed yet.\\n\\nNow, for each *`i`*, we have the choice to make jumps of lengths *`1,2...k`* and we will store the maximum score in *`dp[i]`* after trying out  jump of each length. If *`dp[i]`* is already computed once, we will just return it without doing any re-computations.\\n\\n```\\nint maxResult(vector<int>& nums, int k) {\\n\\tvector<int> dp(size(nums), INT_MIN);\\n\\tdp.back() = nums.back();  // dp[n-1]=nums[n-1]\\n\\treturn solve(nums, dp, k, 0);\\n}\\n// recursive solver which finds max score to reach n-1 starting from ith index\\nint solve(vector<int>& nums, vector<int>& dp, int k, int i) {\\n\\tif(dp[i] != INT_MIN) return dp[i];   // already calculated result for index i\\n\\tfor(int j = 1; j <= k; j++)          // try jumps of all length and choose the one which maximises the score\\n\\t\\tif(i + j < size(nums))\\n\\t\\t\\tdp[i] = max(dp[i], nums[i] + solve(nums, dp, k, i + j));\\n\\treturn dp[i];\\n}\\n```\\n\\n***Time Complexity :*** **`O(k*N)`** For each index, we are trying out `k` jumps and storing the results to avoid future recomputations. Overall, the time complexity required is *`k+k+k...N times`* = `O(k*N)`\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u274C ***Solution - III (Dynamic Programming (Tabulation) - Bottom-Up Approach)***\\n\\nThe above solution still leads to **TLE** with the given constraints. Let\\'s see the iterative (bottom-up) version of the above code before moving to the optimized solution.\\n\\nHere, *`dp[i]`* denotes maximum achievable score to reach *`dp[i]`* starting from 0th index. We start with *`dp[0] = nums[0]`* and make our way till the end. Finally `dp[n-1]` will give the maximum score we can obtain starting from *`i=0`*.\\n\\n```\\nint maxResult(vector<int>& nums, int k) {\\n\\tvector<int> dp(size(nums), INT_MIN);\\n\\tdp[0] = nums[0];\\n\\tfor(int i = 1; i < size(nums); i++) \\n\\t\\tfor(int j = 1; j <= k && i - j >= 0; j++)      // try all jumps length\\n\\t\\t\\tdp[i] = max(dp[i], dp[i - j] + nums[i]);   // choose the jump from previous index which maximises score       \\n\\treturn dp.back();\\n}\\n```\\n\\n***Time Complexity :*** **`O(k*N)`** \\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Optimized Dynamic Programming)***\\n\\nIn the above dynamic programming approach, we can observe that in the equation *`dp[i] = max(dp[i], dp[i - j] + nums[i])`*, **we are always choosing the `dp[i-j]` which has the maximum score**. \\n\\nSo, instead of iterating `k` times, we can just store the maximum amongst the previous *`dp[i-1], dp[i-2], ...dp[i-k]`* and use it directly in the equation. For this, we can make use of a **multiset** to maintain the results of max score for previous k indices in a sorted order. That is, we are storing `dp[i-1], dp[i-2],..., dp[i-k]` in a sorted order in the multiset.\\n\\nWhenever we reach *`i > k`*, the `dp[i-k - 1]` will be useless to us, since there\\'s no way we can reach current index `i` from `i-k - 1`th index. So, we will just remove it from our set. Finally, the above equation - *`dp[i] = max(dp[i], dp[i - j] + nums[i])`*,  can now be solved in **`O(logk)`** instead of `O(k)`.\\n\\n```\\nint maxResult(vector<int>& nums, int k) {\\n\\tvector<int> dp(size(nums), INT_MIN);\\n    multiset<int> s ({ dp[0] = nums[0] });         // set dp[0] = nums[0] and insert it into set\\n\\tfor(int i = 1; i < size(nums); i++) {\\n        if(i > k) s.erase(s.find(dp[i - k - 1]));  // erase elements from which we cant jump to current index\\n        s.insert(dp[i] = *rbegin(s) + nums[i]);    // choose element with max score and jump from that to the current index\\n    }\\n\\treturn dp.back();\\n}\\n```\\n\\n***Time Complexity :*** **`O(N*log(k))`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (Further Optimized DP)***\\n\\nWe can maintain a simple double-side queue in a sorted order to reduce the max previous score lookup from `O(logk)` down to `O(1)`. Here we will store the indices instead of `dp[i]` in the queue.\\n\\nJust as in above approach, we will pop `i-k-1`th index from queue since it will be useless to us. Along with that, we will also pop those indices which will never have any chance of being chosen in the future. So for eg., if the score for current index - `dp[i]` is greater than some indices stored in the queue, it will always be optimal to choose `dp[i]` instead of those other indices. So, we will just pop those indices from queue since they won\\'t ever be used.\\n\\n```\\nint maxResult(vector<int>& nums, int k) {\\n\\tvector<int> dp(size(nums));\\n\\tdp[0] = nums[0];\\n\\tdeque<int> q{ 0 };\\n\\tfor(int i = 1; i < size(nums); i++) {\\n\\t\\tif(q.front() < i - k) q.pop_front();         // can\\'t reach current index from index stored in q     \\n\\t\\tdp[i] = nums[i] + dp[q.front()];             // update max score for current index\\n\\t\\twhile(!q.empty() && dp[q.back()] <= dp[i])   // pop indices which won\\'t be ever chosen in the future\\n\\t\\t    q.pop_back();\\n\\t\\tq.push_back(i);                              // insert current index\\n\\t}\\n\\treturn dp.back();\\n}\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(N)`** required for `dp` and `q`. You can optimize it down to `O(K)` if you use *`nums`* itself as the `dp` array (if you are allowed to modify the given input)\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxResult(vector<int>& nums, int k, int i = 0) {\\n\\tif(i >= size(nums) - 1) return nums.back();\\n\\tint score = INT_MIN;\\n\\tfor(int j = 1; j <= k; j++) \\n\\t\\tscore = max(score, nums[i] + maxResult(nums, k, i + j));\\n\\treturn score;\\n}\\n```\n```\\nint maxResult(vector<int>& nums, int k) {\\n\\tvector<int> dp(size(nums), INT_MIN);\\n\\tdp.back() = nums.back();  // dp[n-1]=nums[n-1]\\n\\treturn solve(nums, dp, k, 0);\\n}\\n// recursive solver which finds max score to reach n-1 starting from ith index\\nint solve(vector<int>& nums, vector<int>& dp, int k, int i) {\\n\\tif(dp[i] != INT_MIN) return dp[i];   // already calculated result for index i\\n\\tfor(int j = 1; j <= k; j++)          // try jumps of all length and choose the one which maximises the score\\n\\t\\tif(i + j < size(nums))\\n\\t\\t\\tdp[i] = max(dp[i], nums[i] + solve(nums, dp, k, i + j));\\n\\treturn dp[i];\\n}\\n```\n```\\nint maxResult(vector<int>& nums, int k) {\\n\\tvector<int> dp(size(nums), INT_MIN);\\n\\tdp[0] = nums[0];\\n\\tfor(int i = 1; i < size(nums); i++) \\n\\t\\tfor(int j = 1; j <= k && i - j >= 0; j++)      // try all jumps length\\n\\t\\t\\tdp[i] = max(dp[i], dp[i - j] + nums[i]);   // choose the jump from previous index which maximises score       \\n\\treturn dp.back();\\n}\\n```\n```\\nint maxResult(vector<int>& nums, int k) {\\n\\tvector<int> dp(size(nums), INT_MIN);\\n    multiset<int> s ({ dp[0] = nums[0] });         // set dp[0] = nums[0] and insert it into set\\n\\tfor(int i = 1; i < size(nums); i++) {\\n        if(i > k) s.erase(s.find(dp[i - k - 1]));  // erase elements from which we cant jump to current index\\n        s.insert(dp[i] = *rbegin(s) + nums[i]);    // choose element with max score and jump from that to the current index\\n    }\\n\\treturn dp.back();\\n}\\n```\n```\\nint maxResult(vector<int>& nums, int k) {\\n\\tvector<int> dp(size(nums));\\n\\tdp[0] = nums[0];\\n\\tdeque<int> q{ 0 };\\n\\tfor(int i = 1; i < size(nums); i++) {\\n\\t\\tif(q.front() < i - k) q.pop_front();         // can\\'t reach current index from index stored in q     \\n\\t\\tdp[i] = nums[i] + dp[q.front()];             // update max score for current index\\n\\t\\twhile(!q.empty() && dp[q.back()] <= dp[i])   // pop indices which won\\'t be ever chosen in the future\\n\\t\\t    q.pop_back();\\n\\t\\tq.push_back(i);                              // insert current index\\n\\t}\\n\\treturn dp.back();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 978544,
                "title": "c-dp-pruning-vs-monodeq",
                "content": "#### DP + Pruning\\nNot the most efficient solution - I somehow fixed my mind on O(n * n) DP during the contest. Until I got TLE :)\\n\\nThen I got a hunch that there must be some O(n) solution, but instead I just modified DP to stop the inner loop when we find a positive number. We would definitelly take that spot before jumping any further.\\n\\n> Note: this solution is not accepted anymore, as all-negative test case was added after the contest.\\n\\n```cpp\\nint maxResult(vector<int>& nums, int k) {\\n    vector<int> dp(nums.size(), INT_MIN);\\n    dp[0] = nums[0];\\n    for (auto i = 0; i < nums.size(); ++i)\\n        for (auto j = 1; j <= k && i + j < nums.size(); ++j) {\\n            dp[i + j] = max(dp[i + j], dp[i] + nums[i + j]);\\n            if (nums[i + j] >= 0)\\n                break;\\n        }\\n    return dp.back();\\n}\\n```\\n#### DP + Monodeq\\nFor each step, the best value is the number at that step, plus the max value among the previous `k` steps.\\n\\nWe can use a sliding window technique along with monotonically decreasing deque. That way, the max value will be the first element in the deque. \\n\\nIt\\'s easy to see that this solution has O(n) complexity, but somehow its runtime is slower than for the pruning solution above. Perhaps there is no a test case with all negative numbers (**update**: now there is).\\n\\n```cpp\\nint maxResult(vector<int>& nums, int k) {\\n    deque<int> d{0};\\n    for (int i = 1; i < nums.size(); ++i) {\\n        if (d.front() + k < i)\\n            d.pop_front();        \\n        nums[i] += nums[d.front()];\\n        while (!d.empty() && nums[d.back()] <= nums[i])\\n            d.pop_back();\\n        d.push_back(i);\\n    }\\n    return nums.back();\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maxResult(vector<int>& nums, int k) {\\n    vector<int> dp(nums.size(), INT_MIN);\\n    dp[0] = nums[0];\\n    for (auto i = 0; i < nums.size(); ++i)\\n        for (auto j = 1; j <= k && i + j < nums.size(); ++j) {\\n            dp[i + j] = max(dp[i + j], dp[i] + nums[i + j]);\\n            if (nums[i + j] >= 0)\\n                break;\\n        }\\n    return dp.back();\\n}\\n```\n```cpp\\nint maxResult(vector<int>& nums, int k) {\\n    deque<int> d{0};\\n    for (int i = 1; i < nums.size(); ++i) {\\n        if (d.front() + k < i)\\n            d.pop_front();        \\n        nums[i] += nums[d.front()];\\n        while (!d.empty() && nums[d.back()] <= nums[i])\\n            d.pop_back();\\n        d.push_back(i);\\n    }\\n    return nums.back();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2256803,
                "title": "c-dp-with-max-heap",
                "content": "score[i] will store the score if I start jumping from index i and priority queue will store all the scores of the window [i+1, min(n-1, i+k)].\\nTo get the maximum score from index i, I should jump to **next index with the maximum value** in the window.\\n\\n```\\n#define pii pair<int, int>\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k)\\n    {\\n        int n=nums.size();\\n        int score[n];\\n        priority_queue<pii> pq;\\n        \\n        for(int i=n-1 ; i>=0 ; i--)\\n        {\\n            while(pq.size() && pq.top().second>i+k)\\n                pq.pop();\\n            \\n            score[i]=nums[i];\\n            score[i]+=(pq.size() ? pq.top().first : 0);\\n            pq.push({score[i], i});\\n        }\\n        \\n        return score[0];\\n    }\\n};\\n```\\n\\n***Time Complexity :*** O(nlogk)\\n***Space Complexity :*** O(n)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define pii pair<int, int>\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k)\\n    {\\n        int n=nums.size();\\n        int score[n];\\n        priority_queue<pii> pq;\\n        \\n        for(int i=n-1 ; i>=0 ; i--)\\n        {\\n            while(pq.size() && pq.top().second>i+k)\\n                pq.pop();\\n            \\n            score[i]=nums[i];\\n            score[i]+=(pq.size() ? pq.top().first : 0);\\n            pq.push({score[i], i});\\n        }\\n        \\n        return score[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261213,
                "title": "java-journey-from-brute-force-to-most-optimized-dp-sliding-window-algorithm",
                "content": "Let\\'s start our discussion from the most obvious initial thought looking at this problem. We need to try out all possible combinations for each index and it\\'s k neighbours and pick the best out of them. Let\\'s start from the initial thought and step by step try to improvise our solution and reach the accepted solutions \\u2705\\n\\n# **BruteForce (Time Limited Exceed)**\\nIn this approach we try out the above thought and try to process all the nodes with their k neighbours and get the max score.\\n\\n```\\nprivate int maxResult(int[] nums, int i, int k) {\\n        if(i >= nums.length - 1) return nums[nums.length - 1];\\n        \\n        int max = Integer.MIN_VALUE;\\n        \\n        for(int j = i + 1; j <= Math.min(i + k, nums.length); j++) // Mininum of i + k, nums.length to prevent unnecessary calls for out of bounds. \\n            max = Math.max(max, maxResult( nums, j , k));\\n        \\n        return max;\\n    }\\n```\\n\\n*Time Complexity* - `O(k^n)` - As at each node we have k next nodes to be processed. So *k,k,k.....n times* gives k^n.\\n\\n# **Recursive + Memoization -- Top-Down DP (Time Limit Exceed)**\\n\\nAs it might be evident that we are recalculating many of the nodes again and again while their solution would remain the same as from a given node the maximum score to reach end would be same. e.g. 1,2,3,4,5,6,7   k - 3, so when we are at Node 1 - we process Node 2,3,4 and get the maximum value. When we move to node Node 2 - we process Node 3,4,5 So if we see we are again processing the Node 3, 4 which is not required at all.\\nSo, this calls for introducing a memory to store the already processed nodes and just provide a lookup of `O(1)`.\\n\\n```\\npublic int maxResult(int[] nums, int k) {\\n        int[] mem = new int[nums.length]; // Lookup table to score max score for given node\\n        \\n        for(int i = 0; i < mem.length; i++)\\n            mem[i] = Integer.MIN_VALUE;\\n        \\n        return maxResult(mem, nums, 0, k);\\n    }\\n    \\n    private int maxResult(int[] mem, int[] nums, int i, int k) {\\n        if(i >= nums.length - 1) return nums[nums.length - 1];\\n        \\n        if(mem[i] != Integer.MIN_VALUE) return mem[i];\\n        \\n        int max = Integer.MIN_VALUE;\\n        \\n        for(int j = i + 1; j <= Math.min(i + k, nums.length); j++)\\n            max = Math.max(max, maxResult(mem, nums, j , k));\\n        \\n        mem[i] = nums[i] + max;\\n        \\n        return mem[i];\\n    }\\n```\\n\\n*Time Complexity* - `O(k^n)` - As at each node we have k next nodes to be processed. So *k,k,k.....n times* gives k^n. Even though the lookup prevents further re-processing of already processed nodes(which can make it little faster).\\n\\n# **DP + Sliding Window -- Optimized using Priority Queue (Accepted) 170ms \\u2705**\\nIf we closely look at the problem we can understand that we need to get the maximum score within a given window ( k steps) preceeding current node(inclusive) and it would give us the maximum score for the current node. At a given node we only need the nearest k nodes data to process. For this we use a priority queue(PQ) to fetch maximum score in `O(1)` with overall cost of `O(nlog(n))` for interal sorting of PQ. Also, once we have moved forward we need to remove the element which is beyond the k step window( even if it is the maximum scoring). \\n\\nTo clear the last statement, we might have some values in Priority Queue which are outside of K step window but when we process a node we make sure we are using the score of the node within the acceptable window.\\n\\n```\\npublic int maxResult(int[] nums, int k) {\\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(k,\\n                Comparator.comparing(o -> -o.getValue())) {{\\n            offer(new Pair<>(0, nums[0]));\\n        }};\\n\\n        int max = nums[0], ans;\\n        for (int i = 1; i < nums.length; i++) {\\n            while (pq.peek().getKey() < i - k) { // We just compare the top node and see if it is outside of window or not.\\n                pq.poll();\\n            }\\n\\n            max = nums[i] + pq.peek().getValue();\\n            pq.offer(new Pair<>(i, max));\\n        }\\n\\n        return max;\\n    }\\n```\\n\\n*Time Complexity* - `O(nlog(n))` - Although it seem that we have multiple while loops but if we think about we are only processing the nodes atmost twice once for processing that and second time while removing from the window. So, overall complexity depends on the sorting in PQ which is `O(nlog(n))` due to internal heap.\\n\\n# **DP + Sliding Window -- Deque (Accepted) 70ms \\u2705**\\nAlthough the above PQ based solution is accepted, we can improve the overall complexity if we can handle getting maximum value for the window without the need to sort them. This can be achieved by maintaining the maximum score element at the front of the queue always. \\n\\nOnce the front element is out of window we can simply remove the element. Also, if we see once we get a score greater than the previous elements in the window we don\\'t need th earlier elements as the current would be always selected for future elements due to it\\'s score greater than earlier ones and also it is latest processed so would remain in the window for the last.\\n\\nSeems easy ...right? Let\\'s see the code.\\n\\n\\n```\\npublic int maxResult(int[] nums, int k) {\\n        Deque<Pair<Integer, Integer>> deque = new LinkedList<>() {{\\n            offer(new Pair<>(0, nums[0]));\\n        }};\\n        int max = nums[0];\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            while (!deque.isEmpty() && deque.peekFirst().getKey() < i - k) {\\n                deque.pollFirst();\\n            }\\n\\n            max = nums[i] + (deque.isEmpty() ? 0 : deque.peekFirst().getValue());\\n\\n            while (!deque.isEmpty() && deque.peekLast().getValue() <= max) {\\n                deque.pollLast();\\n            }\\n\\n            deque.offerLast(new Pair<>(i, max));\\n        }\\n\\n        return max;\\n    }\\n```\\n\\n*Time Complexity* - `O(n)` - At initial glance it might seem that we have multiple loops that might lead to complexity greater than `O(n)`; however, if we take a close look, we can see that each node would be processed maximum of 2 times. Once while the processing of itself and the second time either while removing out of window elements of the onces which are less than the current maximum score. \\n\\nHope that helps!! In case of any improvement or corrections please comment below. Thanks!!",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nprivate int maxResult(int[] nums, int i, int k) {\\n        if(i >= nums.length - 1) return nums[nums.length - 1];\\n        \\n        int max = Integer.MIN_VALUE;\\n        \\n        for(int j = i + 1; j <= Math.min(i + k, nums.length); j++) // Mininum of i + k, nums.length to prevent unnecessary calls for out of bounds. \\n            max = Math.max(max, maxResult( nums, j , k));\\n        \\n        return max;\\n    }\\n```\n```\\npublic int maxResult(int[] nums, int k) {\\n        int[] mem = new int[nums.length]; // Lookup table to score max score for given node\\n        \\n        for(int i = 0; i < mem.length; i++)\\n            mem[i] = Integer.MIN_VALUE;\\n        \\n        return maxResult(mem, nums, 0, k);\\n    }\\n    \\n    private int maxResult(int[] mem, int[] nums, int i, int k) {\\n        if(i >= nums.length - 1) return nums[nums.length - 1];\\n        \\n        if(mem[i] != Integer.MIN_VALUE) return mem[i];\\n        \\n        int max = Integer.MIN_VALUE;\\n        \\n        for(int j = i + 1; j <= Math.min(i + k, nums.length); j++)\\n            max = Math.max(max, maxResult(mem, nums, j , k));\\n        \\n        mem[i] = nums[i] + max;\\n        \\n        return mem[i];\\n    }\\n```\n```\\npublic int maxResult(int[] nums, int k) {\\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(k,\\n                Comparator.comparing(o -> -o.getValue())) {{\\n            offer(new Pair<>(0, nums[0]));\\n        }};\\n\\n        int max = nums[0], ans;\\n        for (int i = 1; i < nums.length; i++) {\\n            while (pq.peek().getKey() < i - k) { // We just compare the top node and see if it is outside of window or not.\\n                pq.poll();\\n            }\\n\\n            max = nums[i] + pq.peek().getValue();\\n            pq.offer(new Pair<>(i, max));\\n        }\\n\\n        return max;\\n    }\\n```\n```\\npublic int maxResult(int[] nums, int k) {\\n        Deque<Pair<Integer, Integer>> deque = new LinkedList<>() {{\\n            offer(new Pair<>(0, nums[0]));\\n        }};\\n        int max = nums[0];\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            while (!deque.isEmpty() && deque.peekFirst().getKey() < i - k) {\\n                deque.pollFirst();\\n            }\\n\\n            max = nums[i] + (deque.isEmpty() ? 0 : deque.peekFirst().getValue());\\n\\n            while (!deque.isEmpty() && deque.peekLast().getValue() <= max) {\\n                deque.pollLast();\\n            }\\n\\n            deque.offerLast(new Pair<>(i, max));\\n        }\\n\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 978573,
                "title": "c-dp-priorityqueue-explain",
                "content": "**Dp Solution** <-- Give You TLE\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        vector<int>dp(nums.size(),INT_MIN);\\n        dp[0] = nums[0];\\n        for(int i = 1;i<nums.size();i++){\\n            int l = k;\\n            while(l){\\n                if(i-l>=0){\\n                    dp[i] = max(dp[i-l]+nums[i],dp[i]);     \\n                }\\n                l--;\\n            }\\n        }\\n        return dp[nums.size()-1];\\n    }\\n};\\n```\\n\\n**Why it give Us Tle In Dp??** Let\\'s Find it and try To Optimize it\\nAs Our Dp solution take O(N * K) Time compexcity where N and K both can be as learge as 10^5\\nso no where it can be accepted by that approch\\n\\nNow while Applying Dp what we did is like\\n```\\nDp[i] = max(dp[i-k]+nums[i],dp[i]) where k-- \\nBy doing this we only found max value from previous find DP values in between i to i-k!!! in \\nO( K ) Time right??\\nSo total time taken is O(N*K)\\n```\\n**Optimize it**\\n```\\nnow  here is the trick we don\\'t need to loop each K time insted of what we can do we can use set/priority_queue to find max DP valu from previous K element by O(log K) time \\nnow find It and add to the DP table . That\\'s it!!!!!!\\n    \\n```\\n\\n**Here Is the O ( N Log K) slution**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        if(nums.size()==1)return nums[0];\\n        vector<int>dp(nums.size(),INT_MIN);\\n        multiset<int>Q;\\n        dp[0] = nums[0];\\n        Q.insert(dp[0]);\\n        for(int i = 1;i<nums.size();i++){\\n            if(Q.size()>k){\\n                auto it = Q.find(dp[i-k-1]);\\n                Q.erase(it);\\n            }\\n            dp[i] = max(*Q.rbegin()+nums[i],dp[i]);\\n            Q.insert(dp[i]);\\n        }\\n        return dp[nums.size()-1];\\n    }\\n};\\n```\\n\\n\\n**If you like it then Please Upvote**\\n**any doubt ask in comment**\\n**Thank You :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        vector<int>dp(nums.size(),INT_MIN);\\n        dp[0] = nums[0];\\n        for(int i = 1;i<nums.size();i++){\\n            int l = k;\\n            while(l){\\n                if(i-l>=0){\\n                    dp[i] = max(dp[i-l]+nums[i],dp[i]);     \\n                }\\n                l--;\\n            }\\n        }\\n        return dp[nums.size()-1];\\n    }\\n};\\n```\n```\\nDp[i] = max(dp[i-k]+nums[i],dp[i]) where k-- \\nBy doing this we only found max value from previous find DP values in between i to i-k!!! in \\nO( K ) Time right??\\nSo total time taken is O(N*K)\\n```\n```\\nnow  here is the trick we don\\'t need to loop each K time insted of what we can do we can use set/priority_queue to find max DP valu from previous K element by O(log K) time \\nnow find It and add to the DP table . That\\'s it!!!!!!\\n    \\n```\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        if(nums.size()==1)return nums[0];\\n        vector<int>dp(nums.size(),INT_MIN);\\n        multiset<int>Q;\\n        dp[0] = nums[0];\\n        Q.insert(dp[0]);\\n        for(int i = 1;i<nums.size();i++){\\n            if(Q.size()>k){\\n                auto it = Q.find(dp[i-k-1]);\\n                Q.erase(it);\\n            }\\n            dp[i] = max(*Q.rbegin()+nums[i],dp[i]);\\n            Q.insert(dp[i]);\\n        }\\n        return dp[nums.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1260696,
                "title": "python-monotonic-deque-explained",
                "content": "This problem is very similar to problem **239. Sliding Window Maximum**, see my explained solution here  https://leetcode.com/problems/sliding-window-maximum/discuss/951683/Python-Decreasing-deque-short-explained\\n\\nLet us ask the question: what is the maximum score we can get when we reached index `i`? It is equal to `nums[i]` + maximum among previous `k` (or less if we reached boundary) numbers. The idea is exaclty the same as we use in problem **239**:\\n\\n1. Let us `deq` be monotonic deque, that is deque, where elements inside will always decrease (in fact we keep indexes, not numbers).\\n2. `while deq and deq[0] < i - k: deq.popleft()` this line will remove all outdated elements from our deque.\\n3. `nums[i] += nums[deq[0]]`. Now we know that our deque is up-to-date, so we have maximum of sliding window inside it, and also because we have decreasing structure, it will be element with index `0`. So, what I did here, instead of using `dp` array, we update elements of `nums` instead.\\n4. `while deq and nums[i] >= nums[deq[-1]]: deq.pop()`. We want to add new element `i`, and we need to keep our deque decreasing, so we remove as much element as needed to keep this invariant, and then put element `i` to the end.\\n\\n#### Complexity\\nTime complexity is just `O(n)`, because for each index `i` it will be at most once put to deque and removed from deque. Space complexity is `O(k)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maxResult(self, nums, k):\\n        deq, n = deque([0]), len(nums)\\n\\n        for i in range(1, n):\\n            while deq and deq[0] < i - k: deq.popleft()\\n            nums[i] += nums[deq[0]]   \\n            while deq and nums[i] >= nums[deq[-1]]: deq.pop()\\n            deq.append(i)\\n            \\n        return nums[-1]\\n```\\n\\n#### Remark\\nAs this problem is closely connected with problem **239**, you can in fact use any method which was working there. I know at least 2 other approaches: one is BST with complexity `O(n log k)` and another is heaps with lazy updates with complexity `O(n log n)`.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Monotonic Queue"
                ],
                "code": "```python\\nclass Solution:\\n    def maxResult(self, nums, k):\\n        deq, n = deque([0]), len(nums)\\n\\n        for i in range(1, n):\\n            while deq and deq[0] < i - k: deq.popleft()\\n            nums[i] += nums[deq[0]]   \\n            while deq and nums[i] >= nums[deq[-1]]: deq.pop()\\n            deq.append(i)\\n            \\n        return nums[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261753,
                "title": "js-python-java-c-easy-dp-deque-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nFor this problem, we can see that there are many possible paths from one end of **nums** to the other, but that they cross back over each other countless times. There may be multiple ways to get to a given element in the middle of **nums**, but there should only be one best way to get from there to the end of **nums**.\\n\\nWhen we find ourselves potentially solving the same subproblem over and over again, it\\'s time for a **dynamic programming** (**DP**) approach. In a normal DP approach, we would create a DP array to store the best solution from each element to the end, but since we\\'re only going to be iterating through **nums** once, we can use an **in-place DP** approach and modify the elements of **nums** as we iterate through.\\n\\n_(**Note**: If you choose not to modify your inputs, you can make a separate DP array to store these values. This will increase the **space complexity** to **O(N)**.)_\\n\\nNow, if we consider being located at a particular element in **nums**, and all the elements ahead of us having been modified to equal the best value to the end of **nums**, then the best value for the current location will be its own value plus the best value it can reach in a jump of up to **k** distance.\\n\\nOne option here would be to use a **priority queue** to keep track of the best results ahead, then we could just take the top value in the priority queue (while remembering to first remove any entries that are farther than **k** distance away). But a priority queue isn\\'t terribly efficient for our purposes.\\n\\nInstead, we can use a **double-ended queue** (**deq**) to good effect here. Since we\\'ll need to remove elements from the front end of **deq** if they\\'re outside the jump window, we should use indexes for the **deq** entries.\\n\\nWhen we go to push an index onto **deq**, we should consider that any indexes at the end of **deq** which represent lower values will never be used, as they will always be surpassed by the newer value until they fall outside the jump window. Before pushing the new index onto **deq** then, we should remove from the end of **deq** any indexes representing lower values.\\n\\nThis consequently means that **deq** will always be sorted from high to low values, which is precisely what we wanted. At every iteration (**i**) then, after removing out-of-window indexes, the top entry will represent the value we want to add to **nums[i]** to equal the best result from **i** to the end of **nums**.\\n\\nWe can continue this iteration down to **i = 0**, then **return nums[0]** as the finished result.\\n\\n - _**Time Complexity: O(N)** where **N** is the length of **nums**_\\n - _**Space Complexity: O(K)** for **deq**_\\n   - _or **O(N)** if we use a separate DP array rather than modifying **nums**_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor Java, the **ArrayDeque()** implementation is much slower than using an **int array** with the same length as **nums** and then using a **sliding window** with pointers (**a, b**) to represent the current first and last element of **deq**. This will push the **space complexity** to **O(N)**.\\n\\nThe same applies to C++ and their implementation of **deque()**, though to a lesser degree.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **92ms / 48.6MB** (beats 100% / 100%).\\n```javascript\\nvar maxResult = function(nums, k) {\\n   let n = nums.length, deq = [n-1]\\n    for (let i = n - 2; ~i; i--) {\\n        if (deq[0] - i > k) deq.shift()\\n        nums[i] += nums[deq[0]]\\n        while (deq.length && nums[deq[deq.length-1]] <= nums[i]) deq.pop()\\n        deq.push(i)\\n    }\\n    return nums[0] \\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **952ms / 28.0MB** (beats 96% / 85%).\\n```python\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        deq = deque([n-1])\\n        for i in range(n-2, -1, -1):\\n            if deq[0] - i > k: deq.popleft()\\n            nums[i] += nums[deq[0]]\\n            while len(deq) and nums[deq[-1]] <= nums[i]: deq.pop()\\n            deq.append(i)\\n        return nums[0]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **5ms / 53.2MB** (beats 100% / 85%).\\n```java\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        int n = nums.length, a = 0, b = 0;\\n        int[] deq = new int[n];\\n        deq[0] = n - 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (deq[a] - i > k) a++;\\n            nums[i] += nums[deq[a]];\\n            while (b >= a && nums[deq[b]] <= nums[i]) b--;\\n            deq[++b] = i;\\n        }\\n        return nums[0];\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **120ms / 76.8MB** (beats 99% / 100%).\\n```c++\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size(), a = 0, b = 0;\\n        int deq[n];\\n        deq[0] = n - 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (deq[a] - i > k) a++;\\n            nums[i] += nums[deq[a]];\\n            while (b >= a && nums[deq[b]] <= nums[i]) b--;\\n            deq[++b] = i;\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar maxResult = function(nums, k) {\\n   let n = nums.length, deq = [n-1]\\n    for (let i = n - 2; ~i; i--) {\\n        if (deq[0] - i > k) deq.shift()\\n        nums[i] += nums[deq[0]]\\n        while (deq.length && nums[deq[deq.length-1]] <= nums[i]) deq.pop()\\n        deq.push(i)\\n    }\\n    return nums[0] \\n};\\n```\n```python\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        deq = deque([n-1])\\n        for i in range(n-2, -1, -1):\\n            if deq[0] - i > k: deq.popleft()\\n            nums[i] += nums[deq[0]]\\n            while len(deq) and nums[deq[-1]] <= nums[i]: deq.pop()\\n            deq.append(i)\\n        return nums[0]\\n```\n```java\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        int n = nums.length, a = 0, b = 0;\\n        int[] deq = new int[n];\\n        deq[0] = n - 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (deq[a] - i > k) a++;\\n            nums[i] += nums[deq[a]];\\n            while (b >= a && nums[deq[b]] <= nums[i]) b--;\\n            deq[++b] = i;\\n        }\\n        return nums[0];\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size(), a = 0, b = 0;\\n        int deq[n];\\n        deq[0] = n - 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (deq[a] - i > k) a++;\\n            nums[i] += nums[deq[a]];\\n            while (b >= a && nums[deq[b]] <= nums[i]) b--;\\n            deq[++b] = i;\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256874,
                "title": "c-dp-max-heap-approach-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        vector<int>dp(nums.size());  //dp[i] stores max cost from ith index to last index\\n        dp[nums.size()-1]=nums[nums.size()-1];\\n        priority_queue<pair<int,int>> maxh; //max heap to store {dp[index], index}\\n        maxh.push({dp[nums.size()-1],nums.size()-1});\\n        for(int i=nums.size()-2;i>=0;i--){\\n            while(maxh.size() && maxh.top().second>i+k) maxh.pop(); //we keep popping elements that are out of our window of size k to find the first top element inside our range.\\n            dp[i]=maxh.top().first+nums[i]; //That will be our max cost so we add it + current index cost\\n            maxh.push({dp[i],i}); // then we push the current dp[i] and i into max heap\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\nPlease upvote if you found this useful :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        vector<int>dp(nums.size());  //dp[i] stores max cost from ith index to last index\\n        dp[nums.size()-1]=nums[nums.size()-1];\\n        priority_queue<pair<int,int>> maxh; //max heap to store {dp[index], index}\\n        maxh.push({dp[nums.size()-1],nums.size()-1});\\n        for(int i=nums.size()-2;i>=0;i--){\\n            while(maxh.size() && maxh.top().second>i+k) maxh.pop(); //we keep popping elements that are out of our window of size k to find the first top element inside our range.\\n            dp[i]=maxh.top().first+nums[i]; //That will be our max cost so we add it + current index cost\\n            maxh.push({dp[i],i}); // then we push the current dp[i] and i into max heap\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256910,
                "title": "optimal-o-n-time-and-space-dp-solution-python-c",
                "content": "**Upvote** if you like efficient solution code!\\n\\n**Join our discord** to meet other people preparing for interviews!\\n**https://discord.gg/Aj2uT5rP**\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        dp = deque([(nums[0], 0)])\\n        for i in range(1, len(nums)):\\n            while dp and dp[0][1] + k < i:\\n                dp.popleft()\\n            cost = nums[i] + dp[0][0]\\n            while dp and cost >= dp[-1][0]:\\n                dp.pop()\\n            dp.append((cost, i))\\n        return dp[-1][0]\\n```\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        deque<pair<int, int>> dp;\\n        dp.emplace_front(nums[0], 0);\\n        for (int i = 1; i < nums.size(); i++) {\\n            while (dp.front().second + k < i) {\\n                dp.pop_front();\\n            }\\n            int cost = dp.front().first + nums[i];\\n            while (!dp.empty() && cost >= dp.back().first) {\\n                dp.pop_back();\\n            }\\n            dp.emplace_back(cost, i);\\n        }\\n        return dp.back().first;\\n    }\\n};\\n```\\n\\n**Time Complexity** O(n) - Single pass through `nums`. At most `n` elments are added to and popped from `dp` deque.\\n**Space Complexity** O(n) - `dp` deque grows to at most `n` elements.",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Monotonic Queue"
                ],
                "code": "```python\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        dp = deque([(nums[0], 0)])\\n        for i in range(1, len(nums)):\\n            while dp and dp[0][1] + k < i:\\n                dp.popleft()\\n            cost = nums[i] + dp[0][0]\\n            while dp and cost >= dp[-1][0]:\\n                dp.pop()\\n            dp.append((cost, i))\\n        return dp[-1][0]\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        deque<pair<int, int>> dp;\\n        dp.emplace_front(nums[0], 0);\\n        for (int i = 1; i < nums.size(); i++) {\\n            while (dp.front().second + k < i) {\\n                dp.pop_front();\\n            }\\n            int cost = dp.front().first + nums[i];\\n            while (!dp.empty() && cost >= dp.back().first) {\\n                dp.pop_back();\\n            }\\n            dp.emplace_back(cost, i);\\n        }\\n        return dp.back().first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256855,
                "title": "java-soln-faster-than-96-96-easy-soln",
                "content": "**Please Upvote if it helps !!**\\n\\n```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        LinkedList<Integer> list = new LinkedList<>(); // for storing indices\\n        list.add(0);\\n        for(int i=1; i<nums.length; i++){\\n\\t\\t\\t//checking if the value lies between the range of last k values, if not \"bye-bye\"\\n            if(list.getFirst() < i-k) list.removeFirst();\\n\\t\\t\\t// setting nums[i] equal to curr. value and curr. max value\\n            nums[i] += nums[list.getFirst()];\\n\\t\\t\\t//if index not between last k values, remove it.\\n            while(!list.isEmpty() && nums[list.getLast()] <= nums[i]) list.removeLast();\\n            list.addLast(i);\\n        }\\n        return nums[nums.length-1];\\n    }\\n}\\n```\\nThank you.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        LinkedList<Integer> list = new LinkedList<>(); // for storing indices\\n        list.add(0);\\n        for(int i=1; i<nums.length; i++){\\n\\t\\t\\t//checking if the value lies between the range of last k values, if not \"bye-bye\"\\n            if(list.getFirst() < i-k) list.removeFirst();\\n\\t\\t\\t// setting nums[i] equal to curr. value and curr. max value\\n            nums[i] += nums[list.getFirst()];\\n\\t\\t\\t//if index not between last k values, remove it.\\n            while(!list.isEmpty() && nums[list.getLast()] <= nums[i]) list.removeLast();\\n            list.addLast(i);\\n        }\\n        return nums[nums.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1260981,
                "title": "python-both-ways-dp-and-priority-queue-max-heap",
                "content": "```\\nNaive Approach: Dynamic Programming: Time = O(N x k) Space = O(N)\\nIdea: \\n1. Create a DP array of size N.\\n2. Traverse through all the elements in nums. For each element, check the previous \\'k\\' elements in DP array and take the maximum as \\'maxV\\'.\\n3. dp[i] = maxV + nums[i]\\n\\nReason: we can move at most \\'k\\' steps from any particular position. Hence, position \\'i\\' can be reached from \\'position \\'i-1\\',\\'i-2\\'...\\'i-k\\'. \\n\\t\\tAnd since we need the max score hence we are taking the max score of the previous \\'k\\' elements \\n\\t\\tand we need to consider the current score as well so we are adding nums[i] to maxV.\\n```\\n```\\nThis approach gives ** TLE ** as both N and k are in the range of 10^5 so T = O(N x k) = O(10^5 x 10^5) = O(10^10) > O(10^8) [the threshold for TLE]. \\n\\nThe Full Code:\\n\\tdef maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [0]*n\\n        for i in range(n):\\n            maxV = float(\\'-inf\\')\\n            for j in range(i-k, i):\\n                if j>=0:\\n                    maxV = max(maxV, dp[j])\\n            if maxV == float(\"-inf\"):\\n                maxV = 0\\n            dp[i] = nums[i] + maxV\\n        return dp[n-1]\\n```\\n```\\nBetter Approach: Using Priority Queue (Max Heap): T = O(N x log k); S = O(k) \\nIdea: Searching the DP array for max value in previous \\'k\\' elements takes Time = O(k). \\nIs there a better way to get the max value in previous \\'k\\' elements? Yes, using a max-heap we can retreive the priority queue in O(1) time \\nbut we need to adjust the priority queue again such that the next maximum element is at the top and this takes O(log k) time.\\n\\nThe Full Code:\\n\\tdef maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        queue = []\\n        val = 0\\n        for i in range(n):\\n            maxV = 0\\n            if queue:\\n                maxV, indx = queue[0]\\n                while indx+k < i:\\n                    maxV, indx = heapq.heappop(queue)\\n                heapq.heappush(queue, [maxV,indx])\\n            val = nums[i] + (-1) * maxV\\n            heapq.heappush(queue, [-1 * val, i]) \\n        return val\\n\\n\\nNow problem with python, there is nothing called max-heap in python, the \"heapq\" is a min-heap by default.\\nSo to use this min-heap as a max-heap, we multiply the value by -1 such that the smallest element becomes the largest and the largest element becomes the smallest.\\nAnd whenever we want to get the actual value we multiply -1 again to the value in the min-heap.\\n\\nThe min-heap may contain values that are not in a distance of previous \\'k\\' from \\'i\\'. So we keep deleting the values whose index in nums is not in a range of \\'k\\' from \\'i\\' by using the while indx+k < i:  loop inside.\\n\\nThere might be a simpler code present, but this is what I have done. Hope it helps!\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nNaive Approach: Dynamic Programming: Time = O(N x k) Space = O(N)\\nIdea: \\n1. Create a DP array of size N.\\n2. Traverse through all the elements in nums. For each element, check the previous \\'k\\' elements in DP array and take the maximum as \\'maxV\\'.\\n3. dp[i] = maxV + nums[i]\\n\\nReason: we can move at most \\'k\\' steps from any particular position. Hence, position \\'i\\' can be reached from \\'position \\'i-1\\',\\'i-2\\'...\\'i-k\\'. \\n\\t\\tAnd since we need the max score hence we are taking the max score of the previous \\'k\\' elements \\n\\t\\tand we need to consider the current score as well so we are adding nums[i] to maxV.\\n```\n```\\nThis approach gives ** TLE ** as both N and k are in the range of 10^5 so T = O(N x k) = O(10^5 x 10^5) = O(10^10) > O(10^8) [the threshold for TLE]. \\n\\nThe Full Code:\\n\\tdef maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [0]*n\\n        for i in range(n):\\n            maxV = float(\\'-inf\\')\\n            for j in range(i-k, i):\\n                if j>=0:\\n                    maxV = max(maxV, dp[j])\\n            if maxV == float(\"-inf\"):\\n                maxV = 0\\n            dp[i] = nums[i] + maxV\\n        return dp[n-1]\\n```\n```\\nBetter Approach: Using Priority Queue (Max Heap): T = O(N x log k); S = O(k) \\nIdea: Searching the DP array for max value in previous \\'k\\' elements takes Time = O(k). \\nIs there a better way to get the max value in previous \\'k\\' elements? Yes, using a max-heap we can retreive the priority queue in O(1) time \\nbut we need to adjust the priority queue again such that the next maximum element is at the top and this takes O(log k) time.\\n\\nThe Full Code:\\n\\tdef maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        queue = []\\n        val = 0\\n        for i in range(n):\\n            maxV = 0\\n            if queue:\\n                maxV, indx = queue[0]\\n                while indx+k < i:\\n                    maxV, indx = heapq.heappop(queue)\\n                heapq.heappush(queue, [maxV,indx])\\n            val = nums[i] + (-1) * maxV\\n            heapq.heappush(queue, [-1 * val, i]) \\n        return val\\n\\n\\nNow problem with python, there is nothing called max-heap in python, the \"heapq\" is a min-heap by default.\\nSo to use this min-heap as a max-heap, we multiply the value by -1 such that the smallest element becomes the largest and the largest element becomes the smallest.\\nAnd whenever we want to get the actual value we multiply -1 again to the value in the min-heap.\\n\\nThe min-heap may contain values that are not in a distance of previous \\'k\\' from \\'i\\'. So we keep deleting the values whose index in nums is not in a range of \\'k\\' from \\'i\\' by using the while indx+k < i:  loop inside.\\n\\nThere might be a simpler code present, but this is what I have done. Hope it helps!\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 978455,
                "title": "priorityqueue-or-deque-solution-java",
                "content": "Using PriorityQueue:\\n```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        if(nums.length == 1) return nums[0];\\n        int ans = Integer.MIN_VALUE;\\n        int n = nums.length;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[1] - a[1]);\\n        pq.offer(new int[]{n - 1, nums[n - 1]});\\n        for (int i = n - 2; i >= 0; i--){\\n            while(pq.peek()[0] > i + k){\\n                pq.poll();\\n            }\\n            ans = nums[i] + pq.peek()[1];\\n            pq.offer(new int[]{i, ans});\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nTime Complexity: O(Nlog(N))\\n\\nUsing Deque:\\n```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        if(nums.length == 1) return nums[0];\\n        int ans = Integer.MIN_VALUE;\\n        int n = nums.length;\\n        Deque<int[]> deque = new ArrayDeque<>();\\n        deque.offer(new int[]{n - 1, nums[n - 1]});\\n        for (int i = n - 2; i >= 0; i--){\\n            while(!deque.isEmpty() && deque.peekFirst()[0] > i + k){\\n                deque.pollFirst();\\n            }\\n            \\n            ans = nums[i] + deque.peekFirst()[1];\\n            \\n            while(!deque.isEmpty() && deque.peekLast()[1] < ans){\\n                deque.pollLast();\\n            }\\n            \\n            deque.offer(new int[]{i, ans});\\n        }\\n        return ans;\\n    }\\n}\\n```\\nTime Complexity:  O(N)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        if(nums.length == 1) return nums[0];\\n        int ans = Integer.MIN_VALUE;\\n        int n = nums.length;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[1] - a[1]);\\n        pq.offer(new int[]{n - 1, nums[n - 1]});\\n        for (int i = n - 2; i >= 0; i--){\\n            while(pq.peek()[0] > i + k){\\n                pq.poll();\\n            }\\n            ans = nums[i] + pq.peek()[1];\\n            pq.offer(new int[]{i, ans});\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        if(nums.length == 1) return nums[0];\\n        int ans = Integer.MIN_VALUE;\\n        int n = nums.length;\\n        Deque<int[]> deque = new ArrayDeque<>();\\n        deque.offer(new int[]{n - 1, nums[n - 1]});\\n        for (int i = n - 2; i >= 0; i--){\\n            while(!deque.isEmpty() && deque.peekFirst()[0] > i + k){\\n                deque.pollFirst();\\n            }\\n            \\n            ans = nums[i] + deque.peekFirst()[1];\\n            \\n            while(!deque.isEmpty() && deque.peekLast()[1] < ans){\\n                deque.pollLast();\\n            }\\n            \\n            deque.offer(new int[]{i, ans});\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257930,
                "title": "sliding-window-and-priority-queue",
                "content": "Approach: **By Recursion**\\nOutput: Time Limit Exceeded\\n**\\u092E\\u0947\\u0930\\u0947 \\u092A\\u093E\\u0938 \\u0907\\u0924\\u0928\\u093E \\u091F\\u093E\\u0907\\u092E \\u0928\\u0939\\u0940\\u0902, \\u091C\\u094B \\u0907\\u0924\\u0928\\u093E \\u0935\\u0947\\u091F \\u0915\\u0930\\u0942\\u0901\\u0917\\u093E **\\n```\\nclass Solution {\\n    \\n    int min = -10001;\\n    \\n    public int maxResult(int[] nums, int k) {\\n        return getScore(nums, k, 0);\\n    }\\n    \\n    int getScore(int[] nums, int k, int currentIndex){\\n        //System.out.println(\"gs( \"+currentIndex+\")\");\\n        if(currentIndex==nums.length-1){\\n            return nums[currentIndex];\\n        }\\n        if(currentIndex>=nums.length){\\n            return min;\\n        }\\n        int maxScore = min;\\n        for(int i=1; i<=k; i++){\\n            maxScore = Math.max(maxScore, nums[currentIndex]+getScore(nums, k, currentIndex+i));\\n        }\\n        return maxScore;\\n    }\\n    \\n}\\n```\\n\\nApproach: **Recusrsion With DP.**\\nOutput: Time Limit Exceeded.\\n**\\u092E\\u0947\\u0930\\u0947 \\u092A\\u093E\\u0938 \\u092D\\u0940 \\u0907\\u0924\\u0928\\u093E \\u091F\\u093E\\u0907\\u092E \\u0928\\u0939\\u0940\\u0902 **\\n```\\nclass Solution {\\n    \\n    int min = -10000*100000 + 1;\\n    Integer[] dp = new Integer[100000];\\n    \\n    public int maxResult(int[] nums, int k) {\\n        return getScore(nums, k, 0);\\n    }\\n    \\n    int getScore(int[] nums, int k, int currentIndex){\\n        //System.out.println(\"gs( \"+currentIndex+\")\");\\n        if(currentIndex==nums.length-1){\\n            return nums[currentIndex];\\n        }\\n        if(currentIndex>=nums.length){\\n            return min;\\n        }\\n        if(dp[currentIndex]!=null){\\n            return dp[currentIndex];\\n        }\\n        int maxScore = min;\\n        for(int i=1; i<=k; i++){\\n            maxScore = Math.max(maxScore, nums[currentIndex]+getScore(nums, k, currentIndex+i));\\n        }\\n        dp[currentIndex] = maxScore;\\n        return dp[currentIndex];\\n    }\\n    \\n}\\n```\\n\\nApproach: **With Sliding Window and PriorityQueue**\\nOutput: Success\\n\\u0906 \\u0939\\u0940 \\u0917\\u090F \\u0928 \\u092E\\u0947\\u0930\\u0947 \\u092A\\u093E\\u0938\\n```\\nclass Solution {\\n    \\n    public int maxResult(int[] nums, int k) {\\n        if(nums.length==0){\\n            return 0;\\n        }\\n        \\n        // To reach at index 0, maxScore is nums[0]\\n        int maxScore = nums[0];\\n        \\n        // [index, max], maxScore will at top\\n        PriorityQueue<int[]> pq = new  PriorityQueue<>((a,b)->b[1]-a[1]);\\n        \\n        //add first index and its score at top\\n        pq.offer(new int[]{0, nums[0]});\\n        \\n        // now, we find maxScore to reach till ith index\\n        for(int i=1; i<nums.length; i++){\\n            // if (i-peek[])<=k \\n            while(!(i-pq.peek()[0]<=k)){\\n                pq.poll();\\n            }\\n            // get the peek of queue\\n            int[] top = pq.peek();\\n            maxScore = top[1] + nums[i];\\n            // get maxScore and add it queue\\n            pq.offer(new int[]{i, maxScore});\\n        }\\n        return maxScore;\\n        \\n    }\\n    \\n}\\n```\\n![image](https://assets.leetcode.com/users/images/e9de8a96-921e-4a4d-8541-25446ccf474a_1657360480.015404.png)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int min = -10001;\\n    \\n    public int maxResult(int[] nums, int k) {\\n        return getScore(nums, k, 0);\\n    }\\n    \\n    int getScore(int[] nums, int k, int currentIndex){\\n        //System.out.println(\"gs( \"+currentIndex+\")\");\\n        if(currentIndex==nums.length-1){\\n            return nums[currentIndex];\\n        }\\n        if(currentIndex>=nums.length){\\n            return min;\\n        }\\n        int maxScore = min;\\n        for(int i=1; i<=k; i++){\\n            maxScore = Math.max(maxScore, nums[currentIndex]+getScore(nums, k, currentIndex+i));\\n        }\\n        return maxScore;\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    \\n    int min = -10000*100000 + 1;\\n    Integer[] dp = new Integer[100000];\\n    \\n    public int maxResult(int[] nums, int k) {\\n        return getScore(nums, k, 0);\\n    }\\n    \\n    int getScore(int[] nums, int k, int currentIndex){\\n        //System.out.println(\"gs( \"+currentIndex+\")\");\\n        if(currentIndex==nums.length-1){\\n            return nums[currentIndex];\\n        }\\n        if(currentIndex>=nums.length){\\n            return min;\\n        }\\n        if(dp[currentIndex]!=null){\\n            return dp[currentIndex];\\n        }\\n        int maxScore = min;\\n        for(int i=1; i<=k; i++){\\n            maxScore = Math.max(maxScore, nums[currentIndex]+getScore(nums, k, currentIndex+i));\\n        }\\n        dp[currentIndex] = maxScore;\\n        return dp[currentIndex];\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    \\n    public int maxResult(int[] nums, int k) {\\n        if(nums.length==0){\\n            return 0;\\n        }\\n        \\n        // To reach at index 0, maxScore is nums[0]\\n        int maxScore = nums[0];\\n        \\n        // [index, max], maxScore will at top\\n        PriorityQueue<int[]> pq = new  PriorityQueue<>((a,b)->b[1]-a[1]);\\n        \\n        //add first index and its score at top\\n        pq.offer(new int[]{0, nums[0]});\\n        \\n        // now, we find maxScore to reach till ith index\\n        for(int i=1; i<nums.length; i++){\\n            // if (i-peek[])<=k \\n            while(!(i-pq.peek()[0]<=k)){\\n                pq.poll();\\n            }\\n            // get the peek of queue\\n            int[] top = pq.peek();\\n            maxScore = top[1] + nums[i];\\n            // get maxScore and add it queue\\n            pq.offer(new int[]{i, maxScore});\\n        }\\n        return maxScore;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1260965,
                "title": "jump-game-vi-dry-run-and-explanation-for-clarity-c",
                "content": "**Dp Explanation:**\\n\\n![image](https://assets.leetcode.com/users/images/0ac678fe-2b13-44d4-ad80-2dee25901f2e_1623236718.3317683.png)\\n![image](https://assets.leetcode.com/users/images/7f50090b-2388-4acc-8a47-ac41519a870c_1623236728.5779495.png)\\n\\n\\n**Using Priority Queue (Time-O(nlogn),Space-O(n)):**\\n\\n**Dry-Run:**\\n![image](https://assets.leetcode.com/users/images/64e74905-957e-4117-8883-103a25b28a29_1623236748.1103823.png)\\n![image](https://assets.leetcode.com/users/images/e890c423-d86d-489f-93a4-24ec5b59e9ed_1623236755.9492424.png)\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        \\n         priority_queue<pair<int,int>> pq;      \\n         vector<int> dp(nums.size(),0);\\n\\t\\t \\n         for(int i=0;i<nums.size();i++)\\n         {\\n             while(!pq.empty() && pq.top().second<i-k)\\n                 pq.pop();\\n             \\n             dp[i]=nums[i]+(pq.empty()?0:pq.top().first);\\n             pq.push({dp[i],i});\\n         }\\n         return dp[nums.size()-1];\\n               \\n    }\\n};\\n```\\n\\n**Using Deque(Time-O(n),Space-O(k)):**\\n\\n**Dry-Run:**\\n![image](https://assets.leetcode.com/users/images/7db66467-d9f4-41a7-bfd2-7008318f1e1c_1623259038.270804.png)\\n\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        \\n        deque<pair<int,int>> dq;\\n        int curr=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            curr=nums[i]+(dq.empty()?0:dq.front().second);\\n            \\n            while(!dq.empty() && dq.back().second<curr)\\n                dq.pop_back();\\n            dq.push_back({i,curr});\\n            \\n            if(dq.front().first+k==i)\\n                dq.pop_front();\\n        }\\n        return curr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        \\n         priority_queue<pair<int,int>> pq;      \\n         vector<int> dp(nums.size(),0);\\n\\t\\t \\n         for(int i=0;i<nums.size();i++)\\n         {\\n             while(!pq.empty() && pq.top().second<i-k)\\n                 pq.pop();\\n             \\n             dp[i]=nums[i]+(pq.empty()?0:pq.top().first);\\n             pq.push({dp[i],i});\\n         }\\n         return dp[nums.size()-1];\\n               \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        \\n        deque<pair<int,int>> dq;\\n        int curr=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            curr=nums[i]+(dq.empty()?0:dq.front().second);\\n            \\n            while(!dq.empty() && dq.back().second<curr)\\n                dq.pop_back();\\n            dq.push_back({i,curr});\\n            \\n            if(dq.front().first+k==i)\\n                dq.pop_front();\\n        }\\n        return curr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980529,
                "title": "java-o-n-solution-dp-dequeue-15ms-simple-code-faster-than-100",
                "content": "**scores[i]** means the max score for i.\\n**queue** store the index of decreasing sequence in scores[i-k]~scores[i-1]. So, **queue.getFirst()** means the max score in scores[i-k]~scores[i-1].\\n\\nBecause the **queue.removeLast()** executed up to n times , So it still O(n) in time complexity.\\n\\n```\\npublic static class Solution {\\n    public int maxResult(int[] nums, int k) {\\n        // state\\n        int[] scores = new int[nums.length];\\n        LinkedList<Integer> queue = new LinkedList<>();\\n\\n        // initialization\\n        scores[0] = nums[0];\\n        queue.offer(0);\\n\\n        // function\\n        for (int i = 1 ; i < nums.length ; i++) {\\n            if (queue.getFirst() < i - k) {\\n                queue.removeFirst();\\n            }\\n            scores[i] = scores[queue.getFirst()] + nums[i];\\n\\n            while (!queue.isEmpty() && scores[queue.getLast()] <= scores[i]) {\\n                queue.removeLast();\\n            }\\n            queue.addLast(i);\\n        }\\n\\n        // answer\\n        return scores[nums.length - 1];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic static class Solution {\\n    public int maxResult(int[] nums, int k) {\\n        // state\\n        int[] scores = new int[nums.length];\\n        LinkedList<Integer> queue = new LinkedList<>();\\n\\n        // initialization\\n        scores[0] = nums[0];\\n        queue.offer(0);\\n\\n        // function\\n        for (int i = 1 ; i < nums.length ; i++) {\\n            if (queue.getFirst() < i - k) {\\n                queue.removeFirst();\\n            }\\n            scores[i] = scores[queue.getFirst()] + nums[i];\\n\\n            while (!queue.isEmpty() && scores[queue.getLast()] <= scores[i]) {\\n                queue.removeLast();\\n            }\\n            queue.addLast(i);\\n        }\\n\\n        // answer\\n        return scores[nums.length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259706,
                "title": "c-recursion-memoization-tabulation-tabulation-priority-queue",
                "content": "In this answer I have solved by optimizing every solution step by step, so that we understand where were we lacking in the previous approach, and what steps are we following to optimize it. For the recursive, memoized, and tabulation solution we are getting TLE. In the last solution we have optimized the Tabulation solution by adding a priority queue and making the solution O(NlogN). \\n\\n\\u274C **Recursive (TLE)**\\nWe are applying brute force in a way in which we are checking all the possible ways and returning the one in which we get the maximum score.\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int k, vector<int>&nums){\\n        if(i >= nums.size()) return 0;\\n        int ans = INT_MIN;\\n        for(int j=1; j<=k; j++){\\n            ans = max(ans, nums[i] + solve(i+j, k, nums));\\n        }\\n        return ans;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        return solve(0, k, nums);\\n    }\\n};\\n```\\n**Time Complexity: O(k^N)**\\n**Space Complexity: O(N)**\\n\\n\\u274C **Memoization (TLE)**\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n\\t\\tint n = nums.size();\\n\\t\\tvector<int> dp(n, INT_MIN);\\n\\t\\tdp[n-1] = nums[n-1];\\n\\t\\treturn solve(nums, dp, k, 0);\\n\\t}\\n\\tint solve(vector<int>& nums, vector<int>& dp, int k, int i) {\\n\\t\\tif(dp[i] != INT_MIN) return dp[i]; \\n        int ans = INT_MIN;\\n\\t\\tfor(int j = 1; j <= k; j++)        \\n\\t\\t\\tif(i + j < nums.size())\\n\\t\\t\\t\\tans = max(ans, nums[i] + solve(nums, dp, k, i + j));\\n\\t\\treturn dp[i] = ans;\\n\\t}\\n};\\n```\\n**Time Complexity: O(kN)**\\n**Space Complexity: O(N)**\\n\\n\\u274C **Bottom-up DP (TLE)**\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        vector<int>dp(nums.size(),INT_MIN);\\n        dp[0] = nums[0];\\n        for(int i=1; i<nums.size(); i++){\\n            for(int j=1; j<=k && i-j >=0; j++){\\n                dp[i] = max(dp[i], nums[i] + dp[i-j]);\\n            }\\n        }\\n        return dp[nums.size()-1];\\n    }\\n};\\n```\\n**Time Complexity: O(kN)**\\n**Space Complexity: O(N)**\\n\\n\\u2714 **Bottom-up DP + priority queue (accepted)**\\nThe optimization here is that, in the previous solution, we are always taking that dp[i-j], j going from 1 to k and i-j should be greater than 0, which is the maximum, so instead of always looping from 1 to k, we are storing the values of dp[i]\\'s in the max heap and taking the top element satisfying the condition that it is not exceeding i by more than k.\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        vector<int>dp(nums.size(),INT_MIN);\\n        dp[0] = nums[0];\\n        priority_queue<pair<int,int>>pq;\\n        pq.push({dp[0],0});\\n        for(int i=1; i<nums.size(); i++){\\n            while(pq.size() && i-pq.top().second >k){\\n                pq.pop();\\n            }\\n            auto top = pq.top();\\n            dp[i] = max(dp[i], nums[i] + dp[top.second]);\\n            pq.push({dp[i],i});\\n        }\\n        return dp[nums.size()-1];\\n    }\\n};\\n```\\n**Time Complexity: O(NlogN)**\\n**Space Complexity: O(N)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int k, vector<int>&nums){\\n        if(i >= nums.size()) return 0;\\n        int ans = INT_MIN;\\n        for(int j=1; j<=k; j++){\\n            ans = max(ans, nums[i] + solve(i+j, k, nums));\\n        }\\n        return ans;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        return solve(0, k, nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n\\t\\tint n = nums.size();\\n\\t\\tvector<int> dp(n, INT_MIN);\\n\\t\\tdp[n-1] = nums[n-1];\\n\\t\\treturn solve(nums, dp, k, 0);\\n\\t}\\n\\tint solve(vector<int>& nums, vector<int>& dp, int k, int i) {\\n\\t\\tif(dp[i] != INT_MIN) return dp[i]; \\n        int ans = INT_MIN;\\n\\t\\tfor(int j = 1; j <= k; j++)        \\n\\t\\t\\tif(i + j < nums.size())\\n\\t\\t\\t\\tans = max(ans, nums[i] + solve(nums, dp, k, i + j));\\n\\t\\treturn dp[i] = ans;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        vector<int>dp(nums.size(),INT_MIN);\\n        dp[0] = nums[0];\\n        for(int i=1; i<nums.size(); i++){\\n            for(int j=1; j<=k && i-j >=0; j++){\\n                dp[i] = max(dp[i], nums[i] + dp[i-j]);\\n            }\\n        }\\n        return dp[nums.size()-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        vector<int>dp(nums.size(),INT_MIN);\\n        dp[0] = nums[0];\\n        priority_queue<pair<int,int>>pq;\\n        pq.push({dp[0],0});\\n        for(int i=1; i<nums.size(); i++){\\n            while(pq.size() && i-pq.top().second >k){\\n                pq.pop();\\n            }\\n            auto top = pq.top();\\n            dp[i] = max(dp[i], nums[i] + dp[top.second]);\\n            pq.push({dp[i],i});\\n        }\\n        return dp[nums.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261755,
                "title": "jump-game-vi-js-python-java-c-easy-dp-deque-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nFor this problem, we can see that there are many possible paths from one end of **nums** to the other, but that they cross back over each other countless times. There may be multiple ways to get to a given element in the middle of **nums**, but there should only be one best way to get from there to the end of **nums**.\\n\\nWhen we find ourselves potentially solving the same subproblem over and over again, it\\'s time for a **dynamic programming** (**DP**) approach. In a normal DP approach, we would create a DP array to store the best solution from each element to the end, but since we\\'re only going to be iterating through **nums** once, we can use an **in-place DP** approach and modify the elements of **nums** as we iterate through.\\n\\n_(**Note**: If you choose not to modify your inputs, you can make a separate DP array to store these values. This will increase the **space complexity** to **O(N)**.)_\\n\\nNow, if we consider being located at a particular element in **nums**, and all the elements ahead of us having been modified to equal the best value to the end of **nums**, then the best value for the current location will be its own value plus the best value it can reach in a jump of up to **k** distance.\\n\\nOne option here would be to use a **priority queue** to keep track of the best results ahead, then we could just take the top value in the priority queue (while remembering to first remove any entries that are farther than **k** distance away). But a priority queue isn\\'t terribly efficient for our purposes.\\n\\nInstead, we can use a **double-ended queue** (**deq**) to good effect here. Since we\\'ll need to remove elements from the front end of **deq** if they\\'re outside the jump window, we should use indexes for the **deq** entries.\\n\\nWhen we go to push an index onto **deq**, we should consider that any indexes at the end of **deq** which represent lower values will never be used, as they will always be surpassed by the newer value until they fall outside the jump window. Before pushing the new index onto **deq** then, we should remove from the end of **deq** any indexes representing lower values.\\n\\nThis consequently means that **deq** will always be sorted from high to low values, which is precisely what we wanted. At every iteration (**i**) then, after removing out-of-window indexes, the top entry will represent the value we want to add to **nums[i]** to equal the best result from **i** to the end of **nums**.\\n\\nWe can continue this iteration down to **i = 0**, then **return nums[0]** as the finished result.\\n\\n - _**Time Complexity: O(N)** where **N** is the length of **nums**_\\n - _**Space Complexity: O(K)** for **deq**_\\n   - _or **O(N)** if we use a separate DP array rather than modifying **nums**_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor Java, the **ArrayDeque()** implementation is much slower than using an **int array** with the same length as **nums** and then using a **sliding window** with pointers (**a, b**) to represent the current first and last element of **deq**. This will push the **space complexity** to **O(N)**.\\n\\nThe same applies to C++ and their implementation of **deque()**, though to a lesser degree.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **92ms / 48.6MB** (beats 100% / 100%).\\n```javascript\\nvar maxResult = function(nums, k) {\\n   let n = nums.length, deq = [n-1]\\n    for (let i = n - 2; ~i; i--) {\\n        if (deq[0] - i > k) deq.shift()\\n        nums[i] += nums[deq[0]]\\n        while (deq.length && nums[deq[deq.length-1]] <= nums[i]) deq.pop()\\n        deq.push(i)\\n    }\\n    return nums[0] \\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **952ms / 28.0MB** (beats 96% / 85%).\\n```python\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        deq = deque([n-1])\\n        for i in range(n-2, -1, -1):\\n            if deq[0] - i > k: deq.popleft()\\n            nums[i] += nums[deq[0]]\\n            while len(deq) and nums[deq[-1]] <= nums[i]: deq.pop()\\n            deq.append(i)\\n        return nums[0]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **5ms / 53.2MB** (beats 100% / 85%).\\n```java\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        int n = nums.length, a = 0, b = 0;\\n        int[] deq = new int[n];\\n        deq[0] = n - 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (deq[a] - i > k) a++;\\n            nums[i] += nums[deq[a]];\\n            while (b >= a && nums[deq[b]] <= nums[i]) b--;\\n            deq[++b] = i;\\n        }\\n        return nums[0];\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **120ms / 76.8MB** (beats 99% / 100%).\\n```c++\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size(), a = 0, b = 0;\\n        int deq[n];\\n        deq[0] = n - 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (deq[a] - i > k) a++;\\n            nums[i] += nums[deq[a]];\\n            while (b >= a && nums[deq[b]] <= nums[i]) b--;\\n            deq[++b] = i;\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar maxResult = function(nums, k) {\\n   let n = nums.length, deq = [n-1]\\n    for (let i = n - 2; ~i; i--) {\\n        if (deq[0] - i > k) deq.shift()\\n        nums[i] += nums[deq[0]]\\n        while (deq.length && nums[deq[deq.length-1]] <= nums[i]) deq.pop()\\n        deq.push(i)\\n    }\\n    return nums[0] \\n};\\n```\n```python\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        deq = deque([n-1])\\n        for i in range(n-2, -1, -1):\\n            if deq[0] - i > k: deq.popleft()\\n            nums[i] += nums[deq[0]]\\n            while len(deq) and nums[deq[-1]] <= nums[i]: deq.pop()\\n            deq.append(i)\\n        return nums[0]\\n```\n```java\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        int n = nums.length, a = 0, b = 0;\\n        int[] deq = new int[n];\\n        deq[0] = n - 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (deq[a] - i > k) a++;\\n            nums[i] += nums[deq[a]];\\n            while (b >= a && nums[deq[b]] <= nums[i]) b--;\\n            deq[++b] = i;\\n        }\\n        return nums[0];\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size(), a = 0, b = 0;\\n        int deq[n];\\n        deq[0] = n - 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (deq[a] - i > k) a++;\\n            nums[i] += nums[deq[a]];\\n            while (b >= a && nums[deq[b]] <= nums[i]) b--;\\n            deq[++b] = i;\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257293,
                "title": "java-recursive-memoized-tabulated-optimized-dp",
                "content": "__RECURSIVE APROACH__\\nThrows TLE.\\n```\\nclass Solution {\\n    \\n    private int MIN = Integer.MIN_VALUE / 2;\\n    \\n    public int maxResult(int[] nums, int k) {\\n        return solve(nums, k, 0, dp);\\n    }\\n    \\n    private int solve(int[] nums, int k, int index){\\n        \\n        if(index >= nums.length) return 0;\\n        if(index == nums.length - 1) return nums[index];\\n        int maximumScore = MIN;\\n        \\n        for(int i = index + 1; i <= Math.min(nums.length - 1, index + k); i++)\\n            maximumScore = Math.max(maximumScore, solve(nums, k, i) + nums[index]);\\n        \\n        return maximumScore;\\n    }\\n}\\n```\\n\\n__MEMOIZED APROACH__\\nThrows TLE.\\n```\\nclass Solution {\\n    \\n    private int MIN = Integer.MIN_VALUE / 2;\\n    \\n    public int maxResult(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        Arrays.fill(dp, MIN);\\n        return solve(nums, k, 0, dp);\\n    }\\n    \\n    private int solve(int[] nums, int k, int index, int[] dp){\\n        \\n        if(index >= nums.length) return 0;\\n        if(index == nums.length - 1) return nums[index];\\n        \\n        if(dp[index] != MIN) return dp[index];\\n        int maximumScore = MIN;\\n        \\n\\n        for(int i = index + 1; i <= Math.min(nums.length - 1, index + k); i++)\\n            maximumScore = Math.max(maximumScore, solve(nums, k, i, dp) + nums[index]);\\n        \\n        return dp[index] = maximumScore;\\n    }\\n}\\n```\\n\\n\\n__TABULATED APROACH__\\nThrows TLE.\\n```\\nclass Solution {\\n    \\n    private int MIN = Integer.MIN_VALUE / 2;\\n    \\n    public int maxResult(int[] nums, int k) {\\n        \\n        int n = nums.length;\\n        int[] dp = new int[nums.length];\\n        \\n        dp[n - 1] = nums[n - 1];\\n        \\n        for(int index = n - 2; index >= 0; index--){\\n            int maximumScore = MIN;\\n\\n            for(int i = index + 1; i <= Math.min(n - 1, index + k); i++)\\n                maximumScore = Math.max(maximumScore, dp[i] + nums[index]);\\n\\n            dp[index] = maximumScore;\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```\\n\\n\\n__OPTIMIZEDAPROACH__ \\uD83E\\uDEE1\\n```\\nclass Solution {\\n    \\n    public int maxResult(int[] nums, int k) {\\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)-> b[0]-a[0]);\\n        pq.add(new int[]{nums[nums.length-1], nums.length-1});\\n        \\n\\n        for(int i = nums.length-2; i > 0; i--){\\n\\n            while(pq.peek()[1] > i+k){\\n                pq.remove();\\n            }\\n\\n            int nextMax = pq.peek()[0];\\n            pq.add(new int[]{nextMax+nums[i], i});\\n        }\\n        \\n\\n        while(pq.peek()[1] > k){\\n            pq.remove();\\n        }\\n\\n        return pq.peek()[0]+nums[0];\\n    }\\n}\\n```\\n\\n__Feel free to connect, comment and criticize__ \\uD83E\\uDEE1\\nauthor : [@bharathkalyans](https://leetcode.com/bharathkalyans/)\\nlinkedin : [@bharathkalyans](https://www.linkedin.com/in/bharathkalyans/)\\ntwitter : [@bharathkalyans](https://twitter.com/bharathkalyans)\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int MIN = Integer.MIN_VALUE / 2;\\n    \\n    public int maxResult(int[] nums, int k) {\\n        return solve(nums, k, 0, dp);\\n    }\\n    \\n    private int solve(int[] nums, int k, int index){\\n        \\n        if(index >= nums.length) return 0;\\n        if(index == nums.length - 1) return nums[index];\\n        int maximumScore = MIN;\\n        \\n        for(int i = index + 1; i <= Math.min(nums.length - 1, index + k); i++)\\n            maximumScore = Math.max(maximumScore, solve(nums, k, i) + nums[index]);\\n        \\n        return maximumScore;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    private int MIN = Integer.MIN_VALUE / 2;\\n    \\n    public int maxResult(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        Arrays.fill(dp, MIN);\\n        return solve(nums, k, 0, dp);\\n    }\\n    \\n    private int solve(int[] nums, int k, int index, int[] dp){\\n        \\n        if(index >= nums.length) return 0;\\n        if(index == nums.length - 1) return nums[index];\\n        \\n        if(dp[index] != MIN) return dp[index];\\n        int maximumScore = MIN;\\n        \\n\\n        for(int i = index + 1; i <= Math.min(nums.length - 1, index + k); i++)\\n            maximumScore = Math.max(maximumScore, solve(nums, k, i, dp) + nums[index]);\\n        \\n        return dp[index] = maximumScore;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    private int MIN = Integer.MIN_VALUE / 2;\\n    \\n    public int maxResult(int[] nums, int k) {\\n        \\n        int n = nums.length;\\n        int[] dp = new int[nums.length];\\n        \\n        dp[n - 1] = nums[n - 1];\\n        \\n        for(int index = n - 2; index >= 0; index--){\\n            int maximumScore = MIN;\\n\\n            for(int i = index + 1; i <= Math.min(n - 1, index + k); i++)\\n                maximumScore = Math.max(maximumScore, dp[i] + nums[index]);\\n\\n            dp[index] = maximumScore;\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public int maxResult(int[] nums, int k) {\\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)-> b[0]-a[0]);\\n        pq.add(new int[]{nums[nums.length-1], nums.length-1});\\n        \\n\\n        for(int i = nums.length-2; i > 0; i--){\\n\\n            while(pq.peek()[1] > i+k){\\n                pq.remove();\\n            }\\n\\n            int nextMax = pq.peek()[0];\\n            pq.add(new int[]{nextMax+nums[i], i});\\n        }\\n        \\n\\n        while(pq.peek()[1] > k){\\n            pq.remove();\\n        }\\n\\n        return pq.peek()[0]+nums[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980737,
                "title": "python-dp-deque-simple-code-faster-than-100",
                "content": "```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        deq = deque()\\n        deq.append(0)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            dp[i] = nums[i] + dp[deq[0]]     #Maximum Value in deque within that window\\n            if deq[0] < i - k + 1:\\n                deq.popleft()                #Check whether left bound is still accessible or not\\n            while deq and dp[deq[-1]] < dp[i]:         \\n                deq.pop()                    #Update deque with current i\\'th element\\n            deq.append(i)\\n        return dp[-1]                        #Return total score\\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(n)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        deq = deque()\\n        deq.append(0)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            dp[i] = nums[i] + dp[deq[0]]     #Maximum Value in deque within that window\\n            if deq[0] < i - k + 1:\\n                deq.popleft()                #Check whether left bound is still accessible or not\\n            while deq and dp[deq[-1]] < dp[i]:         \\n                deq.pop()                    #Update deque with current i\\'th element\\n            deq.append(i)\\n        return dp[-1]                        #Return total score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982147,
                "title": "6-short-lines-with-initialization-trick-python",
                "content": "Edit: Solution based on [ye15\\'s](https://leetcode.com/problems/jump-game-vi/discuss/978563/Python3-range-max-via-priority-queue-and-mono-queue), using my trick described below. Got \"828 ms, faster than 57.87%\" despite the O(n log n) time. This keeps previous sums in a max-heap, with the max sum on top, but discards the max sum if it\\'s too old.\\n```\\ndef maxResult(self, A, k):\\n    pq = [(0, -k)]\\n    for i, a in enumerate(A):\\n        while i - pq[0][1] > k: heappop(pq)\\n        a -= pq[0][0]\\n        heappush(pq, (-a, i))\\n    return a\\n```\\nMy original:\\n\\nBasically the same as apparently most others, but with a little trick to avoid special-casing inside the loop. Time is O(n), space is O(k), and we don\\'t modify the input.\\n\\nKeep a log of the last up to k spots, for each spot remember its max sum until that spot and its index. If the oldest logged spot is too far away from the current spot, then remove it. If spots in the log don\\'t have higher sums than the current spot, they become useless and we remove them. This leads to the log being strictly decreasing by sum. So we find the largest sum in the log at log[0] and use that to compute the current spot\\'s max sum. And we find the smallest sum in the log at log[-1], making it easy to drop those that now become useless.\\n\\nPretend that we really start on a spot with sum 0 at index -k, this way that log entry gets used for the first real spot at index 0 but not for later ones. That means we don\\'t need to check inside the loop whether we *have* an oldest log entry that we might need to remove (as our log is never empty) or whether we\\'re at index 0 (it\\'s treated the same as all others) and we don\\'t modify the input (which would be kinda unclean, though the LC judge doesn\\'t mind).\\n\\n```\\ndef maxResult(self, A, k):\\n    log = deque([(0, -k)])                  # pretend we had sum 0 at index -k\\n    for i, a in enumerate(A):\\n        if i - log[0][1] > k:               # remove oldest entry if too far away\\n            log.popleft()\\n        a += log[0][0]                      # max sum for the current spot\\n        while log and log[-1][0] <= a:      # remove entries that are now useless\\n            log.pop()\\n        log.append((a, i))                  # log the current spot\\n    return a\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef maxResult(self, A, k):\\n    pq = [(0, -k)]\\n    for i, a in enumerate(A):\\n        while i - pq[0][1] > k: heappop(pq)\\n        a -= pq[0][0]\\n        heappush(pq, (-a, i))\\n    return a\\n```\n```\\ndef maxResult(self, A, k):\\n    log = deque([(0, -k)])                  # pretend we had sum 0 at index -k\\n    for i, a in enumerate(A):\\n        if i - log[0][1] > k:               # remove oldest entry if too far away\\n            log.popleft()\\n        a += log[0][0]                      # max sum for the current spot\\n        while log and log[-1][0] <= a:      # remove entries that are now useless\\n            log.pop()\\n        log.append((a, i))                  # log the current spot\\n    return a\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2257034,
                "title": "dynamic-programming-deque-o-n-time-c",
                "content": "*Apply dynamic programming and use a deque to store the max element at front maintaining a decreasing deque.*\\n\\n* Traverse ` nums` from right to left filling ` dp` vector where every `dp[i]` store the maximum **score** we get if we step on `i` .\\n* Now , for every i we need the maximum score on the right in range `[i+1,i+k]`.For that we can maintain a decreasing deque to get the max in **O(n)**\\n* **Reccurence Relation** : `dp[i] = nums[i]+max({dp[i+1]+dp[i+2]+. . .+dp[i+m]}) where m<=k && m<n`\\n```\\n        int n = nums.size();\\n        vector<int> dp(nums.size(),0);\\n        dp[n-1]=nums[n-1];\\n        \\n        deque<int> dq;\\n        dq.push_back(n-1);\\n      \\n        for(int i=n-2;i>=0;i--){\\n          \\n            int a = nums[i];\\n            \\n            while(dq.size() && dq.front()>i+k){    //  take out indices until we find front less than i+k\\n              dq.pop_front();\\n            }\\n            \\n            int next  = dp[dq.front()];\\n            dp[i] = a+next;\\n           \\n            while(dq.size() && dp[dq.back()]< dp[i]){       // if dp[i] is greater than back then pop back because we want to keep max element at front\\n              dq.pop_back();\\n            } \\n            \\n            dq.push_back(i); \\n            \\n        }\\n        \\n        return dp[0];\\n```\\n**Time Complexity : O(n)\\nSpace Complexity : O(n)**",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\n        int n = nums.size();\\n        vector<int> dp(nums.size(),0);\\n        dp[n-1]=nums[n-1];\\n        \\n        deque<int> dq;\\n        dq.push_back(n-1);\\n      \\n        for(int i=n-2;i>=0;i--){\\n          \\n            int a = nums[i];\\n            \\n            while(dq.size() && dq.front()>i+k){    //  take out indices until we find front less than i+k\\n              dq.pop_front();\\n            }\\n            \\n            int next  = dp[dq.front()];\\n            dp[i] = a+next;\\n           \\n            while(dq.size() && dp[dq.back()]< dp[i]){       // if dp[i] is greater than back then pop back because we want to keep max element at front\\n              dq.pop_back();\\n            } \\n            \\n            dq.push_back(i); \\n            \\n        }\\n        \\n        return dp[0];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1631872,
                "title": "dp-with-monotonic-queue-with-explanation",
                "content": "It\\'s one of those, code is so small and compact, but it is combining quite a few concepts.\\nYou need to know forward dp, and you need to optimize that forward dp with monotonic queue.\\n\\nInitial idea would be the forward dp with nested loop.\\nThe issue is n, k both lie in 10^5 range, or in other words, O(n^2) is TLE as it would be 10^10, and 10^5 requires O(nlgn) or better.\\n\\nThe writeup will focus on the optimization, I know a lot of people might even struggle with the dp, but that part is obvious if you understand dp a little.\\n\\nNow problem is when we are at any index we need to check all index in range k to find the correct answer, but what if we could just look up which element has the best result in that range in O(1).\\n```\\ndp[i] = nums[i] + dp[dq.front()];\\n```\\n\\nThat is what a monotonic queue will give us, at front of the queue we have the best element in range (i, i + k]\\nWe check where current best will lie in the queue, by checking it against the worst and removing elements until it is as it\\'s right place.\\n```\\nwhile(!dq.empty() && dp[dq.back()] < dp[i]) {\\n\\tdq.pop_back();\\n}\\ndq.push_back(i);\\n```\\n If you want to know why from the back and not front, the answer is simple, we would like to keep the front best, and if current is worse than front, there is no way to find the right place to insert it (a binary search tree/ heap however can be used instead), but by doing it from the back, we make sure that a fresh element is added to the search space and we know for a fact now that all elements it disregards are useless from this point forward.\\n\\nBut before adding the best, we need to have a check that the front of queue is not outside range, if it is we remove that element.\\n```\\nif(dq.front() - i > k) {\\n\\tdq.pop_front();\\n}\\n```\\nAnd if you want to know why no while loop is required, the reason is since we check it each time, it is not possible to have any element at front that violates this condition (except maybe this one).\\n\\nAs for why the queue will not cause TLE, the reason is simply this: each element is added only once, and removed only once, so the operations related to deque will take O(n) time throught out it\\'s existence at worst.\\n\\nSo time complexity is O(n + n) with space of O(n + k);\\n```\\nint maxResult(vector<int>& nums, int k) {\\n    deque<int> dq;\\n    int n = nums.size();\\n    vector<int> dp(n);\\n    dp[n - 1] = nums[n - 1];\\n    dq.push_back(n - 1);\\n    for(int i = n - 2; i >= 0; i--) {\\n        if(dq.front() - i > k) {\\n            dq.pop_front();\\n        }\\n        dp[i] = nums[i] + dp[dq.front()];\\n        while(!dq.empty() && dp[dq.back()] < dp[i]) {\\n            dq.pop_back();\\n        }\\n        dq.push_back(i);\\n    }\\n    return dp[0];\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Monotonic Queue"
                ],
                "code": "```\\ndp[i] = nums[i] + dp[dq.front()];\\n```\n```\\nwhile(!dq.empty() && dp[dq.back()] < dp[i]) {\\n\\tdq.pop_back();\\n}\\ndq.push_back(i);\\n```\n```\\nif(dq.front() - i > k) {\\n\\tdq.pop_front();\\n}\\n```\n```\\nint maxResult(vector<int>& nums, int k) {\\n    deque<int> dq;\\n    int n = nums.size();\\n    vector<int> dp(n);\\n    dp[n - 1] = nums[n - 1];\\n    dq.push_back(n - 1);\\n    for(int i = n - 2; i >= 0; i--) {\\n        if(dq.front() - i > k) {\\n            dq.pop_front();\\n        }\\n        dp[i] = nums[i] + dp[dq.front()];\\n        while(!dq.empty() && dp[dq.back()] < dp[i]) {\\n            dq.pop_back();\\n        }\\n        dq.push_back(i);\\n    }\\n    return dp[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 978675,
                "title": "c-easy-understanding-o-n-solution-with-monotonic-queue",
                "content": "Maintain a Monotonic queue with index greater or equal than i - k.\\n\\nwhen index = i, the maximum path sum between [i - k, i - 1] is in front of the queue.\\n\\ntime complexity: O(n)\\n\\n```cpp\\nint maxResult(vector<int>& nums, int k) {\\n\\tint n = nums.size();\\n\\n\\tdeque<pair<int, int>> q; // <index, max_path_sum>\\n\\tq.push_back({0, nums[0]});\\n\\n\\tfor (int i = 1; i < n; ++i) {\\n\\t\\tint cur = nums[i] + q.front().second;\\n\\t\\twhile (!q.empty() && cur >= q.back().second)\\n\\t\\t\\tq.pop_back();\\n\\t\\tq.push_back({i, cur});\\n\\t\\t\\n\\t\\tif (q.front().first <= i - k)\\n\\t\\t\\tq.pop_front();\\n\\t}\\n\\n\\treturn q.back().second;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```cpp\\nint maxResult(vector<int>& nums, int k) {\\n\\tint n = nums.size();\\n\\n\\tdeque<pair<int, int>> q; // <index, max_path_sum>\\n\\tq.push_back({0, nums[0]});\\n\\n\\tfor (int i = 1; i < n; ++i) {\\n\\t\\tint cur = nums[i] + q.front().second;\\n\\t\\twhile (!q.empty() && cur >= q.back().second)\\n\\t\\t\\tq.pop_back();\\n\\t\\tq.push_back({i, cur});\\n\\t\\t\\n\\t\\tif (q.front().first <= i - k)\\n\\t\\t\\tq.pop_front();\\n\\t}\\n\\n\\treturn q.back().second;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2258517,
                "title": "python-solution-dp-heap-with-explanation",
                "content": "This problem is **DP, Dynamic programming** problem. \\n\\nWe get answer of bigger solution from smaller solution in dynamic programming due to its 1. overlapping subproblem and 2. optimal substructure features.\\n\\nWhy this is DP problem?\\n\\nLet\\'s say we are now at index `i`. And assume that we know the maximum score we\\'ve got is `D[i]`. \\n\\n**D[i] : maximum score we\\'ve got by jumping from index `0` to index `i`.**\\n\\nThen we can get answers in later indexes(bigger problem, `D[i+1]`, `D[i+2]`, ..., `D[i+k]`) that we jump from index `i` using `D[i]`, and they are not affected by answers before index `i`. \\n\\n<img width=\"366\" alt=\"image\" src=\"https://user-images.githubusercontent.com/41438361/178104493-80e6303f-7426-486a-b5c3-f930ca329667.png\">\\n\\nSo this problem is using the answer of smaller problem to get bigger problem, and answer\\'s of problem can be reused.\\n\\nIf we know `D[i]`, we can get maximum score of \\n\\n```\\n1. `D[i+1]` (jump 1 step forward), D[i] + nums[i+1]\\n2. `D[i+2]` (jump 2 steps forward), D[i] + nums[i+2]\\n ...\\nk. `D[i+k]` (jump k steps forward), D[i] + nums[i+k]\\n```\\n\\nIn other words, to get `D[i]`:\\n\\n```\\n1. get maximum of ( D[i-1], D[i-2], ..., D[i-k] )\\n2. add nums[i] cause we are now at index i.\\n```\\n\\n**First approach, got TLE**\\n\\n```python\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        D = [-float(\\'inf\\')] * (n)\\n        \\n\\t\\t# set initial value\\n        D[0] = nums[0]\\n        \\n        for i in range(1, n):\\n            maxValue = -float(\\'inf\\')\\n            \\n\\t\\t\\t# get max score from D[i-1], D[i-2], .., D[i-k]\\n            for j in range(1, k+1):\\n                if i-j < 0: continue\\n                maxValue = max(maxValue, D[i-j])\\n            \\n\\t\\t\\t# add score of current index to maximum score we\\'ve got\\n            D[i] = maxValue + nums[i]\\n        \\n        return D[n-1]\\n```\\n\\nBut time complexity is `O(nk)` so I got TLE.\\n\\nTo improve time complexity, we can use heap to get maximum score of `D[i-1], D[i-2], .., D[i-k]`.\\n\\n<img width=\"436\" alt=\"image\" src=\"https://user-images.githubusercontent.com/41438361/178105181-4deae7da-07be-4777-acf3-e051641e7736.png\">\\n\\nInstead of comparing all k steps in every index, we can directly get maximum value from max heap by just poping.\\n\\n**Second approach, passed**\\n\\n```python\\nimport heapq\\n\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        D = [-float(\\'inf\\')] * (n)\\n        # stores (D[index], index), max heap\\n        heap = [(-nums[0], 0)]\\n        \\n        D[0] = nums[0]\\n        \\n        for i in range(1, n):\\n            # get max D value from before k steps\\n            (maxValue, index) = heap[0]\\n            \\n            # if maxValue is from many steps before(index we can\\'t jump from), abandon it\\n\\t\\t\\t# O(logN)\\n            while index < i - k:\\n                heapq.heappop(heap)\\n                (maxValue, index) = heap[0]\\n            \\n            D[i] = -maxValue + nums[i]\\n\\t\\t\\t# O(logN)\\n            heapq.heappush(heap, (-D[i], i))\\n\\n        return D[n-1]\\n```\\n\\ntime complexity : `O(nlogn)`",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n1. `D[i+1]` (jump 1 step forward), D[i] + nums[i+1]\\n2. `D[i+2]` (jump 2 steps forward), D[i] + nums[i+2]\\n ...\\nk. `D[i+k]` (jump k steps forward), D[i] + nums[i+k]\\n```\n```\\n1. get maximum of ( D[i-1], D[i-2], ..., D[i-k] )\\n2. add nums[i] cause we are now at index i.\\n```\n```python\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        D = [-float(\\'inf\\')] * (n)\\n        \\n\\t\\t# set initial value\\n        D[0] = nums[0]\\n        \\n        for i in range(1, n):\\n            maxValue = -float(\\'inf\\')\\n            \\n\\t\\t\\t# get max score from D[i-1], D[i-2], .., D[i-k]\\n            for j in range(1, k+1):\\n                if i-j < 0: continue\\n                maxValue = max(maxValue, D[i-j])\\n            \\n\\t\\t\\t# add score of current index to maximum score we\\'ve got\\n            D[i] = maxValue + nums[i]\\n        \\n        return D[n-1]\\n```\n```python\\nimport heapq\\n\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        D = [-float(\\'inf\\')] * (n)\\n        # stores (D[index], index), max heap\\n        heap = [(-nums[0], 0)]\\n        \\n        D[0] = nums[0]\\n        \\n        for i in range(1, n):\\n            # get max D value from before k steps\\n            (maxValue, index) = heap[0]\\n            \\n            # if maxValue is from many steps before(index we can\\'t jump from), abandon it\\n\\t\\t\\t# O(logN)\\n            while index < i - k:\\n                heapq.heappop(heap)\\n                (maxValue, index) = heap[0]\\n            \\n            D[i] = -maxValue + nums[i]\\n\\t\\t\\t# O(logN)\\n            heapq.heappush(heap, (-D[i], i))\\n\\n        return D[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261207,
                "title": "dry-run-picture-dp-with-explanation-c-deque-priorityqueue",
                "content": "**Dp Explanation:**\\n\\n![image](https://assets.leetcode.com/users/images/0ac678fe-2b13-44d4-ad80-2dee25901f2e_1623236718.3317683.png)\\n![image](https://assets.leetcode.com/users/images/7f50090b-2388-4acc-8a47-ac41519a870c_1623236728.5779495.png)\\n\\n\\n**Using Priority Queue (Time-O(nlogn),Space-O(n)):**\\n\\n**Dry-Run:**\\n![image](https://assets.leetcode.com/users/images/64e74905-957e-4117-8883-103a25b28a29_1623236748.1103823.png)\\n![image](https://assets.leetcode.com/users/images/e890c423-d86d-489f-93a4-24ec5b59e9ed_1623236755.9492424.png)\\n\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        \\n         priority_queue<pair<int,int>> pq;      \\n         vector<int> dp(nums.size(),0);\\n\\t\\t \\n         for(int i=0;i<nums.size();i++)\\n         {\\n             while(!pq.empty() && pq.top().second<i-k)\\n                 pq.pop();\\n             \\n             dp[i]=nums[i]+(pq.empty()?0:pq.top().first);\\n             pq.push({dp[i],i});\\n         }\\n         return dp[nums.size()-1];\\n               \\n    }\\n};\\n```\\n\\n**Using Deque(Time-O(n),Space-O(k)):**\\n\\n**Dry-Run:**\\n![image](https://assets.leetcode.com/users/images/2d1fe1fc-520d-4ed0-8a11-f410228f69c3_1623259146.1608186.png)\\n\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        \\n        deque<pair<int,int>> dq;\\n        int curr=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            curr=nums[i]+(dq.empty()?0:dq.front().second);\\n            \\n            while(!dq.empty() && dq.back().second<curr)\\n                dq.pop_back();\\n            dq.push_back({i,curr});\\n            \\n            if(dq.front().first+k==i)\\n                dq.pop_front();\\n        }\\n        return curr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        \\n         priority_queue<pair<int,int>> pq;      \\n         vector<int> dp(nums.size(),0);\\n\\t\\t \\n         for(int i=0;i<nums.size();i++)\\n         {\\n             while(!pq.empty() && pq.top().second<i-k)\\n                 pq.pop();\\n             \\n             dp[i]=nums[i]+(pq.empty()?0:pq.top().first);\\n             pq.push({dp[i],i});\\n         }\\n         return dp[nums.size()-1];\\n               \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        \\n        deque<pair<int,int>> dq;\\n        int curr=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            curr=nums[i]+(dq.empty()?0:dq.front().second);\\n            \\n            while(!dq.empty() && dq.back().second<curr)\\n                dq.pop_back();\\n            dq.push_back({i,curr});\\n            \\n            if(dq.front().first+k==i)\\n                dq.pop_front();\\n        }\\n        return curr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257235,
                "title": "c-dp-recursive-memoization-tabulation-max-heap",
                "content": "The question states we need to find the maximum score. So the intuitive thinking should be recursion. We try out all the possible paths and find the maximum.\\n\\nRecursive Approach (Brute Force): \\n\\n```\\nint f(int i, vector<int>& nums, int k){\\n\\n        if(i==0)\\n            return nums[0];\\n\\t\\t\\t\\n        if(i<0)\\n            return -1e9;\\n        \\n        int maxi=-1e9;\\n        \\n        for(int step =1; step<=k; step++){\\n            maxi=max(maxi,nums[i]+f(i-step,nums,k));\\n        }\\n        return maxi;\\n  }\\n    \\n    int maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>dp(n,-1);\\n        return f(n-1,nums,k);\\n    }\\n```\\n**TC:** exponential\\n*TLE*\\n\\n************************************************\\n\\nRecursive Approach With Simple Memoization:\\n\\n\\n```\\nint f(int i, vector<int>& nums, int k,vector<int>& dp){\\nif(i==0)\\n\\treturn nums[0];\\n\\nif(dp[i]!=-1e9) return dp[i];\\n\\nint maxi=-1e9;\\n\\nfor(int step =1; step<=k; step++){\\n\\tif(i-step>=0)\\n\\tmaxi=max(maxi,nums[i]+f(i-step,nums,k,dp));\\n}\\nreturn dp[i]=maxi;\\n}\\n\\nint maxResult(vector<int>& nums, int k) {\\nint n=nums.size();\\nvector<int>dp(n,-1e9);\\nf(n-1,nums,k,dp);\\nreturn dp[n-1];\\n}\\n```\\n**TC:** O(nk)\\n**SC:** O(n)+O(n)\\n*TLE*\\n\\n************************************************\\n\\nTabulation\\n```\\nint maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>dp(n,-1e9);\\n        \\n        dp[0]=nums[0];\\n        \\n        for(int i=1; i<n; i++){\\n            int maxi=-1e9;\\n            for(int step=1; step<=k; step++){\\n                if(i-step>=0)\\n                    maxi=max(maxi,nums[i]+dp[i-step]);\\n            }\\n            dp[i]=maxi;\\n        }\\n        return dp[n-1];\\n    }\\n```\\n**TC:** O(nk)\\n**SC:** O(n)\\n*TLE*\\n************************************************\\n\\nOptimization using Max Heap:\\n\\n  ```\\nint maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>dp(n,0);\\n        \\n        priority_queue<pair<int,int>>pq;\\n        \\n        for(int i=n-1; i>=0; i--){\\n            while(pq.size()&&pq.top().second>i+k)\\n                pq.pop();\\n            \\n            dp[i]=dp[i]+nums[i]+(pq.size()?pq.top().first:0);\\n            pq.push({dp[i],i});\\n        }\\n        return dp[0];\\n    }\\n```\\n**TC:** O(nlogk)\\n**SC:** O(n)\\n*Accept*\\n\\n\\n\\n\\n\\t\\n\\t\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint f(int i, vector<int>& nums, int k){\\n\\n        if(i==0)\\n            return nums[0];\\n\\t\\t\\t\\n        if(i<0)\\n            return -1e9;\\n        \\n        int maxi=-1e9;\\n        \\n        for(int step =1; step<=k; step++){\\n            maxi=max(maxi,nums[i]+f(i-step,nums,k));\\n        }\\n        return maxi;\\n  }\\n    \\n    int maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>dp(n,-1);\\n        return f(n-1,nums,k);\\n    }\\n```\n```\\nint f(int i, vector<int>& nums, int k,vector<int>& dp){\\nif(i==0)\\n\\treturn nums[0];\\n\\nif(dp[i]!=-1e9) return dp[i];\\n\\nint maxi=-1e9;\\n\\nfor(int step =1; step<=k; step++){\\n\\tif(i-step>=0)\\n\\tmaxi=max(maxi,nums[i]+f(i-step,nums,k,dp));\\n}\\nreturn dp[i]=maxi;\\n}\\n\\nint maxResult(vector<int>& nums, int k) {\\nint n=nums.size();\\nvector<int>dp(n,-1e9);\\nf(n-1,nums,k,dp);\\nreturn dp[n-1];\\n}\\n```\n```\\nint maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>dp(n,-1e9);\\n        \\n        dp[0]=nums[0];\\n        \\n        for(int i=1; i<n; i++){\\n            int maxi=-1e9;\\n            for(int step=1; step<=k; step++){\\n                if(i-step>=0)\\n                    maxi=max(maxi,nums[i]+dp[i-step]);\\n            }\\n            dp[i]=maxi;\\n        }\\n        return dp[n-1];\\n    }\\n```\n```\\nint maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>dp(n,0);\\n        \\n        priority_queue<pair<int,int>>pq;\\n        \\n        for(int i=n-1; i>=0; i--){\\n            while(pq.size()&&pq.top().second>i+k)\\n                pq.pop();\\n            \\n            dp[i]=dp[i]+nums[i]+(pq.size()?pq.top().first:0);\\n            pq.push({dp[i],i});\\n        }\\n        return dp[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1752467,
                "title": "optimizations-from-brute-force-to-deque-solution-3-approaches-time-o-n-space-o-k",
                "content": "Hey there, In this post i would discuss 3 approaches along with the thought process I followed for the same.\\n**P.S. Do upvote it if you like it.**\\n\\n## Approach1(Using DP):\\n#### Thought-process:\\nAfter reading the problem statement, The first thing which come in my mind is recursion. Reason for the same is see we can go at most k steps forward from any index and similarly those indices can also go at most k times forward **(min(i+k,n-1)).** Due to this we need to perform the same task repetitively.\\nThen i tried to draw the recursive tree of few indices and you would see overlapping calls which led to the idea of dynammic programming. Idea is quite simple.\\n**In my dp array, Each cell denotes the maximum ans which we can get starting from that particular index.**\\n\\nSolution for the same:\\n\\n```\\n int getMaximum(vector<int>& dp,int start,int end){\\n       int maxEle = INT_MIN;\\n        for(int i=start;i<=end;i++)\\n            maxEle = max(maxEle, dp[i]);\\n        return maxEle;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        int i,n=nums.size();\\n        vector<int> dp(n);\\n        //If we start from last then we get same ans\\n        dp[n-1]=nums[n-1];\\n        \\n        for(i=n-2;i>=0;i--)\\n            dp[i]=getMaximum(dp,i+1,min(i+k,n-1))+nums[i];\\n        return dp[0];\\n    }\\n```\\n\\n**Time complexity:** O(n*k)\\n**Space complexity:** O(n) for dp array\\n\\n## Approach2:(Using DP+ Multiset + Sliding window)\\n#### Thought process:\\nSo if you see then in the previous question we were going to k indices forward from each index. Which is causing the time complexity to be O(n*k). But the work there is nothing but to see the maximum element in the next k indices.\\n**So i thought to use Priority queue to keep maximum. But priority queue do not provide the option to delete any particular value(As we will need to delete the element which got out of window).**\\n\\n**After thinking a little bit, i tried to use set which does give us the option but in that duplicates were not allowed and we are keeping values not indices so repetition may be there. For also allowing duplicates I used multiset.**\\n\\n#### Explanation:\\nI used the concept of fixed size sliding window, The reason for the same is for first k elements we just need to put the elements in the multiset. For the rest I need to delete that one which got out of window and put current one.\\n\\n#### Code for the same:\\n```\\nint maxResult(vector<int>& nums, int k) {\\n        int i,j,maxValue,n=nums.size();\\n        vector<int> dp(n);\\n        multiset<int> s;\\n        \\n        dp[n-1]=nums[n-1];\\n        s.insert(nums[n-1]);\\n       \\n        i=n-1;\\n        j=n-2;\\n        while(j>=0){\\n            auto largestEle = s.rbegin();\\n            maxValue = nums[j] + *largestEle;\\n            s.insert(maxValue);\\n            dp[j]=maxValue;\\n            if(i-j+1<=k){\\n                j--;\\n                continue;\\n            }\\n            auto pos = s.find(dp[i]);\\n            s.erase(pos);\\n            i--;\\n            j--;\\n        }\\n        return dp[0];\\n    }\\n\\n```\\n**Time complexity:** O(N*logk), since  multiset will always be of size k and each operation will call logk time and we are calling them for n times.\\n**Space complexity:** O(N +k ) O(N) for dp and O(k) for multiset.\\n\\n## Approach3(Using deque):\\nThis approach is based on the reason that in the prev approach what we were doing were removing element which got out of the window and taking the current one inside. So we are performing operations in both the direction.\\n\\n#### Thought process:\\nWe will maintain the deque such that the first element of the deque will always be the maximum element. In this way we will optimize each operation time complexity from **O(logk) to O(1)**.\\nOne question which comes in mind is How we will be certain that the index which we are using is in the size of k?\\nWhat I did is checked if the difference of the current index and that of deque one is greater than or equal to k then we remove that.\\n\\n#### Code:\\n```\\nint maxResult(vector<int>& nums, int k) {\\n        deque<int> dq;\\n        int i,n=nums.size();\\n        vector<int> dp(n);\\n        \\n        dp[n-1]=nums[n-1];\\n        dq.push_back(n-1);\\n        for(i=n-2;i>=0;i--){\\n            dp[i]=nums[i]+dp[dq.front()];\\n            \\n            while(!dq.empty() && dp[i] >= dp[dq.back()])\\n                dq.pop_back();\\n            dq.push_back(i);\\n            \\n            if(dq.front()-i >= k)\\n                dq.pop_front();\\n        }\\n        return dp[0];\\n    }\\n```\\n\\n**Time complexity:** O(N), since deque operation takes O(1) time.\\n**Space complexity:** O(N+k) O(N) for dp,O(k) for deque.\\n\\n\\nIf there are any suggestions/mistakes in my post, please do comment below.\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\n int getMaximum(vector<int>& dp,int start,int end){\\n       int maxEle = INT_MIN;\\n        for(int i=start;i<=end;i++)\\n            maxEle = max(maxEle, dp[i]);\\n        return maxEle;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        int i,n=nums.size();\\n        vector<int> dp(n);\\n        //If we start from last then we get same ans\\n        dp[n-1]=nums[n-1];\\n        \\n        for(i=n-2;i>=0;i--)\\n            dp[i]=getMaximum(dp,i+1,min(i+k,n-1))+nums[i];\\n        return dp[0];\\n    }\\n```\n```\\nint maxResult(vector<int>& nums, int k) {\\n        int i,j,maxValue,n=nums.size();\\n        vector<int> dp(n);\\n        multiset<int> s;\\n        \\n        dp[n-1]=nums[n-1];\\n        s.insert(nums[n-1]);\\n       \\n        i=n-1;\\n        j=n-2;\\n        while(j>=0){\\n            auto largestEle = s.rbegin();\\n            maxValue = nums[j] + *largestEle;\\n            s.insert(maxValue);\\n            dp[j]=maxValue;\\n            if(i-j+1<=k){\\n                j--;\\n                continue;\\n            }\\n            auto pos = s.find(dp[i]);\\n            s.erase(pos);\\n            i--;\\n            j--;\\n        }\\n        return dp[0];\\n    }\\n\\n```\n```\\nint maxResult(vector<int>& nums, int k) {\\n        deque<int> dq;\\n        int i,n=nums.size();\\n        vector<int> dp(n);\\n        \\n        dp[n-1]=nums[n-1];\\n        dq.push_back(n-1);\\n        for(i=n-2;i>=0;i--){\\n            dp[i]=nums[i]+dp[dq.front()];\\n            \\n            while(!dq.empty() && dp[i] >= dp[dq.back()])\\n                dq.pop_back();\\n            dq.push_back(i);\\n            \\n            if(dq.front()-i >= k)\\n                dq.pop_front();\\n        }\\n        return dp[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1260884,
                "title": "c-dp-multiset-explained",
                "content": "**Explanation**\\n* dp[i] denotes the maximum sum value that can be achieved to reach ith index.\\n\\n* For any index i,  we maintain a multiset which has last k values.\\n\\n* For the the ith index we chose the one which has largest value in multiset and then add nums[i] and insert into set.\\n\\n* If the size of multiset becomes greater than k, we have to remove the (i-k-1)th element, so we cannot directly erase dp[i-k-1], because all the elements having same value will be removed, so we find the iterator to dp[i-k-1] and then erase only 1 occurence of it.\\n   \\n* dp[n-1] is the required answer\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        multiset<int>s;\\n        vector<int>dp(n);\\n        dp[0]=nums[0];\\n        s.insert(dp[0]);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s.size()>k)\\n            {\\n                auto itr = s.find(dp[i-k-1]);\\n                s.erase(itr);\\n            }\\n            auto e=s.rbegin();\\n            dp[i]=nums[i]+*e;\\n            s.insert(dp[i]); \\n        }\\n        return dp[n-1];        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        multiset<int>s;\\n        vector<int>dp(n);\\n        dp[0]=nums[0];\\n        s.insert(dp[0]);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s.size()>k)\\n            {\\n                auto itr = s.find(dp[i-k-1]);\\n                s.erase(itr);\\n            }\\n            auto e=s.rbegin();\\n            dp[i]=nums[i]+*e;\\n            s.insert(dp[i]); \\n        }\\n        return dp[n-1];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992922,
                "title": "java-treeset-priorityqueue-and-deque-approaches",
                "content": "Maximum score at an index ```i``` comes from choosing the maximum of scores at last ```k``` indices.\\nSo the solution goes like this: ```for each index i from 0 to n - 1, score[i] = nums[i] + maximum of last k score values```.\\n\\n**TreeSet**\\n```\\npublic int maxResult(int[] nums, int k) {\\n    int n = nums.length;\\n    if(n == 1) return nums[0];\\n    int[] dist = new int[n];\\n    TreeSet<int[]> set = new TreeSet<>((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n    set.add(new int[] { dist[0] = nums[0], 0 });\\n    for(int i = 1; i < n; i++) {\\n        set.add(new int[] { dist[i] = set.last()[0] + nums[i], i });\\n        if(i - k >= 0) set.remove(new int[] { dist[i - k], i - k });\\n    }\\n    return dist[n - 1];\\n}\\n```\\n\\n**PriorityQueue**\\n\\n```\\npublic int maxResult(int[] nums, int k) {\\n    int n = nums.length, res = nums[0];\\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n    pq.add(new int[] { nums[0], 0 });\\n    for(int i = 1; i < n; i++) {\\n        while(pq.peek()[1] < i - k) pq.poll();\\n        pq.add(new int[] { res = pq.peek()[0] + nums[i], i });\\n    }\\n    return res;\\n}\\n```\\n\\n**Deque**\\n\\nWe use use a deque to calculate [sliding window maximum](https://leetcode.com/problems/sliding-window-maximum/) efficiently.\\n\\n```\\npublic int maxResult(int[] nums, int k) {\\n    Deque<Integer> deque = new ArrayDeque<>();\\n    deque.add(0);\\n    for(int i = 1; i < nums.length; i++) {\\n        nums[i] += nums[deque.peek()];\\n        if(i - k == deque.peek()) deque.poll();\\n        while(!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) deque.pollLast();\\n        deque.add(i);\\n    }\\n    return nums[nums.length - 1];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Queue",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```i```\n```k```\n```for each index i from 0 to n - 1, score[i] = nums[i] + maximum of last k score values```\n```\\npublic int maxResult(int[] nums, int k) {\\n    int n = nums.length;\\n    if(n == 1) return nums[0];\\n    int[] dist = new int[n];\\n    TreeSet<int[]> set = new TreeSet<>((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n    set.add(new int[] { dist[0] = nums[0], 0 });\\n    for(int i = 1; i < n; i++) {\\n        set.add(new int[] { dist[i] = set.last()[0] + nums[i], i });\\n        if(i - k >= 0) set.remove(new int[] { dist[i - k], i - k });\\n    }\\n    return dist[n - 1];\\n}\\n```\n```\\npublic int maxResult(int[] nums, int k) {\\n    int n = nums.length, res = nums[0];\\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n    pq.add(new int[] { nums[0], 0 });\\n    for(int i = 1; i < n; i++) {\\n        while(pq.peek()[1] < i - k) pq.poll();\\n        pq.add(new int[] { res = pq.peek()[0] + nums[i], i });\\n    }\\n    return res;\\n}\\n```\n```\\npublic int maxResult(int[] nums, int k) {\\n    Deque<Integer> deque = new ArrayDeque<>();\\n    deque.add(0);\\n    for(int i = 1; i < nums.length; i++) {\\n        nums[i] += nums[deque.peek()];\\n        if(i - k == deque.peek()) deque.poll();\\n        while(!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) deque.pollLast();\\n        deque.add(i);\\n    }\\n    return nums[nums.length - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 978563,
                "title": "python3-range-max",
                "content": "**Algo**\\nReverse scan `nums` and keep track of the maximum of window length `k` via a priority queue. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        pq = [] # max heap \\n        for i in reversed(range(len(nums))): \\n            while pq and pq[0][1] - i > k: heappop(pq)\\n            ans = nums[i] - pq[0][0] if pq else nums[i]\\n            heappush(pq, (-ans, i))\\n        return ans\\n```\\n\\n**Analysis**\\nTime complexity `O(NlogK)`\\nSpace complexity `O(N)`\\n\\nEdit \\nAdding mono-queue implementation \\n(`O(N)` time & `O(K)` space)\\n```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        queue = deque()\\n        for i in reversed(range(len(nums))): \\n            while queue and queue[0][1] - i > k: queue.popleft()\\n            ans = nums[i]\\n            if queue: ans += queue[0][0]\\n            while queue and queue[-1][0] <= ans: queue.pop()\\n            queue.append((ans, i))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        pq = [] # max heap \\n        for i in reversed(range(len(nums))): \\n            while pq and pq[0][1] - i > k: heappop(pq)\\n            ans = nums[i] - pq[0][0] if pq else nums[i]\\n            heappush(pq, (-ans, i))\\n        return ans\\n```\n```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        queue = deque()\\n        for i in reversed(range(len(nums))): \\n            while queue and queue[0][1] - i > k: queue.popleft()\\n            ans = nums[i]\\n            if queue: ans += queue[0][0]\\n            while queue and queue[-1][0] <= ans: queue.pop()\\n            queue.append((ans, i))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257884,
                "title": "java-o-n-sliding-window-solution-clean-code",
                "content": "```\\nclass Pair<K, V> {\\n    private K key;\\n    private V value;\\n    \\n    public Pair (K key, V value) {\\n        this.key = key;\\n        this.value = value;\\n    }\\n    \\n    public K getKey () {\\n        return key;\\n    }\\n    \\n    public V getValue () {\\n        return value;\\n    }\\n}\\n\\n/*\\n * Alternatively, you might want to use javafx.util.Pair and save yourself the trouble\\n * javafx is not a part of the standard Java SDK \\n*/\\n\\nclass MaxStream<V> {\\n    private int size;\\n    private Comparator<V> comparator;\\n    \\n    private int counter;\\n    private Deque<Pair<Integer, V>> q;\\n    \\n    public MaxStream (int size, Comparator comparator) {\\n        this.size = size;\\n        this.comparator = comparator;\\n        \\n        counter = 0;\\n        q = new ArrayDeque<Pair<Integer, V>>();\\n    }\\n    \\n    public void push (V data) {\\n        Pair<Integer, V> pair = new Pair (counter++, data);\\n        if (!q.isEmpty() && q.peek().getKey() < counter - size)\\n            q.pollFirst ();\\n        \\n        while (!q.isEmpty() && comparator.compare(q.peekLast().getValue(), data) == -1) {\\n            q.pollLast();\\n        }\\n        \\n        q.addLast (pair);\\n    }\\n    \\n    public V poll () {\\n        return q.peekFirst().getValue ();\\n    }\\n}\\n\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        int ans = nums[0];\\n        MaxStream<Integer> ms = new MaxStream<Integer> (k, new Comparator<Integer>() {\\n            @Override \\n            public int compare (Integer i, Integer j) {\\n                return i.compareTo(j);\\n            }\\n        });\\n\\t\\t/*\\n\\t\\t * Alternatively, using a method reference to override and instantiate a functional interface works too\\n\\t\\t * \\n\\t\\t * Comparator<Integer> comparator = Integer::compare;\\n\\t\\t * MaxStream<Integer> ms = new MaxStream<Integer> (k, comparator);\\n\\t\\t*/\\n        \\n        for (int i = 1; i < nums.length; ++i) {\\n\\t\\t\\tms.push(ans);\\n            ans = nums[i] + ms.poll ();\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Pair<K, V> {\\n    private K key;\\n    private V value;\\n    \\n    public Pair (K key, V value) {\\n        this.key = key;\\n        this.value = value;\\n    }\\n    \\n    public K getKey () {\\n        return key;\\n    }\\n    \\n    public V getValue () {\\n        return value;\\n    }\\n}\\n\\n/*\\n * Alternatively, you might want to use javafx.util.Pair and save yourself the trouble\\n * javafx is not a part of the standard Java SDK \\n*/\\n\\nclass MaxStream<V> {\\n    private int size;\\n    private Comparator<V> comparator;\\n    \\n    private int counter;\\n    private Deque<Pair<Integer, V>> q;\\n    \\n    public MaxStream (int size, Comparator comparator) {\\n        this.size = size;\\n        this.comparator = comparator;\\n        \\n        counter = 0;\\n        q = new ArrayDeque<Pair<Integer, V>>();\\n    }\\n    \\n    public void push (V data) {\\n        Pair<Integer, V> pair = new Pair (counter++, data);\\n        if (!q.isEmpty() && q.peek().getKey() < counter - size)\\n            q.pollFirst ();\\n        \\n        while (!q.isEmpty() && comparator.compare(q.peekLast().getValue(), data) == -1) {\\n            q.pollLast();\\n        }\\n        \\n        q.addLast (pair);\\n    }\\n    \\n    public V poll () {\\n        return q.peekFirst().getValue ();\\n    }\\n}\\n\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        int ans = nums[0];\\n        MaxStream<Integer> ms = new MaxStream<Integer> (k, new Comparator<Integer>() {\\n            @Override \\n            public int compare (Integer i, Integer j) {\\n                return i.compareTo(j);\\n            }\\n        });\\n\\t\\t/*\\n\\t\\t * Alternatively, using a method reference to override and instantiate a functional interface works too\\n\\t\\t * \\n\\t\\t * Comparator<Integer> comparator = Integer::compare;\\n\\t\\t * MaxStream<Integer> ms = new MaxStream<Integer> (k, comparator);\\n\\t\\t*/\\n        \\n        for (int i = 1; i < nums.length; ++i) {\\n\\t\\t\\tms.push(ans);\\n            ans = nums[i] + ms.poll ();\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256801,
                "title": "java-90-faster-dp-easy-solution",
                "content": "# Please Upvote if you find it helpful :)\\n```\\nint[] scores = new int[nums.length];\\n        LinkedList<Integer> queue = new LinkedList<>();\\n\\n        // initialization\\n        scores[0] = nums[0];\\n        queue.offer(0);\\n\\n        // function\\n        for (int i = 1 ; i < nums.length ; i++) {\\n            if (queue.getFirst() < i - k) {\\n                queue.removeFirst();\\n            }\\n            scores[i] = scores[queue.getFirst()] + nums[i];\\n\\n            while (!queue.isEmpty() && scores[queue.getLast()] <= scores[i]) {\\n                queue.removeLast();\\n            }\\n            queue.addLast(i);\\n        }\\n\\n        // answer\\n        return scores[nums.length - 1];\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nint[] scores = new int[nums.length];\\n        LinkedList<Integer> queue = new LinkedList<>();\\n\\n        // initialization\\n        scores[0] = nums[0];\\n        queue.offer(0);\\n\\n        // function\\n        for (int i = 1 ; i < nums.length ; i++) {\\n            if (queue.getFirst() < i - k) {\\n                queue.removeFirst();\\n            }\\n            scores[i] = scores[queue.getFirst()] + nums[i];\\n\\n            while (!queue.isEmpty() && scores[queue.getLast()] <= scores[i]) {\\n                queue.removeLast();\\n            }\\n            queue.addLast(i);\\n        }\\n\\n        // answer\\n        return scores[nums.length - 1];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261612,
                "title": "c-all-3-methods-recursion-memoization-dp-multiset",
                "content": "**Recursion [TLE]**\\n```cpp\\nclass Solution {\\npublic:\\n    int maxx;\\n    \\n    void recur(vector<int>& nums, int k, int index, int sum) {\\n        if(nums.size()-1 == index){\\n            // Reached last index\\n            maxx = max(maxx, sum);\\n            return;\\n        }\\n        \\n\\t\\t// Check all the possibilities\\n        for(int i=1; (i<=k && (i+index)<nums.size()); ++i) {\\n            recur(nums, k, i+index, sum+nums[i+index]);\\n        }\\n    }\\n    \\n    int maxResult(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size(), -1);\\n        recur(nums, k, 0, nums[0]);\\n        return maxx;\\n    }\\n};\\n```\\n\\n**Memoization [TLE]**\\n```cpp\\nclass Solution {\\npublic:\\n    int recur(vector<int>& nums, int k, int index, vector<int>& dp) {\\n        if(dp[index] != -1)\\n            return dp[index];\\n        \\n        if(index == nums.size()-1) {\\n            dp[index] = nums[index];\\n            return dp[index];\\n        }\\n        \\n        int max_so_far = INT_MIN;\\n        \\n        for(int i=1; (i<=k && (i+index)<nums.size()); ++i) {\\n            max_so_far = max(max_so_far, recur(nums, k, i+index, dp));\\n        }\\n        \\n        dp[index] = max_so_far + nums[index];\\n        \\n        return dp[index];\\n    }\\n    \\n    int maxResult(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size(), -1);\\n        return recur(nums, k, 0, dp);\\n    }\\n};\\n```\\n\\n**DP + Multiset [All test cases passed]**\\n```cpp\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int len = nums.size();\\n        vector<int> dp(nums.size(), -1);\\n        \\n        dp[len-1] = nums[len-1];\\n        multiset<int> ms;\\n        ms.insert(dp[len-1]);\\n        \\n        for(int i=len-2;i>=0; --i) {\\n\\t\\t\\t// Erase the oldest value i.e. the one which was inserted the earliest => i+k+1\\n            if(ms.size() > k) {\\n                ms.erase(ms.find(dp[i+k+1]));\\n            }\\n            dp[i] = *ms.rbegin()+nums[i];\\n            ms.insert(dp[i]);\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxx;\\n    \\n    void recur(vector<int>& nums, int k, int index, int sum) {\\n        if(nums.size()-1 == index){\\n            // Reached last index\\n            maxx = max(maxx, sum);\\n            return;\\n        }\\n        \\n\\t\\t// Check all the possibilities\\n        for(int i=1; (i<=k && (i+index)<nums.size()); ++i) {\\n            recur(nums, k, i+index, sum+nums[i+index]);\\n        }\\n    }\\n    \\n    int maxResult(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size(), -1);\\n        recur(nums, k, 0, nums[0]);\\n        return maxx;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int recur(vector<int>& nums, int k, int index, vector<int>& dp) {\\n        if(dp[index] != -1)\\n            return dp[index];\\n        \\n        if(index == nums.size()-1) {\\n            dp[index] = nums[index];\\n            return dp[index];\\n        }\\n        \\n        int max_so_far = INT_MIN;\\n        \\n        for(int i=1; (i<=k && (i+index)<nums.size()); ++i) {\\n            max_so_far = max(max_so_far, recur(nums, k, i+index, dp));\\n        }\\n        \\n        dp[index] = max_so_far + nums[index];\\n        \\n        return dp[index];\\n    }\\n    \\n    int maxResult(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size(), -1);\\n        return recur(nums, k, 0, dp);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int len = nums.size();\\n        vector<int> dp(nums.size(), -1);\\n        \\n        dp[len-1] = nums[len-1];\\n        multiset<int> ms;\\n        ms.insert(dp[len-1]);\\n        \\n        for(int i=len-2;i>=0; --i) {\\n\\t\\t\\t// Erase the oldest value i.e. the one which was inserted the earliest => i+k+1\\n            if(ms.size() > k) {\\n                ms.erase(ms.find(dp[i+k+1]));\\n            }\\n            dp[i] = *ms.rbegin()+nums[i];\\n            ms.insert(dp[i]);\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979342,
                "title": "c-100-time-and-space-backward-dp-with-early-stopping-and-pic-explanation",
                "content": "## Pic exmplain\\n![image](https://assets.leetcode.com/users/images/4a1479ca-99e5-4856-89ba-4485197a07d6_1608479615.4533622.png)\\n\\n## Approach and code\\n* Optimize from TLE and finally AC.\\n* Reason for early stopping is in the comment part of code\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int dp[100005] = {0};\\n        int n = nums.size();\\n        dp[n - 1] = nums[n - 1];\\n        for(int i = n - 2; i >= 0; i--){\\n            int cnt = 1, mxm = dp[i + 1];\\n            dp[i] = nums[i];\\n            while(i + cnt < n && cnt <= k){\\n                mxm = max(mxm, dp[i + cnt]);\\n                // We can do an early stopping here once we reach the first (and also closest) positive number \\n                // Since it will give us the optimial answer that current point can reach to (the farther the point, less optimial it is) \\n                if(nums[i + cnt] > 0){\\n                    break;\\n                }\\n                else{\\n                    cnt++;\\n                }\\n            }\\n            dp[i] = dp[i] + mxm;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int dp[100005] = {0};\\n        int n = nums.size();\\n        dp[n - 1] = nums[n - 1];\\n        for(int i = n - 2; i >= 0; i--){\\n            int cnt = 1, mxm = dp[i + 1];\\n            dp[i] = nums[i];\\n            while(i + cnt < n && cnt <= k){\\n                mxm = max(mxm, dp[i + cnt]);\\n                // We can do an early stopping here once we reach the first (and also closest) positive number \\n                // Since it will give us the optimial answer that current point can reach to (the farther the point, less optimial it is) \\n                if(nums[i + cnt] > 0){\\n                    break;\\n                }\\n                else{\\n                    cnt++;\\n                }\\n            }\\n            dp[i] = dp[i] + mxm;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978613,
                "title": "c-using-monotonic-increasing-queue",
                "content": "```csharp\\npublic int MaxResult(int[] nums, int k)\\n{\\n\\tint[] scores = new int[nums.Length];\\n\\tscores[0] = nums[0];\\n\\tLinkedList<int> q = new LinkedList<int>();\\n\\tq.AddLast(0);\\n\\n\\tfor (int i = 1; i < nums.Length; i++)\\n\\t{\\n\\t\\twhile (i - q.First.Value > k)\\n\\t\\t{\\n\\t\\t\\tq.RemoveFirst();\\n\\t\\t}\\n\\n\\t\\tscores[i] = scores[q.First.Value] + nums[i];\\n\\n\\t\\twhile (q.Count > 0 && scores[i] >= scores[q.Last.Value])\\n\\t\\t{\\n\\t\\t\\tq.RemoveLast();\\n\\t\\t}\\n\\n\\t\\tq.AddLast(i);\\n\\t}\\n\\n\\treturn scores[nums.Length - 1];\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MaxResult(int[] nums, int k)\\n{\\n\\tint[] scores = new int[nums.Length];\\n\\tscores[0] = nums[0];\\n\\tLinkedList<int> q = new LinkedList<int>();\\n\\tq.AddLast(0);\\n\\n\\tfor (int i = 1; i < nums.Length; i++)\\n\\t{\\n\\t\\twhile (i - q.First.Value > k)\\n\\t\\t{\\n\\t\\t\\tq.RemoveFirst();\\n\\t\\t}\\n\\n\\t\\tscores[i] = scores[q.First.Value] + nums[i];\\n\\n\\t\\twhile (q.Count > 0 && scores[i] >= scores[q.Last.Value])\\n\\t\\t{\\n\\t\\t\\tq.RemoveLast();\\n\\t\\t}\\n\\n\\t\\tq.AddLast(i);\\n\\t}\\n\\n\\treturn scores[nums.Length - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2258276,
                "title": "dynamic-programming-with-heap-o-nlogn",
                "content": "We can see that this problem has overlapping subproblems - maximum score at index i, with optimal substructure (maximum score), hence we can apply DP.\\n\\nThe naive DP solution would be to iterate for every index i, the i-k elements beforehand and to choose the best jump from these elements.\\n\\n# Naive implementation\\n```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [0] * (n)\\n        dp[0] = nums[0]\\n        \\n        for i in range(1, n):\\n            best = float(\\'-inf\\')\\n            for j in range(max(i-k, 0), i):\\n                best = max(best, dp[j] + nums[i])\\n            dp[i] = best\\n        \\n        return dp[n-1]\\n```\\n\\n\\nWe can do better.\\n\\nInstead of iterating i-k elements back for every index i, which causes O(n^2) complexity (k == n at max), we can keep a heap that will know the maximum score of our previous DP solutions. \\n\\nThe heap will keep track of `(-value, index) tuple` for every element. (the reason we keep the value with minus is because python has a minheap, and we can put elements with negative sign to turn it into a max heap)\\n\\nThen instead of iterating backwards, we will look at the heap to know the best solution until now. \\n\\nNote, that we need to discard solutions that contain index lower than `i-k` because they became \"out of range\".\\n\\n\\n# Code\\n```\\nimport heapq\\n\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        heap_window_k = []\\n        dp = [0] * n\\n        \\n        for i in range(n):\\n            dp[i] = nums[i]\\n            if i == 0: \\n                heapq.heappush(heap_window_k, (-nums[0], 0))\\n                continue\\n                \\n            # At most nlogn\\n            while heap_window_k[0][1] < i-k:\\n                heapq.heappop(heap_window_k)\\n            \\n            dp[i] += (-heap_window_k[0][0])\\n            heapq.heappush(heap_window_k, (-dp[i], i))\\n        \\n        return dp[n-1]\\n```\\n\\nThis reduces complexity to `nlogn` since the inner while loop will run **in total** at most for n elements, and popping an element from the heap is `logn` complexity => `O(nlogn)`",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [0] * (n)\\n        dp[0] = nums[0]\\n        \\n        for i in range(1, n):\\n            best = float(\\'-inf\\')\\n            for j in range(max(i-k, 0), i):\\n                best = max(best, dp[j] + nums[i])\\n            dp[i] = best\\n        \\n        return dp[n-1]\\n```\n```\\nimport heapq\\n\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        heap_window_k = []\\n        dp = [0] * n\\n        \\n        for i in range(n):\\n            dp[i] = nums[i]\\n            if i == 0: \\n                heapq.heappush(heap_window_k, (-nums[0], 0))\\n                continue\\n                \\n            # At most nlogn\\n            while heap_window_k[0][1] < i-k:\\n                heapq.heappop(heap_window_k)\\n            \\n            dp[i] += (-heap_window_k[0][0])\\n            heapq.heappush(heap_window_k, (-dp[i], i))\\n        \\n        return dp[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256656,
                "title": "simple-and-easy-c-monotonic-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(n);\\n        deque<int> q;\\n        q.push_back(n-1);\\n        dp[n-1] = nums[n-1];\\n        for(int i = n-2; i>=0;i--)\\n        {\\n            if(q.front()-i > k) q.pop_front();\\n            dp[i] = nums[i]+dp[q.front()];\\n            while(q.size() && dp[q.back()]<dp[i])\\n                 q.pop_back();\\n            q.push_back(i);\\n            \\n        }\\n        return dp[0];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(n);\\n        deque<int> q;\\n        q.push_back(n-1);\\n        dp[n-1] = nums[n-1];\\n        for(int i = n-2; i>=0;i--)\\n        {\\n            if(q.front()-i > k) q.pop_front();\\n            dp[i] = nums[i]+dp[q.front()];\\n            while(q.size() && dp[q.back()]<dp[i])\\n                 q.pop_back();\\n            q.push_back(i);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1271511,
                "title": "easy-to-understand-java-solution-explanation-with-comments-with-dp-o-nlogk",
                "content": "```\\nclass Solution {\\n    \\n    public int maxResult(int[] nums, int k) {\\n        \\n        /* \\n            We will use bottom up approach. That will also take O(n*K)\\n            Will further optimize by using sorted previous k elements for computation. O(n*logk)\\n        */\\n                \\n        int n = nums.length;\\n        int dp[] = new int[n];\\n        \\n        dp[0] = nums[0];  // Base Case for the dp (for 1st pos, only that value can be max)\\n        \\n        // Create Priority Queue which have smaller values first\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((int a[], int b[]) -> b[0] - a[0]); \\n        pq.add(new int[]{nums[0], 0});\\n        \\n        /*\\n            We have stored below values in Priority Queue\\n            - arr[0] (value)\\n            - arr[1] (index)        \\n\\n            Every time a new arr[] is entered in Priority queue,\\n\\n            - Comparison is made based on 0th index arr[0]  (which is the value)\\n              Thus, element with less value is stored ahead in queue\\n\\n            - During fetching, we check if its 1st index arr[1] (which is the index of value) < i-k\\n              Thus, the index of fetched value will be in range of [i] and [i-k]\\n        */\\n        \\n        \\n        for (int i=1; i<n; i++) {\\n            \\n            // Check if the peeked value is in range of last k values, use it. Otherwise, remove it.\\n            \\n            while (!pq.isEmpty() && pq.peek()[1] < i-k) {\\n                pq.remove();  // remove till we get index between last k values.\\n            }\\n            \\n            // Set dp[i] = Curr. Value + Max (last k index values)\\n            dp[i] = nums[i] + pq.peek()[0];\\n            \\n            // Add curr index and its value for further dp[i+1] ...  calculations\\n            pq.add(new int[]{dp[i], i});\\n            \\n        }\\n        \\n         return dp[n-1];\\n    }\\n}\\n```\\n\\n**Please Upvote if you find it helpful. Happy Coding!**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int maxResult(int[] nums, int k) {\\n        \\n        /* \\n            We will use bottom up approach. That will also take O(n*K)\\n            Will further optimize by using sorted previous k elements for computation. O(n*logk)\\n        */\\n                \\n        int n = nums.length;\\n        int dp[] = new int[n];\\n        \\n        dp[0] = nums[0];  // Base Case for the dp (for 1st pos, only that value can be max)\\n        \\n        // Create Priority Queue which have smaller values first\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((int a[], int b[]) -> b[0] - a[0]); \\n        pq.add(new int[]{nums[0], 0});\\n        \\n        /*\\n            We have stored below values in Priority Queue\\n            - arr[0] (value)\\n            - arr[1] (index)        \\n\\n            Every time a new arr[] is entered in Priority queue,\\n\\n            - Comparison is made based on 0th index arr[0]  (which is the value)\\n              Thus, element with less value is stored ahead in queue\\n\\n            - During fetching, we check if its 1st index arr[1] (which is the index of value) < i-k\\n              Thus, the index of fetched value will be in range of [i] and [i-k]\\n        */\\n        \\n        \\n        for (int i=1; i<n; i++) {\\n            \\n            // Check if the peeked value is in range of last k values, use it. Otherwise, remove it.\\n            \\n            while (!pq.isEmpty() && pq.peek()[1] < i-k) {\\n                pq.remove();  // remove till we get index between last k values.\\n            }\\n            \\n            // Set dp[i] = Curr. Value + Max (last k index values)\\n            dp[i] = nums[i] + pq.peek()[0];\\n            \\n            // Add curr index and its value for further dp[i+1] ...  calculations\\n            pq.add(new int[]{dp[i], i});\\n            \\n        }\\n        \\n         return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981557,
                "title": "javascript-monoqueue-100",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxResult = function(nums, k) {\\n    // remove redundant from front then front will be cur max\\n    // push new mx from back and pop all less than equal to\\n    // [3] 3\\n    // [3,-4] 3\\n    // [7] 7\\n    // [7,5] 7\\n    // [7,6] 7\\n    // [6,7]=>[7]\\n    \\n    let dq = [];\\n    \\n    for(let i=nums.length-1;i>=0;i--){\\n        while(dq.length > 0 && dq[0] > i+k)\\n            dq.shift();\\n        if(dq.length <=0)\\n            dq.push(i);\\n        else{\\n            nums[i] = nums[dq[0]] + nums[i];\\n            while(dq.length>0 && nums[dq[dq.length-1]]< nums[i])\\n                dq.pop();\\n            dq.push(i);\\n        }\\n    }\\n    return nums[0];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxResult = function(nums, k) {\\n    // remove redundant from front then front will be cur max\\n    // push new mx from back and pop all less than equal to\\n    // [3] 3\\n    // [3,-4] 3\\n    // [7] 7\\n    // [7,5] 7\\n    // [7,6] 7\\n    // [6,7]=>[7]\\n    \\n    let dq = [];\\n    \\n    for(let i=nums.length-1;i>=0;i--){\\n        while(dq.length > 0 && dq[0] > i+k)\\n            dq.shift();\\n        if(dq.length <=0)\\n            dq.push(i);\\n        else{\\n            nums[i] = nums[dq[0]] + nums[i];\\n            while(dq.length>0 && nums[dq[dq.length-1]]< nums[i])\\n                dq.pop();\\n            dq.push(i);\\n        }\\n    }\\n    return nums[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1770130,
                "title": "c-priority-queue-easy",
                "content": "class Solution {\\npublic:\\n    \\n\\tint maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        priority_queue<pair<int,int>,vector<pair<int,int>>>pq;\\n        pq.push({nums[0],0});\\n        int c = nums[0];\\n        for(int i=1;i<n;i++){\\n            while(i-pq.top().second>k){\\n                pq.pop();\\n            }\\n            c = nums[i]+pq.top().first;\\n            pq.push({c,i});\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    \\n\\tint maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        priority_queue<pair<int,int>,vector<pair<int,int>>>pq;\\n        pq.push({nums[0],0}",
                "codeTag": "Java"
            },
            {
                "id": 1336178,
                "title": "c-dp-deque-solution-o-n",
                "content": "Runtime: 136 ms, faster than 97.89% of C++ online submissions for Jump Game VI.\\nMemory Usage: 80.1 MB, less than 67.84% of C++ online submissions for Jump Game VI.\\n\\n```\\nWe have to jump through the array such that we get the max score. Also we can jump up to max K step \\nfrom any position and so when we work with an item X in the array we should add it to the max score\\nof previous K step. How to do that ? We can store the max score of all previous K steps in a double ended\\nqueue DS such that the max always stays in the front of the queue and only previous K elements stays \\nin the deque. So, we calculate current score by adding current element with front element of the queue.\\nThen we compare the current element with the element back of the queue and if it less than current element\\nthen we remove the element from back of the queue cause we only want the max elements in the deque. We\\ndo this until current element < back element of deque.  Then we push the current element to the back of the deque. \\nAt last we check the index of the front of the deque, if it is less than or equal current index -K then\\nwe remove it as it will not be considered as max value for next element of the array loop and we can only\\njump up to K steps from a given position. \\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        // store the max sum index in running K length sliding window\\n        deque<int>dq;\\n        \\n        for(int i=0;i<n;i++)\\n        {   \\n            // update current sum with max value in previous K elements \\n            nums[i] += (dq.empty() ? 0 : nums[dq.front()]);\\n            \\n            // remove the min value sum from sliding window \\n            while(!dq.empty() && nums[dq.back()] < nums[i])dq.pop_back();\\n            \\n            // add current value\\n            dq.push_back(i);\\n            \\n            // for next operation remove current max vlaue if its index is out of range K\\n            if(dq.front() < i+1-k)dq.pop_front();\\n        }\\n        \\n        \\n        // return max value sum \\n        return nums[dq.back()];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Dynamic Programming",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nWe have to jump through the array such that we get the max score. Also we can jump up to max K step \\nfrom any position and so when we work with an item X in the array we should add it to the max score\\nof previous K step. How to do that ? We can store the max score of all previous K steps in a double ended\\nqueue DS such that the max always stays in the front of the queue and only previous K elements stays \\nin the deque. So, we calculate current score by adding current element with front element of the queue.\\nThen we compare the current element with the element back of the queue and if it less than current element\\nthen we remove the element from back of the queue cause we only want the max elements in the deque. We\\ndo this until current element < back element of deque.  Then we push the current element to the back of the deque. \\nAt last we check the index of the front of the deque, if it is less than or equal current index -K then\\nwe remove it as it will not be considered as max value for next element of the array loop and we can only\\njump up to K steps from a given position. \\n```\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        // store the max sum index in running K length sliding window\\n        deque<int>dq;\\n        \\n        for(int i=0;i<n;i++)\\n        {   \\n            // update current sum with max value in previous K elements \\n            nums[i] += (dq.empty() ? 0 : nums[dq.front()]);\\n            \\n            // remove the min value sum from sliding window \\n            while(!dq.empty() && nums[dq.back()] < nums[i])dq.pop_back();\\n            \\n            // add current value\\n            dq.push_back(i);\\n            \\n            // for next operation remove current max vlaue if its index is out of range K\\n            if(dq.front() < i+1-k)dq.pop_front();\\n        }\\n        \\n        \\n        // return max value sum \\n        return nums[dq.back()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979913,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        // Maintain a monotonic queue. This is implemented using deque.\\n\\t\\t// Idea is similar as the problem \\'Sliding Window Maximum\\'.\\n        deque<int> dq;\\n        int n = nums.size();\\n        // dp array is actually not required since we can do all the computations in the input array itself.\\n        vector<int> dp(n, 0);\\n        // Since we have to consider the 0th index no matter what.\\n        dp[0] = nums[0];\\n        dq.push_front(0);\\n        \\n        for(int i = 1; i < n; i++) {\\n            /*\\n\\t\\t\\tFirst step is to remove all the redundant elements.\\n\\t\\t\\tAll the elements having an index \\'j\\' such that (i - j > k)\\n\\t\\t\\tshould be removed from consideration.\\n\\t\\t\\t*/\\n            while(dq.size() > 0 && i - dq.front() > k) {\\n                dq.pop_front();\\n            }\\n            \\n            // Since we have to consider the index we are on,\\n\\t\\t\\t// we make the current cost as the cost of that index.\\n            dp[i] = nums[i];\\n            \\n            // We select the highest score.\\n            if(dq.size() > 0) {\\n                dp[i] += dp[dq.front()];\\n            }\\n            \\n            /*\\n\\t\\t\\tWe add the current index at its appropriate position in the deque.\\n\\t\\t\\tFor this, we first remove all the elements from the back such that\\n\\t\\t\\tthey are less than our current index. These elements will never be\\n\\t\\t\\tconsidered n the answer, because for any future index where they\\n\\t\\t\\tare valid, we have a better answer (our current index).\\n\\t\\t\\t*/\\n            while(dq.size() > 0 && dp[i] > dp[dq.back()]) {\\n                dq.pop_back();\\n            }\\n            dq.push_back(i);\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        // Maintain a monotonic queue. This is implemented using deque.\\n\\t\\t// Idea is similar as the problem \\'Sliding Window Maximum\\'.\\n        deque<int> dq;\\n        int n = nums.size();\\n        // dp array is actually not required since we can do all the computations in the input array itself.\\n        vector<int> dp(n, 0);\\n        // Since we have to consider the 0th index no matter what.\\n        dp[0] = nums[0];\\n        dq.push_front(0);\\n        \\n        for(int i = 1; i < n; i++) {\\n            /*\\n\\t\\t\\tFirst step is to remove all the redundant elements.\\n\\t\\t\\tAll the elements having an index \\'j\\' such that (i - j > k)\\n\\t\\t\\tshould be removed from consideration.\\n\\t\\t\\t*/\\n            while(dq.size() > 0 && i - dq.front() > k) {\\n                dq.pop_front();\\n            }\\n            \\n            // Since we have to consider the index we are on,\\n\\t\\t\\t// we make the current cost as the cost of that index.\\n            dp[i] = nums[i];\\n            \\n            // We select the highest score.\\n            if(dq.size() > 0) {\\n                dp[i] += dp[dq.front()];\\n            }\\n            \\n            /*\\n\\t\\t\\tWe add the current index at its appropriate position in the deque.\\n\\t\\t\\tFor this, we first remove all the elements from the back such that\\n\\t\\t\\tthey are less than our current index. These elements will never be\\n\\t\\t\\tconsidered n the answer, because for any future index where they\\n\\t\\t\\tare valid, we have a better answer (our current index).\\n\\t\\t\\t*/\\n            while(dq.size() > 0 && dp[i] > dp[dq.back()]) {\\n                dq.pop_back();\\n            }\\n            dq.push_back(i);\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979058,
                "title": "c-dp",
                "content": "Recursion with memoization, top down\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<int> &nums, vector<int> &memo, int indx, int k) {\\n        if (indx >= nums.size()) return 0;\\n        if (indx == nums.size() - 1) return nums[indx];\\n        if (memo[indx] > INT_MIN) return memo[indx];\\n        for (int i = indx + 1; i < nums.size() && i <= indx + k; i++) {\\n            memo[indx] = max(memo[indx], dfs(nums, memo, i, k));\\n            if (nums[i] >= 0) break;\\n        }\\n        return memo[indx] += nums[indx];\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        vector<int> memo(nums.size(), INT_MIN);\\n        return dfs(nums, memo, 0, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<int> &nums, vector<int> &memo, int indx, int k) {\\n        if (indx >= nums.size()) return 0;\\n        if (indx == nums.size() - 1) return nums[indx];\\n        if (memo[indx] > INT_MIN) return memo[indx];\\n        for (int i = indx + 1; i < nums.size() && i <= indx + k; i++) {\\n            memo[indx] = max(memo[indx], dfs(nums, memo, i, k));\\n            if (nums[i] >= 0) break;\\n        }\\n        return memo[indx] += nums[indx];\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        vector<int> memo(nums.size(), INT_MIN);\\n        return dfs(nums, memo, 0, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978706,
                "title": "python-dp-collection-deque-tle-to-accepted",
                "content": "Solution 1 --> TLE\\n+ run i backwards from  n - 1 --> 0\\n++ each i will have max of [i + 1 through i + k + 1]\\n```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        lenn = len(nums)\\n        dp = [0 for _ in range(lenn)]\\n        dp[-1] = nums[-1]\\n        \\n        for r in range(lenn - 2, -1, -1):\\n            dp[r] = nums[r] + max(dp[r + 1: r + k + 1] or [0])\\n        return dp[0]\\n```\\nSolution 2\\nTo avoid TLE:\\n+ do the same and to get the max from [i + 1 through i + k + 1]\\n+ use a deque, which will always store the max so far\\n```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        ln = len(nums)\\n        dp = [0 for _ in range(ln)]\\n        dp[-1] = nums[-1]\\n        \\n        queue = collections.deque([dp[-1]])\\n        for r in range(ln - 2, -1, -1):\\n            dp[r] = nums[r] + queue[0]\\n            \\n            if len(queue) >= k: queue.popleft()\\n            while queue and queue[-1] < dp[r]: queue.pop()\\n            queue.append(dp[r])\\n        return dp[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        lenn = len(nums)\\n        dp = [0 for _ in range(lenn)]\\n        dp[-1] = nums[-1]\\n        \\n        for r in range(lenn - 2, -1, -1):\\n            dp[r] = nums[r] + max(dp[r + 1: r + k + 1] or [0])\\n        return dp[0]\\n```\n```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        ln = len(nums)\\n        dp = [0 for _ in range(ln)]\\n        dp[-1] = nums[-1]\\n        \\n        queue = collections.deque([dp[-1]])\\n        for r in range(ln - 2, -1, -1):\\n            dp[r] = nums[r] + queue[0]\\n            \\n            if len(queue) >= k: queue.popleft()\\n            while queue and queue[-1] < dp[r]: queue.pop()\\n            queue.append(dp[r])\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978523,
                "title": "java-o-n-using-deque-similar-to-sliding-window-maximum",
                "content": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        Deque<Integer> s = new LinkedList<>();\\n        int[] dp = new int[nums.length + 1];\\n        dp[1] = nums[0];\\n        s.offer(1);\\n        for(int i = 2; i <= nums.length; i++) {\\n            dp[i] = nums[i-1] + dp[s.peekFirst()];\\n            \\n            while(!s.isEmpty() && dp[s.peekLast()] < dp[i])\\n                s.pollLast();\\n            \\n            s.offer(i);\\n            \\n            if(i > k) {\\n                if(s.peekFirst() == i-k) s.pollFirst();\\n            }\\n        }\\n        \\n        return dp[nums.length];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        Deque<Integer> s = new LinkedList<>();\\n        int[] dp = new int[nums.length + 1];\\n        dp[1] = nums[0];\\n        s.offer(1);\\n        for(int i = 2; i <= nums.length; i++) {\\n            dp[i] = nums[i-1] + dp[s.peekFirst()];\\n            \\n            while(!s.isEmpty() && dp[s.peekLast()] < dp[i])\\n                s.pollLast();\\n            \\n            s.offer(i);\\n            \\n            if(i > k) {\\n                if(s.peekFirst() == i-k) s.pollFirst();\\n            }\\n        }\\n        \\n        return dp[nums.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600472,
                "title": "c-5-lines-priority-queue-simplest-solution",
                "content": "# Intuition\\nThe idea is to use a priority queue that stores the maximum score at each index while considering the jumping constraints. By iteratively calculating the maximum score at each index and storing it in the priority queue, we can find the overall maximum score required to reach the last index of the array.\\n\\n# Explanation\\n- Initialize maximum score as maxScore reate a priority queue as pq to store pairs of scores and indices.\\n- Iterate through the nums array in reverse order.\\n- Within the loop:\\n1) Check if the priority queue is not empty and the index at the top of priority queue is greater than i+k. If this condition is true, it means that the top element is not reachable and should be removed from priority queue. Repeat this step until the given condition turns out to be false.  \\n2) Calculate the possible increment in maximum score as temp. If the priority queue is not empty, set temp as the score of the top element in the priority queue, otherwise set temp=0.\\n3) Calculate the maximum score for the current index i by adding temp to nums[i].\\n4) Insert the score and index pair to the priority queue.\\n- After the loop finishes, the maximum score will be the value stored in maxScore which is the required result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n log(k))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int maxScore = 0;\\n        priority_queue<pair<int, int>> pq;\\n        \\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            while (!pq.empty() && pq.top().second > i + k) pq.pop();    \\n            int temp = pq.size()?pq.top().first:0;\\n            maxScore = nums[i] + temp;\\n            pq.push({maxScore, i});\\n        }\\n        return maxScore;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int maxScore = 0;\\n        priority_queue<pair<int, int>> pq;\\n        \\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            while (!pq.empty() && pq.top().second > i + k) pq.pop();    \\n            int temp = pq.size()?pq.top().first:0;\\n            maxScore = nums[i] + temp;\\n            pq.push({maxScore, i});\\n        }\\n        return maxScore;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170668,
                "title": "priority-queue-c-simple-easy-to-undterstand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> score(n,0);\\n        priority_queue<pair<int,int>> pq;\\n        for(int i = 0; i < n; i++){\\n            while(!pq.empty() && pq.top().second < i-k){\\n                pq.pop();\\n            }\\n            score[i] += nums[i];\\n            score[i] += ((pq.size()?pq.top().first:0));\\n            pq.push({score[i],i});\\n        }\\n        return score[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> score(n,0);\\n        priority_queue<pair<int,int>> pq;\\n        for(int i = 0; i < n; i++){\\n            while(!pq.empty() && pq.top().second < i-k){\\n                pq.pop();\\n            }\\n            score[i] += nums[i];\\n            score[i] += ((pq.size()?pq.top().first:0));\\n            pq.push({score[i],i});\\n        }\\n        return score[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401030,
                "title": "clean-consice-c",
                "content": "```\\nclass Solution {\\npublic:    \\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        deque<int> dq;\\n        vector<int> dp(n,0);\\n        for(int i = n-1;i>=0;i--){\\n            int end = min(n-1,i+k);\\n            while(!dq.empty() && dq.back() > end)dq.pop_back();\\n            int cost = nums[i] + ((!dq.empty())?dp[dq.back()]:0);\\n            dp[i] = cost;\\n            while(!dq.empty() && dp[dq.front()]< dp[i])dq.pop_front();\\n            dq.push_front(i);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        deque<int> dq;\\n        vector<int> dp(n,0);\\n        for(int i = n-1;i>=0;i--){\\n            int end = min(n-1,i+k);\\n            while(!dq.empty() && dq.back() > end)dq.pop_back();\\n            int cost = nums[i] + ((!dq.empty())?dp[dq.back()]:0);\\n            dp[i] = cost;\\n            while(!dq.empty() && dp[dq.front()]< dp[i])dq.pop_front();\\n            dq.push_front(i);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257510,
                "title": "c-99-05-100-167ms-76-8mb-dp-deque-implement-both-o-n-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int dq[nums.size()],bk=0,fr=0;\\n        dq[bk++]=0;\\n        for(int i=1;i<nums.size();++i){\\n            if(i-dq[fr]>k)++fr;\\n            nums[i]+=nums[dq[fr]];\\n            while(bk>fr&&nums[i]>=nums[dq[bk-1]])--bk;\\n            dq[bk++]=i;\\n        }\\n        return nums[nums.size()-1];\\n    }\\n};\\n```\\n1.DP[i] means the highest score when arriving nums[i].\\n2.the best way to get max score in DP[i] is choosing max(DP[i-1~i-k])+nums[i].\\n3.if (DP[i] <= DP[j]) && (j>i) than DP[j] is better than DP[i] for every case.\\n4.base on hint 1+2+3, we can get a descending sequence by score, the frontmost value of sequence is best choice.\\n5.However, the best choice may be outside the range of DP[i-1~i-k] -> pop front the element which is illegal.\\n6.deque in C++ STL is fat,the max size of deque in this case is less than n -> use an array + back&front pointer to implement deque.\\n7.we don\\'t need DP[] to record score,nums[] is enough.\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int dq[nums.size()],bk=0,fr=0;\\n        dq[bk++]=0;\\n        for(int i=1;i<nums.size();++i){\\n            if(i-dq[fr]>k)++fr;\\n            nums[i]+=nums[dq[fr]];\\n            while(bk>fr&&nums[i]>=nums[dq[bk-1]])--bk;\\n            dq[bk++]=i;\\n        }\\n        return nums[nums.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257140,
                "title": "c-dp-dequeue-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size());\\n        int n = nums.size();\\n        priority_queue<int> pq;\\n        dp[n-1]=nums[n-1];\\n        deque<int> dq;\\n        dq.push_back(n-1);\\n      \\n        for(int i=n-2;i>=0;i--){\\n          \\n            int a = nums[i];\\n            while(dq.size() && dq.front()>i+k){\\n                dq.pop_front();\\n            }\\n            int next  = dp[dq.front()];\\n            dp[i] = a+next;\\n          while(dq.size() && dp[dq.back()]< dp[i]){\\n              dq.pop_back();\\n          }  \\n            dq.push_back(i); \\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size());\\n        int n = nums.size();\\n        priority_queue<int> pq;\\n        dp[n-1]=nums[n-1];\\n        deque<int> dq;\\n        dq.push_back(n-1);\\n      \\n        for(int i=n-2;i>=0;i--){\\n          \\n            int a = nums[i];\\n            while(dq.size() && dq.front()>i+k){\\n                dq.pop_front();\\n            }\\n            int next  = dp[dq.front()];\\n            dp[i] = a+next;\\n          while(dq.size() && dp[dq.back()]< dp[i]){\\n              dq.pop_back();\\n          }  \\n            dq.push_back(i); \\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027018,
                "title": "3-python-solutions",
                "content": "### ***Solution 1 (DP) --> \"TLE\" :  TC: O(n\\\\*k) / SC: O(n)***\\n```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        dp=[nums[0]]+[0]*(len(nums)-1)\\n        for i in range(1,len(nums)): dp[i]=nums[i]+max(dp[max(0,i-k):i])\\n        return dp[-1]\\n```\\n\\n-----------------\\n### ***Solution 2  (heap) --> \"Accepted\":  TC: O(n) / SC: O(k)***\\n```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        heap=[(0,-k)]\\n        for i in range(len(nums)):\\n            while i-heap[0][1]>k: heappop(heap)\\n            nums[i]-=heap[0][0]\\n            heappush(heap,(-nums[i],i))\\n        return nums[-1]\\n```\\n-----------------\\n### ***Solution 3  (deque) --> \"Accepted\":  TC: O(n) / SC: O(k)***\\n```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        dq=deque([(nums[0],0)])\\n        for i in range(1,len(nums)):\\n            score=dq[0][0]+nums[i]\\n            while dq and dq[-1][0]<score: dq.pop()\\n            dq.append((score,i))\\n            if dq[0][1]==i-k: dq.popleft()\\n        return dq[-1][0]\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        dp=[nums[0]]+[0]*(len(nums)-1)\\n        for i in range(1,len(nums)): dp[i]=nums[i]+max(dp[max(0,i-k):i])\\n        return dp[-1]\\n```\n```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        heap=[(0,-k)]\\n        for i in range(len(nums)):\\n            while i-heap[0][1]>k: heappop(heap)\\n            nums[i]-=heap[0][0]\\n            heappush(heap,(-nums[i],i))\\n        return nums[-1]\\n```\n```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        dq=deque([(nums[0],0)])\\n        for i in range(1,len(nums)):\\n            score=dq[0][0]+nums[i]\\n            while dq and dq[-1][0]<score: dq.pop()\\n            dq.append((score,i))\\n            if dq[0][1]==i-k: dq.popleft()\\n        return dq[-1][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262001,
                "title": "very-simple-priority-queue-solution-with-line-by-line-explanation-and-the-thought-process-behind-it",
                "content": "Algorithm - At a given index i we have to find the maximum points we can aquire to reach here. so We can reach here from i -1 , i -2 ... i - k prvivious index. so the maximum points reach index i will be max of ( maximum possible points to reach i -1,i -2 ,i- 3..., i - k) + nums[i]\\n1.for a given index i we will pop a element from priority queue it will be the max previous step point if its position is less then i - k then its not valid and we will pop it\\n2. If its index is >= i - k this is the index we want to jump from to ith index and then put that value added to the nums[i] back to the priority queue and go to the next index that is i + 1\\n3. Do the first two steps for each of the index i in the integer array\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        priority_queue<vector<int>,vector<vector<int>> >pq;\\n        pq.push({nums[0],0});// 0th index value\\n        for(int i = 1; i < n; i++)\\n        {\\n            while(true)\\n            {\\n                vector<int>curr = pq.top();\\n                if(curr[1] < i - k)\\n                {\\n                    pq.pop();// not valid because we can only jump at most k indexes\\n                }\\n                else\\n                {\\n                    nums[i] += curr[0];// we go the max previous value step within k steps back\\n                    pq.push({nums[i],i});// we add it to the queue\\n                    break;// we go to the next position in the array\\n                }\\n            }\\n        }\\n\\t\\t\\treturn nums[n - 1];// we have to reach the last index of the array with maximum points so we return the last index value computed. \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        priority_queue<vector<int>,vector<vector<int>> >pq;\\n        pq.push({nums[0],0});// 0th index value\\n        for(int i = 1; i < n; i++)\\n        {\\n            while(true)\\n            {\\n                vector<int>curr = pq.top();\\n                if(curr[1] < i - k)\\n                {\\n                    pq.pop();// not valid because we can only jump at most k indexes\\n                }\\n                else\\n                {\\n                    nums[i] += curr[0];// we go the max previous value step within k steps back\\n                    pq.push({nums[i],i});// we add it to the queue\\n                    break;// we go to the next position in the array\\n                }\\n            }\\n        }\\n\\t\\t\\treturn nums[n - 1];// we have to reach the last index of the array with maximum points so we return the last index value computed. \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261496,
                "title": "easy-c-dp-heap",
                "content": "The solution uses DP by checking the last k elements from the ith element and pick the largest element from here. Instead of iterating the last k elements repeatedly using a heap will ensure O(1) fetch, and we update the heap when the smallest element more than k elements behind the current.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size(),0);\\n        priority_queue<pair<int,int>> pq;\\n        dp[0] = nums[0];\\n        pq.push({nums[0],0});\\n        for(int i=1;i<nums.size();i++){\\n            dp[i] = nums[i];\\n            while(pq.top().second+k<i){\\n                pq.pop();\\n            }\\n            dp[i]+=pq.top().first;\\n            pq.push({dp[i],i});\\n        }\\n        return dp[nums.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size(),0);\\n        priority_queue<pair<int,int>> pq;\\n        dp[0] = nums[0];\\n        pq.push({nums[0],0});\\n        for(int i=1;i<nums.size();i++){\\n            dp[i] = nums[i];\\n            while(pq.top().second+k<i){\\n                pq.pop();\\n            }\\n            dp[i]+=pq.top().first;\\n            pq.push({dp[i],i});\\n        }\\n        return dp[nums.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261078,
                "title": "java-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k){\\n        //PriorityQueue will contain score and index\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> (b[0] - a[0]));\\n        heap.offer(new int[]{nums[0], 0});\\n        int maximumScore = nums[0];\\n        for(int i=1; i<nums.length; i++) {\\n            while(!(i- heap.peek()[1] <= k)) {\\n                heap.poll();\\n            }\\n            int[] currentElement = heap.peek();\\n            maximumScore  = currentElement[0] + nums[i];\\n            heap.offer(new int[]{maximumScore, i});\\n        }\\n        return maximumScore;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxResult(int[] nums, int k){\\n        //PriorityQueue will contain score and index\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> (b[0] - a[0]));\\n        heap.offer(new int[]{nums[0], 0}",
                "codeTag": "Java"
            },
            {
                "id": 1261057,
                "title": "rust-binaryheap",
                "content": "```rust\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn max_result(nums: Vec<i32>, k: i32) -> i32 {\\n        nums.into_iter()\\n            .enumerate()\\n            .scan(BinaryHeap::with_capacity(k as _), |heap, (i, x)| {\\n                while i - heap.peek().map_or(i, |&(_, j)| j) > k as usize {\\n                    heap.pop();\\n                }\\n                let max = x + heap.peek().map(|&(y, _)| y).unwrap_or(0);\\n                heap.push((max, i));\\n                Some(max)\\n            })\\n            .last()\\n            .unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn max_result(nums: Vec<i32>, k: i32) -> i32 {\\n        nums.into_iter()\\n            .enumerate()\\n            .scan(BinaryHeap::with_capacity(k as _), |heap, (i, x)| {\\n                while i - heap.peek().map_or(i, |&(_, j)| j) > k as usize {\\n                    heap.pop();\\n                }\\n                let max = x + heap.peek().map(|&(y, _)| y).unwrap_or(0);\\n                heap.push((max, i));\\n                Some(max)\\n            })\\n            .last()\\n            .unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261033,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        //we will use deque to store the indices\\n        //we calculate the sum from the last elements \\n        //we maintain the deque in descending order of the sum value at the indices\\n        int len=nums.size();\\n        deque<int> dq;\\n        long bestSum=0;\\n        for(int i=len-1;i>=0;i--)\\n        {\\n            bestSum= (dq.empty()) ? 0 : nums[dq.front()]; //get the maximum sum from the i+k elements\\n            nums[i]+=bestSum;\\n            \\n            //maintain the deque in descending order\\n            while(!dq.empty() && nums[i]>nums[dq.back()])\\n                dq.pop_back();\\n            \\n            dq.push_back(i);\\n            \\n            //store the indices from i to i+k range only\\n            while(!dq.empty() && dq.front()>=i+k)\\n                dq.pop_front();\\n            \\n        }\\n        return nums[0];\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        //we will use deque to store the indices\\n        //we calculate the sum from the last elements \\n        //we maintain the deque in descending order of the sum value at the indices\\n        int len=nums.size();\\n        deque<int> dq;\\n        long bestSum=0;\\n        for(int i=len-1;i>=0;i--)\\n        {\\n            bestSum= (dq.empty()) ? 0 : nums[dq.front()]; //get the maximum sum from the i+k elements\\n            nums[i]+=bestSum;\\n            \\n            //maintain the deque in descending order\\n            while(!dq.empty() && nums[i]>nums[dq.back()])\\n                dq.pop_back();\\n            \\n            dq.push_back(i);\\n            \\n            //store the indices from i to i+k range only\\n            while(!dq.empty() && dq.front()>=i+k)\\n                dq.pop_front();\\n            \\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978671,
                "title": "c-priorityqueue",
                "content": "```\\nclass Solution {\\npublic:\\n\\t int maxResult(vector<int>& nums, int k) {\\n        if (k == 1) {return accumulate(nums.begin(), nums.end(), 0);}\\n        if (nums.size() == 1) {return nums[0];}\\n        if (nums.size() == 2) {return nums[0] + nums[1];}\\n        if (k >= nums.size() - 1) {\\n            int sum = nums[0] + nums.back();\\n            for (int i =  1; i < nums.size() - 1; i++) {\\n                if (nums[i] > 0) {sum += nums[i];}\\n            }\\n            return sum;\\n        }\\n\\t\\t// to store points and index for a certain index i\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomp> maxheap;\\n        int n = nums.size();\\n        int curr = 0;  // to store point for current index\\n        \\n        maxheap.push({nums[0], 0});\\n        for (int i = 1; i < n; i++) {\\n\\t\\t    // to discard those out of valid jump range\\n            while (maxheap.top().second < i - k) {\\n                maxheap.pop();\\n            }\\n            curr = nums[i] + maxheap.top().first;\\n            maxheap.push({curr, i});\\n        }\\n        \\n        return curr;\\n    }\\n    \\n    struct mycomp {\\n        bool operator ()(pair<int, int> p1, pair<int, int> p2) {\\n            return p1.first < p2.first;\\n        }\\n    };\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t int maxResult(vector<int>& nums, int k) {\\n        if (k == 1) {return accumulate(nums.begin(), nums.end(), 0);}\\n        if (nums.size() == 1) {return nums[0];}\\n        if (nums.size() == 2) {return nums[0] + nums[1];}\\n        if (k >= nums.size() - 1) {\\n            int sum = nums[0] + nums.back();\\n            for (int i =  1; i < nums.size() - 1; i++) {\\n                if (nums[i] > 0) {sum += nums[i];}\\n            }\\n            return sum;\\n        }\\n\\t\\t// to store points and index for a certain index i\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomp> maxheap;\\n        int n = nums.size();\\n        int curr = 0;  // to store point for current index\\n        \\n        maxheap.push({nums[0], 0});\\n        for (int i = 1; i < n; i++) {\\n\\t\\t    // to discard those out of valid jump range\\n            while (maxheap.top().second < i - k) {\\n                maxheap.pop();\\n            }\\n            curr = nums[i] + maxheap.top().first;\\n            maxheap.push({curr, i});\\n        }\\n        \\n        return curr;\\n    }\\n    \\n    struct mycomp {\\n        bool operator ()(pair<int, int> p1, pair<int, int> p2) {\\n            return p1.first < p2.first;\\n        }\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978542,
                "title": "ruby-binary-search-o-n-log-k",
                "content": "# First version. Brute force\\n`dp[i]` means max sum that can be achieved jumping till `i`-th element. \\nThere are at max `k`possible points to get to index `i`.\\n\\n```ruby\\ndef max_result(a, k)\\n  n = a.size\\n  dp = Array.new(n, 0)\\n  dp[0] = a[0]\\n  prv = [dp[0]]\\n  for j in 1...n\\n    start = [j - k, 0].max\\n    dp[j] = dp[start...j].max + a[j]\\n  end\\n  dp.last\\nend\\n# Time: O(n * k)\\n# Runtime: TLE\\n```\\n\\nHere `~k` operations are performed for each array element.\\n\\n### Optimization with Binary Search\\n\\nKeep previous points achieved sums in a sorted array.\\n\\n```ruby\\ndef add_into_sorted(arr, x)\\n  i = arr.bsearch_index { |n| n >= x } || arr.size\\n  arr.insert(i, x)\\nend\\n\\ndef delete_from_sorted(arr, x)\\n  i = arr.bsearch_index { |n| n >= x }\\n  arr.delete_at(i)\\nend\\n\\ndef max_result(a, k)\\n  n = a.size\\n  dp = Array.new(n, 0)\\n  dp[0] = a[0]\\n  prv = [dp[0]]\\n  for j in 1...n\\n    dp[j] = prv.last + a[j]\\n    add_into_sorted(prv, dp[j])\\n    if prv.size > k\\n      delete_from_sorted(prv, dp[j - k])\\n    end\\n  end\\n  dp.last\\nend\\n# Time: O(n * log(k))\\n# Runtime: 736 ms\\n```",
                "solutionTags": [
                    "Ruby",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```ruby\\ndef max_result(a, k)\\n  n = a.size\\n  dp = Array.new(n, 0)\\n  dp[0] = a[0]\\n  prv = [dp[0]]\\n  for j in 1...n\\n    start = [j - k, 0].max\\n    dp[j] = dp[start...j].max + a[j]\\n  end\\n  dp.last\\nend\\n# Time: O(n * k)\\n# Runtime: TLE\\n```\n```ruby\\ndef add_into_sorted(arr, x)\\n  i = arr.bsearch_index { |n| n >= x } || arr.size\\n  arr.insert(i, x)\\nend\\n\\ndef delete_from_sorted(arr, x)\\n  i = arr.bsearch_index { |n| n >= x }\\n  arr.delete_at(i)\\nend\\n\\ndef max_result(a, k)\\n  n = a.size\\n  dp = Array.new(n, 0)\\n  dp[0] = a[0]\\n  prv = [dp[0]]\\n  for j in 1...n\\n    dp[j] = prv.last + a[j]\\n    add_into_sorted(prv, dp[j])\\n    if prv.size > k\\n      delete_from_sorted(prv, dp[j - k])\\n    end\\n  end\\n  dp.last\\nend\\n# Time: O(n * log(k))\\n# Runtime: 736 ms\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 978526,
                "title": "using-sliding-window-concept",
                "content": "This seems a normal DP question of minimum jumps to reach the end point. But it will give you a TLE for finding maximum among the elements whose index range from i-x to i-1.\\nHence, we will use sliding window to always obtain the maximum element whose index range from i-x to i-1.\\n\\nPlease like and comment if you find this helpful.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> dp(n);\\n        deque<int> q;\\n        for(int i=0;i<n;i++){\\n            while(!q.empty() && q.front()<i-k){\\n                q.pop_front();\\n            }\\n            if(!q.empty()){\\n                dp[i]+=dp[q.front()];\\n            }\\n            dp[i]+=nums[i];\\n            while(!q.empty() && dp[i]>dp[q.back()]){\\n                q.pop_back();\\n            }\\n            q.push_back(i);\\n        }\\n        return dp.back();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> dp(n);\\n        deque<int> q;\\n        for(int i=0;i<n;i++){\\n            while(!q.empty() && q.front()<i-k){\\n                q.pop_front();\\n            }\\n            if(!q.empty()){\\n                dp[i]+=dp[q.front()];\\n            }\\n            dp[i]+=nums[i];\\n            while(!q.empty() && dp[i]>dp[q.back()]){\\n                q.pop_back();\\n            }\\n            q.push_back(i);\\n        }\\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978515,
                "title": "dp-should-be-accepted-got-tle",
                "content": "```\\nclass Solution {\\n    private int[] dp = new int[1000001];\\n    private int infi = Integer.MIN_VALUE;\\n    public int maxResult(int[] nums, int k) {\\n        Arrays.fill(dp,infi);\\n        return getMaxJumpVal(nums, 0, k);\\n    }\\n\\n    private int getMaxJumpVal(int[] arr, int ind, int k){\\n        if(ind == arr.length-1)\\n            return arr[ind];\\n\\n        if(dp[ind] != infi)\\n            return dp[ind];\\n\\n        int sum = arr[ind];\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 1; i <= k; i++){\\n            if(ind+ i < arr.length){\\n                max = Math.max(max, getMaxJumpVal(arr, ind+i, k));\\n            }\\n        }\\n        dp[ind] = sum + max;\\n        return dp[ind];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[] dp = new int[1000001];\\n    private int infi = Integer.MIN_VALUE;\\n    public int maxResult(int[] nums, int k) {\\n        Arrays.fill(dp,infi);\\n        return getMaxJumpVal(nums, 0, k);\\n    }\\n\\n    private int getMaxJumpVal(int[] arr, int ind, int k){\\n        if(ind == arr.length-1)\\n            return arr[ind];\\n\\n        if(dp[ind] != infi)\\n            return dp[ind];\\n\\n        int sum = arr[ind];\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 1; i <= k; i++){\\n            if(ind+ i < arr.length){\\n                max = Math.max(max, getMaxJumpVal(arr, ind+i, k));\\n            }\\n        }\\n        dp[ind] = sum + max;\\n        return dp[ind];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978475,
                "title": "accepted-c-solution-with-dp-and-sliding-window-using-linkedlist",
                "content": "```\\npublic class Solution\\n    {\\n\\n        public int MaxResult(int[] nums, int k)\\n        {\\n            int[] dp = new int[nums.Length];\\n            int l = nums.Length - 1;\\n            dp[l] = nums[l];\\n\\n            LinkedList<int> wnd = new LinkedList<int>();\\n            wnd.AddLast(l);\\n\\n            while (true)\\n            {\\n                l--;\\n                if (l < 0)\\n                {\\n                    break;\\n                }\\n\\n                while (wnd.Count > 0 && wnd.First.Value > l + k)\\n                {\\n                    wnd.RemoveFirst();\\n                }\\n\\n                dp[l] = dp[wnd.First.Value] + nums[l];\\n\\n                while (wnd.Count > 0 && dp[l] >= dp[wnd.Last.Value])\\n                {\\n                    wnd.RemoveLast();\\n                }\\n\\n                wnd.AddLast(l);\\n            }\\n\\n\\n            return dp[0];\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\npublic class Solution\\n    {\\n\\n        public int MaxResult(int[] nums, int k)\\n        {\\n            int[] dp = new int[nums.Length];\\n            int l = nums.Length - 1;\\n            dp[l] = nums[l];\\n\\n            LinkedList<int> wnd = new LinkedList<int>();\\n            wnd.AddLast(l);\\n\\n            while (true)\\n            {\\n                l--;\\n                if (l < 0)\\n                {\\n                    break;\\n                }\\n\\n                while (wnd.Count > 0 && wnd.First.Value > l + k)\\n                {\\n                    wnd.RemoveFirst();\\n                }\\n\\n                dp[l] = dp[wnd.First.Value] + nums[l];\\n\\n                while (wnd.Count > 0 && dp[l] >= dp[wnd.Last.Value])\\n                {\\n                    wnd.RemoveLast();\\n                }\\n\\n                wnd.AddLast(l);\\n            }\\n\\n\\n            return dp[0];\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978464,
                "title": "python-clean-mono-deque-solution-with-explanation-o-n",
                "content": "**Idea**\\n\\nWe can use monotonic decreasing deque to find the best score. I\\'ll list the general idea here; please refer to the code below for more details.\\n\\nSuppose `best[i]` denotes the best score up until index `i`. We create a mono deque `dec` to keep track of all the index `i`. Here `dec` is sorted based on their corresponding `best[i]`. Additionally, we use lazy deletion to make sure all index in `best` are within range of `k`. \\n\\nThen, we should have `best[i] = best[dec[0]] + nums[i]`.  \\n\\nIn this way, we can populate`best` in linear time and the answer is `best[-1]`.\\n\\n<br />\\n\\n**Complexity**\\n\\nTime complexity: `O(N)`\\nSpace complexity: `O(N)`\\n\\n<br />\\n\\n**Python**\\n```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        \\n        n = len(nums)\\n        best = [0] * n\\n        best[0] = nums[0]\\n        dec = collections.deque([0])\\n        \\n        for i in range(1, n):\\n            # lazy deletion\\n            if dec[0] < i - k:\\n                dec.popleft()\\n            # calculate the best score up until i\\n            best[i] = best[dec[0]] + nums[i]\\n            # maintain the mono dec deque\\n            while dec and best[dec[-1]] <= best[i]:\\n                dec.pop()\\n            dec.append(i)\\n            \\n        return best[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        \\n        n = len(nums)\\n        best = [0] * n\\n        best[0] = nums[0]\\n        dec = collections.deque([0])\\n        \\n        for i in range(1, n):\\n            # lazy deletion\\n            if dec[0] < i - k:\\n                dec.popleft()\\n            # calculate the best score up until i\\n            best[i] = best[dec[0]] + nums[i]\\n            # maintain the mono dec deque\\n            while dec and best[dec[-1]] <= best[i]:\\n                dec.pop()\\n            dec.append(i)\\n            \\n        return best[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046750,
                "title": "c-all-3-approaches-recursion-dp-and-deque",
                "content": "APPROACH 1: using recursion (TLE)\\n```\\nclass Solution {\\npublic:\\n    int recur(vector<int> nums,int k,int index){\\n        if(index==0) return nums[0];\\n        int a=max(index-k,0);\\n        int g=INT_MIN;\\n        for(int i=index-1;i>=a;i--){\\n            int b=recur(nums,k,i);\\n            g=max(g,b);\\n        }\\n        return g+nums[index];\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        int index=nums.size();\\n        int l=recur(nums,k,index-1);\\n        return l;\\n    }\\n};\\n```\\n\\nAPPROACH 2: using dp (TLE)\\n```\\nclass Solution {\\npublic:\\n    int recur(vector<int> nums,int k,int index,vector<int>& dp){\\n        if(index==0) return nums[0];\\n        if(dp[index]!=INT_MIN) return dp[index];\\n        int a=max(index-k,0);\\n        int g=INT_MIN;\\n        for(int i=index-1;i>=a;i--){\\n            int b;\\n            if(dp[i]!=INT_MIN) b=dp[i];\\n            else b=recur(nums,k,i,dp);\\n            g=max(g,b);\\n        }\\n        dp[index]=g+nums[index];\\n        return g+nums[index];\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        int index=nums.size();\\n        vector<int> dp(index,INT_MIN);\\n        dp[0]=nums[0];\\n        int l=recur(nums,k,index-1,dp);\\n        return l;\\n    }\\n};\\n```\\n\\nAPPROACH 3: USING DEQUE (Accepted )\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        deque<int> dq;\\n        dq.push_front(0);\\n        for(int i=1;i<n;i++){\\n             if(i-k-1==dq.front()) dq.pop_front();\\n            nums[i]+=nums[dq.front()];\\n            while(!dq.empty() && nums[dq.back()]<nums[i]) dq.pop_back();\\n            dq.push_back(i);\\n        }\\n        // for(int i=0;i<n;i++) cout<<nums[i]<<endl;\\n        return nums[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int recur(vector<int> nums,int k,int index){\\n        if(index==0) return nums[0];\\n        int a=max(index-k,0);\\n        int g=INT_MIN;\\n        for(int i=index-1;i>=a;i--){\\n            int b=recur(nums,k,i);\\n            g=max(g,b);\\n        }\\n        return g+nums[index];\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        int index=nums.size();\\n        int l=recur(nums,k,index-1);\\n        return l;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int recur(vector<int> nums,int k,int index,vector<int>& dp){\\n        if(index==0) return nums[0];\\n        if(dp[index]!=INT_MIN) return dp[index];\\n        int a=max(index-k,0);\\n        int g=INT_MIN;\\n        for(int i=index-1;i>=a;i--){\\n            int b;\\n            if(dp[i]!=INT_MIN) b=dp[i];\\n            else b=recur(nums,k,i,dp);\\n            g=max(g,b);\\n        }\\n        dp[index]=g+nums[index];\\n        return g+nums[index];\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        int index=nums.size();\\n        vector<int> dp(index,INT_MIN);\\n        dp[0]=nums[0];\\n        int l=recur(nums,k,index-1,dp);\\n        return l;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        deque<int> dq;\\n        dq.push_front(0);\\n        for(int i=1;i<n;i++){\\n             if(i-k-1==dq.front()) dq.pop_front();\\n            nums[i]+=nums[dq.front()];\\n            while(!dq.empty() && nums[dq.back()]<nums[i]) dq.pop_back();\\n            dq.push_back(i);\\n        }\\n        // for(int i=0;i<n;i++) cout<<nums[i]<<endl;\\n        return nums[n-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2263903,
                "title": "why-i-am-getting-wrong-answer-on-this-test-case-please-help",
                "content": "i know i will get TLE but why am i getting wrong answer on the below test case.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<int> dp(nums.size()+k , 0);\\n        for(int i = n - 1 ; i >= 0 ; i--)\\n        {\\n            int a = INT_MIN;\\n            for(int j = 1  ; j <= k ; j++ )\\n            {\\n                a = max(a , nums[i] + dp[i+j]);\\n            }\\n            dp[i] = a;\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n\\n\\nTest case : \\n[-5582,-5317,6711,-639,1001,1845,1728,-4575,-6066,-7770,128,-3254,7281,3966,6857,5477,8968,-1771,9986,-6267,9010,-764,8413,-8154,1087,-1107,4183,3033,58,659,4625,2825,5031,6811,5657,3229,8597,-5772,8869,5723,2960,4040,7222,4841,-1014,581,-2830,3881,-3800,577,-7396,-611,-6944,8461,3294,6297,9713,-2246,-3441,3831,-5754,6716,6040,-6715,5763,8611,5412,-7630,6216,260,2595,6852,-8956,2101,6722,1579,3820,7827,-3369,7144,1974,7310,-5369,-6755,3010,5789,1563,-3330,5373,-2770,4503,-4065,8177,-3333,-4726,-2131,2763,9012,-4755,2382,3642,-5284,-7174,-9815,6392,9729,-1943,-8749,5343,1036,8508,1484,919,4225,3733,8036,-6346,-2088,475,9378,4271,-5906,9327,9399,-1582,3845,3499,-8912,-4671,-1143,-5081,-1621,-1287,5995,4963,5071,5118,-1966,-6249,663,-2296,-8148,-4668,-6919,334,-6609,2888,-4161,118,-1867,5629,8588,-5325,-7853,-4868,-1487,-6544,-9697,-7038,6422,-5545,3376,-8656,8800,-7698,-2928,2279,-9739,4198,6236,-9087,9010,-9894,2145,7353,-92,3205,5431,5913,1619,-250,4728,-7164,-5619,-4721,-9284,-9645,146,7131,-6501,4261,2016,2880,4944,-8768,-6339,-3574,539,4633,9188,7227,-1549,9271,7110,5706,4968,-1275,5545,-5844,-1985,9560,1560,4630,3169,6076,-9433,7007,9927,-8385,-4557,-114,9543,2884,8978,-6447,3664,-7499,-4643,-5993,-5321,3250,-2945,6216,-1606,5569,7326,-6027,9723,-6997,-543,-8298,-4647,2563,1493,9574,1087,-9433,-7749,-7159,-2682,6626,2787,-2845,-7907,-223,-8142,-5403,-3460,-2534,5289,999,9404,-1958,641,4669,-2892,-2921,-7001,-1403,-2353,-7976,-5885,4958,-8117,8785,-654,5918,5533,8704,5827,-7478,-3696,2640,1612,-500,5694,-1973,5308,5272,3358,9190,4648,-7836,658,-3407,6733,1061,-2010,-2707,-1920,1272,3944,-6537,-6090,-7429,-640,836,1904,-4031,814,-1886,8040,-8312,-9407,-1395,-9944,-2074,-6814,2672,1360,8990,5465,-2131,3838,799,-3472,1086,-583,6302,3032,9138,-7778,4538,-5337,2087,2870,-3005,3401,122,-819,-8074,9630,-698,5326,2650,-9355,6487,3801,-3209,8293,662,-8318,-7863,-3814,-2557,-5685,-7952,6224,-7010,2935,5557,-1287,9528,-9218,-5108,-2085,17,4870,-8686,-8854,-9657,8848,-1883,-4535,83,9711,4593,-3440,-6938,3407,-6894,-6213,-883,4552,-731,1485,-7740,-3300,3897,-7629,-4076,7589,3142,-1010,2466,-592,-391,3961,-7049,7654,5758,6983,6048,-4369,-5878,3756,2940,9149,8625,8937,5706,6658,9213,-5226,284,-4524,-1577,-5296,6423,9977,-1805,5462,7587,476,-6424,976,-3925,8819,1821,3603,-842,-9618,-7130,-6253,2562,-7596,3522,6282,-3801,-3896,6924,441,5944,8535,1253,-6154,6872,-9548,-5358,1604,9593,-9256,-701,1023,-1446,-1307,-6809,9542,3673,1813,8717,-6847,-5289,5222,-7266,4231,218,-9633,-4696,5494,9681,1173,-4606,2174,-1155,-8595,-3640,-6550,-7003,4244,-2543,5241,2831,2690,8950,-6609,-9724,7562,-4096,8878,9962,7179,-1170,7826,-146,-2759,-5249,253,6206,3205,-7708,9448,4622,9260,-2853,2486,122,-8880,-769,-8922,648,7358,-6503,-6382,-4260,3988,-5107,-6363,2415,8563,-9070,-5026,2078,-2558,-2027,-7489,-4978,5024,4155,-9737,-221,9930,-9472,1052,-268,6221,2726,-1310,-8708,3482,-5488,-6506,5389,-7048,553,-886,2752,85,-3938,5940,-5112,5855,-7295,3735,2657,3269,6231,4771,3229,-2009,-5748,7256,746,-4301,752,-241,-6151,-2390,9911,825,-7679,-4960,-7224,-2739,-566,-5770,6774,6243,3166,-783,-4303,-9016,5555,-1866,-536,8872,-3927,4269,-3807,1933,9972,981,9256,6857,-208,3645,-3725,5961,1105,6320,-4702,-8419,-4904,-4935,8378,-2994,5831,5296,4730,-9170,-4229,-3911,-160,8757,-5301,-3775,1121,9434,-9880,2689,2340,-7879,3667,-5219,-6116,-1670,7595,6900,3990,4444,6385,-2924,8968,-2673,-6182,7503,5209,6030,802,-3464,1922,-8187,1617,4769,-4866,-3518,5830,3862,-7512,5236,-5164,6324,-5107,6864,-7364,-1375,5762,-275,4975,-7448,5719,-3162,-1546,-2776,-9411,-1845,-4913,-3474,2550,5643,-5527,2946,7158,1938,5125,-8015,2475,-1461,-4900,-5151,-4031,9362,8571,9815,-8438,-6519,1980,-8031,9615,7079,-3573,-883,4217,1079,5918,1767,8670,-5651,-6625,1057,7897,-7104,-4186,851,-6333,-4108,-3250,7899,9628,-6904,-3939,4587,1227,3813,-7449,-7692,-8098,-9813,8862,-2888,-1048,-3564,3074,1437,-2291,3974,3164,4921,-8958,9007,-3938,2042,7454,-910,-998,-4450,-1103,-237,8182,-1391,-4255,-3482,-2918,4053,2280,-7403,4319,-9457,7157,-6315,-7533,6309,2211,-9145,443,4255,-8847,-5557,-9089,1752,-5784,-2399,-8296,-8400,8170,4628,-4583,937,-7067,-3503,-549,-1194,1576,5004,-6963,-8837,5567,870,3954,5489,-8949,-7673,8542,-9040,-7689,-4171,-889,5552,-6836,-4393,513,3177,6664,-5646,2492,9421,-342,2570,8816,2869,-6820,-3389,-1903,-3332,138,6618,293,-9130,3503,-2327,-9728,7632,5881,540,9678,-7629,8804,-2816,7205,7473,-5518,7311,3457,9066,-1224,2097,7857,6612,186,6759,-4516,-3491,-8268,-8928,-7412,7162,6274,5463,2157,-4131,-7061,-8476,-5584,7300,-4348,-5940,-8592,-302,-5817,3151,-4124,1694,-5114,-3252,-2319,-2157,-293,7724,-5673,6105,9535,4333,6353,1290,8710,-5035,8995,-5865,9746,4708,-6387,-8937,3096,-9716,-7124,2531,-660,-4619,-8035,3747,-7821,8793,-727,8242,4957,-7175,4064,-9911,4995,9725,1634,-4275,788,-4920,3831,-3525,-4467,2909,-1200,5377,-4905,-3077,-1763,4443,-3518,3134,-5595,5409,5943,6757,3485,2883,-9261,-7221,654,2001,-926,7840,-5568,2715,-7053,-2082,-2005,7607,-9511,7545,7564,2380,-7257,1449,-3918,-3240,-1928,-6555,-4784,1550,2745,-5316]\\n56\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<int> dp(nums.size()+k , 0);\\n        for(int i = n - 1 ; i >= 0 ; i--)\\n        {\\n            int a = INT_MIN;\\n            for(int j = 1  ; j <= k ; j++ )\\n            {\\n                a = max(a , nums[i] + dp[i+j]);\\n            }\\n            dp[i] = a;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262803,
                "title": "c-dp-monotonic-deque-o-n-time-and-o-k-space",
                "content": "The problem with using a standard 1-D DP approach is that for i-th step we need to find the best choice in the next k steps i.e. search for max in range [i, max(i+k,n-1)] on average this is a O(K) problem and hence, 1-D Dp will get a complexity of O(NK). To overcome this I\\'ve used a standard technique that computes in amortized O(N) the max element that\\'d be present in the range [i, max(i+k,n-1)] using monotonic Deque. The code\\'s pretty elegant and works fast.\\n```\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        //vector<int> dp(n,0);\\n        //vector<bool> set(n, false);\\n        deque<pair<int,int>> mq;\\n        mq.push_back({nums[n-1],n-1});\\n        if (n == 1){\\n            return nums[n-1];\\n        }\\n        for(int i = n-2; i >= 0; i--){\\n             while( (mq.front()).second > i + k){\\n                 mq.pop_front();\\n             }\\n            int cur = nums[i] + (mq.front()).first;\\n            while(!mq.empty() && cur > (mq.back()).first){\\n                mq.pop_back();\\n            }\\n            mq.push_back({cur, i});\\n            if (i == 0) return cur;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Monotonic Queue"
                ],
                "code": "```\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        //vector<int> dp(n,0);\\n        //vector<bool> set(n, false);\\n        deque<pair<int,int>> mq;\\n        mq.push_back({nums[n-1],n-1});\\n        if (n == 1){\\n            return nums[n-1];\\n        }\\n        for(int i = n-2; i >= 0; i--){\\n             while( (mq.front()).second > i + k){\\n                 mq.pop_front();\\n             }\\n            int cur = nums[i] + (mq.front()).first;\\n            while(!mq.empty() && cur > (mq.back()).first){\\n                mq.pop_back();\\n            }\\n            mq.push_back({cur, i});\\n            if (i == 0) return cur;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2260617,
                "title": "tabulation-priorityqueue",
                "content": "Instead of checking every j for every i, keep track of the largest dp[i] values in a heap and calculate dp[i] from right to left. When the largest value in the heap is out of bounds of the current index, remove it and keep checking.\\n```\\nclass Solution {\\n    class Pair implements Comparable<Pair>{\\n        int value;\\n        int index;\\n        Pair(int value, int index){\\n            this.value = value;\\n            this.index = index;\\n        }\\n        public int compareTo(Pair obj){\\n            return Integer.compare(obj.value, this.value);}\\n    }\\n    public int maxResult(int[] nums, int k) {\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        int[] dp = new int[nums.length];\\n        dp[nums.length-1] = nums[nums.length-1];\\n        pq.add(new Pair(nums[nums.length-1],nums.length-1));\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(pq.peek().index<=i+k){\\n                dp[i] = nums[i]+ pq.peek().value;\\n                pq.add(new Pair(dp[i], i));\\n            }\\n            else{\\n                while(pq.peek().index > i+k){\\n                    pq.poll();\\n                }\\n                dp[i] = nums[i]+ pq.peek().value;\\n                pq.add(new Pair(dp[i], i));\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```\\nTime complexity: ***O(n * alpha(1))***\\nSpace: ***O(n + k)*** can be optimise to ***O(k)***",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    class Pair implements Comparable<Pair>{\\n        int value;\\n        int index;\\n        Pair(int value, int index){\\n            this.value = value;\\n            this.index = index;\\n        }\\n        public int compareTo(Pair obj){\\n            return Integer.compare(obj.value, this.value);}\\n    }\\n    public int maxResult(int[] nums, int k) {\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        int[] dp = new int[nums.length];\\n        dp[nums.length-1] = nums[nums.length-1];\\n        pq.add(new Pair(nums[nums.length-1],nums.length-1));\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(pq.peek().index<=i+k){\\n                dp[i] = nums[i]+ pq.peek().value;\\n                pq.add(new Pair(dp[i], i));\\n            }\\n            else{\\n                while(pq.peek().index > i+k){\\n                    pq.poll();\\n                }\\n                dp[i] = nums[i]+ pq.peek().value;\\n                pq.add(new Pair(dp[i], i));\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259022,
                "title": "easy-c-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        priority_queue<pair<int, int>> maxJumps;\\n        int n = nums.size()-1;\\n        maxJumps.push({nums[n], n});\\n        for(int i=n-1; i>=0; --i){\\n            while(maxJumps.size() and maxJumps.top().second-i>k) maxJumps.pop();\\n            nums[i] += maxJumps.top().first;\\n            maxJumps.push({nums[i],i});\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        priority_queue<pair<int, int>> maxJumps;\\n        int n = nums.size()-1;\\n        maxJumps.push({nums[n], n});\\n        for(int i=n-1; i>=0; --i){\\n            while(maxJumps.size() and maxJumps.top().second-i>k) maxJumps.pop();\\n            nums[i] += maxJumps.top().first;\\n            maxJumps.push({nums[i],i});\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258981,
                "title": "python-multiple-solution-1000-ms-fast-solution",
                "content": "Using Deque:\\n\\n\\t\\t\\n\\tclass Solution:\\n\\t\\tdef maxResult(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tdeq = deque([n-1])\\n\\t\\t\\tfor i in range(n-2, -1, -1):\\n\\t\\t\\t\\tif deq[0] - i > k: deq.popleft()\\n\\t\\t\\t\\tnums[i] += nums[deq[0]]\\n\\t\\t\\t\\twhile len(deq) and nums[deq[-1]] <= nums[i]: deq.pop()\\n\\t\\t\\t\\tdeq.append(i)\\n\\t\\t\\treturn nums[0]\\n\\t\\t\\t\\n\\t\\t\\t\\nDeque Another approach: \\n\\n\\tclass Solution:\\n\\t\\tdef maxResult(self, A: List[int], k: int) -> int:\\n\\t\\t\\tlog = deque([(0, -k)])\\n\\t\\t\\tfor i, a in enumerate(A):\\n\\t\\t\\t\\tif i - log[0][1] > k:\\n\\t\\t\\t\\t\\tlog.popleft()\\n\\t\\t\\t\\ta += log[0][0]\\n\\t\\t\\t\\twhile log and log[-1][0] <= a:\\n\\t\\t\\t\\t\\tlog.pop()\\n\\t\\t\\t\\tlog.append((a, i))\\n\\t\\t\\treturn a\\n\\t\\t\\t\\nHeap Approach:\\n\\n\\t\\t\\timport heapq\\n\\n\\t\\t\\tclass Solution:\\n\\t\\t\\t\\tdef maxResult(self, nums: List[int], k: int) -> int:\\n\\t\\t\\t\\t\\tn = len(nums)\\n\\t\\t\\t\\t\\tD = [-float(\\'inf\\')] * (n)\\n\\t\\t\\t\\t\\theap = [(-nums[0], 0)]\\n\\t\\t\\t\\t\\tD[0] = nums[0]   \\n\\t\\t\\t\\t\\tfor i in range(1,n):\\n\\t\\t\\t\\t\\t\\t(maxValue, index) = heap[0]            \\n\\t\\t\\t\\t\\t\\twhile index < i - k:\\n\\t\\t\\t\\t\\t\\t\\theapq.heappop(heap)\\n\\t\\t\\t\\t\\t\\t\\t(maxValue, index) = heap[0]\\n\\n\\t\\t\\t\\t\\t\\tD[i] = -maxValue + nums[i]\\n\\t\\t\\t\\t\\t\\theapq.heappush(heap, (-D[i], i))\\n\\n\\t\\t\\t\\t\\treturn D[n-1]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "Using Deque:\\n\\n\\t\\t\\n\\tclass Solution:\\n\\t\\tdef maxResult(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tdeq = deque([n-1])\\n\\t\\t\\tfor i in range(n-2, -1, -1):\\n\\t\\t\\t\\tif deq[0] - i > k: deq.popleft()\\n\\t\\t\\t\\tnums[i] += nums[deq[0]]\\n\\t\\t\\t\\twhile len(deq) and nums[deq[-1]] <= nums[i]: deq.pop()\\n\\t\\t\\t\\tdeq.append(i)\\n\\t\\t\\treturn nums[0]\\n\\t\\t\\t\\n\\t\\t\\t\\nDeque Another approach: \\n\\n\\tclass Solution:\\n\\t\\tdef maxResult(self, A: List[int], k: int) -> int:\\n\\t\\t\\tlog = deque([(0, -k)])\\n\\t\\t\\tfor i, a in enumerate(A):\\n\\t\\t\\t\\tif i - log[0][1] > k:\\n\\t\\t\\t\\t\\tlog.popleft()\\n\\t\\t\\t\\ta += log[0][0]\\n\\t\\t\\t\\twhile log and log[-1][0] <= a:\\n\\t\\t\\t\\t\\tlog.pop()\\n\\t\\t\\t\\tlog.append((a, i))\\n\\t\\t\\treturn a\\n\\t\\t\\t\\nHeap Approach:\\n\\n\\t\\t\\timport heapq\\n\\n\\t\\t\\tclass Solution:\\n\\t\\t\\t\\tdef maxResult(self, nums: List[int], k: int) -> int:\\n\\t\\t\\t\\t\\tn = len(nums)\\n\\t\\t\\t\\t\\tD = [-float(\\'inf\\')] * (n)\\n\\t\\t\\t\\t\\theap = [(-nums[0], 0)]\\n\\t\\t\\t\\t\\tD[0] = nums[0]   \\n\\t\\t\\t\\t\\tfor i in range(1,n):\\n\\t\\t\\t\\t\\t\\t(maxValue, index) = heap[0]            \\n\\t\\t\\t\\t\\t\\twhile index < i - k:\\n\\t\\t\\t\\t\\t\\t\\theapq.heappop(heap)\\n\\t\\t\\t\\t\\t\\t\\t(maxValue, index) = heap[0]\\n\\n\\t\\t\\t\\t\\t\\tD[i] = -maxValue + nums[i]\\n\\t\\t\\t\\t\\t\\theapq.heappush(heap, (-D[i], i))\\n\\n\\t\\t\\t\\t\\treturn D[n-1]",
                "codeTag": "Java"
            },
            {
                "id": 2258486,
                "title": "c-solution-o-n-priority-queue",
                "content": "```C#\\npublic class Solution {\\n    public int MaxResult(int[] nums, int k) {\\n        var comp = Comparer<int>.Create((x,y) => x.CompareTo(y) * -1);\\n        PriorityQueue<int, int> pq = new PriorityQueue<int, int>(comp);\\n        \\n        int lastSum = 0;\\n        for (int i = 0; i < nums.Length; i++) {\\n            int p = 0;\\n            while (pq.TryPeek(out int el, out p) && el < i - k) pq.Dequeue();\\n            \\n            lastSum = nums[i] + p;\\n            pq.Enqueue(i, lastSum);\\n        }\\n        \\n        return lastSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int MaxResult(int[] nums, int k) {\\n        var comp = Comparer<int>.Create((x,y) => x.CompareTo(y) * -1);\\n        PriorityQueue<int, int> pq = new PriorityQueue<int, int>(comp);\\n        \\n        int lastSum = 0;\\n        for (int i = 0; i < nums.Length; i++) {\\n            int p = 0;\\n            while (pq.TryPeek(out int el, out p) && el < i - k) pq.Dequeue();\\n            \\n            lastSum = nums[i] + p;\\n            pq.Enqueue(i, lastSum);\\n        }\\n        \\n        return lastSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258026,
                "title": "c-simple-intution-space-optimized-dp-used-single-variable-using-priority-queue-max-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& v, int k) {\\n        int score = v[0], n = v.size();\\n        priority_queue<pair<int,int>> pq; // store the {score using current value and the max score so far in the range of k, current index}\\n        pq.push({v[0],0});\\n        \\n        for(int i=1; i<n; i++) {\\n            while(!pq.empty() && pq.top().second+k < i) pq.pop();\\n            score = v[i] + pq.top().first;\\n            pq.push({score, i});\\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& v, int k) {\\n        int score = v[0], n = v.size();\\n        priority_queue<pair<int,int>> pq; // store the {score using current value and the max score so far in the range of k, current index}\\n        pq.push({v[0],0});\\n        \\n        for(int i=1; i<n; i++) {\\n            while(!pq.empty() && pq.top().second+k < i) pq.pop();\\n            score = v[i] + pq.top().first;\\n            pq.push({score, i});\\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257602,
                "title": "java-solution-12ms-faster-than-98",
                "content": "\\n***UPVOTE THIS IF IT HELPS YOU***\\n\\n\\n```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        int n = nums.length, a = 0, b = 0;\\n        int[] deq = new int[n];\\n        deq[0] = n - 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (deq[a] - i > k) a++;\\n            nums[i] += nums[deq[a]];\\n            while (b >= a && nums[deq[b]] <= nums[i]) b--;\\n            deq[++b] = i;\\n        }\\n        return nums[0];\\n    }\\n}\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e87d7079-32c3-4c82-b748-1bacb7a54cbe_1657350516.541222.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        int n = nums.length, a = 0, b = 0;\\n        int[] deq = new int[n];\\n        deq[0] = n - 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (deq[a] - i > k) a++;\\n            nums[i] += nums[deq[a]];\\n            while (b >= a && nums[deq[b]] <= nums[i]) b--;\\n            deq[++b] = i;\\n        }\\n        return nums[0];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257389,
                "title": "dp-solution-priority-queue-starting-from-last-index",
                "content": "\\n```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        \\n        n=len(nums)\\n        dp=[-float(\\'inf\\')]*n\\n        \\n        dp[n-1]=nums[-1]\\n        p_q=[[-dp[n-1],n-1]]\\n        heapq.heapify(p_q)\\n        \\n        for i in range(n-2,-1,-1):\\n            while p_q[0][1]>(i+k):\\n                heapq.heappop(p_q)\\n                \\n            dp[i]=nums[i]-p_q[0][0]\\n            heapq.heappush(p_q,[-dp[i],i])\\n                \\n        return dp[0]\\n        \\n```\\n\\nKindly upvote this solution, if you find it useful on any level",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        \\n        n=len(nums)\\n        dp=[-float(\\'inf\\')]*n\\n        \\n        dp[n-1]=nums[-1]\\n        p_q=[[-dp[n-1],n-1]]\\n        heapq.heapify(p_q)\\n        \\n        for i in range(n-2,-1,-1):\\n            while p_q[0][1]>(i+k):\\n                heapq.heappop(p_q)\\n                \\n            dp[i]=nums[i]-p_q[0][0]\\n            heapq.heappush(p_q,[-dp[i],i])\\n                \\n        return dp[0]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257212,
                "title": "easy-c-solution-dp-multiset",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        multiset<int, greater<int>> st;\\n        \\n        vector<int> dp(n, 0);\\n        dp[n - 1] = nums[n - 1];\\n        st.insert(nums[n - 1]);\\n        \\n        for(int i = n - 2; i >= 0; i--) {\\n            if(i >= n - k - 1) {\\n                dp[i] = *(st.begin()) + nums[i];\\n                st.insert(dp[i]);\\n            }\\n            else {\\n                auto itr = st.find(dp[i + k + 1]);\\n                if(itr != st.end()){\\n                    st.erase(itr);\\n                }\\n                \\n                dp[i] = *(st.begin()) + nums[i];\\n                st.insert(dp[i]);\\n            }\\n        }\\n        \\n        // for(int i = 0; i < n; i++)\\n        //     cout << dp[i] << \" \";\\n        // cout << endl;\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        multiset<int, greater<int>> st;\\n        \\n        vector<int> dp(n, 0);\\n        dp[n - 1] = nums[n - 1];\\n        st.insert(nums[n - 1]);\\n        \\n        for(int i = n - 2; i >= 0; i--) {\\n            if(i >= n - k - 1) {\\n                dp[i] = *(st.begin()) + nums[i];\\n                st.insert(dp[i]);\\n            }\\n            else {\\n                auto itr = st.find(dp[i + k + 1]);\\n                if(itr != st.end()){\\n                    st.erase(itr);\\n                }\\n                \\n                dp[i] = *(st.begin()) + nums[i];\\n                st.insert(dp[i]);\\n            }\\n        }\\n        \\n        // for(int i = 0; i < n; i++)\\n        //     cout << dp[i] << \" \";\\n        // cout << endl;\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2257072,
                "title": "priority-queue-o-n-sliding-window-java",
                "content": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        PriorityQueue<int[]> pq=new PriorityQueue<int[]>((a,b)->b[0]-a[0]);\\n        pq.add(new int[]{nums[0],0});\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            while(pq.peek()[1]<(i-k))\\n                pq.poll();\\n            pq.add(new int[]{res=nums[i]+pq.peek()[0],i});\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        PriorityQueue<int[]> pq=new PriorityQueue<int[]>((a,b)->b[0]-a[0]);\\n        pq.add(new int[]{nums[0],0});\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            while(pq.peek()[1]<(i-k))\\n                pq.poll();\\n            pq.add(new int[]{res=nums[i]+pq.peek()[0],i});\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256990,
                "title": "optimised-tabulation",
                "content": "```\\nclass Solution {\\npublic:\\n    //memoization\\n   /* int f(vector<int> & nums,int k,int i,vector<int> & dp,int n){\\n        if(i==nums.size()-1)\\n            return nums[i];\\n        if(i>=nums.size())\\n            return INT_MIN;\\n            \\n        if(dp[i]!=-1)\\n            return dp[i];\\n        int ma=INT_MIN;\\n        for(int j=i+1;j<=min(n-1,i+k);j++){\\n            int take=nums[i]+f(nums,k,j,dp,n);\\n        \\n            ma=max(take,ma);\\n            \\n        }\\n      return  dp[i]=ma;\\n        \\n        \\n        \\n        \\n        \\n    }*/\\n    \\n    int maxResult(vector<int>& nums, int k) {\\n      int n= nums.size();\\n    vector<int>dp(n,-1);\\n        dp[n-1]=nums[n-1];\\n        priority_queue<pair<int,int>>pq;\\n        pq.push({dp[n-1],n-1});\\n    \\n        for(int i=n-2;i>=0;i--){\\n            \\n            while(!pq.empty() and pq.top().second>i+k)\\n                pq.pop();\\n            dp[i]=nums[i]+pq.top().first;\\n            pq.push({dp[i],i});\\n            \\n            \\n            \\n         \\n            \\n            \\n            \\n            \\n        }\\n        \\n        \\n        return dp[0];\\n        \\n        \\n        \\n    \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //memoization\\n   /* int f(vector<int> & nums,int k,int i,vector<int> & dp,int n){\\n        if(i==nums.size()-1)\\n            return nums[i];\\n        if(i>=nums.size())\\n            return INT_MIN;\\n            \\n        if(dp[i]!=-1)\\n            return dp[i];\\n        int ma=INT_MIN;\\n        for(int j=i+1;j<=min(n-1,i+k);j++){\\n            int take=nums[i]+f(nums,k,j,dp,n);\\n        \\n            ma=max(take,ma);\\n            \\n        }\\n      return  dp[i]=ma;\\n        \\n        \\n        \\n        \\n        \\n    }*/\\n    \\n    int maxResult(vector<int>& nums, int k) {\\n      int n= nums.size();\\n    vector<int>dp(n,-1);\\n        dp[n-1]=nums[n-1];\\n        priority_queue<pair<int,int>>pq;\\n        pq.push({dp[n-1],n-1});\\n    \\n        for(int i=n-2;i>=0;i--){\\n            \\n            while(!pq.empty() and pq.top().second>i+k)\\n                pq.pop();\\n            dp[i]=nums[i]+pq.top().first;\\n            pq.push({dp[i],i});\\n            \\n            \\n            \\n         \\n            \\n            \\n            \\n            \\n        }\\n        \\n        \\n        return dp[0];\\n        \\n        \\n        \\n    \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256913,
                "title": "easy-priority-queue-solution",
                "content": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n    int n = nums.length, res = nums[0];\\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n    pq.add(new int[] { nums[0], 0 });\\n    for(int i = 1; i < n; i++) {\\n        while(pq.peek()[1] < i - k) pq.poll();\\n        pq.add(new int[] { res = pq.peek()[0] + nums[i], i });\\n    }\\n    return res;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n    int n = nums.length, res = nums[0];\\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n    pq.add(new int[] { nums[0], 0 });\\n    for(int i = 1; i < n; i++) {\\n        while(pq.peek()[1] < i - k) pq.poll();\\n        pq.add(new int[] { res = pq.peek()[0] + nums[i], i });\\n    }\\n    return res;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2157913,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& A, int k) {\\n        int n = A.size();\\n        deque<int> q{n-1};\\n        for(int i = n - 2; i >= 0; i--) {\\n            A[i] += A[q.front()];\\n            if(q.front() == i + k) q.pop_front(); \\n            while(!q.empty() && A[q.back()] <= A[i]) q.pop_back();\\n            q.push_back(i);\\n        }\\n        return A[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& A, int k) {\\n        int n = A.size();\\n        deque<int> q{n-1};\\n        for(int i = n - 2; i >= 0; i--) {\\n            A[i] += A[q.front()];\\n            if(q.front() == i + k) q.pop_front(); \\n            while(!q.empty() && A[q.back()] <= A[i]) q.pop_back();\\n            q.push_back(i);\\n        }\\n        return A[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548618,
                "title": "c-solution-dp-and-deque-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<long long> dp(n,0);\\n        deque<long long> dq;\\n        dq.push_back(0);\\n        dp[0]=nums[0];\\n        \\n        for(int i=1;i<min(k,n);i++)\\n        {\\n            dp[i]=nums[i]+dp[dq.front()];\\n            \\n            while(!dq.empty()&&dp[dq.back()]<=dp[i]) dq.pop_back();\\n            dq.push_back(i);\\n        }\\n        \\n        for(int i=k;i<n;i++)\\n        {\\n            dp[i]=nums[i]+dp[dq.front()];\\n            \\n            while(!dq.empty()&&dp[dq.back()]<=dp[i]) dq.pop_back();\\n            dq.push_back(i);\\n            \\n             if(dq.front()==i-k) dq.pop_front();\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<long long> dp(n,0);\\n        deque<long long> dq;\\n        dq.push_back(0);\\n        dp[0]=nums[0];\\n        \\n        for(int i=1;i<min(k,n);i++)\\n        {\\n            dp[i]=nums[i]+dp[dq.front()];\\n            \\n            while(!dq.empty()&&dp[dq.back()]<=dp[i]) dq.pop_back();\\n            dq.push_back(i);\\n        }\\n        \\n        for(int i=k;i<n;i++)\\n        {\\n            dp[i]=nums[i]+dp[dq.front()];\\n            \\n            while(!dq.empty()&&dp[dq.back()]<=dp[i]) dq.pop_back();\\n            dq.push_back(i);\\n            \\n             if(dq.front()==i-k) dq.pop_front();\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496588,
                "title": "c-no-dp",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int maxsum = nums[n - 1];\\n        priority_queue<pair<int, int>> pq;\\n        pq.push(make_pair(nums[n - 1], n - 1));\\n        for(int i = n - 2; i >= 0; i--){\\n           while(pq.size() != 0 && (pq.top().second - i) > k) pq.pop();\\n           maxsum = nums[i] + pq.top().first;\\n           pq.push(make_pair(maxsum, i));\\n        }\\n        return maxsum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int maxsum = nums[n - 1];\\n        priority_queue<pair<int, int>> pq;\\n        pq.push(make_pair(nums[n - 1], n - 1));\\n        for(int i = n - 2; i >= 0; i--){\\n           while(pq.size() != 0 && (pq.top().second - i) > k) pq.pop();\\n           maxsum = nums[i] + pq.top().first;\\n           pq.push(make_pair(maxsum, i));\\n        }\\n        return maxsum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261804,
                "title": "java-priority-queue",
                "content": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        \\n        PriorityQueue<Pair> pq = new PriorityQueue();\\n        pq.add(new Pair(0, nums[0]));\\n        int max = nums[0];\\n        for(int i = 1;i<nums.length;i++){\\n            \\n            while(pq.peek().index <i-k){\\n                pq.poll();\\n            }\\n            \\n            max = pq.peek().val + nums[i];\\n            pq.add(new Pair(i,  max));\\n        }\\n        \\n        return max;\\n        \\n    }\\n    \\n    static class Pair implements Comparable<Pair>{\\n        int index;\\n        int val;\\n        \\n        Pair(int index, int val){\\n            this.index = index;\\n            this.val = val;\\n        }\\n        \\n        \\n        public int compareTo(Pair o){\\n            return o.val - this.val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        \\n        PriorityQueue<Pair> pq = new PriorityQueue();\\n        pq.add(new Pair(0, nums[0]));\\n        int max = nums[0];\\n        for(int i = 1;i<nums.length;i++){\\n            \\n            while(pq.peek().index <i-k){\\n                pq.poll();\\n            }\\n            \\n            max = pq.peek().val + nums[i];\\n            pq.add(new Pair(i,  max));\\n        }\\n        \\n        return max;\\n        \\n    }\\n    \\n    static class Pair implements Comparable<Pair>{\\n        int index;\\n        int val;\\n        \\n        Pair(int index, int val){\\n            this.index = index;\\n            this.val = val;\\n        }\\n        \\n        \\n        public int compareTo(Pair o){\\n            return o.val - this.val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261497,
                "title": "c-recur-memo-topdown-montonic-deque-interview-style",
                "content": "```\\n //Recur+Memo -> TLE : Time : O(N*K) after memoization\\nclass Solution {\\npublic:\\n    int maxScore = INT_MIN;\\n    int K;\\n    int n;\\n    unordered_map<int, int> mp;\\n\\n    int maxScoreUtilRecursionMemo(vector<int>& nums, int idx) {\\n        if(idx == n-1) {\\n            return nums[idx];\\n        }\\n        if(mp.find(idx) != mp.end())\\n            return mp[idx];\\n        \\n        int maxScore = INT_MIN;\\n        for(int i = idx+1; i<=min(idx+K, n-1); i++) {\\n            maxScore = max(maxScore, maxScoreUtilRecursionMemo(nums, i));\\n        }\\n        \\n        return mp[idx] = nums[idx] + maxScore;\\n    }\\n\\t\\n\\tint maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        K = k;\\n        return maxScoreUtilRecursionMemo(nums, 0);        \\n    }\\n};\\n```\\n\\n```\\n//DP -> TLE : Time : O(N*K) :For every index i, we find best element among\\n//elements at {i+1, i+2, ... i+k}\\nclass Solution {\\npublic:\\n    int maxScore = INT_MIN;\\n    int K;\\n    int n;\\n\\n    int maxScoreUtilBottomUp(vector<int>& nums) {\\n        vector<int> t(n, -1);\\n        //t[i] = maximum score to reach end from index i\\n        t[n-1] = nums[n-1];\\n        for(int i = n-2; i>=0; i--) {\\n            int maxNextStep = INT_MIN;\\n            for(int j = 1; j<=K; j++) {\\n                maxNextStep = max(maxNextStep, t[min(i+j, n-1)]);\\n            }\\n            \\n            t[i] = nums[i] + maxNextStep;\\n        }\\n        return t[0];\\n    }\\n\\t\\n\\tint maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        K = k;\\n        //return maxScoreUtilRecursionMemo(nums, 0, 0);\\n        //return maxScoreUtilBottomUp(nums);\\n        \\n        \\n        return maxScoreUtilOptimized(nums);   \\n    }\\n\\t\\n```\\n\\n```\\n//Accepted : O(N), we store the max element among k sized window\\n//in monotonic decreasing deque\\nclass Solution {\\npublic:\\n    int maxScore = INT_MIN;\\n    int K;\\n    int n;\\n\\t\\n    int maxScoreUtilOptimized(vector<int>& nums) {\\n        vector<int> t(n, -1);\\n        //t[i] = maximum score to reach end from index i\\n        t[n-1] = nums[n-1];\\n        \\n        deque<int> deq;\\n        \\n        deq.push_back(n-1);\\n        \\n        for(int i = n-2; i>=0; i--) {\\n            \\n            //first remove those(maximum values) who are out of index\\n            while(!deq.empty() && deq.front() > i+K)\\n                deq.pop_front();\\n            \\n            t[i] = nums[i] + t[deq.front()];\\n            \\n            //maintaining monotonic decreasing deque\\n            while(!deq.empty() && t[deq.back()] <= t[i]) {\\n                deq.pop_back();\\n            }\\n            deq.push_back(i);\\n        }\\n        return t[0];\\n    }\\n\\n    int maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        K = k;\\n               \\n        return maxScoreUtilOptimized(nums);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n //Recur+Memo -> TLE : Time : O(N*K) after memoization\\nclass Solution {\\npublic:\\n    int maxScore = INT_MIN;\\n    int K;\\n    int n;\\n    unordered_map<int, int> mp;\\n\\n    int maxScoreUtilRecursionMemo(vector<int>& nums, int idx) {\\n        if(idx == n-1) {\\n            return nums[idx];\\n        }\\n        if(mp.find(idx) != mp.end())\\n            return mp[idx];\\n        \\n        int maxScore = INT_MIN;\\n        for(int i = idx+1; i<=min(idx+K, n-1); i++) {\\n            maxScore = max(maxScore, maxScoreUtilRecursionMemo(nums, i));\\n        }\\n        \\n        return mp[idx] = nums[idx] + maxScore;\\n    }\\n\\t\\n\\tint maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        K = k;\\n        return maxScoreUtilRecursionMemo(nums, 0);        \\n    }\\n};\\n```\n```\\n//DP -> TLE : Time : O(N*K) :For every index i, we find best element among\\n//elements at {i+1, i+2, ... i+k}\\nclass Solution {\\npublic:\\n    int maxScore = INT_MIN;\\n    int K;\\n    int n;\\n\\n    int maxScoreUtilBottomUp(vector<int>& nums) {\\n        vector<int> t(n, -1);\\n        //t[i] = maximum score to reach end from index i\\n        t[n-1] = nums[n-1];\\n        for(int i = n-2; i>=0; i--) {\\n            int maxNextStep = INT_MIN;\\n            for(int j = 1; j<=K; j++) {\\n                maxNextStep = max(maxNextStep, t[min(i+j, n-1)]);\\n            }\\n            \\n            t[i] = nums[i] + maxNextStep;\\n        }\\n        return t[0];\\n    }\\n\\t\\n\\tint maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        K = k;\\n        //return maxScoreUtilRecursionMemo(nums, 0, 0);\\n        //return maxScoreUtilBottomUp(nums);\\n        \\n        \\n        return maxScoreUtilOptimized(nums);   \\n    }\\n\\t\\n```\n```\\n//Accepted : O(N), we store the max element among k sized window\\n//in monotonic decreasing deque\\nclass Solution {\\npublic:\\n    int maxScore = INT_MIN;\\n    int K;\\n    int n;\\n\\t\\n    int maxScoreUtilOptimized(vector<int>& nums) {\\n        vector<int> t(n, -1);\\n        //t[i] = maximum score to reach end from index i\\n        t[n-1] = nums[n-1];\\n        \\n        deque<int> deq;\\n        \\n        deq.push_back(n-1);\\n        \\n        for(int i = n-2; i>=0; i--) {\\n            \\n            //first remove those(maximum values) who are out of index\\n            while(!deq.empty() && deq.front() > i+K)\\n                deq.pop_front();\\n            \\n            t[i] = nums[i] + t[deq.front()];\\n            \\n            //maintaining monotonic decreasing deque\\n            while(!deq.empty() && t[deq.back()] <= t[i]) {\\n                deq.pop_back();\\n            }\\n            deq.push_back(i);\\n        }\\n        return t[0];\\n    }\\n\\n    int maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        K = k;\\n               \\n        return maxScoreUtilOptimized(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261225,
                "title": "go-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\nInspired by [this](https://leetcode.com/problems/jump-game-vi/discuss/978544/C%2B%2B-DP-%2B-Pruning-vs.-Monodeq) solution\\n```\\nfunc maxResult(nums []int, k int) int {\\n    \\tvar dq []int\\n\\tdq = append(dq, 0)\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tif dq[0]+k < i {\\n\\t\\t\\tdq = dq[1:]\\n\\t\\t}\\n\\t\\tnums[i] += nums[dq[0]]\\n\\t\\tfor len(dq) > 0 && nums[dq[len(dq)-1]] <= nums[i] {\\n\\t\\t\\tdq = dq[:len(dq)-1]\\n\\t\\t}\\n\\t\\tdq = append(dq, i)\\n\\t}\\n\\n\\treturn nums[len(nums)-1]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Queue"
                ],
                "code": "```\\nfunc maxResult(nums []int, k int) int {\\n    \\tvar dq []int\\n\\tdq = append(dq, 0)\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tif dq[0]+k < i {\\n\\t\\t\\tdq = dq[1:]\\n\\t\\t}\\n\\t\\tnums[i] += nums[dq[0]]\\n\\t\\tfor len(dq) > 0 && nums[dq[len(dq)-1]] <= nums[i] {\\n\\t\\t\\tdq = dq[:len(dq)-1]\\n\\t\\t}\\n\\t\\tdq = append(dq, i)\\n\\t}\\n\\n\\treturn nums[len(nums)-1]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261146,
                "title": "c-dp-deque",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        \\n        deque<pair<int,int>> q;\\n        q.push_back({arr[0],0});\\n        int dist[n];\\n        dist[0]=arr[0];\\n        for(int i=1;i<n;++i)\\n        {\\n            while(!q.empty() && (i-q.front().second)>k)\\n                q.pop_front();\\n            \\n            dist[i]=q.front().first+arr[i];\\n            \\n            while(!q.empty() && q.back().first<dist[i])\\n                q.pop_back();\\n            \\n            q.push_back({dist[i],i});\\n                \\n        }\\n        \\n        return dist[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        \\n        deque<pair<int,int>> q;\\n        q.push_back({arr[0],0});\\n        int dist[n];\\n        dist[0]=arr[0];\\n        for(int i=1;i<n;++i)\\n        {\\n            while(!q.empty() && (i-q.front().second)>k)\\n                q.pop_front();\\n            \\n            dist[i]=q.front().first+arr[i];\\n            \\n            while(!q.empty() && q.back().first<dist[i])\\n                q.pop_back();\\n            \\n            q.push_back({dist[i],i});\\n                \\n        }\\n        \\n        return dist[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261136,
                "title": "java-dp-dque-easy-to-understand-o-n",
                "content": "1. keep a dp array where dp[i] denotes the max score for ith element. then our answer will be ```dp[nums.length - 1]```\\n2. ```dp[i] = nums[i] + max(dp[j])  where j ranges from (i - k) --> i```\\n3. O(N*K) solution: we can run a double for loop. outer loop starting from i = 1, for each i, iterate inner loop i-k times to find max dp[i] value.\\n4. O(N) solution: let\\'s say ```k=3``` and  suppose at ith iteration, our dp array looks like  ```4, 1, 3```  .\\n for next iteration which is  ```i=3```, our max value will be let\\'s say ```6```. now for numbers in range ```i = 4 -  6``` we don\\'t need to dont actually care about dp values ```4,1, 3``` since they are already smaller. \\nexpanding on this idea we  can maintain a strictly decreasing queue. where first element is always the max and within k distance from the cur element. we insert the dp value from last and keep removing elements that are smaller than the cur value\\n\\n``` java\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        int dp[] = new int[nums.length];\\n        dp[0] = nums[0];\\n        Deque<int[]> queue = new ArrayDeque<>();\\n        queue.addLast(new int[]{0, dp[0]});\\n        \\n        for(int i = 1; i < nums.length; i++) {\\n\\t\\t\\t//remove all elements that more than k dist away\\n\\t\\t\\twhile(queue.peekFirst()[0] < i - k) {\\n                queue.pollFirst();\\n            }\\n\\t        //first element in the queue is always the max element\\t\\n            dp[i] = queue.peekFirst()[1] + nums[i];\\n\\t        \\n\\t\\t\\t//remove all elements from right that are smaller than cur element, \\n\\t\\t\\t//since they can never be used as max\\n            while(!queue.isEmpty() && queue.peekLast()[1] < dp[i]){\\n                queue.pollLast();\\n            }\\n            queue.addLast(new int[]{i, dp[i]});\\n        }\\n        \\n        return dp[nums.length - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```dp[nums.length - 1]```\n```dp[i] = nums[i] + max(dp[j])  where j ranges from (i - k) --> i```\n```k=3```\n```4, 1, 3```\n```i=3```\n```6```\n```i = 4 -  6```\n```4,1, 3```\n``` java\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        int dp[] = new int[nums.length];\\n        dp[0] = nums[0];\\n        Deque<int[]> queue = new ArrayDeque<>();\\n        queue.addLast(new int[]{0, dp[0]});\\n        \\n        for(int i = 1; i < nums.length; i++) {\\n\\t\\t\\t//remove all elements that more than k dist away\\n\\t\\t\\twhile(queue.peekFirst()[0] < i - k) {\\n                queue.pollFirst();\\n            }\\n\\t        //first element in the queue is always the max element\\t\\n            dp[i] = queue.peekFirst()[1] + nums[i];\\n\\t        \\n\\t\\t\\t//remove all elements from right that are smaller than cur element, \\n\\t\\t\\t//since they can never be used as max\\n            while(!queue.isEmpty() && queue.peekLast()[1] < dp[i]){\\n                queue.pollLast();\\n            }\\n            queue.addLast(new int[]{i, dp[i]});\\n        }\\n        \\n        return dp[nums.length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261111,
                "title": "rust-dp-solution",
                "content": "```rust\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn max_result(nums: Vec<i32>, k: i32) -> i32 {\\n\\t\\t// score[i] = max { score[i-k], ..., score[i-1] } + nums[i]\\n        // maintain a priority queue to reduce each score calc to O(logn) time\\n        // time: O(nlogn)\\n        // space: O(n)\\n        let n = nums.len();\\n        let k = k as usize;\\n        let mut score = nums[0];\\n        let mut pq = BinaryHeap::new();\\n        pq.push((nums[0], 0));\\n        for i in 1..n {\\n            while let Some(&(v, idx)) = pq.peek() {\\n                if idx + k < i {\\n                    pq.pop();\\n                    continue;\\n                }\\n                score = v + nums[i];\\n                pq.push((score, i));\\n                break;\\n            }\\n        }\\n        score\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```rust\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn max_result(nums: Vec<i32>, k: i32) -> i32 {\\n\\t\\t// score[i] = max { score[i-k], ..., score[i-1] } + nums[i]\\n        // maintain a priority queue to reduce each score calc to O(logn) time\\n        // time: O(nlogn)\\n        // space: O(n)\\n        let n = nums.len();\\n        let k = k as usize;\\n        let mut score = nums[0];\\n        let mut pq = BinaryHeap::new();\\n        pq.push((nums[0], 0));\\n        for i in 1..n {\\n            while let Some(&(v, idx)) = pq.peek() {\\n                if idx + k < i {\\n                    pq.pop();\\n                    continue;\\n                }\\n                score = v + nums[i];\\n                pq.push((score, i));\\n                break;\\n            }\\n        }\\n        score\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1260791,
                "title": "simple-javascript-dp",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxResult = function(nums, k) {\\n    let dp=[],kWindow=[];\\n    dp[0]=nums[0];\\n    kWindow[0]=0;//kWindow will store indexes for the valid range \\n    for(let i=1;i<nums.length;i++){\\n        if(i-kWindow[0]+1>k+1){//Remove first element if window from first element to i is greater than k\\n            kWindow.shift();\\n        }\\n        dp[i]=dp[kWindow[0]]+nums[i];\\n        while(kWindow.length>0 && dp[kWindow[kWindow.length-1]]<=dp[i]){//Remove all the elements starting from back of the kWindow which are less than dp[i], this way the first element of kWindow will remain the maximum one in the current window.\\n            kWindow.pop();\\n        }\\n        kWindow.push(i);\\n    }\\n    return dp[nums.length-1];\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxResult = function(nums, k) {\\n    let dp=[],kWindow=[];\\n    dp[0]=nums[0];\\n    kWindow[0]=0;//kWindow will store indexes for the valid range \\n    for(let i=1;i<nums.length;i++){\\n        if(i-kWindow[0]+1>k+1){//Remove first element if window from first element to i is greater than k\\n            kWindow.shift();\\n        }\\n        dp[i]=dp[kWindow[0]]+nums[i];\\n        while(kWindow.length>0 && dp[kWindow[kWindow.length-1]]<=dp[i]){//Remove all the elements starting from back of the kWindow which are less than dp[i], this way the first element of kWindow will remain the maximum one in the current window.\\n            kWindow.pop();\\n        }\\n        kWindow.push(i);\\n    }\\n    return dp[nums.length-1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1260778,
                "title": "explained-c-o-n-time-and-o-k-space-dp-monotonic-dequeue-sliding-window",
                "content": "Idea : ***check the last k elements from the current index and add the max score from those k to the current one***. \\n\\nSimple brute force way is to calculate max from last k at each iteration. \\n\\nOptimized version is to use a monotonic ***deque over a window of size k which keeps the max item from the last k window*** at front.\\n\\nItems from Deque are removed when - \\n*1. Current element at front of deque goes out of window; \\n2. Newly inserted element is bigger than the back element in Deque.*\\n\\nIt is straighforward to see that the deque is decreasing in nature (not strictly decreasing) and at any given time the max size is k.\\n\\nI also didn\\'t use a dp array since input can be reused. But if there is a restriction not to change input, then also we can just use a dp array of size O(k).\\n\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\t\\t\\n        deque<int> dq;\\n        dq.push_back(nums[0]);\\n\\t\\t\\n        for (int i = 1; i < n; i++) {      // O(n)\\n            int curMax = dq.front();       // Front at deque has the max score from the last k elements\\n            nums[i] += curMax;\\n            if (i - k >= 0 && dq.front() == nums[i - k])     // If current max is going out of window of size k, then remove it.\\n                dq.pop_front();\\n            while (!dq.empty() && nums[i] > dq.back())       // Remove all smaller elements from deque \\n                dq.pop_back();\\n            dq.push_back(nums[i]);\\n        }\\n        return nums[n-1];\\n    }\\n};\\n```\\n\\nTime : O(n) since we iterate just once over the whole input.\\nSpace : O(k) max k elements can be there in deque.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\t\\t\\n        deque<int> dq;\\n        dq.push_back(nums[0]);\\n\\t\\t\\n        for (int i = 1; i < n; i++) {      // O(n)\\n            int curMax = dq.front();       // Front at deque has the max score from the last k elements\\n            nums[i] += curMax;\\n            if (i - k >= 0 && dq.front() == nums[i - k])     // If current max is going out of window of size k, then remove it.\\n                dq.pop_front();\\n            while (!dq.empty() && nums[i] > dq.back())       // Remove all smaller elements from deque \\n                dq.pop_back();\\n            dq.push_back(nums[i]);\\n        }\\n        return nums[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1260493,
                "title": "c-easy-and-short-solution-using-priority-queue-explained",
                "content": "Here we just take max value from priority queue which is in the range i-k to i-1 and add current value to that. We first pop out values from priority queue having index less than i-k and then use top of our priority queue. \\nYou can dry run this on example testcase for better understanding. We can use same approach from right to left also.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>> q;\\n        q.push({nums[0],0});\\n        int cur=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            while(q.top().second<i-k) q.pop();\\n            cur=nums[i]+q.top().first;\\n            q.push({cur,i});\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>> q;\\n        q.push({nums[0],0});\\n        int cur=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            while(q.top().second<i-k) q.pop();\\n            cur=nums[i]+q.top().first;\\n            q.push({cur,i});\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194740,
                "title": "java-simple-and-easy-to-understand-solution-1-ms-faster-than-85-85-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        int n = nums.length;\\n        \\n        Deque<int[]> deque = new LinkedList();\\n        \\n        deque.addLast(new int[]{0, nums[0]});\\n        \\n        int maxScore = nums[0];\\n        \\n        for(int i = 1; i < n; i++){\\n            //remove all the index, from which  \\n            //not reachable to current index\\n            if(!deque.isEmpty() && deque.peekFirst()[0] < i - k){\\n                deque.pollFirst();\\n            }        \\n            \\n            //previous maximum score\\n            int score = deque.peekFirst()[1];\\n            \\n            //max score acheived to current index\\n            maxScore = nums[i] + score;\\n            \\n            //remove all the index which score is \\n            //less or equal to current index score\\n            while(!deque.isEmpty() && maxScore >= deque.peekLast()[1]){\\n                deque.pollLast();\\n            }\\n            \\n            deque.addLast(new int[]{i, maxScore});\\n        }\\n        \\n        \\n        return maxScore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        int n = nums.length;\\n        \\n        Deque<int[]> deque = new LinkedList();\\n        \\n        deque.addLast(new int[]{0, nums[0]});\\n        \\n        int maxScore = nums[0];\\n        \\n        for(int i = 1; i < n; i++){\\n            //remove all the index, from which  \\n            //not reachable to current index\\n            if(!deque.isEmpty() && deque.peekFirst()[0] < i - k){\\n                deque.pollFirst();\\n            }        \\n            \\n            //previous maximum score\\n            int score = deque.peekFirst()[1];\\n            \\n            //max score acheived to current index\\n            maxScore = nums[i] + score;\\n            \\n            //remove all the index which score is \\n            //less or equal to current index score\\n            while(!deque.isEmpty() && maxScore >= deque.peekLast()[1]){\\n                deque.pollLast();\\n            }\\n            \\n            deque.addLast(new int[]{i, maxScore});\\n        }\\n        \\n        \\n        return maxScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164637,
                "title": "javascript-o-n-time-dp-monoqueue-using-doubly-linked-list",
                "content": "Time: `O(N)`\\nSpace: `O(N)`\\n```javascript\\nclass Node {\\n    constructor(val) {\\n        this.val = val;\\n        this.next = null;\\n        this.prev = null;\\n    }\\n}\\n\\nclass DoublyLinkedList {\\n    constructor() {\\n        const dummy = new Node();\\n        this.head = dummy;\\n        this.tail = dummy;\\n        this.size = 0;\\n    }\\n    \\n    push(val) {\\n        const newNode = new Node(val);\\n        newNode.prev = this.tail;\\n        this.tail.next = newNode;\\n        this.tail = this.tail.next;\\n        this.size++;\\n    }\\n    \\n    pop() {\\n        this.tail = this.tail.prev;\\n        this.tail.next = null;\\n        this.size--;\\n    }\\n    \\n    shift() {\\n        this.head = this.head.next;\\n        this.head.prev = null;\\n        this.size--;\\n    }\\n    \\n    get peekHead() {\\n        return this.head.next.val;\\n    }\\n    \\n    get peekTail() {\\n        return this.tail.val;\\n    }\\n}\\n\\n\\nvar maxResult = function(nums, k) {\\n    const maxList = new DoublyLinkedList();\\n    maxList.push([nums[0], 0]);\\n    let start = 0;\\n    \\n    for(let i = 1; i < nums.length; i++) {\\n        const currSum = maxList.peekHead[0] + nums[i];\\n        while(maxList.size && currSum > maxList.peekTail[0]) maxList.pop();\\n        maxList.push([currSum, i]);\\n        \\n        if(i == start + k) {\\n            if(maxList.peekHead[1] == start) maxList.shift();\\n            start++;\\n        }\\n    }\\n    return maxList.peekTail[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Doubly-Linked List"
                ],
                "code": "```javascript\\nclass Node {\\n    constructor(val) {\\n        this.val = val;\\n        this.next = null;\\n        this.prev = null;\\n    }\\n}\\n\\nclass DoublyLinkedList {\\n    constructor() {\\n        const dummy = new Node();\\n        this.head = dummy;\\n        this.tail = dummy;\\n        this.size = 0;\\n    }\\n    \\n    push(val) {\\n        const newNode = new Node(val);\\n        newNode.prev = this.tail;\\n        this.tail.next = newNode;\\n        this.tail = this.tail.next;\\n        this.size++;\\n    }\\n    \\n    pop() {\\n        this.tail = this.tail.prev;\\n        this.tail.next = null;\\n        this.size--;\\n    }\\n    \\n    shift() {\\n        this.head = this.head.next;\\n        this.head.prev = null;\\n        this.size--;\\n    }\\n    \\n    get peekHead() {\\n        return this.head.next.val;\\n    }\\n    \\n    get peekTail() {\\n        return this.tail.val;\\n    }\\n}\\n\\n\\nvar maxResult = function(nums, k) {\\n    const maxList = new DoublyLinkedList();\\n    maxList.push([nums[0], 0]);\\n    let start = 0;\\n    \\n    for(let i = 1; i < nums.length; i++) {\\n        const currSum = maxList.peekHead[0] + nums[i];\\n        while(maxList.size && currSum > maxList.peekTail[0]) maxList.pop();\\n        maxList.push([currSum, i]);\\n        \\n        if(i == start + k) {\\n            if(maxList.peekHead[1] == start) maxList.shift();\\n            start++;\\n        }\\n    }\\n    return maxList.peekTail[0];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979001,
                "title": "java-dp-with-priorityqueue",
                "content": "First move from top down recursive approach to botton up thinking and come up with this recurence relation\\nscore[i] = nums[i] + max(score[i-k], ..., score[i-1]) \\nusing linear scan for max will cause the time complexity O(nk) \\nuse maxheap or segment tree for getting maximum in the range i-1 to i-k in O(logk) time\\nfurther you can optimise using a sliding window (dequeu based impl)\\n\\n```\\npublic int maxResult(int[] nums, int k) {\\n        if(nums == null || nums.length == 0)\\n            return 0;\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0]; // k >=1\\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((int[] arr1, int[] arr2) -> arr2[0] - arr1[0]);\\n        maxHeap.add(new int[]{nums[0], 0});\\n\\n        for (int i= 1; i < nums.length; i++ ){\\n            while (!maxHeap.isEmpty() && maxHeap.peek()[1] < i-k){\\n                maxHeap.remove();\\n            }\\n            dp[i] = nums[i] + maxHeap.peek()[0];\\n            maxHeap.add(new int[]{dp[i], i});\\n        }\\n        return dp[nums.length-1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxResult(int[] nums, int k) {\\n        if(nums == null || nums.length == 0)\\n            return 0;\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0]; // k >=1\\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((int[] arr1, int[] arr2) -> arr2[0] - arr1[0]);\\n        maxHeap.add(new int[]{nums[0], 0});\\n\\n        for (int i= 1; i < nums.length; i++ ){\\n            while (!maxHeap.isEmpty() && maxHeap.peek()[1] < i-k){\\n                maxHeap.remove();\\n            }\\n            dp[i] = nums[i] + maxHeap.peek()[0];\\n            maxHeap.add(new int[]{dp[i], i});\\n        }\\n        return dp[nums.length-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 978917,
                "title": "python-max-heap",
                "content": "```python\\nfrom heapq import *\\nclass Solution:\\n    def maxResult(self, A, k):\\n        if len(A)==1: return A[0]\\n        hp = [(-A[0], 0)] #max heap\\n        heapify(hp)\\n        for i in range(1, len(A)): #loop over indices\\n            while i-hp[0][1]>k: #if the difference is exceeded, discard\\n                heappop(hp)\\n            if i==len(A)-1: return A[i]-hp[0][0] #in last round return the answer\\n            heappush(hp, (-A[i]+hp[0][0], i)) #always keep maximum possible value for each index\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom heapq import *\\nclass Solution:\\n    def maxResult(self, A, k):\\n        if len(A)==1: return A[0]\\n        hp = [(-A[0], 0)] #max heap\\n        heapify(hp)\\n        for i in range(1, len(A)): #loop over indices\\n            while i-hp[0][1]>k: #if the difference is exceeded, discard\\n                heappop(hp)\\n            if i==len(A)-1: return A[i]-hp[0][0] #in last round return the answer\\n            heappush(hp, (-A[i]+hp[0][0], i)) #always keep maximum possible value for each index\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978572,
                "title": "c-easy-solution-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int N = nums.size();\\n        int dp[N+1];\\n        memset(dp, 0, sizeof(dp));\\n        dp[0] = nums[0];\\n        multiset<int> maxValue;\\n        maxValue.insert(dp[0]);\\n        for (int i = 1; i < N; i++) {\\n            dp[i] = nums[i] + *maxValue.rbegin(); // max value of last k steps\\n            maxValue.insert(dp[i]);\\n            if (i >= k) {\\n                maxValue.erase(maxValue.find(dp[i-k])); // remove \"i-k\" result from set\\n            }\\n        }\\n        return dp[N-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int N = nums.size();\\n        int dp[N+1];\\n        memset(dp, 0, sizeof(dp));\\n        dp[0] = nums[0];\\n        multiset<int> maxValue;\\n        maxValue.insert(dp[0]);\\n        for (int i = 1; i < N; i++) {\\n            dp[i] = nums[i] + *maxValue.rbegin(); // max value of last k steps\\n            maxValue.insert(dp[i]);\\n            if (i >= k) {\\n                maxValue.erase(maxValue.find(dp[i-k])); // remove \"i-k\" result from set\\n            }\\n        }\\n        return dp[N-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978564,
                "title": "java-bottom-up-dp-sliding-window-80",
                "content": "* Bottom Up DP\\n```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        //strategy: Bottom Up DP\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        //always start at 0th index so largest curr sum is nums[0]\\n        dp[0] = nums[0];\\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i = 1; i < n; i++) {\\n            //remove the sums outside of the curr range\\n            while (q.size() >= k) {\\n                q.poll();\\n            }\\n            //remove the sums that are smaller than previous cell\\n            while (!q.isEmpty() && dp[q.peek()] < dp[i - 1]) {\\n                q.poll();\\n            }\\n            //add to q \\n            q.add(i - 1);\\n            //the first number is the biggest within the range\\n            dp[i] = nums[i] + dp[q.peek()];\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\\n* Sliding Window\\n```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        //strategy: Sliding Window\\n        int n = nums.length, max = nums[0];\\n        //sort by descending sum\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n        //add max and pos to pq\\n        pq.add(new int[]{max, 0});\\n        for (int i = 1; i < n; i++) {\\n            //remove sums that outside of the range\\n            while (pq.peek()[1] < i - k) {\\n                pq.poll();\\n            }\\n            //find new max\\n            max = nums[i] + pq.peek()[0];\\n            //add curr max and pos to pq\\n            pq.add(new int[]{max, i});\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        //strategy: Bottom Up DP\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        //always start at 0th index so largest curr sum is nums[0]\\n        dp[0] = nums[0];\\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i = 1; i < n; i++) {\\n            //remove the sums outside of the curr range\\n            while (q.size() >= k) {\\n                q.poll();\\n            }\\n            //remove the sums that are smaller than previous cell\\n            while (!q.isEmpty() && dp[q.peek()] < dp[i - 1]) {\\n                q.poll();\\n            }\\n            //add to q \\n            q.add(i - 1);\\n            //the first number is the biggest within the range\\n            dp[i] = nums[i] + dp[q.peek()];\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        //strategy: Sliding Window\\n        int n = nums.length, max = nums[0];\\n        //sort by descending sum\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n        //add max and pos to pq\\n        pq.add(new int[]{max, 0});\\n        for (int i = 1; i < n; i++) {\\n            //remove sums that outside of the range\\n            while (pq.peek()[1] < i - k) {\\n                pq.poll();\\n            }\\n            //find new max\\n            max = nums[i] + pq.peek()[0];\\n            //add curr max and pos to pq\\n            pq.add(new int[]{max, i});\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552788,
                "title": "dp-monotonic-queue",
                "content": "Similar to Sliding Window Maximum\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(n);\\n        dp[n - 1] = nums[n - 1];\\n        deque<int> dq;\\n        dq.push_back(n - 1);\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            // Remove elements from the front of the deque that are no longer reachable\\n            while (!dq.empty() && dq.front() > i + k) {\\n                dq.pop_front();\\n            }\\n\\n            // Calculate the maximum score at the current index\\n            dp[i] = dp[dq.front()] + nums[i];\\n\\n            // Remove elements from the back of the deque that have smaller maximum scores\\n            while (!dq.empty() && dp[i] >= dp[dq.back()]) {\\n                dq.pop_back();\\n            }\\n\\n            // Add the current index to the deque\\n            dq.push_back(i);\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(n);\\n        dp[n - 1] = nums[n - 1];\\n        deque<int> dq;\\n        dq.push_back(n - 1);\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            // Remove elements from the front of the deque that are no longer reachable\\n            while (!dq.empty() && dq.front() > i + k) {\\n                dq.pop_front();\\n            }\\n\\n            // Calculate the maximum score at the current index\\n            dp[i] = dp[dq.front()] + nums[i];\\n\\n            // Remove elements from the back of the deque that have smaller maximum scores\\n            while (!dq.empty() && dp[i] >= dp[dq.back()]) {\\n                dq.pop_back();\\n            }\\n\\n            // Add the current index to the deque\\n            dq.push_back(i);\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509711,
                "title": "golang-monotonic-stack",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfunc maxResult(nums []int, k int) int {\\n    n := len(nums)\\n    monoStack := []int{0}\\n    score := make([]int, n)\\n    score[0] = nums[0]\\n\\n    for i := 1; i < n; i++ {\\n        // Remove older indexes\\n        for len(monoStack) > 0 && monoStack[0] < i - k {\\n            monoStack = monoStack[1:]\\n        }\\n\\n        score[i] = score[monoStack[0]] + nums[i]\\n\\n        // Remove indexes with lesser value\\n        for len(monoStack) > 0 && score[i] >= score[monoStack[len(monoStack)-1]] {\\n            monoStack = monoStack[:len(monoStack)-1]\\n        }\\n        monoStack = append(monoStack, i)\\n    }\\n    \\n    return score[n-1]\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxResult(nums []int, k int) int {\\n    n := len(nums)\\n    monoStack := []int{0}\\n    score := make([]int, n)\\n    score[0] = nums[0]\\n\\n    for i := 1; i < n; i++ {\\n        // Remove older indexes\\n        for len(monoStack) > 0 && monoStack[0] < i - k {\\n            monoStack = monoStack[1:]\\n        }\\n\\n        score[i] = score[monoStack[0]] + nums[i]\\n\\n        // Remove indexes with lesser value\\n        for len(monoStack) > 0 && score[i] >= score[monoStack[len(monoStack)-1]] {\\n            monoStack = monoStack[:len(monoStack)-1]\\n        }\\n        monoStack = append(monoStack, i)\\n    }\\n    \\n    return score[n-1]\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2556641,
                "title": "c-fast-and-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        \\n        deque<pair<int,int>> dq;\\n        dq.push_back({nums[0],0});\\n        \\n        int i=0, j=0;\\n        int mn=nums[0];\\n        \\n        for(i=1;i<n;i++)\\n        {   \\n            while(dq.size() and dq.front().second<i-k)\\n            dq.pop_front();\\n            \\n            mn = nums[i] + dq.front().first;\\n            \\n            while(dq.size() and dq.back().first<=mn)\\n            dq.pop_back();\\n            \\n            dq.push_back({mn, i});\\n        }\\n        \\n        return mn;\\n    }\\n};\\n```\\nUpvote if it helps !",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        \\n        deque<pair<int,int>> dq;\\n        dq.push_back({nums[0],0});\\n        \\n        int i=0, j=0;\\n        int mn=nums[0];\\n        \\n        for(i=1;i<n;i++)\\n        {   \\n            while(dq.size() and dq.front().second<i-k)\\n            dq.pop_front();\\n            \\n            mn = nums[i] + dq.front().first;\\n            \\n            while(dq.size() and dq.back().first<=mn)\\n            dq.pop_back();\\n            \\n            dq.push_back({mn, i});\\n        }\\n        \\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496404,
                "title": "dynamic-programming-and-sliding-window",
                "content": "### dp[i] = maximum score when we reached are at ith index \\n#### dp[i] = max(dp[i], dp[i-k]+nums[i] for k in range(1, K(given)+1))\\n\\n\\n\\n##       to optimise we can use sliding window and have highest dp[i-1 to i-k]\\n        n = len(nums)\\n        dp = [-1*float(\"inf\") for _ in range(n)]\\n        dp[0] = nums[0]\\n        deq = [0]\\n        for i in range(1,n):\\n##### check if first element of deq is out of window limit\\n            if deq and deq[0] <= i - k -1:\\n                deq.pop(0)\\n##### take the maximum number  \\n            max_number = dp[deq[0]]\\n            dp[i] = nums[i]+max_number\\n#####           remove all smaller element than dp[i] from deq ( this ensures we get maximum dp[i-k] for the next iteration \\n            while deq and dp[i]> dp[deq[-1]]:\\n                deq.pop()\\n#####          append ith index into deq  \\n            deq.append(i)\\n        return dp[-1]",
                "solutionTags": [
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "### dp[i] = maximum score when we reached are at ith index \\n#### dp[i] = max(dp[i], dp[i-k]+nums[i] for k in range(1, K(given)+1))\\n\\n\\n\\n##       to optimise we can use sliding window and have highest dp[i-1 to i-k]\\n        n = len(nums)\\n        dp = [-1*float(\"inf\") for _ in range(n)]\\n        dp[0] = nums[0]\\n        deq = [0]\\n        for i in range(1,n):\\n##### check if first element of deq is out of window limit\\n            if deq and deq[0] <= i - k -1:\\n                deq.pop(0)\\n##### take the maximum number  \\n            max_number = dp[deq[0]]\\n            dp[i] = nums[i]+max_number\\n#####           remove all smaller element than dp[i] from deq ( this ensures we get maximum dp[i-k] for the next iteration \\n            while deq and dp[i]> dp[deq[-1]]:\\n                deq.pop()\\n#####          append ith index into deq  \\n            deq.append(i)\\n        return dp[-1]",
                "codeTag": "Unknown"
            },
            {
                "id": 2442179,
                "title": "c-deque-dp-faster-than-98-60-less-than-77-63",
                "content": "### C++ | deque | DP\\nRuntime: 172 ms, faster than 98.60% of C++ online submissions for Jump Game VI.\\nMemory Usage: 80.2 MB, less than 77.63% of C++ online submissions for Jump Game VI.\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        if (nums.size() == 1) return nums[0];\\n        \\n        deque<pair<int, int>> dq;\\n        int curr_val = 0;\\n        \\n        dq.push_back({nums[0], 0});\\n        \\n        for (int curr = 1; curr < nums.size(); curr++) {\\n            \\n            if (dq.front().second < curr - k) {\\n                dq.pop_front();\\n            }\\n            \\n            curr_val = dq.front().first + nums[curr];\\n            \\n            while (!dq.empty() && curr_val > dq.back().first) {\\n                dq.pop_back();\\n            }\\n            \\n            dq.push_back({curr_val, curr});\\n        }\\n        \\n        return curr_val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        if (nums.size() == 1) return nums[0];\\n        \\n        deque<pair<int, int>> dq;\\n        int curr_val = 0;\\n        \\n        dq.push_back({nums[0], 0});\\n        \\n        for (int curr = 1; curr < nums.size(); curr++) {\\n            \\n            if (dq.front().second < curr - k) {\\n                dq.pop_front();\\n            }\\n            \\n            curr_val = dq.front().first + nums[curr];\\n            \\n            while (!dq.empty() && curr_val > dq.back().first) {\\n                dq.pop_back();\\n            }\\n            \\n            dq.push_back({curr_val, curr});\\n        }\\n        \\n        return curr_val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377800,
                "title": "easy-java-solution",
                "content": "* Create a maxHeap which will store the current score and the index at which it occured\\n* offer the 0th indexed element and index to the pq\\n* take a result variable and initianlize it to nums[0]\\n* iterate from i=1 to length of array\\n* if the (current index - index of the top element of pq  <=k) is not true than keep on polling elents from the pq\\n* get the current peek elemnt from the pq\\n* update the res value to current array element and score of peek element\\n* offer the new values into the pq\\n* return res\\n```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        if(nums.length==0)return 0;\\n        //score,index\\n        Queue<int[]>pq = new PriorityQueue<>((a,b)->(b[0]-a[0]));\\n        pq.offer(new int[]{nums[0],0});\\n        int res = nums[0];\\n        for(int i =1;i<nums.length;i++){\\n            while(!(i-pq.peek()[1]<=k))\\n                pq.poll();\\n            int[]curr = pq.peek();\\n            res = nums[i]+curr[0];\\n            pq.offer(new int[]{res,i});\\n        }\\n        return res;\\n    }\\n}\\n```\\n***IF  YOU LIKED THE APPROACH PLEASE UPVOTE !! ***",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        if(nums.length==0)return 0;\\n        //score,index\\n        Queue<int[]>pq = new PriorityQueue<>((a,b)->(b[0]-a[0]));\\n        pq.offer(new int[]{nums[0],0});\\n        int res = nums[0];\\n        for(int i =1;i<nums.length;i++){\\n            while(!(i-pq.peek()[1]<=k))\\n                pq.poll();\\n            int[]curr = pq.peek();\\n            res = nums[i]+curr[0];\\n            pq.offer(new int[]{res,i});\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304786,
                "title": "using-max-heap",
                "content": "```\\nint maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>dp(n,INT_MIN);\\n        dp[n-1]=nums[n-1];\\n        priority_queue<pair<int,int>>pq;\\n        pq.push({dp[n-1],n-1});\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            while(pq.top().second>i+k) pq.pop();\\n            dp[i]=pq.top().first+nums[i];\\n            pq.push({dp[i],i});\\n            \\n        }\\n        return dp[0];\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>dp(n,INT_MIN);\\n        dp[n-1]=nums[n-1];\\n        priority_queue<pair<int,int>>pq;\\n        pq.push({dp[n-1],n-1});\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            while(pq.top().second>i+k) pq.pop();\\n            dp[i]=pq.top().first+nums[i];\\n            pq.push({dp[i],i});\\n            \\n        }\\n        return dp[0];\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2289516,
                "title": "c-dp-multiset-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        multiset<int> m;\\n        int n=nums.size();\\n        vector<int> dp(n);\\n        dp[n-1] = nums[n-1];\\n        m.insert(dp[n-1]);\\n        //multiset will give the current max in window [i+1,min(n-1,i+k)] in dp array\\n        //dp[i] = answer for the same question if we start from nums[i]\\n        //dp[i] = nums[i] + max (for j in range(i+1,min(n-1,i+k))(dp[j]))\\n        int j=n-1,i;\\n        for(i=n-2;i>=0;i--){\\n            if(j-i>k){\\n                m.erase(m.find(dp[j--]));\\n            }\\n            dp[i] = nums[i] + *m.rbegin();\\n            m.insert(dp[i]);\\n        }\\n        // for(auto x:dp)cout<<x<<\" \";\\n        // cout<<endl;\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        multiset<int> m;\\n        int n=nums.size();\\n        vector<int> dp(n);\\n        dp[n-1] = nums[n-1];\\n        m.insert(dp[n-1]);\\n        //multiset will give the current max in window [i+1,min(n-1,i+k)] in dp array\\n        //dp[i] = answer for the same question if we start from nums[i]\\n        //dp[i] = nums[i] + max (for j in range(i+1,min(n-1,i+k))(dp[j]))\\n        int j=n-1,i;\\n        for(i=n-2;i>=0;i--){\\n            if(j-i>k){\\n                m.erase(m.find(dp[j--]));\\n            }\\n            dp[i] = nums[i] + *m.rbegin();\\n            m.insert(dp[i]);\\n        }\\n        // for(auto x:dp)cout<<x<<\" \";\\n        // cout<<endl;\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2277499,
                "title": "c-short-code-simple-heap-priority-queue-7-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        priority_queue<pair<int, int>> pq;\\n        pq.push({nums[0], 0});\\n        \\n        for(int i=1;i<nums.size();i++){\\n            while(pq.size() && pq.top().second < i-k) pq.pop();\\n            pq.push({pq.top().first + nums[i], i});\\n        }\\n        while(pq.top().second != nums.size()-1) pq.pop();\\n        return pq.top().first;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        priority_queue<pair<int, int>> pq;\\n        pq.push({nums[0], 0});\\n        \\n        for(int i=1;i<nums.size();i++){\\n            while(pq.size() && pq.top().second < i-k) pq.pop();\\n            pq.push({pq.top().first + nums[i], i});\\n        }\\n        while(pq.top().second != nums.size()-1) pq.pop();\\n        return pq.top().first;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262971,
                "title": "python3-solution-with-using-deque",
                "content": "```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        dq = collections.deque([0])\\n        res = 0\\n        \\n        for i in range(1, len(nums)):\\n            while dq and dq[0] < i - k:\\n                dq.popleft()\\n            \\n            nums[i] += nums[dq[0]]\\n            \\n            while dq and nums[i] >= nums[dq[-1]]:\\n                dq.pop()\\n    \\n            dq.append(i)\\n        \\n        return nums[-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        dq = collections.deque([0])\\n        res = 0\\n        \\n        for i in range(1, len(nums)):\\n            while dq and dq[0] < i - k:\\n                dq.popleft()\\n            \\n            nums[i] += nums[dq[0]]\\n            \\n            while dq and nums[i] >= nums[dq[-1]]:\\n                dq.pop()\\n    \\n            dq.append(i)\\n        \\n        return nums[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260217,
                "title": "java-solution-using-linked-list",
                "content": "class Solution {\\n    public int maxResult(int[] nums, int k) {\\n        LinkedList<Integer> list = new LinkedList<>(); \\n        list.add(0);\\n        for(int i=1; i<nums.length; i++){\\n            if(list.getFirst() < i-k) list.removeFirst();\\n            nums[i] += nums[list.getFirst()];\\n            while(!list.isEmpty() && nums[list.getLast()] <= nums[i]) list.removeLast();\\n            list.addLast(i);\\n        }\\n        return nums[nums.length-1];\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxResult(int[] nums, int k) {\\n        LinkedList<Integer> list = new LinkedList<>(); \\n        list.add(0);\\n        for(int i=1; i<nums.length; i++){\\n            if(list.getFirst() < i-k) list.removeFirst();\\n            nums[i] += nums[list.getFirst()];\\n            while(!list.isEmpty() && nums[list.getLast()] <= nums[i]) list.removeLast();\\n            list.addLast(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2259839,
                "title": "1696-jump-game-vi",
                "content": "class Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(n);\\n        dp[n - 1] = nums[n - 1];\\n        \\n        priority_queue<pair<int, int>> q;\\n        q.push({dp[n - 1], n - 1});\\n        \\n        for(int i = n - 2; i >= max(0, n - 1 - k); --i) {\\n            dp[i] = q.top().first + nums[i];\\n            q.push({dp[i], i});\\n        }\\n        for(int i = n - 2 - k; i >= 0; --i) {\\n            while(!q.empty() && q.top().second > i + k) q.pop();\\n            dp[i] = nums[i] + (q.size() ? q.top().first : 0);\\n            q.push({dp[i], i});\\n        }\\n        return dp[0];\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(n);\\n        dp[n - 1] = nums[n - 1];\\n        \\n        priority_queue<pair<int, int>> q;\\n        q.push({dp[n - 1], n - 1}",
                "codeTag": "Java"
            },
            {
                "id": 2259677,
                "title": "c-o-k-n-to-o-nlogk-brute-force-to-dynamic-programming",
                "content": "**1. Solution I - Brute force**\\nUsing recursion, we will explore all possible options. For any index i, such that it is within the bounds of the array, i.e. i<n-1, we can jump atmost k steps forward, so we will try each jump of lengths `1,2...k` and return the maximum score at the end.\\n\\nC++ code - Time Limit Exceeded\\n*Time Complexity: O(k^n)\\nSpace Complexity: O(n*) \\n\\n```\\nclass Solution {\\npublic:\\n    int countAll(vector<int> &nums,int i,int k){\\n        if(i >= nums.size()-1) return nums[i];\\n        int ans = INT_MIN;\\n        for(int x = 1; x <= k; x++){\\n            if((i+x) >= nums.size()) continue;\\n            ans=max(ans,nums[i]+countAll(nums,i+x,k));\\n        }\\n        return ans;\\n    }\\n    \\n    int maxResult(vector<int>& nums, int k) {\\n        return countAll(nums,0,k);\\n    }\\n};\\n```\\n\\n**2. Solution II - Top-Down Dynamic Programming**\\nWe will memoize the above recursive solution, to avoid calculation for the same index multiple times. So, we store the calculated results and return it directly whenever required. To store the results, we make an array, called `dp` of size n and initialize `dp[0] = nums[0]`, and all the other values as INT_MIN, which will suggest that they have never been computed.\\n\\nC++ code - Time Limit Exceeded \\n*Time Complexity: O(kn)\\nSpace Complexity: O(n)*\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int countAll(vector<int> &nums,int i,int k){\\n        if(i >= nums.size()-1) return nums[i];\\n        if(dp[i] != INT_MIN) return dp[i];\\n        int ans = INT_MIN;\\n        for(int x = 1; x <= k; x++){\\n            if((i+x) >= nums.size()) continue;\\n            ans=max(ans,nums[i]+countAll(nums,i+x,k));\\n        }\\n        return dp[i] = ans;\\n    }\\n    \\n    int maxResult(vector<int>& nums, int k) {\\n        memset(dp, INT_MIN, sizeof(dp));\\n        return countAll(nums,0,k);\\n    }\\n};\\n```\\n\\n**Solution III - Bottom Up Dynamic Programming**\\nWe do the same as above, only iteratively this time\\n\\nC++ code - Time Limit Exceeded\\n*Time Complexity: O(kn)\\nSpace Complexity: O(n)*\\n\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> dp(n,INT_MIN);\\n        dp[0] = nums[0];\\n        for(int i = 1; i < n; i++){\\n            for(int x = 1; x <= k; x++){\\n\\t\\t\\t\\tif((i-x) < 0) break;\\n                dp[i]=max(dp[i],nums[i]+dp[i-x]);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\n\\n**Solution IV - Dynamic Programming + Multiset**\\nFor our optimized dynamic programming approach, we can observe that once we cross the k jumps, the values at i-k-1 and before, do not play any part in calculation of `dp[i]`. Further, for calculation of `dp[i]`, we only care about the **maximum** of` dp[i-1], dp[i-2], ... dp[i-k]` . We can store the previous k values\\' results in a multiset and once we cross the i-k-1 value, we remove it from our multiset, as it is no longer in consideration.\\n\\nC++ code - Accepted\\n*Time Complexity: O(nlog(k))\\nSpace Complexity: O(n)*\\n\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(n,INT_MIN);\\n        dp[0] = nums[0];\\n        multiset<int> s;\\n        s.insert(dp[0]);\\n        for(int i = 1; i < n; i++){\\n            if(i > k){\\n                s.erase(s.find(dp[i-k-1]));\\n            }\\n            dp[i] = *(s.rbegin())+nums[i];\\n            s.insert(dp[i]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAll(vector<int> &nums,int i,int k){\\n        if(i >= nums.size()-1) return nums[i];\\n        int ans = INT_MIN;\\n        for(int x = 1; x <= k; x++){\\n            if((i+x) >= nums.size()) continue;\\n            ans=max(ans,nums[i]+countAll(nums,i+x,k));\\n        }\\n        return ans;\\n    }\\n    \\n    int maxResult(vector<int>& nums, int k) {\\n        return countAll(nums,0,k);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[100001];\\n    int countAll(vector<int> &nums,int i,int k){\\n        if(i >= nums.size()-1) return nums[i];\\n        if(dp[i] != INT_MIN) return dp[i];\\n        int ans = INT_MIN;\\n        for(int x = 1; x <= k; x++){\\n            if((i+x) >= nums.size()) continue;\\n            ans=max(ans,nums[i]+countAll(nums,i+x,k));\\n        }\\n        return dp[i] = ans;\\n    }\\n    \\n    int maxResult(vector<int>& nums, int k) {\\n        memset(dp, INT_MIN, sizeof(dp));\\n        return countAll(nums,0,k);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> dp(n,INT_MIN);\\n        dp[0] = nums[0];\\n        for(int i = 1; i < n; i++){\\n            for(int x = 1; x <= k; x++){\\n\\t\\t\\t\\tif((i-x) < 0) break;\\n                dp[i]=max(dp[i],nums[i]+dp[i-x]);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(n,INT_MIN);\\n        dp[0] = nums[0];\\n        multiset<int> s;\\n        s.insert(dp[0]);\\n        for(int i = 1; i < n; i++){\\n            if(i > k){\\n                s.erase(s.find(dp[i-k-1]));\\n            }\\n            dp[i] = *(s.rbegin())+nums[i];\\n            s.insert(dp[i]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259431,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>a(n,0);\\n        priority_queue<pair<int,int>>p;\\n        a[0]=nums[0];\\n        p.push({a[0],0});\\n        for(int i=1;i<n;i++)\\n        {\\n            while(p.size() and p.top().second<i-k)\\n                p.pop();\\n            a[i]=nums[i]+p.top().first;\\n            p.push({a[i],i});\\n        }\\n        return a[n-1];\\n    }\\n};\\nfeel free to ask your doubt happy to help\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>a(n,0);\\n        priority_queue<pair<int,int>>p;\\n        a[0]=nums[0];\\n        p.push({a[0],0});\\n        for(int i=1;i<n;i++)\\n        {\\n            while(p.size() and p.top().second<i-k)\\n                p.pop();\\n            a[i]=nums[i]+p.top().first;\\n            p.push({a[i],i});\\n        }\\n        return a[n-1];\\n    }\\n};\\nfeel free to ask your doubt happy to help\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259084,
                "title": "c-priority-queue-solution-easy",
                "content": "```\\n// https://leetcode.com/problems/jump-game-vi/\\n// 1696. Jump Game VI\\n\\nclass Solution {\\npublic:    \\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        priority_queue<pair<int,int>> pq;\\n        pq.push({nums[n-1],n-1});\\n        for(int i = n-2;i>=0;i--)\\n        {\\n            while(pq.top().second>i+k)\\n                pq.pop();\\n            pq.push({nums[i] + pq.top().first,i});\\n        }\\n        while(pq.top().second!=0)\\n            pq.pop();\\n        return pq.top().first;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// https://leetcode.com/problems/jump-game-vi/\\n// 1696. Jump Game VI\\n\\nclass Solution {\\npublic:    \\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        priority_queue<pair<int,int>> pq;\\n        pq.push({nums[n-1],n-1});\\n        for(int i = n-2;i>=0;i--)\\n        {\\n            while(pq.top().second>i+k)\\n                pq.pop();\\n            pq.push({nums[i] + pq.top().first,i});\\n        }\\n        while(pq.top().second!=0)\\n            pq.pop();\\n        return pq.top().first;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258875,
                "title": "very-easy-java-explanation-t-c-o-n-s-c-o-1",
                "content": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        Deque<Integer> dq=new ArrayDeque<>();\\n        dq.add(0);\\n        for(int i=1;i<nums.length;i++){\\n            nums[i]=nums[i]+nums[dq.peekFirst()];\\n            while(!dq.isEmpty() && nums[i]>=nums[dq.peekLast()]){\\n                dq.removeLast();\\n            }\\n            dq.add(i);\\n            if(i-dq.peekFirst()>=k) dq.removeFirst();\\n        }\\n        return nums[nums.length-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        Deque<Integer> dq=new ArrayDeque<>();\\n        dq.add(0);\\n        for(int i=1;i<nums.length;i++){\\n            nums[i]=nums[i]+nums[dq.peekFirst()];\\n            while(!dq.isEmpty() && nums[i]>=nums[dq.peekLast()]){\\n                dq.removeLast();\\n            }\\n            dq.add(i);\\n            if(i-dq.peekFirst()>=k) dq.removeFirst();\\n        }\\n        return nums[nums.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258829,
                "title": "c-easy-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        deque<int> dq;\\n        int n = nums.size();\\n        vector<int> dp(n);\\n        dp[n-1] = nums[n-1];\\n        dq.push_back(n-1);\\n        \\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(dq.front() - i > k) dq.pop_front();\\n            \\n            dp[i] = nums[i] + dp[dq.front()];\\n            while(dq.size() && dp[dq.back()] < dp[i]) dq.pop_back();\\n            \\n            dq.push_back(i);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        deque<int> dq;\\n        int n = nums.size();\\n        vector<int> dp(n);\\n        dp[n-1] = nums[n-1];\\n        dq.push_back(n-1);\\n        \\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(dq.front() - i > k) dq.pop_front();\\n            \\n            dp[i] = nums[i] + dp[dq.front()];\\n            while(dq.size() && dp[dq.back()] < dp[i]) dq.pop_back();\\n            \\n            dq.push_back(i);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258806,
                "title": "python-o-n-time-and-o-k-space-dp-approach",
                "content": "**simple approach**\\nHere I am storing the best result for ith element in the nums array itself.\\n\\n```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n\\t\\t# taking a length of the array\\n        n = len(nums)\\n        \\n\\t\\t#looping from 1st element to last element in nums array\\n        for i in range(1,n):\\n\\t\\t\\t\\n\\t\\t\\t#taking range so we can loop\\n\\t\\t\\t#from i-k-1 to i-1\\n            range_val = max(0,i-k)\\n\\t\\t\\t\\n\\t\\t\\t#taking a temporary variable to store maximum value\\n            temp = float(\"-inf\")\\n\\t\\t\\t\\n\\t\\t\\t#loop through the k values \\n            for j in range(range_val,i):\\n                temp= max(temp,nums[j])\\n\\t\\t\\t#simple assigning max value\\n            nums[i] = nums[i]+temp\\n        #print(nums)\\n        return nums[-1]\\n            \\n```\\n\\nHere, we are not taking exta space so space complexity becomes O(1) but but, We are visiting nums[i] k time due to loop so time complexity becomes O(n*k)\\n**AS result I am getting time out error (which I don\\'t like)**\\n\\n**optimized solutions**\\n\\nSame as above. We are just adding new list (array). So we do not need to visit my element K times.\\n\\n```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        \\n        #taking a length of the array\\n        n = len(nums)\\n        \\n        #taking extra array so we can store max values in it\\n        # we will also take care of range\\n        list_index = [0]\\n        \\n        #looping from 1st element to last element in nums array\\n        for i in range(1,n):\\n            \\n            #we need only those index which are between\\n            # i-k-1 to i-1\\n            # we are removing all unnecessary index\\n            while i-list_index[0]>k and len(list_index)>0:\\n                curr_index = list_index.pop(0)\\n            \\n            ##simple assigning max value\\n            nums[i] = nums[i]+nums[list_index[0]]\\n            #print(nums[i])\\n            \\n            \\n            #we need only max values index that\\'s why\\n            #removing all those value index which are lower than or equal to our new nums[i]\\n            while list_index and nums[list_index[-1]]<= nums[i]:\\n                list_index.pop()\\n            \\n            #appendin new index in array\\n            #we already remove low values so\\n            #0th index of list_index automatic becomes max value index\\n            list_index.append(i)\\n            \\n        #print(nums)\\n        return nums[-1]\\n```\\n\\nHere, we are taking exta space to store visited index so space complexity becomes O(k) why?\\nwe are storing max to max k+1 indexes at time.\\n\\nwe are visitng each index only twice so time complexity becomes O(n).\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n\\t\\t# taking a length of the array\\n        n = len(nums)\\n        \\n\\t\\t#looping from 1st element to last element in nums array\\n        for i in range(1,n):\\n\\t\\t\\t\\n\\t\\t\\t#taking range so we can loop\\n\\t\\t\\t#from i-k-1 to i-1\\n            range_val = max(0,i-k)\\n\\t\\t\\t\\n\\t\\t\\t#taking a temporary variable to store maximum value\\n            temp = float(\"-inf\")\\n\\t\\t\\t\\n\\t\\t\\t#loop through the k values \\n            for j in range(range_val,i):\\n                temp= max(temp,nums[j])\\n\\t\\t\\t#simple assigning max value\\n            nums[i] = nums[i]+temp\\n        #print(nums)\\n        return nums[-1]\\n            \\n```\n```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        \\n        #taking a length of the array\\n        n = len(nums)\\n        \\n        #taking extra array so we can store max values in it\\n        # we will also take care of range\\n        list_index = [0]\\n        \\n        #looping from 1st element to last element in nums array\\n        for i in range(1,n):\\n            \\n            #we need only those index which are between\\n            # i-k-1 to i-1\\n            # we are removing all unnecessary index\\n            while i-list_index[0]>k and len(list_index)>0:\\n                curr_index = list_index.pop(0)\\n            \\n            ##simple assigning max value\\n            nums[i] = nums[i]+nums[list_index[0]]\\n            #print(nums[i])\\n            \\n            \\n            #we need only max values index that\\'s why\\n            #removing all those value index which are lower than or equal to our new nums[i]\\n            while list_index and nums[list_index[-1]]<= nums[i]:\\n                list_index.pop()\\n            \\n            #appendin new index in array\\n            #we already remove low values so\\n            #0th index of list_index automatic becomes max value index\\n            list_index.append(i)\\n            \\n        #print(nums)\\n        return nums[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258741,
                "title": "jump-game-6",
                "content": "class Solution {\\n    public int maxResult(int[] nums, int k) {\\n         int n=nums.length;\\n        PriorityQueue<pair> pq=new PriorityQueue<>((a,b)->b.val-a.val ); //max heap\\n        int mat[]=new int[n];\\n        mat[0]=nums[0];\\n        pair max=new pair(nums[0],0);\\n       \\n        for(int i=1;i<n;i++){\\n           \\n            if(!pq.isEmpty() && pq.peek().val>max.val)max=pq.remove(); // to get max in k range;\\n            if(max.index+k<i){\\n                 //System.out.println(i+\" \"+max.val);\\n                while(pq.peek().index+k<i)pq.remove();\\n                max=pq.remove();\\n            }\\n            int val=max.val+nums[i];\\n            pq.add(new pair(val,i) );\\n            mat[i]=val;\\n        }\\n      //  for(int i=0;i<n;i++)System.out.print(mat[i]+\" \");\\n        return mat[n-1];\\n        //\\n    }\\n    public class pair{\\n        int val;\\n        int index;\\n        public pair(int val,int index){\\n            this.val=val;\\n            this.index=index;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int maxResult(int[] nums, int k) {\\n         int n=nums.length;\\n        PriorityQueue<pair> pq=new PriorityQueue<>((a,b)->b.val-a.val ); //max heap\\n        int mat[]=new int[n];\\n        mat[0]=nums[0];\\n        pair max=new pair(nums[0],0);\\n       \\n        for(int i=1;i<n;i++){\\n           \\n            if(!pq.isEmpty() && pq.peek().val>max.val)max=pq.remove(); // to get max in k range;\\n            if(max.index+k<i){\\n                 //System.out.println(i+\" \"+max.val);\\n                while(pq.peek().index+k<i)pq.remove();\\n                max=pq.remove();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2258690,
                "title": "c-3-approaches-priority-queue-sliding-window-brute-force",
                "content": "**Approach: 1**\\n```\\nstruct comp\\n{\\n    bool operator()(pair<int,int>p1,pair<int,int>p2)\\n    {\\n        return p1.second<p2.second;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,comp>pq;\\n        pq.push({0,nums[0]});\\n        for(int i=1;i<nums.size();i++)\\n        {   while(pq.top().first<i-k)\\n                 pq.pop();\\n       \\n          \\n            nums[i]+=pq.top().second;\\n        \\n         pq.push({i,nums[i]});\\n          }\\n        return nums[nums.size()-1];\\n    }\\n};\\n```\\n**Approach: 2**\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        for(int i=1;i<nums.size();i++)\\n        {  int index=max(i-k,0);\\n           int diff=(index==0)?i:k;\\n            nums[i]+=*max_element(nums.begin()+i-diff,nums.begin()+i);\\n         cout<<nums[i]<<endl;\\n        }\\n        return nums[nums.size()-1];\\n    }\\n};\\n```\\n**Approach: 3**\\n```\\nclass Solution {\\n    private:\\n    vector<long long int>v;\\n    int len;\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n     \\n        len=nums.size();\\n        v.resize(len,LLONG_MIN);\\n    \\n        return fun(nums,0,k);\\n    }\\n    long long int fun(vector<int>&nums,int index,int k)\\n    { \\n        \\n        if(index==len-1)\\n            return nums[index];\\n        if(index>=len)\\n          return LLONG_MIN;\\n        else\\n        { long long int ans=LLONG_MIN;\\n           if(v[index]!=LLONG_MIN)\\n               return v[index];\\n         else{\\n         \\n            for(int i=1;i<=k;i++)\\n            {   \\n               ans= max(fun(nums,index+i,k),ans);\\n            \\n            }\\n         }\\n         v[index]=ans+nums[index];\\n         return v[index];\\n        }\\n            \\n    }\\n};\\n```\\n***PLEASE UPVOTE IF YOU FIND IT A LITTLE BIT HELPFUL, MEANS A LOT ;)***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstruct comp\\n{\\n    bool operator()(pair<int,int>p1,pair<int,int>p2)\\n    {\\n        return p1.second<p2.second;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,comp>pq;\\n        pq.push({0,nums[0]});\\n        for(int i=1;i<nums.size();i++)\\n        {   while(pq.top().first<i-k)\\n                 pq.pop();\\n       \\n          \\n            nums[i]+=pq.top().second;\\n        \\n         pq.push({i,nums[i]});\\n          }\\n        return nums[nums.size()-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        for(int i=1;i<nums.size();i++)\\n        {  int index=max(i-k,0);\\n           int diff=(index==0)?i:k;\\n            nums[i]+=*max_element(nums.begin()+i-diff,nums.begin()+i);\\n         cout<<nums[i]<<endl;\\n        }\\n        return nums[nums.size()-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    private:\\n    vector<long long int>v;\\n    int len;\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n     \\n        len=nums.size();\\n        v.resize(len,LLONG_MIN);\\n    \\n        return fun(nums,0,k);\\n    }\\n    long long int fun(vector<int>&nums,int index,int k)\\n    { \\n        \\n        if(index==len-1)\\n            return nums[index];\\n        if(index>=len)\\n          return LLONG_MIN;\\n        else\\n        { long long int ans=LLONG_MIN;\\n           if(v[index]!=LLONG_MIN)\\n               return v[index];\\n         else{\\n         \\n            for(int i=1;i<=k;i++)\\n            {   \\n               ans= max(fun(nums,index+i,k),ans);\\n            \\n            }\\n         }\\n         v[index]=ans+nums[index];\\n         return v[index];\\n        }\\n            \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2258629,
                "title": "c-priority-queue-max-heap-w-comments-dry-run",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n        -> ****PQ in case of Pairs is heapify-ed by the first element of the pair****\\n        nums = [10,-5,-2,4,0,3] \\n        k = 3\\n        \\n        v[0] = 10;\\n        itr 1 : Heap looks like\\n            10,0\\n            /\\n         5,1\\n         \\n         v = [10, 5, 0, 0, 0, 0]\\n         \\n         itr 2: Heap looks like\\n            10,0\\n            /  \\\\\\n           5,1  8,2\\n           \\n         v = [10, 5, 8, 0, 0, 0]\\n         \\n         itr 3: Heap looks like\\n            14,3\\n            /  \\\\\\n          10,0  8,2\\n          /\\n          5,1\\n          \\n          v = [10, 5, 8, 14, 0, 0]\\n          \\n          itr 4: Heap looks like\\n            14,3\\n            /  \\\\\\n          10,0  14,4\\n          /  \\\\\\n         8,2  5,1\\n         \\n         v = [10, 5, 8, 14, 14, 0]\\n         \\n         itr 5: Heap looks like\\n             17,5\\n            /    \\\\\\n         14,3    14,4\\n        /  \\\\     /\\n    10,0    8,2 5,1\\n    \\n        final itr vector looks like\\n        v = [10, 5, 8, 14, 14, 17]\\n        we return v[n-1] as our final answer\\n        \\n        intuition : if pq.top falls out of range of jump, we pop that pair and                             continue\\n    */\\n    \\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(k == 1) { \\n             return accumulate(nums.begin(), nums.end(), 0);\\n        }\\n        vector<int> v(n);\\n        v[0] = nums[0];\\n        priority_queue<pair<int,int>> pq;\\n        pq.push({nums[0],0});\\n        for(int i = 1; i < n; i++) {\\n            while(pq.empty() == false && pq.top().second < i - k) {\\n                pq.pop();\\n            }\\n            v[i] = nums[i] + pq.top().first;\\n            pq.push({v[i], i});\\n        }\\n        return v[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n        -> ****PQ in case of Pairs is heapify-ed by the first element of the pair****\\n        nums = [10,-5,-2,4,0,3] \\n        k = 3\\n        \\n        v[0] = 10;\\n        itr 1 : Heap looks like\\n            10,0\\n            /\\n         5,1\\n         \\n         v = [10, 5, 0, 0, 0, 0]\\n         \\n         itr 2: Heap looks like\\n            10,0\\n            /  \\\\\\n           5,1  8,2\\n           \\n         v = [10, 5, 8, 0, 0, 0]\\n         \\n         itr 3: Heap looks like\\n            14,3\\n            /  \\\\\\n          10,0  8,2\\n          /\\n          5,1\\n          \\n          v = [10, 5, 8, 14, 0, 0]\\n          \\n          itr 4: Heap looks like\\n            14,3\\n            /  \\\\\\n          10,0  14,4\\n          /  \\\\\\n         8,2  5,1\\n         \\n         v = [10, 5, 8, 14, 14, 0]\\n         \\n         itr 5: Heap looks like\\n             17,5\\n            /    \\\\\\n         14,3    14,4\\n        /  \\\\     /\\n    10,0    8,2 5,1\\n    \\n        final itr vector looks like\\n        v = [10, 5, 8, 14, 14, 17]\\n        we return v[n-1] as our final answer\\n        \\n        intuition : if pq.top falls out of range of jump, we pop that pair and                             continue\\n    */\\n    \\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(k == 1) { \\n             return accumulate(nums.begin(), nums.end(), 0);\\n        }\\n        vector<int> v(n);\\n        v[0] = nums[0];\\n        priority_queue<pair<int,int>> pq;\\n        pq.push({nums[0],0});\\n        for(int i = 1; i < n; i++) {\\n            while(pq.empty() == false && pq.top().second < i - k) {\\n                pq.pop();\\n            }\\n            v[i] = nums[i] + pq.top().first;\\n            pq.push({v[i], i});\\n        }\\n        return v[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258542,
                "title": "10-ms-faster-than-98-99-of-java-online-submissions-for-jump-game-vi",
                "content": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        int[] ar = new int[nums.length];\\n        ar[0] = nums[0];\\n        int max = nums[0], maxidx = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (i - k <= 0 || maxidx >= i - k) {\\n                ar[i] = max + nums[i];\\n                if (ar[i] >= max) {\\n                    max = ar[i];\\n                    maxidx = i;\\n                }\\n            } else {\\n                max = ar[i - k];\\n                maxidx = i - k;\\n                for (int j = i - k + 1; j < i; j++) {\\n                    if (ar[j] >= max) {\\n                        max = ar[j];\\n                        maxidx = j;\\n                    }\\n                }\\n                ar[i] = max + nums[i];\\n                if (ar[i] >= max) {\\n                    max = ar[i];\\n                    maxidx = i;\\n                }\\n            }\\n        }\\n        return ar[nums.length - 1];        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        int[] ar = new int[nums.length];\\n        ar[0] = nums[0];\\n        int max = nums[0], maxidx = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (i - k <= 0 || maxidx >= i - k) {\\n                ar[i] = max + nums[i];\\n                if (ar[i] >= max) {\\n                    max = ar[i];\\n                    maxidx = i;\\n                }\\n            } else {\\n                max = ar[i - k];\\n                maxidx = i - k;\\n                for (int j = i - k + 1; j < i; j++) {\\n                    if (ar[j] >= max) {\\n                        max = ar[j];\\n                        maxidx = j;\\n                    }\\n                }\\n                ar[i] = max + nums[i];\\n                if (ar[i] >= max) {\\n                    max = ar[i];\\n                    maxidx = i;\\n                }\\n            }\\n        }\\n        return ar[nums.length - 1];        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258306,
                "title": "c-explained-dp-deque",
                "content": "\\n```\\n/*\\n        \\n        In one move, at most k steps forward\\n        \\n        \\n        Score of any path = sum of all values visited in the path\\n        \\n        Needs to find Maximum score possible\\n\\n        As we have multiple choices for next jump, so we can think about dp\\n        \\n        dp[i] = max score if moving from index i to last index\\n        \\n        \\n        we have k choices for next move (for each index i)\\n\\n\\n        Ans=dp[0]\\n        \\n        T.C= O(n*k)\\n        \\n        It gives TLEEEEEEEEE\\n\\t\\t\\n\\t\\t*/\\n\\t\\t\\n\\nint dp[100001];\\nclass Solution {\\npublic:\\n    int n;\\n    int maxResult(vector<int>& nums, int k) {\\n        \\n         n=nums.size();\\n     \\n        memset(dp,-1,sizeof(dp));\\n        \\n        return find(0,nums,k);\\n    }\\n    \\n    int find(int i,vector<int>&nums,int k){\\n         if(i==n-1)\\n             return nums[i];\\n        else if(i>=n)\\n            return INT_MIN;\\n        \\n         if(dp[i]!=-1)\\n             return dp[i];\\n        \\n         int ans=INT_MIN;\\n        \\n        for(int k1=1;k1<=k;k1++){\\n            if(i+k1<n)\\n            ans=max(ans,nums[i]+find(i+k1,nums,k));\\n            else\\n                break;\\n        }\\n        \\n        return dp[i]=ans;\\n    }\\n};\\n\\n/*\\n\\nApproach 1: (optimization using deque)\\n\\ndp[i] = max score possible if start moving from index i and reaches to index \\nlast index n-1\\n\\n\\ndp[i]= nums[i] + max(dp[i+1],dp[i+2],.....dp[i+k])\\n\\nwe use deque to keep track of max among these next k values\\n\\nans= dp[0]\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        \\n         int n=nums.size();\\n        \\n         vector<int>dp(n);\\n\\n         dp[n-1]=nums[n-1];\\n\\n         deque<int>dq;\\n        \\n         dq.push_back(n-1);\\n        \\n         for(int i=n-2;i>=0;i--){\\n             \\n          dp[i]=nums[i];\\n           \\n             \\n        //Now jumping from previous greatest index j to index i (Note index j should lies in range of i)\\n\\n          if(dq.size()>0) {\\n              int j=dq.front();\\n              if(j-i>k)\\n                  dq.pop_front();\\n          }\\n              \\n             \\n              if(dq.size()>0){\\n                  int j=dq.front();\\n                dp[i]+=dp[j];\\n              }\\n             \\n    // Updating deque to push index of dp[i] to it ( NOTE: keep that index at front of deque whose value is max)\\n             \\n          while(dq.size()>0 && (dp[i]>=dp[dq.back()]))\\n              dq.pop_back();\\n             \\n             \\n             dq.push_back(i);\\n             \\n         \\n         }\\n        \\n        \\n        return dp[0];\\n        \\n        \\n    }\\n        \\n    \\n};\\n\\n    \\n /*\\n\\nApproach 2 (using deque) : \\n\\ndp[i] = max score if we ends at index i and starts moving from index 0\\n\\nAns= dp[n-1]\\n\\ndp[i]=nums[i] +  max(dp[0],dp[1],dp[2]....,dp[i-1])  Considering that \\n\\nall indexes [0,1,2,3,...i-1] lies in range of i (as we can only jump upto k steps forward)\\n\\nmax among last k values  , can be found out in conastant time using deque)\\n\\nLet we have calculated dp[0] , dp[1] , dp[2] , dp[3]\\n\\nAs soon as we caluculating them we store them in deque , front of deque = max among all these\\n\\nThan for dp[4] = nums[4] + max(dp[0],dp[1],dp[2],dp[3])\\n               = nums[4] + front of deque\\n               \\nThan for further indexes we update deque by pushing index \\'4\\' corresponding to value dp[4] \\n\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        \\n         int n=nums.size();\\n        \\n         vector<int>dp(n);\\n\\n         dp[0]=nums[0];\\n\\n         deque<int>dq;\\n        \\n         dq.push_back(0);\\n        \\n        \\n         for(int i=1;i<n;i++){\\n\\n             \\n          dp[i]=nums[i];\\n           \\n             \\n        //Now jumping from previous greatest index j to index i (Note index j should lies in range of i)\\n\\n          if(dq.size()>0) {\\n              int j=dq.front();\\n              if(i-j>k)\\n                  dq.pop_front();\\n          }\\n              \\n             \\n              if(dq.size()>0){\\n                  int j=dq.front();\\n                dp[i]+=dp[j];\\n              }\\n             \\n    // Updating deque to push index of dp[i] to it ( NOTE: keep that index at front of deque whose value is max)\\n             \\n          while(dq.size()>0 && (dp[i]>=dp[dq.back()]))\\n              dq.pop_back();\\n             \\n             \\n             dq.push_back(i);\\n             \\n         \\n         }\\n        \\n        \\n        return dp[n-1];\\n        \\n        \\n    }\\n\\n};\\n\\n\\n\\n\\n\\n\\n    \\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    int n;\\n    int maxResult(vector<int>& nums, int k) {\\n        \\n         n=nums.size();\\n     \\n        memset(dp,-1,sizeof(dp));\\n        \\n        return find(0,nums,k);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2258287,
                "title": "dp-sliding-window-max-faster-than-98-95-o-n-time-and-space",
                "content": "**Code (C++):**\\n```\\nint maxResult(vector<int>& nums, int k) {\\n        if (nums.size() == 0 || k == 0) return 0;\\n        if (nums.size() == 1) return nums[0];\\n        if (nums.size() == 2) return nums[0] + nums[1];\\n        if (k == 1) return accumulate(nums.begin(), nums.end(), 0);\\n        int n = nums.size();\\n        long long int dp[n];\\n        dp[0] = nums[0];\\n        dp[1] = dp[0] + nums[1];\\n        deque<int> q;\\n        q.push_back(0);\\n        if (dp[1] >= dp[q.back()]) {\\n            q.pop_back();\\n            q.push_back(1);\\n        } else {\\n            q.push_back(1);\\n        }\\n        \\n        for (int i=2; i<n; i++) {\\n            dp[i] = nums[i] + dp[q.front()];\\n            while (!q.empty() && dp[i] >= dp[q.back()]) q.pop_back();\\n            if (!q.empty() && q.front() <= i - k) q.pop_front();\\n            q.push_back(i);\\n        }\\n        \\n        return dp[n-1];\\n}\\n```\\n\\nTime Complexity: O(N)\\nAuxiliary Space Complexity: O(N)\\n\\n***Upvote this post if you found it helpful :)***",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint maxResult(vector<int>& nums, int k) {\\n        if (nums.size() == 0 || k == 0) return 0;\\n        if (nums.size() == 1) return nums[0];\\n        if (nums.size() == 2) return nums[0] + nums[1];\\n        if (k == 1) return accumulate(nums.begin(), nums.end(), 0);\\n        int n = nums.size();\\n        long long int dp[n];\\n        dp[0] = nums[0];\\n        dp[1] = dp[0] + nums[1];\\n        deque<int> q;\\n        q.push_back(0);\\n        if (dp[1] >= dp[q.back()]) {\\n            q.pop_back();\\n            q.push_back(1);\\n        } else {\\n            q.push_back(1);\\n        }\\n        \\n        for (int i=2; i<n; i++) {\\n            dp[i] = nums[i] + dp[q.front()];\\n            while (!q.empty() && dp[i] >= dp[q.back()]) q.pop_back();\\n            if (!q.empty() && q.front() <= i - k) q.pop_front();\\n            q.push_back(i);\\n        }\\n        \\n        return dp[n-1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2258245,
                "title": "python-3-solution-faster-than-86",
                "content": "```\\nlass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        h = [(-nums[0],0)]\\n        \\n        for i in range(1,N):\\n            while h[0][1]<i-k:\\n                heappop(h)\\n            max_so_far = h[0][0]\\n            heappush(h,(max_so_far-nums[i],i))\\n            if i == N-1:\\n                return -(max_so_far-nums[i])\\n        return nums[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nlass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        h = [(-nums[0],0)]\\n        \\n        for i in range(1,N):\\n            while h[0][1]<i-k:\\n                heappop(h)\\n            max_so_far = h[0][0]\\n            heappush(h,(max_so_far-nums[i],i))\\n            if i == N-1:\\n                return -(max_so_far-nums[i])\\n        return nums[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2258179,
                "title": "c-o-n-log-k-using-set-explained-using-proper-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int ans=nums[0], i=n-1;\\n        int dp[n];\\n\\t\\t//using pair because there may be same numbers too\\n        set<pair<int, int>> hp;\\n        dp[n-1]=nums[n-1];\\n        while(i--){\\n            hp.insert({dp[i+1], i+1});\\n\\t\\t\\t//maintaining the k sized window (removing the i+k+1 th element)\\n            if(i+k+1<n) hp.erase({dp[i+k+1], i+k+1});\\n\\t\\t\\t// main dp logic\\n\\t\\t\\t// we\\'re finding the maximum to reach from ith element to last element by adding the nums[i]th element and max of (dp[i+1], dp[i+k])\\n            dp[i] = nums[i]+(*(--hp.end())).first;\\n        }\\n\\t\\t//returning maximum to reach last element from 0th index\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int ans=nums[0], i=n-1;\\n        int dp[n];\\n\\t\\t//using pair because there may be same numbers too\\n        set<pair<int, int>> hp;\\n        dp[n-1]=nums[n-1];\\n        while(i--){\\n            hp.insert({dp[i+1], i+1});\\n\\t\\t\\t//maintaining the k sized window (removing the i+k+1 th element)\\n            if(i+k+1<n) hp.erase({dp[i+k+1], i+k+1});\\n\\t\\t\\t// main dp logic\\n\\t\\t\\t// we\\'re finding the maximum to reach from ith element to last element by adding the nums[i]th element and max of (dp[i+1], dp[i+k])\\n            dp[i] = nums[i]+(*(--hp.end())).first;\\n        }\\n\\t\\t//returning maximum to reach last element from 0th index\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258175,
                "title": "java-all-jump-game-solutions",
                "content": "https://leetcode.com/problems/jump-game/\\n**55. Jump Game: `TC: / SC: O(n) / O(1)`**\\n```\\n    public boolean canJump(int[] nums) {\\n        int max_reach = 0;\\n        \\n        for(int i =0; i < nums.length; i++) {\\n            if(i > max_reach) return false;\\n            \\n            max_reach = Math.max(max_reach, i + nums[i]);\\n        }\\n        \\n        return true;\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-ii/\\n**45. Jump Game II: `TC: / SC: O(n) / O(1)`**\\n```\\n    public int jump(int[] nums) {\\n        if(nums.length == 1) return 0;\\n        \\n        int temp = 0, max = 0, count = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(i > temp) {\\n                temp = max;\\n                max = 0;\\n                count++;\\n            }\\n            max = Math.max(max, nums[i] + i);\\n        }\\n        \\n        return count;\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-iii/\\n**1306. Jump Game III: `TC: / SC: O(n) / O(n)`**\\n```\\n    public static boolean[] jumped;\\n    public boolean canReach(int[] arr, int start) {\\n        jumped = new boolean[arr.length];\\n        \\n        return check(arr, start);\\n    }\\n    public boolean check(int[] arr, int i) {\\n        if(i >= arr.length || i < 0 || jumped[i]) return false;\\n        if(arr[i] == 0) return true;\\n        jumped[i] = true;\\n        \\n        return check(arr, i + arr[i]) || check(arr, i - arr[i]);\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-iv/\\n**1345. Jump Game IV: `TC: / SC: O(n) / O(n)`**\\n```\\n    public int minJumps(int[] arr) {\\n        int steps = 0;\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        \\n        for(int i = 0; i < arr.length; i++) \\n            map.computeIfAbsent(arr[i], li -> new ArrayList()).add(i);\\n        \\n        boolean[] jumped = new boolean[arr.length]; \\n        jumped[0] = true;\\n        Queue<Integer> q = new LinkedList<>(); \\n        q.offer(0);\\n        \\n        while(!q.isEmpty()) {\\n            for(int i = q.size(); i > 0; i--) {\\n                int temp = q.poll();\\n                if(temp == arr.length - 1) return steps;\\n                \\n                List<Integer> li = map.get(arr[temp]);\\n                if(temp != 0) li.add(temp - 1);\\n                if(temp != arr.length) li.add(temp + 1);\\n                \\n                for(int j : li) {\\n                    if(!jumped[j]) {\\n                        jumped[j] = true;\\n                        q.offer(j);\\n                    }\\n                }\\n                li.clear();\\n            }\\n            steps++;\\n        }\\n        \\n        return 0;\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-vi/submissions/\\n\\u2705**1696. Jump Game VI: `TC: / SC: O(n) / O(n)`**\\n```\\n    public int maxResult(int[] nums, int k) {\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        dq.offer(0);\\n        \\n        for(int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[dq.peekFirst()];\\n            \\n            while(!dq.isEmpty() && nums[dq.peekLast()] <= nums[i])\\n                dq.pollLast();\\n            dq.offer(i);\\n            \\n            if(i - dq.peekFirst() >= k) dq.pollFirst();\\n        } \\n        \\n        return nums[nums.length - 1];\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-vii/submissions/\\n**1871. Jump Game VII: `TC: / SC: O(n) / O(n)`**\\n```\\n    public boolean canReach(String s, int minJump, int maxJump) {\\n        int n = s.length(), available = 0;\\n        if(s.charAt(n - 1) == \\'1\\') return false;\\n        \\n        boolean[] dp = new boolean[n];\\n        dp[0] = true;\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(i >= minJump) available += dp[i - minJump] ? 1 : 0;\\n            if(i > maxJump) available -= dp[i - maxJump - 1] ? 1 : 0;\\n            \\n            dp[i] = available > 0 && s.charAt(i) == \\'0\\';\\n        }\\n        \\n        return dp[n - 1];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\n    public boolean canJump(int[] nums) {\\n        int max_reach = 0;\\n        \\n        for(int i =0; i < nums.length; i++) {\\n            if(i > max_reach) return false;\\n            \\n            max_reach = Math.max(max_reach, i + nums[i]);\\n        }\\n        \\n        return true;\\n    }\\n```\n```\\n    public int jump(int[] nums) {\\n        if(nums.length == 1) return 0;\\n        \\n        int temp = 0, max = 0, count = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(i > temp) {\\n                temp = max;\\n                max = 0;\\n                count++;\\n            }\\n            max = Math.max(max, nums[i] + i);\\n        }\\n        \\n        return count;\\n    }\\n```\n```\\n    public static boolean[] jumped;\\n    public boolean canReach(int[] arr, int start) {\\n        jumped = new boolean[arr.length];\\n        \\n        return check(arr, start);\\n    }\\n    public boolean check(int[] arr, int i) {\\n        if(i >= arr.length || i < 0 || jumped[i]) return false;\\n        if(arr[i] == 0) return true;\\n        jumped[i] = true;\\n        \\n        return check(arr, i + arr[i]) || check(arr, i - arr[i]);\\n    }\\n```\n```\\n    public int minJumps(int[] arr) {\\n        int steps = 0;\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        \\n        for(int i = 0; i < arr.length; i++) \\n            map.computeIfAbsent(arr[i], li -> new ArrayList()).add(i);\\n        \\n        boolean[] jumped = new boolean[arr.length]; \\n        jumped[0] = true;\\n        Queue<Integer> q = new LinkedList<>(); \\n        q.offer(0);\\n        \\n        while(!q.isEmpty()) {\\n            for(int i = q.size(); i > 0; i--) {\\n                int temp = q.poll();\\n                if(temp == arr.length - 1) return steps;\\n                \\n                List<Integer> li = map.get(arr[temp]);\\n                if(temp != 0) li.add(temp - 1);\\n                if(temp != arr.length) li.add(temp + 1);\\n                \\n                for(int j : li) {\\n                    if(!jumped[j]) {\\n                        jumped[j] = true;\\n                        q.offer(j);\\n                    }\\n                }\\n                li.clear();\\n            }\\n            steps++;\\n        }\\n        \\n        return 0;\\n    }\\n```\n```\\n    public int maxResult(int[] nums, int k) {\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        dq.offer(0);\\n        \\n        for(int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[dq.peekFirst()];\\n            \\n            while(!dq.isEmpty() && nums[dq.peekLast()] <= nums[i])\\n                dq.pollLast();\\n            dq.offer(i);\\n            \\n            if(i - dq.peekFirst() >= k) dq.pollFirst();\\n        } \\n        \\n        return nums[nums.length - 1];\\n    }\\n```\n```\\n    public boolean canReach(String s, int minJump, int maxJump) {\\n        int n = s.length(), available = 0;\\n        if(s.charAt(n - 1) == \\'1\\') return false;\\n        \\n        boolean[] dp = new boolean[n];\\n        dp[0] = true;\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(i >= minJump) available += dp[i - minJump] ? 1 : 0;\\n            if(i > maxJump) available -= dp[i - maxJump - 1] ? 1 : 0;\\n            \\n            dp[i] = available > 0 && s.charAt(i) == \\'0\\';\\n        }\\n        \\n        return dp[n - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2258120,
                "title": "java-easy-to-understand-1d-dynamic-programming",
                "content": "```\\nclass Solution {\\n    \\n    class Pair{\\n        int num;\\n        int index;\\n\\n        Pair(int num, int index){\\n            this.num = num;\\n            this.index = index;\\n        }\\n    }\\n    \\n    public int maxResult(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        PriorityQueue<Pair> pq = new PriorityQueue<>(new Comparator<Pair>() {\\n            @Override\\n            public int compare(Pair o1, Pair o2) {\\n                return o2.num - o1.num;\\n            }\\n        });\\n\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            if(i == nums.length - 1){\\n                dp[i] = nums[i];\\n                pq.add(new Pair(nums[i], i));\\n            }else{\\n                int start = i+1;\\n                int end = Math.min(nums.length - 1, i + k);\\n\\n                if(start == end){\\n                    dp[i] = nums[i] + dp[i+1];\\n                    pq.add(new Pair(dp[i], i));\\n                }else{\\n                    while (!pq.isEmpty()){\\n                        Pair p = pq.peek();\\n\\n                        if(p.index >= start && p.index <= end){\\n                            dp[i] = nums[i] + p.num;\\n                            pq.add(new Pair(dp[i], i));\\n                            break;\\n                        }else{\\n                            pq.poll();\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class Pair{\\n        int num;\\n        int index;\\n\\n        Pair(int num, int index){\\n            this.num = num;\\n            this.index = index;\\n        }\\n    }\\n    \\n    public int maxResult(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        PriorityQueue<Pair> pq = new PriorityQueue<>(new Comparator<Pair>() {\\n            @Override\\n            public int compare(Pair o1, Pair o2) {\\n                return o2.num - o1.num;\\n            }\\n        });\\n\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            if(i == nums.length - 1){\\n                dp[i] = nums[i];\\n                pq.add(new Pair(nums[i], i));\\n            }else{\\n                int start = i+1;\\n                int end = Math.min(nums.length - 1, i + k);\\n\\n                if(start == end){\\n                    dp[i] = nums[i] + dp[i+1];\\n                    pq.add(new Pair(dp[i], i));\\n                }else{\\n                    while (!pq.isEmpty()){\\n                        Pair p = pq.peek();\\n\\n                        if(p.index >= start && p.index <= end){\\n                            dp[i] = nums[i] + p.num;\\n                            pq.add(new Pair(dp[i], i));\\n                            break;\\n                        }else{\\n                            pq.poll();\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258004,
                "title": "java-solution-explained-priority-queue",
                "content": "**Java Solution Approach Explained | Easy Understanding | Priority Queue**\\nIntuition : Keep track of the maximum score we can get for the i\\'th index, to do that we will make sure that the max element is at the top of the Priority Queue. How can we do that? \\n\\nHere is the idea : Remove all the maximum elements from the PQ from which the current is not reachable. \\nWe will do this till we get the maximum value the top with an index which is between Math.max(0, index - k), index)\\n\\nImplementation : \\n\\n```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        // edge cases\\n        if(nums == null || nums.length == 0){\\n            return 0;\\n        }\\n        // initialization\\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> (b[0] - a[0]));\\n        // score to index mapping\\n        maxHeap.add(new int[] {nums[0], 0});\\n        int score = nums[0];\\n        \\n        // iterate over the elements\\n        for(int index = 1;index < nums.length;index++){\\n            // remove all the maximum while are out of the scope\\n            while(maxHeap.size() > 1 && maxHeap.peek()[1] < index - k){\\n                maxHeap.poll();\\n            }\\n            \\n            // add the maximum current score with the index value\\n            maxHeap.add(new int[] {(score = nums[index] + maxHeap.peek()[0]), index});\\n        }\\n        \\n        return score;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        // edge cases\\n        if(nums == null || nums.length == 0){\\n            return 0;\\n        }\\n        // initialization\\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> (b[0] - a[0]));\\n        // score to index mapping\\n        maxHeap.add(new int[] {nums[0], 0});\\n        int score = nums[0];\\n        \\n        // iterate over the elements\\n        for(int index = 1;index < nums.length;index++){\\n            // remove all the maximum while are out of the scope\\n            while(maxHeap.size() > 1 && maxHeap.peek()[1] < index - k){\\n                maxHeap.poll();\\n            }\\n            \\n            // add the maximum current score with the index value\\n            maxHeap.add(new int[] {(score = nums[index] + maxHeap.peek()[0]), index});\\n        }\\n        \\n        return score;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257887,
                "title": "easy-c-dp-solution-using-max-heap-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(n,0); // to store the maximum score till the i^th index.\\n        \\n        priority_queue<pair<int, int>> pq; // to store the answers in the heap so that we can retrieve the\\n                                           // max element directly from the heap instead of maintaining two for loops\\n        \\n        dp[0] = nums[0];\\n        pq.push({dp[0], 0});\\n        \\n        // The idea is to calculate the maximium score we can find for the i^th index,\\n        // considering we can reach position i from positions (i-1) ---> (i-k).\\n        // so inorder to do that we can make use of heap data strucutre to store the maximum result\\n        // in the range (i-1) ---> (i-k), which can be easily used to fetch from the heap.\\n        for(int i=1;i<n;i++){\\n            while(pq.size() and pq.top().second < i-k) pq.pop(); // if we are at the i^th position it\\'s uneccessary to\\n                                                                 // keep track of the elements who are positioned at\\n                                                                 // indices less than (i-k)          \\n            \\n            \\n            dp[i] = nums[i] +  pq.top().first ; // This is the step where we precisely get the maximum element\\n                                                // from the heap data strucutre (i.e.) max(dp[i-1]......dp[i-k])\\n           \\n            \\n            pq.push({dp[i], i}); // finally push the calculated answer into heap so that in future calculations\\n                                 // somewhere for some  i^th index this might fall in the range (i-1) ---> (i-k).\\n        }\\n       \\n        return dp[n-1]; // finally our answer will be stored at the last index.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(n,0); // to store the maximum score till the i^th index.\\n        \\n        priority_queue<pair<int, int>> pq; // to store the answers in the heap so that we can retrieve the\\n                                           // max element directly from the heap instead of maintaining two for loops\\n        \\n        dp[0] = nums[0];\\n        pq.push({dp[0], 0});\\n        \\n        // The idea is to calculate the maximium score we can find for the i^th index,\\n        // considering we can reach position i from positions (i-1) ---> (i-k).\\n        // so inorder to do that we can make use of heap data strucutre to store the maximum result\\n        // in the range (i-1) ---> (i-k), which can be easily used to fetch from the heap.\\n        for(int i=1;i<n;i++){\\n            while(pq.size() and pq.top().second < i-k) pq.pop(); // if we are at the i^th position it\\'s uneccessary to\\n                                                                 // keep track of the elements who are positioned at\\n                                                                 // indices less than (i-k)          \\n            \\n            \\n            dp[i] = nums[i] +  pq.top().first ; // This is the step where we precisely get the maximum element\\n                                                // from the heap data strucutre (i.e.) max(dp[i-1]......dp[i-k])\\n           \\n            \\n            pq.push({dp[i], i}); // finally push the calculated answer into heap so that in future calculations\\n                                 // somewhere for some  i^th index this might fall in the range (i-1) ---> (i-k).\\n        }\\n       \\n        return dp[n-1]; // finally our answer will be stored at the last index.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257860,
                "title": "simplest-java-code-70-less-time-o-n-solution-15-lines-of-code",
                "content": "Here work is done repeatedly that\\'s why to use dp\\n        \\n Logic: \\n**Step 1:** make the **monotonic Queue**(A monotonic Queue is a data structure in the elements from the front to the end is **strictly either increasing or decreasing.**) to push the nums\\'s index to push it into it which has a maximum value.\\n\\n**Step 2:** make **dp of size n** to store the sum of the maximum of previous k steps.\\n\\n**Step 3:** now **start traversal of nums** from the last element and **add the sum to dp** and the curr Sum is maximum than the queue.peek than add that index to the queue.\\n\\n**Step 4:** **return dp[0]** as an answer.\\n        \\n\\t\\t\\n\\n```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        \\n        //make monotone queue\\n        Deque<Integer> queue=new LinkedList<>();\\n        //make the dp \\n        int n=nums.length;\\n        int[] dp=new int[n];\\n        \\n        //push last index (bez right now assume that it is the max) to the queue.\\n        queue.add(n-1);\\n        dp[n-1]=nums[n-1];\\n        \\n        \\n        for(int i=n-2;i>=0;i--){\\n            \\n            //check for that we won\\'t exceeding max jump k\\n            if(queue.peek()-i > k) \\n                queue.removeFirst();\\n            \\n            //add the sum to dp \\n            dp[i]=nums[i] + dp[queue.peek()];\\n            \\n            //check that current dp[i] sum is while greater than the queue store index than remove it bez in queue we store the max sum index only\\n            while(queue.size()!=0 && dp[i]>dp[queue.getLast()]) \\n                queue.removeLast();\\n            \\n            //push the current dp index to dp\\n            queue.add(i);\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        \\n        //make monotone queue\\n        Deque<Integer> queue=new LinkedList<>();\\n        //make the dp \\n        int n=nums.length;\\n        int[] dp=new int[n];\\n        \\n        //push last index (bez right now assume that it is the max) to the queue.\\n        queue.add(n-1);\\n        dp[n-1]=nums[n-1];\\n        \\n        \\n        for(int i=n-2;i>=0;i--){\\n            \\n            //check for that we won\\'t exceeding max jump k\\n            if(queue.peek()-i > k) \\n                queue.removeFirst();\\n            \\n            //add the sum to dp \\n            dp[i]=nums[i] + dp[queue.peek()];\\n            \\n            //check that current dp[i] sum is while greater than the queue store index than remove it bez in queue we store the max sum index only\\n            while(queue.size()!=0 && dp[i]>dp[queue.getLast()]) \\n                queue.removeLast();\\n            \\n            //push the current dp index to dp\\n            queue.add(i);\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257785,
                "title": "easy-4-line-code-dp-tabulation-deque",
                "content": "DP Tabulation approach using deque\\n\\nComments added for your understanding\\n\\n**Plz Upvote**\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        //initialize\\n        vector<int> dp(n);\\n        dp[0] = nums[0];\\n        \\n        deque<int> q{0};\\n        \\n        for(int i = 1; i < n; i++){\\n            if(q.front() < i - k) q.pop_front();         // can\\'t reach current index from index stored in q \\n            \\n            dp[i] = nums[i] + dp[q.front()];             // update max score for current index\\n            \\n            while(!q.empty() && dp[q.back()] <= dp[i])   // pop indices which won\\'t be ever chosen in the future\\n                q.pop_back();\\n            \\n            q.push_back(i);                              // insert current index\\n        }\\n        return dp.back();\\n    }\\n    \\n};\\n```\\n**plz upvote**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        //initialize\\n        vector<int> dp(n);\\n        dp[0] = nums[0];\\n        \\n        deque<int> q{0};\\n        \\n        for(int i = 1; i < n; i++){\\n            if(q.front() < i - k) q.pop_front();         // can\\'t reach current index from index stored in q \\n            \\n            dp[i] = nums[i] + dp[q.front()];             // update max score for current index\\n            \\n            while(!q.empty() && dp[q.back()] <= dp[i])   // pop indices which won\\'t be ever chosen in the future\\n                q.pop_back();\\n            \\n            q.push_back(i);                              // insert current index\\n        }\\n        return dp.back();\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257708,
                "title": "cleanest-python3-solution-explanation-complexity-analysis-sliding-window-dp",
                "content": "### Breakdown\\n\\nLet\\'s start with the most intuitive DP solution. To reach an index `i`, you can jump from previous `k` indices before that. Simply choose one such index that gives you the maximum score.\\n\\n```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        for i in range(1, len(nums)):\\n            nums[i] += max(nums[j] for j in range(max(i-k, 0), i))\\n        \\n        return nums[-1]\\n```\\n\\nAssuming `N` numbers and `K` max jump size, the time complexity comes out to be `O(N * K)` which is pretty high for this problem\\'s constraints (TLE).\\n\\nOptimization \\u2013\\xA0Looking at the past `K` indices is expensive; we can reduce it down to `O(1)` by using sliding window maximum / max-queue.\\n\\n### Code\\n```\\nclass MaxQueue:\\n    def __init__(self):\\n        self.queue = deque()\\n        self.max_queue = deque()\\n    \\n    def append(self, val):\\n        self.queue.append(val)\\n        \\n        while self.max_queue and self.max_queue[-1] < val:\\n            self.max_queue.pop()\\n\\n        self.max_queue.append(val)\\n    \\n    def popleft(self):\\n        val = self.queue.popleft()\\n        \\n        if self.max_queue[0] == val:\\n            self.max_queue.popleft()\\n        \\n        return val\\n    \\n    def getmax(self):\\n        return self.max_queue[0]\\n    \\n    def __len__(self):\\n        return len(self.queue)\\n\\n    \\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        mq = MaxQueue()\\n        mq.append(nums[0])\\n        \\n        for i in range(1, len(nums)):\\n            nums[i] += mq.getmax()\\n            mq.append(nums[i])\\n            \\n            if len(mq) > k:\\n                mq.popleft()\\n        \\n        return nums[-1]\\n```\\n\\n### Complexity analysis\\n\\nLet `N` be the size of the input and `K` max jump size, then:\\n1. Time complexity \\u2013\\xA0`O(N)` since we evaluate max score for each index, and max lookup at each index takes constant time.\\n2. Space complexity = `O(K)` since our queue never needs more than K elements.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        for i in range(1, len(nums)):\\n            nums[i] += max(nums[j] for j in range(max(i-k, 0), i))\\n        \\n        return nums[-1]\\n```\n```\\nclass MaxQueue:\\n    def __init__(self):\\n        self.queue = deque()\\n        self.max_queue = deque()\\n    \\n    def append(self, val):\\n        self.queue.append(val)\\n        \\n        while self.max_queue and self.max_queue[-1] < val:\\n            self.max_queue.pop()\\n\\n        self.max_queue.append(val)\\n    \\n    def popleft(self):\\n        val = self.queue.popleft()\\n        \\n        if self.max_queue[0] == val:\\n            self.max_queue.popleft()\\n        \\n        return val\\n    \\n    def getmax(self):\\n        return self.max_queue[0]\\n    \\n    def __len__(self):\\n        return len(self.queue)\\n\\n    \\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        mq = MaxQueue()\\n        mq.append(nums[0])\\n        \\n        for i in range(1, len(nums)):\\n            nums[i] += mq.getmax()\\n            mq.append(nums[i])\\n            \\n            if len(mq) > k:\\n                mq.popleft()\\n        \\n        return nums[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257641,
                "title": "simple-c-solution-using-dp-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int maxResult(vector<int>& nums, int k) {\\n        \\n       vector<int>t(nums.size(),0);\\n     \\n        t[0]=nums[0];\\n        \\n        priority_queue<pair<int,int>>q;\\n        q.push({nums[0],0});\\n        \\n        for(int i=1;i<nums.size();i++){\\n            \\n            while(q.top().second<i-k)\\n            q.pop();\\n            \\n            t[i]=nums[i]+q.top().first;\\n            q.push({t[i],i});\\n        }\\n        \\n        return t[nums.size()-1];\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxResult(vector<int>& nums, int k) {\\n        \\n       vector<int>t(nums.size(),0);\\n     \\n        t[0]=nums[0];\\n        \\n        priority_queue<pair<int,int>>q;\\n        q.push({nums[0],0});\\n        \\n        for(int i=1;i<nums.size();i++){\\n            \\n            while(q.top().second<i-k)\\n            q.pop();\\n            \\n            t[i]=nums[i]+q.top().first;\\n            q.push({t[i],i});\\n        }\\n        \\n        return t[nums.size()-1];\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257620,
                "title": "java-solutions",
                "content": "class Solution {\\n    public int maxResult(int[] nums, int k) {\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        dq.add(0);\\n        for(int i = 1; i < nums.length; i++){\\n            nums[i] += nums[dq.peek()];\\n             if(i - k == dq.peek())dq.poll();\\n            while(dq.size() > 0 && nums[dq.peekLast()] <= nums[i])dq.pollLast();\\n            dq.add(i);\\n        }\\n        return nums[nums.length-1];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxResult(int[] nums, int k) {\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        dq.add(0);\\n        for(int i = 1; i < nums.length; i++){\\n            nums[i] += nums[dq.peek()];\\n             if(i - k == dq.peek())dq.poll();\\n            while(dq.size() > 0 && nums[dq.peekLast()] <= nums[i])dq.pollLast();\\n            dq.add(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2257618,
                "title": "c-fast-and-efficient-solution-using-deque",
                "content": "class Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        \\n        deque< int > q;\\n        \\n        int n = nums.size();\\n        q.push_back( 0 );\\n        for( int i = 1; i < n; i++ ) {\\n            \\n            while( k + q.front() < i )\\n                q.pop_front();\\n            \\n            nums[ i ] += nums[ q.front() ];\\n            while( q.size() > 0 and nums[ i ] >= nums[ q.back() ] )\\n                q.pop_back();\\n            \\n            q.push_back( i );\\n            \\n        }\\n        \\n        return nums[ n - 1 ];\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        \\n        deque< int > q;\\n        \\n        int n = nums.size();\\n        q.push_back( 0 );\\n        for( int i = 1; i < n; i++ ) {\\n            \\n            while( k + q.front() < i )\\n                q.pop_front();\\n            \\n            nums[ i ] += nums[ q.front() ];\\n            while( q.size() > 0 and nums[ i ] >= nums[ q.back() ] )\\n                q.pop_back();\\n            \\n            q.push_back( i );\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2257606,
                "title": "dp-priority-queue-python-solutions-explanation",
                "content": "#### Amortized Analysis\\n---\\nTime Complexity: O(nlog(n))\\nSpace Complexity: O(n)\\n\\n#### Explanitaion\\n---\\n##### Observation\\nAs we are caring about maximizing the score and while running dp we know that the position (i<sup>th</sup>) already calculated is at it\\'s optimal state\\n\\nExample:\\nlets say we have DP array that tracking the max number. and as bottom up dp we are calculate right to left so when we done i<sup>th</sup> index calculation we know that from `i` to `n-1` we hav optimal solution stored on each position. to find the maximum number for i<sup>th</sup> position we do not need to search `i + 1` to `n-1` if we can keep the max it will solve the problem.\\n\\nNow for this problem as we can only check up to `k` index from `i` we can\\'t just keep a simple variable to track the value. we need a priority queue (max heap) to track `k` maximum dp state\\n\\n##### Algorithm\\n**Step 1:** initialize max_heap with `nums[n-1]` also track the index\\n**Step 2:** loop `i` from `n-2` to `0` \\n**Step 3:** if current top heap element index is grater than `i+k` then discard it from the heap until top index is within `i + k` range\\n**Step 4:** add current `nums[i]` to top heap and put it to the heap\\n**Step 5:** return the 0<sup>th</sup> index from the heap\\n\\n#### Code\\n---\\n```python\\nfrom heapq import heappush as hpush, heappop as hpop\\n\\n\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        max_heap = [(-nums[-1], n - 1)]\\n        res = nums[-1]\\n        for i in range(n-2, -1, -1):\\n            while heap and heap[0][1] > i + k:\\n                hpop(heap)\\n            res = nums[i] - max_heap[0][0]  # as max_heap already has opposite sign number, so - * - => + \\n            hpush(heap, (-res, i) )\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nfrom heapq import heappush as hpush, heappop as hpop\\n\\n\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        max_heap = [(-nums[-1], n - 1)]\\n        res = nums[-1]\\n        for i in range(n-2, -1, -1):\\n            while heap and heap[0][1] > i + k:\\n                hpop(heap)\\n            res = nums[i] - max_heap[0][0]  # as max_heap already has opposite sign number, so - * - => + \\n            hpush(heap, (-res, i) )\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257576,
                "title": "dp-and-using-heap-for-maximum-previous-sum-atmost-k-apart",
                "content": "```\\nimport heapq\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        heap = []\\n        deleted = defaultdict(int)\\n        heapq.heappush(heap, -nums[0])\\n        for i in range(1, n):\\n            msum = heap[0]\\n            while msum in deleted:\\n                deleted[msum] -= 1\\n                if deleted[msum] == 0:\\n                    del deleted[msum]\\n                heapq.heappop(heap)\\n                msum = heap[0]\\n            dp[i] = nums[i] - msum\\n            heapq.heappush(heap, -dp[i])\\n            if i >= k:\\n                deleted[-dp[i - k]] += 1\\n        return dp[n - 1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport heapq\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        heap = []\\n        deleted = defaultdict(int)\\n        heapq.heappush(heap, -nums[0])\\n        for i in range(1, n):\\n            msum = heap[0]\\n            while msum in deleted:\\n                deleted[msum] -= 1\\n                if deleted[msum] == 0:\\n                    del deleted[msum]\\n                heapq.heappop(heap)\\n                msum = heap[0]\\n            dp[i] = nums[i] - msum\\n            heapq.heappush(heap, -dp[i])\\n            if i >= k:\\n                deleted[-dp[i - k]] += 1\\n        return dp[n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257553,
                "title": "java-solution-priority-queue",
                "content": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        if(nums.length==0)return 0;\\n        \\n        int max=nums[0];\\n        Queue<int[]> pq = new PriorityQueue<>((a,b)-> (b[0]-a[0]));\\n        pq.offer(new int[]{nums[0],0});\\n        for(int i=1;i<nums.length;i++){\\n            \\n            while(i-pq.peek()[1]>k){\\n                pq.poll();\\n            }\\n            int[] curr = pq.peek();\\n            max = nums[i]+ curr[0];\\n            pq.offer(new int[]{max,i});\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int maxResult(int[] nums, int k) {\\n        if(nums.length==0)return 0;\\n        \\n        int max=nums[0];\\n        Queue<int[]> pq = new PriorityQueue<>((a,b)-> (b[0]-a[0]));\\n        pq.offer(new int[]{nums[0],0}",
                "codeTag": "Java"
            },
            {
                "id": 2257485,
                "title": "c-heap-deque-two-solutions",
                "content": "**Priority_Queue**\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        //base cases\\n        if(nums.size()==1) return nums[0];\\n        if(k==1) return (accumulate(nums.begin(),nums.end(),0));\\n        \\n        priority_queue<pair<int,int>>maxHeap;\\n        maxHeap.push({nums[0],0});\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            //exclude the elements which are out of bound\\n            while(i-maxHeap.top().second > k) maxHeap.pop();\\n            maxHeap.push({maxHeap.top().first+nums[i],i});\\n        }\\n        //match the index\\n        while(!maxHeap.empty())\\n        {\\n            if(maxHeap.top().second == nums.size()-1) return maxHeap.top().first;\\n            else maxHeap.pop();\\n        }\\n        //TC in worst case => O(N*log(N-K)) , SC=O(N)\\n        return -1;\\n    }\\n};\\n```\\n**Deque**\\n```\\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(NULL); cin.tie(NULL);cout.tie(NULL);\\n    }\\n    \\n    int maxResult(vector<int>& nums, int k) {\\n        //base cases\\n        if(nums.size()==1) return nums[0];\\n        if(k==1) return (accumulate(nums.begin(),nums.end(),0));\\n        \\n        deque<pair<int,int>>dq;\\n        //initialize the deque\\n        dq.push_back({nums[0],0});\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            //check if the greatest value either out of range or not\\n            while(i-dq.front().second > k) dq.pop_front();\\n            int val = dq.front().first+nums[i];\\n            //excluding the small(useless) values\\n            while(!dq.empty() &&val > dq.back().first) dq.pop_back();\\n            //push the current val\\n            dq.push_back({val,i});\\n        }\\n        \\n        //matching the index with last index\\n        while(!dq.empty())\\n        {\\n            if(dq.front().second == nums.size()-1) return dq.front().first;\\n            else dq.pop_front();\\n        }\\n        //TC => O(N) , SC=> O(N)\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        //base cases\\n        if(nums.size()==1) return nums[0];\\n        if(k==1) return (accumulate(nums.begin(),nums.end(),0));\\n        \\n        priority_queue<pair<int,int>>maxHeap;\\n        maxHeap.push({nums[0],0});\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            //exclude the elements which are out of bound\\n            while(i-maxHeap.top().second > k) maxHeap.pop();\\n            maxHeap.push({maxHeap.top().first+nums[i],i});\\n        }\\n        //match the index\\n        while(!maxHeap.empty())\\n        {\\n            if(maxHeap.top().second == nums.size()-1) return maxHeap.top().first;\\n            else maxHeap.pop();\\n        }\\n        //TC in worst case => O(N*log(N-K)) , SC=O(N)\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(NULL); cin.tie(NULL);cout.tie(NULL);\\n    }\\n    \\n    int maxResult(vector<int>& nums, int k) {\\n        //base cases\\n        if(nums.size()==1) return nums[0];\\n        if(k==1) return (accumulate(nums.begin(),nums.end(),0));\\n        \\n        deque<pair<int,int>>dq;\\n        //initialize the deque\\n        dq.push_back({nums[0],0});\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            //check if the greatest value either out of range or not\\n            while(i-dq.front().second > k) dq.pop_front();\\n            int val = dq.front().first+nums[i];\\n            //excluding the small(useless) values\\n            while(!dq.empty() &&val > dq.back().first) dq.pop_back();\\n            //push the current val\\n            dq.push_back({val,i});\\n        }\\n        \\n        //matching the index with last index\\n        while(!dq.empty())\\n        {\\n            if(dq.front().second == nums.size()-1) return dq.front().first;\\n            else dq.pop_front();\\n        }\\n        //TC => O(N) , SC=> O(N)\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2257477,
                "title": "c-dp-solution-both-optimized-and-unoptimized",
                "content": "**Idea:** So, lets define a dp array such that dp[i] = maximum score to reach ith index of the array.\\nNow we can define the recursion. \\nFor dp[i], what could have been the last step? We could either have jumped from i-1 index, or i-2 index, .......upto i-k index.(assuming those exist).\\n**dp[i] = max(dp[i-1],[i-2],....,dp[i-k])+nums[i]**\\n \\n(nums[i] will be the cost of jumping to the ith index)\\n**1st Approach:** [TLE]\\nThis is unoptimized DP approach. We have to find dp[n], so for that we have to iterate over the whole array. And for finding dp[i], we want the max of last k elements in the array.\\n**Time Complexity: O(n*k)**\\n**Space Complexity:O(n)**\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int dp[n];\\n        dp[0]=nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            int l=max(i-k,0);\\n            int val=INT_MIN;\\n            for(int j=l;j<=i-1;j++){\\n                val = max(dp[j] ,val);\\n            }\\n            dp[i]=val+nums[i];\\n        }\\n        return dp[n-1];\\n        \\n    }\\n};\\n```\\n\\n\\n**2nd Approach:**  [Accepted]\\nSince we need the max of the last k elements, every time, there\\'s no need to iterate every time in a loop. Instead , we can use a multiset and can access to its last element every time (since it stores in increasing order) . Every time , the length of this set becomes more than k, we erase the [i-k-1]th element.\\n**Time Complexity: O(n*log(k))**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int dp[n];\\n        dp[0]=nums[0];\\n        multiset<int> s;\\n        s.insert(dp[0]);\\n        \\n        for(int i=1;i<n;i++){\\n            if(i>k) {\\n                s.erase(s.find(dp[i-k-1]));\\n            }\\n            \\n            dp[i] = *rbegin(s)+nums[i];\\n            s.insert(dp[i]);\\n            \\n        }\\n        return dp[n-1];\\n        \\n    }\\n};\\n```\\n**3rd Approach:** [Accepted]\\nWe can further optimize the  second solution using deque.\\n**Time Complexity:O(n)**\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int dp[n];\\n        dp[0]=nums[0];\\n        deque<int> dq;\\n        dq.push_back(0);\\n        \\n        for(int i=1;i<n;i++){\\n            if(dq.front() < i-k) {\\n                 dq.pop_front(); \\n            }\\n            dp[i] = nums[i] + dp[dq.front()];\\n            while(!dq.empty() && dp[dq.back()] <= dp[i]){\\n                dq.pop_back();\\n\\t\\t       \\n            }\\n            dq.push_back(i); \\n\\t\\t       \\n            \\n        }\\n        return dp[n-1];\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int dp[n];\\n        dp[0]=nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            int l=max(i-k,0);\\n            int val=INT_MIN;\\n            for(int j=l;j<=i-1;j++){\\n                val = max(dp[j] ,val);\\n            }\\n            dp[i]=val+nums[i];\\n        }\\n        return dp[n-1];\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int dp[n];\\n        dp[0]=nums[0];\\n        multiset<int> s;\\n        s.insert(dp[0]);\\n        \\n        for(int i=1;i<n;i++){\\n            if(i>k) {\\n                s.erase(s.find(dp[i-k-1]));\\n            }\\n            \\n            dp[i] = *rbegin(s)+nums[i];\\n            s.insert(dp[i]);\\n            \\n        }\\n        return dp[n-1];\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int dp[n];\\n        dp[0]=nums[0];\\n        deque<int> dq;\\n        dq.push_back(0);\\n        \\n        for(int i=1;i<n;i++){\\n            if(dq.front() < i-k) {\\n                 dq.pop_front(); \\n            }\\n            dp[i] = nums[i] + dp[dq.front()];\\n            while(!dq.empty() && dp[dq.back()] <= dp[i]){\\n                dq.pop_back();\\n\\t\\t       \\n            }\\n            dq.push_back(i); \\n\\t\\t       \\n            \\n        }\\n        return dp[n-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257453,
                "title": "python-o-n-time-and-o-k-space",
                "content": "```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        #we need to store the maximum score from i-k to ith index and for that we will use a deque\\n        maxIndex = deque()\\n        maxIndex.append(0)\\n        for i in range(1,len(nums)):\\n            index = maxIndex[0]\\n            while i - index > k and len(maxIndex) > 0:\\n                maxIndex.popleft()\\n                index = maxIndex[0]\\n            nums[i] = nums[i] + nums[index]\\n            last = maxIndex[len(maxIndex)-1]\\n            while len(maxIndex) > 0 and  nums[last] <= nums[i]:\\n                maxIndex.pop()\\n                if len(maxIndex) >0:\\n                    last = maxIndex[len(maxIndex)-1]\\n            maxIndex.append(i)\\n        return nums[-1]\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxResult(self, nums: List[int], k: int) -> int:\\n        #we need to store the maximum score from i-k to ith index and for that we will use a deque\\n        maxIndex = deque()\\n        maxIndex.append(0)\\n        for i in range(1,len(nums)):\\n            index = maxIndex[0]\\n            while i - index > k and len(maxIndex) > 0:\\n                maxIndex.popleft()\\n                index = maxIndex[0]\\n            nums[i] = nums[i] + nums[index]\\n            last = maxIndex[len(maxIndex)-1]\\n            while len(maxIndex) > 0 and  nums[last] <= nums[i]:\\n                maxIndex.pop()\\n                if len(maxIndex) >0:\\n                    last = maxIndex[len(maxIndex)-1]\\n            maxIndex.append(i)\\n        return nums[-1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2257281,
                "title": "please-someone-explain-why-this-dp-solution-is-not-working-c",
                "content": "```\\nint maxResult(vector<int>& nums, int k) \\n    {\\n        int n=nums.size();\\n        vector<int>dp(n,0);\\n        dp[n-1]=nums[n-1];\\n        for(int ind=n-2;ind>=0;ind--)\\n        {\\n            int ans=-1e9;\\n            for(int i=ind+1;i<=ind+k && i<n ;i++)\\n            {\\n                ans=max(ans, nums[ind]+ dp[i]);\\n            }\\n            dp[ind]= ans;\\n        }\\n        \\n        \\n        int x= dp[0];\\n        if(x==-1e9)\\n            return 0;\\n        return x;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint maxResult(vector<int>& nums, int k) \\n    {\\n        int n=nums.size();\\n        vector<int>dp(n,0);\\n        dp[n-1]=nums[n-1];\\n        for(int ind=n-2;ind>=0;ind--)\\n        {\\n            int ans=-1e9;\\n            for(int i=ind+1;i<=ind+k && i<n ;i++)\\n            {\\n                ans=max(ans, nums[ind]+ dp[i]);\\n            }\\n            dp[ind]= ans;\\n        }\\n        \\n        \\n        int x= dp[0];\\n        if(x==-1e9)\\n            return 0;\\n        return x;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2257184,
                "title": "jump-game-vi-dp-explanation-solution-with-comments-priority-queue",
                "content": "Jump Game VI : \\n\\tPre Requisites : \\n\\t1) Priority Queue\\n\\t2) Jump Game I, II, III, IV, V (Optional)\\n\\nWe will make a priority queue for storing the maximum possible score from that position and the position itself, i.e we will make a priority_queue of pair of maximum score and index.\\n\\nNow, We are traversing From Back, But You Can Do it from front as well......\\n\\nWhat we will do is, we will start traversing from back and will check the priority queue, if the maximum score is available at an index at distance more than k, than we will pop it. Now, whatever will be at top will be the maximum score possible, so we will add score of this index and thus, we will get maximum possible score from this index. We will push it into priority_queue and will continue the procedure till i = 0; The last score will be our answer . Thank You !!!\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        \\n        // Priority Queue For Storing Maximum Value From That Point and Index Of That Point For Identifying Whether We Can Jump Upto That Point Or Not\\n        priority_queue<pair<int, int>> pq;\\n        \\n        // DP for storing the maximum values upto that point\\n        vector<int> dp(nums.size(), 0);\\n        \\n        // Base Case\\n        dp[nums.size() - 1] = nums[nums.size() - 1];\\n        pq.push({nums[nums.size() - 1], nums.size() - 1});\\n        \\n        // We are traversing From Right, You Can Traverse From Left As Well\\n        for(int i = nums.size() - 2; i >= 0; i--) {\\n            \\n            // While The Maximum Element is Out Of Range, Keep Popping Out\\n            while(pq.top().second > i + k) pq.pop();\\n            \\n            // Now, The Element With Maximum Score and Within The Range will be the Best To Jump From This Position \\n            dp[i] = nums[i] + pq.top().first;\\n            \\n            // Now, Push Maximum Score From This Index and The Index Itself\\n            pq.push({dp[i], i});\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        \\n        // Priority Queue For Storing Maximum Value From That Point and Index Of That Point For Identifying Whether We Can Jump Upto That Point Or Not\\n        priority_queue<pair<int, int>> pq;\\n        \\n        // DP for storing the maximum values upto that point\\n        vector<int> dp(nums.size(), 0);\\n        \\n        // Base Case\\n        dp[nums.size() - 1] = nums[nums.size() - 1];\\n        pq.push({nums[nums.size() - 1], nums.size() - 1});\\n        \\n        // We are traversing From Right, You Can Traverse From Left As Well\\n        for(int i = nums.size() - 2; i >= 0; i--) {\\n            \\n            // While The Maximum Element is Out Of Range, Keep Popping Out\\n            while(pq.top().second > i + k) pq.pop();\\n            \\n            // Now, The Element With Maximum Score and Within The Range will be the Best To Jump From This Position \\n            dp[i] = nums[i] + pq.top().first;\\n            \\n            // Now, Push Maximum Score From This Index and The Index Itself\\n            pq.push({dp[i], i});\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257160,
                "title": "ruby-dp-t-o-n-s-o-n-100-100",
                "content": "This approach uses DP and 2 pointers\\n\\nWe\\'ll have 2 pointers i and j that never decreases, each one runs from 0 to n - 1, ensure the time complexity is O(n) in the worst case.\\n\\n(1) If the max_result at j greater than one at i, that means the max_result at t for all t > j when iterating from i is always less than when iterating from j. There is no point to keep the loop in i because it will be overridden when we got to j anyway. So in this case, we\\'ll update i = j, j = j + 1 and continue the loop.\\n(2) If the max_result at j smaller than one at i, that means that max_result at t for all t > j when iterating from i is always bigger than j. When get to j, there is no point to check the max_result at t with t < i + k, because it won\\'t be updated anyway, so in this case, we increase the i pointer and keep the j pointer at the exact position when finishing the i iteration.\\n(3) If the max_result at j bigger than one at j - 1 (previous one), we won\\'t terminate the i iteration because j isn\\'t greater than i (1), but we can be sure that when iterating from j, it will override all the values when iterating from j - 1. So in this case, after finishing the i iteration, we update i to the first j that max_result[j] > max_result[j - 1] and keep j at the end of i iteration.\\n\\nUpvote if you find it helpful, thanks\\n\\n```\\n# @param {Integer[]} nums\\n# @param {Integer} k\\n# @return {Integer}\\ndef max_result(nums, k)\\n  size = nums.size\\n  dp = [nums[0]]\\n  i = 0\\n  j = 1\\n\\n  while i < size\\n    base = dp[i]\\n    prev = base\\n    nexti = nil\\n\\n    while j < size && j <= i + k\\n      num = nums[j]\\n      dpj = dp[j]\\n      \\n      res = dpj ? [dpj, base + num].max : (base + num)\\n      dp[j] = res\\n\\n      if res >= base\\n        nexti = j\\n        j += 2\\n        break\\n      elsif !nexti\\n        nexti = j if prev < res\\n        prev = res\\n      end\\n      \\n      j += 1\\n    end\\n    \\n    j -= 1\\n    i = nexti || (i + 1)\\n  end\\n\\n  dp[-1]\\nend",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "This approach uses DP and 2 pointers\\n\\nWe\\'ll have 2 pointers i and j that never decreases, each one runs from 0 to n - 1, ensure the time complexity is O(n) in the worst case.\\n\\n(1) If the max_result at j greater than one at i, that means the max_result at t for all t > j when iterating from i is always less than when iterating from j. There is no point to keep the loop in i because it will be overridden when we got to j anyway. So in this case, we\\'ll update i = j, j = j + 1 and continue the loop.\\n(2) If the max_result at j smaller than one at i, that means that max_result at t for all t > j when iterating from i is always bigger than j. When get to j, there is no point to check the max_result at t with t < i + k, because it won\\'t be updated anyway, so in this case, we increase the i pointer and keep the j pointer at the exact position when finishing the i iteration.\\n(3) If the max_result at j bigger than one at j - 1 (previous one), we won\\'t terminate the i iteration because j isn\\'t greater than i (1), but we can be sure that when iterating from j, it will override all the values when iterating from j - 1. So in this case, after finishing the i iteration, we update i to the first j that max_result[j] > max_result[j - 1] and keep j at the end of i iteration.\\n\\nUpvote if you find it helpful, thanks\\n\\n```\\n# @param {Integer[]} nums\\n# @param {Integer} k\\n# @return {Integer}\\ndef max_result(nums, k)\\n  size = nums.size\\n  dp = [nums[0]]\\n  i = 0\\n  j = 1\\n\\n  while i < size\\n    base = dp[i]\\n    prev = base\\n    nexti = nil\\n\\n    while j < size && j <= i + k\\n      num = nums[j]\\n      dpj = dp[j]\\n      \\n      res = dpj ? [dpj, base + num].max : (base + num)\\n      dp[j] = res\\n\\n      if res >= base\\n        nexti = j\\n        j += 2\\n        break\\n      elsif !nexti\\n        nexti = j if prev < res\\n        prev = res\\n      end\\n      \\n      j += 1\\n    end\\n    \\n    j -= 1\\n    i = nexti || (i + 1)\\n  end\\n\\n  dp[-1]\\nend",
                "codeTag": "Python3"
            },
            {
                "id": 2257153,
                "title": "no-dp-or-deque-simple-and-short-priority-queue-solution-efficient",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int maxResult(vector<int> &nums, int k)\\n    {\\n        vector<int> v(nums.size());\\n        v[0] = nums[0];\\n        priority_queue<pair<int, int>> pq;\\n        pq.push({nums[0], 0});\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            while (!pq.empty() && pq.top().second < i - k)\\n                pq.pop();\\n            v[i] = nums[i] + pq.top().first;\\n            pq.push({v[i], i});\\n        }\\n        return v[nums.size() - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int maxResult(vector<int> &nums, int k)\\n    {\\n        vector<int> v(nums.size());\\n        v[0] = nums[0];\\n        priority_queue<pair<int, int>> pq;\\n        pq.push({nums[0], 0});\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            while (!pq.empty() && pq.top().second < i - k)\\n                pq.pop();\\n            v[i] = nums[i] + pq.top().first;\\n            pq.push({v[i], i});\\n        }\\n        return v[nums.size() - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257081,
                "title": "cpp-beats-100-runtime-and-70-memory-users-deque-dp-solution",
                "content": "![image](https://assets.leetcode.com/users/images/60f78857-74f1-457e-b78b-43462f354174_1657343686.8092892.png)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(n);\\n        deque<int> dq;\\n        dq.push_back(n-1);\\n        dp[n-1] = nums[n-1];\\n        \\n        for(int i = n-2; i>=0;i--)\\n        {\\n            if(dq.front()-i > k) dq.pop_front();\\n            dp[i] = nums[i]+dp[dq.front()];\\n            while(dq.size() && dp[dq.back()]<dp[i]){\\n                 dq.pop_back();\\n            }\\n            dq.push_back(i);\\n            \\n        }\\n        return dp[0];\\n    }\\n};\\n\\nstatic const auto io_sync_off = [](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    return NULL;\\n}();\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(n);\\n        deque<int> dq;\\n        dq.push_back(n-1);\\n        dp[n-1] = nums[n-1];\\n        \\n        for(int i = n-2; i>=0;i--)\\n        {\\n            if(dq.front()-i > k) dq.pop_front();\\n            dp[i] = nums[i]+dp[dq.front()];\\n            while(dq.size() && dp[dq.back()]<dp[i]){\\n                 dq.pop_back();\\n            }\\n            dq.push_back(i);\\n            \\n        }\\n        return dp[0];\\n    }\\n};\\n\\nstatic const auto io_sync_off = [](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    return NULL;\\n}();\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256989,
                "title": "n-log-k-complexity-c-easy-to-understand",
                "content": "1. put the slide window element (sorted) into multiset.\\n2. each time nums[i] + \\\\*set.rbegin() -> sum of the biggest for prev k elements\\n3. once the slide window size is larger than k, remove the slide window front (remove only one need to use find to locate the iterator position) by set.erase(set.find(nums[i - k])); \\n\\n```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        multiset<int> set; \\n        set.insert(nums[0]);\\n        \\n        \\n        for (int i = 1; i < n; i++) {\\n            int ans = nums[i];\\n            \\n            nums[i] = ans + *set.rbegin();\\n        \\n            set.insert(nums[i]);\\n            \\n            if (set.size() > k) {\\n                set.erase(set.find(nums[i - k]));\\n            }\\n        }\\n        \\n        return nums.back();\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxResult(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        multiset<int> set; \\n        set.insert(nums[0]);\\n        \\n        \\n        for (int i = 1; i < n; i++) {\\n            int ans = nums[i];\\n            \\n            nums[i] = ans + *set.rbegin();\\n        \\n            set.insert(nums[i]);\\n            \\n            if (set.size() > k) {\\n                set.erase(set.find(nums[i - k]));\\n            }\\n        }\\n        \\n        return nums.back();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256969,
                "title": "javascript-dp-dequeue",
                "content": "```\\nvar maxResult = function(nums, k) {\\n    const n = nums.length;\\n    const dp = [...nums];\\n    const queue = [];\\n\\n    for(let i = 1; i < n; i += 1) {\\n        const prev = dp[i - 1];\\n        while(queue.length > 0 && queue[queue.length - 1] < prev) {\\n            queue.pop();\\n        }\\n        queue.push(prev);\\n        if(i - k - 1 >= 0 && dp[i - k - 1] === queue[0]) {\\n            queue.shift();\\n        }\\n\\n        dp[i] += queue[0];\\n    }\\n\\n    return dp[n - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar maxResult = function(nums, k) {\\n    const n = nums.length;\\n    const dp = [...nums];\\n    const queue = [];\\n\\n    for(let i = 1; i < n; i += 1) {\\n        const prev = dp[i - 1];\\n        while(queue.length > 0 && queue[queue.length - 1] < prev) {\\n            queue.pop();\\n        }\\n        queue.push(prev);\\n        if(i - k - 1 >= 0 && dp[i - k - 1] === queue[0]) {\\n            queue.shift();\\n        }\\n\\n        dp[i] += queue[0];\\n    }\\n\\n    return dp[n - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2256934,
                "title": "java-dp-deque-easy-to-understand-explanation",
                "content": "We can think in reverse, when we in one position, we could go back k steps to find the maximum sum.\\nSo, the core question become how to find the maximum number in the prev k numebrs.\\nFirstly, I use PriorityQueue to find the max number, however, when k are large, it meets TLE.\\nThen I use deque, each time I add the num, I remove the front nums smaller than this num, which accelerate my solution.\\n```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        dp[0] = nums[0];\\n        \\n        Deque<Integer> deque = new ArrayDeque<>();\\n        deque.addLast(0); // store the index\\n        \\n        for (int i = 1; i < n; i++) {\\n            while (!deque.isEmpty() && deque.peekFirst() < i - k) // store k or less nums\\n                deque.pollFirst();\\n            \\n            dp[i] = nums[i] + dp[deque.peekFirst()];\\n\\n            while (!deque.isEmpty() && dp[deque.peekLast()] <= dp[i]) // make sure the head is the biggest\\n                deque.pollLast();\\n            \\n            deque.addLast(i);\\n        }\\n        \\n        return dp[n - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxResult(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        dp[0] = nums[0];\\n        \\n        Deque<Integer> deque = new ArrayDeque<>();\\n        deque.addLast(0); // store the index\\n        \\n        for (int i = 1; i < n; i++) {\\n            while (!deque.isEmpty() && deque.peekFirst() < i - k) // store k or less nums\\n                deque.pollFirst();\\n            \\n            dp[i] = nums[i] + dp[deque.peekFirst()];\\n\\n            while (!deque.isEmpty() && dp[deque.peekLast()] <= dp[i]) // make sure the head is the biggest\\n                deque.pollLast();\\n            \\n            deque.addLast(i);\\n        }\\n        \\n        return dp[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256931,
                "title": "easy-js-solution",
                "content": "```\\nvar maxResult = function(nums, k) {\\n    // curr => max (of k before) + currVal\\n    const len = nums.length;\\n    const dp = new Array(len).fill(-Infinity);\\n    \\n    const heap = new MaxPriorityQueue({\\n        priority: x => x.val\\n    });\\n    \\n    dp[0] = nums[0];\\n    heap.enqueue({ val: nums[0], idx: 0 });\\n    \\n    for(let i = 1; i < len; i++) {\\n\\t\\t// remove unreached nodes before\\n        while(heap.front().element.idx < i - k) {\\n            heap.dequeue();\\n        }\\n        const top = heap.front().element;\\n        dp[i] = Math.max(dp[i], top.val + nums[i]);\\n        heap.enqueue({ val: dp[i], idx: i });\\n    }\\n    return dp[len - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxResult = function(nums, k) {\\n    // curr => max (of k before) + currVal\\n    const len = nums.length;\\n    const dp = new Array(len).fill(-Infinity);\\n    \\n    const heap = new MaxPriorityQueue({\\n        priority: x => x.val\\n    });\\n    \\n    dp[0] = nums[0];\\n    heap.enqueue({ val: nums[0], idx: 0 });\\n    \\n    for(let i = 1; i < len; i++) {\\n\\t\\t// remove unreached nodes before\\n        while(heap.front().element.idx < i - k) {\\n            heap.dequeue();\\n        }\\n        const top = heap.front().element;\\n        dp[i] = Math.max(dp[i], top.val + nums[i]);\\n        heap.enqueue({ val: dp[i], idx: i });\\n    }\\n    return dp[len - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2256903,
                "title": "java-priorityqueue-max-heap-simple-logic-easy-to-understand",
                "content": "```\\nclass Pair{\\n    int mxScore, idx; //maxScore one can get from \"idx\" (to reach lastIdx)\\n    Pair(int mxScore, int idx) { this.mxScore = mxScore; this.idx = idx; }   \\n}\\nclass Solution {\\n    public int maxResult(int[] nums, int k) \\n    {\\n        int n = nums.length;\\n        PriorityQueue<Pair>pq = new PriorityQueue<Pair>((Pair a, Pair b)->{\\n            return (b.mxScore - a.mxScore);  //MAX HEAP ON THE BASIS OF  SCORE\\n        }); \\n        pq.add(new Pair(nums[n - 1], n - 1)); //maxScore for lastIdx is \"nums[n - 1]\"\\n        //============================================================================\\n        int ans = nums[n - 1];\\n        for (int i = n - 2; i >= 0; i--)\\n        {\\n            //========================================\\n            while(true)\\n            {\\n                int bestJumpIdx = pq.peek().idx;  //best idx to where we can jump from \"ith index\"\\n                if (bestJumpIdx > i + k) pq.poll(); //if that best index is out of our range, remove it\\n                                                    //removing it won\\'t affect any further indexes\\n                else break;\\n            }\\n            //===========================================\\n            int mxNextScore = pq.peek().mxScore;\\n            int mxCurrScore = nums[i] + mxNextScore;\\n            ans = mxCurrScore;  //to record the best score outside the loop\\n            pq.add(new Pair(mxCurrScore, i));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Pair{\\n    int mxScore, idx; //maxScore one can get from \"idx\" (to reach lastIdx)\\n    Pair(int mxScore, int idx) { this.mxScore = mxScore; this.idx = idx; }   \\n}\\nclass Solution {\\n    public int maxResult(int[] nums, int k) \\n    {\\n        int n = nums.length;\\n        PriorityQueue<Pair>pq = new PriorityQueue<Pair>((Pair a, Pair b)->{\\n            return (b.mxScore - a.mxScore);  //MAX HEAP ON THE BASIS OF  SCORE\\n        }); \\n        pq.add(new Pair(nums[n - 1], n - 1)); //maxScore for lastIdx is \"nums[n - 1]\"\\n        //============================================================================\\n        int ans = nums[n - 1];\\n        for (int i = n - 2; i >= 0; i--)\\n        {\\n            //========================================\\n            while(true)\\n            {\\n                int bestJumpIdx = pq.peek().idx;  //best idx to where we can jump from \"ith index\"\\n                if (bestJumpIdx > i + k) pq.poll(); //if that best index is out of our range, remove it\\n                                                    //removing it won\\'t affect any further indexes\\n                else break;\\n            }\\n            //===========================================\\n            int mxNextScore = pq.peek().mxScore;\\n            int mxCurrScore = nums[i] + mxNextScore;\\n            ans = mxCurrScore;  //to record the best score outside the loop\\n            pq.add(new Pair(mxCurrScore, i));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565304,
                "content": [
                    {
                        "username": "faangboy",
                        "content": "Based on the solutions posted so far, the optimal approach seems the one similar to Sliding Window Maximum. But that question is hard, and for some one like me who has never solved it before, I don\\'t think it was medium for me ;)"
                    },
                    {
                        "username": "lalit10368",
                        "content": "You are right, I spent days trying to solve this problem but couldn't. So, I decided to attempt Sliding Window Maximum  instead. It's also listed in Similar Problems section. That problem looked straightforward compared to this one, although still hard. But the problem statement was pretty clear on using sliding windows. After spending some time I was able to figure out the solution and solved it in my first attempt. No wrong answers, no TLE, not even compilation issue. Most problems I could have solved in my head(both medium & hard levels) may be little bit of paper scribbling but this one(maximum sliding window) literally required a whiteboard and moving those window pointers around.\nMy Solution to the Maximum Window Problem : \nhttps://leetcode.com/problems/sliding-window-maximum/submissions/899998243/\n"
                    },
                    {
                        "username": "h98dubey",
                        "content": "Is it just me or anyone else also thinks that this problem should be under hard catogary, specially if you are looking this problem for the first time ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-vi/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming + Deque\n\n  \n**Approach 2:** Dynamic Programming + Priority Queue\n\n  \n**Approach 3:** Segment Tree\n\n  \n**Approach 4:** Dynamic Programming + Deque (Compressed)\n\n  \n**Approach 5:** Dynamic Programming + Priority Queue (Compressed)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Started from Jump Game I, jumped for 6 days and finally reached Jump Game VI."
                    },
                    {
                        "username": "xingasong",
                        "content": "Just wonder how leetcode decide the difficulty of a question..."
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "they assume u have done its prerequisites"
                    },
                    {
                        "username": "JustinNie",
                        "content": "It has to be hard, since it is hard."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is almost same as Constrained Subsequence Sum,which is hard.This should be hard or the other should be medium."
                    },
                    {
                        "username": "f20201382",
                        "content": "Why does the given code not work?\\n `class Solution {\\npublic:\\n    int n;\\n    int k;\\n    int maxScore(vector<int>& nums, vector<int>& dp, int i){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int score = INT_MIN;\\n        for(int j=1;j<=k;j++){\\n            score = max(score, nums[i]+maxScore(nums,dp,i+j));\\n        }\\n\\n        return dp[i] = score;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        this->k = k;\\n        vector<int> dp(n,-1);\\n        return maxScore(nums,dp,0);\\n    }\\n};.`\\n"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "yeah same doubt did u find the error ?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why the logic of picking the max in the next window , throws error. Like for k=2, if I pick i=2 as maximum then search through range [i + 1, min(n - 1, i + k)] i.e [3,5] and pick the max value in that range. If 5 contains the max value then start the next iteration [5,7] from the index =5. I wrote the code and it failed for this test case\\n\\n[-5582,-5317,6711,-639,1001,1845,1728,-4575,-6066,-7770,128,-3254,7281,3966,6857,5477,8968,-1771,9986,-6267,9010,-764,8413,-8154,1087,-1107,4183,3033,58,659,4625,2825,5031,6811,5657,3229,8597,-5772,8869,5723,2960,4040,7222,4841,-1014,581,-2830,3881,-3800,577,-7396,-611,-6944,8461,3294,6297,9713,-2246,-3441,3831,-5754,6716,6040,-6715,5763,8611,5412,-7630,6216,260,2595,6852,-8956,2101,6722,1579,3820,7827,-3369,7144,1974,7310,-5369,-6755,3010,5789,1563,-3330,5373,-2770,4503,-4065,8177,-3333,-4726,-2131,2763,9012,-4755,2382,3642,-5284,-7174,-9815,6392,9729,-1943,-8749,5343,1036,8508,1484,919,4225,3733,8036,-6346,-2088,475,9378,4271,-5906,9327,9399,-1582,3845,3499,-8912,-4671,-1143,-5081,-1621,-1287,5995,4963,5071,5118,-1966,-6249,663,-2296,-8148,-4668,-6919,334,-6609,2888,-4161,118,-1867,5629,8588,-5325,-7853,-4868,-1487,-6544,-9697,-7038,6422,-5545,3376,-8656,8800,-7698,-2928,2279,-9739,4198,6236,-9087,9010,-9894,2145,7353,-92,3205,5431,5913,1619,-250,4728,-7164,-5619,-4721,-9284,-9645,146,7131,-6501,4261,2016,2880,4944,-8768,-6339,-3574,539,4633,9188,7227,-1549,9271,7110,5706,4968,-1275,5545,-5844,-1985,9560,1560,4630,3169,6076,-9433,7007,9927,-8385,-4557,-114,9543,2884,8978,-6447,3664,-7499,-4643,-5993,-5321,3250,-2945,6216,-1606,5569,7326,-6027,9723,-6997,-543,-8298,-4647,2563,1493,9574,1087,-9433,-7749,-7159,-2682,6626,2787,-2845,-7907,-223,-8142,-5403,-3460,-2534,5289,999,9404,-1958,641,4669,-2892,-2921,-7001,-1403,-2353,-7976,-5885,4958,-8117,8785,-654,5918,5533,8704,5827,-7478,-3696,2640,1612,-500,5694,-1973,5308,5272,3358,9190,4648,-7836,658,-3407,6733,1061,-2010,-2707,-1920,1272,3944,-6537,-6090,-7429,-640,836,1904,-4031,814,-1886,8040,-8312,-9407,-1395,-9944,-2074,-6814,2672,1360,8990,5465,-2131,3838,799,-3472,1086,-583,6302,3032,9138,-7778,4538,-5337,2087,2870,-3005,3401,122,-819,-8074,9630,-698,5326,2650,-9355,6487,3801,-3209,8293,662,-8318,-7863,-3814,-2557,-5685,-7952,6224,-7010,2935,5557,-1287,9528,-9218,-5108,-2085,17,4870,-8686,-8854,-9657,8848,-1883,-4535,83,9711,4593,-3440,-6938,3407,-6894,-6213,-883,4552,-731,1485,-7740,-3300,3897,-7629,-4076,7589,3142,-1010,2466,-592,-391,3961,-7049,7654,5758,6983,6048,-4369,-5878,3756,2940,9149,8625,8937,5706,6658,9213,-5226,284,-4524,-1577,-5296,6423,9977,-1805,5462,7587,476,-6424,976,-3925,8819,1821,3603,-842,-9618,-7130,-6253,2562,-7596,3522,6282,-3801,-3896,6924,441,5944,8535,1253,-6154,6872,-9548,-5358,1604,9593,-9256,-701,1023,-1446,-1307,-6809,9542,3673,1813,8717,-6847,-5289,5222,-7266,4231,218,-9633,-4696,5494,9681,1173,-4606,2174,-1155,-8595,-3640,-6550,-7003,4244,-2543,5241,2831,2690,8950,-6609,-9724,7562,-4096,8878,9962,7179,-1170,7826,-146,-2759,-5249,253,6206,3205,-7708,9448,4622,9260,-2853,2486,122,-8880,-769,-8922,648,7358,-6503,-6382,-4260,3988,-5107,-6363,2415,8563,-9070,-5026,2078,-2558,-2027,-7489,-4978,5024,4155,-9737,-221,9930,-9472,1052,-268,6221,2726,-1310,-8708,3482,-5488,-6506,5389,-7048,553,-886,2752,85,-3938,5940,-5112,5855,-7295,3735,2657,3269,6231,4771,3229,-2009,-5748,7256,746,-4301,752,-241,-6151,-2390,9911,825,-7679,-4960,-7224,-2739,-566,-5770,6774,6243,3166,-783,-4303,-9016,5555,-1866,-536,8872,-3927,4269,-3807,1933,9972,981,9256,6857,-208,3645,-3725,5961,1105,6320,-4702,-8419,-4904,-4935,8378,-2994,5831,5296,4730,-9170,-4229,-3911,-160,8757,-5301,-3775,1121,9434,-9880,2689,2340,-7879,3667,-5219,-6116,-1670,7595,6900,3990,4444,6385,-2924,8968,-2673,-6182,7503,5209,6030,802,-3464,1922,-8187,1617,4769,-4866,-3518,5830,3862,-7512,5236,-5164,6324,-5107,6864,-7364,-1375,5762,-275,4975,-7448,5719,-3162,-1546,-2776,-9411,-1845,-4913,-3474,2550,5643,-5527,2946,7158,1938,5125,-8015,2475,-1461,-4900,-5151,-4031,9362,8571,9815,-8438,-6519,1980,-8031,9615,7079,-3573,-883,4217,1079,5918,1767,8670,-5651,-6625,1057,7897,-7104,-4186,851,-6333,-4108,-3250,7899,9628,-6904,-3939,4587,1227,3813,-7449,-7692,-8098,-9813,8862,-2888,-1048,-3564,3074,1437,-2291,3974,3164,4921,-8958,9007,-3938,2042,7454,-910,-998,-4450,-1103,-237,8182,-1391,-4255,-3482,-2918,4053,2280,-7403,4319,-9457,7157,-6315,-7533,6309,2211,-9145,443,4255,-8847,-5557,-9089,1752,-5784,-2399,-8296,-8400,8170,4628,-4583,937,-7067,-3503,-549,-1194,1576,5004,-6963,-8837,5567,870,3954,5489,-8949,-7673,8542,-9040,-7689,-4171,-889,5552,-6836,-4393,513,3177,6664,-5646,2492,9421,-342,2570,8816,2869,-6820,-3389,-1903,-3332,138,6618,293,-9130,3503,-2327,-9728,7632,5881,540,9678,-7629,8804,-2816,7205,7473,-5518,7311,3457,9066,-1224,2097,7857,6612,186,6759,-4516,-3491,-8268,-8928,-7412,7162,6274,5463,2157,-4131,-7061,-8476,-5584,7300,-4348,-5940,-8592,-302,-5817,3151,-4124,1694,-5114,-3252,-2319,-2157,-293,7724,-5673,6105,9535,4333,6353,1290,8710,-5035,8995,-5865,9746,4708,-6387,-8937,3096,-9716,-7124,2531,-660,-4619,-8035,3747,-7821,8793,-727,8242,4957,-7175,4064,-9911,4995,9725,1634,-4275,788,-4920,3831,-3525,-4467,2909,-1200,5377,-4905,-3077,-1763,4443,-3518,3134,-5595,5409,5943,6757,3485,2883,-9261,-7221,654,2001,-926,7840,-5568,2715,-7053,-2082,-2005,7607,-9511,7545,7564,2380,-7257,1449,-3918,-3240,-1928,-6555,-4784,1550,2745,-5316]\\nk=56"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if you use a heap, this question is medium. if you use a monotonic queue, this is easily a hard ... whenever lc suggests heap, it seems like monotonic queue is usually always faster "
                    }
                ]
            },
            {
                "id": 1570471,
                "content": [
                    {
                        "username": "faangboy",
                        "content": "Based on the solutions posted so far, the optimal approach seems the one similar to Sliding Window Maximum. But that question is hard, and for some one like me who has never solved it before, I don\\'t think it was medium for me ;)"
                    },
                    {
                        "username": "lalit10368",
                        "content": "You are right, I spent days trying to solve this problem but couldn't. So, I decided to attempt Sliding Window Maximum  instead. It's also listed in Similar Problems section. That problem looked straightforward compared to this one, although still hard. But the problem statement was pretty clear on using sliding windows. After spending some time I was able to figure out the solution and solved it in my first attempt. No wrong answers, no TLE, not even compilation issue. Most problems I could have solved in my head(both medium & hard levels) may be little bit of paper scribbling but this one(maximum sliding window) literally required a whiteboard and moving those window pointers around.\nMy Solution to the Maximum Window Problem : \nhttps://leetcode.com/problems/sliding-window-maximum/submissions/899998243/\n"
                    },
                    {
                        "username": "h98dubey",
                        "content": "Is it just me or anyone else also thinks that this problem should be under hard catogary, specially if you are looking this problem for the first time ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-vi/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming + Deque\n\n  \n**Approach 2:** Dynamic Programming + Priority Queue\n\n  \n**Approach 3:** Segment Tree\n\n  \n**Approach 4:** Dynamic Programming + Deque (Compressed)\n\n  \n**Approach 5:** Dynamic Programming + Priority Queue (Compressed)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Started from Jump Game I, jumped for 6 days and finally reached Jump Game VI."
                    },
                    {
                        "username": "xingasong",
                        "content": "Just wonder how leetcode decide the difficulty of a question..."
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "they assume u have done its prerequisites"
                    },
                    {
                        "username": "JustinNie",
                        "content": "It has to be hard, since it is hard."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is almost same as Constrained Subsequence Sum,which is hard.This should be hard or the other should be medium."
                    },
                    {
                        "username": "f20201382",
                        "content": "Why does the given code not work?\\n `class Solution {\\npublic:\\n    int n;\\n    int k;\\n    int maxScore(vector<int>& nums, vector<int>& dp, int i){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int score = INT_MIN;\\n        for(int j=1;j<=k;j++){\\n            score = max(score, nums[i]+maxScore(nums,dp,i+j));\\n        }\\n\\n        return dp[i] = score;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        this->k = k;\\n        vector<int> dp(n,-1);\\n        return maxScore(nums,dp,0);\\n    }\\n};.`\\n"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "yeah same doubt did u find the error ?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why the logic of picking the max in the next window , throws error. Like for k=2, if I pick i=2 as maximum then search through range [i + 1, min(n - 1, i + k)] i.e [3,5] and pick the max value in that range. If 5 contains the max value then start the next iteration [5,7] from the index =5. I wrote the code and it failed for this test case\\n\\n[-5582,-5317,6711,-639,1001,1845,1728,-4575,-6066,-7770,128,-3254,7281,3966,6857,5477,8968,-1771,9986,-6267,9010,-764,8413,-8154,1087,-1107,4183,3033,58,659,4625,2825,5031,6811,5657,3229,8597,-5772,8869,5723,2960,4040,7222,4841,-1014,581,-2830,3881,-3800,577,-7396,-611,-6944,8461,3294,6297,9713,-2246,-3441,3831,-5754,6716,6040,-6715,5763,8611,5412,-7630,6216,260,2595,6852,-8956,2101,6722,1579,3820,7827,-3369,7144,1974,7310,-5369,-6755,3010,5789,1563,-3330,5373,-2770,4503,-4065,8177,-3333,-4726,-2131,2763,9012,-4755,2382,3642,-5284,-7174,-9815,6392,9729,-1943,-8749,5343,1036,8508,1484,919,4225,3733,8036,-6346,-2088,475,9378,4271,-5906,9327,9399,-1582,3845,3499,-8912,-4671,-1143,-5081,-1621,-1287,5995,4963,5071,5118,-1966,-6249,663,-2296,-8148,-4668,-6919,334,-6609,2888,-4161,118,-1867,5629,8588,-5325,-7853,-4868,-1487,-6544,-9697,-7038,6422,-5545,3376,-8656,8800,-7698,-2928,2279,-9739,4198,6236,-9087,9010,-9894,2145,7353,-92,3205,5431,5913,1619,-250,4728,-7164,-5619,-4721,-9284,-9645,146,7131,-6501,4261,2016,2880,4944,-8768,-6339,-3574,539,4633,9188,7227,-1549,9271,7110,5706,4968,-1275,5545,-5844,-1985,9560,1560,4630,3169,6076,-9433,7007,9927,-8385,-4557,-114,9543,2884,8978,-6447,3664,-7499,-4643,-5993,-5321,3250,-2945,6216,-1606,5569,7326,-6027,9723,-6997,-543,-8298,-4647,2563,1493,9574,1087,-9433,-7749,-7159,-2682,6626,2787,-2845,-7907,-223,-8142,-5403,-3460,-2534,5289,999,9404,-1958,641,4669,-2892,-2921,-7001,-1403,-2353,-7976,-5885,4958,-8117,8785,-654,5918,5533,8704,5827,-7478,-3696,2640,1612,-500,5694,-1973,5308,5272,3358,9190,4648,-7836,658,-3407,6733,1061,-2010,-2707,-1920,1272,3944,-6537,-6090,-7429,-640,836,1904,-4031,814,-1886,8040,-8312,-9407,-1395,-9944,-2074,-6814,2672,1360,8990,5465,-2131,3838,799,-3472,1086,-583,6302,3032,9138,-7778,4538,-5337,2087,2870,-3005,3401,122,-819,-8074,9630,-698,5326,2650,-9355,6487,3801,-3209,8293,662,-8318,-7863,-3814,-2557,-5685,-7952,6224,-7010,2935,5557,-1287,9528,-9218,-5108,-2085,17,4870,-8686,-8854,-9657,8848,-1883,-4535,83,9711,4593,-3440,-6938,3407,-6894,-6213,-883,4552,-731,1485,-7740,-3300,3897,-7629,-4076,7589,3142,-1010,2466,-592,-391,3961,-7049,7654,5758,6983,6048,-4369,-5878,3756,2940,9149,8625,8937,5706,6658,9213,-5226,284,-4524,-1577,-5296,6423,9977,-1805,5462,7587,476,-6424,976,-3925,8819,1821,3603,-842,-9618,-7130,-6253,2562,-7596,3522,6282,-3801,-3896,6924,441,5944,8535,1253,-6154,6872,-9548,-5358,1604,9593,-9256,-701,1023,-1446,-1307,-6809,9542,3673,1813,8717,-6847,-5289,5222,-7266,4231,218,-9633,-4696,5494,9681,1173,-4606,2174,-1155,-8595,-3640,-6550,-7003,4244,-2543,5241,2831,2690,8950,-6609,-9724,7562,-4096,8878,9962,7179,-1170,7826,-146,-2759,-5249,253,6206,3205,-7708,9448,4622,9260,-2853,2486,122,-8880,-769,-8922,648,7358,-6503,-6382,-4260,3988,-5107,-6363,2415,8563,-9070,-5026,2078,-2558,-2027,-7489,-4978,5024,4155,-9737,-221,9930,-9472,1052,-268,6221,2726,-1310,-8708,3482,-5488,-6506,5389,-7048,553,-886,2752,85,-3938,5940,-5112,5855,-7295,3735,2657,3269,6231,4771,3229,-2009,-5748,7256,746,-4301,752,-241,-6151,-2390,9911,825,-7679,-4960,-7224,-2739,-566,-5770,6774,6243,3166,-783,-4303,-9016,5555,-1866,-536,8872,-3927,4269,-3807,1933,9972,981,9256,6857,-208,3645,-3725,5961,1105,6320,-4702,-8419,-4904,-4935,8378,-2994,5831,5296,4730,-9170,-4229,-3911,-160,8757,-5301,-3775,1121,9434,-9880,2689,2340,-7879,3667,-5219,-6116,-1670,7595,6900,3990,4444,6385,-2924,8968,-2673,-6182,7503,5209,6030,802,-3464,1922,-8187,1617,4769,-4866,-3518,5830,3862,-7512,5236,-5164,6324,-5107,6864,-7364,-1375,5762,-275,4975,-7448,5719,-3162,-1546,-2776,-9411,-1845,-4913,-3474,2550,5643,-5527,2946,7158,1938,5125,-8015,2475,-1461,-4900,-5151,-4031,9362,8571,9815,-8438,-6519,1980,-8031,9615,7079,-3573,-883,4217,1079,5918,1767,8670,-5651,-6625,1057,7897,-7104,-4186,851,-6333,-4108,-3250,7899,9628,-6904,-3939,4587,1227,3813,-7449,-7692,-8098,-9813,8862,-2888,-1048,-3564,3074,1437,-2291,3974,3164,4921,-8958,9007,-3938,2042,7454,-910,-998,-4450,-1103,-237,8182,-1391,-4255,-3482,-2918,4053,2280,-7403,4319,-9457,7157,-6315,-7533,6309,2211,-9145,443,4255,-8847,-5557,-9089,1752,-5784,-2399,-8296,-8400,8170,4628,-4583,937,-7067,-3503,-549,-1194,1576,5004,-6963,-8837,5567,870,3954,5489,-8949,-7673,8542,-9040,-7689,-4171,-889,5552,-6836,-4393,513,3177,6664,-5646,2492,9421,-342,2570,8816,2869,-6820,-3389,-1903,-3332,138,6618,293,-9130,3503,-2327,-9728,7632,5881,540,9678,-7629,8804,-2816,7205,7473,-5518,7311,3457,9066,-1224,2097,7857,6612,186,6759,-4516,-3491,-8268,-8928,-7412,7162,6274,5463,2157,-4131,-7061,-8476,-5584,7300,-4348,-5940,-8592,-302,-5817,3151,-4124,1694,-5114,-3252,-2319,-2157,-293,7724,-5673,6105,9535,4333,6353,1290,8710,-5035,8995,-5865,9746,4708,-6387,-8937,3096,-9716,-7124,2531,-660,-4619,-8035,3747,-7821,8793,-727,8242,4957,-7175,4064,-9911,4995,9725,1634,-4275,788,-4920,3831,-3525,-4467,2909,-1200,5377,-4905,-3077,-1763,4443,-3518,3134,-5595,5409,5943,6757,3485,2883,-9261,-7221,654,2001,-926,7840,-5568,2715,-7053,-2082,-2005,7607,-9511,7545,7564,2380,-7257,1449,-3918,-3240,-1928,-6555,-4784,1550,2745,-5316]\\nk=56"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if you use a heap, this question is medium. if you use a monotonic queue, this is easily a hard ... whenever lc suggests heap, it seems like monotonic queue is usually always faster "
                    }
                ]
            },
            {
                "id": 1567780,
                "content": [
                    {
                        "username": "faangboy",
                        "content": "Based on the solutions posted so far, the optimal approach seems the one similar to Sliding Window Maximum. But that question is hard, and for some one like me who has never solved it before, I don\\'t think it was medium for me ;)"
                    },
                    {
                        "username": "lalit10368",
                        "content": "You are right, I spent days trying to solve this problem but couldn't. So, I decided to attempt Sliding Window Maximum  instead. It's also listed in Similar Problems section. That problem looked straightforward compared to this one, although still hard. But the problem statement was pretty clear on using sliding windows. After spending some time I was able to figure out the solution and solved it in my first attempt. No wrong answers, no TLE, not even compilation issue. Most problems I could have solved in my head(both medium & hard levels) may be little bit of paper scribbling but this one(maximum sliding window) literally required a whiteboard and moving those window pointers around.\nMy Solution to the Maximum Window Problem : \nhttps://leetcode.com/problems/sliding-window-maximum/submissions/899998243/\n"
                    },
                    {
                        "username": "h98dubey",
                        "content": "Is it just me or anyone else also thinks that this problem should be under hard catogary, specially if you are looking this problem for the first time ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-vi/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming + Deque\n\n  \n**Approach 2:** Dynamic Programming + Priority Queue\n\n  \n**Approach 3:** Segment Tree\n\n  \n**Approach 4:** Dynamic Programming + Deque (Compressed)\n\n  \n**Approach 5:** Dynamic Programming + Priority Queue (Compressed)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Started from Jump Game I, jumped for 6 days and finally reached Jump Game VI."
                    },
                    {
                        "username": "xingasong",
                        "content": "Just wonder how leetcode decide the difficulty of a question..."
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "they assume u have done its prerequisites"
                    },
                    {
                        "username": "JustinNie",
                        "content": "It has to be hard, since it is hard."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is almost same as Constrained Subsequence Sum,which is hard.This should be hard or the other should be medium."
                    },
                    {
                        "username": "f20201382",
                        "content": "Why does the given code not work?\\n `class Solution {\\npublic:\\n    int n;\\n    int k;\\n    int maxScore(vector<int>& nums, vector<int>& dp, int i){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int score = INT_MIN;\\n        for(int j=1;j<=k;j++){\\n            score = max(score, nums[i]+maxScore(nums,dp,i+j));\\n        }\\n\\n        return dp[i] = score;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        this->k = k;\\n        vector<int> dp(n,-1);\\n        return maxScore(nums,dp,0);\\n    }\\n};.`\\n"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "yeah same doubt did u find the error ?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why the logic of picking the max in the next window , throws error. Like for k=2, if I pick i=2 as maximum then search through range [i + 1, min(n - 1, i + k)] i.e [3,5] and pick the max value in that range. If 5 contains the max value then start the next iteration [5,7] from the index =5. I wrote the code and it failed for this test case\\n\\n[-5582,-5317,6711,-639,1001,1845,1728,-4575,-6066,-7770,128,-3254,7281,3966,6857,5477,8968,-1771,9986,-6267,9010,-764,8413,-8154,1087,-1107,4183,3033,58,659,4625,2825,5031,6811,5657,3229,8597,-5772,8869,5723,2960,4040,7222,4841,-1014,581,-2830,3881,-3800,577,-7396,-611,-6944,8461,3294,6297,9713,-2246,-3441,3831,-5754,6716,6040,-6715,5763,8611,5412,-7630,6216,260,2595,6852,-8956,2101,6722,1579,3820,7827,-3369,7144,1974,7310,-5369,-6755,3010,5789,1563,-3330,5373,-2770,4503,-4065,8177,-3333,-4726,-2131,2763,9012,-4755,2382,3642,-5284,-7174,-9815,6392,9729,-1943,-8749,5343,1036,8508,1484,919,4225,3733,8036,-6346,-2088,475,9378,4271,-5906,9327,9399,-1582,3845,3499,-8912,-4671,-1143,-5081,-1621,-1287,5995,4963,5071,5118,-1966,-6249,663,-2296,-8148,-4668,-6919,334,-6609,2888,-4161,118,-1867,5629,8588,-5325,-7853,-4868,-1487,-6544,-9697,-7038,6422,-5545,3376,-8656,8800,-7698,-2928,2279,-9739,4198,6236,-9087,9010,-9894,2145,7353,-92,3205,5431,5913,1619,-250,4728,-7164,-5619,-4721,-9284,-9645,146,7131,-6501,4261,2016,2880,4944,-8768,-6339,-3574,539,4633,9188,7227,-1549,9271,7110,5706,4968,-1275,5545,-5844,-1985,9560,1560,4630,3169,6076,-9433,7007,9927,-8385,-4557,-114,9543,2884,8978,-6447,3664,-7499,-4643,-5993,-5321,3250,-2945,6216,-1606,5569,7326,-6027,9723,-6997,-543,-8298,-4647,2563,1493,9574,1087,-9433,-7749,-7159,-2682,6626,2787,-2845,-7907,-223,-8142,-5403,-3460,-2534,5289,999,9404,-1958,641,4669,-2892,-2921,-7001,-1403,-2353,-7976,-5885,4958,-8117,8785,-654,5918,5533,8704,5827,-7478,-3696,2640,1612,-500,5694,-1973,5308,5272,3358,9190,4648,-7836,658,-3407,6733,1061,-2010,-2707,-1920,1272,3944,-6537,-6090,-7429,-640,836,1904,-4031,814,-1886,8040,-8312,-9407,-1395,-9944,-2074,-6814,2672,1360,8990,5465,-2131,3838,799,-3472,1086,-583,6302,3032,9138,-7778,4538,-5337,2087,2870,-3005,3401,122,-819,-8074,9630,-698,5326,2650,-9355,6487,3801,-3209,8293,662,-8318,-7863,-3814,-2557,-5685,-7952,6224,-7010,2935,5557,-1287,9528,-9218,-5108,-2085,17,4870,-8686,-8854,-9657,8848,-1883,-4535,83,9711,4593,-3440,-6938,3407,-6894,-6213,-883,4552,-731,1485,-7740,-3300,3897,-7629,-4076,7589,3142,-1010,2466,-592,-391,3961,-7049,7654,5758,6983,6048,-4369,-5878,3756,2940,9149,8625,8937,5706,6658,9213,-5226,284,-4524,-1577,-5296,6423,9977,-1805,5462,7587,476,-6424,976,-3925,8819,1821,3603,-842,-9618,-7130,-6253,2562,-7596,3522,6282,-3801,-3896,6924,441,5944,8535,1253,-6154,6872,-9548,-5358,1604,9593,-9256,-701,1023,-1446,-1307,-6809,9542,3673,1813,8717,-6847,-5289,5222,-7266,4231,218,-9633,-4696,5494,9681,1173,-4606,2174,-1155,-8595,-3640,-6550,-7003,4244,-2543,5241,2831,2690,8950,-6609,-9724,7562,-4096,8878,9962,7179,-1170,7826,-146,-2759,-5249,253,6206,3205,-7708,9448,4622,9260,-2853,2486,122,-8880,-769,-8922,648,7358,-6503,-6382,-4260,3988,-5107,-6363,2415,8563,-9070,-5026,2078,-2558,-2027,-7489,-4978,5024,4155,-9737,-221,9930,-9472,1052,-268,6221,2726,-1310,-8708,3482,-5488,-6506,5389,-7048,553,-886,2752,85,-3938,5940,-5112,5855,-7295,3735,2657,3269,6231,4771,3229,-2009,-5748,7256,746,-4301,752,-241,-6151,-2390,9911,825,-7679,-4960,-7224,-2739,-566,-5770,6774,6243,3166,-783,-4303,-9016,5555,-1866,-536,8872,-3927,4269,-3807,1933,9972,981,9256,6857,-208,3645,-3725,5961,1105,6320,-4702,-8419,-4904,-4935,8378,-2994,5831,5296,4730,-9170,-4229,-3911,-160,8757,-5301,-3775,1121,9434,-9880,2689,2340,-7879,3667,-5219,-6116,-1670,7595,6900,3990,4444,6385,-2924,8968,-2673,-6182,7503,5209,6030,802,-3464,1922,-8187,1617,4769,-4866,-3518,5830,3862,-7512,5236,-5164,6324,-5107,6864,-7364,-1375,5762,-275,4975,-7448,5719,-3162,-1546,-2776,-9411,-1845,-4913,-3474,2550,5643,-5527,2946,7158,1938,5125,-8015,2475,-1461,-4900,-5151,-4031,9362,8571,9815,-8438,-6519,1980,-8031,9615,7079,-3573,-883,4217,1079,5918,1767,8670,-5651,-6625,1057,7897,-7104,-4186,851,-6333,-4108,-3250,7899,9628,-6904,-3939,4587,1227,3813,-7449,-7692,-8098,-9813,8862,-2888,-1048,-3564,3074,1437,-2291,3974,3164,4921,-8958,9007,-3938,2042,7454,-910,-998,-4450,-1103,-237,8182,-1391,-4255,-3482,-2918,4053,2280,-7403,4319,-9457,7157,-6315,-7533,6309,2211,-9145,443,4255,-8847,-5557,-9089,1752,-5784,-2399,-8296,-8400,8170,4628,-4583,937,-7067,-3503,-549,-1194,1576,5004,-6963,-8837,5567,870,3954,5489,-8949,-7673,8542,-9040,-7689,-4171,-889,5552,-6836,-4393,513,3177,6664,-5646,2492,9421,-342,2570,8816,2869,-6820,-3389,-1903,-3332,138,6618,293,-9130,3503,-2327,-9728,7632,5881,540,9678,-7629,8804,-2816,7205,7473,-5518,7311,3457,9066,-1224,2097,7857,6612,186,6759,-4516,-3491,-8268,-8928,-7412,7162,6274,5463,2157,-4131,-7061,-8476,-5584,7300,-4348,-5940,-8592,-302,-5817,3151,-4124,1694,-5114,-3252,-2319,-2157,-293,7724,-5673,6105,9535,4333,6353,1290,8710,-5035,8995,-5865,9746,4708,-6387,-8937,3096,-9716,-7124,2531,-660,-4619,-8035,3747,-7821,8793,-727,8242,4957,-7175,4064,-9911,4995,9725,1634,-4275,788,-4920,3831,-3525,-4467,2909,-1200,5377,-4905,-3077,-1763,4443,-3518,3134,-5595,5409,5943,6757,3485,2883,-9261,-7221,654,2001,-926,7840,-5568,2715,-7053,-2082,-2005,7607,-9511,7545,7564,2380,-7257,1449,-3918,-3240,-1928,-6555,-4784,1550,2745,-5316]\\nk=56"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if you use a heap, this question is medium. if you use a monotonic queue, this is easily a hard ... whenever lc suggests heap, it seems like monotonic queue is usually always faster "
                    }
                ]
            },
            {
                "id": 1978808,
                "content": [
                    {
                        "username": "faangboy",
                        "content": "Based on the solutions posted so far, the optimal approach seems the one similar to Sliding Window Maximum. But that question is hard, and for some one like me who has never solved it before, I don\\'t think it was medium for me ;)"
                    },
                    {
                        "username": "lalit10368",
                        "content": "You are right, I spent days trying to solve this problem but couldn't. So, I decided to attempt Sliding Window Maximum  instead. It's also listed in Similar Problems section. That problem looked straightforward compared to this one, although still hard. But the problem statement was pretty clear on using sliding windows. After spending some time I was able to figure out the solution and solved it in my first attempt. No wrong answers, no TLE, not even compilation issue. Most problems I could have solved in my head(both medium & hard levels) may be little bit of paper scribbling but this one(maximum sliding window) literally required a whiteboard and moving those window pointers around.\nMy Solution to the Maximum Window Problem : \nhttps://leetcode.com/problems/sliding-window-maximum/submissions/899998243/\n"
                    },
                    {
                        "username": "h98dubey",
                        "content": "Is it just me or anyone else also thinks that this problem should be under hard catogary, specially if you are looking this problem for the first time ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-vi/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming + Deque\n\n  \n**Approach 2:** Dynamic Programming + Priority Queue\n\n  \n**Approach 3:** Segment Tree\n\n  \n**Approach 4:** Dynamic Programming + Deque (Compressed)\n\n  \n**Approach 5:** Dynamic Programming + Priority Queue (Compressed)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Started from Jump Game I, jumped for 6 days and finally reached Jump Game VI."
                    },
                    {
                        "username": "xingasong",
                        "content": "Just wonder how leetcode decide the difficulty of a question..."
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "they assume u have done its prerequisites"
                    },
                    {
                        "username": "JustinNie",
                        "content": "It has to be hard, since it is hard."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is almost same as Constrained Subsequence Sum,which is hard.This should be hard or the other should be medium."
                    },
                    {
                        "username": "f20201382",
                        "content": "Why does the given code not work?\\n `class Solution {\\npublic:\\n    int n;\\n    int k;\\n    int maxScore(vector<int>& nums, vector<int>& dp, int i){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int score = INT_MIN;\\n        for(int j=1;j<=k;j++){\\n            score = max(score, nums[i]+maxScore(nums,dp,i+j));\\n        }\\n\\n        return dp[i] = score;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        this->k = k;\\n        vector<int> dp(n,-1);\\n        return maxScore(nums,dp,0);\\n    }\\n};.`\\n"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "yeah same doubt did u find the error ?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why the logic of picking the max in the next window , throws error. Like for k=2, if I pick i=2 as maximum then search through range [i + 1, min(n - 1, i + k)] i.e [3,5] and pick the max value in that range. If 5 contains the max value then start the next iteration [5,7] from the index =5. I wrote the code and it failed for this test case\\n\\n[-5582,-5317,6711,-639,1001,1845,1728,-4575,-6066,-7770,128,-3254,7281,3966,6857,5477,8968,-1771,9986,-6267,9010,-764,8413,-8154,1087,-1107,4183,3033,58,659,4625,2825,5031,6811,5657,3229,8597,-5772,8869,5723,2960,4040,7222,4841,-1014,581,-2830,3881,-3800,577,-7396,-611,-6944,8461,3294,6297,9713,-2246,-3441,3831,-5754,6716,6040,-6715,5763,8611,5412,-7630,6216,260,2595,6852,-8956,2101,6722,1579,3820,7827,-3369,7144,1974,7310,-5369,-6755,3010,5789,1563,-3330,5373,-2770,4503,-4065,8177,-3333,-4726,-2131,2763,9012,-4755,2382,3642,-5284,-7174,-9815,6392,9729,-1943,-8749,5343,1036,8508,1484,919,4225,3733,8036,-6346,-2088,475,9378,4271,-5906,9327,9399,-1582,3845,3499,-8912,-4671,-1143,-5081,-1621,-1287,5995,4963,5071,5118,-1966,-6249,663,-2296,-8148,-4668,-6919,334,-6609,2888,-4161,118,-1867,5629,8588,-5325,-7853,-4868,-1487,-6544,-9697,-7038,6422,-5545,3376,-8656,8800,-7698,-2928,2279,-9739,4198,6236,-9087,9010,-9894,2145,7353,-92,3205,5431,5913,1619,-250,4728,-7164,-5619,-4721,-9284,-9645,146,7131,-6501,4261,2016,2880,4944,-8768,-6339,-3574,539,4633,9188,7227,-1549,9271,7110,5706,4968,-1275,5545,-5844,-1985,9560,1560,4630,3169,6076,-9433,7007,9927,-8385,-4557,-114,9543,2884,8978,-6447,3664,-7499,-4643,-5993,-5321,3250,-2945,6216,-1606,5569,7326,-6027,9723,-6997,-543,-8298,-4647,2563,1493,9574,1087,-9433,-7749,-7159,-2682,6626,2787,-2845,-7907,-223,-8142,-5403,-3460,-2534,5289,999,9404,-1958,641,4669,-2892,-2921,-7001,-1403,-2353,-7976,-5885,4958,-8117,8785,-654,5918,5533,8704,5827,-7478,-3696,2640,1612,-500,5694,-1973,5308,5272,3358,9190,4648,-7836,658,-3407,6733,1061,-2010,-2707,-1920,1272,3944,-6537,-6090,-7429,-640,836,1904,-4031,814,-1886,8040,-8312,-9407,-1395,-9944,-2074,-6814,2672,1360,8990,5465,-2131,3838,799,-3472,1086,-583,6302,3032,9138,-7778,4538,-5337,2087,2870,-3005,3401,122,-819,-8074,9630,-698,5326,2650,-9355,6487,3801,-3209,8293,662,-8318,-7863,-3814,-2557,-5685,-7952,6224,-7010,2935,5557,-1287,9528,-9218,-5108,-2085,17,4870,-8686,-8854,-9657,8848,-1883,-4535,83,9711,4593,-3440,-6938,3407,-6894,-6213,-883,4552,-731,1485,-7740,-3300,3897,-7629,-4076,7589,3142,-1010,2466,-592,-391,3961,-7049,7654,5758,6983,6048,-4369,-5878,3756,2940,9149,8625,8937,5706,6658,9213,-5226,284,-4524,-1577,-5296,6423,9977,-1805,5462,7587,476,-6424,976,-3925,8819,1821,3603,-842,-9618,-7130,-6253,2562,-7596,3522,6282,-3801,-3896,6924,441,5944,8535,1253,-6154,6872,-9548,-5358,1604,9593,-9256,-701,1023,-1446,-1307,-6809,9542,3673,1813,8717,-6847,-5289,5222,-7266,4231,218,-9633,-4696,5494,9681,1173,-4606,2174,-1155,-8595,-3640,-6550,-7003,4244,-2543,5241,2831,2690,8950,-6609,-9724,7562,-4096,8878,9962,7179,-1170,7826,-146,-2759,-5249,253,6206,3205,-7708,9448,4622,9260,-2853,2486,122,-8880,-769,-8922,648,7358,-6503,-6382,-4260,3988,-5107,-6363,2415,8563,-9070,-5026,2078,-2558,-2027,-7489,-4978,5024,4155,-9737,-221,9930,-9472,1052,-268,6221,2726,-1310,-8708,3482,-5488,-6506,5389,-7048,553,-886,2752,85,-3938,5940,-5112,5855,-7295,3735,2657,3269,6231,4771,3229,-2009,-5748,7256,746,-4301,752,-241,-6151,-2390,9911,825,-7679,-4960,-7224,-2739,-566,-5770,6774,6243,3166,-783,-4303,-9016,5555,-1866,-536,8872,-3927,4269,-3807,1933,9972,981,9256,6857,-208,3645,-3725,5961,1105,6320,-4702,-8419,-4904,-4935,8378,-2994,5831,5296,4730,-9170,-4229,-3911,-160,8757,-5301,-3775,1121,9434,-9880,2689,2340,-7879,3667,-5219,-6116,-1670,7595,6900,3990,4444,6385,-2924,8968,-2673,-6182,7503,5209,6030,802,-3464,1922,-8187,1617,4769,-4866,-3518,5830,3862,-7512,5236,-5164,6324,-5107,6864,-7364,-1375,5762,-275,4975,-7448,5719,-3162,-1546,-2776,-9411,-1845,-4913,-3474,2550,5643,-5527,2946,7158,1938,5125,-8015,2475,-1461,-4900,-5151,-4031,9362,8571,9815,-8438,-6519,1980,-8031,9615,7079,-3573,-883,4217,1079,5918,1767,8670,-5651,-6625,1057,7897,-7104,-4186,851,-6333,-4108,-3250,7899,9628,-6904,-3939,4587,1227,3813,-7449,-7692,-8098,-9813,8862,-2888,-1048,-3564,3074,1437,-2291,3974,3164,4921,-8958,9007,-3938,2042,7454,-910,-998,-4450,-1103,-237,8182,-1391,-4255,-3482,-2918,4053,2280,-7403,4319,-9457,7157,-6315,-7533,6309,2211,-9145,443,4255,-8847,-5557,-9089,1752,-5784,-2399,-8296,-8400,8170,4628,-4583,937,-7067,-3503,-549,-1194,1576,5004,-6963,-8837,5567,870,3954,5489,-8949,-7673,8542,-9040,-7689,-4171,-889,5552,-6836,-4393,513,3177,6664,-5646,2492,9421,-342,2570,8816,2869,-6820,-3389,-1903,-3332,138,6618,293,-9130,3503,-2327,-9728,7632,5881,540,9678,-7629,8804,-2816,7205,7473,-5518,7311,3457,9066,-1224,2097,7857,6612,186,6759,-4516,-3491,-8268,-8928,-7412,7162,6274,5463,2157,-4131,-7061,-8476,-5584,7300,-4348,-5940,-8592,-302,-5817,3151,-4124,1694,-5114,-3252,-2319,-2157,-293,7724,-5673,6105,9535,4333,6353,1290,8710,-5035,8995,-5865,9746,4708,-6387,-8937,3096,-9716,-7124,2531,-660,-4619,-8035,3747,-7821,8793,-727,8242,4957,-7175,4064,-9911,4995,9725,1634,-4275,788,-4920,3831,-3525,-4467,2909,-1200,5377,-4905,-3077,-1763,4443,-3518,3134,-5595,5409,5943,6757,3485,2883,-9261,-7221,654,2001,-926,7840,-5568,2715,-7053,-2082,-2005,7607,-9511,7545,7564,2380,-7257,1449,-3918,-3240,-1928,-6555,-4784,1550,2745,-5316]\\nk=56"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if you use a heap, this question is medium. if you use a monotonic queue, this is easily a hard ... whenever lc suggests heap, it seems like monotonic queue is usually always faster "
                    }
                ]
            },
            {
                "id": 1576050,
                "content": [
                    {
                        "username": "faangboy",
                        "content": "Based on the solutions posted so far, the optimal approach seems the one similar to Sliding Window Maximum. But that question is hard, and for some one like me who has never solved it before, I don\\'t think it was medium for me ;)"
                    },
                    {
                        "username": "lalit10368",
                        "content": "You are right, I spent days trying to solve this problem but couldn't. So, I decided to attempt Sliding Window Maximum  instead. It's also listed in Similar Problems section. That problem looked straightforward compared to this one, although still hard. But the problem statement was pretty clear on using sliding windows. After spending some time I was able to figure out the solution and solved it in my first attempt. No wrong answers, no TLE, not even compilation issue. Most problems I could have solved in my head(both medium & hard levels) may be little bit of paper scribbling but this one(maximum sliding window) literally required a whiteboard and moving those window pointers around.\nMy Solution to the Maximum Window Problem : \nhttps://leetcode.com/problems/sliding-window-maximum/submissions/899998243/\n"
                    },
                    {
                        "username": "h98dubey",
                        "content": "Is it just me or anyone else also thinks that this problem should be under hard catogary, specially if you are looking this problem for the first time ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-vi/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming + Deque\n\n  \n**Approach 2:** Dynamic Programming + Priority Queue\n\n  \n**Approach 3:** Segment Tree\n\n  \n**Approach 4:** Dynamic Programming + Deque (Compressed)\n\n  \n**Approach 5:** Dynamic Programming + Priority Queue (Compressed)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Started from Jump Game I, jumped for 6 days and finally reached Jump Game VI."
                    },
                    {
                        "username": "xingasong",
                        "content": "Just wonder how leetcode decide the difficulty of a question..."
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "they assume u have done its prerequisites"
                    },
                    {
                        "username": "JustinNie",
                        "content": "It has to be hard, since it is hard."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is almost same as Constrained Subsequence Sum,which is hard.This should be hard or the other should be medium."
                    },
                    {
                        "username": "f20201382",
                        "content": "Why does the given code not work?\\n `class Solution {\\npublic:\\n    int n;\\n    int k;\\n    int maxScore(vector<int>& nums, vector<int>& dp, int i){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int score = INT_MIN;\\n        for(int j=1;j<=k;j++){\\n            score = max(score, nums[i]+maxScore(nums,dp,i+j));\\n        }\\n\\n        return dp[i] = score;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        this->k = k;\\n        vector<int> dp(n,-1);\\n        return maxScore(nums,dp,0);\\n    }\\n};.`\\n"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "yeah same doubt did u find the error ?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why the logic of picking the max in the next window , throws error. Like for k=2, if I pick i=2 as maximum then search through range [i + 1, min(n - 1, i + k)] i.e [3,5] and pick the max value in that range. If 5 contains the max value then start the next iteration [5,7] from the index =5. I wrote the code and it failed for this test case\\n\\n[-5582,-5317,6711,-639,1001,1845,1728,-4575,-6066,-7770,128,-3254,7281,3966,6857,5477,8968,-1771,9986,-6267,9010,-764,8413,-8154,1087,-1107,4183,3033,58,659,4625,2825,5031,6811,5657,3229,8597,-5772,8869,5723,2960,4040,7222,4841,-1014,581,-2830,3881,-3800,577,-7396,-611,-6944,8461,3294,6297,9713,-2246,-3441,3831,-5754,6716,6040,-6715,5763,8611,5412,-7630,6216,260,2595,6852,-8956,2101,6722,1579,3820,7827,-3369,7144,1974,7310,-5369,-6755,3010,5789,1563,-3330,5373,-2770,4503,-4065,8177,-3333,-4726,-2131,2763,9012,-4755,2382,3642,-5284,-7174,-9815,6392,9729,-1943,-8749,5343,1036,8508,1484,919,4225,3733,8036,-6346,-2088,475,9378,4271,-5906,9327,9399,-1582,3845,3499,-8912,-4671,-1143,-5081,-1621,-1287,5995,4963,5071,5118,-1966,-6249,663,-2296,-8148,-4668,-6919,334,-6609,2888,-4161,118,-1867,5629,8588,-5325,-7853,-4868,-1487,-6544,-9697,-7038,6422,-5545,3376,-8656,8800,-7698,-2928,2279,-9739,4198,6236,-9087,9010,-9894,2145,7353,-92,3205,5431,5913,1619,-250,4728,-7164,-5619,-4721,-9284,-9645,146,7131,-6501,4261,2016,2880,4944,-8768,-6339,-3574,539,4633,9188,7227,-1549,9271,7110,5706,4968,-1275,5545,-5844,-1985,9560,1560,4630,3169,6076,-9433,7007,9927,-8385,-4557,-114,9543,2884,8978,-6447,3664,-7499,-4643,-5993,-5321,3250,-2945,6216,-1606,5569,7326,-6027,9723,-6997,-543,-8298,-4647,2563,1493,9574,1087,-9433,-7749,-7159,-2682,6626,2787,-2845,-7907,-223,-8142,-5403,-3460,-2534,5289,999,9404,-1958,641,4669,-2892,-2921,-7001,-1403,-2353,-7976,-5885,4958,-8117,8785,-654,5918,5533,8704,5827,-7478,-3696,2640,1612,-500,5694,-1973,5308,5272,3358,9190,4648,-7836,658,-3407,6733,1061,-2010,-2707,-1920,1272,3944,-6537,-6090,-7429,-640,836,1904,-4031,814,-1886,8040,-8312,-9407,-1395,-9944,-2074,-6814,2672,1360,8990,5465,-2131,3838,799,-3472,1086,-583,6302,3032,9138,-7778,4538,-5337,2087,2870,-3005,3401,122,-819,-8074,9630,-698,5326,2650,-9355,6487,3801,-3209,8293,662,-8318,-7863,-3814,-2557,-5685,-7952,6224,-7010,2935,5557,-1287,9528,-9218,-5108,-2085,17,4870,-8686,-8854,-9657,8848,-1883,-4535,83,9711,4593,-3440,-6938,3407,-6894,-6213,-883,4552,-731,1485,-7740,-3300,3897,-7629,-4076,7589,3142,-1010,2466,-592,-391,3961,-7049,7654,5758,6983,6048,-4369,-5878,3756,2940,9149,8625,8937,5706,6658,9213,-5226,284,-4524,-1577,-5296,6423,9977,-1805,5462,7587,476,-6424,976,-3925,8819,1821,3603,-842,-9618,-7130,-6253,2562,-7596,3522,6282,-3801,-3896,6924,441,5944,8535,1253,-6154,6872,-9548,-5358,1604,9593,-9256,-701,1023,-1446,-1307,-6809,9542,3673,1813,8717,-6847,-5289,5222,-7266,4231,218,-9633,-4696,5494,9681,1173,-4606,2174,-1155,-8595,-3640,-6550,-7003,4244,-2543,5241,2831,2690,8950,-6609,-9724,7562,-4096,8878,9962,7179,-1170,7826,-146,-2759,-5249,253,6206,3205,-7708,9448,4622,9260,-2853,2486,122,-8880,-769,-8922,648,7358,-6503,-6382,-4260,3988,-5107,-6363,2415,8563,-9070,-5026,2078,-2558,-2027,-7489,-4978,5024,4155,-9737,-221,9930,-9472,1052,-268,6221,2726,-1310,-8708,3482,-5488,-6506,5389,-7048,553,-886,2752,85,-3938,5940,-5112,5855,-7295,3735,2657,3269,6231,4771,3229,-2009,-5748,7256,746,-4301,752,-241,-6151,-2390,9911,825,-7679,-4960,-7224,-2739,-566,-5770,6774,6243,3166,-783,-4303,-9016,5555,-1866,-536,8872,-3927,4269,-3807,1933,9972,981,9256,6857,-208,3645,-3725,5961,1105,6320,-4702,-8419,-4904,-4935,8378,-2994,5831,5296,4730,-9170,-4229,-3911,-160,8757,-5301,-3775,1121,9434,-9880,2689,2340,-7879,3667,-5219,-6116,-1670,7595,6900,3990,4444,6385,-2924,8968,-2673,-6182,7503,5209,6030,802,-3464,1922,-8187,1617,4769,-4866,-3518,5830,3862,-7512,5236,-5164,6324,-5107,6864,-7364,-1375,5762,-275,4975,-7448,5719,-3162,-1546,-2776,-9411,-1845,-4913,-3474,2550,5643,-5527,2946,7158,1938,5125,-8015,2475,-1461,-4900,-5151,-4031,9362,8571,9815,-8438,-6519,1980,-8031,9615,7079,-3573,-883,4217,1079,5918,1767,8670,-5651,-6625,1057,7897,-7104,-4186,851,-6333,-4108,-3250,7899,9628,-6904,-3939,4587,1227,3813,-7449,-7692,-8098,-9813,8862,-2888,-1048,-3564,3074,1437,-2291,3974,3164,4921,-8958,9007,-3938,2042,7454,-910,-998,-4450,-1103,-237,8182,-1391,-4255,-3482,-2918,4053,2280,-7403,4319,-9457,7157,-6315,-7533,6309,2211,-9145,443,4255,-8847,-5557,-9089,1752,-5784,-2399,-8296,-8400,8170,4628,-4583,937,-7067,-3503,-549,-1194,1576,5004,-6963,-8837,5567,870,3954,5489,-8949,-7673,8542,-9040,-7689,-4171,-889,5552,-6836,-4393,513,3177,6664,-5646,2492,9421,-342,2570,8816,2869,-6820,-3389,-1903,-3332,138,6618,293,-9130,3503,-2327,-9728,7632,5881,540,9678,-7629,8804,-2816,7205,7473,-5518,7311,3457,9066,-1224,2097,7857,6612,186,6759,-4516,-3491,-8268,-8928,-7412,7162,6274,5463,2157,-4131,-7061,-8476,-5584,7300,-4348,-5940,-8592,-302,-5817,3151,-4124,1694,-5114,-3252,-2319,-2157,-293,7724,-5673,6105,9535,4333,6353,1290,8710,-5035,8995,-5865,9746,4708,-6387,-8937,3096,-9716,-7124,2531,-660,-4619,-8035,3747,-7821,8793,-727,8242,4957,-7175,4064,-9911,4995,9725,1634,-4275,788,-4920,3831,-3525,-4467,2909,-1200,5377,-4905,-3077,-1763,4443,-3518,3134,-5595,5409,5943,6757,3485,2883,-9261,-7221,654,2001,-926,7840,-5568,2715,-7053,-2082,-2005,7607,-9511,7545,7564,2380,-7257,1449,-3918,-3240,-1928,-6555,-4784,1550,2745,-5316]\\nk=56"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if you use a heap, this question is medium. if you use a monotonic queue, this is easily a hard ... whenever lc suggests heap, it seems like monotonic queue is usually always faster "
                    }
                ]
            },
            {
                "id": 1575384,
                "content": [
                    {
                        "username": "faangboy",
                        "content": "Based on the solutions posted so far, the optimal approach seems the one similar to Sliding Window Maximum. But that question is hard, and for some one like me who has never solved it before, I don\\'t think it was medium for me ;)"
                    },
                    {
                        "username": "lalit10368",
                        "content": "You are right, I spent days trying to solve this problem but couldn't. So, I decided to attempt Sliding Window Maximum  instead. It's also listed in Similar Problems section. That problem looked straightforward compared to this one, although still hard. But the problem statement was pretty clear on using sliding windows. After spending some time I was able to figure out the solution and solved it in my first attempt. No wrong answers, no TLE, not even compilation issue. Most problems I could have solved in my head(both medium & hard levels) may be little bit of paper scribbling but this one(maximum sliding window) literally required a whiteboard and moving those window pointers around.\nMy Solution to the Maximum Window Problem : \nhttps://leetcode.com/problems/sliding-window-maximum/submissions/899998243/\n"
                    },
                    {
                        "username": "h98dubey",
                        "content": "Is it just me or anyone else also thinks that this problem should be under hard catogary, specially if you are looking this problem for the first time ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-vi/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming + Deque\n\n  \n**Approach 2:** Dynamic Programming + Priority Queue\n\n  \n**Approach 3:** Segment Tree\n\n  \n**Approach 4:** Dynamic Programming + Deque (Compressed)\n\n  \n**Approach 5:** Dynamic Programming + Priority Queue (Compressed)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Started from Jump Game I, jumped for 6 days and finally reached Jump Game VI."
                    },
                    {
                        "username": "xingasong",
                        "content": "Just wonder how leetcode decide the difficulty of a question..."
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "they assume u have done its prerequisites"
                    },
                    {
                        "username": "JustinNie",
                        "content": "It has to be hard, since it is hard."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is almost same as Constrained Subsequence Sum,which is hard.This should be hard or the other should be medium."
                    },
                    {
                        "username": "f20201382",
                        "content": "Why does the given code not work?\\n `class Solution {\\npublic:\\n    int n;\\n    int k;\\n    int maxScore(vector<int>& nums, vector<int>& dp, int i){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int score = INT_MIN;\\n        for(int j=1;j<=k;j++){\\n            score = max(score, nums[i]+maxScore(nums,dp,i+j));\\n        }\\n\\n        return dp[i] = score;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        this->k = k;\\n        vector<int> dp(n,-1);\\n        return maxScore(nums,dp,0);\\n    }\\n};.`\\n"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "yeah same doubt did u find the error ?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why the logic of picking the max in the next window , throws error. Like for k=2, if I pick i=2 as maximum then search through range [i + 1, min(n - 1, i + k)] i.e [3,5] and pick the max value in that range. If 5 contains the max value then start the next iteration [5,7] from the index =5. I wrote the code and it failed for this test case\\n\\n[-5582,-5317,6711,-639,1001,1845,1728,-4575,-6066,-7770,128,-3254,7281,3966,6857,5477,8968,-1771,9986,-6267,9010,-764,8413,-8154,1087,-1107,4183,3033,58,659,4625,2825,5031,6811,5657,3229,8597,-5772,8869,5723,2960,4040,7222,4841,-1014,581,-2830,3881,-3800,577,-7396,-611,-6944,8461,3294,6297,9713,-2246,-3441,3831,-5754,6716,6040,-6715,5763,8611,5412,-7630,6216,260,2595,6852,-8956,2101,6722,1579,3820,7827,-3369,7144,1974,7310,-5369,-6755,3010,5789,1563,-3330,5373,-2770,4503,-4065,8177,-3333,-4726,-2131,2763,9012,-4755,2382,3642,-5284,-7174,-9815,6392,9729,-1943,-8749,5343,1036,8508,1484,919,4225,3733,8036,-6346,-2088,475,9378,4271,-5906,9327,9399,-1582,3845,3499,-8912,-4671,-1143,-5081,-1621,-1287,5995,4963,5071,5118,-1966,-6249,663,-2296,-8148,-4668,-6919,334,-6609,2888,-4161,118,-1867,5629,8588,-5325,-7853,-4868,-1487,-6544,-9697,-7038,6422,-5545,3376,-8656,8800,-7698,-2928,2279,-9739,4198,6236,-9087,9010,-9894,2145,7353,-92,3205,5431,5913,1619,-250,4728,-7164,-5619,-4721,-9284,-9645,146,7131,-6501,4261,2016,2880,4944,-8768,-6339,-3574,539,4633,9188,7227,-1549,9271,7110,5706,4968,-1275,5545,-5844,-1985,9560,1560,4630,3169,6076,-9433,7007,9927,-8385,-4557,-114,9543,2884,8978,-6447,3664,-7499,-4643,-5993,-5321,3250,-2945,6216,-1606,5569,7326,-6027,9723,-6997,-543,-8298,-4647,2563,1493,9574,1087,-9433,-7749,-7159,-2682,6626,2787,-2845,-7907,-223,-8142,-5403,-3460,-2534,5289,999,9404,-1958,641,4669,-2892,-2921,-7001,-1403,-2353,-7976,-5885,4958,-8117,8785,-654,5918,5533,8704,5827,-7478,-3696,2640,1612,-500,5694,-1973,5308,5272,3358,9190,4648,-7836,658,-3407,6733,1061,-2010,-2707,-1920,1272,3944,-6537,-6090,-7429,-640,836,1904,-4031,814,-1886,8040,-8312,-9407,-1395,-9944,-2074,-6814,2672,1360,8990,5465,-2131,3838,799,-3472,1086,-583,6302,3032,9138,-7778,4538,-5337,2087,2870,-3005,3401,122,-819,-8074,9630,-698,5326,2650,-9355,6487,3801,-3209,8293,662,-8318,-7863,-3814,-2557,-5685,-7952,6224,-7010,2935,5557,-1287,9528,-9218,-5108,-2085,17,4870,-8686,-8854,-9657,8848,-1883,-4535,83,9711,4593,-3440,-6938,3407,-6894,-6213,-883,4552,-731,1485,-7740,-3300,3897,-7629,-4076,7589,3142,-1010,2466,-592,-391,3961,-7049,7654,5758,6983,6048,-4369,-5878,3756,2940,9149,8625,8937,5706,6658,9213,-5226,284,-4524,-1577,-5296,6423,9977,-1805,5462,7587,476,-6424,976,-3925,8819,1821,3603,-842,-9618,-7130,-6253,2562,-7596,3522,6282,-3801,-3896,6924,441,5944,8535,1253,-6154,6872,-9548,-5358,1604,9593,-9256,-701,1023,-1446,-1307,-6809,9542,3673,1813,8717,-6847,-5289,5222,-7266,4231,218,-9633,-4696,5494,9681,1173,-4606,2174,-1155,-8595,-3640,-6550,-7003,4244,-2543,5241,2831,2690,8950,-6609,-9724,7562,-4096,8878,9962,7179,-1170,7826,-146,-2759,-5249,253,6206,3205,-7708,9448,4622,9260,-2853,2486,122,-8880,-769,-8922,648,7358,-6503,-6382,-4260,3988,-5107,-6363,2415,8563,-9070,-5026,2078,-2558,-2027,-7489,-4978,5024,4155,-9737,-221,9930,-9472,1052,-268,6221,2726,-1310,-8708,3482,-5488,-6506,5389,-7048,553,-886,2752,85,-3938,5940,-5112,5855,-7295,3735,2657,3269,6231,4771,3229,-2009,-5748,7256,746,-4301,752,-241,-6151,-2390,9911,825,-7679,-4960,-7224,-2739,-566,-5770,6774,6243,3166,-783,-4303,-9016,5555,-1866,-536,8872,-3927,4269,-3807,1933,9972,981,9256,6857,-208,3645,-3725,5961,1105,6320,-4702,-8419,-4904,-4935,8378,-2994,5831,5296,4730,-9170,-4229,-3911,-160,8757,-5301,-3775,1121,9434,-9880,2689,2340,-7879,3667,-5219,-6116,-1670,7595,6900,3990,4444,6385,-2924,8968,-2673,-6182,7503,5209,6030,802,-3464,1922,-8187,1617,4769,-4866,-3518,5830,3862,-7512,5236,-5164,6324,-5107,6864,-7364,-1375,5762,-275,4975,-7448,5719,-3162,-1546,-2776,-9411,-1845,-4913,-3474,2550,5643,-5527,2946,7158,1938,5125,-8015,2475,-1461,-4900,-5151,-4031,9362,8571,9815,-8438,-6519,1980,-8031,9615,7079,-3573,-883,4217,1079,5918,1767,8670,-5651,-6625,1057,7897,-7104,-4186,851,-6333,-4108,-3250,7899,9628,-6904,-3939,4587,1227,3813,-7449,-7692,-8098,-9813,8862,-2888,-1048,-3564,3074,1437,-2291,3974,3164,4921,-8958,9007,-3938,2042,7454,-910,-998,-4450,-1103,-237,8182,-1391,-4255,-3482,-2918,4053,2280,-7403,4319,-9457,7157,-6315,-7533,6309,2211,-9145,443,4255,-8847,-5557,-9089,1752,-5784,-2399,-8296,-8400,8170,4628,-4583,937,-7067,-3503,-549,-1194,1576,5004,-6963,-8837,5567,870,3954,5489,-8949,-7673,8542,-9040,-7689,-4171,-889,5552,-6836,-4393,513,3177,6664,-5646,2492,9421,-342,2570,8816,2869,-6820,-3389,-1903,-3332,138,6618,293,-9130,3503,-2327,-9728,7632,5881,540,9678,-7629,8804,-2816,7205,7473,-5518,7311,3457,9066,-1224,2097,7857,6612,186,6759,-4516,-3491,-8268,-8928,-7412,7162,6274,5463,2157,-4131,-7061,-8476,-5584,7300,-4348,-5940,-8592,-302,-5817,3151,-4124,1694,-5114,-3252,-2319,-2157,-293,7724,-5673,6105,9535,4333,6353,1290,8710,-5035,8995,-5865,9746,4708,-6387,-8937,3096,-9716,-7124,2531,-660,-4619,-8035,3747,-7821,8793,-727,8242,4957,-7175,4064,-9911,4995,9725,1634,-4275,788,-4920,3831,-3525,-4467,2909,-1200,5377,-4905,-3077,-1763,4443,-3518,3134,-5595,5409,5943,6757,3485,2883,-9261,-7221,654,2001,-926,7840,-5568,2715,-7053,-2082,-2005,7607,-9511,7545,7564,2380,-7257,1449,-3918,-3240,-1928,-6555,-4784,1550,2745,-5316]\\nk=56"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if you use a heap, this question is medium. if you use a monotonic queue, this is easily a hard ... whenever lc suggests heap, it seems like monotonic queue is usually always faster "
                    }
                ]
            },
            {
                "id": 1822758,
                "content": [
                    {
                        "username": "faangboy",
                        "content": "Based on the solutions posted so far, the optimal approach seems the one similar to Sliding Window Maximum. But that question is hard, and for some one like me who has never solved it before, I don\\'t think it was medium for me ;)"
                    },
                    {
                        "username": "lalit10368",
                        "content": "You are right, I spent days trying to solve this problem but couldn't. So, I decided to attempt Sliding Window Maximum  instead. It's also listed in Similar Problems section. That problem looked straightforward compared to this one, although still hard. But the problem statement was pretty clear on using sliding windows. After spending some time I was able to figure out the solution and solved it in my first attempt. No wrong answers, no TLE, not even compilation issue. Most problems I could have solved in my head(both medium & hard levels) may be little bit of paper scribbling but this one(maximum sliding window) literally required a whiteboard and moving those window pointers around.\nMy Solution to the Maximum Window Problem : \nhttps://leetcode.com/problems/sliding-window-maximum/submissions/899998243/\n"
                    },
                    {
                        "username": "h98dubey",
                        "content": "Is it just me or anyone else also thinks that this problem should be under hard catogary, specially if you are looking this problem for the first time ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-vi/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming + Deque\n\n  \n**Approach 2:** Dynamic Programming + Priority Queue\n\n  \n**Approach 3:** Segment Tree\n\n  \n**Approach 4:** Dynamic Programming + Deque (Compressed)\n\n  \n**Approach 5:** Dynamic Programming + Priority Queue (Compressed)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Started from Jump Game I, jumped for 6 days and finally reached Jump Game VI."
                    },
                    {
                        "username": "xingasong",
                        "content": "Just wonder how leetcode decide the difficulty of a question..."
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "they assume u have done its prerequisites"
                    },
                    {
                        "username": "JustinNie",
                        "content": "It has to be hard, since it is hard."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is almost same as Constrained Subsequence Sum,which is hard.This should be hard or the other should be medium."
                    },
                    {
                        "username": "f20201382",
                        "content": "Why does the given code not work?\\n `class Solution {\\npublic:\\n    int n;\\n    int k;\\n    int maxScore(vector<int>& nums, vector<int>& dp, int i){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int score = INT_MIN;\\n        for(int j=1;j<=k;j++){\\n            score = max(score, nums[i]+maxScore(nums,dp,i+j));\\n        }\\n\\n        return dp[i] = score;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        this->k = k;\\n        vector<int> dp(n,-1);\\n        return maxScore(nums,dp,0);\\n    }\\n};.`\\n"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "yeah same doubt did u find the error ?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why the logic of picking the max in the next window , throws error. Like for k=2, if I pick i=2 as maximum then search through range [i + 1, min(n - 1, i + k)] i.e [3,5] and pick the max value in that range. If 5 contains the max value then start the next iteration [5,7] from the index =5. I wrote the code and it failed for this test case\\n\\n[-5582,-5317,6711,-639,1001,1845,1728,-4575,-6066,-7770,128,-3254,7281,3966,6857,5477,8968,-1771,9986,-6267,9010,-764,8413,-8154,1087,-1107,4183,3033,58,659,4625,2825,5031,6811,5657,3229,8597,-5772,8869,5723,2960,4040,7222,4841,-1014,581,-2830,3881,-3800,577,-7396,-611,-6944,8461,3294,6297,9713,-2246,-3441,3831,-5754,6716,6040,-6715,5763,8611,5412,-7630,6216,260,2595,6852,-8956,2101,6722,1579,3820,7827,-3369,7144,1974,7310,-5369,-6755,3010,5789,1563,-3330,5373,-2770,4503,-4065,8177,-3333,-4726,-2131,2763,9012,-4755,2382,3642,-5284,-7174,-9815,6392,9729,-1943,-8749,5343,1036,8508,1484,919,4225,3733,8036,-6346,-2088,475,9378,4271,-5906,9327,9399,-1582,3845,3499,-8912,-4671,-1143,-5081,-1621,-1287,5995,4963,5071,5118,-1966,-6249,663,-2296,-8148,-4668,-6919,334,-6609,2888,-4161,118,-1867,5629,8588,-5325,-7853,-4868,-1487,-6544,-9697,-7038,6422,-5545,3376,-8656,8800,-7698,-2928,2279,-9739,4198,6236,-9087,9010,-9894,2145,7353,-92,3205,5431,5913,1619,-250,4728,-7164,-5619,-4721,-9284,-9645,146,7131,-6501,4261,2016,2880,4944,-8768,-6339,-3574,539,4633,9188,7227,-1549,9271,7110,5706,4968,-1275,5545,-5844,-1985,9560,1560,4630,3169,6076,-9433,7007,9927,-8385,-4557,-114,9543,2884,8978,-6447,3664,-7499,-4643,-5993,-5321,3250,-2945,6216,-1606,5569,7326,-6027,9723,-6997,-543,-8298,-4647,2563,1493,9574,1087,-9433,-7749,-7159,-2682,6626,2787,-2845,-7907,-223,-8142,-5403,-3460,-2534,5289,999,9404,-1958,641,4669,-2892,-2921,-7001,-1403,-2353,-7976,-5885,4958,-8117,8785,-654,5918,5533,8704,5827,-7478,-3696,2640,1612,-500,5694,-1973,5308,5272,3358,9190,4648,-7836,658,-3407,6733,1061,-2010,-2707,-1920,1272,3944,-6537,-6090,-7429,-640,836,1904,-4031,814,-1886,8040,-8312,-9407,-1395,-9944,-2074,-6814,2672,1360,8990,5465,-2131,3838,799,-3472,1086,-583,6302,3032,9138,-7778,4538,-5337,2087,2870,-3005,3401,122,-819,-8074,9630,-698,5326,2650,-9355,6487,3801,-3209,8293,662,-8318,-7863,-3814,-2557,-5685,-7952,6224,-7010,2935,5557,-1287,9528,-9218,-5108,-2085,17,4870,-8686,-8854,-9657,8848,-1883,-4535,83,9711,4593,-3440,-6938,3407,-6894,-6213,-883,4552,-731,1485,-7740,-3300,3897,-7629,-4076,7589,3142,-1010,2466,-592,-391,3961,-7049,7654,5758,6983,6048,-4369,-5878,3756,2940,9149,8625,8937,5706,6658,9213,-5226,284,-4524,-1577,-5296,6423,9977,-1805,5462,7587,476,-6424,976,-3925,8819,1821,3603,-842,-9618,-7130,-6253,2562,-7596,3522,6282,-3801,-3896,6924,441,5944,8535,1253,-6154,6872,-9548,-5358,1604,9593,-9256,-701,1023,-1446,-1307,-6809,9542,3673,1813,8717,-6847,-5289,5222,-7266,4231,218,-9633,-4696,5494,9681,1173,-4606,2174,-1155,-8595,-3640,-6550,-7003,4244,-2543,5241,2831,2690,8950,-6609,-9724,7562,-4096,8878,9962,7179,-1170,7826,-146,-2759,-5249,253,6206,3205,-7708,9448,4622,9260,-2853,2486,122,-8880,-769,-8922,648,7358,-6503,-6382,-4260,3988,-5107,-6363,2415,8563,-9070,-5026,2078,-2558,-2027,-7489,-4978,5024,4155,-9737,-221,9930,-9472,1052,-268,6221,2726,-1310,-8708,3482,-5488,-6506,5389,-7048,553,-886,2752,85,-3938,5940,-5112,5855,-7295,3735,2657,3269,6231,4771,3229,-2009,-5748,7256,746,-4301,752,-241,-6151,-2390,9911,825,-7679,-4960,-7224,-2739,-566,-5770,6774,6243,3166,-783,-4303,-9016,5555,-1866,-536,8872,-3927,4269,-3807,1933,9972,981,9256,6857,-208,3645,-3725,5961,1105,6320,-4702,-8419,-4904,-4935,8378,-2994,5831,5296,4730,-9170,-4229,-3911,-160,8757,-5301,-3775,1121,9434,-9880,2689,2340,-7879,3667,-5219,-6116,-1670,7595,6900,3990,4444,6385,-2924,8968,-2673,-6182,7503,5209,6030,802,-3464,1922,-8187,1617,4769,-4866,-3518,5830,3862,-7512,5236,-5164,6324,-5107,6864,-7364,-1375,5762,-275,4975,-7448,5719,-3162,-1546,-2776,-9411,-1845,-4913,-3474,2550,5643,-5527,2946,7158,1938,5125,-8015,2475,-1461,-4900,-5151,-4031,9362,8571,9815,-8438,-6519,1980,-8031,9615,7079,-3573,-883,4217,1079,5918,1767,8670,-5651,-6625,1057,7897,-7104,-4186,851,-6333,-4108,-3250,7899,9628,-6904,-3939,4587,1227,3813,-7449,-7692,-8098,-9813,8862,-2888,-1048,-3564,3074,1437,-2291,3974,3164,4921,-8958,9007,-3938,2042,7454,-910,-998,-4450,-1103,-237,8182,-1391,-4255,-3482,-2918,4053,2280,-7403,4319,-9457,7157,-6315,-7533,6309,2211,-9145,443,4255,-8847,-5557,-9089,1752,-5784,-2399,-8296,-8400,8170,4628,-4583,937,-7067,-3503,-549,-1194,1576,5004,-6963,-8837,5567,870,3954,5489,-8949,-7673,8542,-9040,-7689,-4171,-889,5552,-6836,-4393,513,3177,6664,-5646,2492,9421,-342,2570,8816,2869,-6820,-3389,-1903,-3332,138,6618,293,-9130,3503,-2327,-9728,7632,5881,540,9678,-7629,8804,-2816,7205,7473,-5518,7311,3457,9066,-1224,2097,7857,6612,186,6759,-4516,-3491,-8268,-8928,-7412,7162,6274,5463,2157,-4131,-7061,-8476,-5584,7300,-4348,-5940,-8592,-302,-5817,3151,-4124,1694,-5114,-3252,-2319,-2157,-293,7724,-5673,6105,9535,4333,6353,1290,8710,-5035,8995,-5865,9746,4708,-6387,-8937,3096,-9716,-7124,2531,-660,-4619,-8035,3747,-7821,8793,-727,8242,4957,-7175,4064,-9911,4995,9725,1634,-4275,788,-4920,3831,-3525,-4467,2909,-1200,5377,-4905,-3077,-1763,4443,-3518,3134,-5595,5409,5943,6757,3485,2883,-9261,-7221,654,2001,-926,7840,-5568,2715,-7053,-2082,-2005,7607,-9511,7545,7564,2380,-7257,1449,-3918,-3240,-1928,-6555,-4784,1550,2745,-5316]\\nk=56"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if you use a heap, this question is medium. if you use a monotonic queue, this is easily a hard ... whenever lc suggests heap, it seems like monotonic queue is usually always faster "
                    }
                ]
            },
            {
                "id": 1979271,
                "content": [
                    {
                        "username": "faangboy",
                        "content": "Based on the solutions posted so far, the optimal approach seems the one similar to Sliding Window Maximum. But that question is hard, and for some one like me who has never solved it before, I don\\'t think it was medium for me ;)"
                    },
                    {
                        "username": "lalit10368",
                        "content": "You are right, I spent days trying to solve this problem but couldn't. So, I decided to attempt Sliding Window Maximum  instead. It's also listed in Similar Problems section. That problem looked straightforward compared to this one, although still hard. But the problem statement was pretty clear on using sliding windows. After spending some time I was able to figure out the solution and solved it in my first attempt. No wrong answers, no TLE, not even compilation issue. Most problems I could have solved in my head(both medium & hard levels) may be little bit of paper scribbling but this one(maximum sliding window) literally required a whiteboard and moving those window pointers around.\nMy Solution to the Maximum Window Problem : \nhttps://leetcode.com/problems/sliding-window-maximum/submissions/899998243/\n"
                    },
                    {
                        "username": "h98dubey",
                        "content": "Is it just me or anyone else also thinks that this problem should be under hard catogary, specially if you are looking this problem for the first time ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-vi/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming + Deque\n\n  \n**Approach 2:** Dynamic Programming + Priority Queue\n\n  \n**Approach 3:** Segment Tree\n\n  \n**Approach 4:** Dynamic Programming + Deque (Compressed)\n\n  \n**Approach 5:** Dynamic Programming + Priority Queue (Compressed)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Started from Jump Game I, jumped for 6 days and finally reached Jump Game VI."
                    },
                    {
                        "username": "xingasong",
                        "content": "Just wonder how leetcode decide the difficulty of a question..."
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "they assume u have done its prerequisites"
                    },
                    {
                        "username": "JustinNie",
                        "content": "It has to be hard, since it is hard."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is almost same as Constrained Subsequence Sum,which is hard.This should be hard or the other should be medium."
                    },
                    {
                        "username": "f20201382",
                        "content": "Why does the given code not work?\\n `class Solution {\\npublic:\\n    int n;\\n    int k;\\n    int maxScore(vector<int>& nums, vector<int>& dp, int i){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int score = INT_MIN;\\n        for(int j=1;j<=k;j++){\\n            score = max(score, nums[i]+maxScore(nums,dp,i+j));\\n        }\\n\\n        return dp[i] = score;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        this->k = k;\\n        vector<int> dp(n,-1);\\n        return maxScore(nums,dp,0);\\n    }\\n};.`\\n"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "yeah same doubt did u find the error ?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why the logic of picking the max in the next window , throws error. Like for k=2, if I pick i=2 as maximum then search through range [i + 1, min(n - 1, i + k)] i.e [3,5] and pick the max value in that range. If 5 contains the max value then start the next iteration [5,7] from the index =5. I wrote the code and it failed for this test case\\n\\n[-5582,-5317,6711,-639,1001,1845,1728,-4575,-6066,-7770,128,-3254,7281,3966,6857,5477,8968,-1771,9986,-6267,9010,-764,8413,-8154,1087,-1107,4183,3033,58,659,4625,2825,5031,6811,5657,3229,8597,-5772,8869,5723,2960,4040,7222,4841,-1014,581,-2830,3881,-3800,577,-7396,-611,-6944,8461,3294,6297,9713,-2246,-3441,3831,-5754,6716,6040,-6715,5763,8611,5412,-7630,6216,260,2595,6852,-8956,2101,6722,1579,3820,7827,-3369,7144,1974,7310,-5369,-6755,3010,5789,1563,-3330,5373,-2770,4503,-4065,8177,-3333,-4726,-2131,2763,9012,-4755,2382,3642,-5284,-7174,-9815,6392,9729,-1943,-8749,5343,1036,8508,1484,919,4225,3733,8036,-6346,-2088,475,9378,4271,-5906,9327,9399,-1582,3845,3499,-8912,-4671,-1143,-5081,-1621,-1287,5995,4963,5071,5118,-1966,-6249,663,-2296,-8148,-4668,-6919,334,-6609,2888,-4161,118,-1867,5629,8588,-5325,-7853,-4868,-1487,-6544,-9697,-7038,6422,-5545,3376,-8656,8800,-7698,-2928,2279,-9739,4198,6236,-9087,9010,-9894,2145,7353,-92,3205,5431,5913,1619,-250,4728,-7164,-5619,-4721,-9284,-9645,146,7131,-6501,4261,2016,2880,4944,-8768,-6339,-3574,539,4633,9188,7227,-1549,9271,7110,5706,4968,-1275,5545,-5844,-1985,9560,1560,4630,3169,6076,-9433,7007,9927,-8385,-4557,-114,9543,2884,8978,-6447,3664,-7499,-4643,-5993,-5321,3250,-2945,6216,-1606,5569,7326,-6027,9723,-6997,-543,-8298,-4647,2563,1493,9574,1087,-9433,-7749,-7159,-2682,6626,2787,-2845,-7907,-223,-8142,-5403,-3460,-2534,5289,999,9404,-1958,641,4669,-2892,-2921,-7001,-1403,-2353,-7976,-5885,4958,-8117,8785,-654,5918,5533,8704,5827,-7478,-3696,2640,1612,-500,5694,-1973,5308,5272,3358,9190,4648,-7836,658,-3407,6733,1061,-2010,-2707,-1920,1272,3944,-6537,-6090,-7429,-640,836,1904,-4031,814,-1886,8040,-8312,-9407,-1395,-9944,-2074,-6814,2672,1360,8990,5465,-2131,3838,799,-3472,1086,-583,6302,3032,9138,-7778,4538,-5337,2087,2870,-3005,3401,122,-819,-8074,9630,-698,5326,2650,-9355,6487,3801,-3209,8293,662,-8318,-7863,-3814,-2557,-5685,-7952,6224,-7010,2935,5557,-1287,9528,-9218,-5108,-2085,17,4870,-8686,-8854,-9657,8848,-1883,-4535,83,9711,4593,-3440,-6938,3407,-6894,-6213,-883,4552,-731,1485,-7740,-3300,3897,-7629,-4076,7589,3142,-1010,2466,-592,-391,3961,-7049,7654,5758,6983,6048,-4369,-5878,3756,2940,9149,8625,8937,5706,6658,9213,-5226,284,-4524,-1577,-5296,6423,9977,-1805,5462,7587,476,-6424,976,-3925,8819,1821,3603,-842,-9618,-7130,-6253,2562,-7596,3522,6282,-3801,-3896,6924,441,5944,8535,1253,-6154,6872,-9548,-5358,1604,9593,-9256,-701,1023,-1446,-1307,-6809,9542,3673,1813,8717,-6847,-5289,5222,-7266,4231,218,-9633,-4696,5494,9681,1173,-4606,2174,-1155,-8595,-3640,-6550,-7003,4244,-2543,5241,2831,2690,8950,-6609,-9724,7562,-4096,8878,9962,7179,-1170,7826,-146,-2759,-5249,253,6206,3205,-7708,9448,4622,9260,-2853,2486,122,-8880,-769,-8922,648,7358,-6503,-6382,-4260,3988,-5107,-6363,2415,8563,-9070,-5026,2078,-2558,-2027,-7489,-4978,5024,4155,-9737,-221,9930,-9472,1052,-268,6221,2726,-1310,-8708,3482,-5488,-6506,5389,-7048,553,-886,2752,85,-3938,5940,-5112,5855,-7295,3735,2657,3269,6231,4771,3229,-2009,-5748,7256,746,-4301,752,-241,-6151,-2390,9911,825,-7679,-4960,-7224,-2739,-566,-5770,6774,6243,3166,-783,-4303,-9016,5555,-1866,-536,8872,-3927,4269,-3807,1933,9972,981,9256,6857,-208,3645,-3725,5961,1105,6320,-4702,-8419,-4904,-4935,8378,-2994,5831,5296,4730,-9170,-4229,-3911,-160,8757,-5301,-3775,1121,9434,-9880,2689,2340,-7879,3667,-5219,-6116,-1670,7595,6900,3990,4444,6385,-2924,8968,-2673,-6182,7503,5209,6030,802,-3464,1922,-8187,1617,4769,-4866,-3518,5830,3862,-7512,5236,-5164,6324,-5107,6864,-7364,-1375,5762,-275,4975,-7448,5719,-3162,-1546,-2776,-9411,-1845,-4913,-3474,2550,5643,-5527,2946,7158,1938,5125,-8015,2475,-1461,-4900,-5151,-4031,9362,8571,9815,-8438,-6519,1980,-8031,9615,7079,-3573,-883,4217,1079,5918,1767,8670,-5651,-6625,1057,7897,-7104,-4186,851,-6333,-4108,-3250,7899,9628,-6904,-3939,4587,1227,3813,-7449,-7692,-8098,-9813,8862,-2888,-1048,-3564,3074,1437,-2291,3974,3164,4921,-8958,9007,-3938,2042,7454,-910,-998,-4450,-1103,-237,8182,-1391,-4255,-3482,-2918,4053,2280,-7403,4319,-9457,7157,-6315,-7533,6309,2211,-9145,443,4255,-8847,-5557,-9089,1752,-5784,-2399,-8296,-8400,8170,4628,-4583,937,-7067,-3503,-549,-1194,1576,5004,-6963,-8837,5567,870,3954,5489,-8949,-7673,8542,-9040,-7689,-4171,-889,5552,-6836,-4393,513,3177,6664,-5646,2492,9421,-342,2570,8816,2869,-6820,-3389,-1903,-3332,138,6618,293,-9130,3503,-2327,-9728,7632,5881,540,9678,-7629,8804,-2816,7205,7473,-5518,7311,3457,9066,-1224,2097,7857,6612,186,6759,-4516,-3491,-8268,-8928,-7412,7162,6274,5463,2157,-4131,-7061,-8476,-5584,7300,-4348,-5940,-8592,-302,-5817,3151,-4124,1694,-5114,-3252,-2319,-2157,-293,7724,-5673,6105,9535,4333,6353,1290,8710,-5035,8995,-5865,9746,4708,-6387,-8937,3096,-9716,-7124,2531,-660,-4619,-8035,3747,-7821,8793,-727,8242,4957,-7175,4064,-9911,4995,9725,1634,-4275,788,-4920,3831,-3525,-4467,2909,-1200,5377,-4905,-3077,-1763,4443,-3518,3134,-5595,5409,5943,6757,3485,2883,-9261,-7221,654,2001,-926,7840,-5568,2715,-7053,-2082,-2005,7607,-9511,7545,7564,2380,-7257,1449,-3918,-3240,-1928,-6555,-4784,1550,2745,-5316]\\nk=56"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if you use a heap, this question is medium. if you use a monotonic queue, this is easily a hard ... whenever lc suggests heap, it seems like monotonic queue is usually always faster "
                    }
                ]
            },
            {
                "id": 1929420,
                "content": [
                    {
                        "username": "faangboy",
                        "content": "Based on the solutions posted so far, the optimal approach seems the one similar to Sliding Window Maximum. But that question is hard, and for some one like me who has never solved it before, I don\\'t think it was medium for me ;)"
                    },
                    {
                        "username": "lalit10368",
                        "content": "You are right, I spent days trying to solve this problem but couldn't. So, I decided to attempt Sliding Window Maximum  instead. It's also listed in Similar Problems section. That problem looked straightforward compared to this one, although still hard. But the problem statement was pretty clear on using sliding windows. After spending some time I was able to figure out the solution and solved it in my first attempt. No wrong answers, no TLE, not even compilation issue. Most problems I could have solved in my head(both medium & hard levels) may be little bit of paper scribbling but this one(maximum sliding window) literally required a whiteboard and moving those window pointers around.\nMy Solution to the Maximum Window Problem : \nhttps://leetcode.com/problems/sliding-window-maximum/submissions/899998243/\n"
                    },
                    {
                        "username": "h98dubey",
                        "content": "Is it just me or anyone else also thinks that this problem should be under hard catogary, specially if you are looking this problem for the first time ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-vi/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming + Deque\n\n  \n**Approach 2:** Dynamic Programming + Priority Queue\n\n  \n**Approach 3:** Segment Tree\n\n  \n**Approach 4:** Dynamic Programming + Deque (Compressed)\n\n  \n**Approach 5:** Dynamic Programming + Priority Queue (Compressed)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Started from Jump Game I, jumped for 6 days and finally reached Jump Game VI."
                    },
                    {
                        "username": "xingasong",
                        "content": "Just wonder how leetcode decide the difficulty of a question..."
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "they assume u have done its prerequisites"
                    },
                    {
                        "username": "JustinNie",
                        "content": "It has to be hard, since it is hard."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is almost same as Constrained Subsequence Sum,which is hard.This should be hard or the other should be medium."
                    },
                    {
                        "username": "f20201382",
                        "content": "Why does the given code not work?\\n `class Solution {\\npublic:\\n    int n;\\n    int k;\\n    int maxScore(vector<int>& nums, vector<int>& dp, int i){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int score = INT_MIN;\\n        for(int j=1;j<=k;j++){\\n            score = max(score, nums[i]+maxScore(nums,dp,i+j));\\n        }\\n\\n        return dp[i] = score;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        this->k = k;\\n        vector<int> dp(n,-1);\\n        return maxScore(nums,dp,0);\\n    }\\n};.`\\n"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "yeah same doubt did u find the error ?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why the logic of picking the max in the next window , throws error. Like for k=2, if I pick i=2 as maximum then search through range [i + 1, min(n - 1, i + k)] i.e [3,5] and pick the max value in that range. If 5 contains the max value then start the next iteration [5,7] from the index =5. I wrote the code and it failed for this test case\\n\\n[-5582,-5317,6711,-639,1001,1845,1728,-4575,-6066,-7770,128,-3254,7281,3966,6857,5477,8968,-1771,9986,-6267,9010,-764,8413,-8154,1087,-1107,4183,3033,58,659,4625,2825,5031,6811,5657,3229,8597,-5772,8869,5723,2960,4040,7222,4841,-1014,581,-2830,3881,-3800,577,-7396,-611,-6944,8461,3294,6297,9713,-2246,-3441,3831,-5754,6716,6040,-6715,5763,8611,5412,-7630,6216,260,2595,6852,-8956,2101,6722,1579,3820,7827,-3369,7144,1974,7310,-5369,-6755,3010,5789,1563,-3330,5373,-2770,4503,-4065,8177,-3333,-4726,-2131,2763,9012,-4755,2382,3642,-5284,-7174,-9815,6392,9729,-1943,-8749,5343,1036,8508,1484,919,4225,3733,8036,-6346,-2088,475,9378,4271,-5906,9327,9399,-1582,3845,3499,-8912,-4671,-1143,-5081,-1621,-1287,5995,4963,5071,5118,-1966,-6249,663,-2296,-8148,-4668,-6919,334,-6609,2888,-4161,118,-1867,5629,8588,-5325,-7853,-4868,-1487,-6544,-9697,-7038,6422,-5545,3376,-8656,8800,-7698,-2928,2279,-9739,4198,6236,-9087,9010,-9894,2145,7353,-92,3205,5431,5913,1619,-250,4728,-7164,-5619,-4721,-9284,-9645,146,7131,-6501,4261,2016,2880,4944,-8768,-6339,-3574,539,4633,9188,7227,-1549,9271,7110,5706,4968,-1275,5545,-5844,-1985,9560,1560,4630,3169,6076,-9433,7007,9927,-8385,-4557,-114,9543,2884,8978,-6447,3664,-7499,-4643,-5993,-5321,3250,-2945,6216,-1606,5569,7326,-6027,9723,-6997,-543,-8298,-4647,2563,1493,9574,1087,-9433,-7749,-7159,-2682,6626,2787,-2845,-7907,-223,-8142,-5403,-3460,-2534,5289,999,9404,-1958,641,4669,-2892,-2921,-7001,-1403,-2353,-7976,-5885,4958,-8117,8785,-654,5918,5533,8704,5827,-7478,-3696,2640,1612,-500,5694,-1973,5308,5272,3358,9190,4648,-7836,658,-3407,6733,1061,-2010,-2707,-1920,1272,3944,-6537,-6090,-7429,-640,836,1904,-4031,814,-1886,8040,-8312,-9407,-1395,-9944,-2074,-6814,2672,1360,8990,5465,-2131,3838,799,-3472,1086,-583,6302,3032,9138,-7778,4538,-5337,2087,2870,-3005,3401,122,-819,-8074,9630,-698,5326,2650,-9355,6487,3801,-3209,8293,662,-8318,-7863,-3814,-2557,-5685,-7952,6224,-7010,2935,5557,-1287,9528,-9218,-5108,-2085,17,4870,-8686,-8854,-9657,8848,-1883,-4535,83,9711,4593,-3440,-6938,3407,-6894,-6213,-883,4552,-731,1485,-7740,-3300,3897,-7629,-4076,7589,3142,-1010,2466,-592,-391,3961,-7049,7654,5758,6983,6048,-4369,-5878,3756,2940,9149,8625,8937,5706,6658,9213,-5226,284,-4524,-1577,-5296,6423,9977,-1805,5462,7587,476,-6424,976,-3925,8819,1821,3603,-842,-9618,-7130,-6253,2562,-7596,3522,6282,-3801,-3896,6924,441,5944,8535,1253,-6154,6872,-9548,-5358,1604,9593,-9256,-701,1023,-1446,-1307,-6809,9542,3673,1813,8717,-6847,-5289,5222,-7266,4231,218,-9633,-4696,5494,9681,1173,-4606,2174,-1155,-8595,-3640,-6550,-7003,4244,-2543,5241,2831,2690,8950,-6609,-9724,7562,-4096,8878,9962,7179,-1170,7826,-146,-2759,-5249,253,6206,3205,-7708,9448,4622,9260,-2853,2486,122,-8880,-769,-8922,648,7358,-6503,-6382,-4260,3988,-5107,-6363,2415,8563,-9070,-5026,2078,-2558,-2027,-7489,-4978,5024,4155,-9737,-221,9930,-9472,1052,-268,6221,2726,-1310,-8708,3482,-5488,-6506,5389,-7048,553,-886,2752,85,-3938,5940,-5112,5855,-7295,3735,2657,3269,6231,4771,3229,-2009,-5748,7256,746,-4301,752,-241,-6151,-2390,9911,825,-7679,-4960,-7224,-2739,-566,-5770,6774,6243,3166,-783,-4303,-9016,5555,-1866,-536,8872,-3927,4269,-3807,1933,9972,981,9256,6857,-208,3645,-3725,5961,1105,6320,-4702,-8419,-4904,-4935,8378,-2994,5831,5296,4730,-9170,-4229,-3911,-160,8757,-5301,-3775,1121,9434,-9880,2689,2340,-7879,3667,-5219,-6116,-1670,7595,6900,3990,4444,6385,-2924,8968,-2673,-6182,7503,5209,6030,802,-3464,1922,-8187,1617,4769,-4866,-3518,5830,3862,-7512,5236,-5164,6324,-5107,6864,-7364,-1375,5762,-275,4975,-7448,5719,-3162,-1546,-2776,-9411,-1845,-4913,-3474,2550,5643,-5527,2946,7158,1938,5125,-8015,2475,-1461,-4900,-5151,-4031,9362,8571,9815,-8438,-6519,1980,-8031,9615,7079,-3573,-883,4217,1079,5918,1767,8670,-5651,-6625,1057,7897,-7104,-4186,851,-6333,-4108,-3250,7899,9628,-6904,-3939,4587,1227,3813,-7449,-7692,-8098,-9813,8862,-2888,-1048,-3564,3074,1437,-2291,3974,3164,4921,-8958,9007,-3938,2042,7454,-910,-998,-4450,-1103,-237,8182,-1391,-4255,-3482,-2918,4053,2280,-7403,4319,-9457,7157,-6315,-7533,6309,2211,-9145,443,4255,-8847,-5557,-9089,1752,-5784,-2399,-8296,-8400,8170,4628,-4583,937,-7067,-3503,-549,-1194,1576,5004,-6963,-8837,5567,870,3954,5489,-8949,-7673,8542,-9040,-7689,-4171,-889,5552,-6836,-4393,513,3177,6664,-5646,2492,9421,-342,2570,8816,2869,-6820,-3389,-1903,-3332,138,6618,293,-9130,3503,-2327,-9728,7632,5881,540,9678,-7629,8804,-2816,7205,7473,-5518,7311,3457,9066,-1224,2097,7857,6612,186,6759,-4516,-3491,-8268,-8928,-7412,7162,6274,5463,2157,-4131,-7061,-8476,-5584,7300,-4348,-5940,-8592,-302,-5817,3151,-4124,1694,-5114,-3252,-2319,-2157,-293,7724,-5673,6105,9535,4333,6353,1290,8710,-5035,8995,-5865,9746,4708,-6387,-8937,3096,-9716,-7124,2531,-660,-4619,-8035,3747,-7821,8793,-727,8242,4957,-7175,4064,-9911,4995,9725,1634,-4275,788,-4920,3831,-3525,-4467,2909,-1200,5377,-4905,-3077,-1763,4443,-3518,3134,-5595,5409,5943,6757,3485,2883,-9261,-7221,654,2001,-926,7840,-5568,2715,-7053,-2082,-2005,7607,-9511,7545,7564,2380,-7257,1449,-3918,-3240,-1928,-6555,-4784,1550,2745,-5316]\\nk=56"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if you use a heap, this question is medium. if you use a monotonic queue, this is easily a hard ... whenever lc suggests heap, it seems like monotonic queue is usually always faster "
                    }
                ]
            },
            {
                "id": 1826645,
                "content": [
                    {
                        "username": "faangboy",
                        "content": "Based on the solutions posted so far, the optimal approach seems the one similar to Sliding Window Maximum. But that question is hard, and for some one like me who has never solved it before, I don\\'t think it was medium for me ;)"
                    },
                    {
                        "username": "lalit10368",
                        "content": "You are right, I spent days trying to solve this problem but couldn't. So, I decided to attempt Sliding Window Maximum  instead. It's also listed in Similar Problems section. That problem looked straightforward compared to this one, although still hard. But the problem statement was pretty clear on using sliding windows. After spending some time I was able to figure out the solution and solved it in my first attempt. No wrong answers, no TLE, not even compilation issue. Most problems I could have solved in my head(both medium & hard levels) may be little bit of paper scribbling but this one(maximum sliding window) literally required a whiteboard and moving those window pointers around.\nMy Solution to the Maximum Window Problem : \nhttps://leetcode.com/problems/sliding-window-maximum/submissions/899998243/\n"
                    },
                    {
                        "username": "h98dubey",
                        "content": "Is it just me or anyone else also thinks that this problem should be under hard catogary, specially if you are looking this problem for the first time ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-vi/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming + Deque\n\n  \n**Approach 2:** Dynamic Programming + Priority Queue\n\n  \n**Approach 3:** Segment Tree\n\n  \n**Approach 4:** Dynamic Programming + Deque (Compressed)\n\n  \n**Approach 5:** Dynamic Programming + Priority Queue (Compressed)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Started from Jump Game I, jumped for 6 days and finally reached Jump Game VI."
                    },
                    {
                        "username": "xingasong",
                        "content": "Just wonder how leetcode decide the difficulty of a question..."
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "they assume u have done its prerequisites"
                    },
                    {
                        "username": "JustinNie",
                        "content": "It has to be hard, since it is hard."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is almost same as Constrained Subsequence Sum,which is hard.This should be hard or the other should be medium."
                    },
                    {
                        "username": "f20201382",
                        "content": "Why does the given code not work?\\n `class Solution {\\npublic:\\n    int n;\\n    int k;\\n    int maxScore(vector<int>& nums, vector<int>& dp, int i){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int score = INT_MIN;\\n        for(int j=1;j<=k;j++){\\n            score = max(score, nums[i]+maxScore(nums,dp,i+j));\\n        }\\n\\n        return dp[i] = score;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        this->k = k;\\n        vector<int> dp(n,-1);\\n        return maxScore(nums,dp,0);\\n    }\\n};.`\\n"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "yeah same doubt did u find the error ?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why the logic of picking the max in the next window , throws error. Like for k=2, if I pick i=2 as maximum then search through range [i + 1, min(n - 1, i + k)] i.e [3,5] and pick the max value in that range. If 5 contains the max value then start the next iteration [5,7] from the index =5. I wrote the code and it failed for this test case\\n\\n[-5582,-5317,6711,-639,1001,1845,1728,-4575,-6066,-7770,128,-3254,7281,3966,6857,5477,8968,-1771,9986,-6267,9010,-764,8413,-8154,1087,-1107,4183,3033,58,659,4625,2825,5031,6811,5657,3229,8597,-5772,8869,5723,2960,4040,7222,4841,-1014,581,-2830,3881,-3800,577,-7396,-611,-6944,8461,3294,6297,9713,-2246,-3441,3831,-5754,6716,6040,-6715,5763,8611,5412,-7630,6216,260,2595,6852,-8956,2101,6722,1579,3820,7827,-3369,7144,1974,7310,-5369,-6755,3010,5789,1563,-3330,5373,-2770,4503,-4065,8177,-3333,-4726,-2131,2763,9012,-4755,2382,3642,-5284,-7174,-9815,6392,9729,-1943,-8749,5343,1036,8508,1484,919,4225,3733,8036,-6346,-2088,475,9378,4271,-5906,9327,9399,-1582,3845,3499,-8912,-4671,-1143,-5081,-1621,-1287,5995,4963,5071,5118,-1966,-6249,663,-2296,-8148,-4668,-6919,334,-6609,2888,-4161,118,-1867,5629,8588,-5325,-7853,-4868,-1487,-6544,-9697,-7038,6422,-5545,3376,-8656,8800,-7698,-2928,2279,-9739,4198,6236,-9087,9010,-9894,2145,7353,-92,3205,5431,5913,1619,-250,4728,-7164,-5619,-4721,-9284,-9645,146,7131,-6501,4261,2016,2880,4944,-8768,-6339,-3574,539,4633,9188,7227,-1549,9271,7110,5706,4968,-1275,5545,-5844,-1985,9560,1560,4630,3169,6076,-9433,7007,9927,-8385,-4557,-114,9543,2884,8978,-6447,3664,-7499,-4643,-5993,-5321,3250,-2945,6216,-1606,5569,7326,-6027,9723,-6997,-543,-8298,-4647,2563,1493,9574,1087,-9433,-7749,-7159,-2682,6626,2787,-2845,-7907,-223,-8142,-5403,-3460,-2534,5289,999,9404,-1958,641,4669,-2892,-2921,-7001,-1403,-2353,-7976,-5885,4958,-8117,8785,-654,5918,5533,8704,5827,-7478,-3696,2640,1612,-500,5694,-1973,5308,5272,3358,9190,4648,-7836,658,-3407,6733,1061,-2010,-2707,-1920,1272,3944,-6537,-6090,-7429,-640,836,1904,-4031,814,-1886,8040,-8312,-9407,-1395,-9944,-2074,-6814,2672,1360,8990,5465,-2131,3838,799,-3472,1086,-583,6302,3032,9138,-7778,4538,-5337,2087,2870,-3005,3401,122,-819,-8074,9630,-698,5326,2650,-9355,6487,3801,-3209,8293,662,-8318,-7863,-3814,-2557,-5685,-7952,6224,-7010,2935,5557,-1287,9528,-9218,-5108,-2085,17,4870,-8686,-8854,-9657,8848,-1883,-4535,83,9711,4593,-3440,-6938,3407,-6894,-6213,-883,4552,-731,1485,-7740,-3300,3897,-7629,-4076,7589,3142,-1010,2466,-592,-391,3961,-7049,7654,5758,6983,6048,-4369,-5878,3756,2940,9149,8625,8937,5706,6658,9213,-5226,284,-4524,-1577,-5296,6423,9977,-1805,5462,7587,476,-6424,976,-3925,8819,1821,3603,-842,-9618,-7130,-6253,2562,-7596,3522,6282,-3801,-3896,6924,441,5944,8535,1253,-6154,6872,-9548,-5358,1604,9593,-9256,-701,1023,-1446,-1307,-6809,9542,3673,1813,8717,-6847,-5289,5222,-7266,4231,218,-9633,-4696,5494,9681,1173,-4606,2174,-1155,-8595,-3640,-6550,-7003,4244,-2543,5241,2831,2690,8950,-6609,-9724,7562,-4096,8878,9962,7179,-1170,7826,-146,-2759,-5249,253,6206,3205,-7708,9448,4622,9260,-2853,2486,122,-8880,-769,-8922,648,7358,-6503,-6382,-4260,3988,-5107,-6363,2415,8563,-9070,-5026,2078,-2558,-2027,-7489,-4978,5024,4155,-9737,-221,9930,-9472,1052,-268,6221,2726,-1310,-8708,3482,-5488,-6506,5389,-7048,553,-886,2752,85,-3938,5940,-5112,5855,-7295,3735,2657,3269,6231,4771,3229,-2009,-5748,7256,746,-4301,752,-241,-6151,-2390,9911,825,-7679,-4960,-7224,-2739,-566,-5770,6774,6243,3166,-783,-4303,-9016,5555,-1866,-536,8872,-3927,4269,-3807,1933,9972,981,9256,6857,-208,3645,-3725,5961,1105,6320,-4702,-8419,-4904,-4935,8378,-2994,5831,5296,4730,-9170,-4229,-3911,-160,8757,-5301,-3775,1121,9434,-9880,2689,2340,-7879,3667,-5219,-6116,-1670,7595,6900,3990,4444,6385,-2924,8968,-2673,-6182,7503,5209,6030,802,-3464,1922,-8187,1617,4769,-4866,-3518,5830,3862,-7512,5236,-5164,6324,-5107,6864,-7364,-1375,5762,-275,4975,-7448,5719,-3162,-1546,-2776,-9411,-1845,-4913,-3474,2550,5643,-5527,2946,7158,1938,5125,-8015,2475,-1461,-4900,-5151,-4031,9362,8571,9815,-8438,-6519,1980,-8031,9615,7079,-3573,-883,4217,1079,5918,1767,8670,-5651,-6625,1057,7897,-7104,-4186,851,-6333,-4108,-3250,7899,9628,-6904,-3939,4587,1227,3813,-7449,-7692,-8098,-9813,8862,-2888,-1048,-3564,3074,1437,-2291,3974,3164,4921,-8958,9007,-3938,2042,7454,-910,-998,-4450,-1103,-237,8182,-1391,-4255,-3482,-2918,4053,2280,-7403,4319,-9457,7157,-6315,-7533,6309,2211,-9145,443,4255,-8847,-5557,-9089,1752,-5784,-2399,-8296,-8400,8170,4628,-4583,937,-7067,-3503,-549,-1194,1576,5004,-6963,-8837,5567,870,3954,5489,-8949,-7673,8542,-9040,-7689,-4171,-889,5552,-6836,-4393,513,3177,6664,-5646,2492,9421,-342,2570,8816,2869,-6820,-3389,-1903,-3332,138,6618,293,-9130,3503,-2327,-9728,7632,5881,540,9678,-7629,8804,-2816,7205,7473,-5518,7311,3457,9066,-1224,2097,7857,6612,186,6759,-4516,-3491,-8268,-8928,-7412,7162,6274,5463,2157,-4131,-7061,-8476,-5584,7300,-4348,-5940,-8592,-302,-5817,3151,-4124,1694,-5114,-3252,-2319,-2157,-293,7724,-5673,6105,9535,4333,6353,1290,8710,-5035,8995,-5865,9746,4708,-6387,-8937,3096,-9716,-7124,2531,-660,-4619,-8035,3747,-7821,8793,-727,8242,4957,-7175,4064,-9911,4995,9725,1634,-4275,788,-4920,3831,-3525,-4467,2909,-1200,5377,-4905,-3077,-1763,4443,-3518,3134,-5595,5409,5943,6757,3485,2883,-9261,-7221,654,2001,-926,7840,-5568,2715,-7053,-2082,-2005,7607,-9511,7545,7564,2380,-7257,1449,-3918,-3240,-1928,-6555,-4784,1550,2745,-5316]\\nk=56"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if you use a heap, this question is medium. if you use a monotonic queue, this is easily a hard ... whenever lc suggests heap, it seems like monotonic queue is usually always faster "
                    }
                ]
            },
            {
                "id": 1565304,
                "content": [
                    {
                        "username": "faangboy",
                        "content": "Based on the solutions posted so far, the optimal approach seems the one similar to Sliding Window Maximum. But that question is hard, and for some one like me who has never solved it before, I don\\'t think it was medium for me ;)"
                    },
                    {
                        "username": "lalit10368",
                        "content": "You are right, I spent days trying to solve this problem but couldn't. So, I decided to attempt Sliding Window Maximum  instead. It's also listed in Similar Problems section. That problem looked straightforward compared to this one, although still hard. But the problem statement was pretty clear on using sliding windows. After spending some time I was able to figure out the solution and solved it in my first attempt. No wrong answers, no TLE, not even compilation issue. Most problems I could have solved in my head(both medium & hard levels) may be little bit of paper scribbling but this one(maximum sliding window) literally required a whiteboard and moving those window pointers around.\nMy Solution to the Maximum Window Problem : \nhttps://leetcode.com/problems/sliding-window-maximum/submissions/899998243/\n"
                    },
                    {
                        "username": "h98dubey",
                        "content": "Is it just me or anyone else also thinks that this problem should be under hard catogary, specially if you are looking this problem for the first time ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-vi/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming + Deque\n\n  \n**Approach 2:** Dynamic Programming + Priority Queue\n\n  \n**Approach 3:** Segment Tree\n\n  \n**Approach 4:** Dynamic Programming + Deque (Compressed)\n\n  \n**Approach 5:** Dynamic Programming + Priority Queue (Compressed)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Started from Jump Game I, jumped for 6 days and finally reached Jump Game VI."
                    },
                    {
                        "username": "xingasong",
                        "content": "Just wonder how leetcode decide the difficulty of a question..."
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "they assume u have done its prerequisites"
                    },
                    {
                        "username": "JustinNie",
                        "content": "It has to be hard, since it is hard."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is almost same as Constrained Subsequence Sum,which is hard.This should be hard or the other should be medium."
                    },
                    {
                        "username": "f20201382",
                        "content": "Why does the given code not work?\\n `class Solution {\\npublic:\\n    int n;\\n    int k;\\n    int maxScore(vector<int>& nums, vector<int>& dp, int i){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int score = INT_MIN;\\n        for(int j=1;j<=k;j++){\\n            score = max(score, nums[i]+maxScore(nums,dp,i+j));\\n        }\\n\\n        return dp[i] = score;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        this->k = k;\\n        vector<int> dp(n,-1);\\n        return maxScore(nums,dp,0);\\n    }\\n};.`\\n"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "yeah same doubt did u find the error ?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why the logic of picking the max in the next window , throws error. Like for k=2, if I pick i=2 as maximum then search through range [i + 1, min(n - 1, i + k)] i.e [3,5] and pick the max value in that range. If 5 contains the max value then start the next iteration [5,7] from the index =5. I wrote the code and it failed for this test case\\n\\n[-5582,-5317,6711,-639,1001,1845,1728,-4575,-6066,-7770,128,-3254,7281,3966,6857,5477,8968,-1771,9986,-6267,9010,-764,8413,-8154,1087,-1107,4183,3033,58,659,4625,2825,5031,6811,5657,3229,8597,-5772,8869,5723,2960,4040,7222,4841,-1014,581,-2830,3881,-3800,577,-7396,-611,-6944,8461,3294,6297,9713,-2246,-3441,3831,-5754,6716,6040,-6715,5763,8611,5412,-7630,6216,260,2595,6852,-8956,2101,6722,1579,3820,7827,-3369,7144,1974,7310,-5369,-6755,3010,5789,1563,-3330,5373,-2770,4503,-4065,8177,-3333,-4726,-2131,2763,9012,-4755,2382,3642,-5284,-7174,-9815,6392,9729,-1943,-8749,5343,1036,8508,1484,919,4225,3733,8036,-6346,-2088,475,9378,4271,-5906,9327,9399,-1582,3845,3499,-8912,-4671,-1143,-5081,-1621,-1287,5995,4963,5071,5118,-1966,-6249,663,-2296,-8148,-4668,-6919,334,-6609,2888,-4161,118,-1867,5629,8588,-5325,-7853,-4868,-1487,-6544,-9697,-7038,6422,-5545,3376,-8656,8800,-7698,-2928,2279,-9739,4198,6236,-9087,9010,-9894,2145,7353,-92,3205,5431,5913,1619,-250,4728,-7164,-5619,-4721,-9284,-9645,146,7131,-6501,4261,2016,2880,4944,-8768,-6339,-3574,539,4633,9188,7227,-1549,9271,7110,5706,4968,-1275,5545,-5844,-1985,9560,1560,4630,3169,6076,-9433,7007,9927,-8385,-4557,-114,9543,2884,8978,-6447,3664,-7499,-4643,-5993,-5321,3250,-2945,6216,-1606,5569,7326,-6027,9723,-6997,-543,-8298,-4647,2563,1493,9574,1087,-9433,-7749,-7159,-2682,6626,2787,-2845,-7907,-223,-8142,-5403,-3460,-2534,5289,999,9404,-1958,641,4669,-2892,-2921,-7001,-1403,-2353,-7976,-5885,4958,-8117,8785,-654,5918,5533,8704,5827,-7478,-3696,2640,1612,-500,5694,-1973,5308,5272,3358,9190,4648,-7836,658,-3407,6733,1061,-2010,-2707,-1920,1272,3944,-6537,-6090,-7429,-640,836,1904,-4031,814,-1886,8040,-8312,-9407,-1395,-9944,-2074,-6814,2672,1360,8990,5465,-2131,3838,799,-3472,1086,-583,6302,3032,9138,-7778,4538,-5337,2087,2870,-3005,3401,122,-819,-8074,9630,-698,5326,2650,-9355,6487,3801,-3209,8293,662,-8318,-7863,-3814,-2557,-5685,-7952,6224,-7010,2935,5557,-1287,9528,-9218,-5108,-2085,17,4870,-8686,-8854,-9657,8848,-1883,-4535,83,9711,4593,-3440,-6938,3407,-6894,-6213,-883,4552,-731,1485,-7740,-3300,3897,-7629,-4076,7589,3142,-1010,2466,-592,-391,3961,-7049,7654,5758,6983,6048,-4369,-5878,3756,2940,9149,8625,8937,5706,6658,9213,-5226,284,-4524,-1577,-5296,6423,9977,-1805,5462,7587,476,-6424,976,-3925,8819,1821,3603,-842,-9618,-7130,-6253,2562,-7596,3522,6282,-3801,-3896,6924,441,5944,8535,1253,-6154,6872,-9548,-5358,1604,9593,-9256,-701,1023,-1446,-1307,-6809,9542,3673,1813,8717,-6847,-5289,5222,-7266,4231,218,-9633,-4696,5494,9681,1173,-4606,2174,-1155,-8595,-3640,-6550,-7003,4244,-2543,5241,2831,2690,8950,-6609,-9724,7562,-4096,8878,9962,7179,-1170,7826,-146,-2759,-5249,253,6206,3205,-7708,9448,4622,9260,-2853,2486,122,-8880,-769,-8922,648,7358,-6503,-6382,-4260,3988,-5107,-6363,2415,8563,-9070,-5026,2078,-2558,-2027,-7489,-4978,5024,4155,-9737,-221,9930,-9472,1052,-268,6221,2726,-1310,-8708,3482,-5488,-6506,5389,-7048,553,-886,2752,85,-3938,5940,-5112,5855,-7295,3735,2657,3269,6231,4771,3229,-2009,-5748,7256,746,-4301,752,-241,-6151,-2390,9911,825,-7679,-4960,-7224,-2739,-566,-5770,6774,6243,3166,-783,-4303,-9016,5555,-1866,-536,8872,-3927,4269,-3807,1933,9972,981,9256,6857,-208,3645,-3725,5961,1105,6320,-4702,-8419,-4904,-4935,8378,-2994,5831,5296,4730,-9170,-4229,-3911,-160,8757,-5301,-3775,1121,9434,-9880,2689,2340,-7879,3667,-5219,-6116,-1670,7595,6900,3990,4444,6385,-2924,8968,-2673,-6182,7503,5209,6030,802,-3464,1922,-8187,1617,4769,-4866,-3518,5830,3862,-7512,5236,-5164,6324,-5107,6864,-7364,-1375,5762,-275,4975,-7448,5719,-3162,-1546,-2776,-9411,-1845,-4913,-3474,2550,5643,-5527,2946,7158,1938,5125,-8015,2475,-1461,-4900,-5151,-4031,9362,8571,9815,-8438,-6519,1980,-8031,9615,7079,-3573,-883,4217,1079,5918,1767,8670,-5651,-6625,1057,7897,-7104,-4186,851,-6333,-4108,-3250,7899,9628,-6904,-3939,4587,1227,3813,-7449,-7692,-8098,-9813,8862,-2888,-1048,-3564,3074,1437,-2291,3974,3164,4921,-8958,9007,-3938,2042,7454,-910,-998,-4450,-1103,-237,8182,-1391,-4255,-3482,-2918,4053,2280,-7403,4319,-9457,7157,-6315,-7533,6309,2211,-9145,443,4255,-8847,-5557,-9089,1752,-5784,-2399,-8296,-8400,8170,4628,-4583,937,-7067,-3503,-549,-1194,1576,5004,-6963,-8837,5567,870,3954,5489,-8949,-7673,8542,-9040,-7689,-4171,-889,5552,-6836,-4393,513,3177,6664,-5646,2492,9421,-342,2570,8816,2869,-6820,-3389,-1903,-3332,138,6618,293,-9130,3503,-2327,-9728,7632,5881,540,9678,-7629,8804,-2816,7205,7473,-5518,7311,3457,9066,-1224,2097,7857,6612,186,6759,-4516,-3491,-8268,-8928,-7412,7162,6274,5463,2157,-4131,-7061,-8476,-5584,7300,-4348,-5940,-8592,-302,-5817,3151,-4124,1694,-5114,-3252,-2319,-2157,-293,7724,-5673,6105,9535,4333,6353,1290,8710,-5035,8995,-5865,9746,4708,-6387,-8937,3096,-9716,-7124,2531,-660,-4619,-8035,3747,-7821,8793,-727,8242,4957,-7175,4064,-9911,4995,9725,1634,-4275,788,-4920,3831,-3525,-4467,2909,-1200,5377,-4905,-3077,-1763,4443,-3518,3134,-5595,5409,5943,6757,3485,2883,-9261,-7221,654,2001,-926,7840,-5568,2715,-7053,-2082,-2005,7607,-9511,7545,7564,2380,-7257,1449,-3918,-3240,-1928,-6555,-4784,1550,2745,-5316]\\nk=56"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if you use a heap, this question is medium. if you use a monotonic queue, this is easily a hard ... whenever lc suggests heap, it seems like monotonic queue is usually always faster "
                    }
                ]
            },
            {
                "id": 1570471,
                "content": [
                    {
                        "username": "faangboy",
                        "content": "Based on the solutions posted so far, the optimal approach seems the one similar to Sliding Window Maximum. But that question is hard, and for some one like me who has never solved it before, I don\\'t think it was medium for me ;)"
                    },
                    {
                        "username": "lalit10368",
                        "content": "You are right, I spent days trying to solve this problem but couldn't. So, I decided to attempt Sliding Window Maximum  instead. It's also listed in Similar Problems section. That problem looked straightforward compared to this one, although still hard. But the problem statement was pretty clear on using sliding windows. After spending some time I was able to figure out the solution and solved it in my first attempt. No wrong answers, no TLE, not even compilation issue. Most problems I could have solved in my head(both medium & hard levels) may be little bit of paper scribbling but this one(maximum sliding window) literally required a whiteboard and moving those window pointers around.\nMy Solution to the Maximum Window Problem : \nhttps://leetcode.com/problems/sliding-window-maximum/submissions/899998243/\n"
                    },
                    {
                        "username": "h98dubey",
                        "content": "Is it just me or anyone else also thinks that this problem should be under hard catogary, specially if you are looking this problem for the first time ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-vi/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming + Deque\n\n  \n**Approach 2:** Dynamic Programming + Priority Queue\n\n  \n**Approach 3:** Segment Tree\n\n  \n**Approach 4:** Dynamic Programming + Deque (Compressed)\n\n  \n**Approach 5:** Dynamic Programming + Priority Queue (Compressed)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Started from Jump Game I, jumped for 6 days and finally reached Jump Game VI."
                    },
                    {
                        "username": "xingasong",
                        "content": "Just wonder how leetcode decide the difficulty of a question..."
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "they assume u have done its prerequisites"
                    },
                    {
                        "username": "JustinNie",
                        "content": "It has to be hard, since it is hard."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is almost same as Constrained Subsequence Sum,which is hard.This should be hard or the other should be medium."
                    },
                    {
                        "username": "f20201382",
                        "content": "Why does the given code not work?\\n `class Solution {\\npublic:\\n    int n;\\n    int k;\\n    int maxScore(vector<int>& nums, vector<int>& dp, int i){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int score = INT_MIN;\\n        for(int j=1;j<=k;j++){\\n            score = max(score, nums[i]+maxScore(nums,dp,i+j));\\n        }\\n\\n        return dp[i] = score;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        this->k = k;\\n        vector<int> dp(n,-1);\\n        return maxScore(nums,dp,0);\\n    }\\n};.`\\n"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "yeah same doubt did u find the error ?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why the logic of picking the max in the next window , throws error. Like for k=2, if I pick i=2 as maximum then search through range [i + 1, min(n - 1, i + k)] i.e [3,5] and pick the max value in that range. If 5 contains the max value then start the next iteration [5,7] from the index =5. I wrote the code and it failed for this test case\\n\\n[-5582,-5317,6711,-639,1001,1845,1728,-4575,-6066,-7770,128,-3254,7281,3966,6857,5477,8968,-1771,9986,-6267,9010,-764,8413,-8154,1087,-1107,4183,3033,58,659,4625,2825,5031,6811,5657,3229,8597,-5772,8869,5723,2960,4040,7222,4841,-1014,581,-2830,3881,-3800,577,-7396,-611,-6944,8461,3294,6297,9713,-2246,-3441,3831,-5754,6716,6040,-6715,5763,8611,5412,-7630,6216,260,2595,6852,-8956,2101,6722,1579,3820,7827,-3369,7144,1974,7310,-5369,-6755,3010,5789,1563,-3330,5373,-2770,4503,-4065,8177,-3333,-4726,-2131,2763,9012,-4755,2382,3642,-5284,-7174,-9815,6392,9729,-1943,-8749,5343,1036,8508,1484,919,4225,3733,8036,-6346,-2088,475,9378,4271,-5906,9327,9399,-1582,3845,3499,-8912,-4671,-1143,-5081,-1621,-1287,5995,4963,5071,5118,-1966,-6249,663,-2296,-8148,-4668,-6919,334,-6609,2888,-4161,118,-1867,5629,8588,-5325,-7853,-4868,-1487,-6544,-9697,-7038,6422,-5545,3376,-8656,8800,-7698,-2928,2279,-9739,4198,6236,-9087,9010,-9894,2145,7353,-92,3205,5431,5913,1619,-250,4728,-7164,-5619,-4721,-9284,-9645,146,7131,-6501,4261,2016,2880,4944,-8768,-6339,-3574,539,4633,9188,7227,-1549,9271,7110,5706,4968,-1275,5545,-5844,-1985,9560,1560,4630,3169,6076,-9433,7007,9927,-8385,-4557,-114,9543,2884,8978,-6447,3664,-7499,-4643,-5993,-5321,3250,-2945,6216,-1606,5569,7326,-6027,9723,-6997,-543,-8298,-4647,2563,1493,9574,1087,-9433,-7749,-7159,-2682,6626,2787,-2845,-7907,-223,-8142,-5403,-3460,-2534,5289,999,9404,-1958,641,4669,-2892,-2921,-7001,-1403,-2353,-7976,-5885,4958,-8117,8785,-654,5918,5533,8704,5827,-7478,-3696,2640,1612,-500,5694,-1973,5308,5272,3358,9190,4648,-7836,658,-3407,6733,1061,-2010,-2707,-1920,1272,3944,-6537,-6090,-7429,-640,836,1904,-4031,814,-1886,8040,-8312,-9407,-1395,-9944,-2074,-6814,2672,1360,8990,5465,-2131,3838,799,-3472,1086,-583,6302,3032,9138,-7778,4538,-5337,2087,2870,-3005,3401,122,-819,-8074,9630,-698,5326,2650,-9355,6487,3801,-3209,8293,662,-8318,-7863,-3814,-2557,-5685,-7952,6224,-7010,2935,5557,-1287,9528,-9218,-5108,-2085,17,4870,-8686,-8854,-9657,8848,-1883,-4535,83,9711,4593,-3440,-6938,3407,-6894,-6213,-883,4552,-731,1485,-7740,-3300,3897,-7629,-4076,7589,3142,-1010,2466,-592,-391,3961,-7049,7654,5758,6983,6048,-4369,-5878,3756,2940,9149,8625,8937,5706,6658,9213,-5226,284,-4524,-1577,-5296,6423,9977,-1805,5462,7587,476,-6424,976,-3925,8819,1821,3603,-842,-9618,-7130,-6253,2562,-7596,3522,6282,-3801,-3896,6924,441,5944,8535,1253,-6154,6872,-9548,-5358,1604,9593,-9256,-701,1023,-1446,-1307,-6809,9542,3673,1813,8717,-6847,-5289,5222,-7266,4231,218,-9633,-4696,5494,9681,1173,-4606,2174,-1155,-8595,-3640,-6550,-7003,4244,-2543,5241,2831,2690,8950,-6609,-9724,7562,-4096,8878,9962,7179,-1170,7826,-146,-2759,-5249,253,6206,3205,-7708,9448,4622,9260,-2853,2486,122,-8880,-769,-8922,648,7358,-6503,-6382,-4260,3988,-5107,-6363,2415,8563,-9070,-5026,2078,-2558,-2027,-7489,-4978,5024,4155,-9737,-221,9930,-9472,1052,-268,6221,2726,-1310,-8708,3482,-5488,-6506,5389,-7048,553,-886,2752,85,-3938,5940,-5112,5855,-7295,3735,2657,3269,6231,4771,3229,-2009,-5748,7256,746,-4301,752,-241,-6151,-2390,9911,825,-7679,-4960,-7224,-2739,-566,-5770,6774,6243,3166,-783,-4303,-9016,5555,-1866,-536,8872,-3927,4269,-3807,1933,9972,981,9256,6857,-208,3645,-3725,5961,1105,6320,-4702,-8419,-4904,-4935,8378,-2994,5831,5296,4730,-9170,-4229,-3911,-160,8757,-5301,-3775,1121,9434,-9880,2689,2340,-7879,3667,-5219,-6116,-1670,7595,6900,3990,4444,6385,-2924,8968,-2673,-6182,7503,5209,6030,802,-3464,1922,-8187,1617,4769,-4866,-3518,5830,3862,-7512,5236,-5164,6324,-5107,6864,-7364,-1375,5762,-275,4975,-7448,5719,-3162,-1546,-2776,-9411,-1845,-4913,-3474,2550,5643,-5527,2946,7158,1938,5125,-8015,2475,-1461,-4900,-5151,-4031,9362,8571,9815,-8438,-6519,1980,-8031,9615,7079,-3573,-883,4217,1079,5918,1767,8670,-5651,-6625,1057,7897,-7104,-4186,851,-6333,-4108,-3250,7899,9628,-6904,-3939,4587,1227,3813,-7449,-7692,-8098,-9813,8862,-2888,-1048,-3564,3074,1437,-2291,3974,3164,4921,-8958,9007,-3938,2042,7454,-910,-998,-4450,-1103,-237,8182,-1391,-4255,-3482,-2918,4053,2280,-7403,4319,-9457,7157,-6315,-7533,6309,2211,-9145,443,4255,-8847,-5557,-9089,1752,-5784,-2399,-8296,-8400,8170,4628,-4583,937,-7067,-3503,-549,-1194,1576,5004,-6963,-8837,5567,870,3954,5489,-8949,-7673,8542,-9040,-7689,-4171,-889,5552,-6836,-4393,513,3177,6664,-5646,2492,9421,-342,2570,8816,2869,-6820,-3389,-1903,-3332,138,6618,293,-9130,3503,-2327,-9728,7632,5881,540,9678,-7629,8804,-2816,7205,7473,-5518,7311,3457,9066,-1224,2097,7857,6612,186,6759,-4516,-3491,-8268,-8928,-7412,7162,6274,5463,2157,-4131,-7061,-8476,-5584,7300,-4348,-5940,-8592,-302,-5817,3151,-4124,1694,-5114,-3252,-2319,-2157,-293,7724,-5673,6105,9535,4333,6353,1290,8710,-5035,8995,-5865,9746,4708,-6387,-8937,3096,-9716,-7124,2531,-660,-4619,-8035,3747,-7821,8793,-727,8242,4957,-7175,4064,-9911,4995,9725,1634,-4275,788,-4920,3831,-3525,-4467,2909,-1200,5377,-4905,-3077,-1763,4443,-3518,3134,-5595,5409,5943,6757,3485,2883,-9261,-7221,654,2001,-926,7840,-5568,2715,-7053,-2082,-2005,7607,-9511,7545,7564,2380,-7257,1449,-3918,-3240,-1928,-6555,-4784,1550,2745,-5316]\\nk=56"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if you use a heap, this question is medium. if you use a monotonic queue, this is easily a hard ... whenever lc suggests heap, it seems like monotonic queue is usually always faster "
                    }
                ]
            },
            {
                "id": 1567780,
                "content": [
                    {
                        "username": "faangboy",
                        "content": "Based on the solutions posted so far, the optimal approach seems the one similar to Sliding Window Maximum. But that question is hard, and for some one like me who has never solved it before, I don\\'t think it was medium for me ;)"
                    },
                    {
                        "username": "lalit10368",
                        "content": "You are right, I spent days trying to solve this problem but couldn't. So, I decided to attempt Sliding Window Maximum  instead. It's also listed in Similar Problems section. That problem looked straightforward compared to this one, although still hard. But the problem statement was pretty clear on using sliding windows. After spending some time I was able to figure out the solution and solved it in my first attempt. No wrong answers, no TLE, not even compilation issue. Most problems I could have solved in my head(both medium & hard levels) may be little bit of paper scribbling but this one(maximum sliding window) literally required a whiteboard and moving those window pointers around.\nMy Solution to the Maximum Window Problem : \nhttps://leetcode.com/problems/sliding-window-maximum/submissions/899998243/\n"
                    },
                    {
                        "username": "h98dubey",
                        "content": "Is it just me or anyone else also thinks that this problem should be under hard catogary, specially if you are looking this problem for the first time ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-vi/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming + Deque\n\n  \n**Approach 2:** Dynamic Programming + Priority Queue\n\n  \n**Approach 3:** Segment Tree\n\n  \n**Approach 4:** Dynamic Programming + Deque (Compressed)\n\n  \n**Approach 5:** Dynamic Programming + Priority Queue (Compressed)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Started from Jump Game I, jumped for 6 days and finally reached Jump Game VI."
                    },
                    {
                        "username": "xingasong",
                        "content": "Just wonder how leetcode decide the difficulty of a question..."
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "they assume u have done its prerequisites"
                    },
                    {
                        "username": "JustinNie",
                        "content": "It has to be hard, since it is hard."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is almost same as Constrained Subsequence Sum,which is hard.This should be hard or the other should be medium."
                    },
                    {
                        "username": "f20201382",
                        "content": "Why does the given code not work?\\n `class Solution {\\npublic:\\n    int n;\\n    int k;\\n    int maxScore(vector<int>& nums, vector<int>& dp, int i){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int score = INT_MIN;\\n        for(int j=1;j<=k;j++){\\n            score = max(score, nums[i]+maxScore(nums,dp,i+j));\\n        }\\n\\n        return dp[i] = score;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        this->k = k;\\n        vector<int> dp(n,-1);\\n        return maxScore(nums,dp,0);\\n    }\\n};.`\\n"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "yeah same doubt did u find the error ?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why the logic of picking the max in the next window , throws error. Like for k=2, if I pick i=2 as maximum then search through range [i + 1, min(n - 1, i + k)] i.e [3,5] and pick the max value in that range. If 5 contains the max value then start the next iteration [5,7] from the index =5. I wrote the code and it failed for this test case\\n\\n[-5582,-5317,6711,-639,1001,1845,1728,-4575,-6066,-7770,128,-3254,7281,3966,6857,5477,8968,-1771,9986,-6267,9010,-764,8413,-8154,1087,-1107,4183,3033,58,659,4625,2825,5031,6811,5657,3229,8597,-5772,8869,5723,2960,4040,7222,4841,-1014,581,-2830,3881,-3800,577,-7396,-611,-6944,8461,3294,6297,9713,-2246,-3441,3831,-5754,6716,6040,-6715,5763,8611,5412,-7630,6216,260,2595,6852,-8956,2101,6722,1579,3820,7827,-3369,7144,1974,7310,-5369,-6755,3010,5789,1563,-3330,5373,-2770,4503,-4065,8177,-3333,-4726,-2131,2763,9012,-4755,2382,3642,-5284,-7174,-9815,6392,9729,-1943,-8749,5343,1036,8508,1484,919,4225,3733,8036,-6346,-2088,475,9378,4271,-5906,9327,9399,-1582,3845,3499,-8912,-4671,-1143,-5081,-1621,-1287,5995,4963,5071,5118,-1966,-6249,663,-2296,-8148,-4668,-6919,334,-6609,2888,-4161,118,-1867,5629,8588,-5325,-7853,-4868,-1487,-6544,-9697,-7038,6422,-5545,3376,-8656,8800,-7698,-2928,2279,-9739,4198,6236,-9087,9010,-9894,2145,7353,-92,3205,5431,5913,1619,-250,4728,-7164,-5619,-4721,-9284,-9645,146,7131,-6501,4261,2016,2880,4944,-8768,-6339,-3574,539,4633,9188,7227,-1549,9271,7110,5706,4968,-1275,5545,-5844,-1985,9560,1560,4630,3169,6076,-9433,7007,9927,-8385,-4557,-114,9543,2884,8978,-6447,3664,-7499,-4643,-5993,-5321,3250,-2945,6216,-1606,5569,7326,-6027,9723,-6997,-543,-8298,-4647,2563,1493,9574,1087,-9433,-7749,-7159,-2682,6626,2787,-2845,-7907,-223,-8142,-5403,-3460,-2534,5289,999,9404,-1958,641,4669,-2892,-2921,-7001,-1403,-2353,-7976,-5885,4958,-8117,8785,-654,5918,5533,8704,5827,-7478,-3696,2640,1612,-500,5694,-1973,5308,5272,3358,9190,4648,-7836,658,-3407,6733,1061,-2010,-2707,-1920,1272,3944,-6537,-6090,-7429,-640,836,1904,-4031,814,-1886,8040,-8312,-9407,-1395,-9944,-2074,-6814,2672,1360,8990,5465,-2131,3838,799,-3472,1086,-583,6302,3032,9138,-7778,4538,-5337,2087,2870,-3005,3401,122,-819,-8074,9630,-698,5326,2650,-9355,6487,3801,-3209,8293,662,-8318,-7863,-3814,-2557,-5685,-7952,6224,-7010,2935,5557,-1287,9528,-9218,-5108,-2085,17,4870,-8686,-8854,-9657,8848,-1883,-4535,83,9711,4593,-3440,-6938,3407,-6894,-6213,-883,4552,-731,1485,-7740,-3300,3897,-7629,-4076,7589,3142,-1010,2466,-592,-391,3961,-7049,7654,5758,6983,6048,-4369,-5878,3756,2940,9149,8625,8937,5706,6658,9213,-5226,284,-4524,-1577,-5296,6423,9977,-1805,5462,7587,476,-6424,976,-3925,8819,1821,3603,-842,-9618,-7130,-6253,2562,-7596,3522,6282,-3801,-3896,6924,441,5944,8535,1253,-6154,6872,-9548,-5358,1604,9593,-9256,-701,1023,-1446,-1307,-6809,9542,3673,1813,8717,-6847,-5289,5222,-7266,4231,218,-9633,-4696,5494,9681,1173,-4606,2174,-1155,-8595,-3640,-6550,-7003,4244,-2543,5241,2831,2690,8950,-6609,-9724,7562,-4096,8878,9962,7179,-1170,7826,-146,-2759,-5249,253,6206,3205,-7708,9448,4622,9260,-2853,2486,122,-8880,-769,-8922,648,7358,-6503,-6382,-4260,3988,-5107,-6363,2415,8563,-9070,-5026,2078,-2558,-2027,-7489,-4978,5024,4155,-9737,-221,9930,-9472,1052,-268,6221,2726,-1310,-8708,3482,-5488,-6506,5389,-7048,553,-886,2752,85,-3938,5940,-5112,5855,-7295,3735,2657,3269,6231,4771,3229,-2009,-5748,7256,746,-4301,752,-241,-6151,-2390,9911,825,-7679,-4960,-7224,-2739,-566,-5770,6774,6243,3166,-783,-4303,-9016,5555,-1866,-536,8872,-3927,4269,-3807,1933,9972,981,9256,6857,-208,3645,-3725,5961,1105,6320,-4702,-8419,-4904,-4935,8378,-2994,5831,5296,4730,-9170,-4229,-3911,-160,8757,-5301,-3775,1121,9434,-9880,2689,2340,-7879,3667,-5219,-6116,-1670,7595,6900,3990,4444,6385,-2924,8968,-2673,-6182,7503,5209,6030,802,-3464,1922,-8187,1617,4769,-4866,-3518,5830,3862,-7512,5236,-5164,6324,-5107,6864,-7364,-1375,5762,-275,4975,-7448,5719,-3162,-1546,-2776,-9411,-1845,-4913,-3474,2550,5643,-5527,2946,7158,1938,5125,-8015,2475,-1461,-4900,-5151,-4031,9362,8571,9815,-8438,-6519,1980,-8031,9615,7079,-3573,-883,4217,1079,5918,1767,8670,-5651,-6625,1057,7897,-7104,-4186,851,-6333,-4108,-3250,7899,9628,-6904,-3939,4587,1227,3813,-7449,-7692,-8098,-9813,8862,-2888,-1048,-3564,3074,1437,-2291,3974,3164,4921,-8958,9007,-3938,2042,7454,-910,-998,-4450,-1103,-237,8182,-1391,-4255,-3482,-2918,4053,2280,-7403,4319,-9457,7157,-6315,-7533,6309,2211,-9145,443,4255,-8847,-5557,-9089,1752,-5784,-2399,-8296,-8400,8170,4628,-4583,937,-7067,-3503,-549,-1194,1576,5004,-6963,-8837,5567,870,3954,5489,-8949,-7673,8542,-9040,-7689,-4171,-889,5552,-6836,-4393,513,3177,6664,-5646,2492,9421,-342,2570,8816,2869,-6820,-3389,-1903,-3332,138,6618,293,-9130,3503,-2327,-9728,7632,5881,540,9678,-7629,8804,-2816,7205,7473,-5518,7311,3457,9066,-1224,2097,7857,6612,186,6759,-4516,-3491,-8268,-8928,-7412,7162,6274,5463,2157,-4131,-7061,-8476,-5584,7300,-4348,-5940,-8592,-302,-5817,3151,-4124,1694,-5114,-3252,-2319,-2157,-293,7724,-5673,6105,9535,4333,6353,1290,8710,-5035,8995,-5865,9746,4708,-6387,-8937,3096,-9716,-7124,2531,-660,-4619,-8035,3747,-7821,8793,-727,8242,4957,-7175,4064,-9911,4995,9725,1634,-4275,788,-4920,3831,-3525,-4467,2909,-1200,5377,-4905,-3077,-1763,4443,-3518,3134,-5595,5409,5943,6757,3485,2883,-9261,-7221,654,2001,-926,7840,-5568,2715,-7053,-2082,-2005,7607,-9511,7545,7564,2380,-7257,1449,-3918,-3240,-1928,-6555,-4784,1550,2745,-5316]\\nk=56"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if you use a heap, this question is medium. if you use a monotonic queue, this is easily a hard ... whenever lc suggests heap, it seems like monotonic queue is usually always faster "
                    }
                ]
            },
            {
                "id": 1978808,
                "content": [
                    {
                        "username": "faangboy",
                        "content": "Based on the solutions posted so far, the optimal approach seems the one similar to Sliding Window Maximum. But that question is hard, and for some one like me who has never solved it before, I don\\'t think it was medium for me ;)"
                    },
                    {
                        "username": "lalit10368",
                        "content": "You are right, I spent days trying to solve this problem but couldn't. So, I decided to attempt Sliding Window Maximum  instead. It's also listed in Similar Problems section. That problem looked straightforward compared to this one, although still hard. But the problem statement was pretty clear on using sliding windows. After spending some time I was able to figure out the solution and solved it in my first attempt. No wrong answers, no TLE, not even compilation issue. Most problems I could have solved in my head(both medium & hard levels) may be little bit of paper scribbling but this one(maximum sliding window) literally required a whiteboard and moving those window pointers around.\nMy Solution to the Maximum Window Problem : \nhttps://leetcode.com/problems/sliding-window-maximum/submissions/899998243/\n"
                    },
                    {
                        "username": "h98dubey",
                        "content": "Is it just me or anyone else also thinks that this problem should be under hard catogary, specially if you are looking this problem for the first time ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-vi/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming + Deque\n\n  \n**Approach 2:** Dynamic Programming + Priority Queue\n\n  \n**Approach 3:** Segment Tree\n\n  \n**Approach 4:** Dynamic Programming + Deque (Compressed)\n\n  \n**Approach 5:** Dynamic Programming + Priority Queue (Compressed)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Started from Jump Game I, jumped for 6 days and finally reached Jump Game VI."
                    },
                    {
                        "username": "xingasong",
                        "content": "Just wonder how leetcode decide the difficulty of a question..."
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "they assume u have done its prerequisites"
                    },
                    {
                        "username": "JustinNie",
                        "content": "It has to be hard, since it is hard."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is almost same as Constrained Subsequence Sum,which is hard.This should be hard or the other should be medium."
                    },
                    {
                        "username": "f20201382",
                        "content": "Why does the given code not work?\\n `class Solution {\\npublic:\\n    int n;\\n    int k;\\n    int maxScore(vector<int>& nums, vector<int>& dp, int i){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int score = INT_MIN;\\n        for(int j=1;j<=k;j++){\\n            score = max(score, nums[i]+maxScore(nums,dp,i+j));\\n        }\\n\\n        return dp[i] = score;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        this->k = k;\\n        vector<int> dp(n,-1);\\n        return maxScore(nums,dp,0);\\n    }\\n};.`\\n"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "yeah same doubt did u find the error ?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why the logic of picking the max in the next window , throws error. Like for k=2, if I pick i=2 as maximum then search through range [i + 1, min(n - 1, i + k)] i.e [3,5] and pick the max value in that range. If 5 contains the max value then start the next iteration [5,7] from the index =5. I wrote the code and it failed for this test case\\n\\n[-5582,-5317,6711,-639,1001,1845,1728,-4575,-6066,-7770,128,-3254,7281,3966,6857,5477,8968,-1771,9986,-6267,9010,-764,8413,-8154,1087,-1107,4183,3033,58,659,4625,2825,5031,6811,5657,3229,8597,-5772,8869,5723,2960,4040,7222,4841,-1014,581,-2830,3881,-3800,577,-7396,-611,-6944,8461,3294,6297,9713,-2246,-3441,3831,-5754,6716,6040,-6715,5763,8611,5412,-7630,6216,260,2595,6852,-8956,2101,6722,1579,3820,7827,-3369,7144,1974,7310,-5369,-6755,3010,5789,1563,-3330,5373,-2770,4503,-4065,8177,-3333,-4726,-2131,2763,9012,-4755,2382,3642,-5284,-7174,-9815,6392,9729,-1943,-8749,5343,1036,8508,1484,919,4225,3733,8036,-6346,-2088,475,9378,4271,-5906,9327,9399,-1582,3845,3499,-8912,-4671,-1143,-5081,-1621,-1287,5995,4963,5071,5118,-1966,-6249,663,-2296,-8148,-4668,-6919,334,-6609,2888,-4161,118,-1867,5629,8588,-5325,-7853,-4868,-1487,-6544,-9697,-7038,6422,-5545,3376,-8656,8800,-7698,-2928,2279,-9739,4198,6236,-9087,9010,-9894,2145,7353,-92,3205,5431,5913,1619,-250,4728,-7164,-5619,-4721,-9284,-9645,146,7131,-6501,4261,2016,2880,4944,-8768,-6339,-3574,539,4633,9188,7227,-1549,9271,7110,5706,4968,-1275,5545,-5844,-1985,9560,1560,4630,3169,6076,-9433,7007,9927,-8385,-4557,-114,9543,2884,8978,-6447,3664,-7499,-4643,-5993,-5321,3250,-2945,6216,-1606,5569,7326,-6027,9723,-6997,-543,-8298,-4647,2563,1493,9574,1087,-9433,-7749,-7159,-2682,6626,2787,-2845,-7907,-223,-8142,-5403,-3460,-2534,5289,999,9404,-1958,641,4669,-2892,-2921,-7001,-1403,-2353,-7976,-5885,4958,-8117,8785,-654,5918,5533,8704,5827,-7478,-3696,2640,1612,-500,5694,-1973,5308,5272,3358,9190,4648,-7836,658,-3407,6733,1061,-2010,-2707,-1920,1272,3944,-6537,-6090,-7429,-640,836,1904,-4031,814,-1886,8040,-8312,-9407,-1395,-9944,-2074,-6814,2672,1360,8990,5465,-2131,3838,799,-3472,1086,-583,6302,3032,9138,-7778,4538,-5337,2087,2870,-3005,3401,122,-819,-8074,9630,-698,5326,2650,-9355,6487,3801,-3209,8293,662,-8318,-7863,-3814,-2557,-5685,-7952,6224,-7010,2935,5557,-1287,9528,-9218,-5108,-2085,17,4870,-8686,-8854,-9657,8848,-1883,-4535,83,9711,4593,-3440,-6938,3407,-6894,-6213,-883,4552,-731,1485,-7740,-3300,3897,-7629,-4076,7589,3142,-1010,2466,-592,-391,3961,-7049,7654,5758,6983,6048,-4369,-5878,3756,2940,9149,8625,8937,5706,6658,9213,-5226,284,-4524,-1577,-5296,6423,9977,-1805,5462,7587,476,-6424,976,-3925,8819,1821,3603,-842,-9618,-7130,-6253,2562,-7596,3522,6282,-3801,-3896,6924,441,5944,8535,1253,-6154,6872,-9548,-5358,1604,9593,-9256,-701,1023,-1446,-1307,-6809,9542,3673,1813,8717,-6847,-5289,5222,-7266,4231,218,-9633,-4696,5494,9681,1173,-4606,2174,-1155,-8595,-3640,-6550,-7003,4244,-2543,5241,2831,2690,8950,-6609,-9724,7562,-4096,8878,9962,7179,-1170,7826,-146,-2759,-5249,253,6206,3205,-7708,9448,4622,9260,-2853,2486,122,-8880,-769,-8922,648,7358,-6503,-6382,-4260,3988,-5107,-6363,2415,8563,-9070,-5026,2078,-2558,-2027,-7489,-4978,5024,4155,-9737,-221,9930,-9472,1052,-268,6221,2726,-1310,-8708,3482,-5488,-6506,5389,-7048,553,-886,2752,85,-3938,5940,-5112,5855,-7295,3735,2657,3269,6231,4771,3229,-2009,-5748,7256,746,-4301,752,-241,-6151,-2390,9911,825,-7679,-4960,-7224,-2739,-566,-5770,6774,6243,3166,-783,-4303,-9016,5555,-1866,-536,8872,-3927,4269,-3807,1933,9972,981,9256,6857,-208,3645,-3725,5961,1105,6320,-4702,-8419,-4904,-4935,8378,-2994,5831,5296,4730,-9170,-4229,-3911,-160,8757,-5301,-3775,1121,9434,-9880,2689,2340,-7879,3667,-5219,-6116,-1670,7595,6900,3990,4444,6385,-2924,8968,-2673,-6182,7503,5209,6030,802,-3464,1922,-8187,1617,4769,-4866,-3518,5830,3862,-7512,5236,-5164,6324,-5107,6864,-7364,-1375,5762,-275,4975,-7448,5719,-3162,-1546,-2776,-9411,-1845,-4913,-3474,2550,5643,-5527,2946,7158,1938,5125,-8015,2475,-1461,-4900,-5151,-4031,9362,8571,9815,-8438,-6519,1980,-8031,9615,7079,-3573,-883,4217,1079,5918,1767,8670,-5651,-6625,1057,7897,-7104,-4186,851,-6333,-4108,-3250,7899,9628,-6904,-3939,4587,1227,3813,-7449,-7692,-8098,-9813,8862,-2888,-1048,-3564,3074,1437,-2291,3974,3164,4921,-8958,9007,-3938,2042,7454,-910,-998,-4450,-1103,-237,8182,-1391,-4255,-3482,-2918,4053,2280,-7403,4319,-9457,7157,-6315,-7533,6309,2211,-9145,443,4255,-8847,-5557,-9089,1752,-5784,-2399,-8296,-8400,8170,4628,-4583,937,-7067,-3503,-549,-1194,1576,5004,-6963,-8837,5567,870,3954,5489,-8949,-7673,8542,-9040,-7689,-4171,-889,5552,-6836,-4393,513,3177,6664,-5646,2492,9421,-342,2570,8816,2869,-6820,-3389,-1903,-3332,138,6618,293,-9130,3503,-2327,-9728,7632,5881,540,9678,-7629,8804,-2816,7205,7473,-5518,7311,3457,9066,-1224,2097,7857,6612,186,6759,-4516,-3491,-8268,-8928,-7412,7162,6274,5463,2157,-4131,-7061,-8476,-5584,7300,-4348,-5940,-8592,-302,-5817,3151,-4124,1694,-5114,-3252,-2319,-2157,-293,7724,-5673,6105,9535,4333,6353,1290,8710,-5035,8995,-5865,9746,4708,-6387,-8937,3096,-9716,-7124,2531,-660,-4619,-8035,3747,-7821,8793,-727,8242,4957,-7175,4064,-9911,4995,9725,1634,-4275,788,-4920,3831,-3525,-4467,2909,-1200,5377,-4905,-3077,-1763,4443,-3518,3134,-5595,5409,5943,6757,3485,2883,-9261,-7221,654,2001,-926,7840,-5568,2715,-7053,-2082,-2005,7607,-9511,7545,7564,2380,-7257,1449,-3918,-3240,-1928,-6555,-4784,1550,2745,-5316]\\nk=56"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if you use a heap, this question is medium. if you use a monotonic queue, this is easily a hard ... whenever lc suggests heap, it seems like monotonic queue is usually always faster "
                    }
                ]
            },
            {
                "id": 1576050,
                "content": [
                    {
                        "username": "faangboy",
                        "content": "Based on the solutions posted so far, the optimal approach seems the one similar to Sliding Window Maximum. But that question is hard, and for some one like me who has never solved it before, I don\\'t think it was medium for me ;)"
                    },
                    {
                        "username": "lalit10368",
                        "content": "You are right, I spent days trying to solve this problem but couldn't. So, I decided to attempt Sliding Window Maximum  instead. It's also listed in Similar Problems section. That problem looked straightforward compared to this one, although still hard. But the problem statement was pretty clear on using sliding windows. After spending some time I was able to figure out the solution and solved it in my first attempt. No wrong answers, no TLE, not even compilation issue. Most problems I could have solved in my head(both medium & hard levels) may be little bit of paper scribbling but this one(maximum sliding window) literally required a whiteboard and moving those window pointers around.\nMy Solution to the Maximum Window Problem : \nhttps://leetcode.com/problems/sliding-window-maximum/submissions/899998243/\n"
                    },
                    {
                        "username": "h98dubey",
                        "content": "Is it just me or anyone else also thinks that this problem should be under hard catogary, specially if you are looking this problem for the first time ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-vi/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming + Deque\n\n  \n**Approach 2:** Dynamic Programming + Priority Queue\n\n  \n**Approach 3:** Segment Tree\n\n  \n**Approach 4:** Dynamic Programming + Deque (Compressed)\n\n  \n**Approach 5:** Dynamic Programming + Priority Queue (Compressed)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Started from Jump Game I, jumped for 6 days and finally reached Jump Game VI."
                    },
                    {
                        "username": "xingasong",
                        "content": "Just wonder how leetcode decide the difficulty of a question..."
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "they assume u have done its prerequisites"
                    },
                    {
                        "username": "JustinNie",
                        "content": "It has to be hard, since it is hard."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is almost same as Constrained Subsequence Sum,which is hard.This should be hard or the other should be medium."
                    },
                    {
                        "username": "f20201382",
                        "content": "Why does the given code not work?\\n `class Solution {\\npublic:\\n    int n;\\n    int k;\\n    int maxScore(vector<int>& nums, vector<int>& dp, int i){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int score = INT_MIN;\\n        for(int j=1;j<=k;j++){\\n            score = max(score, nums[i]+maxScore(nums,dp,i+j));\\n        }\\n\\n        return dp[i] = score;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        this->k = k;\\n        vector<int> dp(n,-1);\\n        return maxScore(nums,dp,0);\\n    }\\n};.`\\n"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "yeah same doubt did u find the error ?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why the logic of picking the max in the next window , throws error. Like for k=2, if I pick i=2 as maximum then search through range [i + 1, min(n - 1, i + k)] i.e [3,5] and pick the max value in that range. If 5 contains the max value then start the next iteration [5,7] from the index =5. I wrote the code and it failed for this test case\\n\\n[-5582,-5317,6711,-639,1001,1845,1728,-4575,-6066,-7770,128,-3254,7281,3966,6857,5477,8968,-1771,9986,-6267,9010,-764,8413,-8154,1087,-1107,4183,3033,58,659,4625,2825,5031,6811,5657,3229,8597,-5772,8869,5723,2960,4040,7222,4841,-1014,581,-2830,3881,-3800,577,-7396,-611,-6944,8461,3294,6297,9713,-2246,-3441,3831,-5754,6716,6040,-6715,5763,8611,5412,-7630,6216,260,2595,6852,-8956,2101,6722,1579,3820,7827,-3369,7144,1974,7310,-5369,-6755,3010,5789,1563,-3330,5373,-2770,4503,-4065,8177,-3333,-4726,-2131,2763,9012,-4755,2382,3642,-5284,-7174,-9815,6392,9729,-1943,-8749,5343,1036,8508,1484,919,4225,3733,8036,-6346,-2088,475,9378,4271,-5906,9327,9399,-1582,3845,3499,-8912,-4671,-1143,-5081,-1621,-1287,5995,4963,5071,5118,-1966,-6249,663,-2296,-8148,-4668,-6919,334,-6609,2888,-4161,118,-1867,5629,8588,-5325,-7853,-4868,-1487,-6544,-9697,-7038,6422,-5545,3376,-8656,8800,-7698,-2928,2279,-9739,4198,6236,-9087,9010,-9894,2145,7353,-92,3205,5431,5913,1619,-250,4728,-7164,-5619,-4721,-9284,-9645,146,7131,-6501,4261,2016,2880,4944,-8768,-6339,-3574,539,4633,9188,7227,-1549,9271,7110,5706,4968,-1275,5545,-5844,-1985,9560,1560,4630,3169,6076,-9433,7007,9927,-8385,-4557,-114,9543,2884,8978,-6447,3664,-7499,-4643,-5993,-5321,3250,-2945,6216,-1606,5569,7326,-6027,9723,-6997,-543,-8298,-4647,2563,1493,9574,1087,-9433,-7749,-7159,-2682,6626,2787,-2845,-7907,-223,-8142,-5403,-3460,-2534,5289,999,9404,-1958,641,4669,-2892,-2921,-7001,-1403,-2353,-7976,-5885,4958,-8117,8785,-654,5918,5533,8704,5827,-7478,-3696,2640,1612,-500,5694,-1973,5308,5272,3358,9190,4648,-7836,658,-3407,6733,1061,-2010,-2707,-1920,1272,3944,-6537,-6090,-7429,-640,836,1904,-4031,814,-1886,8040,-8312,-9407,-1395,-9944,-2074,-6814,2672,1360,8990,5465,-2131,3838,799,-3472,1086,-583,6302,3032,9138,-7778,4538,-5337,2087,2870,-3005,3401,122,-819,-8074,9630,-698,5326,2650,-9355,6487,3801,-3209,8293,662,-8318,-7863,-3814,-2557,-5685,-7952,6224,-7010,2935,5557,-1287,9528,-9218,-5108,-2085,17,4870,-8686,-8854,-9657,8848,-1883,-4535,83,9711,4593,-3440,-6938,3407,-6894,-6213,-883,4552,-731,1485,-7740,-3300,3897,-7629,-4076,7589,3142,-1010,2466,-592,-391,3961,-7049,7654,5758,6983,6048,-4369,-5878,3756,2940,9149,8625,8937,5706,6658,9213,-5226,284,-4524,-1577,-5296,6423,9977,-1805,5462,7587,476,-6424,976,-3925,8819,1821,3603,-842,-9618,-7130,-6253,2562,-7596,3522,6282,-3801,-3896,6924,441,5944,8535,1253,-6154,6872,-9548,-5358,1604,9593,-9256,-701,1023,-1446,-1307,-6809,9542,3673,1813,8717,-6847,-5289,5222,-7266,4231,218,-9633,-4696,5494,9681,1173,-4606,2174,-1155,-8595,-3640,-6550,-7003,4244,-2543,5241,2831,2690,8950,-6609,-9724,7562,-4096,8878,9962,7179,-1170,7826,-146,-2759,-5249,253,6206,3205,-7708,9448,4622,9260,-2853,2486,122,-8880,-769,-8922,648,7358,-6503,-6382,-4260,3988,-5107,-6363,2415,8563,-9070,-5026,2078,-2558,-2027,-7489,-4978,5024,4155,-9737,-221,9930,-9472,1052,-268,6221,2726,-1310,-8708,3482,-5488,-6506,5389,-7048,553,-886,2752,85,-3938,5940,-5112,5855,-7295,3735,2657,3269,6231,4771,3229,-2009,-5748,7256,746,-4301,752,-241,-6151,-2390,9911,825,-7679,-4960,-7224,-2739,-566,-5770,6774,6243,3166,-783,-4303,-9016,5555,-1866,-536,8872,-3927,4269,-3807,1933,9972,981,9256,6857,-208,3645,-3725,5961,1105,6320,-4702,-8419,-4904,-4935,8378,-2994,5831,5296,4730,-9170,-4229,-3911,-160,8757,-5301,-3775,1121,9434,-9880,2689,2340,-7879,3667,-5219,-6116,-1670,7595,6900,3990,4444,6385,-2924,8968,-2673,-6182,7503,5209,6030,802,-3464,1922,-8187,1617,4769,-4866,-3518,5830,3862,-7512,5236,-5164,6324,-5107,6864,-7364,-1375,5762,-275,4975,-7448,5719,-3162,-1546,-2776,-9411,-1845,-4913,-3474,2550,5643,-5527,2946,7158,1938,5125,-8015,2475,-1461,-4900,-5151,-4031,9362,8571,9815,-8438,-6519,1980,-8031,9615,7079,-3573,-883,4217,1079,5918,1767,8670,-5651,-6625,1057,7897,-7104,-4186,851,-6333,-4108,-3250,7899,9628,-6904,-3939,4587,1227,3813,-7449,-7692,-8098,-9813,8862,-2888,-1048,-3564,3074,1437,-2291,3974,3164,4921,-8958,9007,-3938,2042,7454,-910,-998,-4450,-1103,-237,8182,-1391,-4255,-3482,-2918,4053,2280,-7403,4319,-9457,7157,-6315,-7533,6309,2211,-9145,443,4255,-8847,-5557,-9089,1752,-5784,-2399,-8296,-8400,8170,4628,-4583,937,-7067,-3503,-549,-1194,1576,5004,-6963,-8837,5567,870,3954,5489,-8949,-7673,8542,-9040,-7689,-4171,-889,5552,-6836,-4393,513,3177,6664,-5646,2492,9421,-342,2570,8816,2869,-6820,-3389,-1903,-3332,138,6618,293,-9130,3503,-2327,-9728,7632,5881,540,9678,-7629,8804,-2816,7205,7473,-5518,7311,3457,9066,-1224,2097,7857,6612,186,6759,-4516,-3491,-8268,-8928,-7412,7162,6274,5463,2157,-4131,-7061,-8476,-5584,7300,-4348,-5940,-8592,-302,-5817,3151,-4124,1694,-5114,-3252,-2319,-2157,-293,7724,-5673,6105,9535,4333,6353,1290,8710,-5035,8995,-5865,9746,4708,-6387,-8937,3096,-9716,-7124,2531,-660,-4619,-8035,3747,-7821,8793,-727,8242,4957,-7175,4064,-9911,4995,9725,1634,-4275,788,-4920,3831,-3525,-4467,2909,-1200,5377,-4905,-3077,-1763,4443,-3518,3134,-5595,5409,5943,6757,3485,2883,-9261,-7221,654,2001,-926,7840,-5568,2715,-7053,-2082,-2005,7607,-9511,7545,7564,2380,-7257,1449,-3918,-3240,-1928,-6555,-4784,1550,2745,-5316]\\nk=56"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if you use a heap, this question is medium. if you use a monotonic queue, this is easily a hard ... whenever lc suggests heap, it seems like monotonic queue is usually always faster "
                    }
                ]
            },
            {
                "id": 1575384,
                "content": [
                    {
                        "username": "faangboy",
                        "content": "Based on the solutions posted so far, the optimal approach seems the one similar to Sliding Window Maximum. But that question is hard, and for some one like me who has never solved it before, I don\\'t think it was medium for me ;)"
                    },
                    {
                        "username": "lalit10368",
                        "content": "You are right, I spent days trying to solve this problem but couldn't. So, I decided to attempt Sliding Window Maximum  instead. It's also listed in Similar Problems section. That problem looked straightforward compared to this one, although still hard. But the problem statement was pretty clear on using sliding windows. After spending some time I was able to figure out the solution and solved it in my first attempt. No wrong answers, no TLE, not even compilation issue. Most problems I could have solved in my head(both medium & hard levels) may be little bit of paper scribbling but this one(maximum sliding window) literally required a whiteboard and moving those window pointers around.\nMy Solution to the Maximum Window Problem : \nhttps://leetcode.com/problems/sliding-window-maximum/submissions/899998243/\n"
                    },
                    {
                        "username": "h98dubey",
                        "content": "Is it just me or anyone else also thinks that this problem should be under hard catogary, specially if you are looking this problem for the first time ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-vi/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming + Deque\n\n  \n**Approach 2:** Dynamic Programming + Priority Queue\n\n  \n**Approach 3:** Segment Tree\n\n  \n**Approach 4:** Dynamic Programming + Deque (Compressed)\n\n  \n**Approach 5:** Dynamic Programming + Priority Queue (Compressed)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Started from Jump Game I, jumped for 6 days and finally reached Jump Game VI."
                    },
                    {
                        "username": "xingasong",
                        "content": "Just wonder how leetcode decide the difficulty of a question..."
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "they assume u have done its prerequisites"
                    },
                    {
                        "username": "JustinNie",
                        "content": "It has to be hard, since it is hard."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is almost same as Constrained Subsequence Sum,which is hard.This should be hard or the other should be medium."
                    },
                    {
                        "username": "f20201382",
                        "content": "Why does the given code not work?\\n `class Solution {\\npublic:\\n    int n;\\n    int k;\\n    int maxScore(vector<int>& nums, vector<int>& dp, int i){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int score = INT_MIN;\\n        for(int j=1;j<=k;j++){\\n            score = max(score, nums[i]+maxScore(nums,dp,i+j));\\n        }\\n\\n        return dp[i] = score;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        this->k = k;\\n        vector<int> dp(n,-1);\\n        return maxScore(nums,dp,0);\\n    }\\n};.`\\n"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "yeah same doubt did u find the error ?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why the logic of picking the max in the next window , throws error. Like for k=2, if I pick i=2 as maximum then search through range [i + 1, min(n - 1, i + k)] i.e [3,5] and pick the max value in that range. If 5 contains the max value then start the next iteration [5,7] from the index =5. I wrote the code and it failed for this test case\\n\\n[-5582,-5317,6711,-639,1001,1845,1728,-4575,-6066,-7770,128,-3254,7281,3966,6857,5477,8968,-1771,9986,-6267,9010,-764,8413,-8154,1087,-1107,4183,3033,58,659,4625,2825,5031,6811,5657,3229,8597,-5772,8869,5723,2960,4040,7222,4841,-1014,581,-2830,3881,-3800,577,-7396,-611,-6944,8461,3294,6297,9713,-2246,-3441,3831,-5754,6716,6040,-6715,5763,8611,5412,-7630,6216,260,2595,6852,-8956,2101,6722,1579,3820,7827,-3369,7144,1974,7310,-5369,-6755,3010,5789,1563,-3330,5373,-2770,4503,-4065,8177,-3333,-4726,-2131,2763,9012,-4755,2382,3642,-5284,-7174,-9815,6392,9729,-1943,-8749,5343,1036,8508,1484,919,4225,3733,8036,-6346,-2088,475,9378,4271,-5906,9327,9399,-1582,3845,3499,-8912,-4671,-1143,-5081,-1621,-1287,5995,4963,5071,5118,-1966,-6249,663,-2296,-8148,-4668,-6919,334,-6609,2888,-4161,118,-1867,5629,8588,-5325,-7853,-4868,-1487,-6544,-9697,-7038,6422,-5545,3376,-8656,8800,-7698,-2928,2279,-9739,4198,6236,-9087,9010,-9894,2145,7353,-92,3205,5431,5913,1619,-250,4728,-7164,-5619,-4721,-9284,-9645,146,7131,-6501,4261,2016,2880,4944,-8768,-6339,-3574,539,4633,9188,7227,-1549,9271,7110,5706,4968,-1275,5545,-5844,-1985,9560,1560,4630,3169,6076,-9433,7007,9927,-8385,-4557,-114,9543,2884,8978,-6447,3664,-7499,-4643,-5993,-5321,3250,-2945,6216,-1606,5569,7326,-6027,9723,-6997,-543,-8298,-4647,2563,1493,9574,1087,-9433,-7749,-7159,-2682,6626,2787,-2845,-7907,-223,-8142,-5403,-3460,-2534,5289,999,9404,-1958,641,4669,-2892,-2921,-7001,-1403,-2353,-7976,-5885,4958,-8117,8785,-654,5918,5533,8704,5827,-7478,-3696,2640,1612,-500,5694,-1973,5308,5272,3358,9190,4648,-7836,658,-3407,6733,1061,-2010,-2707,-1920,1272,3944,-6537,-6090,-7429,-640,836,1904,-4031,814,-1886,8040,-8312,-9407,-1395,-9944,-2074,-6814,2672,1360,8990,5465,-2131,3838,799,-3472,1086,-583,6302,3032,9138,-7778,4538,-5337,2087,2870,-3005,3401,122,-819,-8074,9630,-698,5326,2650,-9355,6487,3801,-3209,8293,662,-8318,-7863,-3814,-2557,-5685,-7952,6224,-7010,2935,5557,-1287,9528,-9218,-5108,-2085,17,4870,-8686,-8854,-9657,8848,-1883,-4535,83,9711,4593,-3440,-6938,3407,-6894,-6213,-883,4552,-731,1485,-7740,-3300,3897,-7629,-4076,7589,3142,-1010,2466,-592,-391,3961,-7049,7654,5758,6983,6048,-4369,-5878,3756,2940,9149,8625,8937,5706,6658,9213,-5226,284,-4524,-1577,-5296,6423,9977,-1805,5462,7587,476,-6424,976,-3925,8819,1821,3603,-842,-9618,-7130,-6253,2562,-7596,3522,6282,-3801,-3896,6924,441,5944,8535,1253,-6154,6872,-9548,-5358,1604,9593,-9256,-701,1023,-1446,-1307,-6809,9542,3673,1813,8717,-6847,-5289,5222,-7266,4231,218,-9633,-4696,5494,9681,1173,-4606,2174,-1155,-8595,-3640,-6550,-7003,4244,-2543,5241,2831,2690,8950,-6609,-9724,7562,-4096,8878,9962,7179,-1170,7826,-146,-2759,-5249,253,6206,3205,-7708,9448,4622,9260,-2853,2486,122,-8880,-769,-8922,648,7358,-6503,-6382,-4260,3988,-5107,-6363,2415,8563,-9070,-5026,2078,-2558,-2027,-7489,-4978,5024,4155,-9737,-221,9930,-9472,1052,-268,6221,2726,-1310,-8708,3482,-5488,-6506,5389,-7048,553,-886,2752,85,-3938,5940,-5112,5855,-7295,3735,2657,3269,6231,4771,3229,-2009,-5748,7256,746,-4301,752,-241,-6151,-2390,9911,825,-7679,-4960,-7224,-2739,-566,-5770,6774,6243,3166,-783,-4303,-9016,5555,-1866,-536,8872,-3927,4269,-3807,1933,9972,981,9256,6857,-208,3645,-3725,5961,1105,6320,-4702,-8419,-4904,-4935,8378,-2994,5831,5296,4730,-9170,-4229,-3911,-160,8757,-5301,-3775,1121,9434,-9880,2689,2340,-7879,3667,-5219,-6116,-1670,7595,6900,3990,4444,6385,-2924,8968,-2673,-6182,7503,5209,6030,802,-3464,1922,-8187,1617,4769,-4866,-3518,5830,3862,-7512,5236,-5164,6324,-5107,6864,-7364,-1375,5762,-275,4975,-7448,5719,-3162,-1546,-2776,-9411,-1845,-4913,-3474,2550,5643,-5527,2946,7158,1938,5125,-8015,2475,-1461,-4900,-5151,-4031,9362,8571,9815,-8438,-6519,1980,-8031,9615,7079,-3573,-883,4217,1079,5918,1767,8670,-5651,-6625,1057,7897,-7104,-4186,851,-6333,-4108,-3250,7899,9628,-6904,-3939,4587,1227,3813,-7449,-7692,-8098,-9813,8862,-2888,-1048,-3564,3074,1437,-2291,3974,3164,4921,-8958,9007,-3938,2042,7454,-910,-998,-4450,-1103,-237,8182,-1391,-4255,-3482,-2918,4053,2280,-7403,4319,-9457,7157,-6315,-7533,6309,2211,-9145,443,4255,-8847,-5557,-9089,1752,-5784,-2399,-8296,-8400,8170,4628,-4583,937,-7067,-3503,-549,-1194,1576,5004,-6963,-8837,5567,870,3954,5489,-8949,-7673,8542,-9040,-7689,-4171,-889,5552,-6836,-4393,513,3177,6664,-5646,2492,9421,-342,2570,8816,2869,-6820,-3389,-1903,-3332,138,6618,293,-9130,3503,-2327,-9728,7632,5881,540,9678,-7629,8804,-2816,7205,7473,-5518,7311,3457,9066,-1224,2097,7857,6612,186,6759,-4516,-3491,-8268,-8928,-7412,7162,6274,5463,2157,-4131,-7061,-8476,-5584,7300,-4348,-5940,-8592,-302,-5817,3151,-4124,1694,-5114,-3252,-2319,-2157,-293,7724,-5673,6105,9535,4333,6353,1290,8710,-5035,8995,-5865,9746,4708,-6387,-8937,3096,-9716,-7124,2531,-660,-4619,-8035,3747,-7821,8793,-727,8242,4957,-7175,4064,-9911,4995,9725,1634,-4275,788,-4920,3831,-3525,-4467,2909,-1200,5377,-4905,-3077,-1763,4443,-3518,3134,-5595,5409,5943,6757,3485,2883,-9261,-7221,654,2001,-926,7840,-5568,2715,-7053,-2082,-2005,7607,-9511,7545,7564,2380,-7257,1449,-3918,-3240,-1928,-6555,-4784,1550,2745,-5316]\\nk=56"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if you use a heap, this question is medium. if you use a monotonic queue, this is easily a hard ... whenever lc suggests heap, it seems like monotonic queue is usually always faster "
                    }
                ]
            },
            {
                "id": 1822758,
                "content": [
                    {
                        "username": "faangboy",
                        "content": "Based on the solutions posted so far, the optimal approach seems the one similar to Sliding Window Maximum. But that question is hard, and for some one like me who has never solved it before, I don\\'t think it was medium for me ;)"
                    },
                    {
                        "username": "lalit10368",
                        "content": "You are right, I spent days trying to solve this problem but couldn't. So, I decided to attempt Sliding Window Maximum  instead. It's also listed in Similar Problems section. That problem looked straightforward compared to this one, although still hard. But the problem statement was pretty clear on using sliding windows. After spending some time I was able to figure out the solution and solved it in my first attempt. No wrong answers, no TLE, not even compilation issue. Most problems I could have solved in my head(both medium & hard levels) may be little bit of paper scribbling but this one(maximum sliding window) literally required a whiteboard and moving those window pointers around.\nMy Solution to the Maximum Window Problem : \nhttps://leetcode.com/problems/sliding-window-maximum/submissions/899998243/\n"
                    },
                    {
                        "username": "h98dubey",
                        "content": "Is it just me or anyone else also thinks that this problem should be under hard catogary, specially if you are looking this problem for the first time ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-vi/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming + Deque\n\n  \n**Approach 2:** Dynamic Programming + Priority Queue\n\n  \n**Approach 3:** Segment Tree\n\n  \n**Approach 4:** Dynamic Programming + Deque (Compressed)\n\n  \n**Approach 5:** Dynamic Programming + Priority Queue (Compressed)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Started from Jump Game I, jumped for 6 days and finally reached Jump Game VI."
                    },
                    {
                        "username": "xingasong",
                        "content": "Just wonder how leetcode decide the difficulty of a question..."
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "they assume u have done its prerequisites"
                    },
                    {
                        "username": "JustinNie",
                        "content": "It has to be hard, since it is hard."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is almost same as Constrained Subsequence Sum,which is hard.This should be hard or the other should be medium."
                    },
                    {
                        "username": "f20201382",
                        "content": "Why does the given code not work?\\n `class Solution {\\npublic:\\n    int n;\\n    int k;\\n    int maxScore(vector<int>& nums, vector<int>& dp, int i){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int score = INT_MIN;\\n        for(int j=1;j<=k;j++){\\n            score = max(score, nums[i]+maxScore(nums,dp,i+j));\\n        }\\n\\n        return dp[i] = score;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        this->k = k;\\n        vector<int> dp(n,-1);\\n        return maxScore(nums,dp,0);\\n    }\\n};.`\\n"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "yeah same doubt did u find the error ?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why the logic of picking the max in the next window , throws error. Like for k=2, if I pick i=2 as maximum then search through range [i + 1, min(n - 1, i + k)] i.e [3,5] and pick the max value in that range. If 5 contains the max value then start the next iteration [5,7] from the index =5. I wrote the code and it failed for this test case\\n\\n[-5582,-5317,6711,-639,1001,1845,1728,-4575,-6066,-7770,128,-3254,7281,3966,6857,5477,8968,-1771,9986,-6267,9010,-764,8413,-8154,1087,-1107,4183,3033,58,659,4625,2825,5031,6811,5657,3229,8597,-5772,8869,5723,2960,4040,7222,4841,-1014,581,-2830,3881,-3800,577,-7396,-611,-6944,8461,3294,6297,9713,-2246,-3441,3831,-5754,6716,6040,-6715,5763,8611,5412,-7630,6216,260,2595,6852,-8956,2101,6722,1579,3820,7827,-3369,7144,1974,7310,-5369,-6755,3010,5789,1563,-3330,5373,-2770,4503,-4065,8177,-3333,-4726,-2131,2763,9012,-4755,2382,3642,-5284,-7174,-9815,6392,9729,-1943,-8749,5343,1036,8508,1484,919,4225,3733,8036,-6346,-2088,475,9378,4271,-5906,9327,9399,-1582,3845,3499,-8912,-4671,-1143,-5081,-1621,-1287,5995,4963,5071,5118,-1966,-6249,663,-2296,-8148,-4668,-6919,334,-6609,2888,-4161,118,-1867,5629,8588,-5325,-7853,-4868,-1487,-6544,-9697,-7038,6422,-5545,3376,-8656,8800,-7698,-2928,2279,-9739,4198,6236,-9087,9010,-9894,2145,7353,-92,3205,5431,5913,1619,-250,4728,-7164,-5619,-4721,-9284,-9645,146,7131,-6501,4261,2016,2880,4944,-8768,-6339,-3574,539,4633,9188,7227,-1549,9271,7110,5706,4968,-1275,5545,-5844,-1985,9560,1560,4630,3169,6076,-9433,7007,9927,-8385,-4557,-114,9543,2884,8978,-6447,3664,-7499,-4643,-5993,-5321,3250,-2945,6216,-1606,5569,7326,-6027,9723,-6997,-543,-8298,-4647,2563,1493,9574,1087,-9433,-7749,-7159,-2682,6626,2787,-2845,-7907,-223,-8142,-5403,-3460,-2534,5289,999,9404,-1958,641,4669,-2892,-2921,-7001,-1403,-2353,-7976,-5885,4958,-8117,8785,-654,5918,5533,8704,5827,-7478,-3696,2640,1612,-500,5694,-1973,5308,5272,3358,9190,4648,-7836,658,-3407,6733,1061,-2010,-2707,-1920,1272,3944,-6537,-6090,-7429,-640,836,1904,-4031,814,-1886,8040,-8312,-9407,-1395,-9944,-2074,-6814,2672,1360,8990,5465,-2131,3838,799,-3472,1086,-583,6302,3032,9138,-7778,4538,-5337,2087,2870,-3005,3401,122,-819,-8074,9630,-698,5326,2650,-9355,6487,3801,-3209,8293,662,-8318,-7863,-3814,-2557,-5685,-7952,6224,-7010,2935,5557,-1287,9528,-9218,-5108,-2085,17,4870,-8686,-8854,-9657,8848,-1883,-4535,83,9711,4593,-3440,-6938,3407,-6894,-6213,-883,4552,-731,1485,-7740,-3300,3897,-7629,-4076,7589,3142,-1010,2466,-592,-391,3961,-7049,7654,5758,6983,6048,-4369,-5878,3756,2940,9149,8625,8937,5706,6658,9213,-5226,284,-4524,-1577,-5296,6423,9977,-1805,5462,7587,476,-6424,976,-3925,8819,1821,3603,-842,-9618,-7130,-6253,2562,-7596,3522,6282,-3801,-3896,6924,441,5944,8535,1253,-6154,6872,-9548,-5358,1604,9593,-9256,-701,1023,-1446,-1307,-6809,9542,3673,1813,8717,-6847,-5289,5222,-7266,4231,218,-9633,-4696,5494,9681,1173,-4606,2174,-1155,-8595,-3640,-6550,-7003,4244,-2543,5241,2831,2690,8950,-6609,-9724,7562,-4096,8878,9962,7179,-1170,7826,-146,-2759,-5249,253,6206,3205,-7708,9448,4622,9260,-2853,2486,122,-8880,-769,-8922,648,7358,-6503,-6382,-4260,3988,-5107,-6363,2415,8563,-9070,-5026,2078,-2558,-2027,-7489,-4978,5024,4155,-9737,-221,9930,-9472,1052,-268,6221,2726,-1310,-8708,3482,-5488,-6506,5389,-7048,553,-886,2752,85,-3938,5940,-5112,5855,-7295,3735,2657,3269,6231,4771,3229,-2009,-5748,7256,746,-4301,752,-241,-6151,-2390,9911,825,-7679,-4960,-7224,-2739,-566,-5770,6774,6243,3166,-783,-4303,-9016,5555,-1866,-536,8872,-3927,4269,-3807,1933,9972,981,9256,6857,-208,3645,-3725,5961,1105,6320,-4702,-8419,-4904,-4935,8378,-2994,5831,5296,4730,-9170,-4229,-3911,-160,8757,-5301,-3775,1121,9434,-9880,2689,2340,-7879,3667,-5219,-6116,-1670,7595,6900,3990,4444,6385,-2924,8968,-2673,-6182,7503,5209,6030,802,-3464,1922,-8187,1617,4769,-4866,-3518,5830,3862,-7512,5236,-5164,6324,-5107,6864,-7364,-1375,5762,-275,4975,-7448,5719,-3162,-1546,-2776,-9411,-1845,-4913,-3474,2550,5643,-5527,2946,7158,1938,5125,-8015,2475,-1461,-4900,-5151,-4031,9362,8571,9815,-8438,-6519,1980,-8031,9615,7079,-3573,-883,4217,1079,5918,1767,8670,-5651,-6625,1057,7897,-7104,-4186,851,-6333,-4108,-3250,7899,9628,-6904,-3939,4587,1227,3813,-7449,-7692,-8098,-9813,8862,-2888,-1048,-3564,3074,1437,-2291,3974,3164,4921,-8958,9007,-3938,2042,7454,-910,-998,-4450,-1103,-237,8182,-1391,-4255,-3482,-2918,4053,2280,-7403,4319,-9457,7157,-6315,-7533,6309,2211,-9145,443,4255,-8847,-5557,-9089,1752,-5784,-2399,-8296,-8400,8170,4628,-4583,937,-7067,-3503,-549,-1194,1576,5004,-6963,-8837,5567,870,3954,5489,-8949,-7673,8542,-9040,-7689,-4171,-889,5552,-6836,-4393,513,3177,6664,-5646,2492,9421,-342,2570,8816,2869,-6820,-3389,-1903,-3332,138,6618,293,-9130,3503,-2327,-9728,7632,5881,540,9678,-7629,8804,-2816,7205,7473,-5518,7311,3457,9066,-1224,2097,7857,6612,186,6759,-4516,-3491,-8268,-8928,-7412,7162,6274,5463,2157,-4131,-7061,-8476,-5584,7300,-4348,-5940,-8592,-302,-5817,3151,-4124,1694,-5114,-3252,-2319,-2157,-293,7724,-5673,6105,9535,4333,6353,1290,8710,-5035,8995,-5865,9746,4708,-6387,-8937,3096,-9716,-7124,2531,-660,-4619,-8035,3747,-7821,8793,-727,8242,4957,-7175,4064,-9911,4995,9725,1634,-4275,788,-4920,3831,-3525,-4467,2909,-1200,5377,-4905,-3077,-1763,4443,-3518,3134,-5595,5409,5943,6757,3485,2883,-9261,-7221,654,2001,-926,7840,-5568,2715,-7053,-2082,-2005,7607,-9511,7545,7564,2380,-7257,1449,-3918,-3240,-1928,-6555,-4784,1550,2745,-5316]\\nk=56"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if you use a heap, this question is medium. if you use a monotonic queue, this is easily a hard ... whenever lc suggests heap, it seems like monotonic queue is usually always faster "
                    }
                ]
            },
            {
                "id": 1979271,
                "content": [
                    {
                        "username": "faangboy",
                        "content": "Based on the solutions posted so far, the optimal approach seems the one similar to Sliding Window Maximum. But that question is hard, and for some one like me who has never solved it before, I don\\'t think it was medium for me ;)"
                    },
                    {
                        "username": "lalit10368",
                        "content": "You are right, I spent days trying to solve this problem but couldn't. So, I decided to attempt Sliding Window Maximum  instead. It's also listed in Similar Problems section. That problem looked straightforward compared to this one, although still hard. But the problem statement was pretty clear on using sliding windows. After spending some time I was able to figure out the solution and solved it in my first attempt. No wrong answers, no TLE, not even compilation issue. Most problems I could have solved in my head(both medium & hard levels) may be little bit of paper scribbling but this one(maximum sliding window) literally required a whiteboard and moving those window pointers around.\nMy Solution to the Maximum Window Problem : \nhttps://leetcode.com/problems/sliding-window-maximum/submissions/899998243/\n"
                    },
                    {
                        "username": "h98dubey",
                        "content": "Is it just me or anyone else also thinks that this problem should be under hard catogary, specially if you are looking this problem for the first time ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-vi/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming + Deque\n\n  \n**Approach 2:** Dynamic Programming + Priority Queue\n\n  \n**Approach 3:** Segment Tree\n\n  \n**Approach 4:** Dynamic Programming + Deque (Compressed)\n\n  \n**Approach 5:** Dynamic Programming + Priority Queue (Compressed)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Started from Jump Game I, jumped for 6 days and finally reached Jump Game VI."
                    },
                    {
                        "username": "xingasong",
                        "content": "Just wonder how leetcode decide the difficulty of a question..."
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "they assume u have done its prerequisites"
                    },
                    {
                        "username": "JustinNie",
                        "content": "It has to be hard, since it is hard."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is almost same as Constrained Subsequence Sum,which is hard.This should be hard or the other should be medium."
                    },
                    {
                        "username": "f20201382",
                        "content": "Why does the given code not work?\\n `class Solution {\\npublic:\\n    int n;\\n    int k;\\n    int maxScore(vector<int>& nums, vector<int>& dp, int i){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int score = INT_MIN;\\n        for(int j=1;j<=k;j++){\\n            score = max(score, nums[i]+maxScore(nums,dp,i+j));\\n        }\\n\\n        return dp[i] = score;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        this->k = k;\\n        vector<int> dp(n,-1);\\n        return maxScore(nums,dp,0);\\n    }\\n};.`\\n"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "yeah same doubt did u find the error ?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why the logic of picking the max in the next window , throws error. Like for k=2, if I pick i=2 as maximum then search through range [i + 1, min(n - 1, i + k)] i.e [3,5] and pick the max value in that range. If 5 contains the max value then start the next iteration [5,7] from the index =5. I wrote the code and it failed for this test case\\n\\n[-5582,-5317,6711,-639,1001,1845,1728,-4575,-6066,-7770,128,-3254,7281,3966,6857,5477,8968,-1771,9986,-6267,9010,-764,8413,-8154,1087,-1107,4183,3033,58,659,4625,2825,5031,6811,5657,3229,8597,-5772,8869,5723,2960,4040,7222,4841,-1014,581,-2830,3881,-3800,577,-7396,-611,-6944,8461,3294,6297,9713,-2246,-3441,3831,-5754,6716,6040,-6715,5763,8611,5412,-7630,6216,260,2595,6852,-8956,2101,6722,1579,3820,7827,-3369,7144,1974,7310,-5369,-6755,3010,5789,1563,-3330,5373,-2770,4503,-4065,8177,-3333,-4726,-2131,2763,9012,-4755,2382,3642,-5284,-7174,-9815,6392,9729,-1943,-8749,5343,1036,8508,1484,919,4225,3733,8036,-6346,-2088,475,9378,4271,-5906,9327,9399,-1582,3845,3499,-8912,-4671,-1143,-5081,-1621,-1287,5995,4963,5071,5118,-1966,-6249,663,-2296,-8148,-4668,-6919,334,-6609,2888,-4161,118,-1867,5629,8588,-5325,-7853,-4868,-1487,-6544,-9697,-7038,6422,-5545,3376,-8656,8800,-7698,-2928,2279,-9739,4198,6236,-9087,9010,-9894,2145,7353,-92,3205,5431,5913,1619,-250,4728,-7164,-5619,-4721,-9284,-9645,146,7131,-6501,4261,2016,2880,4944,-8768,-6339,-3574,539,4633,9188,7227,-1549,9271,7110,5706,4968,-1275,5545,-5844,-1985,9560,1560,4630,3169,6076,-9433,7007,9927,-8385,-4557,-114,9543,2884,8978,-6447,3664,-7499,-4643,-5993,-5321,3250,-2945,6216,-1606,5569,7326,-6027,9723,-6997,-543,-8298,-4647,2563,1493,9574,1087,-9433,-7749,-7159,-2682,6626,2787,-2845,-7907,-223,-8142,-5403,-3460,-2534,5289,999,9404,-1958,641,4669,-2892,-2921,-7001,-1403,-2353,-7976,-5885,4958,-8117,8785,-654,5918,5533,8704,5827,-7478,-3696,2640,1612,-500,5694,-1973,5308,5272,3358,9190,4648,-7836,658,-3407,6733,1061,-2010,-2707,-1920,1272,3944,-6537,-6090,-7429,-640,836,1904,-4031,814,-1886,8040,-8312,-9407,-1395,-9944,-2074,-6814,2672,1360,8990,5465,-2131,3838,799,-3472,1086,-583,6302,3032,9138,-7778,4538,-5337,2087,2870,-3005,3401,122,-819,-8074,9630,-698,5326,2650,-9355,6487,3801,-3209,8293,662,-8318,-7863,-3814,-2557,-5685,-7952,6224,-7010,2935,5557,-1287,9528,-9218,-5108,-2085,17,4870,-8686,-8854,-9657,8848,-1883,-4535,83,9711,4593,-3440,-6938,3407,-6894,-6213,-883,4552,-731,1485,-7740,-3300,3897,-7629,-4076,7589,3142,-1010,2466,-592,-391,3961,-7049,7654,5758,6983,6048,-4369,-5878,3756,2940,9149,8625,8937,5706,6658,9213,-5226,284,-4524,-1577,-5296,6423,9977,-1805,5462,7587,476,-6424,976,-3925,8819,1821,3603,-842,-9618,-7130,-6253,2562,-7596,3522,6282,-3801,-3896,6924,441,5944,8535,1253,-6154,6872,-9548,-5358,1604,9593,-9256,-701,1023,-1446,-1307,-6809,9542,3673,1813,8717,-6847,-5289,5222,-7266,4231,218,-9633,-4696,5494,9681,1173,-4606,2174,-1155,-8595,-3640,-6550,-7003,4244,-2543,5241,2831,2690,8950,-6609,-9724,7562,-4096,8878,9962,7179,-1170,7826,-146,-2759,-5249,253,6206,3205,-7708,9448,4622,9260,-2853,2486,122,-8880,-769,-8922,648,7358,-6503,-6382,-4260,3988,-5107,-6363,2415,8563,-9070,-5026,2078,-2558,-2027,-7489,-4978,5024,4155,-9737,-221,9930,-9472,1052,-268,6221,2726,-1310,-8708,3482,-5488,-6506,5389,-7048,553,-886,2752,85,-3938,5940,-5112,5855,-7295,3735,2657,3269,6231,4771,3229,-2009,-5748,7256,746,-4301,752,-241,-6151,-2390,9911,825,-7679,-4960,-7224,-2739,-566,-5770,6774,6243,3166,-783,-4303,-9016,5555,-1866,-536,8872,-3927,4269,-3807,1933,9972,981,9256,6857,-208,3645,-3725,5961,1105,6320,-4702,-8419,-4904,-4935,8378,-2994,5831,5296,4730,-9170,-4229,-3911,-160,8757,-5301,-3775,1121,9434,-9880,2689,2340,-7879,3667,-5219,-6116,-1670,7595,6900,3990,4444,6385,-2924,8968,-2673,-6182,7503,5209,6030,802,-3464,1922,-8187,1617,4769,-4866,-3518,5830,3862,-7512,5236,-5164,6324,-5107,6864,-7364,-1375,5762,-275,4975,-7448,5719,-3162,-1546,-2776,-9411,-1845,-4913,-3474,2550,5643,-5527,2946,7158,1938,5125,-8015,2475,-1461,-4900,-5151,-4031,9362,8571,9815,-8438,-6519,1980,-8031,9615,7079,-3573,-883,4217,1079,5918,1767,8670,-5651,-6625,1057,7897,-7104,-4186,851,-6333,-4108,-3250,7899,9628,-6904,-3939,4587,1227,3813,-7449,-7692,-8098,-9813,8862,-2888,-1048,-3564,3074,1437,-2291,3974,3164,4921,-8958,9007,-3938,2042,7454,-910,-998,-4450,-1103,-237,8182,-1391,-4255,-3482,-2918,4053,2280,-7403,4319,-9457,7157,-6315,-7533,6309,2211,-9145,443,4255,-8847,-5557,-9089,1752,-5784,-2399,-8296,-8400,8170,4628,-4583,937,-7067,-3503,-549,-1194,1576,5004,-6963,-8837,5567,870,3954,5489,-8949,-7673,8542,-9040,-7689,-4171,-889,5552,-6836,-4393,513,3177,6664,-5646,2492,9421,-342,2570,8816,2869,-6820,-3389,-1903,-3332,138,6618,293,-9130,3503,-2327,-9728,7632,5881,540,9678,-7629,8804,-2816,7205,7473,-5518,7311,3457,9066,-1224,2097,7857,6612,186,6759,-4516,-3491,-8268,-8928,-7412,7162,6274,5463,2157,-4131,-7061,-8476,-5584,7300,-4348,-5940,-8592,-302,-5817,3151,-4124,1694,-5114,-3252,-2319,-2157,-293,7724,-5673,6105,9535,4333,6353,1290,8710,-5035,8995,-5865,9746,4708,-6387,-8937,3096,-9716,-7124,2531,-660,-4619,-8035,3747,-7821,8793,-727,8242,4957,-7175,4064,-9911,4995,9725,1634,-4275,788,-4920,3831,-3525,-4467,2909,-1200,5377,-4905,-3077,-1763,4443,-3518,3134,-5595,5409,5943,6757,3485,2883,-9261,-7221,654,2001,-926,7840,-5568,2715,-7053,-2082,-2005,7607,-9511,7545,7564,2380,-7257,1449,-3918,-3240,-1928,-6555,-4784,1550,2745,-5316]\\nk=56"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if you use a heap, this question is medium. if you use a monotonic queue, this is easily a hard ... whenever lc suggests heap, it seems like monotonic queue is usually always faster "
                    }
                ]
            },
            {
                "id": 1929420,
                "content": [
                    {
                        "username": "faangboy",
                        "content": "Based on the solutions posted so far, the optimal approach seems the one similar to Sliding Window Maximum. But that question is hard, and for some one like me who has never solved it before, I don\\'t think it was medium for me ;)"
                    },
                    {
                        "username": "lalit10368",
                        "content": "You are right, I spent days trying to solve this problem but couldn't. So, I decided to attempt Sliding Window Maximum  instead. It's also listed in Similar Problems section. That problem looked straightforward compared to this one, although still hard. But the problem statement was pretty clear on using sliding windows. After spending some time I was able to figure out the solution and solved it in my first attempt. No wrong answers, no TLE, not even compilation issue. Most problems I could have solved in my head(both medium & hard levels) may be little bit of paper scribbling but this one(maximum sliding window) literally required a whiteboard and moving those window pointers around.\nMy Solution to the Maximum Window Problem : \nhttps://leetcode.com/problems/sliding-window-maximum/submissions/899998243/\n"
                    },
                    {
                        "username": "h98dubey",
                        "content": "Is it just me or anyone else also thinks that this problem should be under hard catogary, specially if you are looking this problem for the first time ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-vi/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming + Deque\n\n  \n**Approach 2:** Dynamic Programming + Priority Queue\n\n  \n**Approach 3:** Segment Tree\n\n  \n**Approach 4:** Dynamic Programming + Deque (Compressed)\n\n  \n**Approach 5:** Dynamic Programming + Priority Queue (Compressed)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Started from Jump Game I, jumped for 6 days and finally reached Jump Game VI."
                    },
                    {
                        "username": "xingasong",
                        "content": "Just wonder how leetcode decide the difficulty of a question..."
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "they assume u have done its prerequisites"
                    },
                    {
                        "username": "JustinNie",
                        "content": "It has to be hard, since it is hard."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is almost same as Constrained Subsequence Sum,which is hard.This should be hard or the other should be medium."
                    },
                    {
                        "username": "f20201382",
                        "content": "Why does the given code not work?\\n `class Solution {\\npublic:\\n    int n;\\n    int k;\\n    int maxScore(vector<int>& nums, vector<int>& dp, int i){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int score = INT_MIN;\\n        for(int j=1;j<=k;j++){\\n            score = max(score, nums[i]+maxScore(nums,dp,i+j));\\n        }\\n\\n        return dp[i] = score;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        this->k = k;\\n        vector<int> dp(n,-1);\\n        return maxScore(nums,dp,0);\\n    }\\n};.`\\n"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "yeah same doubt did u find the error ?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why the logic of picking the max in the next window , throws error. Like for k=2, if I pick i=2 as maximum then search through range [i + 1, min(n - 1, i + k)] i.e [3,5] and pick the max value in that range. If 5 contains the max value then start the next iteration [5,7] from the index =5. I wrote the code and it failed for this test case\\n\\n[-5582,-5317,6711,-639,1001,1845,1728,-4575,-6066,-7770,128,-3254,7281,3966,6857,5477,8968,-1771,9986,-6267,9010,-764,8413,-8154,1087,-1107,4183,3033,58,659,4625,2825,5031,6811,5657,3229,8597,-5772,8869,5723,2960,4040,7222,4841,-1014,581,-2830,3881,-3800,577,-7396,-611,-6944,8461,3294,6297,9713,-2246,-3441,3831,-5754,6716,6040,-6715,5763,8611,5412,-7630,6216,260,2595,6852,-8956,2101,6722,1579,3820,7827,-3369,7144,1974,7310,-5369,-6755,3010,5789,1563,-3330,5373,-2770,4503,-4065,8177,-3333,-4726,-2131,2763,9012,-4755,2382,3642,-5284,-7174,-9815,6392,9729,-1943,-8749,5343,1036,8508,1484,919,4225,3733,8036,-6346,-2088,475,9378,4271,-5906,9327,9399,-1582,3845,3499,-8912,-4671,-1143,-5081,-1621,-1287,5995,4963,5071,5118,-1966,-6249,663,-2296,-8148,-4668,-6919,334,-6609,2888,-4161,118,-1867,5629,8588,-5325,-7853,-4868,-1487,-6544,-9697,-7038,6422,-5545,3376,-8656,8800,-7698,-2928,2279,-9739,4198,6236,-9087,9010,-9894,2145,7353,-92,3205,5431,5913,1619,-250,4728,-7164,-5619,-4721,-9284,-9645,146,7131,-6501,4261,2016,2880,4944,-8768,-6339,-3574,539,4633,9188,7227,-1549,9271,7110,5706,4968,-1275,5545,-5844,-1985,9560,1560,4630,3169,6076,-9433,7007,9927,-8385,-4557,-114,9543,2884,8978,-6447,3664,-7499,-4643,-5993,-5321,3250,-2945,6216,-1606,5569,7326,-6027,9723,-6997,-543,-8298,-4647,2563,1493,9574,1087,-9433,-7749,-7159,-2682,6626,2787,-2845,-7907,-223,-8142,-5403,-3460,-2534,5289,999,9404,-1958,641,4669,-2892,-2921,-7001,-1403,-2353,-7976,-5885,4958,-8117,8785,-654,5918,5533,8704,5827,-7478,-3696,2640,1612,-500,5694,-1973,5308,5272,3358,9190,4648,-7836,658,-3407,6733,1061,-2010,-2707,-1920,1272,3944,-6537,-6090,-7429,-640,836,1904,-4031,814,-1886,8040,-8312,-9407,-1395,-9944,-2074,-6814,2672,1360,8990,5465,-2131,3838,799,-3472,1086,-583,6302,3032,9138,-7778,4538,-5337,2087,2870,-3005,3401,122,-819,-8074,9630,-698,5326,2650,-9355,6487,3801,-3209,8293,662,-8318,-7863,-3814,-2557,-5685,-7952,6224,-7010,2935,5557,-1287,9528,-9218,-5108,-2085,17,4870,-8686,-8854,-9657,8848,-1883,-4535,83,9711,4593,-3440,-6938,3407,-6894,-6213,-883,4552,-731,1485,-7740,-3300,3897,-7629,-4076,7589,3142,-1010,2466,-592,-391,3961,-7049,7654,5758,6983,6048,-4369,-5878,3756,2940,9149,8625,8937,5706,6658,9213,-5226,284,-4524,-1577,-5296,6423,9977,-1805,5462,7587,476,-6424,976,-3925,8819,1821,3603,-842,-9618,-7130,-6253,2562,-7596,3522,6282,-3801,-3896,6924,441,5944,8535,1253,-6154,6872,-9548,-5358,1604,9593,-9256,-701,1023,-1446,-1307,-6809,9542,3673,1813,8717,-6847,-5289,5222,-7266,4231,218,-9633,-4696,5494,9681,1173,-4606,2174,-1155,-8595,-3640,-6550,-7003,4244,-2543,5241,2831,2690,8950,-6609,-9724,7562,-4096,8878,9962,7179,-1170,7826,-146,-2759,-5249,253,6206,3205,-7708,9448,4622,9260,-2853,2486,122,-8880,-769,-8922,648,7358,-6503,-6382,-4260,3988,-5107,-6363,2415,8563,-9070,-5026,2078,-2558,-2027,-7489,-4978,5024,4155,-9737,-221,9930,-9472,1052,-268,6221,2726,-1310,-8708,3482,-5488,-6506,5389,-7048,553,-886,2752,85,-3938,5940,-5112,5855,-7295,3735,2657,3269,6231,4771,3229,-2009,-5748,7256,746,-4301,752,-241,-6151,-2390,9911,825,-7679,-4960,-7224,-2739,-566,-5770,6774,6243,3166,-783,-4303,-9016,5555,-1866,-536,8872,-3927,4269,-3807,1933,9972,981,9256,6857,-208,3645,-3725,5961,1105,6320,-4702,-8419,-4904,-4935,8378,-2994,5831,5296,4730,-9170,-4229,-3911,-160,8757,-5301,-3775,1121,9434,-9880,2689,2340,-7879,3667,-5219,-6116,-1670,7595,6900,3990,4444,6385,-2924,8968,-2673,-6182,7503,5209,6030,802,-3464,1922,-8187,1617,4769,-4866,-3518,5830,3862,-7512,5236,-5164,6324,-5107,6864,-7364,-1375,5762,-275,4975,-7448,5719,-3162,-1546,-2776,-9411,-1845,-4913,-3474,2550,5643,-5527,2946,7158,1938,5125,-8015,2475,-1461,-4900,-5151,-4031,9362,8571,9815,-8438,-6519,1980,-8031,9615,7079,-3573,-883,4217,1079,5918,1767,8670,-5651,-6625,1057,7897,-7104,-4186,851,-6333,-4108,-3250,7899,9628,-6904,-3939,4587,1227,3813,-7449,-7692,-8098,-9813,8862,-2888,-1048,-3564,3074,1437,-2291,3974,3164,4921,-8958,9007,-3938,2042,7454,-910,-998,-4450,-1103,-237,8182,-1391,-4255,-3482,-2918,4053,2280,-7403,4319,-9457,7157,-6315,-7533,6309,2211,-9145,443,4255,-8847,-5557,-9089,1752,-5784,-2399,-8296,-8400,8170,4628,-4583,937,-7067,-3503,-549,-1194,1576,5004,-6963,-8837,5567,870,3954,5489,-8949,-7673,8542,-9040,-7689,-4171,-889,5552,-6836,-4393,513,3177,6664,-5646,2492,9421,-342,2570,8816,2869,-6820,-3389,-1903,-3332,138,6618,293,-9130,3503,-2327,-9728,7632,5881,540,9678,-7629,8804,-2816,7205,7473,-5518,7311,3457,9066,-1224,2097,7857,6612,186,6759,-4516,-3491,-8268,-8928,-7412,7162,6274,5463,2157,-4131,-7061,-8476,-5584,7300,-4348,-5940,-8592,-302,-5817,3151,-4124,1694,-5114,-3252,-2319,-2157,-293,7724,-5673,6105,9535,4333,6353,1290,8710,-5035,8995,-5865,9746,4708,-6387,-8937,3096,-9716,-7124,2531,-660,-4619,-8035,3747,-7821,8793,-727,8242,4957,-7175,4064,-9911,4995,9725,1634,-4275,788,-4920,3831,-3525,-4467,2909,-1200,5377,-4905,-3077,-1763,4443,-3518,3134,-5595,5409,5943,6757,3485,2883,-9261,-7221,654,2001,-926,7840,-5568,2715,-7053,-2082,-2005,7607,-9511,7545,7564,2380,-7257,1449,-3918,-3240,-1928,-6555,-4784,1550,2745,-5316]\\nk=56"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if you use a heap, this question is medium. if you use a monotonic queue, this is easily a hard ... whenever lc suggests heap, it seems like monotonic queue is usually always faster "
                    }
                ]
            },
            {
                "id": 1826645,
                "content": [
                    {
                        "username": "faangboy",
                        "content": "Based on the solutions posted so far, the optimal approach seems the one similar to Sliding Window Maximum. But that question is hard, and for some one like me who has never solved it before, I don\\'t think it was medium for me ;)"
                    },
                    {
                        "username": "lalit10368",
                        "content": "You are right, I spent days trying to solve this problem but couldn't. So, I decided to attempt Sliding Window Maximum  instead. It's also listed in Similar Problems section. That problem looked straightforward compared to this one, although still hard. But the problem statement was pretty clear on using sliding windows. After spending some time I was able to figure out the solution and solved it in my first attempt. No wrong answers, no TLE, not even compilation issue. Most problems I could have solved in my head(both medium & hard levels) may be little bit of paper scribbling but this one(maximum sliding window) literally required a whiteboard and moving those window pointers around.\nMy Solution to the Maximum Window Problem : \nhttps://leetcode.com/problems/sliding-window-maximum/submissions/899998243/\n"
                    },
                    {
                        "username": "h98dubey",
                        "content": "Is it just me or anyone else also thinks that this problem should be under hard catogary, specially if you are looking this problem for the first time ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-vi/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming + Deque\n\n  \n**Approach 2:** Dynamic Programming + Priority Queue\n\n  \n**Approach 3:** Segment Tree\n\n  \n**Approach 4:** Dynamic Programming + Deque (Compressed)\n\n  \n**Approach 5:** Dynamic Programming + Priority Queue (Compressed)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Started from Jump Game I, jumped for 6 days and finally reached Jump Game VI."
                    },
                    {
                        "username": "xingasong",
                        "content": "Just wonder how leetcode decide the difficulty of a question..."
                    },
                    {
                        "username": "lightyagami281199",
                        "content": "they assume u have done its prerequisites"
                    },
                    {
                        "username": "JustinNie",
                        "content": "It has to be hard, since it is hard."
                    },
                    {
                        "username": "stefan1096",
                        "content": "This is almost same as Constrained Subsequence Sum,which is hard.This should be hard or the other should be medium."
                    },
                    {
                        "username": "f20201382",
                        "content": "Why does the given code not work?\\n `class Solution {\\npublic:\\n    int n;\\n    int k;\\n    int maxScore(vector<int>& nums, vector<int>& dp, int i){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int score = INT_MIN;\\n        for(int j=1;j<=k;j++){\\n            score = max(score, nums[i]+maxScore(nums,dp,i+j));\\n        }\\n\\n        return dp[i] = score;\\n    }\\n    int maxResult(vector<int>& nums, int k) {\\n        n = nums.size();\\n        this->k = k;\\n        vector<int> dp(n,-1);\\n        return maxScore(nums,dp,0);\\n    }\\n};.`\\n"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "yeah same doubt did u find the error ?"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "Why the logic of picking the max in the next window , throws error. Like for k=2, if I pick i=2 as maximum then search through range [i + 1, min(n - 1, i + k)] i.e [3,5] and pick the max value in that range. If 5 contains the max value then start the next iteration [5,7] from the index =5. I wrote the code and it failed for this test case\\n\\n[-5582,-5317,6711,-639,1001,1845,1728,-4575,-6066,-7770,128,-3254,7281,3966,6857,5477,8968,-1771,9986,-6267,9010,-764,8413,-8154,1087,-1107,4183,3033,58,659,4625,2825,5031,6811,5657,3229,8597,-5772,8869,5723,2960,4040,7222,4841,-1014,581,-2830,3881,-3800,577,-7396,-611,-6944,8461,3294,6297,9713,-2246,-3441,3831,-5754,6716,6040,-6715,5763,8611,5412,-7630,6216,260,2595,6852,-8956,2101,6722,1579,3820,7827,-3369,7144,1974,7310,-5369,-6755,3010,5789,1563,-3330,5373,-2770,4503,-4065,8177,-3333,-4726,-2131,2763,9012,-4755,2382,3642,-5284,-7174,-9815,6392,9729,-1943,-8749,5343,1036,8508,1484,919,4225,3733,8036,-6346,-2088,475,9378,4271,-5906,9327,9399,-1582,3845,3499,-8912,-4671,-1143,-5081,-1621,-1287,5995,4963,5071,5118,-1966,-6249,663,-2296,-8148,-4668,-6919,334,-6609,2888,-4161,118,-1867,5629,8588,-5325,-7853,-4868,-1487,-6544,-9697,-7038,6422,-5545,3376,-8656,8800,-7698,-2928,2279,-9739,4198,6236,-9087,9010,-9894,2145,7353,-92,3205,5431,5913,1619,-250,4728,-7164,-5619,-4721,-9284,-9645,146,7131,-6501,4261,2016,2880,4944,-8768,-6339,-3574,539,4633,9188,7227,-1549,9271,7110,5706,4968,-1275,5545,-5844,-1985,9560,1560,4630,3169,6076,-9433,7007,9927,-8385,-4557,-114,9543,2884,8978,-6447,3664,-7499,-4643,-5993,-5321,3250,-2945,6216,-1606,5569,7326,-6027,9723,-6997,-543,-8298,-4647,2563,1493,9574,1087,-9433,-7749,-7159,-2682,6626,2787,-2845,-7907,-223,-8142,-5403,-3460,-2534,5289,999,9404,-1958,641,4669,-2892,-2921,-7001,-1403,-2353,-7976,-5885,4958,-8117,8785,-654,5918,5533,8704,5827,-7478,-3696,2640,1612,-500,5694,-1973,5308,5272,3358,9190,4648,-7836,658,-3407,6733,1061,-2010,-2707,-1920,1272,3944,-6537,-6090,-7429,-640,836,1904,-4031,814,-1886,8040,-8312,-9407,-1395,-9944,-2074,-6814,2672,1360,8990,5465,-2131,3838,799,-3472,1086,-583,6302,3032,9138,-7778,4538,-5337,2087,2870,-3005,3401,122,-819,-8074,9630,-698,5326,2650,-9355,6487,3801,-3209,8293,662,-8318,-7863,-3814,-2557,-5685,-7952,6224,-7010,2935,5557,-1287,9528,-9218,-5108,-2085,17,4870,-8686,-8854,-9657,8848,-1883,-4535,83,9711,4593,-3440,-6938,3407,-6894,-6213,-883,4552,-731,1485,-7740,-3300,3897,-7629,-4076,7589,3142,-1010,2466,-592,-391,3961,-7049,7654,5758,6983,6048,-4369,-5878,3756,2940,9149,8625,8937,5706,6658,9213,-5226,284,-4524,-1577,-5296,6423,9977,-1805,5462,7587,476,-6424,976,-3925,8819,1821,3603,-842,-9618,-7130,-6253,2562,-7596,3522,6282,-3801,-3896,6924,441,5944,8535,1253,-6154,6872,-9548,-5358,1604,9593,-9256,-701,1023,-1446,-1307,-6809,9542,3673,1813,8717,-6847,-5289,5222,-7266,4231,218,-9633,-4696,5494,9681,1173,-4606,2174,-1155,-8595,-3640,-6550,-7003,4244,-2543,5241,2831,2690,8950,-6609,-9724,7562,-4096,8878,9962,7179,-1170,7826,-146,-2759,-5249,253,6206,3205,-7708,9448,4622,9260,-2853,2486,122,-8880,-769,-8922,648,7358,-6503,-6382,-4260,3988,-5107,-6363,2415,8563,-9070,-5026,2078,-2558,-2027,-7489,-4978,5024,4155,-9737,-221,9930,-9472,1052,-268,6221,2726,-1310,-8708,3482,-5488,-6506,5389,-7048,553,-886,2752,85,-3938,5940,-5112,5855,-7295,3735,2657,3269,6231,4771,3229,-2009,-5748,7256,746,-4301,752,-241,-6151,-2390,9911,825,-7679,-4960,-7224,-2739,-566,-5770,6774,6243,3166,-783,-4303,-9016,5555,-1866,-536,8872,-3927,4269,-3807,1933,9972,981,9256,6857,-208,3645,-3725,5961,1105,6320,-4702,-8419,-4904,-4935,8378,-2994,5831,5296,4730,-9170,-4229,-3911,-160,8757,-5301,-3775,1121,9434,-9880,2689,2340,-7879,3667,-5219,-6116,-1670,7595,6900,3990,4444,6385,-2924,8968,-2673,-6182,7503,5209,6030,802,-3464,1922,-8187,1617,4769,-4866,-3518,5830,3862,-7512,5236,-5164,6324,-5107,6864,-7364,-1375,5762,-275,4975,-7448,5719,-3162,-1546,-2776,-9411,-1845,-4913,-3474,2550,5643,-5527,2946,7158,1938,5125,-8015,2475,-1461,-4900,-5151,-4031,9362,8571,9815,-8438,-6519,1980,-8031,9615,7079,-3573,-883,4217,1079,5918,1767,8670,-5651,-6625,1057,7897,-7104,-4186,851,-6333,-4108,-3250,7899,9628,-6904,-3939,4587,1227,3813,-7449,-7692,-8098,-9813,8862,-2888,-1048,-3564,3074,1437,-2291,3974,3164,4921,-8958,9007,-3938,2042,7454,-910,-998,-4450,-1103,-237,8182,-1391,-4255,-3482,-2918,4053,2280,-7403,4319,-9457,7157,-6315,-7533,6309,2211,-9145,443,4255,-8847,-5557,-9089,1752,-5784,-2399,-8296,-8400,8170,4628,-4583,937,-7067,-3503,-549,-1194,1576,5004,-6963,-8837,5567,870,3954,5489,-8949,-7673,8542,-9040,-7689,-4171,-889,5552,-6836,-4393,513,3177,6664,-5646,2492,9421,-342,2570,8816,2869,-6820,-3389,-1903,-3332,138,6618,293,-9130,3503,-2327,-9728,7632,5881,540,9678,-7629,8804,-2816,7205,7473,-5518,7311,3457,9066,-1224,2097,7857,6612,186,6759,-4516,-3491,-8268,-8928,-7412,7162,6274,5463,2157,-4131,-7061,-8476,-5584,7300,-4348,-5940,-8592,-302,-5817,3151,-4124,1694,-5114,-3252,-2319,-2157,-293,7724,-5673,6105,9535,4333,6353,1290,8710,-5035,8995,-5865,9746,4708,-6387,-8937,3096,-9716,-7124,2531,-660,-4619,-8035,3747,-7821,8793,-727,8242,4957,-7175,4064,-9911,4995,9725,1634,-4275,788,-4920,3831,-3525,-4467,2909,-1200,5377,-4905,-3077,-1763,4443,-3518,3134,-5595,5409,5943,6757,3485,2883,-9261,-7221,654,2001,-926,7840,-5568,2715,-7053,-2082,-2005,7607,-9511,7545,7564,2380,-7257,1449,-3918,-3240,-1928,-6555,-4784,1550,2745,-5316]\\nk=56"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "if you use a heap, this question is medium. if you use a monotonic queue, this is easily a hard ... whenever lc suggests heap, it seems like monotonic queue is usually always faster "
                    }
                ]
            }
        ]
    }
]