[
    {
        "title": "Remove Duplicates from Sorted List II",
        "question_content": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.\n&nbsp;\nExample 1:\n\nInput: head = [1,2,3,3,4,4,5]\nOutput: [1,2,5]\n\nExample 2:\n\nInput: head = [1,1,1,2,3]\nOutput: [2,3]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the list is in the range [0, 300].\n\t-100 <= Node.val <= 100\n\tThe list is guaranteed to be sorted in ascending order.",
        "solutions": [
            {
                "id": 28335,
                "title": "my-accepted-java-code",
                "content": "    public ListNode deleteDuplicates(ListNode head) {\\n            if(head==null) return null;\\n            ListNode FakeHead=new ListNode(0);\\n            FakeHead.next=head;\\n            ListNode pre=FakeHead;\\n            ListNode cur=head;\\n            while(cur!=null){\\n                while(cur.next!=null&&cur.val==cur.next.val){\\n                    cur=cur.next;\\n                }\\n                if(pre.next==cur){\\n                    pre=pre.next;\\n                }\\n                else{\\n                    pre.next=cur.next;\\n                }\\n                cur=cur.next;\\n            }\\n            return FakeHead.next;\\n        }",
                "solutionTags": [],
                "code": "    public ListNode deleteDuplicates(ListNode head) {\\n            if(head==null) return null;\\n            ListNode FakeHead=new ListNode(0);\\n            FakeHead.next=head;\\n            ListNode pre=FakeHead;\\n            ListNode cur=head;\\n            while(cur!=null){\\n                while(cur.next!=null&&cur.val==cur.next.val){\\n                    cur=cur.next;\\n                }\\n                if(pre.next==cur){\\n                    pre=pre.next;\\n                }\\n                else{\\n                    pre.next=cur.next;\\n                }\\n                cur=cur.next;\\n            }\\n            return FakeHead.next;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1395724,
                "title": "8-lines-c-solution-faster-than-100-submissions-for-beginners-explanation-of-approach",
                "content": "first make a dummy node and assign its value equals to 0 and its next points to the head of the given linked list.\\nalso make a prev node and point it to the dummy node.\\n***Always remember that a prev node is always required wherever we have to delete a node or we have to break links and create new links . this thing is very important for beginner coders for developing their intusions in future. That\\'s not a rule i have said it on the basis of my coding expirience***.\\nThen you have to traverse the linked list so run a while loop.\\ncheck that if the two adjacent nodes are equal or not if the two adjacent nodes are equal then traverse trhe linked list upto ehen the adjacent nodes are not identical.\\nThen directly connect the link from prev->next to the head->next.\\nWhile in other case is the adjacent nodes are not equal then simply traverse the linked list by prev=prev->next.\\n\\n\\n\\n\\n ListNode* deleteDuplicates(ListNode* head) {\\n       \\n        ListNode *dummy=new ListNode(0,head);\\n           ListNode *prev=dummy;\\n            \\n            while(head!=NULL){\\n           \\n            if(head->next!=NULL && head->val==head->next->val){\\n                    \\n    while(head->next!=NULL && head->val==head->next->val)head=head->next;\\n                         \\n                       \\n                            prev->next=head->next;\\n                    }\\n                    \\n                    else prev=prev->next;\\n                           \\n                   \\n                    head=head->next;\\n            }\\n            \\n            return dummy->next;\\n                \\n        }\\n\\t\\t\\n\\t\\t\\n\\t\\t//if(you_like_and_understand_my_solution)\\n\\t\\t//{\\n\\t\\t//  please_upvote++;\\n\\t\\t// }\\n\\t\\t\\n\\t\\t/*Guys plz plz plz upvote my solution if you really like and understand it.and if you stuck at any point then feel free to comment*/.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "first make a dummy node and assign its value equals to 0 and its next points to the head of the given linked list.\\nalso make a prev node and point it to the dummy node.\\n***Always remember that a prev node is always required wherever we have to delete a node or we have to break links and create new links . this thing is very important for beginner coders for developing their intusions in future. That\\'s not a rule i have said it on the basis of my coding expirience***.\\nThen you have to traverse the linked list so run a while loop.\\ncheck that if the two adjacent nodes are equal or not if the two adjacent nodes are equal then traverse trhe linked list upto ehen the adjacent nodes are not identical.\\nThen directly connect the link from prev->next to the head->next.\\nWhile in other case is the adjacent nodes are not equal then simply traverse the linked list by prev=prev->next.\\n\\n\\n\\n\\n ListNode* deleteDuplicates(ListNode* head) {\\n       \\n        ListNode *dummy=new ListNode(0,head);\\n           ListNode *prev=dummy;\\n            \\n            while(head!=NULL){\\n           \\n            if(head->next!=NULL && head->val==head->next->val){\\n                    \\n    while(head->next!=NULL && head->val==head->next->val)head=head->next;\\n                         \\n                       \\n                            prev->next=head->next;\\n                    }\\n                    \\n                    else prev=prev->next;\\n                           \\n                   \\n                    head=head->next;\\n            }\\n            \\n            return dummy->next;\\n                \\n        }\\n\\t\\t\\n\\t\\t\\n\\t\\t//if(you_like_and_understand_my_solution)\\n\\t\\t//{\\n\\t\\t//  please_upvote++;\\n\\t\\t// }\\n\\t\\t\\n\\t\\t/*Guys plz plz plz upvote my solution if you really like and understand it.and if you stuck at any point then feel free to comment*/.",
                "codeTag": "Unknown"
            },
            {
                "id": 28336,
                "title": "python-in-place-solution-with-dummy-head-node",
                "content": "        \\n    def deleteDuplicates(self, head):\\n        dummy = pre = ListNode(0)\\n        dummy.next = head\\n        while head and head.next:\\n            if head.val == head.next.val:\\n                while head and head.next and head.val == head.next.val:\\n                    head = head.next\\n                head = head.next\\n                pre.next = head\\n            else:\\n                pre = pre.next\\n                head = head.next\\n        return dummy.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def deleteDuplicates(self, head):\\n        dummy = pre = ListNode(0)\\n        dummy.next = head\\n        while head and head.next:\\n            if head.val == head.next.val:\\n                while head and head.next and head.val == head.next.val:\\n                    head = head.next\\n                head = head.next\\n                pre.next = head\\n            else:\\n                pre = pre.next\\n                head = head.next\\n        return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 28364,
                "title": "java-simple-and-clean-code-with-comment",
                "content": "    public class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n    \\t//use two pointers, slow - track the node before the dup nodes, \\n    \\t// fast - to find the last node of dups.\\n        ListNode dummy = new ListNode(0), fast = head, slow = dummy;\\n        slow.next = fast;\\n        while(fast != null) {\\n        \\twhile (fast.next != null && fast.val == fast.next.val) {\\n         \\t\\tfast = fast.next;    //while loop to find the last node of the dups.\\n        \\t}\\n        \\tif (slow.next != fast) { //duplicates detected.\\n        \\t\\tslow.next = fast.next; //remove the dups.\\n        \\t\\tfast = slow.next;     //reposition the fast pointer.\\n        \\t} else { //no dup, move down both pointer.\\n        \\t\\tslow = slow.next;\\n        \\t\\tfast = fast.next;\\n        \\t}\\n        \\t\\n        }\\n        return dummy.next;\\n    } }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n    \\t//use two pointers, slow - track the node before the dup nodes, \\n    \\t// fast - to find the last node of dups.\\n        ListNode dummy = new ListNode(0), fast = head, slow = dummy;\\n        slow.next = fast;\\n        while(fast != null) {\\n        \\twhile (fast.next != null && fast.val == fast.next.val) {\\n         \\t\\tfast = fast.next;    //while loop to find the last node of the dups.\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 28339,
                "title": "my-recursive-java-solution",
                "content": "    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) return null;\\n        \\n        if (head.next != null && head.val == head.next.val) {\\n            while (head.next != null && head.val == head.next.val) {\\n                head = head.next;\\n            }\\n            return deleteDuplicates(head.next);\\n        } else {\\n            head.next = deleteDuplicates(head.next);\\n        }\\n        return head;\\n    }\\n    \\n\\n\\nif current node is not unique, return deleteDuplicates with head.next. \\nIf current node is unique, link it to the result of next list made by recursive call. Any improvement?",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) return null;\\n        \\n        if (head.next != null && head.val == head.next.val) {\\n            while (head.next != null && head.val == head.next.val) {\\n                head = head.next;\\n            }\\n            return deleteDuplicates(head.next);\\n        } else {\\n            head.next = deleteDuplicates(head.next);\\n        }\\n        return head;\\n    }\\n    \\n\\n\\nif current node is not unique, return deleteDuplicates with head.next. \\nIf current node is unique, link it to the result of next list made by recursive call. Any improvement?",
                "codeTag": "Unknown"
            },
            {
                "id": 28355,
                "title": "simple-and-clear-c-recursive-solution",
                "content": "\\n\\n    class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            if (!head) return 0;\\n            if (!head->next) return head;\\n            \\n            int val = head->val;\\n            ListNode* p = head->next;\\n            \\n            if (p->val != val) {\\n                head->next = deleteDuplicates(p);\\n                return head;\\n            } else {\\n                while (p && p->val == val) p = p->next;\\n                return deleteDuplicates(p);\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            if (!head) return 0;\\n            if (!head->next) return head;\\n            \\n            int val = head->val;\\n            ListNode* p = head->next;\\n            \\n            if (p->val != val) {\\n                head->next = deleteDuplicates(p);\\n                return head;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2419088,
                "title": "very-easy-100-fully-explained-java-c-python-js-c-python3",
                "content": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.\\n# **Java Solution:**\\nRuntime: 1 ms, faster than 93.57% of Java online submissions for Remove Duplicates from Sorted List II.\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        // Special case...\\n        if (head == null || head.next == null)\\n            return head;\\n        // create a fake node that acts like a fake head of list pointing to the original head and it points to the original head......\\n        ListNode fake = new ListNode(0);\\n        fake.next = head;\\n        ListNode curr = fake;\\n        // Loop till curr.next and curr.next.next not null\\n        while(curr.next != null && curr.next.next != null){         // curr.next means the next node of curr pointer and curr.next.next means the next of next of curr pointer...\\n            // if the value of curr.next and curr.next.next is same...\\n            // There is a duplicate value present in the list...\\n            if(curr.next.val == curr.next.next.val) {\\n                int duplicate = curr.next.val;\\n                // If the next node of curr is not null and its value is eual to the duplicate value...\\n                while(curr.next !=null && curr.next.val == duplicate) {\\n                    // Skip those element and keep updating curr...\\n                    curr.next = curr.next.next;\\n                }\\n            }\\n            // Otherwise, move curr forward...\\n            else{\\n                curr = curr.next;\\n            }\\n        }\\n        return fake.next;       // Return the linked list...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\nRuntime: 6 ms, faster than 88.10% of C++ online submissions for Remove Duplicates from Sorted List II.\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // create a fake node that acts like a fake head of list pointing to the original head...\\n        ListNode* fake = new ListNode(0);\\n        // fake node points to the original head...\\n        fake->next = head;\\n        ListNode* pre = fake;     //pointing to last node which has no duplicate...\\n        ListNode* curr = head;      // To traverse the linked list...\\n        // Now we traverse nodes and do the process...\\n        while (curr != NULL) {\\n            // Create a loop until the current and previous values are same, keep updating curr...\\n            while (curr->next != NULL && pre->next->val == curr->next->val)\\n                curr = curr->next;\\n            // if curr has non-duplicate value, move the pre pointer to next node...\\n            if (pre->next == curr)\\n                pre = pre->next;\\n            // If curr is updated to the last duplicate value, discard it & connect pre and curr->next...\\n            else\\n                pre->next = curr->next;\\n                // Move curr forward...\\n                // In next iteration, we still need to check whether curr points to duplicate value...\\n                curr = curr->next;\\n        }\\n        // Return the linked list...\\n        return fake->next;\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\nRuntime: 28 ms, faster than 79.86% of Python online submissions for Remove Duplicates from Sorted List II.\\n```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        fake = ListNode(-1)\\n        fake.next = head\\n        # We use prev (for node just before duplications begins), curr (for the last node of the duplication group)...\\n        curr, prev = head, fake\\n        while curr:\\n            # while we have curr.next and its value is equal to curr...\\n            # It means, that we have one more duplicate...\\n            while curr.next and curr.val == curr.next.val:\\n                # So move curr pointer to the right...\\n                curr = curr.next\\n            # If it happens, that prev.next equal to curr...\\n            # It means, that we have only 1 element in the group of duplicated elements...\\n            if prev.next == curr:\\n                # Don\\'t need to delete it, we move both pointers to right...\\n                prev = prev.next\\n                curr = curr.next\\n            # Otherwise, we need to skip a group of duplicated elements...\\n            # set prev.next = curr.next, and curr = prev.next...\\n            else:\\n                prev.next = curr.next\\n                curr = prev.next\\n        # Return the linked list...\\n        return fake.next\\n```\\n        \\n# **JavaScript Solution:**\\nRuntime: 91 ms, faster than 67.42% of JavaScript online submissions for Remove Duplicates from Sorted List II.\\n```\\nvar deleteDuplicates = function(head) {\\n    // Special case...\\n    if (head == null || head.next == null)\\n        return head;\\n    // create a fake node that acts like a fake head of list pointing to the original head and it points to the original head......\\n    var fake = new ListNode(0);\\n    fake.next = head;\\n    var curr = fake;\\n    // Loop till curr.next and curr.next.next not null\\n    while(curr.next != null && curr.next.next != null){         // curr.next means the next node of curr pointer and curr.next.next means the next of next of curr pointer...\\n        // if the value of curr.next and curr.next.next is same...\\n        // There is a duplicate value present in the list...\\n        if(curr.next.val == curr.next.next.val) {\\n            let duplicate = curr.next.val;\\n            // If the next node of curr is not null and its value is eual to the duplicate value...\\n            while(curr.next !=null && curr.next.val == duplicate) {\\n                // Skip those element and keep updating curr...\\n                curr.next = curr.next.next;\\n            }\\n        }\\n        // Otherwise, move curr forward...\\n        else{\\n            curr = curr.next;\\n        }\\n    }\\n    return fake.next;       // Return the linked list...\\n};\\n```\\n\\n# **C Language:**\\n```\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    // create a fake node that acts like a fake head of list pointing to the original head...\\n    struct ListNode* fake = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    // fake node points to the original head...\\n    fake->next = head;\\n    struct ListNode* pre = fake;        //pointing to last node which has no duplicate...\\n    struct ListNode* curr = head;       // To traverse the linked list...\\n    // Now we traverse nodes and do the process...\\n    while (curr != NULL) {\\n        // Create a loop until the current and previous values are same, keep updating curr...\\n        while (curr->next != NULL && pre->next->val == curr->next->val)\\n            curr = curr->next;\\n        // if curr has non-duplicate value, move the pre pointer to next node...\\n        if (pre->next == curr)\\n            pre = pre->next;\\n        // If curr is updated to the last duplicate value, discard it & connect pre and curr->next...\\n        else\\n            pre->next = curr->next;\\n            // Move curr forward...\\n            // In next iteration, we still need to check whether curr points to duplicate value...\\n            curr = curr->next;\\n    }\\n    // Return the linked list...\\n    return fake->next;\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fake = ListNode(-1)\\n        fake.next = head\\n        # We use prev (for node just before duplications begins), curr (for the last node of the duplication group)...\\n        curr, prev = head, fake\\n        while curr:\\n            # while we have curr.next and its value is equal to curr...\\n            # It means, that we have one more duplicate...\\n            while curr.next and curr.val == curr.next.val:\\n                # So move curr pointer to the right...\\n                curr = curr.next\\n            # If it happens, that prev.next equal to curr...\\n            # It means, that we have only 1 element in the group of duplicated elements...\\n            if prev.next == curr:\\n                # Don\\'t need to delete it, we move both pointers to right...\\n                prev = prev.next\\n                curr = curr.next\\n            # Otherwise, we need to skip a group of duplicated elements...\\n            # set prev.next = curr.next, and curr = prev.next...\\n            else:\\n                prev.next = curr.next\\n                curr = prev.next\\n        # Return the linked list...\\n        return fake.next\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        // Special case...\\n        if (head == null || head.next == null)\\n            return head;\\n        // create a fake node that acts like a fake head of list pointing to the original head and it points to the original head......\\n        ListNode fake = new ListNode(0);\\n        fake.next = head;\\n        ListNode curr = fake;\\n        // Loop till curr.next and curr.next.next not null\\n        while(curr.next != null && curr.next.next != null){         // curr.next means the next node of curr pointer and curr.next.next means the next of next of curr pointer...\\n            // if the value of curr.next and curr.next.next is same...\\n            // There is a duplicate value present in the list...\\n            if(curr.next.val == curr.next.next.val) {\\n                int duplicate = curr.next.val;\\n                // If the next node of curr is not null and its value is eual to the duplicate value...\\n                while(curr.next !=null && curr.next.val == duplicate) {\\n                    // Skip those element and keep updating curr...\\n                    curr.next = curr.next.next;\\n                }\\n            }\\n            // Otherwise, move curr forward...\\n            else{\\n                curr = curr.next;\\n            }\\n        }\\n        return fake.next;       // Return the linked list...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // create a fake node that acts like a fake head of list pointing to the original head...\\n        ListNode* fake = new ListNode(0);\\n        // fake node points to the original head...\\n        fake->next = head;\\n        ListNode* pre = fake;     //pointing to last node which has no duplicate...\\n        ListNode* curr = head;      // To traverse the linked list...\\n        // Now we traverse nodes and do the process...\\n        while (curr != NULL) {\\n            // Create a loop until the current and previous values are same, keep updating curr...\\n            while (curr->next != NULL && pre->next->val == curr->next->val)\\n                curr = curr->next;\\n            // if curr has non-duplicate value, move the pre pointer to next node...\\n            if (pre->next == curr)\\n                pre = pre->next;\\n            // If curr is updated to the last duplicate value, discard it & connect pre and curr->next...\\n            else\\n                pre->next = curr->next;\\n                // Move curr forward...\\n                // In next iteration, we still need to check whether curr points to duplicate value...\\n                curr = curr->next;\\n        }\\n        // Return the linked list...\\n        return fake->next;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        fake = ListNode(-1)\\n        fake.next = head\\n        # We use prev (for node just before duplications begins), curr (for the last node of the duplication group)...\\n        curr, prev = head, fake\\n        while curr:\\n            # while we have curr.next and its value is equal to curr...\\n            # It means, that we have one more duplicate...\\n            while curr.next and curr.val == curr.next.val:\\n                # So move curr pointer to the right...\\n                curr = curr.next\\n            # If it happens, that prev.next equal to curr...\\n            # It means, that we have only 1 element in the group of duplicated elements...\\n            if prev.next == curr:\\n                # Don\\'t need to delete it, we move both pointers to right...\\n                prev = prev.next\\n                curr = curr.next\\n            # Otherwise, we need to skip a group of duplicated elements...\\n            # set prev.next = curr.next, and curr = prev.next...\\n            else:\\n                prev.next = curr.next\\n                curr = prev.next\\n        # Return the linked list...\\n        return fake.next\\n```\n```\\nvar deleteDuplicates = function(head) {\\n    // Special case...\\n    if (head == null || head.next == null)\\n        return head;\\n    // create a fake node that acts like a fake head of list pointing to the original head and it points to the original head......\\n    var fake = new ListNode(0);\\n    fake.next = head;\\n    var curr = fake;\\n    // Loop till curr.next and curr.next.next not null\\n    while(curr.next != null && curr.next.next != null){         // curr.next means the next node of curr pointer and curr.next.next means the next of next of curr pointer...\\n        // if the value of curr.next and curr.next.next is same...\\n        // There is a duplicate value present in the list...\\n        if(curr.next.val == curr.next.next.val) {\\n            let duplicate = curr.next.val;\\n            // If the next node of curr is not null and its value is eual to the duplicate value...\\n            while(curr.next !=null && curr.next.val == duplicate) {\\n                // Skip those element and keep updating curr...\\n                curr.next = curr.next.next;\\n            }\\n        }\\n        // Otherwise, move curr forward...\\n        else{\\n            curr = curr.next;\\n        }\\n    }\\n    return fake.next;       // Return the linked list...\\n};\\n```\n```\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    // create a fake node that acts like a fake head of list pointing to the original head...\\n    struct ListNode* fake = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    // fake node points to the original head...\\n    fake->next = head;\\n    struct ListNode* pre = fake;        //pointing to last node which has no duplicate...\\n    struct ListNode* curr = head;       // To traverse the linked list...\\n    // Now we traverse nodes and do the process...\\n    while (curr != NULL) {\\n        // Create a loop until the current and previous values are same, keep updating curr...\\n        while (curr->next != NULL && pre->next->val == curr->next->val)\\n            curr = curr->next;\\n        // if curr has non-duplicate value, move the pre pointer to next node...\\n        if (pre->next == curr)\\n            pre = pre->next;\\n        // If curr is updated to the last duplicate value, discard it & connect pre and curr->next...\\n        else\\n            pre->next = curr->next;\\n            // Move curr forward...\\n            // In next iteration, we still need to check whether curr points to duplicate value...\\n            curr = curr->next;\\n    }\\n    // Return the linked list...\\n    return fake->next;\\n}\\n```\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fake = ListNode(-1)\\n        fake.next = head\\n        # We use prev (for node just before duplications begins), curr (for the last node of the duplication group)...\\n        curr, prev = head, fake\\n        while curr:\\n            # while we have curr.next and its value is equal to curr...\\n            # It means, that we have one more duplicate...\\n            while curr.next and curr.val == curr.next.val:\\n                # So move curr pointer to the right...\\n                curr = curr.next\\n            # If it happens, that prev.next equal to curr...\\n            # It means, that we have only 1 element in the group of duplicated elements...\\n            if prev.next == curr:\\n                # Don\\'t need to delete it, we move both pointers to right...\\n                prev = prev.next\\n                curr = curr.next\\n            # Otherwise, we need to skip a group of duplicated elements...\\n            # set prev.next = curr.next, and curr = prev.next...\\n            else:\\n                prev.next = curr.next\\n                curr = prev.next\\n        # Return the linked list...\\n        return fake.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28334,
                "title": "is-this-the-best-c-solution",
                "content": "    class Solution {\\n    public:\\n        ListNode *deleteDuplicates(ListNode *head) {\\n            ListNode **runner = &head;\\n            \\n            if(!head || !head->next)return head;\\n            \\n            while(*runner)\\n            {\\n                if((*runner)->next && (*runner)->next->val == (*runner)->val)\\n                {\\n                    ListNode *temp = *runner;\\n                    while(temp && (*runner)->val == temp->val)\\n                        temp = temp->next;\\n                    \\n                    *runner = temp;\\n                }\\n                else\\n                    runner = &((*runner)->next);\\n            }\\n            \\n            return head;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *deleteDuplicates(ListNode *head) {\\n            ListNode **runner = &head;\\n            \\n            if(!head || !head->next)return head;\\n            \\n            while(*runner)\\n            {\\n                if((*runner)->next && (*runner)->next->val == (*runner)->val)\\n                {\\n                    ListNode *temp = *runner;\\n                    while(temp && (*runner)->val == temp->val)\\n                        temp = temp->next;\\n                    \\n                    *runner = temp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 28351,
                "title": "c-solution-simple-and-easy-to-understand",
                "content": "Simply check if the element is duplicate. If yes, record it and use a while loop to go to the next unique element.\\n\\n    class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            ListNode* dummy = new ListNode(0);\\n            dummy->next = head;\\n            ListNode* cur = dummy;\\n            int duplicate;\\n            while (cur->next && cur->next->next) {\\n                if (cur->next->val == cur->next->next->val) {\\n                    duplicate = cur->next->val;\\n                    while (cur->next && cur->next->val == duplicate) {\\n                        cur->next = cur->next->next;\\n                    }\\n                }\\n                else {\\n                    cur = cur->next;\\n                }\\n            }\\n            return dummy->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            ListNode* dummy = new ListNode(0);\\n            dummy->next = head;\\n            ListNode* cur = dummy;\\n            int duplicate;\\n            while (cur->next && cur->next->next) {\\n                if (cur->next->val == cur->next->next->val) {\\n                    duplicate = cur->next->val;\\n                    while (cur->next && cur->next->val == duplicate) {\\n                        cur->next = cur->next->next;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1002902,
                "title": "python-2-pointers-solution-explained",
                "content": "Idea here is to traverse our linked list and use two pointers:\\n\\n1. `slow` is for node just before duplications begins\\n2. `fast` is for the last node of duplication group.\\n\\nNow, we traverse nodes and do the following steps:\\n1. while we have `fast.next` and its value is equal to `fast`, it means, than we have one more duplicate, so we move `fast` pointer to the right.\\n2. If it happen, that `slow.next` equal to `fast`, it means, that we have only `1` element in group of duplicated elements, that is we do not need to delete it and we move both pointers to right.\\n3. If it happen, that `slow.next` is not equal to `fast`, it means, that we need to skip group of duplicated elements: we create new connection: `slow.next = fast.next`, and also we allocate `fast = slow.next`. Note, that now we still have the original property: `slow` points to node before group of duplicated elements and `fast` will be the last element of this group (after `while fast.next and fast.val == fast.next.val:` line)\\n\\n**Complexity**: time complexity is `O(n)`: we traverse our list at most twice for each of the pointers. Space complexity is `O(1)`: we did not use any additional memory here.\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head):\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        fast, slow = head, dummy\\n        while fast:\\n            while fast.next and fast.val == fast.next.val:\\n                fast = fast.next\\n            if slow.next == fast:\\n                slow, fast = slow.next, fast.next\\n            else:\\n                slow.next = fast.next\\n                fast = slow.next\\n                \\n        return dummy.next\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head):\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        fast, slow = head, dummy\\n        while fast:\\n            while fast.next and fast.val == fast.next.val:\\n                fast = fast.next\\n            if slow.next == fast:\\n                slow, fast = slow.next, fast.next\\n            else:\\n                slow.next = fast.next\\n                fast = slow.next\\n                \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165015,
                "title": "python3-simple-recursive-and-iterative-solution-with-figure-explanation",
                "content": "**Recursive**\\n- Idea\\n\\t- Base case: list is empty or contains only one element --> No duplicates\\n\\t- Recursive case: Assuming that the rest of the list is already done removing duplicates, we only need to consider the first part\\n\\t\\t- There\\'s no duplicate in the first part\\n\\t\\t\\t![image](https://assets.leetcode.com/users/images/490adbec-efbb-4f4e-87aa-feff28e37f78_1618746910.08464.png)\\n\\t\\t- There\\'re duplicates in the first part\\n\\t\\t\\t![image](https://assets.leetcode.com/users/images/7e0078bb-8da8-4ffe-a3ef-4f1c6748603f_1618747062.235478.png)\\n- Implementation\\n   ```python\\n   def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        # Base case\\n        if not head or not head.next:\\n            return head\\n        \\n        # Recursive case\\n        \\n        # No duplicate in the first part\\n        if head.next.val != head.val: \\n            head.next = self.deleteDuplicates(head.next)\\n            return head\\n        \\n        # Duplicates exist in the first part\\n        cur = head\\n        while cur.next and cur.next.val == cur.val:\\n            cur = cur.next\\n        return self.deleteDuplicates(cur.next)\\n   ```\\n   \\n- Complexity\\n\\t- Time: O(n)\\n\\t- Space: O(n)\\n\\n\\n\\n**Iterative**\\n- Idea\\n\\t- Add `dummy_head` before `head`. `dummy.next` is the first node of the list.\\n\\t\\t- Using `dummy_head` can help us to handle edge cases easily. For example, removing duplicate nodes at the beginning of list.\\n\\t- Use two pointers `prev` and `cur` for removing nodes\\n\\t- Iterate the list\\n\\t\\t- If there\\'s no duplicate, move `prev` and `cur` one step forward\\n\\t\\t- If there\\'re duplicate\\n\\t\\t\\t- Iterate `cur` to the last duplicate node\\n\\t\\t\\t- \"Jump over\" the duplicates \\n\\t\\t\\t\\t- `prev.next = cur.next` \\n\\t\\t\\t\\t- `cur = cur.next`\\n\\t\\t![image](https://assets.leetcode.com/users/images/b1eff2b9-24b8-47ac-9b09-88341cc0db64_1618752302.197709.png)\\n- Implementation\\n\\t```python\\n\\tdef deleteDuplicates(self, head: ListNode) -> ListNode:\\n        dummy_head = ListNode(next=head)\\n        prev, cur = dummy_head, head\\n        \\n        while cur and cur.next:\\n            if cur.val != cur.next.val:\\n                # If there\\'s no duplicate,\\n                # move prev and cur one step forward\\n                prev, cur = cur, cur.next\\n            else:\\n                # If there\\'re duplicates,\\n                # iterate cur to the last duplicate nodes,\\n                while cur.next and cur.val == cur.next.val:\\n                    cur = cur.next\\n                    \\n                # and jump over the duplicates\\n                prev.next = cur.next\\n                cur = cur.next\\n        \\n        return dummy_head.next\\n\\t```\\n\\t\\n- Complexity\\n\\t- Time: O(n)\\n\\t- Space: O(1)\\n\\n\\nIf you think this is helpful, please give it a vote.",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```python\\n   def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        # Base case\\n        if not head or not head.next:\\n            return head\\n        \\n        # Recursive case\\n        \\n        # No duplicate in the first part\\n        if head.next.val != head.val: \\n            head.next = self.deleteDuplicates(head.next)\\n            return head\\n        \\n        # Duplicates exist in the first part\\n        cur = head\\n        while cur.next and cur.next.val == cur.val:\\n            cur = cur.next\\n        return self.deleteDuplicates(cur.next)\\n   ```\n```python\\n\\tdef deleteDuplicates(self, head: ListNode) -> ListNode:\\n        dummy_head = ListNode(next=head)\\n        prev, cur = dummy_head, head\\n        \\n        while cur and cur.next:\\n            if cur.val != cur.next.val:\\n                # If there\\'s no duplicate,\\n                # move prev and cur one step forward\\n                prev, cur = cur, cur.next\\n            else:\\n                # If there\\'re duplicates,\\n                # iterate cur to the last duplicate nodes,\\n                while cur.next and cur.val == cur.next.val:\\n                    cur = cur.next\\n                    \\n                # and jump over the duplicates\\n                prev.next = cur.next\\n                cur = cur.next\\n        \\n        return dummy_head.next\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 28338,
                "title": "o-n-time-o-1-space-easiest-understanding",
                "content": "The idea is simple, we maintain two pointers, pre, cur in the given List. Pre pointer is always referring to one position before the cur pointer. When we found pre.val != cur.val && cur.val != cur.next.val, the node referred by cur pointer is a unique node. \\n\\n\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        ListNode dummy = new ListNode(0 == head.val ? 1 : 0); // to guarantee the dummy node is not same as the original head. \\n\\n        dummy.next = head;\\n        \\n        ListNode pre = dummy;\\n        ListNode cur = head;\\n\\n        ListNode first = dummy;  // the first node in the new unduplicated(result) list.\\n        \\n        while (cur != null && cur.next != null) {\\n            if (cur.val != pre.val && cur.val != cur.next.val) { // we found a unique node, we connect it at the tail of the unduplicated list, and update the first node.\\n                first.next = cur;\\n                first = first.next;\\n            }\\n            pre = cur;\\n            cur = cur.next;\\n        }\\n        \\n        if (pre.val != cur.val) { // the last node needs to be dealt with independently\\n            first.next = cur;\\n            first = first.next;\\n        }\\n        \\n        first.next = null; // the subsequent list is duplicate.\\n        \\n        return dummy.next;\\n    }",
                "solutionTags": [],
                "code": "The idea is simple, we maintain two pointers, pre, cur in the given List. Pre pointer is always referring to one position before the cur pointer. When we found pre.val != cur.val && cur.val != cur.next.val, the node referred by cur pointer is a unique node. \\n\\n\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        ListNode dummy = new ListNode(0 == head.val ? 1 : 0); // to guarantee the dummy node is not same as the original head. \\n\\n        dummy.next = head;\\n        \\n        ListNode pre = dummy;\\n        ListNode cur = head;\\n\\n        ListNode first = dummy;  // the first node in the new unduplicated(result) list.\\n        \\n        while (cur != null && cur.next != null) {\\n            if (cur.val != pre.val && cur.val != cur.next.val) { // we found a unique node, we connect it at the tail of the unduplicated list, and update the first node.\\n                first.next = cur;\\n                first = first.next;\\n            }\\n            pre = cur;\\n            cur = cur.next;\\n        }\\n        \\n        if (pre.val != cur.val) { // the last node needs to be dealt with independently\\n            first.next = cur;\\n            first = first.next;\\n        }\\n        \\n        first.next = null; // the subsequent list is duplicate.\\n        \\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 816387,
                "title": "simple-3-pointer-solution-8ms-c",
                "content": "* Faster than 93.08% (8ms)\\n* Memory usage less than 96.39% (10.8 MB)\\n\\n```\\nclass Solution\\n{\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head)\\n    {\\n        if(!head)\\n            return head;\\n        \\n        ListNode *prev=NULL, *curr=head, *next=curr->next;\\n        while(next)\\n        {\\n            if(curr->val == next->val)\\n            {\\n                while(next && next->val == curr->val)\\n                    next=next->next;\\n                if(!prev) // This condition means element at the head is repeating. So, head pointer needs to be shifted.\\n                    head=next;\\n                else\\n                    prev->next = next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n            }\\n            \\n            curr=next;\\n            if(next)\\n                next=curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n#### If you like the solution, do give it an upvote. In case of queries, feel free to leave them in the comment.\\n#### LeetCode and Chill !!!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head)\\n    {\\n        if(!head)\\n            return head;\\n        \\n        ListNode *prev=NULL, *curr=head, *next=curr->next;\\n        while(next)\\n        {\\n            if(curr->val == next->val)\\n            {\\n                while(next && next->val == curr->val)\\n                    next=next->next;\\n                if(!prev) // This condition means element at the head is repeating. So, head pointer needs to be shifted.\\n                    head=next;\\n                else\\n                    prev->next = next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n            }\\n            \\n            curr=next;\\n            if(next)\\n                next=curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28572,
                "title": "a-short-and-simple-java-solution",
                "content": "    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        ListNode d = dummy;\\n        while (head != null) {\\n            if (head.next != null && head.val == head.next.val) {\\n                while (head.next != null && head.val == head.next.val)\\n                    head = head.next;\\n            } else {\\n                d.next = head;\\n                d = d.next;\\n            }\\n            head = head.next;\\n        }\\n        d.next = null;\\n        return dummy.next;\\n    }\\n\\n1->1->1->2->2->3\\n\\nwe skip all the 1's and start the loop from 2\\n\\nand also skip all the 2's, and now head.val == 3;\\n\\nponit d.next to the tail, end the loop",
                "solutionTags": [],
                "code": "    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        ListNode d = dummy;\\n        while (head != null) {\\n            if (head.next != null && head.val == head.next.val) {\\n                while (head.next != null && head.val == head.next.val)\\n                    head = head.next;\\n            } else {\\n                d.next = head;\\n                d = d.next;\\n            }\\n            head = head.next;\\n        }\\n        d.next = null;\\n        return dummy.next;\\n    }\\n\\n1->1->1->2->2->3\\n\\nwe skip all the 1's and start the loop from 2\\n\\nand also skip all the 2's, and now head.val == 3;\\n\\nponit d.next to the tail, end the loop",
                "codeTag": "Unknown"
            },
            {
                "id": 1832481,
                "title": "c-detailed-explanation-w-actually-memory-delete-commented-code-easy-to-understand",
                "content": "***Brief note about Question-***\\n```\\nLet\\'s take an example not given-\\nSuppose our head given to us as head = -1 -> 0 -> 3 -> 4 -> 4 -> 4 -> 5 -> 5-> 6\\n\\nSince, 4 and 5 are repeating, so we delete that nodes, and our final answer looks like\\nhead = -1 -> 0 -> 3 -> 6\\n```\\n_____________\\n***Solution - I (Accepted)-***\\n* First we create a dummy node name as `prehead` whose next contains the` head` node.\\n* After that, we have to make a current pointer and moves that pointer in the our linked list.\\n* Suppose at  a point we find `curr ->next -> val == curr -> next -> next -> val`then we have to delete all nodes upto which they are having the same value.\\n* We actually delete that nodes from our linked list and free up memory.\\n* And lastly, as use of dummy node i.e our` prehead`, it\\'s next store our head node, so we return `prehead -> next.`\\n* Since, It is pretty straightforward to visuliaze the links how they works here, that\\'s why in this post i don\\'t include images.\\n* See code for more clarification.\\n________\\n**Code (C++)**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        //if head is NULL or just having a single node, simply return from here head \\n        if(head == NULL || head->next == NULL) \\n            return head;\\n        \\n        // creating our dummy node i.e prehead\\n        // we are giving it\\'s value is -101, because see constraints\\n        // -100 <= Node.val <= 100\\n        ListNode* prehead = new ListNode(-101);\\n        \\n        prehead -> next = head; // prehead\\'s next contain head\\n        \\n        ListNode* curr = prehead; // make a current pointer to move\\n        \\n        // while it not reaches to the end\\n        while(curr -> next != NULL && curr -> next -> next != NULL)\\n        {\\n            // if values are equal, now we have to delete values, till when they are equal\\n           if(curr -> next -> val == curr -> next -> next -> val)\\n           {\\n               // temp pointer to find upto when the va;ues are equal and delete that nodes which ar not be include in our answer\\n               ListNode* temp = curr -> next -> next;\\n               while(temp != NULL && curr -> next -> val == temp -> val)\\n               {\\n                   ListNode *anthortemp = temp;\\n                   temp = temp -> next;\\n                   delete anthortemp; // actually freeing up the memory\\n               }\\n               curr -> next = temp;\\n           }\\n           else // if values are not equal\\'s then simply move curr to next\\n           {\\n               curr = curr -> next;\\n           }\\n        }\\n        \\n        // and at last, prehead\\'s next contain head node, so return that\\n        return prehead -> next;\\n        \\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLet\\'s take an example not given-\\nSuppose our head given to us as head = -1 -> 0 -> 3 -> 4 -> 4 -> 4 -> 5 -> 5-> 6\\n\\nSince, 4 and 5 are repeating, so we delete that nodes, and our final answer looks like\\nhead = -1 -> 0 -> 3 -> 6\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        //if head is NULL or just having a single node, simply return from here head \\n        if(head == NULL || head->next == NULL) \\n            return head;\\n        \\n        // creating our dummy node i.e prehead\\n        // we are giving it\\'s value is -101, because see constraints\\n        // -100 <= Node.val <= 100\\n        ListNode* prehead = new ListNode(-101);\\n        \\n        prehead -> next = head; // prehead\\'s next contain head\\n        \\n        ListNode* curr = prehead; // make a current pointer to move\\n        \\n        // while it not reaches to the end\\n        while(curr -> next != NULL && curr -> next -> next != NULL)\\n        {\\n            // if values are equal, now we have to delete values, till when they are equal\\n           if(curr -> next -> val == curr -> next -> next -> val)\\n           {\\n               // temp pointer to find upto when the va;ues are equal and delete that nodes which ar not be include in our answer\\n               ListNode* temp = curr -> next -> next;\\n               while(temp != NULL && curr -> next -> val == temp -> val)\\n               {\\n                   ListNode *anthortemp = temp;\\n                   temp = temp -> next;\\n                   delete anthortemp; // actually freeing up the memory\\n               }\\n               curr -> next = temp;\\n           }\\n           else // if values are not equal\\'s then simply move curr to next\\n           {\\n               curr = curr -> next;\\n           }\\n        }\\n        \\n        // and at last, prehead\\'s next contain head node, so return that\\n        return prehead -> next;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28398,
                "title": "clean-python-solution-involving-dummy-node",
                "content": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        prev, curr = dummy, dummy.next\\n        \\n        while curr:\\n            if curr.next and curr.val == curr.next.val:\\n                val_to_rem = curr.val\\n                \\n                while curr and curr.val == val_to_rem:\\n                    curr = curr.next\\n                    \\n                prev.next = curr\\n                \\n            else:\\n                prev, curr = curr, curr.next\\n                \\n        return dummy.next",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        prev, curr = dummy, dummy.next\\n        \\n        while curr:\\n            if curr.next and curr.val == curr.next.val:\\n                val_to_rem = curr.val\\n                \\n                while curr and curr.val == val_to_rem:\\n                    curr = curr.next\\n                    \\n                prev.next = curr\\n                \\n            else:\\n                prev, curr = curr, curr.next\\n                \\n        return dummy.next",
                "codeTag": "Java"
            },
            {
                "id": 3224134,
                "title": "detailed-explanation-how-to-think-about-the-ques-100",
                "content": "# Intuition\\nTo solve this problem, we can use a dummy node and two pointers, current and previous. The dummy node serves as the head of the result linked list and helps us handle the case where the original head node needs to be removed. The current pointer moves through the linked list, checking for duplicates, and the previous pointer follows behind it, keeping track of the last distinct node.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We first create a dummy node with a value of 0 and set its next pointer to the original head node. We also initialize the prev and curr pointers to the dummy node and the head node, respectively.\\n- We then iterate through the linked list using the curr pointer, checking for duplicates with the curr.next node. If we find duplicates, we keep moving the curr pointer until we find the last duplicate node. We then update the prev.next pointer to point to the node after the last duplicate node.\\n- If we don\\'t find duplicates, we simply update the prev pointer to the curr node and move the curr pointer to its next node\\n- After iterating through the entire linked list, we return the next pointer of the dummy node, which points to the head of the resulting linked list.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n        if(head == NULL || head->next == NULL) return head;\\n\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* curr = head;\\n        ListNode* prev = dummy;\\n\\n        while(curr != NULL){\\n            if(curr->next != NULL && curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr= curr->next;\\n                }\\n                prev->next = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n            }\\n            curr = curr->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```\\n\\n![7abc56.jpg](https://assets.leetcode.com/users/images/53a2ee22-0977-4b5c-9768-f81d45e59bc2_1677219527.1926677.jpeg)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n        if(head == NULL || head->next == NULL) return head;\\n\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* curr = head;\\n        ListNode* prev = dummy;\\n\\n        while(curr != NULL){\\n            if(curr->next != NULL && curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr= curr->next;\\n                }\\n                prev->next = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n            }\\n            curr = curr->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565744,
                "title": "simple-c-iterative-solution-comments-97-faster",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // handle edge cases, if list is empty\\n        // or if it has one element, return it\\n        if (head == nullptr || head->next == nullptr) {\\n            return head;\\n        }\\n        \\n        // create an auxiliary head pointer\\n        // and a new iterator\\n        auto auxiliary_head = new ListNode(-1);\\n        auto iter = auxiliary_head;\\n        \\n        while (head != nullptr) {\\n            if (head->next && head->val == head->next->val) {\\n                // if current node value is equal to its next value\\n                // skip all nodes of that value\\n                int curr = head->val;\\n                while (head && head->val == curr) {\\n                    head = head->next;\\n                }\\n            } else {\\n                // otherwise, assign node to next iterator\\n                // increment new iterator and increment node\\n                iter->next = head;\\n                iter = iter->next;\\n                head = head->next;\\n            }\\n        }\\n        \\n        // we need to cut the cord\\n        iter->next = nullptr;\\n        \\n        // return new head\\n        return auxiliary_head->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // handle edge cases, if list is empty\\n        // or if it has one element, return it\\n        if (head == nullptr || head->next == nullptr) {\\n            return head;\\n        }\\n        \\n        // create an auxiliary head pointer\\n        // and a new iterator\\n        auto auxiliary_head = new ListNode(-1);\\n        auto iter = auxiliary_head;\\n        \\n        while (head != nullptr) {\\n            if (head->next && head->val == head->next->val) {\\n                // if current node value is equal to its next value\\n                // skip all nodes of that value\\n                int curr = head->val;\\n                while (head && head->val == curr) {\\n                    head = head->next;\\n                }\\n            } else {\\n                // otherwise, assign node to next iterator\\n                // increment new iterator and increment node\\n                iter->next = head;\\n                iter = iter->next;\\n                head = head->next;\\n            }\\n        }\\n        \\n        // we need to cut the cord\\n        iter->next = nullptr;\\n        \\n        // return new head\\n        return auxiliary_head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28371,
                "title": "javascript-iterative-solution",
                "content": "```\\nvar deleteDuplicates = function(head) {\\n    const dummy = new ListNode();\\n    dummy.next = head;\\n    let node = dummy;                                                  // the last known distinct node\\n    while (node.next) {\\n        if (node.next.next && node.next.val === node.next.next.val) {  // if the next two nodes are equal...\\n            let nonValNode = node.next.next.next;\\n            while (nonValNode && nonValNode.val === node.next.val) {   // ...find the first one that isn't...\\n                nonValNode = nonValNode.next;\\n            }\\n            node.next = nonValNode;                                    // ...and glue it to the last known distinct node;...\\n        } else {\\n            node = node.next;                                          // ...otherwise the next node is distinct\\n        }\\n    }\\n    return dummy.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteDuplicates = function(head) {\\n    const dummy = new ListNode();\\n    dummy.next = head;\\n    let node = dummy;                                                  // the last known distinct node\\n    while (node.next) {\\n        if (node.next.next && node.next.val === node.next.next.val) {  // if the next two nodes are equal...\\n            let nonValNode = node.next.next.next;\\n            while (nonValNode && nonValNode.val === node.next.val) {   // ...find the first one that isn't...\\n                nonValNode = nonValNode.next;\\n            }\\n            node.next = nonValNode;                                    // ...and glue it to the last known distinct node;...\\n        } else {\\n            node = node.next;                                          // ...otherwise the next node is distinct\\n        }\\n    }\\n    return dummy.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 560641,
                "title": "java-solution-short-simple",
                "content": "```\\n\\tpublic ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)return head;\\n    \\n        if(head.val != head.next.val){\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }\\n        \\n        while(head.next != null && head.val == head.next.val){\\n            head = head.next;\\n        }\\n        \\n        return deleteDuplicates(head.next);\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\tpublic ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)return head;\\n    \\n        if(head.val != head.next.val){\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }\\n        \\n        while(head.next != null && head.val == head.next.val){\\n            head = head.next;\\n        }\\n        \\n        return deleteDuplicates(head.next);\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28483,
                "title": "c-8ms-iterative-naive-but-easy-to-implement",
                "content": "It is my first post ever... Did not saw similar ones so I would like to share a naive way to implement this.\\nIdea is to set a flag, which indicates the current head should be added or not.\\n\\n    class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            if(!head||!head->next) return head;\\n            ListNode* dummy = new ListNode(0);\\n            ListNode* tail = dummy;\\n            int flag = true; // should the current head be added ?\\n            while(head){\\n                while(head&&head->next&&head->val==head->next->val)\\n                {\\n                    flag = false; // finds duplicate, set it to false\\n                    head = head->next;\\n                }\\n                if(flag) // if should be added\\n                {\\n                    tail->next = head;\\n                    tail = tail->next;\\n                }\\n                head = head->next;\\n                flag = true; // time for a new head value, set flag back to true\\n            }\\n            tail->next = nullptr; // Don't forget this... I did..\\n            return dummy->next;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            if(!head||!head->next) return head;\\n            ListNode* dummy = new ListNode(0);\\n            ListNode* tail = dummy;\\n            int flag = true; // should the current head be added ?\\n            while(head){\\n                while(head&&head->next&&head->val==head->next->val)\\n                {\\n                    flag = false; // finds duplicate, set it to false\\n                    head = head->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1833176,
                "title": "4ms-simple-c-easy",
                "content": "\\n```\\n  ListNode* deleteDuplicates(ListNode* head) \\n    {\\n        if(!head || !head->next)\\n        {\\n            return head;\\n        }\\n        \\n        int x=head->val;\\n        int y=head->next->val;\\n        \\n        if(x!=y)\\n        {\\n            head->next=deleteDuplicates(head->next);\\n        }\\n        else\\n        {\\n            while(head && x==head->val)\\n            {\\n                head=head->next;\\n            }\\n           return deleteDuplicates(head);\\n        }\\n     \\n        return head;\\n    }\\n\\t",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "\\n```\\n  ListNode* deleteDuplicates(ListNode* head) \\n    {\\n        if(!head || !head->next)\\n        {\\n            return head;\\n        }\\n        \\n        int x=head->val;\\n        int y=head->next->val;\\n        \\n        if(x!=y)\\n        {\\n            head->next=deleteDuplicates(head->next);\\n        }\\n        else\\n        {\\n            while(head && x==head->val)\\n            {\\n                head=head->next;\\n            }\\n           return deleteDuplicates(head);\\n        }\\n     \\n        return head;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1832645,
                "title": "c-efficient-short-easy-clean-solution-beginner-friendly",
                "content": "#### *please Upvote, if you Find its Helpful :)*\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp=new ListNode(0,head);//dummy node\\n        ListNode* prev=temp;\\n        \\n        while(head!=NULL){\\n            if(head->next!=NULL && head->val==head->next->val){\\n               while(head->next!=NULL && head->val==head->next->val){\\n                   head=head->next;\\n               }\\n                prev->next=head->next;\\n            }else{\\n                prev=prev->next;\\n            }\\n            head=head->next;\\n        }\\n        return temp->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp=new ListNode(0,head);//dummy node\\n        ListNode* prev=temp;\\n        \\n        while(head!=NULL){\\n            if(head->next!=NULL && head->val==head->next->val){\\n               while(head->next!=NULL && head->val==head->next->val){\\n                   head=head->next;\\n               }\\n                prev->next=head->next;\\n            }else{\\n                prev=prev->next;\\n            }\\n            head=head->next;\\n        }\\n        return temp->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832457,
                "title": "java-100-faster-solution-using-two-pointer",
                "content": "```class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n        ListNode prev=dummy;\\n        ListNode curr=head;\\n        while(curr!=null){\\n            if(curr.next!=null && curr.val==curr.next.val) {\\n                while(curr.next!=null && curr.val==curr.next.val){\\n                    curr=curr.next;\\n                }\\n               prev.next=curr.next;\\n            }\\n            else{\\n                prev=curr; \\n            }\\n            curr=curr.next;\\n        }\\n      return dummy.next;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n        ListNode prev=dummy;\\n        ListNode curr=head;\\n        while(curr!=null){\\n            if(curr.next!=null && curr.val==curr.next.val) {\\n                while(curr.next!=null && curr.val==curr.next.val){\\n                    curr=curr.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 28479,
                "title": "8ms-clean-c-code",
                "content": "This is not a hard problem, but it is also not very easy to make the code clean and neat.\\n\\n    class Solution {\\n        public:\\n            ListNode* deleteDuplicates(ListNode* head) {\\n                if( !head ) return NULL;\\n                ListNode* p = new ListNode(head->val-1), *ptr = p, *pre = p;\\n                while( head ) {\\n                    if( pre->val != head->val && (!head->next || head->next->val != head->val )) {\\n                        ptr->next = head;\\n                        ptr = ptr->next;\\n                    }\\n                    pre = head;\\n                    head = head->next;\\n                }\\n                ptr->next = NULL;\\n                return p->next;\\n            }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            ListNode* deleteDuplicates(ListNode* head) {\\n                if( !head ) return NULL;\\n                ListNode* p = new ListNode(head->val-1), *ptr = p, *pre = p;\\n                while( head ) {\\n                    if( pre->val != head->val && (!head->next || head->next->val != head->val )) {\\n                        ptr->next = head;\\n                        ptr = ptr->next;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2583544,
                "title": "easy-recursive-c-approach",
                "content": "In the recursive approach we\\'ll first set our base cases that if our *head* or *head -> next* is *NULL* then we simply return the head node as we have either a *NULL* or a Single Node in the Linked List.\\n\\nNow,\\nIf the value in head Node and the next Node is equal then using a while loop we\\'ll shift the head Node forward till the time two adjacent nodes have the same value \\n(i.e. till *head -> val == head -> next -> val*).\\n```\\n/*\\nFor example : 1 -> 1 -> 1 -> 2 -> 3 \\nInitially our head will point at the first Node containing the value 1.\\nAfter going through the loop the head will be pointing at the third Node that again contains 1 but the value of the next Node isn\\'t 1 so the loop will terminate .\\n*/\\n```\\nAt the end of the while loop it\\'s important to notice that we\\'ll currently be on the Node whose value was duplicated so we\\'ll call recursion on the next value of head and update our pre-existing head. \\n**head = deleteDuplicates(head -> next)**\\n\\nOtherwise if the value of head and the next node are different we\\'ll just simply update our  *head -> next* by calling recursion on it leaving our head Node preserved as it wasn\\'t duplicated. \\n **head -> next = deleteDuplicates(head -> next)**\\n\\nFinally we\\'ll return the head Node. \\n```\\nListNode* deleteDuplicates(ListNode* head) {\\n        \\n\\t// Base Case\\n    if(!head || !head -> next){\\n\\t\\treturn head;\\n     }\\n        \\n        int flag = head -> val;\\n        //If head is found duplicated\\n        if(head -> next -> val == flag){\\n            while(head -> next && head -> next -> val == flag){\\n               head = head -> next; \\n            }\\n            // Since head node is still the one which was duplicated calling recursion on next Node and updating current head\\n            head = deleteDuplicates(head -> next); \\n        }\\n        \\n        // If head isn\\'t duplicated\\n        else{\\n            //Leaving current head preserved and calling recursion from the next Node of list\\n            head -> next = deleteDuplicates(head -> next);\\n        }\\n        return head;\\n    }\\n\\t\\n\\t/*\\n\\tif(solution -> understandable){\\n\\t\\tupvote++;\\n\\t}\\n\\tPS : This is my first ever answer on leetcode hope you liked it. Please comment for suggestions and feedback :)\\n\\t*/\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/*\\nFor example : 1 -> 1 -> 1 -> 2 -> 3 \\nInitially our head will point at the first Node containing the value 1.\\nAfter going through the loop the head will be pointing at the third Node that again contains 1 but the value of the next Node isn\\'t 1 so the loop will terminate .\\n*/\\n```\n```\\nListNode* deleteDuplicates(ListNode* head) {\\n        \\n\\t// Base Case\\n    if(!head || !head -> next){\\n\\t\\treturn head;\\n     }\\n        \\n        int flag = head -> val;\\n        //If head is found duplicated\\n        if(head -> next -> val == flag){\\n            while(head -> next && head -> next -> val == flag){\\n               head = head -> next; \\n            }\\n            // Since head node is still the one which was duplicated calling recursion on next Node and updating current head\\n            head = deleteDuplicates(head -> next); \\n        }\\n        \\n        // If head isn\\'t duplicated\\n        else{\\n            //Leaving current head preserved and calling recursion from the next Node of list\\n            head -> next = deleteDuplicates(head -> next);\\n        }\\n        return head;\\n    }\\n\\t\\n\\t/*\\n\\tif(solution -> understandable){\\n\\t\\tupvote++;\\n\\t}\\n\\tPS : This is my first ever answer on leetcode hope you liked it. Please comment for suggestions and feedback :)\\n\\t*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1832725,
                "title": "c-easy-to-understand-iteration-simple",
                "content": "**82. Remove Duplicates from Sorted List II**\\n\\n#### **APPROACH -**\\n*Create a **dummyHead** with `dummyHead->next = head`\\nTraverse through the linked list with intially `isDuplicate = false`\\nMove through the nodes till same valued nodes present and update **isDuplicate**\\nSet the new links based on whether the current node is a duplicate\\nReturn **dummyHead->next***\\n</br>\\n#### **COMPLEXITY -**\\n* Time Complexity : O(N)\\n* Space Complexity : O(1)\\n</br>\\n#### **CODE -**\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *dummyHead = new ListNode(0, head);\\n        ListNode *prev = dummyHead, *curr = head;\\n        \\n        while(curr) {\\n            bool isDuplicate = false;\\n            while(curr->next && curr->val == curr->next->val) {\\n                isDuplicate = true;\\n                curr = curr->next;\\n            }\\n            if(isDuplicate)\\n                prev->next = curr->next;\\n            else\\n                prev = curr;\\n            curr = curr->next;\\n        }\\n\\t\\t\\n        return dummyHead->next;\\n    }\\n};\\n```\\n\\n**Please Upvote if it helps** \\u2B06\\uFE0F",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *dummyHead = new ListNode(0, head);\\n        ListNode *prev = dummyHead, *curr = head;\\n        \\n        while(curr) {\\n            bool isDuplicate = false;\\n            while(curr->next && curr->val == curr->next->val) {\\n                isDuplicate = true;\\n                curr = curr->next;\\n            }\\n            if(isDuplicate)\\n                prev->next = curr->next;\\n            else\\n                prev = curr;\\n            curr = curr->next;\\n        }\\n\\t\\t\\n        return dummyHead->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832310,
                "title": "c-easy-to-understand-recursion-simple",
                "content": "# 82. Remove Duplicates from Sorted List II\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Linked list problem, Recursion.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n[LeetCode](https://github.com/knockcat/Leetcode)       **LINK TO LEETCODE REPOSITORY**\\n``` ```\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**EXPLANATION**\\n\\n* **Traverse the list** from the **head** (or start) node.\\n* While traversing, **compare each node with its next node.**\\n* If the **data of the next node is the same as the current node** then **delete the next node.** \\n* **Before we delete a node**, we need to store the next pointer of the node.\\n\\n``` ```\\n\\n**TIME COMPLEXITY**  : O(N)  , *N is number of Nodes*\\n**SPACE COMPLEXITY** : O(1) \\n``` ```\\n\\n**CODE WITH EXPLANATION**\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\t\\t// if list contains no node\\n        if(!head)\\n            return 0;\\n\\t\\t//if list containg a single node return head\\n        if(!head -> next)\\n            return head;\\n        \\n\\t\\t// keepitn val of head in a temp variable var.\\n        int val = head ->val;\\n\\t\\t// temp contain the reference of next  node\\n        ListNode *temp = head -> next;\\n        \\n\\t\\t// if the next node have different value then,\\n\\t\\t// update head->next by temp(temp contains reference to next node)\\n        if(temp -> val != val)\\n        {\\n            head -> next = deleteDuplicates(temp);\\n            return head;\\n        }\\n        else\\n        {\\n\\t\\t\\t// if the values are same just update temp to temp->next;\\n           while(temp && temp -> val == val)\\n            {\\n\\t\\t\\t\\t// assigning temp to p \\n                ListNode *p = temp;\\n\\t\\t\\t\\t// updating temp with next node\\n                temp = temp->next;\\n\\t\\t\\t\\t// freeing the memory\\n                delete p;\\n            }\\n            return deleteDuplicates(temp);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Linked list problem, Recursion.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n``` ```\n``` ```\n``` ```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\t\\t// if list contains no node\\n        if(!head)\\n            return 0;\\n\\t\\t//if list containg a single node return head\\n        if(!head -> next)\\n            return head;\\n        \\n\\t\\t// keepitn val of head in a temp variable var.\\n        int val = head ->val;\\n\\t\\t// temp contain the reference of next  node\\n        ListNode *temp = head -> next;\\n        \\n\\t\\t// if the next node have different value then,\\n\\t\\t// update head->next by temp(temp contains reference to next node)\\n        if(temp -> val != val)\\n        {\\n            head -> next = deleteDuplicates(temp);\\n            return head;\\n        }\\n        else\\n        {\\n\\t\\t\\t// if the values are same just update temp to temp->next;\\n           while(temp && temp -> val == val)\\n            {\\n\\t\\t\\t\\t// assigning temp to p \\n                ListNode *p = temp;\\n\\t\\t\\t\\t// updating temp with next node\\n                temp = temp->next;\\n\\t\\t\\t\\t// freeing the memory\\n                delete p;\\n            }\\n            return deleteDuplicates(temp);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918883,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        let dummy: ListNode? = ListNode(-1)\\n        dummy?.next = head\\n\\n        var curr = dummy\\n        while let nextVal = curr?.next?.val, let nextNextVal = curr?.next?.next?.val {\\n            if nextVal == nextNextVal {\\n                let duplicate = nextVal\\n                while curr?.next != nil, curr?.next?.val == duplicate {\\n                    curr?.next = curr?.next?.next\\n                }\\n            } else {\\n                curr = curr?.next\\n            }\\n        }\\n\\n        return dummy?.next\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        let dummy: ListNode? = ListNode(-1)\\n        dummy?.next = head\\n\\n        var curr = dummy\\n        while let nextVal = curr?.next?.val, let nextNextVal = curr?.next?.next?.val {\\n            if nextVal == nextNextVal {\\n                let duplicate = nextVal\\n                while curr?.next != nil, curr?.next?.val == duplicate {\\n                    curr?.next = curr?.next?.next\\n                }\\n            } else {\\n                curr = curr?.next\\n            }\\n        }\\n\\n        return dummy?.next\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28438,
                "title": "my-python-solution-beats-91",
                "content": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        if head==None:\\n            return None\\n        \\n        dummy=ListNode(0)\\n        dummy.next=head\\n        \\n        cur=head\\n        prev=dummy\\n        \\n        dup=0\\n        \\n        while cur!=None and cur.next!=None:\\n            if cur.val==cur.next.val:\\n                cur=cur.next\\n                dup=1\\n            else:\\n                if dup==1:\\n                    prev.next=cur.next\\n                    cur=cur.next\\n                    dup=0\\n                else:\\n                    prev=cur\\n                    cur=cur.next\\n        if dup==1:\\n            prev.next=cur.next\\n            cur=cur.next\\n            \\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        if head==None:\\n            return None\\n        \\n        dummy=ListNode(0)\\n        dummy.next=head\\n        \\n        cur=head\\n        prev=dummy\\n        \\n        dup=0\\n        \\n        while cur!=None and cur.next!=None:\\n            if cur.val==cur.next.val:\\n                cur=cur.next\\n                dup=1\\n            else:\\n                if dup==1:\\n                    prev.next=cur.next\\n                    cur=cur.next\\n                    dup=0\\n                else:\\n                    prev=cur\\n                    cur=cur.next\\n        if dup==1:\\n            prev.next=cur.next\\n            cur=cur.next\\n            \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28487,
                "title": "recommend-for-beginners-c-implementation-with-detailed-explaination",
                "content": "At the first glance, we can use the similar code of the simpler problem : which only delete the duplicate ones, So if we want to delete all the duplicate ones including the copy. We can use  the dummy node and the pre pointer to jump over all the duplicate nodes.\\nThe Trap is that you may ignore that when we meet the no-duplicate numbers, we should do different op based the previous states. Just like state-machine.\\nAt last but not least important, we should delete the duplicate number occurs at the end . \\n\\n    class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            if(!head)   return NULL;\\n            ListNode* dummy=new ListNode(INT_MAX);\\n            dummy->next=head;\\n            ListNode* pre=dummy, *cur=head, *next=head->next;\\n            bool flag=false;\\n            while(next){\\n                if(next->val==cur->val){\\n                    flag=true;\\n                    next=next->next;\\n                }\\n                else{\\n                    if(flag) {\\n                        pre->next=next;\\n                        cur=next;\\n                        next=next->next;\\n                    }\\n                    else{\\n                        pre=pre->next;\\n                        cur=cur->next;\\n                        next=next->next;\\n                    }\\n                    flag=false;\\n                }\\n            }\\n            //the corner cases : if the duplicate number locates at the end \\n            if(flag) pre->next=next;\\n            return dummy->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            if(!head)   return NULL;\\n            ListNode* dummy=new ListNode(INT_MAX);\\n            dummy->next=head;\\n            ListNode* pre=dummy, *cur=head, *next=head->next;\\n            bool flag=false;\\n            while(next){\\n                if(next->val==cur->val){\\n                    flag=true;\\n                    next=next->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1003243,
                "title": "c-iterative-2-pointer-solution-explained-100-time-40-space",
                "content": "This problem is rather easy to solve with extra memory and possibly an extra pass; a better challenge comes from trying to trying to work under more constrained requirements.\\n\\nFirst of all we will declare a few support variables:\\n* `res` will be the base from which we will build our solution and will save us a bit of painful edge cases to otherwise consider, for the affordable cost of one extra node;\\n* `prev` and `iter` will be the 2 pointers we will use to parse and purge the list from duplicates;\\n* `currVal` is a convenience variable to store the currently parsed value.\\n\\nWe will attach `head` right after `res` and then move on with a main loop that will run as long as we have `prev && prev->next`, in which:\\n* we will prepare the ground for the next inner loop, setting `iter` right after `prev` and assigning `iter->val` to `currVal`;\\n* advance `iter` with our inner loop, as long as we still have `iter->next` and its value matches the one stored in `currVal`;\\n* we will then have 2 cases:\\n\\t* the loop never run, since we only have one node with `currVal` right after `prev`, so this very node will become our `prev` for the next iteration;\\n\\t* otherwise, it means we found multiple occurrences of the same value and then we will just have to slice them away frome the list: in the next iteration `prev` will stay the same (so, potentially it might always be just `res`) and its successor will be the next node with a different value than `currVal`.\\n\\nOnce we are done, we can return `res->next` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // support variables\\n        ListNode *res = new ListNode(-101), *prev = res, *iter = head;\\n        int currVal;\\n        // attaching res before head\\n        res->next = head;\\n        while (prev && prev->next) {\\n            // preparing for the inner loop\\n            iter = prev->next;\\n            currVal = iter->val;\\n            // advancing with all the similar values\\n            while (iter->next && iter->next->val == currVal) iter = iter->next;\\n            // case 1: only one node with currVal\\n            if (iter == prev->next || !iter) prev = iter;\\n            else prev->next = iter->next;\\n        }\\n        return res->next;\\n    }\\n};\\n```\\n\\nAnd since it just occurred to me that with my last version of the code `currVal` has little use, refactor without it - performance is clearly basically the same, despite saving a few bytes and assignments:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // support variables\\n        ListNode *res = new ListNode(-101), *prev = res, *iter = head;\\n        // attaching res before head\\n        res->next = head;\\n        while (prev && prev->next) {\\n            // preparing for the inner loop\\n            iter = prev->next;\\n            // advancing with all the similar values\\n            while (iter->next && iter->next->val == iter->val) iter = iter->next;\\n            // case 1: only one node with the same value\\n            if (iter == prev->next || !iter) prev = iter;\\n            // case 2: multiple nodes with the same value found\\n            else prev->next = iter->next;\\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // support variables\\n        ListNode *res = new ListNode(-101), *prev = res, *iter = head;\\n        int currVal;\\n        // attaching res before head\\n        res->next = head;\\n        while (prev && prev->next) {\\n            // preparing for the inner loop\\n            iter = prev->next;\\n            currVal = iter->val;\\n            // advancing with all the similar values\\n            while (iter->next && iter->next->val == currVal) iter = iter->next;\\n            // case 1: only one node with currVal\\n            if (iter == prev->next || !iter) prev = iter;\\n            else prev->next = iter->next;\\n        }\\n        return res->next;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // support variables\\n        ListNode *res = new ListNode(-101), *prev = res, *iter = head;\\n        // attaching res before head\\n        res->next = head;\\n        while (prev && prev->next) {\\n            // preparing for the inner loop\\n            iter = prev->next;\\n            // advancing with all the similar values\\n            while (iter->next && iter->next->val == iter->val) iter = iter->next;\\n            // case 1: only one node with the same value\\n            if (iter == prev->next || !iter) prev = iter;\\n            // case 2: multiple nodes with the same value found\\n            else prev->next = iter->next;\\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382651,
                "title": "standard-c-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe standard way to handle this use case is to use the so-called Sentinel Node. Sentinel nodes are widely used for trees and linked lists as pseudo-heads, pseudo-tails, etc. They are purely functional and usually don\\'t hold any data. Their primary purpose is to standardize the situation to avoid edge case handling.\\n\\nFor example, let\\'s use here pseudo-head with zero value to ensure that the situation \"delete the list head\" could never happen, and all nodes to delete are \"inside\" the list.\\n\\n# Complexity\\n- Time complexity: O(N)\\n    one linear traversing of the linked list\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n    Because not using any additonal space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* sentinel = new ListNode(0, head);\\n        ListNode* prev = sentinel;\\n        while(head){\\n            if(head->next and head->val == head->next->val){\\n                while(head->next and head->val == head->next->val){\\n                    head = head->next;\\n                }\\n                prev->next = head->next;\\n            }\\n            else{\\n                prev = prev->next;\\n            }\\n            head = head->next; \\n        }\\n        return sentinel->next;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* sentinel = new ListNode(0, head);\\n        ListNode* prev = sentinel;\\n        while(head){\\n            if(head->next and head->val == head->next->val){\\n                while(head->next and head->val == head->next->val){\\n                    head = head->next;\\n                }\\n                prev->next = head->next;\\n            }\\n            else{\\n                prev = prev->next;\\n            }\\n            head = head->next; \\n        }\\n        return sentinel->next;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185194,
                "title": "82-remove-duplicates-from-sorted-list-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create a dummy node dummy and set its next node as the head of the linked list.\\n2. Create a prev variable and initialize it with dummy.\\n3. Use a while loop to traverse the linked list while head and head.next are not None.\\n4. Check if the value of the current node head is equal to the value of the next node head.next.\\n5. If yes, then use another while loop to traverse the linked list and find all the duplicates.\\n6. Once all the duplicates are found, set head to head.next and update the next node of prev to head.\\n7. If the values are not equal, update the prev to prev.next and head to head.next.\\n8. Return dummy.next as the new head of the linked list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prev = dummy\\n        while head and head.next:\\n            if head.val == head.next.val:\\n                while head and head.next and head.val == head.next.val:\\n                    head = head.next\\n                head = head.next\\n                prev.next = head\\n            else:\\n                prev = prev.next\\n                head = head.next\\n        return dummy.next\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prev = dummy\\n        while head and head.next:\\n            if head.val == head.next.val:\\n                while head and head.next and head.val == head.next.val:\\n                    head = head.next\\n                head = head.next\\n                prev.next = head\\n            else:\\n                prev = prev.next\\n                head = head.next\\n        return dummy.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893347,
                "title": "100-fastest-typescript-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\\n  if (!head) { return null }\\n  if (!head.next) { return head }\\n  let fakeHead = new ListNode(undefined, head) // beginning of a returned linked list\\n  let prev = fakeHead // start of the group with same values\\n  let current = head // pointer\\n\\n  while (current) { // move through the current group until new value is seen\\n    while (current.next && prev.next && prev.next.val === current.next.val) { current = current.next }\\n\\n    if (prev.next === current) {\\n      prev = prev.next // if group has only one member, move prev to current\\n    } else {\\n      prev.next = current.next // otherwise, exclude the group\\n    }\\n\\n    current = current.next as ListNode // Move to the next node\\n  }\\n\\n  return fakeHead.next\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\\n  if (!head) { return null }\\n  if (!head.next) { return head }\\n  let fakeHead = new ListNode(undefined, head) // beginning of a returned linked list\\n  let prev = fakeHead // start of the group with same values\\n  let current = head // pointer\\n\\n  while (current) { // move through the current group until new value is seen\\n    while (current.next && prev.next && prev.next.val === current.next.val) { current = current.next }\\n\\n    if (prev.next === current) {\\n      prev = prev.next // if group has only one member, move prev to current\\n    } else {\\n      prev.next = current.next // otherwise, exclude the group\\n    }\\n\\n    current = current.next as ListNode // Move to the next node\\n  }\\n\\n  return fakeHead.next\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832665,
                "title": "python3-runtime-28-ms-faster-than-99-71-memory-13-8-mb-less-than-96-26",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        fake = ListNode(0, head)\\n        pred = fake\\n        while head:\\n            if head.next and head.val==head.next.val:\\n                while head.next and head.val==head.next.val:\\n                    head = head.next\\n                pred.next = head.next\\n            else: \\n\\t\\t\\t\\tpred = pred.next\\n            head = head.next\\n        return fake.next\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        fake = ListNode(0, head)\\n        pred = fake\\n        while head:\\n            if head.next and head.val==head.next.val:\\n                while head.next and head.val==head.next.val:\\n                    head = head.next\\n                pred.next = head.next\\n            else: \\n\\t\\t\\t\\tpred = pred.next\\n            head = head.next\\n        return fake.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003116,
                "title": "c-recursion-simple-straight-and-easy-to-understand-solution",
                "content": "```\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        if(head->val!=head->next->val){\\n            head->next=deleteDuplicates(head->next);\\n            return head;\\n        }\\n        int val=head->val;\\n        while(head && head->val==val)\\n            head=head->next;\\n        return deleteDuplicates(head);\\n    }\\n};\\n```\\n\\nTime Complexity:  O(n) where n is number of nodes in linked list.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        if(head->val!=head->next->val){\\n            head->next=deleteDuplicates(head->next);\\n            return head;\\n        }\\n        int val=head->val;\\n        while(head && head->val==val)\\n            head=head->next;\\n        return deleteDuplicates(head);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 588495,
                "title": "java-clear-explanation-of-question-and-logic-behind-the-answer",
                "content": "ok lets do this!!\\ni see a lot of people unabe to explain the question and the solution!\\nlet me first explain the question!!\\nquestion says to remove the duplicates from an sorted linked list!\\n(piece of advice-whenever you are given a sorted ds ,this is a hint that the question is easy....so dont think too much)\\nanyways lets see some ex:\\n1->2->2->3->3->4;\\nwe are required to remove ALL THE DUPLICATES ;\\nthus final list would be\\n1->4\\nand not\\n1->2->3->4;\\n\\nso lets go into the solution!\\nlike any other linked list problem lets take two pointer,\\none fast and one slow!\\nthe fast and slow both move one step at a time but fast is always ahead of slow as fast starts one node further than slow in the beginning!\\nLOGIC AND INTUITION:\\n\"thus the function of our fast node is to search for duplicates and wait for slow to catch up before moving any further!\\nin other words whenever fast detects a duplicate it would keep traversing till the last duplicate and then wait..\\nthe slow pointer will remove(delete) all the duplicate in the way and finally come to  fast node!\\nthis process continues till the fast encounters a null value indicating end of linkedl list\"\\n\\nINITIALLY WE ALSO NEED A DUMMY NODE SO THAT FAST IS ONE STEP AHEAD OF SLOW!\\n\\n```\\npublic class Solution {\\npublic ListNode deleteDuplicates(ListNode head) {\\n    ListNode dummy = new ListNode(0), fast = head, slow = dummy;\\n    slow.next = fast;\\n    while(fast != null) {\\n    \\twhile (fast.next != null && fast.val == fast.next.val) { // this loop basically takes fast to end of the current duplicates that we are tracking\\n     \\t\\tfast = fast.next;   \\n    \\t}\\n    \\tif (slow.next != fast) { \\n    \\t\\tslow.next = fast.next; //remove the duplicates.\\n    \\t\\tfast = slow.next;     //fast moves to next unique value .\\n    \\t} else { //no duplicates...lets move towards right!!.\\n    \\t\\tslow = slow.next;\\n    \\t\\tfast = fast.next;\\n    \\t}\\n    \\t\\n    }\\n    return dummy.next;\\n} }\\n\\n\\nhope it helps!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\npublic ListNode deleteDuplicates(ListNode head) {\\n    ListNode dummy = new ListNode(0), fast = head, slow = dummy;\\n    slow.next = fast;\\n    while(fast != null) {\\n    \\twhile (fast.next != null && fast.val == fast.next.val) { // this loop basically takes fast to end of the current duplicates that we are tracking\\n     \\t\\tfast = fast.next;   \\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 508337,
                "title": "java-easy-10-line-solution-with-explanation",
                "content": "```\\npublic ListNode deleteDuplicates(ListNode head) {\\n\\tif(head == null) return head;\\n\\tListNode dummy = new ListNode(0), pre = dummy, curr = head;\\n\\tpre.next = curr;\\n\\twhile(curr != null) {\\n\\t\\twhile(curr.next != null && curr.val == curr.next.val) \\n\\t\\t\\tcurr = curr.next;                   // curr goes to next node until it finds new val which is not same as prev one\\n\\t\\tif(pre.next == curr) pre = pre.next;    // no duplicate, so move pre to next node\\n\\t\\telse pre.next = curr.next;              // skip duplicate but don\\'t move pre\\n\\t\\tcurr = curr.next;                       // update curr\\n\\t}\\n\\treturn dummy.next;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode deleteDuplicates(ListNode head) {\\n\\tif(head == null) return head;\\n\\tListNode dummy = new ListNode(0), pre = dummy, curr = head;\\n\\tpre.next = curr;\\n\\twhile(curr != null) {\\n\\t\\twhile(curr.next != null && curr.val == curr.next.val) \\n\\t\\t\\tcurr = curr.next;                   // curr goes to next node until it finds new val which is not same as prev one\\n\\t\\tif(pre.next == curr) pre = pre.next;    // no duplicate, so move pre to next node\\n\\t\\telse pre.next = curr.next;              // skip duplicate but don\\'t move pre\\n\\t\\tcurr = curr.next;                       // update curr\\n\\t}\\n\\treturn dummy.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3905732,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* dummyNode = new ListNode(-1);\\n        dummyNode -> next = head;\\n        ListNode* curr = dummyNode;\\n\\n        while(curr->next!=nullptr&&curr->next->next!=nullptr){\\n            if(curr->next->val==curr->next->next->val){\\n                int duplicate = curr->next->val;\\n                while(curr->next!=nullptr&&curr->next->val==duplicate){\\n                    ListNode* temp = curr -> next;\\n                    curr -> next = curr->next->next;\\n                    delete temp;\\n                }\\n\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n\\n        }\\n        return dummyNode->next;\\n    }\\n};\\n```\\n\\n![i.jpg](https://assets.leetcode.com/users/images/5ee16cc9-1523-46bf-bcae-e384caf0092f_1691954059.9454777.webp)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* dummyNode = new ListNode(-1);\\n        dummyNode -> next = head;\\n        ListNode* curr = dummyNode;\\n\\n        while(curr->next!=nullptr&&curr->next->next!=nullptr){\\n            if(curr->next->val==curr->next->next->val){\\n                int duplicate = curr->next->val;\\n                while(curr->next!=nullptr&&curr->next->val==duplicate){\\n                    ListNode* temp = curr -> next;\\n                    curr -> next = curr->next->next;\\n                    delete temp;\\n                }\\n\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n\\n        }\\n        return dummyNode->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617877,
                "title": "both-the-solutions-fully-and-clearly-explained-1-iterative-solution-2-using-stl-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. For iterative solution, simply iterate the Linked List and check for duplicate nodes and delete them.\\n2. For STL solution, store the elements of the Linked List in the map and delete them if their frequency is greater than 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n***Solution 1:***\\n\\n1. Iterate the Linked List from one step back than the head, as it is possible that we need to delete the first element as well, and we know that **for deleting any node we require the previous node**.\\n2. Now just iterate the Linked List and store the current value of node in a variable named \\'variable\\' and till the subsequent elements == varible delete them.\\n3. If the above condition is not true, just move forward i.e., itr = itr -> next.\\n4. Finally return prev -> next (since our head of the list is stored in prev -> next pointer).\\n\\n\\n***Solution 2:***\\n\\n1. Iterate the Linked List and store the elements in a map named mp.\\n2. Create a new node \\'newHead\\' as the dummy head of the resulting Linked List.\\n3. Create a temporary pointer \\'temp\\' to keep treack of the last node in the resulting Linked List. Initalize it to \\'newHead\\'.\\n4. Iterate over the map, when (it.second == 1) create a new node \\'ans\\' with the value (it.first).\\n5. Connect the new node \\'ans\\' to the last node in the resulting Linked List by assigning \\'temp -> next = ans\\', and update \\'temp\\' to \\'ans\\' for the next iteration.\\n6. After processing all the unique values, the resulting Linked List is ready. Return \\'newHead -> next\\', which points to the first node in the resulting Linked List. \\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is O(n) for both the approaches.\\n\\n- Space complexity: \\n**Solution 1: O(1)\\n Solution 2: O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIn Solution 2 we are using map to store the unique values of the Linked List.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        if(head == NULL) return head;\\n\\n        ListNode* prev = new ListNode(); //this is pointing before head\\n        //Let\\'s say the list is 2 -> 2 -> 3 -> 5 -> 5 -> 5, in this case we have to delete the 1st element as well, therefore we have used prev pointer\\n        prev -> next = head;\\n\\n        ListNode* itr = prev;\\n\\n        while(itr -> next != NULL && itr -> next -> next != NULL)\\n        {\\n            if(itr -> next -> val == itr -> next -> next -> val)\\n            {\\n                int variable = itr -> next -> val;\\n                //We have to delete all the duplicate elements along with the original element\\n                while(itr -> next != NULL && itr -> next -> val == variable)\\n                {\\n                    itr -> next = itr -> next -> next;\\n                }\\n            }\\n            else //if we\\'ll not write else condition, we\\'ll get TLE\\n            {\\n                itr = itr -> next;\\n            }\\n        }\\n        return prev -> next; //head pointer is in prev -> next\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        map <int, int> mp;\\n\\n        while(head != NULL)\\n        {\\n            mp[head -> val]++;\\n            head = head -> next;\\n        }\\n\\n        ListNode* newHead = new ListNode(); //Creating new list for answer\\n        ListNode* temp = newHead; //temp variable to keep track of the last node\\n        for(auto & it: mp)\\n        {\\n            if(it.second == 1)\\n            {\\n                ListNode* ans = new ListNode(it.first); //to avoid integer to pointer conversion\\n                temp -> next = ans;\\n                temp = ans;\\n            }\\n        }\\n        return newHead -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        if(head == NULL) return head;\\n\\n        ListNode* prev = new ListNode(); //this is pointing before head\\n        //Let\\'s say the list is 2 -> 2 -> 3 -> 5 -> 5 -> 5, in this case we have to delete the 1st element as well, therefore we have used prev pointer\\n        prev -> next = head;\\n\\n        ListNode* itr = prev;\\n\\n        while(itr -> next != NULL && itr -> next -> next != NULL)\\n        {\\n            if(itr -> next -> val == itr -> next -> next -> val)\\n            {\\n                int variable = itr -> next -> val;\\n                //We have to delete all the duplicate elements along with the original element\\n                while(itr -> next != NULL && itr -> next -> val == variable)\\n                {\\n                    itr -> next = itr -> next -> next;\\n                }\\n            }\\n            else //if we\\'ll not write else condition, we\\'ll get TLE\\n            {\\n                itr = itr -> next;\\n            }\\n        }\\n        return prev -> next; //head pointer is in prev -> next\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        map <int, int> mp;\\n\\n        while(head != NULL)\\n        {\\n            mp[head -> val]++;\\n            head = head -> next;\\n        }\\n\\n        ListNode* newHead = new ListNode(); //Creating new list for answer\\n        ListNode* temp = newHead; //temp variable to keep track of the last node\\n        for(auto & it: mp)\\n        {\\n            if(it.second == 1)\\n            {\\n                ListNode* ans = new ListNode(it.first); //to avoid integer to pointer conversion\\n                temp -> next = ans;\\n                temp = ans;\\n            }\\n        }\\n        return newHead -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989127,
                "title": "100-faster-java-code-with-comments-for-better-understanding",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy =new ListNode(0,head);\\n        ListNode prev=dummy;\\n        while(head!=null){\\n            if(head.next!=null && head.val==head.next.val){\\n                //skip that nodes\\n                while(head.next!=null && head.val==head.next.val){\\n                    head=head.next;\\n                }\\n                prev.next=head.next;  //prev\\'s next point to the head next\\n            }else{\\n                prev=prev.next;\\n            }\\n            head=head.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\nif it is helpful upvote please",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy =new ListNode(0,head);\\n        ListNode prev=dummy;\\n        while(head!=null){\\n            if(head.next!=null && head.val==head.next.val){\\n                //skip that nodes\\n                while(head.next!=null && head.val==head.next.val){\\n                    head=head.next;\\n                }\\n                prev.next=head.next;  //prev\\'s next point to the head next\\n            }else{\\n                prev=prev.next;\\n            }\\n            head=head.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433787,
                "title": "js-o-n-time-o-1-space-with-explanation",
                "content": "Approach:\\nIn this problem, there are 3 cases to consider mainly\\n1. duplicates in the beginning - need to set a new `head`.\\n2. duplicates in between and at the end of the list.\\n3. unique value\\n\\nBasically, we start by checking values of the two adjacent nodes. If the values are equal (duplicates) -\\n1. for case 1, we did not have a prior node with unique value, the current node will basically be the first possible node encountered with a unique value (`possible` since after traversing further nodes, this node could also be having duplicate value). So we set this as the new node as head.\\n2. for case 2, we will have encountered a prior node with a unique value already, so we set the next pointer of that node as the current node.\\n3. for case 3, we set the prev node as the current node and move to the next node.\\n\\n```\\nvar deleteDuplicates = function(head) {\\n    let curr = head,\\n        prev = null;\\n    while(curr && curr.next) {\\n\\t\\t// if current node and next node value are same,\\n\\t\\t// iterate until we get to the node which does not have the same value as these 2 nodes\\n        if(curr.val === curr.next.val) {\\n            while(curr && curr.next && curr.val === curr.next.val) {\\n                curr = curr.next;\\n            }\\n\\t\\t\\t// the above loop will stop at the last duplicate node, for instance for 1,1,1,2,...\\n\\t\\t\\t// the loop will stop at 3rd node from start with value 1\\n\\t\\t\\t// so we move to next node which is not part of the previous set of duplicates\\n            curr = curr.next;\\n\\t\\t\\t\\n\\t\\t\\t// if no prev unique value node is encountered, set the `head` to this node\\n            if(!prev) {\\n                head = curr;\\n            } else {    // if there is a prev unique value node, reset it\\'s next pointer\\n\\t\\t\\t\\t// we do not change the prev node, since the current node itself can be having duplicate value\\n\\t\\t\\t\\t// so we will process the current node, until we identify it as having a unique value\\n                prev.next = curr;    \\n            }\\n        } else {    // node is having unique value\\n\\t\\t\\t// set prev as the current node and move to the next node\\n            prev = curr;\\n            curr = curr.next;    \\n        }\\n    }\\n    return head;    // finally return the head\\n};\\n```\\n\\nTime Complexity = O(n)\\nSpace Complexity = O(1)\\n\\nTest Cases for dry run:\\n```\\n[1,2,3,3,4,4,5]      // duplicates in between\\n[1,1,1,2,2,2,3,4]    // duplicates at the beginning\\n[1,2,3,4,4,4]        // duplicates at the end\\n[1,1,2,2,3,3]        // all duplicates\\n[]                   // empty list\\n[1]                  // only one node\\n[1,1]                // only two nodes (duplicates)\\n[1,2]                // only two nodes (no duplicates)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteDuplicates = function(head) {\\n    let curr = head,\\n        prev = null;\\n    while(curr && curr.next) {\\n\\t\\t// if current node and next node value are same,\\n\\t\\t// iterate until we get to the node which does not have the same value as these 2 nodes\\n        if(curr.val === curr.next.val) {\\n            while(curr && curr.next && curr.val === curr.next.val) {\\n                curr = curr.next;\\n            }\\n\\t\\t\\t// the above loop will stop at the last duplicate node, for instance for 1,1,1,2,...\\n\\t\\t\\t// the loop will stop at 3rd node from start with value 1\\n\\t\\t\\t// so we move to next node which is not part of the previous set of duplicates\\n            curr = curr.next;\\n\\t\\t\\t\\n\\t\\t\\t// if no prev unique value node is encountered, set the `head` to this node\\n            if(!prev) {\\n                head = curr;\\n            } else {    // if there is a prev unique value node, reset it\\'s next pointer\\n\\t\\t\\t\\t// we do not change the prev node, since the current node itself can be having duplicate value\\n\\t\\t\\t\\t// so we will process the current node, until we identify it as having a unique value\\n                prev.next = curr;    \\n            }\\n        } else {    // node is having unique value\\n\\t\\t\\t// set prev as the current node and move to the next node\\n            prev = curr;\\n            curr = curr.next;    \\n        }\\n    }\\n    return head;    // finally return the head\\n};\\n```\n```\\n[1,2,3,3,4,4,5]      // duplicates in between\\n[1,1,1,2,2,2,3,4]    // duplicates at the beginning\\n[1,2,3,4,4,4]        // duplicates at the end\\n[1,1,2,2,3,3]        // all duplicates\\n[]                   // empty list\\n[1]                  // only one node\\n[1,1]                // only two nodes (duplicates)\\n[1,2]                // only two nodes (no duplicates)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 338369,
                "title": "short-rust-solution",
                "content": "```rust\\npub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n    if head.is_none() { return head; }\\n\\n    let mut to_remove = head.as_ref().unwrap().val - 1;\\n    let mut dummy = Some(Box::new(ListNode { next: head, val: to_remove, }));\\n    let mut node = &mut dummy.as_mut().unwrap().next;\\n\\n    loop {\\n        match node {\\n            None => return dummy.unwrap().next,\\n            Some(n) if n.val == to_remove => *node = n.next.take(),\\n            Some(n) if n.next.is_some() && n.val == n.next.as_ref().unwrap().val => to_remove = n.val,\\n            Some(n) => {\\n                node = &mut n.next;\\n                if let Some(n) = node { to_remove = n.val - 1; }\\n            }\\n        }\\n    }\\n}\\n```\\nIt\\'s important to use pattern matching with conditions inside its branches, otherwise the ownership issues will drive you crazy.",
                "solutionTags": [],
                "code": "```rust\\npub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n    if head.is_none() { return head; }\\n\\n    let mut to_remove = head.as_ref().unwrap().val - 1;\\n    let mut dummy = Some(Box::new(ListNode { next: head, val: to_remove, }));\\n    let mut node = &mut dummy.as_mut().unwrap().next;\\n\\n    loop {\\n        match node {\\n            None => return dummy.unwrap().next,\\n            Some(n) if n.val == to_remove => *node = n.next.take(),\\n            Some(n) if n.next.is_some() && n.val == n.next.as_ref().unwrap().val => to_remove = n.val,\\n            Some(n) => {\\n                node = &mut n.next;\\n                if let Some(n) = node { to_remove = n.val - 1; }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048375,
                "title": "beginner-friendly-solution-hash-map-c-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp=head;\\n        ListNode* newlist=new ListNode();\\n        ListNode* temp2=newlist;\\n        map<int,int>m;\\n        while(temp)\\n        {\\n            m[temp->val]++;\\n            temp=temp->next;\\n        }\\n        for(auto i=m.begin();i!=m.end();i++)\\n        {\\n            if(i->second==1)\\n            {\\n                cout<<i->first<<endl;\\n                ListNode* node=new ListNode(i->first);\\n                temp2->next=node;\\n                temp2=temp2->next;\\n            }\\n        }\\n        return newlist->next;\\n    }\\n    \\n};\\n```\\n![c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg](https://assets.leetcode.com/users/images/98ecf9d3-1257-4ca7-9638-6b2afb6c4ce6_1694792835.9833024.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp=head;\\n        ListNode* newlist=new ListNode();\\n        ListNode* temp2=newlist;\\n        map<int,int>m;\\n        while(temp)\\n        {\\n            m[temp->val]++;\\n            temp=temp->next;\\n        }\\n        for(auto i=m.begin();i!=m.end();i++)\\n        {\\n            if(i->second==1)\\n            {\\n                cout<<i->first<<endl;\\n                ListNode* node=new ListNode(i->first);\\n                temp2->next=node;\\n                temp2=temp2->next;\\n            }\\n        }\\n        return newlist->next;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3212752,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Java Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) return null;\\n\\n        ListNode ans = new ListNode();\\n        ans.next = head;\\n\\n        ListNode ptr = ans;\\n\\n        while (ptr.next != null && ptr.next.next != null) {\\n\\n            if (ptr.next.val == ptr.next.next.val) {\\n                int value = ptr.next.val;\\n                while (ptr.next != null && ptr.next.val == value) {\\n                    ptr.next = ptr.next.next;\\n                }\\n            } else {\\n                ptr = ptr.next;\\n            }\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) return null;\\n\\n        ListNode ans = new ListNode();\\n        ans.next = head;\\n\\n        ListNode ptr = ans;\\n\\n        while (ptr.next != null && ptr.next.next != null) {\\n\\n            if (ptr.next.val == ptr.next.next.val) {\\n                int value = ptr.next.val;\\n                while (ptr.next != null && ptr.next.val == value) {\\n                    ptr.next = ptr.next.next;\\n                }\\n            } else {\\n                ptr = ptr.next;\\n            }\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124662,
                "title": "c-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        bool j = false;\\n        while (head->next!=NULL && head->val == head->next->val){\\n            j = true;\\n            head->next = head->next->next;\\n        }\\n        if (j){\\n            head = deleteDuplicates(head->next);\\n            return head;\\n        }\\n        head->next = deleteDuplicates(head->next);\\n        return head;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/34398cd7-c2e8-4957-8661-69f127428365_1654659184.92216.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        bool j = false;\\n        while (head->next!=NULL && head->val == head->next->val){\\n            j = true;\\n            head->next = head->next->next;\\n        }\\n        if (j){\\n            head = deleteDuplicates(head->next);\\n            return head;\\n        }\\n        head->next = deleteDuplicates(head->next);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834089,
                "title": "1-ms-java-solution-o-1-space-complexity-o-n-time-complexity",
                "content": "***STEPS :***\\n* Make two arrays of 100 length to keep the track of the count of ListNodes Value.\\n* Iterate the Linked List for counting .\\n* Create a dummy node and marks its next to head node.\\n* Create a temp node to iterate the linked list .\\n* Now while iterating check if nexts nodes count in the array is 1 or not if it is one then move to next node else move to next of next node .\\n* Return dummy\\'s next node\\n\\n\\n\\n**TIME COMPLEXITY ANALYSIS:**\\n* *TIME COMPLEXITY :* O(N) {For counting} + O(N) {For iterating the array} =O(2N)\\n* *SPACE COMPLEXITY :* O(1) {For keep track of count of Nodes value = O(1)\\n\\n\\n*Code for more understanding*\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        int pos [] = new int [101];\\n        int neg [] = new int [100];\\n        ListNode temp = head;\\n        while(temp!=null){\\n            if(temp.val>=0){\\n                pos[temp.val]++;\\n            }\\n            else{\\n                neg[Math.abs(temp.val)]++;\\n            }\\n            temp = temp.next;\\n        }\\n        ListNode dummy = new ListNode(-1);\\n        dummy .next = head;\\n        temp = dummy;\\n        while(temp.next!=null){\\n            \\n            if(temp.next.val>=0){\\n                if(pos[temp.next.val]!=1){\\n                    temp.next = temp.next.next;\\n                }\\n                else temp = temp.next;\\n            }\\n            else{\\n               if(neg[Math.abs(temp.next.val)]!=1){\\n                   temp.next = temp.next.next;\\n               } \\n                else temp = temp.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        int pos [] = new int [101];\\n        int neg [] = new int [100];\\n        ListNode temp = head;\\n        while(temp!=null){\\n            if(temp.val>=0){\\n                pos[temp.val]++;\\n            }\\n            else{\\n                neg[Math.abs(temp.val)]++;\\n            }\\n            temp = temp.next;\\n        }\\n        ListNode dummy = new ListNode(-1);\\n        dummy .next = head;\\n        temp = dummy;\\n        while(temp.next!=null){\\n            \\n            if(temp.next.val>=0){\\n                if(pos[temp.next.val]!=1){\\n                    temp.next = temp.next.next;\\n                }\\n                else temp = temp.next;\\n            }\\n            else{\\n               if(neg[Math.abs(temp.next.val)]!=1){\\n                   temp.next = temp.next.next;\\n               } \\n                else temp = temp.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833446,
                "title": "c-code-easy-explanation-w-commented-code-faster-than-100-00-easy-understanding",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\n\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n     //if head is NULL or just having a single node, simply return from here head \\n    if(head == NULL || head -> next == NULL)\\n        return head;\\n    \\n    // creating our dummy node i.e prehead\\n        // we are giving it\\'s value is -101, because see constraints\\n        // -100 <= Node.val <= 100\\n    struct ListNode* prehead = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    \\n    prehead -> val = -101;\\n    prehead -> next = head; // prehead\\'s next contain head\\n    \\n    struct ListNode* curr = prehead; // make a current pointer to move\\n    \\n    // while it not reaches to the end\\n    while(curr -> next != NULL && curr -> next -> next != NULL)\\n    {\\n        // if values are equal, now we have to delete values, till when they are equal\\n        if(curr -> next -> val == curr -> next -> next -> val)\\n        {\\n            struct ListNode* temp = curr -> next -> next;\\n            \\n            while(temp != NULL && curr -> next -> val == temp -> val)\\n            {\\n                struct ListNode* anthortemp = temp;\\n                temp = temp -> next;\\n                \\n                free(anthortemp); // actually freeing up the memory\\n            }\\n            \\n            curr -> next = temp;\\n            \\n        }\\n        else // if values are not equal\\'s then simply move curr to next\\n        {\\n            curr = curr -> next;\\n        }\\n    }\\n    \\n     // and at last, prehead\\'s next contain head node, so return that\\n    return prehead -> next;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\n\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n     //if head is NULL or just having a single node, simply return from here head \\n    if(head == NULL || head -> next == NULL)\\n        return head;\\n    \\n    // creating our dummy node i.e prehead\\n        // we are giving it\\'s value is -101, because see constraints\\n        // -100 <= Node.val <= 100\\n    struct ListNode* prehead = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    \\n    prehead -> val = -101;\\n    prehead -> next = head; // prehead\\'s next contain head\\n    \\n    struct ListNode* curr = prehead; // make a current pointer to move\\n    \\n    // while it not reaches to the end\\n    while(curr -> next != NULL && curr -> next -> next != NULL)\\n    {\\n        // if values are equal, now we have to delete values, till when they are equal\\n        if(curr -> next -> val == curr -> next -> next -> val)\\n        {\\n            struct ListNode* temp = curr -> next -> next;\\n            \\n            while(temp != NULL && curr -> next -> val == temp -> val)\\n            {\\n                struct ListNode* anthortemp = temp;\\n                temp = temp -> next;\\n                \\n                free(anthortemp); // actually freeing up the memory\\n            }\\n            \\n            curr -> next = temp;\\n            \\n        }\\n        else // if values are not equal\\'s then simply move curr to next\\n        {\\n            curr = curr -> next;\\n        }\\n    }\\n    \\n     // and at last, prehead\\'s next contain head node, so return that\\n    return prehead -> next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1833010,
                "title": "javascript-easy-to-understand-2-solutions-detailed-explanation",
                "content": "## Core Strategy\\n\\nThe important points for this problem are:\\n- the original linked list is sorted\\n- we need to remove all the duplicate number, rather than left one there\\n\\nSo, what we need to do is:\\n- find a way to check one value is duplicated or not\\n- traverse the linked list and remove the duplicate nodes\\n- make sure we can still get the head of the final linked list\\n\\nFor step 2, we just use loop to traverse the linked list.\\nFor step 3, we could use a dummy node as the new head, to let us easier remove the old head node if we need.\\nFor step 1, here are 2 solutions with extra space or not.\\n\\n## With extra space\\n\\nFor this solution, we use a hashtable to do the counting for values in linked list. Then traverse again and remove the nodes we don\\'t need.\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst deleteDuplicates = head => {\\n  const count = {};\\n  const dummy = { next: head };\\n  for (let cur = head; cur; cur = cur.next) {\\n    count[cur.val] = (count[cur.val] || 0) + 1;\\n  }\\n  for (let cur = dummy; cur.next;) {\\n    count[cur.next.val] > 1 ? (cur.next = cur.next.next) : (cur = cur.next);\\n  }\\n  return dummy.next;\\n};\\n```\\n\\n## Without extra space\\n\\nFor this solution, since we don\\'t want to use extra space, so we need to maintain 3 pointers - `prev`, `cur` and `next`. By this, we could compare the value and remove the nodes easily.\\n\\nI use the optional chaining operator (`?.`) in JS to avoid more checking logic.\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst deleteDuplicates = head => {\\n  const dummy = { next: head };\\n  let prev = dummy;\\n  let cur = head;\\n  let next = head?.next;\\n  while (next) {\\n    if (cur.val !== next.val) {\\n      prev = cur;\\n      cur = next;\\n      next = next.next;\\n    } else {\\n      const val = cur.val;\\n      while (next && next.val === val) {\\n        next = next.next;\\n      }\\n      cur = next;\\n      next = next?.next;\\n      prev.next = cur;\\n    }\\n  }\\n  return dummy.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst deleteDuplicates = head => {\\n  const count = {};\\n  const dummy = { next: head };\\n  for (let cur = head; cur; cur = cur.next) {\\n    count[cur.val] = (count[cur.val] || 0) + 1;\\n  }\\n  for (let cur = dummy; cur.next;) {\\n    count[cur.next.val] > 1 ? (cur.next = cur.next.next) : (cur = cur.next);\\n  }\\n  return dummy.next;\\n};\\n```\n```js\\nconst deleteDuplicates = head => {\\n  const dummy = { next: head };\\n  let prev = dummy;\\n  let cur = head;\\n  let next = head?.next;\\n  while (next) {\\n    if (cur.val !== next.val) {\\n      prev = cur;\\n      cur = next;\\n      next = next.next;\\n    } else {\\n      const val = cur.val;\\n      while (next && next.val === val) {\\n        next = next.next;\\n      }\\n      cur = next;\\n      next = next?.next;\\n      prev.next = cur;\\n    }\\n  }\\n  return dummy.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1706302,
                "title": "python3-easy-to-understand-recurrsion-faster-then-98",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n\\tif not head:\\n\\t\\treturn head\\n\\n\\tif not head.next:\\n\\t\\treturn head\\n\\n\\tif head.val != head.next.val:\\n\\t\\thead.next = self.deleteDuplicates(head.next)\\n\\t\\treturn head\\n\\n\\tif not head.next.next or head.next.val != head.next.next.val:\\n\\t\\treturn self.deleteDuplicates(head.next.next)\\n\\n\\n\\treturn self.deleteDuplicates(head.next) \\n```\\n\\n![image](https://assets.leetcode.com/users/images/18cd6f3e-253d-4785-8a74-937a33da5d5b_1642746179.505114.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n\\tif not head:\\n\\t\\treturn head\\n\\n\\tif not head.next:\\n\\t\\treturn head\\n\\n\\tif head.val != head.next.val:\\n\\t\\thead.next = self.deleteDuplicates(head.next)\\n\\t\\treturn head\\n\\n\\tif not head.next.next or head.next.val != head.next.next.val:\\n\\t\\treturn self.deleteDuplicates(head.next.next)\\n\\n\\n\\treturn self.deleteDuplicates(head.next) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003478,
                "title": "c-super-simple-easy-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *last = new ListNode(0), *new_head = last;\\n        \\n        while (head) {\\n            \\n            if (head->next && head->val == head->next->val) {\\n                while (head->next && head->val == head->next->val)\\n                    head = head->next;\\n            }\\n            \\n            else {\\n                last->next = head;\\n                last = head;\\n            }\\n            \\n            head = head->next;\\n        }\\n        \\n        last->next = NULL;\\n        return new_head->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *last = new ListNode(0), *new_head = last;\\n        \\n        while (head) {\\n            \\n            if (head->next && head->val == head->next->val) {\\n                while (head->next && head->val == head->next->val)\\n                    head = head->next;\\n            }\\n            \\n            else {\\n                last->next = head;\\n                last = head;\\n            }\\n            \\n            head = head->next;\\n        }\\n        \\n        last->next = NULL;\\n        return new_head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561149,
                "title": "c-mimimalizm",
                "content": "```cpp\\nListNode* deleteDuplicates(ListNode* head, bool dup = false) {\\n    if (head == nullptr)\\n        return nullptr;\\n    while (head->next != 0 && head->val == head->next->val) {\\n        dup = true;\\n        head->next = head->next->next;\\n    }\\n    head->next = deleteDuplicates(head->next);\\n    return dup ? head->next : head;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nListNode* deleteDuplicates(ListNode* head, bool dup = false) {\\n    if (head == nullptr)\\n        return nullptr;\\n    while (head->next != 0 && head->val == head->next->val) {\\n        dup = true;\\n        head->next = head->next->next;\\n    }\\n    head->next = deleteDuplicates(head->next);\\n    return dup ? head->next : head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28469,
                "title": "java-concise-iterative-solution",
                "content": "        \\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode p, dummy = new ListNode(0);\\n        p = dummy;\\n        dummy.next = head;\\n        while (head != null && head.next != null) {\\n            if (head.val == head.next.val) {\\n                while (head.next != null && head.val == head.next.val) {\\n                    head = head.next;\\n                }\\n                head = head.next;\\n                p.next = head;\\n            } else {\\n                head = head.next;\\n                p = p.next;\\n            }\\n        }\\n        return dummy.next;\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "        \\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode p, dummy = new ListNode(0);\\n        p = dummy;\\n        dummy.next = head;\\n        while (head != null && head.next != null) {\\n            if (head.val == head.next.val) {\\n                while (head.next != null && head.val == head.next.val) {\\n                    head = head.next;\\n                }\\n                head = head.next;\\n                p.next = head;\\n            } else {\\n                head = head.next;\\n                p = p.next;\\n            }\\n        }\\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 28390,
                "title": "a-easy-to-understand-python-solution",
                "content": "\\n\\n    def deleteDuplicates(self, head):\\n        # Add a dummy node point to the current list\\n        newhead = ListNode(0)\\n        newhead.next = head\\n        val_need_to_be_deleted = None\\n        tail = newhead\\n        \\n        while head:\\n            \\n            # Triger delete mode if current has the same val as the next\\n            if head and head.next and head.val == head.next.val:\\n                val_need_to_be_deleted = head.val\\n            \\n            # Not a dup if delete mode is off or the current value doesn't match the value need to be deleted\\n            if val_need_to_be_deleted == None or head.val != val_need_to_be_deleted:\\n                # add it to the newlist\\n                tail.next = head\\n                tail = head\\n                \\n            head = head.next\\n            \\n        tail.next = None\\n        return newhead.next",
                "solutionTags": [],
                "code": "\\n\\n    def deleteDuplicates(self, head):\\n        # Add a dummy node point to the current list\\n        newhead = ListNode(0)\\n        newhead.next = head\\n        val_need_to_be_deleted = None\\n        tail = newhead\\n        \\n        while head:\\n            \\n            # Triger delete mode if current has the same val as the next\\n            if head and head.next and head.val == head.next.val:\\n                val_need_to_be_deleted = head.val\\n            \\n            # Not a dup if delete mode is off or the current value doesn't match the value need to be deleted\\n            if val_need_to_be_deleted == None or head.val != val_need_to_be_deleted:\\n                # add it to the newlist\\n                tail.next = head\\n                tail = head\\n                \\n            head = head.next\\n            \\n        tail.next = None\\n        return newhead.next",
                "codeTag": "Python3"
            },
            {
                "id": 3142482,
                "title": "easy-c-solution-linked-list-two-pointer-best-solution-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Linklist + Two Pointer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approache by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity :O(N), because we are traversing over the elements exactly one. Thus the time complexity is linear.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(1), because we have used constant elements. Thus the space complexity is constant.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n\\n/*\\n\\n    Time Complexity :O(N), because we are traversing over the elements exactly one. Thus the time complexity is\\n    linear.\\n\\n    Space Complexity : O(1), because we have used constant elements. Thus the space complexity is constant.\\n\\n    Using Linklist + Two Pointer.\\n\\n*/\\n\\n\\n/********************************************* First Code *********************************************/\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr = curr->next;\\n                }\\n                if(prev == NULL){\\n                    head = curr->next;\\n                }\\n                else{\\n                    prev->next = curr->next;\\n                }\\n                curr = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/********************************************* Second Code *********************************************/\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        ListNode* dummyHead = new ListNode(-1);\\n        ListNode* dummyTail = dummyHead;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr = curr->next;\\n                }\\n                dummyTail->next = curr->next;\\n                curr = curr->next;\\n            }\\n            else{\\n                dummyTail->next = curr;\\n                dummyTail = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        return dummyHead->next;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/********************************************* Third Code *********************************************/\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        ListNode* dummyHead = new ListNode(-1);\\n        ListNode* dummyTail = dummyHead;\\n        dummyTail->next = curr;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr = curr->next;\\n                }\\n                dummyTail->next = curr->next;\\n                curr = curr->next;\\n            }\\n            else{\\n                dummyTail = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        return dummyHead->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n\\n/*\\n\\n    Time Complexity :O(N), because we are traversing over the elements exactly one. Thus the time complexity is\\n    linear.\\n\\n    Space Complexity : O(1), because we have used constant elements. Thus the space complexity is constant.\\n\\n    Using Linklist + Two Pointer.\\n\\n*/\\n\\n\\n/********************************************* First Code *********************************************/\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr = curr->next;\\n                }\\n                if(prev == NULL){\\n                    head = curr->next;\\n                }\\n                else{\\n                    prev->next = curr->next;\\n                }\\n                curr = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/********************************************* Second Code *********************************************/\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        ListNode* dummyHead = new ListNode(-1);\\n        ListNode* dummyTail = dummyHead;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr = curr->next;\\n                }\\n                dummyTail->next = curr->next;\\n                curr = curr->next;\\n            }\\n            else{\\n                dummyTail->next = curr;\\n                dummyTail = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        return dummyHead->next;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/********************************************* Third Code *********************************************/\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        ListNode* dummyHead = new ListNode(-1);\\n        ListNode* dummyTail = dummyHead;\\n        dummyTail->next = curr;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr = curr->next;\\n                }\\n                dummyTail->next = curr->next;\\n                curr = curr->next;\\n            }\\n            else{\\n                dummyTail = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        return dummyHead->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120308,
                "title": "sabse-easy-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head || !head -> next){\\n\\t\\treturn head;\\n     }\\n        \\n        int target = head -> val;\\n\\n        if(head -> next -> val == target){\\n            while(head -> next && head -> next -> val == target){\\n               head = head -> next; \\n            }\\n           \\n            head = deleteDuplicates(head -> next); \\n        }\\n        \\n      \\n        else{\\n            \\n            head -> next = deleteDuplicates(head -> next);\\n        }\\n        return head;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head || !head -> next){\\n\\t\\treturn head;\\n     }\\n        \\n        int target = head -> val;\\n\\n        if(head -> next -> val == target){\\n            while(head -> next && head -> next -> val == target){\\n               head = head -> next; \\n            }\\n           \\n            head = deleteDuplicates(head -> next); \\n        }\\n        \\n      \\n        else{\\n            \\n            head -> next = deleteDuplicates(head -> next);\\n        }\\n        return head;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066893,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* t=head;\\n        int c=1;\\n        ListNode* dummy=new ListNode(1);\\n        ListNode* ans=dummy;\\n        int f=1;\\n        while(f && t)\\n        {\\n            ListNode* p=t;\\n            int c=0;\\n            while(t->next && t->val==t->next->val)\\n            {\\n                c++;\\n                t=t->next;\\n            }\\n            if(c==0)\\n            {\\n                ans->next=p;\\n                ans=ans->next;\\n            }\\n            t=t->next;\\n        }\\n        ans->next=NULL;\\n        return dummy->next;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* t=head;\\n        int c=1;\\n        ListNode* dummy=new ListNode(1);\\n        ListNode* ans=dummy;\\n        int f=1;\\n        while(f && t)\\n        {\\n            ListNode* p=t;\\n            int c=0;\\n            while(t->next && t->val==t->next->val)\\n            {\\n                c++;\\n                t=t->next;\\n            }\\n            if(c==0)\\n            {\\n                ans->next=p;\\n                ans=ans->next;\\n            }\\n            t=t->next;\\n        }\\n        ans->next=NULL;\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035441,
                "title": "my-accepted-python-code",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        if head is not None:\\n            if head.next is not None:\\n                if head.val == head.next.val:\\n                    headTemp = self.deleteDuplicates(head.next)\\n                    if headTemp is not None:\\n                        if head.val == headTemp.val:\\n                            if headTemp is not None:\\n                                return headTemp.next\\n                            return None\\n                    return headTemp\\n                else:\\n                    head.next = self.deleteDuplicates(head.next)\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        if head is not None:\\n            if head.next is not None:\\n                if head.val == head.next.val:\\n                    headTemp = self.deleteDuplicates(head.next)\\n                    if headTemp is not None:\\n                        if head.val == headTemp.val:\\n                            if headTemp is not None:\\n                                return headTemp.next\\n                            return None\\n                    return headTemp\\n                else:\\n                    head.next = self.deleteDuplicates(head.next)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027773,
                "title": "javascript-solution-with-explanation-o-n-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code is defining a function deleteDuplicates that takes in a singly linked list head and removes any duplicate nodes from the list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere is an explanation of the code:\\n\\nFirst, a dummy node is created with a value of 0 and it is set as the next node of the dummy node. This dummy node will be used to track the head of the list as it is modified. prev is set to dummy and curr is set to head.\\n\\nA while loop is then entered that will continue until curr is null. Inside the loop, there is another while loop that will continue until curr.next is null or curr.val is not equal to curr.next.val. This inner loop is used to move curr to the last occurrence of a value that is duplicated in the list.\\n\\nAfter the inner loop, there is an if statement that checks if prev.next is equal to curr. If it is, this means that curr was not a duplicate and prev should be advanced to curr. If prev.next is not equal to curr, this means that curr was a duplicate and prev.next should be set to curr.next to skip over the duplicates.\\n\\nFinally, curr is advanced to curr.next and the process repeats until curr is null. The modified list, with duplicates removed, is then returned as dummy.next.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this function is O(n), because the function iterates through the linked list once, and performs a constant amount of work on each iteration.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is also O(1), because the function only stores a constant amount of data (the dummy node, the prev and curr pointers) regardless of the size of the input.\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n   let dummy = new ListNode(0)\\n    dummy.next = head;\\n    let prev = dummy, curr = head;\\n    while (curr) {\\n        while (curr.next && curr.val == curr.next.val)\\n            curr = curr.next\\n        if (prev.next == curr)\\n            prev = curr\\n        else\\n            prev.next = curr.next\\n        curr = curr.next\\n    }\\n    return dummy.next\\n\\n};\\n<!--I hope this helps!-->\\n<!--Please upvote if you like this solution-->\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code is defining a function deleteDuplicates that takes in a singly linked list head and removes any duplicate nodes from the list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere is an explanation of the code:\\n\\nFirst, a dummy node is created with a value of 0 and it is set as the next node of the dummy node. This dummy node will be used to track the head of the list as it is modified. prev is set to dummy and curr is set to head.\\n\\nA while loop is then entered that will continue until curr is null. Inside the loop, there is another while loop that will continue until curr.next is null or curr.val is not equal to curr.next.val. This inner loop is used to move curr to the last occurrence of a value that is duplicated in the list.\\n\\nAfter the inner loop, there is an if statement that checks if prev.next is equal to curr. If it is, this means that curr was not a duplicate and prev should be advanced to curr. If prev.next is not equal to curr, this means that curr was a duplicate and prev.next should be set to curr.next to skip over the duplicates.\\n\\nFinally, curr is advanced to curr.next and the process repeats until curr is null. The modified list, with duplicates removed, is then returned as dummy.next.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this function is O(n), because the function iterates through the linked list once, and performs a constant amount of work on each iteration.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is also O(1), because the function only stores a constant amount of data (the dummy node, the prev and curr pointers) regardless of the size of the input.\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n   let dummy = new ListNode(0)\\n    dummy.next = head;\\n    let prev = dummy, curr = head;\\n    while (curr) {\\n        while (curr.next && curr.val == curr.next.val)\\n            curr = curr.next\\n        if (prev.next == curr)\\n            prev = curr\\n        else\\n            prev.next = curr.next\\n        curr = curr.next\\n    }\\n    return dummy.next\\n\\n};\\n<!--I hope this helps!-->\\n<!--Please upvote if you like this solution-->\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2743244,
                "title": "beginner-level-to-optimised-solution",
                "content": "**1. Beginner Level -**\\n\\nIn this approach, we are using an auxliary space (HashMap and HashSet) to point out duplicates and in the HashSet we are not considering those duplicates.\\n\\nI can certainly tell that it is a very lengthy approach, but in an Interview, it is bit easy to come up with, if you have a good knowledge of HashMap & HashSet.\\n\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null) { return null; }\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        ListNode node = head;\\n        \\n        // Traversing the LL and making the Map such that we can point duplicates\\n        while(node != null){\\n            if(map.containsKey(node.val)) { map.put(node.val, 1); }\\n            else { map.put(node.val, 0); }\\n            node = node.next;\\n        }\\n        \\n        HashSet<Integer> finalNodeVals = new HashSet<>();\\n        for(int i : map.keySet()){\\n            if(map.get(i) == 0) { finalNodeVals.add(i); }\\n        }\\n        \\n        if(finalNodeVals.size() == 0) { return null; }\\n        \\n        ListNode node1 = head, finalHead = head;\\n        boolean first = true;\\n        \\n        while(node1 != null){\\n            if(finalNodeVals.contains(node1.val) && first == true) { \\n                head = node1; finalHead = head; first = false; \\n            }\\n            else if(finalNodeVals.contains(node1.val) && first == false) { \\n                head.next = node1; head = head.next;\\n            }\\n            node1 = node1.next;\\n        }\\n        \\n        head.next = null;\\n        \\n        return finalHead;\\n    }\\n}\\n```\\n\\n**Time Complexity = O(n)\\nSpace Complexity = O(n)**\\n\\n**2. Optimised Level :-**\\n\\nBelow is the algorithm for the problem - \\n\\n* Make three nodes `pre`, \\'ans\\' & `curr`.\\n* `pre` will be the previous node to the current node and `curr` will be the current node. \\'ans\\' will point to `pre` at first, and will stay there.\\n* While duplicates found in current node(`curr`), then move on to the next node.\\n* If we move on, then the `curr` will **NOT** certainly be the next node to the `pre` node.\\n* At this point of time `pre`\\'s next pointer will point to `curr`\\'s next pointer. This way we are linking the non-duplicate nodes togher.\\n* Else the `pre`\\'s  next pointer will point to `curr`. Also `pre` will move on by 1 node like `curr`.\\n* Move forward the curr.\\n* After traversing the entire list as `curr`, just return the next pointed node of `ans`, which is our answer.\\n\\nPlease practise it to get a better point of view.\\n\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode pre = new ListNode(0);\\n        pre.next = head;\\n        ListNode curr = head, ans = pre;\\n        \\n        while(curr != null){\\n            while(curr.next != null && curr.val == curr.next.val){\\n                curr = curr.next;\\n            }\\n            if(pre.next != curr){\\n                pre.next = curr.next;\\n            }\\n            else{\\n                pre.next = curr; pre = pre.next;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        return ans.next;\\n    }\\n}\\n```\\n\\n**Time Complexity: O(n)\\nSpace Complexity: O(1)**\\n\\nHappy Coding :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null) { return null; }\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        ListNode node = head;\\n        \\n        // Traversing the LL and making the Map such that we can point duplicates\\n        while(node != null){\\n            if(map.containsKey(node.val)) { map.put(node.val, 1); }\\n            else { map.put(node.val, 0); }\\n            node = node.next;\\n        }\\n        \\n        HashSet<Integer> finalNodeVals = new HashSet<>();\\n        for(int i : map.keySet()){\\n            if(map.get(i) == 0) { finalNodeVals.add(i); }\\n        }\\n        \\n        if(finalNodeVals.size() == 0) { return null; }\\n        \\n        ListNode node1 = head, finalHead = head;\\n        boolean first = true;\\n        \\n        while(node1 != null){\\n            if(finalNodeVals.contains(node1.val) && first == true) { \\n                head = node1; finalHead = head; first = false; \\n            }\\n            else if(finalNodeVals.contains(node1.val) && first == false) { \\n                head.next = node1; head = head.next;\\n            }\\n            node1 = node1.next;\\n        }\\n        \\n        head.next = null;\\n        \\n        return finalHead;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode pre = new ListNode(0);\\n        pre.next = head;\\n        ListNode curr = head, ans = pre;\\n        \\n        while(curr != null){\\n            while(curr.next != null && curr.val == curr.next.val){\\n                curr = curr.next;\\n            }\\n            if(pre.next != curr){\\n                pre.next = curr.next;\\n            }\\n            else{\\n                pre.next = curr; pre = pre.next;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118235,
                "title": "cpp-easy-solution",
                "content": "```class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* dummyNode=new ListNode(-1); \\n    dummyNode->next=head;//add a extra node so that we can check that whether the repeated num starts from first node or not.\\n    ListNode* curr=dummyNode;\\n    \\n    while(curr->next != NULL and curr->next->next != NULL){\\n        if(curr->next->val != curr->next->next->val){\\n          curr=curr->next;\\n        }\\n        else{\\n            int value=curr->next->val;\\n            \\n            while(curr->next and curr->next->val == value){ //Checking repetitions of the duplicate node\\n                curr->next=curr->next->next;\\n            }\\n        }\\n    }\\n    return dummyNode->next;\\n    }\\n};\\n```\\nPlease upvote if you like this solution .",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* dummyNode=new ListNode(-1); \\n    dummyNode->next=head;//add a extra node so that we can check that whether the repeated num starts from first node or not.\\n    ListNode* curr=dummyNode;\\n    \\n    while(curr->next != NULL and curr->next->next != NULL){\\n        if(curr->next->val != curr->next->next->val){\\n          curr=curr->next;\\n        }\\n        else{\\n            int value=curr->next->val;\\n            \\n            while(curr->next and curr->next->val == value){ //Checking repetitions of the duplicate node\\n                curr->next=curr->next->next;\\n            }\\n        }\\n    }\\n    return dummyNode->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832692,
                "title": "c-easy-to-understand-iterative-simple",
                "content": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Linked list problem, Recursion.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n```\\n\\n**EXPLANATION**\\n\\n\\n* **Traverse the list** from the **head** (or start) node.\\n* While traversing, **compare each node with its next node**.\\n* If the data of the next node is the **same** as the current node then **skip** the next node.(don\\'t add to answer)\\n* If node has **unique value add to answer**  \\n* Then we need **update** our pointers.\\n\\nTIME COMPLEXITY : O(N) , N is number of Nodes\\nSPACE COMPLEXITY : O(1)\\n\\n\\n\\n\\n\\n```\\nListNode* deleteDuplicates(ListNode* head) {\\n\\tif(!head || !head->next) return head; //base case\\n\\t\\n\\tListNode* prev,*start=head,*end=head;  // 3 pointers\\n\\tListNode* dummy=new ListNode();   // to handle corner case-> first element has duplicate\\n\\tprev=dummy;\\n\\t\\n\\twhile(end){\\n\\n\\t\\tif(end->next && end->val==end->next->val) {end=end->next; continue;} //skip duplicate\\n\\t\\t\\n\\t\\tif(!end->next && start!=end) {prev->next=NULL;break;} // to handle corner case-> last element has duplicate\\n\\t\\t\\n\\t\\tif(start==end) {prev->next=end, prev=prev->next;} //unique element add to answer\\n\\t\\t\\n\\t\\tstart=end->next, end=end->next; //update pointers\\n\\t}\\n\\t\\n\\treturn dummy->next; \\n}\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Linked list problem, Recursion.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n```\n```\\nListNode* deleteDuplicates(ListNode* head) {\\n\\tif(!head || !head->next) return head; //base case\\n\\t\\n\\tListNode* prev,*start=head,*end=head;  // 3 pointers\\n\\tListNode* dummy=new ListNode();   // to handle corner case-> first element has duplicate\\n\\tprev=dummy;\\n\\t\\n\\twhile(end){\\n\\n\\t\\tif(end->next && end->val==end->next->val) {end=end->next; continue;} //skip duplicate\\n\\t\\t\\n\\t\\tif(!end->next && start!=end) {prev->next=NULL;break;} // to handle corner case-> last element has duplicate\\n\\t\\t\\n\\t\\tif(start==end) {prev->next=end, prev=prev->next;} //unique element add to answer\\n\\t\\t\\n\\t\\tstart=end->next, end=end->next; //update pointers\\n\\t}\\n\\t\\n\\treturn dummy->next; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1832500,
                "title": "c-95-faster",
                "content": "![image](https://assets.leetcode.com/users/images/002a7e8a-8850-455a-bfad-c32c2e7efd6f_1646794760.4226303.png)\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL or head->next == NULL){\\n            return head;\\n        }\\n        ListNode * temp = head;\\n        ListNode * prev = new ListNode(-2);\\n        ListNode * head1 = prev;\\n        prev->next = head;\\n        int find = head->val;\\n        while(temp != NULL){\\n            if(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                while(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                    temp = temp->next;\\n                }\\n                prev->next = temp->next;\\n                temp = prev->next;\\n            }\\n            else{\\n                prev = prev->next;\\n                temp = temp->next;\\n                \\n            }\\n        }\\n        return head1->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL or head->next == NULL){\\n            return head;\\n        }\\n        ListNode * temp = head;\\n        ListNode * prev = new ListNode(-2);\\n        ListNode * head1 = prev;\\n        prev->next = head;\\n        int find = head->val;\\n        while(temp != NULL){\\n            if(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                while(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                    temp = temp->next;\\n                }\\n                prev->next = temp->next;\\n                temp = prev->next;\\n            }\\n            else{\\n                prev = prev->next;\\n                temp = temp->next;\\n                \\n            }\\n        }\\n        return head1->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640463,
                "title": "c-easy-to-undersand-efficient-code-3-approaches",
                "content": "**Approach 1**\\n**Iterative method**\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* sentinel=new ListNode(0);\\n        sentinel->next=head;\\n        ListNode* pred=sentinel;\\n        if(!head)\\n        return NULL;\\n        while(head)\\n        {\\n            if(head->next!=NULL&&head->val==head->next->val)\\n            {\\n            while(head->next!=NULL&&head->val==head->next->val)\\n            {\\n                head=head->next;\\n            }\\n                pred->next=head->next;\\n            }\\n            else\\n            {\\n                pred=pred->next;\\n            }\\n            head=head->next;\\n        }\\n        return sentinel->next;\\n    }\\n};\\n```\\n**Approach 2**\\n**Recurcive solution**\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n       if(!head)\\n       return NULL;\\n       if(!head->next)\\n       return head;\\n       int value=head->val;\\n        ListNode* curr=head->next;\\n        if(curr->val==value)\\n        {\\n            while(curr&&curr->val==value)\\n            {\\n                curr=curr->next;\\n            }\\n            return deleteDuplicates(curr);\\n        }\\n        else\\n        {\\n            head->next=deleteDuplicates(curr);\\n            return head;\\n        }\\n    }\\n};\\n```\\n**Approach 3**\\n**Creating new nodes**\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head)\\n        return NULL;\\n        unordered_map<int,int> freq;\\n        while(head)\\n        {\\n            freq[head->val]++;\\n            head=head->next;\\n        }\\n        vector<int> v;\\n        for(auto pr:freq)\\n        {\\n            if(pr.second==1)\\n            v.push_back(pr.first);\\n        }\\n        if(v.size()==0)\\n        return NULL;\\n        sort(v.begin(),v.end());\\n        ListNode* temp=new ListNode(v[0]);\\n        ListNode* p=temp;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            temp->next=new ListNode(v[i]);\\n            temp=temp->next;\\n        }\\n        temp->next=NULL;\\n        return p;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* sentinel=new ListNode(0);\\n        sentinel->next=head;\\n        ListNode* pred=sentinel;\\n        if(!head)\\n        return NULL;\\n        while(head)\\n        {\\n            if(head->next!=NULL&&head->val==head->next->val)\\n            {\\n            while(head->next!=NULL&&head->val==head->next->val)\\n            {\\n                head=head->next;\\n            }\\n                pred->next=head->next;\\n            }\\n            else\\n            {\\n                pred=pred->next;\\n            }\\n            head=head->next;\\n        }\\n        return sentinel->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n       if(!head)\\n       return NULL;\\n       if(!head->next)\\n       return head;\\n       int value=head->val;\\n        ListNode* curr=head->next;\\n        if(curr->val==value)\\n        {\\n            while(curr&&curr->val==value)\\n            {\\n                curr=curr->next;\\n            }\\n            return deleteDuplicates(curr);\\n        }\\n        else\\n        {\\n            head->next=deleteDuplicates(curr);\\n            return head;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head)\\n        return NULL;\\n        unordered_map<int,int> freq;\\n        while(head)\\n        {\\n            freq[head->val]++;\\n            head=head->next;\\n        }\\n        vector<int> v;\\n        for(auto pr:freq)\\n        {\\n            if(pr.second==1)\\n            v.push_back(pr.first);\\n        }\\n        if(v.size()==0)\\n        return NULL;\\n        sort(v.begin(),v.end());\\n        ListNode* temp=new ListNode(v[0]);\\n        ListNode* p=temp;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            temp->next=new ListNode(v[i]);\\n            temp=temp->next;\\n        }\\n        temp->next=NULL;\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215315,
                "title": "simple-and-clear-explanation-of-recursive-solution",
                "content": "Problem Statement:[https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/](http://)\\n\\n### How to  write a Recursive function?\\n*We have to follow three steps to write a*  **recursive code** \\n1.  **Assumption:**\\n* \\t  Assumption is nothing but what do you want your function to do.\\n2. **Main Logic:**\\n*     Solving problem using sub problems\\n3. **Base Condition:**\\n*     When recursion should terminate \\n\\n**Before diving into the solution lets understand the question**:\\n\\tThey have given a Linked list, we have to remove all the occurences of an element whose frequency is more than one and return the new linkedlist.\\n\\t![image](https://assets.leetcode.com/users/images/3fae7b24-93ab-4cfd-b452-de689684fa2f_1621272982.2501419.png)\\n\\t\\nIn the given linkedlist frequencies of 3 and 4 is 2, which is greater than 1, so we have to delete all the occurence of 3 and 4 then we have to return head node of new linked list.\\n\\n### Defining our three steps in recursion\\n**Assumption:** Remove all the occurences of an element whose frequency is more than one and return the linkedlist.\\n\\n**Main Logic:** Here we have two cases for a node either to consider it or not in final linkedlist.\\n*    **Case-1:** If we land on a node whose frequency is 1, then we should \\n      consider it and this node should point to the **nextnode** in the linkedlist\\n      whose frequency is 1, if we don\\'t find any node then it should point to NULL.\\n*   **Case-2:** If we land on a node whose frequency is more than 1, then \\n\\t  we have to ignore all the nodes of same value till we get **nextnode** whose \\n\\t  frequency is 1, if we don\\'t find any node then it should point to NULL.\\n\\t  \\n**BaseCondition**: \\n*    If we are at **Last node** then there is no need to check its frequency (because we are at lastnode there will be no nodes after it, so it\\'s frequency is one.) so we can simply return that node.\\n*    If the head node is NULL then we have to return.\\n\\n### Recursive Solution:\\n```\\nListNode* recursiveDeletion(ListNode*head){\\n\\t\\t//Base Conditions:\\n\\t\\tif(head==NULL || head->next==NULL)\\n\\t\\t\\treturn head;\\n\\t\\t\\t\\n\\t\\tbool flag=false //To check the given node is repeating or not.\\n\\t\\tint headValue=head->val;\\n\\t\\t\\n\\t\\tListNode*temp=head->next; //temporary pointer for itearating till we get\\n\\t\\t\\t\\t\\t\\t\\t\\t //a node whose data is not equal to headValue.\\n\\t\\twhile(temp!=NULL && temp->next==headValue){\\n\\t\\t\\tflag=true;\\n\\t\\t\\ttemp=temp->next; //shift to next node \\n\\t\\t}\\n\\t\\t//Now temp pointer points to a node whose value is different from headValue.\\n\\t\\t\\n\\t\\t// MAIN LOGIC: Case-2 (frequency more than 1)\\n\\t\\tif(flag==true){\\n\\t\\t\\treturn recursiveDeletion(temp);\\n\\t\\t\\t// we are not appending temp node to the previous node of head \\n            //because we don\\'t know whether temp node is repeating or not \\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\t//Case-1 ( frequency is 1)\\n\\t\\t\\thead->next= recursiveDeletion(head->next);\\n\\t\\t\\t// we are considering head in our linkedlist\\n\\t\\t\\t\\n\\t\\t\\treturn head;\\n\\t\\t\\t//******why should we return head?***********\\n\\t\\t\\t// beacuse we have to link head node to the prev node as we called\\n\\t\\t\\t//prev->next=recursiveDeletion(prev->next)  prev->next == head \\n            //as head is not repeating we have to return pointer of head.\\n\\t\\t\\t\\n\\t\\t\\t//head points to the nextnode return by the function it can either be\\n\\t\\t\\t // NULL or a node\\n\\t\\t\\t\\n\\t\\t}\\t\\n}\\n```\\n\\nIf you have any doubts feel free to ask in comment section\\n\\nThis is my first article tell me your review on this and where can I improve.\\n\\n\\n\\n\\t\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nListNode* recursiveDeletion(ListNode*head){\\n\\t\\t//Base Conditions:\\n\\t\\tif(head==NULL || head->next==NULL)\\n\\t\\t\\treturn head;\\n\\t\\t\\t\\n\\t\\tbool flag=false //To check the given node is repeating or not.\\n\\t\\tint headValue=head->val;\\n\\t\\t\\n\\t\\tListNode*temp=head->next; //temporary pointer for itearating till we get\\n\\t\\t\\t\\t\\t\\t\\t\\t //a node whose data is not equal to headValue.\\n\\t\\twhile(temp!=NULL && temp->next==headValue){\\n\\t\\t\\tflag=true;\\n\\t\\t\\ttemp=temp->next; //shift to next node \\n\\t\\t}\\n\\t\\t//Now temp pointer points to a node whose value is different from headValue.\\n\\t\\t\\n\\t\\t// MAIN LOGIC: Case-2 (frequency more than 1)\\n\\t\\tif(flag==true){\\n\\t\\t\\treturn recursiveDeletion(temp);\\n\\t\\t\\t// we are not appending temp node to the previous node of head \\n            //because we don\\'t know whether temp node is repeating or not \\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\t//Case-1 ( frequency is 1)\\n\\t\\t\\thead->next= recursiveDeletion(head->next);\\n\\t\\t\\t// we are considering head in our linkedlist\\n\\t\\t\\t\\n\\t\\t\\treturn head;\\n\\t\\t\\t//******why should we return head?***********\\n\\t\\t\\t// beacuse we have to link head node to the prev node as we called\\n\\t\\t\\t//prev->next=recursiveDeletion(prev->next)  prev->next == head \\n            //as head is not repeating we have to return pointer of head.\\n\\t\\t\\t\\n\\t\\t\\t//head points to the nextnode return by the function it can either be\\n\\t\\t\\t // NULL or a node\\n\\t\\t\\t\\n\\t\\t}\\t\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1175415,
                "title": "c-8ms-o-n-solution",
                "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n            return head;\\n        ListNode*prev=new ListNode(-101);\\n        prev->next=head;\\n        ListNode*temp=head;\\n        ListNode*temp2=new ListNode(-102);\\n        ListNode*h=temp2;\\n        while(temp->next!=NULL){\\n            if(temp->val!=prev->val && temp->val!=temp->next->val){\\n                if(temp2->val==-102){\\n                      temp2->val=temp->val;\\n                    h=temp2;\\n                }\\n                \\n                else{\\n                     ListNode*node=new ListNode(temp->val);\\n                   temp2->next=node;\\n                temp2=node;   \\n                }\\n              \\n            }\\n            temp=temp->next;\\n            prev=prev->next;\\n        }\\n           if(temp->val!=prev->val){\\n                if(temp2->val==-102){\\n                      temp2->val=temp->val;\\n                    h=temp2;\\n                }\\n                \\n                else{\\n                     ListNode*node=new ListNode(temp->val);\\n                   temp2->next=node;\\n                temp2=node;   \\n                }\\n              \\n            }\\n        temp2->next=NULL;\\n        if(h->val==-102)\\n            return NULL;\\n        return h;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n            return head;\\n        ListNode*prev=new ListNode(-101);\\n        prev->next=head;\\n        ListNode*temp=head;\\n        ListNode*temp2=new ListNode(-102);\\n        ListNode*h=temp2;\\n        while(temp->next!=NULL){\\n            if(temp->val!=prev->val && temp->val!=temp->next->val){\\n                if(temp2->val==-102){\\n                      temp2->val=temp->val;\\n                    h=temp2;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 805304,
                "title": "both-recursive-and-iterative-c",
                "content": "\\n         //iterative\\n\\t\\t \\n        class Solution {\\n        public:\\n            ListNode* deleteDuplicates(ListNode* head) {\\n                if(head==NULL ||head->next==NULL)\\n                    return head;\\n                ListNode *tail= new ListNode(-1);\\n                ListNode* newhead=tail;\\n                while(head!=NULL){\\n                    if(head->next!=NULL && head->val==head->next->val){\\n                        int curr=head->val;\\n                        head=head->next;\\n                        while(head && head->val==curr)\\n                            head=head->next;\\n                    }else{\\n                        tail->next=head;\\n                        tail=tail->next;\\n                        head=head->next;\\n                    }\\n                }\\n                tail->next=NULL;\\n                return newhead->next;\\n            }\\n        };\\n\\t\\t\\n\\t\\t//recursive\\n\\t\\t\\n\\t\\tclass Solution {\\n        public:\\n            ListNode* deleteDuplicates(ListNode* head) {\\n                if(head==nullptr) return head;\\n                ListNode* p1=head->next;\\n                if(p1 && p1->val==head->val){\\n                 while(p1 && p1->val==head->val) {\\n                     p1=p1->next;\\n                 }\\n                    return deleteDuplicates(p1);\\n                }\\n                else \\n                head->next = deleteDuplicates(head->next);\\n                return head;\\n            } \\n        };\\n\\t\\t\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public:\\n            ListNode* deleteDuplicates(ListNode* head) {\\n                if(head==NULL ||head->next==NULL)\\n                    return head;\\n                ListNode *tail= new ListNode(-1);\\n                ListNode* newhead=tail;\\n                while(head!=NULL){\\n                    if(head->next!=NULL && head->val==head->next->val){\\n                        int curr=head->val;\\n                        head=head->next;\\n                        while(head && head->val==curr)\\n                            head=head->next;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 509070,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        if not head:\\n            return \\n        ret = pre = ListNode(0)\\n        ret.next = cur = head\\n        while(cur.next):\\n            nxt = cur.next\\n            if cur.val == nxt.val:\\n                while(nxt.next and nxt.val == nxt.next.val):\\n                    nxt = nxt.next\\n                pre.next = cur = nxt.next\\n                if not cur: return ret.next\\n            else:\\n                pre,cur,nxt = cur,nxt,nxt.next\\n            \\n            \\n        return ret.next\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        if not head:\\n            return \\n        ret = pre = ListNode(0)\\n        ret.next = cur = head\\n        while(cur.next):\\n            nxt = cur.next\\n            if cur.val == nxt.val:\\n                while(nxt.next and nxt.val == nxt.next.val):\\n                    nxt = nxt.next\\n                pre.next = cur = nxt.next\\n                if not cur: return ret.next\\n            else:\\n                pre,cur,nxt = cur,nxt,nxt.next\\n            \\n            \\n        return ret.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234766,
                "title": "python-recursive-iterative-easy-to-understand-both-beat-100",
                "content": "recursive:\\n```python\\nclass Solution:\\n    def deleteDuplicates(self, head: \\'ListNode\\') -> \\'ListNode\\':\\n        if not head or not head.next: return head\\n        nxt = head.next\\n        if nxt.val != head.val:\\n            head.next = self.deleteDuplicates(nxt)\\n            return head\\n        else:\\n            while nxt and nxt.val == head.val:\\n                nxt = nxt.next\\n            return self.deleteDuplicates(nxt)\\n```\\niterative:\\n```python\\nclass Solution:\\n    def deleteDuplicates(self, head: \\'ListNode\\') -> \\'ListNode\\':\\n        dum = ListNode(0)\\n        dum.next, pre, cur = head, dum, head\\n        while cur:\\n            while cur.next and cur.val == cur.next.val:\\n                cur = cur.next\\n            if pre.next == cur: \\n                pre = cur\\n            else: \\n                pre.next = cur.next\\n            cur = cur.next\\n        return dum.next\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def deleteDuplicates(self, head: \\'ListNode\\') -> \\'ListNode\\':\\n        if not head or not head.next: return head\\n        nxt = head.next\\n        if nxt.val != head.val:\\n            head.next = self.deleteDuplicates(nxt)\\n            return head\\n        else:\\n            while nxt and nxt.val == head.val:\\n                nxt = nxt.next\\n            return self.deleteDuplicates(nxt)\\n```\n```python\\nclass Solution:\\n    def deleteDuplicates(self, head: \\'ListNode\\') -> \\'ListNode\\':\\n        dum = ListNode(0)\\n        dum.next, pre, cur = head, dum, head\\n        while cur:\\n            while cur.next and cur.val == cur.next.val:\\n                cur = cur.next\\n            if pre.next == cur: \\n                pre = cur\\n            else: \\n                pre.next = cur.next\\n            cur = cur.next\\n        return dum.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28333,
                "title": "accpted-javascript-solution",
                "content": "``` \\nconst deleteDuplicates = function(head) {\\n    if(head === null || head.next === null) return head;\\n    \\n    const dummy = new ListNode(0);\\n    dummy.next = head;\\n    head = dummy;\\n    \\n    while(head.next !== null && head.next.next !== null) {\\n        if(head.next.val === head.next.next.val) {\\n            let val = head.next.val;\\n            while( head.next !== null && head.next.val === val ){\\n                head.next = head.next.next;\\n            }\\n        } else {\\n            head = head.next;\\n        }\\n\\t}\\n\\treturn dummy.next\\n}\\n```",
                "solutionTags": [],
                "code": "``` \\nconst deleteDuplicates = function(head) {\\n    if(head === null || head.next === null) return head;\\n    \\n    const dummy = new ListNode(0);\\n    dummy.next = head;\\n    head = dummy;\\n    \\n    while(head.next !== null && head.next.next !== null) {\\n        if(head.next.val === head.next.next.val) {\\n            let val = head.next.val;\\n            while( head.next !== null && head.next.val === val ){\\n                head.next = head.next.next;\\n            }\\n        } else {\\n            head = head.next;\\n        }\\n\\t}\\n\\treturn dummy.next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28594,
                "title": "11-lines-c-solution-with-comments",
                "content": "    \\tListNode *deleteDuplicates(ListNode *head) {\\n        if(!head||!head->next)return head;\\n        ListNode *newhead=0,**phead=&newhead;//phead pointer to new head pointer\\n        while(head)\\n        {\\n            if(head->next&&head->val==head->next->val)\\n\\t\\t\\t{//skip all nodes has duplicate value\\n\\t\\t\\t\\tint dupval=head->val;\\n\\t\\t\\t\\twhile(head&&head->val==dupval)head=head->next;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}//assign and advance phead\\n\\t\\t\\telse {*phead=head; phead=&((*phead)->next);}\\n\\t\\t\\thead=head->next;\\n        }\\n        *phead=0;// point the next of last node to NULL\\n        return newhead;\\n    }",
                "solutionTags": [],
                "code": "    \\tListNode *deleteDuplicates(ListNode *head) {\\n        if(!head||!head->next)return head;\\n        ListNode *newhead=0,**phead=&newhead;//phead pointer to new head pointer\\n        while(head)\\n        {\\n            if(head->next&&head->val==head->next->val)\\n\\t\\t\\t{//skip all nodes has duplicate value\\n\\t\\t\\t\\tint dupval=head->val;\\n\\t\\t\\t\\twhile(head&&head->val==dupval)head=head->next;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}//assign and advance phead\\n\\t\\t\\telse {*phead=head; phead=&((*phead)->next);}\\n\\t\\t\\thead=head->next;\\n        }\\n        *phead=0;// point the next of last node to NULL\\n        return newhead;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3835448,
                "title": "easy-c-solution",
                "content": "\\n# Approach\\nCreate a dummy node:\\n\\nWe start by creating a dummy node that acts as the \"head\" of the updated linked list. The dummy node will have a value of 0 and point to the original head of the linked list.\\nInitialize pointers:\\n\\nWe initialize two pointers, head and prev, both pointing to the dummy node initially.\\nThe head pointer is used to traverse the original linked list, and the prev pointer is used to keep track of the last non-duplicate node in the updated linked list.\\nTraverse the linked list:\\n\\nWe use a while loop to iterate through the linked list until the head pointer reaches the end (NULL).\\nInside the loop, we check if the current node\\'s value is equal to the value of its next node (indicating a duplicate).\\nRemove duplicates:\\n\\nIf a duplicate is found (i.e., head->val == head->next->val), we enter another nested while loop to skip all the consecutive nodes with the same value. This ensures that we find the last node with the same value.\\nUpdate pointers:\\n\\nAfter the nested loop, head will be pointing to the last duplicate node.\\nWe then update the prev->next pointer to skip all the duplicate nodes and point to the node after the last duplicate node.\\nIf no duplicates were found, we simply move the prev pointer to the next node.\\nMove head pointer:\\n\\nIn either case (duplicate found or not), we move the head pointer to the next node.\\nReturn the updated linked list:\\n\\nAfter the loop ends, the original linked list is modified such that all duplicates are removed, and the prev pointer points to the last non-duplicate node.\\nWe return dummy->next, which is the head of the updated linked list.\\nThis approach effectively removes all duplicate elements from the linked list while maintaining the order of the non-duplicate elements.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head)\\n    {\\n        ListNode *dummy=new ListNode(0,head);\\n        ListNode *prev=dummy;\\n        while(head!=NULL)\\n        {\\n            if(head->next!=NULL && head->val==head->next->val)\\n            {\\n                while(head->next!=NULL && head->val==head->next->val)\\n                {\\n                    head=head->next;\\n                }\\n            prev->next=head->next;\\n            }\\n            else\\n            {\\n                prev=prev->next;\\n            }\\n        head=head->next;\\n        }\\n        return dummy->next;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head)\\n    {\\n        ListNode *dummy=new ListNode(0,head);\\n        ListNode *prev=dummy;\\n        while(head!=NULL)\\n        {\\n            if(head->next!=NULL && head->val==head->next->val)\\n            {\\n                while(head->next!=NULL && head->val==head->next->val)\\n                {\\n                    head=head->next;\\n                }\\n            prev->next=head->next;\\n            }\\n            else\\n            {\\n                prev=prev->next;\\n            }\\n        head=head->next;\\n        }\\n        return dummy->next;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404383,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIterate through the list while counting the frequency of every element. If the frequency of the element is one then we add the element to the list.\\n\\nTo do this take a previous pointer and point it to NULL. Take a temporary pointer to iterate though the list. Count the frequency of every element. If the frequency is one, point the prevoius Node to the current Node and initialize the privious node to the current Node. But if the previous node is NULL, then initialize head pointer to the current Node and previous Node to also the current node. When temp reaches to NULL and previous node is not NULL then point the Previous Node to NULL.\\n\\nBut if the prevoius node is still is NULL it means the list has no value of single frequency. In this case return NULL.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ Cause the list is iterated only once. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity $$O(1)$$ We only use constant size variables\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n        ListNode* temp = head;//Temporary pointer\\n        ListNode* pre = NULL;//Initializing previous pointer to NULL\\n        \\n        /* Looping through the list untill the tempurary pointer\\n        reaches NULL */  \\n        while(temp != NULL){\\n\\n            int k = 1;\\n            ListNode* curr = temp; //Initialize current pointer to temp\\n            \\n            //Counting the frequency of the current element\\n            while((temp != NULL) && (temp->val == curr->val)){\\n                temp = temp->next;\\n                k++;\\n            }\\n            k--;\\n\\n            //If frequency of the element is 1 put it in the the list\\n            if(k == 1){\\n\\n                // If the previous pointer is null then initialize\\n                // the head pointer  and the previous pointer \\n                // to the current pointer\\n  \\n                if(pre == NULL){\\n                    head = curr;\\n                    pre = curr;\\n                }\\n\\n                //if not then previous to current and next value of\\n                // privious pointer to current pointer\\n                else{\\n                    pre->next = curr;\\n                    pre = curr;\\n                }\\n            }\\n            // when temporary pointer reaches to NULL\\n            // and prevoius pointer is not null then initialie\\n            // next value of prevoius pointer to NULL or temp\\n\\n            if(temp == NULL && pre != NULL){\\n                pre->next = temp;\\n            }\\n        } \\n\\n        // If prevoius pointer is still is NULL, it means that \\n        // no value is eligible for the ans list\\n        // so initialize head to NULL and return head\\n\\n        if(pre == NULL){\\n            head = NULL;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n        ListNode* temp = head;//Temporary pointer\\n        ListNode* pre = NULL;//Initializing previous pointer to NULL\\n        \\n        /* Looping through the list untill the tempurary pointer\\n        reaches NULL */  \\n        while(temp != NULL){\\n\\n            int k = 1;\\n            ListNode* curr = temp; //Initialize current pointer to temp\\n            \\n            //Counting the frequency of the current element\\n            while((temp != NULL) && (temp->val == curr->val)){\\n                temp = temp->next;\\n                k++;\\n            }\\n            k--;\\n\\n            //If frequency of the element is 1 put it in the the list\\n            if(k == 1){\\n\\n                // If the previous pointer is null then initialize\\n                // the head pointer  and the previous pointer \\n                // to the current pointer\\n  \\n                if(pre == NULL){\\n                    head = curr;\\n                    pre = curr;\\n                }\\n\\n                //if not then previous to current and next value of\\n                // privious pointer to current pointer\\n                else{\\n                    pre->next = curr;\\n                    pre = curr;\\n                }\\n            }\\n            // when temporary pointer reaches to NULL\\n            // and prevoius pointer is not null then initialie\\n            // next value of prevoius pointer to NULL or temp\\n\\n            if(temp == NULL && pre != NULL){\\n                pre->next = temp;\\n            }\\n        } \\n\\n        // If prevoius pointer is still is NULL, it means that \\n        // no value is eligible for the ans list\\n        // so initialize head to NULL and return head\\n\\n        if(pre == NULL){\\n            head = NULL;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383200,
                "title": "java-simple-straightforward-solution-o-n-100-faster",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        // Create a new LikedList that will contain our final answer in .next\\n        ListNode newList = new ListNode();\\n        // Create a copy of the head of the new LinkedList\\n        ListNode newListHead = newList;\\n\\n        // Iterate over the list\\n        while(head != null){\\n            // Keep track of whether or not we moved over a chunk of duplicated\\n            boolean wentOverAChunk = false;\\n            // This while loop jumps over the chunk of duplicated\\n            while(head.next != null && head.next.val == head.val){\\n                head = head.next;\\n                wentOverAChunk = true; // Set to true if we encountered duplicates\\n            }\\n            // If we haven\\'t encountered duplicates, add a copy of the node to the newList\\n            if(!wentOverAChunk){\\n                newList.next = new ListNode(head.val);\\n                newList = newList.next;\\n            }\\n            head = head.next;\\n        }\\n        return newListHead.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        // Create a new LikedList that will contain our final answer in .next\\n        ListNode newList = new ListNode();\\n        // Create a copy of the head of the new LinkedList\\n        ListNode newListHead = newList;\\n\\n        // Iterate over the list\\n        while(head != null){\\n            // Keep track of whether or not we moved over a chunk of duplicated\\n            boolean wentOverAChunk = false;\\n            // This while loop jumps over the chunk of duplicated\\n            while(head.next != null && head.next.val == head.val){\\n                head = head.next;\\n                wentOverAChunk = true; // Set to true if we encountered duplicates\\n            }\\n            // If we haven\\'t encountered duplicates, add a copy of the node to the newList\\n            if(!wentOverAChunk){\\n                newList.next = new ListNode(head.val);\\n                newList = newList.next;\\n            }\\n            head = head.next;\\n        }\\n        return newListHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235911,
                "title": "python-93-83-faster-easy-o-n-solution",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head==None or head.next==None:\\n            return head\\n        d={}\\n        temp=head\\n        while temp!=None:\\n            if temp.val in d:\\n                d[temp.val]+=1\\n            else:\\n                d[temp.val]=1\\n            temp=temp.next\\n        temp=head\\n        L=ListNode()\\n        temp2=L\\n        while temp!=None:\\n            if temp.next==None and d[temp.val]>1:\\n                temp2.next=None\\n            if d[temp.val]>1:\\n                temp=temp.next\\n            else:\\n                temp2.next=temp\\n                temp2=temp2.next\\n                temp=temp.next\\n        return L.next\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head==None or head.next==None:\\n            return head\\n        d={}\\n        temp=head\\n        while temp!=None:\\n            if temp.val in d:\\n                d[temp.val]+=1\\n            else:\\n                d[temp.val]=1\\n            temp=temp.next\\n        temp=head\\n        L=ListNode()\\n        temp2=L\\n        while temp!=None:\\n            if temp.next==None and d[temp.val]>1:\\n                temp2.next=None\\n            if d[temp.val]>1:\\n                temp=temp.next\\n            else:\\n                temp2.next=temp\\n                temp2=temp2.next\\n                temp=temp.next\\n        return L.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368612,
                "title": "c-recusrive-solution-easy-understanding",
                "content": "```\\n if(!head || !head->next)\\n        return head;\\n        \\n        Node*next=head->next;\\n        if(head->data==next->data)\\n        {\\n            while(next && next->data==head->data)\\n                next=next->next;\\n            return removeAllDuplicates(next);\\n        }\\n        else\\n        {\\n            head->next=removeAllDuplicates(next);\\n            return head;\\n        }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n if(!head || !head->next)\\n        return head;\\n        \\n        Node*next=head->next;\\n        if(head->data==next->data)\\n        {\\n            while(next && next->data==head->data)\\n                next=next->next;\\n            return removeAllDuplicates(next);\\n        }\\n        else\\n        {\\n            head->next=removeAllDuplicates(next);\\n            return head;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2242508,
                "title": "golang-solution-sentinel-node",
                "content": "```\\nfunc deleteDuplicates(head *ListNode) *ListNode {\\n    // sentinel\\n    sentinel := &ListNode{Next: head}\\n    \\n    // predecessor = the last node\\n    // before the sublist of duplicates\\n    pred := sentinel\\n    \\n    for head != nil {\\n        if head.Next != nil && head.Val == head.Next.Val {\\n            for head.Next != nil && head.Val == head.Next.Val {\\n                head = head.Next\\n            }\\n            \\n            pred.Next = head.Next\\n        } else {\\n            pred = pred.Next\\n        }\\n        \\n        // move forward\\n        head = head.Next\\n    }\\n    \\n    return sentinel.Next\\n}\\n``",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc deleteDuplicates(head *ListNode) *ListNode {\\n    // sentinel\\n    sentinel := &ListNode{Next: head}\\n    \\n    // predecessor = the last node\\n    // before the sublist of duplicates\\n    pred := sentinel\\n    \\n    for head != nil {\\n        if head.Next != nil && head.Val == head.Next.Val {\\n            for head.Next != nil && head.Val == head.Next.Val {\\n                head = head.Next\\n            }\\n            \\n            pred.Next = head.Next\\n        } else {\\n            pred = pred.Next\\n        }\\n        \\n        // move forward\\n        head = head.Next\\n    }\\n    \\n    return sentinel.Next\\n}\\n``",
                "codeTag": "Unknown"
            },
            {
                "id": 1833627,
                "title": "python-go-dummy-node-solution-and-explanation",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python/Go] \\uD83C\\uDF1F Dummy Node Solution and Explanation \\uD83D\\uDC95\\n\\n## 1\\uFE0F\\u20E3 Main Idea:\\nIt is very important to set a dummy node **points to head**, in this question the head of linked lists will be change if original head is duplicate\\n\\nFor Example 2\\n\\n\\thead = [1,1,1,2,3], Output: [2,3]\\n\\nYou can see that we change head to 2, so it\\'s important to set a dummy node before head and then we return dummy.next\\n\\nAnother requirement for this question is that we have to remove duplicate nodes.\\n\\n**Algorithm**\\n\\n0. We set a prev node, before we traverse into list\\n1. We set subHead = prev.next, and sent it to traverse the list.\\nOnce we find that **subHead.val != subHead.next.val** means subHead is not duplicate, we can move prev.next = subHead, and move prev forwar\\n2. If we find that subHead is **duplicate**, and then move subHead = subHead.next until **subHead.val != subHead.next.val** (Could be None or new value)\\nAnd then we make **prev.next = subHead.next**\\nNote that we not move prev forward at this stage, only remove duplicate. We only move prev forward to non duplicate nodes which will be excute at step2\\n## Complexity Analysis\\n* Time: O(N): Let N be the length of linked list\\n* Space: O(1)\\n## Floyd\\'s Cycle Detection Code\\n**Python**\\n```python\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        # Create a dummy node\\n        dummy = ListNode(-1, head)\\n        prev = dummy\\n        \\n        while prev.next and prev.next.next:\\n            # Init subHead\\n            subHead = prev.next\\n            # If not duplicate move prev forward\\n            if subHead.val != subHead.next.val:\\n                prev.next = subHead\\n                prev = prev.next\\n                continue\\n            # If duplicate remove them and point prev.next to next integer\\n            # Note that we not move prev forward at this stage, only remove duplicate\\n            while subHead.next and subHead.val == subHead.next.val:\\n                subHead = subHead.next\\n            prev.next = subHead.next\\n        # return head\\n        return dummy.next\\n```\\n**Go**\\n```go\\nfunc deleteDuplicates(head *ListNode) *ListNode {\\n    // Create a dummy node\\n    dummy := ListNode{0, head}\\n    prev := &dummy\\n    \\n    for prev.Next != nil && prev.Next.Next != nil{\\n        // Init subHead\\n        subHead := prev.Next\\n        // If not duplicate move prev forward\\n        if subHead.Val != subHead.Next.Val{\\n            prev.Next = subHead\\n            prev = prev.Next\\n            continue\\n        }\\n        // If duplicate remove them and point prev.next to next integer\\n        // Note that we not move prev forward at this stage, only remove duplicate\\n        for subHead.Next != nil && subHead.Val == subHead.Next.Val{\\n            subHead = subHead.Next\\n        }\\n        prev.Next = subHead.Next\\n        \\n    }\\n\\n    return dummy.Next\\n}\\n```\\n\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        # Create a dummy node\\n        dummy = ListNode(-1, head)\\n        prev = dummy\\n        \\n        while prev.next and prev.next.next:\\n            # Init subHead\\n            subHead = prev.next\\n            # If not duplicate move prev forward\\n            if subHead.val != subHead.next.val:\\n                prev.next = subHead\\n                prev = prev.next\\n                continue\\n            # If duplicate remove them and point prev.next to next integer\\n            # Note that we not move prev forward at this stage, only remove duplicate\\n            while subHead.next and subHead.val == subHead.next.val:\\n                subHead = subHead.next\\n            prev.next = subHead.next\\n        # return head\\n        return dummy.next\\n```\n```go\\nfunc deleteDuplicates(head *ListNode) *ListNode {\\n    // Create a dummy node\\n    dummy := ListNode{0, head}\\n    prev := &dummy\\n    \\n    for prev.Next != nil && prev.Next.Next != nil{\\n        // Init subHead\\n        subHead := prev.Next\\n        // If not duplicate move prev forward\\n        if subHead.Val != subHead.Next.Val{\\n            prev.Next = subHead\\n            prev = prev.Next\\n            continue\\n        }\\n        // If duplicate remove them and point prev.next to next integer\\n        // Note that we not move prev forward at this stage, only remove duplicate\\n        for subHead.Next != nil && subHead.Val == subHead.Next.Val{\\n            subHead = subHead.Next\\n        }\\n        prev.Next = subHead.Next\\n        \\n    }\\n\\n    return dummy.Next\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833360,
                "title": "c-2-methods-100-faster-easy-to-understand",
                "content": "**Method 1 :**  Brute Force [ TC : O(N)  & SC : O(N) ]\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        unordered_map<int,int>m;\\n        ListNode* h = new ListNode(0);\\n        \\n        ListNode* curr = head;\\n        while(curr)\\n        {\\n            m[curr->val]++;\\n            curr = curr->next;\\n        }\\n        \\n        curr = h;\\n        ListNode* temp = head;\\n        while(temp)\\n        {\\n            if(m[temp->val] == 1)\\n            {\\n                curr->next = temp;\\n                curr = curr->next;\\n            }\\n            \\n        temp = temp->next;\\n        }\\n        curr->next = NULL;\\n\\n        return h->next;\\n        \\n       \\n    }\\n};\\n```\\n\\n\\n**Method 2:** Optimize Solution [ TC : O(N)  & SC : O(1) ]\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        ListNode* h = new ListNode(0);\\n        ListNode* prev = h;\\n        ListNode* curr = head;\\n     \\n        \\n        while(curr)\\n        {\\n            if(curr->next && curr->val == curr->next->val)\\n            {\\n                while(curr->next && curr->val == curr->next->val)\\n                    curr = curr->next;\\n            }\\n            else\\n            {\\n                   prev->next = curr;\\n                    prev = curr;   \\n            }\\n            \\n            curr = curr->next;\\n        }\\n        prev->next = NULL;\\n        return h->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        unordered_map<int,int>m;\\n        ListNode* h = new ListNode(0);\\n        \\n        ListNode* curr = head;\\n        while(curr)\\n        {\\n            m[curr->val]++;\\n            curr = curr->next;\\n        }\\n        \\n        curr = h;\\n        ListNode* temp = head;\\n        while(temp)\\n        {\\n            if(m[temp->val] == 1)\\n            {\\n                curr->next = temp;\\n                curr = curr->next;\\n            }\\n            \\n        temp = temp->next;\\n        }\\n        curr->next = NULL;\\n\\n        return h->next;\\n        \\n       \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        ListNode* h = new ListNode(0);\\n        ListNode* prev = h;\\n        ListNode* curr = head;\\n     \\n        \\n        while(curr)\\n        {\\n            if(curr->next && curr->val == curr->next->val)\\n            {\\n                while(curr->next && curr->val == curr->next->val)\\n                    curr = curr->next;\\n            }\\n            else\\n            {\\n                   prev->next = curr;\\n                    prev = curr;   \\n            }\\n            \\n            curr = curr->next;\\n        }\\n        prev->next = NULL;\\n        return h->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832967,
                "title": "tc-o-n-sc-o-1-c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        \\n        ListNode* dummy = new ListNode(0, head);\\n        ListNode* temp=head;\\n        ListNode* prev=dummy;\\n        \\n        while(temp!=NULL){\\n            if(temp->next!=NULL && temp->val == temp->next->val){\\n                while(temp->next!=NULL && temp->val == temp->next->val)\\n                    temp=temp->next;\\n                prev->next=temp->next;\\n            }\\n            else if(prev->next!=NULL)\\n                prev=prev->next;\\n            temp=temp->next;      \\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        \\n        ListNode* dummy = new ListNode(0, head);\\n        ListNode* temp=head;\\n        ListNode* prev=dummy;\\n        \\n        while(temp!=NULL){\\n            if(temp->next!=NULL && temp->val == temp->next->val){\\n                while(temp->next!=NULL && temp->val == temp->next->val)\\n                    temp=temp->next;\\n                prev->next=temp->next;\\n            }\\n            else if(prev->next!=NULL)\\n                prev=prev->next;\\n            temp=temp->next;      \\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783662,
                "title": "java-solution-with-dry-run",
                "content": "```\\n\\nprev      head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\nhead will keep track of removing the duplicates elements of Sorted LL\\nso when head.next != null and head.next.val == head.val \\nmove the head pointer to it\\'s next until head.next.val != head.val\\n \\nWhen head.next.val not equal to head.val then just mov prev and head pointer by one step\\n\\n\\n         prev  head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\n\\n              prev  head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\nNow head.next.val == head.val so move head pointer till head.next.val != head.val\\n\\n\\n              prev      head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\n\\nNow head is pointing to last occurence of duplicate element so connect pre next to head next  and move head to it\\'s next\\n\\n1. prev.next = head.next\\n\\n              prev      head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |_____________|\\n\\n\\n2. head = head.next\\n              prev          head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |_____________|\\n\\n\\nnow head.val == head.next.val so move head pointer till head.next.val != head.val\\n\\n              prev               head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |_____________|\\n\\nNow head is pointing to last occurence of duplicate element so connect pre next to head next  and move head to it\\'s next\\n\\n1. prev.next = head.next\\n\\n             prev               head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |______________________|\\n\\n\\n2. head = head.next\\n\\n             prev                    head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |______________________|\\n\\n\\nResultant LL  : \\n\\n     0 -> 1->2->5\\n    dummy    \\n    \\n    RETURN dummy.next\\n\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n \\n ```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null) return null;\\n        \\n        ListNode dummy = new ListNode(0, head);\\n        ListNode prev = dummy;\\n        \\n        while(head != null)\\n        {\\n            if(head.next != null && head.val == head.next.val)\\n            {\\n                while(head.next != null && head.val == head.next.val)\\n                {\\n                    head = head.next;\\n                }\\n                \\n                prev.next = head.next;\\n                head = head.next;\\n            }\\n            else\\n            {\\n                prev= prev.next;\\n                head = head.next;\\n            }\\n        }\\n        \\n        return dummy.next;\\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nprev      head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\nhead will keep track of removing the duplicates elements of Sorted LL\\nso when head.next != null and head.next.val == head.val \\nmove the head pointer to it\\'s next until head.next.val != head.val\\n \\nWhen head.next.val not equal to head.val then just mov prev and head pointer by one step\\n\\n\\n         prev  head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\n\\n              prev  head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\nNow head.next.val == head.val so move head pointer till head.next.val != head.val\\n\\n\\n              prev      head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\n\\nNow head is pointing to last occurence of duplicate element so connect pre next to head next  and move head to it\\'s next\\n\\n1. prev.next = head.next\\n\\n              prev      head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |_____________|\\n\\n\\n2. head = head.next\\n              prev          head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |_____________|\\n\\n\\nnow head.val == head.next.val so move head pointer till head.next.val != head.val\\n\\n              prev               head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |_____________|\\n\\nNow head is pointing to last occurence of duplicate element so connect pre next to head next  and move head to it\\'s next\\n\\n1. prev.next = head.next\\n\\n             prev               head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |______________________|\\n\\n\\n2. head = head.next\\n\\n             prev                    head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |______________________|\\n\\n\\nResultant LL  : \\n\\n     0 -> 1->2->5\\n    dummy    \\n    \\n    RETURN dummy.next\\n\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1703186,
                "title": "c-easy-to-understand-faster-than-95-percent",
                "content": "```\\n ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL or head->next == NULL){\\n            return head;\\n        }\\n        ListNode * temp = head;\\n        ListNode * prev = new ListNode(-2);\\n        ListNode * head1 = prev;\\n        prev->next = head;\\n        int find = head->val;\\n        while(temp != NULL){\\n            if(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                while(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                    temp = temp->next;\\n                }\\n                prev->next = temp->next;\\n                temp = prev->next;\\n            }\\n            else{\\n                prev = prev->next;\\n                temp = temp->next;\\n                \\n            }\\n        }\\n        return head1->next;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL or head->next == NULL){\\n            return head;\\n        }\\n        ListNode * temp = head;\\n        ListNode * prev = new ListNode(-2);\\n        ListNode * head1 = prev;\\n        prev->next = head;\\n        int find = head->val;\\n        while(temp != NULL){\\n            if(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                while(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                    temp = temp->next;\\n                }\\n                prev->next = temp->next;\\n                temp = prev->next;\\n            }\\n            else{\\n                prev = prev->next;\\n                temp = temp->next;\\n                \\n            }\\n        }\\n        return head1->next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1407383,
                "title": "ultra-simple-cpp-solution-suggestions-for-optimization-are-welcomed",
                "content": "Runtime: 8 ms, faster than 60.39% of C++ online submissions for Remove Duplicates from Sorted List II.\\nMemory Usage: 11.1 MB, less than 90.02% of C++ online submissions for Remove Duplicates from Sorted List II.\\n\\nT(n) = O(n)\\nS(n) = O(1)\\n\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        ListNode* curr   = head;\\n        ListNode* prev   = nullptr;\\n        ListNode* ahead  = head;\\n        \\n        \\n        while(curr){\\n            \\n            if(curr->next && curr->val==curr->next->val){\\n                \\n                while(curr->next && curr->val==curr->next->val)\\n                    curr = curr->next;    \\n                \\n                if(prev==nullptr){\\n                    head = curr->next;\\n                    prev==nullptr;\\n                }\\n                else\\n                    prev->next = curr->next;    \\n                \\n                curr = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        \\n        return head;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        ListNode* curr   = head;\\n        ListNode* prev   = nullptr;\\n        ListNode* ahead  = head;\\n        \\n        \\n        while(curr){\\n            \\n            if(curr->next && curr->val==curr->next->val){\\n                \\n                while(curr->next && curr->val==curr->next->val)\\n                    curr = curr->next;    \\n                \\n                if(prev==nullptr){\\n                    head = curr->next;\\n                    prev==nullptr;\\n                }\\n                else\\n                    prev->next = curr->next;    \\n                \\n                curr = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        \\n        return head;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1235937,
                "title": "c-recursion-easy",
                "content": "As the solution is recursive, let\\'s see the base cases.\\n1. If the ```head``` is ```NULL``` return ```head```, coz nothing to do further.\\n2. Else check for the duplicates of ```head``` with the help of temp pointer and update the ```head```\\n3. If the present ```temp``` or ```head``` is not ```NULL``` then call the deleteDuplicates on ```temp->next```.\\n4. Return ```head```.\\n\\nHope this helps!\\n```\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head) return head;\\n        ListNode* temp = head;\\n        while(head and head->next and head->val == head->next->val){\\n            while(temp and head->val == temp->val)\\n                temp = temp->next;\\n            head = temp;\\n        }\\n        if(temp)\\n        temp->next = deleteDuplicates(temp->next);\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```head```\n```NULL```\n```head```\n```head```\n```head```\n```temp```\n```head```\n```NULL```\n```temp->next```\n```head```\n```\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head) return head;\\n        ListNode* temp = head;\\n        while(head and head->next and head->val == head->next->val){\\n            while(temp and head->val == temp->val)\\n                temp = temp->next;\\n            head = temp;\\n        }\\n        if(temp)\\n        temp->next = deleteDuplicates(temp->next);\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1232028,
                "title": "different-way-to-write-the-solution-python-code-not-using-two-while-loops",
                "content": "I tried alternate approach compared to solution.\\n\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        s = ListNode(0, head)\\n        p = s\\n        d = None\\n        while s and s.next and s.next.next:\\n            if s.next.val == s.next.next.val:\\n                d = s.next.val\\n                s.next = s.next.next.next\\n            elif d is not None and d == s.next.val:\\n                s.next = s.next.next\\n            else:\\n                s = s.next\\n        if s.next and s.next.val == d:\\n            s.next = s.next.next\\n        return p.next\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        s = ListNode(0, head)\\n        p = s\\n        d = None\\n        while s and s.next and s.next.next:\\n            if s.next.val == s.next.next.val:\\n                d = s.next.val\\n                s.next = s.next.next.next\\n            elif d is not None and d == s.next.val:\\n                s.next = s.next.next\\n            else:\\n                s = s.next\\n        if s.next and s.next.val == d:\\n            s.next = s.next.next\\n        return p.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003306,
                "title": "remove-duplicates-from-sorted-list-ii-c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        //recursion exit condition\\n        if (!head||!head->next) return head;\\n        \\n        ListNode* node = head->next;\\n        \\n        //case: node val is not a duplicate of head val\\n        if (node->val != head->val) {\\n            //repeat process with next two nodes\\n            head->next = deleteDuplicates(node);\\n            return head;\\n        } \\n        //case: node val is a duplicate of head val\\n        else {\\n            //remove all nodes until no duplicate value as head, or end of list\\n            while (node && node->val == head->val) node = node->next;\\n            //return node here because head is part of the duplicate\\n            return deleteDuplicates(node);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        //recursion exit condition\\n        if (!head||!head->next) return head;\\n        \\n        ListNode* node = head->next;\\n        \\n        //case: node val is not a duplicate of head val\\n        if (node->val != head->val) {\\n            //repeat process with next two nodes\\n            head->next = deleteDuplicates(node);\\n            return head;\\n        } \\n        //case: node val is a duplicate of head val\\n        else {\\n            //remove all nodes until no duplicate value as head, or end of list\\n            while (node && node->val == head->val) node = node->next;\\n            //return node here because head is part of the duplicate\\n            return deleteDuplicates(node);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 715415,
                "title": "java-recursion-o-n",
                "content": "```\\npublic ListNode deleteDuplicates(ListNode head) {\\n\\tif( head != null && head.next != null) {            \\n\\t\\tif(head.next.val != head.val) {\\n\\t\\t\\thead.next = deleteDuplicates(head.next);\\n\\t\\t} else {\\n\\t\\t\\twhile(head.next != null && head.val == head.next.val)\\n\\t\\t\\t\\thead = head.next;\\n\\t\\t\\treturn deleteDuplicates(head.next);\\n\\t\\t}\\n\\t}\\n\\treturn head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode deleteDuplicates(ListNode head) {\\n\\tif( head != null && head.next != null) {            \\n\\t\\tif(head.next.val != head.val) {\\n\\t\\t\\thead.next = deleteDuplicates(head.next);\\n\\t\\t} else {\\n\\t\\t\\twhile(head.next != null && head.val == head.next.val)\\n\\t\\t\\t\\thead = head.next;\\n\\t\\t\\treturn deleteDuplicates(head.next);\\n\\t\\t}\\n\\t}\\n\\treturn head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 362394,
                "title": "java-recursive-and-iterative-approaches",
                "content": "Recursive approach:\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        if (head.val != head.next.val) {\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }\\n        // When the current heads are followed with a bunch of duplicates;\\n        while (head.next != null && head.val == head.next.val) {\\n            head = head.next;\\n        }\\n        return deleteDuplicates(head.next);\\n    }\\n}\\n```\\n\\nIterative approach:\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        ListNode dummyHead = new ListNode(0);\\n        dummyHead.next = head;\\n        ListNode cur = dummyHead;\\n        while (cur.next != null && cur.next.next != null) {\\n            // pass when no duplicate\\n            if (cur.next.val != cur.next.next.val) {\\n                cur = cur.next;\\n                continue;\\n            }\\n            ListNode prev = cur;\\n            cur = cur.next;\\n            while (cur.next != null && cur.val == cur.next.val) {\\n                cur = cur.next;\\n            }\\n            prev.next = cur.next;\\n            cur = prev;\\n        }\\n        return dummyHead.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        if (head.val != head.next.val) {\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }\\n        // When the current heads are followed with a bunch of duplicates;\\n        while (head.next != null && head.val == head.next.val) {\\n            head = head.next;\\n        }\\n        return deleteDuplicates(head.next);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        ListNode dummyHead = new ListNode(0);\\n        dummyHead.next = head;\\n        ListNode cur = dummyHead;\\n        while (cur.next != null && cur.next.next != null) {\\n            // pass when no duplicate\\n            if (cur.next.val != cur.next.next.val) {\\n                cur = cur.next;\\n                continue;\\n            }\\n            ListNode prev = cur;\\n            cur = cur.next;\\n            while (cur.next != null && cur.val == cur.next.val) {\\n                cur = cur.next;\\n            }\\n            prev.next = cur.next;\\n            cur = prev;\\n        }\\n        return dummyHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 249643,
                "title": "swift-solution",
                "content": "```swift\\nclass Solution {\\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        var temp = ListNode(0)\\n        var slow: ListNode? = temp, fast = head\\n        while slow != nil {\\n            if fast != nil && fast!.val == fast!.next?.val {\\n                while fast!.val == fast!.next?.val {\\n                    fast = fast!.next\\n                }\\n                fast = fast?.next\\n            \\n            } else {\\n                slow!.next = fast\\n                slow = slow?.next\\n                fast = fast?.next\\n            }\\n        }\\n        return temp.next\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        var temp = ListNode(0)\\n        var slow: ListNode? = temp, fast = head\\n        while slow != nil {\\n            if fast != nil && fast!.val == fast!.next?.val {\\n                while fast!.val == fast!.next?.val {\\n                    fast = fast!.next\\n                }\\n                fast = fast?.next\\n            \\n            } else {\\n                slow!.next = fast\\n                slow = slow?.next\\n                fast = fast?.next\\n            }\\n        }\\n        return temp.next\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 225398,
                "title": "python-simple-recursive-100-with-explanation",
                "content": "Look at the first node, it is either duplicate or unique.\\n**(1)** duplicate: it is like A-A-......-B, then B is the head we return\\n**(2)** unique: it is like A-B-......, then A is the head we return\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        # Edge/Base case\\n        if not head or not head.next:\\n            return head\\n        # case (1)\\n        if head.val == head.next.val:\\n            while head.next and head.val == head.next.val:\\n                head = head.next\\n            return self.deleteDuplicates(head.next)    \\n        # case (2)\\n        else:\\n            head.next = self.deleteDuplicates(head.next)\\n            return head\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        # Edge/Base case\\n        if not head or not head.next:\\n            return head\\n        # case (1)\\n        if head.val == head.next.val:\\n            while head.next and head.val == head.next.val:\\n                head = head.next\\n            return self.deleteDuplicates(head.next)    \\n        # case (2)\\n        else:\\n            head.next = self.deleteDuplicates(head.next)\\n            return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164789,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        curr = head\\n        prev = ListNode(0)\\n        prev.next = curr\\n        rec = prev\\n        while curr:\\n            dupl = False \\n            while curr.next and curr.val == curr.next.val:\\n                dupl = True\\n                curr = curr.next\\n            if dupl:\\n                curr = curr.next\\n                prev.next = curr\\n            else:\\n                prev = curr\\n                curr = curr.next\\n        return rec.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        curr = head\\n        prev = ListNode(0)\\n        prev.next = curr\\n        rec = prev\\n        while curr:\\n            dupl = False \\n            while curr.next and curr.val == curr.next.val:\\n                dupl = True\\n                curr = curr.next\\n            if dupl:\\n                curr = curr.next\\n                prev.next = curr\\n            else:\\n                prev = curr\\n                curr = curr.next\\n        return rec.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28522,
                "title": "super-simple-and-easy-to-understand-cpp-solution",
                "content": "    class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            ListNode dummy(0);\\n            dummy.next = head;\\n            ListNode *p = &dummy;\\n            ListNode *p1 = head;\\n            ListNode *p2 = head;\\n            while (p1) {\\n                while (p2->next && p1->val==p2->next->val) {\\n                    p2 = p2->next;\\n                }\\n\\n                if (p1==p2) {\\n                    p = p1;\\n                } else {\\n                    p->next = p2->next;\\n                }\\n\\n                p1 = p2 = p->next;\\n            }\\n\\n            return dummy.next;\\n\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            ListNode dummy(0);\\n            dummy.next = head;\\n            ListNode *p = &dummy;\\n            ListNode *p1 = head;\\n            ListNode *p2 = head;\\n            while (p1) {\\n                while (p2->next && p1->val==p2->next->val) {\\n                    p2 = p2->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4019039,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null||head.next==null)return head;\\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode prev=dummy;\\n        ListNode cur=head;\\n        while(cur!=null){\\n            if(cur.next!=null && cur.val==cur.next.val){\\n                while(cur.next!=null && cur.val==cur.next.val){\\n                    cur=cur.next;\\n                }\\n                prev.next=cur.next;\\n            }\\n            else{\\n                prev=cur;\\n            }\\n            cur=cur.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null||head.next==null)return head;\\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode prev=dummy;\\n        ListNode cur=head;\\n        while(cur!=null){\\n            if(cur.next!=null && cur.val==cur.next.val){\\n                while(cur.next!=null && cur.val==cur.next.val){\\n                    cur=cur.next;\\n                }\\n                prev.next=cur.next;\\n            }\\n            else{\\n                prev=cur;\\n            }\\n            cur=cur.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840394,
                "title": "javascript-with-explanation",
                "content": "# Intuition\\nI had to review other answers to get a better understanding, but none of the explanation really were thorough enough to fully understand.\\n\\n# Approach\\nAs other have mentioned, we need to create a dummy node or preNode.\\nSince the intent is that we need a pre node in order for us to keep track and remove the duplicates. \\nIf we don\\'t have the pre node, we going to have a hard time updating the current node. The pre node is key to solving this problem.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nconst deleteDuplicates = function(head) {\\n    // Example head: [1,2,3,3,4,4,5]\\n    let dummyNode = new ListNode(0)\\n    dummyNode.next = head \\n    // dummyNode -> [0,1,2,3,3,4,4,5] \\n    // which now gives us a starting node to update once\\n    // we\\'ve found and removed duplicate\\n    // we assign dummyNode to list \\n    let list = dummyNode\\n\\n    // Start list = [0,1,2,3,3,4,4,5]\\n    // We want to continously check the next and the next.next node\\n    // AKA nodes 1 -> 2 above in list\\n    // The while loop below will reach the else statement until \\n    // we reach the  3 -> 3 nodes\\n    while (list.next && list.next.next) {\\n        if (list.next.val === list.next.next.val) {\\n            // [1,2,3,3,4,4,5]\\n            //      ^ ^ \\n            // Now that we\\'ve found our first duplicate,\\n            // it turns into a sub loop to remove not just one, \\n            // but all dupes, referring to 2nd Ex: [1,1,1,2,3]\\n            while (list.next && list.next.next && list.next.val === list.next.next.val) {\\n                 // [1,2,3,3,4,4,5]\\n                 //        ^ ^ \\n                list.next = list.next.next\\n                // Next, which is the 2nd node 3 gets updated to 4. \\n                // We then wold loop again in the while loop\\n                // which will be false, moving on to the next line below\\n            }\\n            // Now we remove the first 3 since it\\'s part of the dupes\\n            // list is 1 below, so list.next is 2\\n            // [1,2,3,4,4,5] -> [1,2,4,4,5]\\n            //  | ^   ^ \\n            list.next = list.next.next\\n        } else {\\n            // If not a dupe we update current with next.\\n            list = list.next\\n        }\\n    }\\n    return dummyNode.next\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nconst deleteDuplicates = function(head) {\\n    // Example head: [1,2,3,3,4,4,5]\\n    let dummyNode = new ListNode(0)\\n    dummyNode.next = head \\n    // dummyNode -> [0,1,2,3,3,4,4,5] \\n    // which now gives us a starting node to update once\\n    // we\\'ve found and removed duplicate\\n    // we assign dummyNode to list \\n    let list = dummyNode\\n\\n    // Start list = [0,1,2,3,3,4,4,5]\\n    // We want to continously check the next and the next.next node\\n    // AKA nodes 1 -> 2 above in list\\n    // The while loop below will reach the else statement until \\n    // we reach the  3 -> 3 nodes\\n    while (list.next && list.next.next) {\\n        if (list.next.val === list.next.next.val) {\\n            // [1,2,3,3,4,4,5]\\n            //      ^ ^ \\n            // Now that we\\'ve found our first duplicate,\\n            // it turns into a sub loop to remove not just one, \\n            // but all dupes, referring to 2nd Ex: [1,1,1,2,3]\\n            while (list.next && list.next.next && list.next.val === list.next.next.val) {\\n                 // [1,2,3,3,4,4,5]\\n                 //        ^ ^ \\n                list.next = list.next.next\\n                // Next, which is the 2nd node 3 gets updated to 4. \\n                // We then wold loop again in the while loop\\n                // which will be false, moving on to the next line below\\n            }\\n            // Now we remove the first 3 since it\\'s part of the dupes\\n            // list is 1 below, so list.next is 2\\n            // [1,2,3,4,4,5] -> [1,2,4,4,5]\\n            //  | ^   ^ \\n            list.next = list.next.next\\n        } else {\\n            // If not a dupe we update current with next.\\n            list = list.next\\n        }\\n    }\\n    return dummyNode.next\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531498,
                "title": "simple-solution-two-pointer-c-java",
                "content": "\\n# Approach 1 - Using HashMap\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a hashmap and store the frequency of elements and recreate the linked list by taking the elements occurring once.\\n\\nBut for that we have to traverse the linked list twice and we will not use the fact that the given linked list is sorted.\\n\\n# Approach 2 - Two pointer\\n$$ Optimized \\\\hspace{0.2cm} solution $$\\n<!-- This is the actual solution in the code. -->\\nWe can use the given condition that the linked list is sorted and use two pointers to keep track of repeated nodes.\\n\\nKeep a `count` variable and keep track of number of occurances of nodes.\\n\\nTraverse through the linked list and add the elements which occur only once to the new linked list.\\n> **Optimization:** Can modify the given linked list without using extra space.\\n\\nNote: Don\\'t forget to check for the last element of the linked list.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\n\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head == NULL || head->next == NULL) return head;\\n\\n        ListNode *curr = head, *prev = NULL;\\n        ListNode *r_head = NULL, *r_tail = NULL;\\n\\n        int cnt = 0;\\n        while (curr != NULL) {\\n            if (prev == NULL || prev->val == curr->val) {\\n                ++cnt;\\n            } else {\\n                if (cnt < 2) {\\n                    if (r_head == NULL) {\\n                        r_head = new ListNode(prev->val);\\n                        r_tail = r_head;\\n                    } else {\\n                        r_tail->next = new ListNode(prev->val);\\n                        r_tail = r_tail->next;\\n                    }\\n                }\\n                cnt = 1;\\n            }\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        // To check for the last element of linked list\\n        if (cnt < 2 && prev != NULL) {\\n            if (r_head == NULL) {\\n                r_head = new ListNode(prev->val);\\n            } else {\\n                r_tail->next = new ListNode(prev->val);\\n            }\\n        }\\n        return r_head;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    \\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        \\n        ListNode curr = head, prev = null;\\n        ListNode r_head = null, r_tail = null;\\n\\n        int cnt = 0;\\n        while (curr != null) {\\n            if (prev == null || prev.val == curr.val) {\\n                ++cnt;\\n            } else {\\n                if (cnt < 2) {\\n                    if (r_head == null) {\\n                        r_head = new ListNode(prev.val);\\n                        r_tail = r_head;\\n                    } else {\\n                        r_tail.next = new ListNode(prev.val);\\n                        r_tail = r_tail.next;\\n                    }\\n                }\\n                cnt = 1;\\n            }\\n            prev = curr;\\n            curr = curr.next;\\n        }\\n        // To check for the last element of linked list\\n        if (cnt < 2 && prev != null) {\\n            if (r_head == null) {\\n                r_head = new ListNode(prev.val);\\n            } else {\\n                r_tail.next = new ListNode(prev.val);\\n            }\\n        }\\n        return r_head;\\n    }\\n}\\n```\\n\\n**Will you upvote if the solution was helpful?**",
                "solutionTags": [
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```C++ []\\nclass Solution {\\n\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head == NULL || head->next == NULL) return head;\\n\\n        ListNode *curr = head, *prev = NULL;\\n        ListNode *r_head = NULL, *r_tail = NULL;\\n\\n        int cnt = 0;\\n        while (curr != NULL) {\\n            if (prev == NULL || prev->val == curr->val) {\\n                ++cnt;\\n            } else {\\n                if (cnt < 2) {\\n                    if (r_head == NULL) {\\n                        r_head = new ListNode(prev->val);\\n                        r_tail = r_head;\\n                    } else {\\n                        r_tail->next = new ListNode(prev->val);\\n                        r_tail = r_tail->next;\\n                    }\\n                }\\n                cnt = 1;\\n            }\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        // To check for the last element of linked list\\n        if (cnt < 2 && prev != NULL) {\\n            if (r_head == NULL) {\\n                r_head = new ListNode(prev->val);\\n            } else {\\n                r_tail->next = new ListNode(prev->val);\\n            }\\n        }\\n        return r_head;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    \\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        \\n        ListNode curr = head, prev = null;\\n        ListNode r_head = null, r_tail = null;\\n\\n        int cnt = 0;\\n        while (curr != null) {\\n            if (prev == null || prev.val == curr.val) {\\n                ++cnt;\\n            } else {\\n                if (cnt < 2) {\\n                    if (r_head == null) {\\n                        r_head = new ListNode(prev.val);\\n                        r_tail = r_head;\\n                    } else {\\n                        r_tail.next = new ListNode(prev.val);\\n                        r_tail = r_tail.next;\\n                    }\\n                }\\n                cnt = 1;\\n            }\\n            prev = curr;\\n            curr = curr.next;\\n        }\\n        // To check for the last element of linked list\\n        if (cnt < 2 && prev != null) {\\n            if (r_head == null) {\\n                r_head = new ListNode(prev.val);\\n            } else {\\n                r_tail.next = new ListNode(prev.val);\\n            }\\n        }\\n        return r_head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453909,
                "title": "easy-and-simple-java-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n         ListNode curr=dummy;\\n        if(head==null || head.next==null){\\n             return head;\\n        }\\n        while(curr.next!=null && curr.next.next!=null){\\n          if(curr.next.val==curr.next.next.val){\\n              int value=curr.next.val;\\n              while(curr.next!=null && curr.next.val==value){\\n                  curr.next=curr.next.next;\\n              }\\n          }\\n          else{\\n              curr=curr.next;\\n          }  \\n        }\\n        return dummy.next;\\n        // ListNode ptr=head;\\n        // ListNode ptr2=head.next;\\n        // if(head==null || head.next==null){\\n        //     return head;\\n        // }\\n        // if(head.val==head.next.val){\\n        //     head=head.next.next.next;\\n        // }\\n        // while(ptr2.next!=null){\\n        //     if(ptr2.val==ptr2.next.val){\\n        //        ptr.next=ptr2.next.next;\\n        //        ptr2=ptr2.next.next;\\n        //     }\\n        //     else{\\n        //         ptr=ptr.next;\\n        //         ptr2=ptr2.next;\\n        //     }\\n        // }\\n        // return head;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n         ListNode curr=dummy;\\n        if(head==null || head.next==null){\\n             return head;\\n        }\\n        while(curr.next!=null && curr.next.next!=null){\\n          if(curr.next.val==curr.next.next.val){\\n              int value=curr.next.val;\\n              while(curr.next!=null && curr.next.val==value){\\n                  curr.next=curr.next.next;\\n              }\\n          }\\n          else{\\n              curr=curr.next;\\n          }  \\n        }\\n        return dummy.next;\\n        // ListNode ptr=head;\\n        // ListNode ptr2=head.next;\\n        // if(head==null || head.next==null){\\n        //     return head;\\n        // }\\n        // if(head.val==head.next.val){\\n        //     head=head.next.next.next;\\n        // }\\n        // while(ptr2.next!=null){\\n        //     if(ptr2.val==ptr2.next.val){\\n        //        ptr.next=ptr2.next.next;\\n        //        ptr2=ptr2.next.next;\\n        //     }\\n        //     else{\\n        //         ptr=ptr.next;\\n        //         ptr2=ptr2.next;\\n        //     }\\n        // }\\n        // return head;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239255,
                "title": "python-97-02-faster-easy-o-n-solution",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head==None or head.next==None:\\n            return head\\n        temp=head\\n        dummy=pre=ListNode()\\n        while temp and temp.next:\\n            if temp.val==temp.next.val:\\n                while temp and temp.next and temp.val==temp.next.val:\\n                    temp=temp.next\\n                temp=temp.next\\n                pre.next=temp\\n            else:\\n                pre.next=temp\\n                pre=pre.next\\n                temp=temp.next\\n        return dummy.next\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head==None or head.next==None:\\n            return head\\n        temp=head\\n        dummy=pre=ListNode()\\n        while temp and temp.next:\\n            if temp.val==temp.next.val:\\n                while temp and temp.next and temp.val==temp.next.val:\\n                    temp=temp.next\\n                temp=temp.next\\n                pre.next=temp\\n            else:\\n                pre.next=temp\\n                pre=pre.next\\n                temp=temp.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3150415,
                "title": "1-baar-code-dekhe-fir-vishwas-kare-sabse-easy-approach-using-hashing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        unordered_map<int,int> ump;\\n        ListNode* head1=new ListNode(0);\\n        ListNode *tomp=head1;\\n\\n        ListNode *temp=head;\\n        while(temp!=NULL)\\n        {\\n            ump[temp->val]++;\\n            temp=temp->next;\\n        }\\n         \\n        temp=head;\\n        while(temp!=NULL)\\n        {\\n            if(ump[temp->val]==1)\\n            {\\n             ListNode * temp1 =new ListNode(temp->val);\\n             tomp->next=temp1;\\n             tomp=temp1;\\n\\n            \\n               \\n\\n            }\\n            temp=temp->next;\\n        }\\n\\nreturn head1->next;\\n\\n    \\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        unordered_map<int,int> ump;\\n        ListNode* head1=new ListNode(0);\\n        ListNode *tomp=head1;\\n\\n        ListNode *temp=head;\\n        while(temp!=NULL)\\n        {\\n            ump[temp->val]++;\\n            temp=temp->next;\\n        }\\n         \\n        temp=head;\\n        while(temp!=NULL)\\n        {\\n            if(ump[temp->val]==1)\\n            {\\n             ListNode * temp1 =new ListNode(temp->val);\\n             tomp->next=temp1;\\n             tomp=temp1;\\n\\n            \\n               \\n\\n            }\\n            temp=temp->next;\\n        }\\n\\nreturn head1->next;\\n\\n    \\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081759,
                "title": "easy-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n            return  NULL;\\n        ListNode* dummy = new ListNode(0,head);\\n        ListNode* p=dummy, *q=head;\\n        int flag=1;\\n        while(q && q->next){\\n            if(q->val == q->next->val){\\n                q=q->next;\\n                flag=0;\\n            }\\n            else{\\n                if(flag){\\n                    p=p->next;\\n                    q=q->next;\\n                }\\n                else{\\n                    p->next = q->next;\\n                    q=q->next;\\n                }\\n                flag=1;\\n            }\\n        }\\n        if(flag){\\n            p=p->next;\\n            q=q->next;\\n        }\\n        else{\\n            p->next = q->next;\\n            q=q->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n            return  NULL;\\n        ListNode* dummy = new ListNode(0,head);\\n        ListNode* p=dummy, *q=head;\\n        int flag=1;\\n        while(q && q->next){\\n            if(q->val == q->next->val){\\n                q=q->next;\\n                flag=0;\\n            }\\n            else{\\n                if(flag){\\n                    p=p->next;\\n                    q=q->next;\\n                }\\n                else{\\n                    p->next = q->next;\\n                    q=q->next;\\n                }\\n                flag=1;\\n            }\\n        }\\n        if(flag){\\n            p=p->next;\\n            q=q->next;\\n        }\\n        else{\\n            p->next = q->next;\\n            q=q->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059535,
                "title": "0ms-beats100-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null) return null;\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n        ListNode ptr=dummy;\\n        while(ptr.next!=null && ptr.next.next!=null){\\n            if(ptr.next.val==ptr.next.next.val){\\n                int value=ptr.next.val;\\n                while(ptr.next!=null && ptr.next.val==value){\\n                    ptr.next=ptr.next.next;\\n                }\\n            }\\n            else{\\n                ptr=ptr.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null) return null;\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n        ListNode ptr=dummy;\\n        while(ptr.next!=null && ptr.next.next!=null){\\n            if(ptr.next.val==ptr.next.next.val){\\n                int value=ptr.next.val;\\n                while(ptr.next!=null && ptr.next.val==value){\\n                    ptr.next=ptr.next.next;\\n                }\\n            }\\n            else{\\n                ptr=ptr.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057378,
                "title": "0ms-100-faster-java-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null) return null;\\n\\n        ListNode ans=new ListNode();\\n        ans.next=head;\\n\\n        ListNode ptr=ans;\\n\\n        while(ptr.next!=null && ptr.next.next!=null){\\n\\n            if(ptr.next.val == ptr.next.next.val){\\n                int value=ptr.next.val;\\n                while(ptr.next!=null && ptr.next.val==value){\\n                    ptr.next=ptr.next.next;\\n                }\\n            }\\n            else{\\n                ptr=ptr.next;\\n            }\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null) return null;\\n\\n        ListNode ans=new ListNode();\\n        ans.next=head;\\n\\n        ListNode ptr=ans;\\n\\n        while(ptr.next!=null && ptr.next.next!=null){\\n\\n            if(ptr.next.val == ptr.next.next.val){\\n                int value=ptr.next.val;\\n                while(ptr.next!=null && ptr.next.val==value){\\n                    ptr.next=ptr.next.next;\\n                }\\n            }\\n            else{\\n                ptr=ptr.next;\\n            }\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831244,
                "title": "java-solution-faster-than-100-of-java-submissions-easy-to-understand",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {    \\n        ListNode result = new ListNode(0, null);\\n        ListNode curr = result;\\n        boolean isRepeated = false;\\n        while (head != null){\\n            while (head.next != null && head.val == head.next.val){\\n                isRepeated = true;\\n                head = head.next;\\n            }\\n            \\n            if (!isRepeated){\\n                curr.next = new ListNode(head.val, null);\\n                curr = curr.next;\\n            }\\n            \\n            isRepeated = false;\\n            head = head.next;\\n        }\\n        return result.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {    \\n        ListNode result = new ListNode(0, null);\\n        ListNode curr = result;\\n        boolean isRepeated = false;\\n        while (head != null){\\n            while (head.next != null && head.val == head.next.val){\\n                isRepeated = true;\\n                head = head.next;\\n            }\\n            \\n            if (!isRepeated){\\n                curr.next = new ListNode(head.val, null);\\n                curr = curr.next;\\n            }\\n            \\n            isRepeated = false;\\n            head = head.next;\\n        }\\n        return result.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834326,
                "title": "python-easy-solution",
                "content": "```\\n\\n```class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        l = {}\\n        h = ret = ListNode(0)\\n        while head:\\n            if head.val not in l.keys():\\n                l[head.val] = 1\\n            else:\\n                l[head.val] += 1\\n            head = head.next\\n        for i in l.keys():\\n            if l[i] == 1:\\n                # print(i)\\n                ret.next = ListNode(i)\\n                ret = ret.next\\n        return h.next",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1833325,
                "title": "remove-duplicate-from-sorted-list-ii-t-c-o-n-s-c-o-1",
                "content": "```\\nListNode* deleteDuplicates(ListNode* head) \\n    {\\n\\t\\t// Return head, if no nodes are present or only one node is present.\\n        if (!head || !head->next)\\n            return head;\\n\\t\\t// Create a prev variable of ListNode type and initialize it with 0.\\n        ListNode* prev = new ListNode(0);\\n        ListNode* ans = prev; // To keep track of first element of the prev.\\n        ListNode* curr = head; \\n\\t\\t// Run the loop unless you find end of the loop or last node.\\n        while (curr && curr->next)\\n        {\\n\\t\\t\\t// Run another loop to skip the duplicate number.\\n            while (curr && curr->next && curr->val == curr->next->val)\\n            {\\n                int x = curr->val;\\n                while (curr && curr->val == x)\\n                    curr = curr->next;\\n            }\\n\\t\\t\\t// After skipping the nodes, join the prev node to the next of the last repeating or duplicate node.\\n            prev->next = curr;\\n            prev = prev->next;\\n            curr = (curr != NULL)? curr->next: NULL; // increment curr until it become NULL.\\n        }\\n\\t\\t// Return next of ans, since prev is having a dummy value a the first node.\\n        return ans->next;\\n    }\\n\\t// Even after running two nested loops, each node is visited only ones, hence the solution is O(n) and space requirement is O(1).\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nListNode* deleteDuplicates(ListNode* head) \\n    {\\n\\t\\t// Return head, if no nodes are present or only one node is present.\\n        if (!head || !head->next)\\n            return head;\\n\\t\\t// Create a prev variable of ListNode type and initialize it with 0.\\n        ListNode* prev = new ListNode(0);\\n        ListNode* ans = prev; // To keep track of first element of the prev.\\n        ListNode* curr = head; \\n\\t\\t// Run the loop unless you find end of the loop or last node.\\n        while (curr && curr->next)\\n        {\\n\\t\\t\\t// Run another loop to skip the duplicate number.\\n            while (curr && curr->next && curr->val == curr->next->val)\\n            {\\n                int x = curr->val;\\n                while (curr && curr->val == x)\\n                    curr = curr->next;\\n            }\\n\\t\\t\\t// After skipping the nodes, join the prev node to the next of the last repeating or duplicate node.\\n            prev->next = curr;\\n            prev = prev->next;\\n            curr = (curr != NULL)? curr->next: NULL; // increment curr until it become NULL.\\n        }\\n\\t\\t// Return next of ans, since prev is having a dummy value a the first node.\\n        return ans->next;\\n    }\\n\\t// Even after running two nested loops, each node is visited only ones, hence the solution is O(n) and space requirement is O(1).\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1597764,
                "title": "two-pointers-with-python",
                "content": "```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        dummy = ListNode(0,head)\\n        cur = head\\n        pre = dummy\\n        while cur and cur.next:\\n            while cur.next and cur.val == cur.next.val:\\n                cur = cur.next\\n            if pre.next == cur:\\n                pre = pre.next\\n                \\n            else:\\n                pre.next = cur.next\\n                \\n            cur = cur.next\\n\\n        return dummy.next\\n\\t\\t\\n\\n**Note**\\n\\n1. Linked list in python is a blind point to me. It was hard for me to realize that the `head` is actually a node, that points to the following list, say, `[1,2,3,3,4,4,5]`. \\n\\n2. In python, linked list has shallow copy too.\\n3. Whenever deal with the linked list type of problem, consider the feasibility of `dummy` node first. Two pointers must have a dummy node.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        dummy = ListNode(0,head)\\n        cur = head\\n        pre = dummy\\n        while cur and cur.next:\\n            while cur.next and cur.val == cur.next.val:\\n                cur = cur.next\\n            if pre.next == cur:\\n                pre = pre.next\\n                \\n            else:\\n                pre.next = cur.next\\n                \\n            cur = cur.next\\n\\n        return dummy.next\\n\\t\\t\\n\\n**Note**\\n\\n1. Linked list in python is a blind point to me. It was hard for me to realize that the `head` is actually a node, that points to the following list, say, `[1,2,3,3,4,4,5]`. \\n\\n2. In python, linked list has shallow copy too.\\n3. Whenever deal with the linked list type of problem, consider the feasibility of `dummy` node first. Two pointers must have a dummy node.",
                "codeTag": "Java"
            },
            {
                "id": 1545206,
                "title": "o-n-and-o-1",
                "content": "\\n\\t\\tListNode* tmp = new ListNode(-1);\\n        tmp->next = head;\\n        ListNode* prev = tmp;\\n        while(head != NULL && head->next != NULL)\\n        {\\n            if(head->val == head->next->val)\\n            {\\n                while(head->next != NULL && head->val == head->next->val)\\n                    head = head->next;\\n                head = head->next;\\n                prev->next = head;\\n            }\\n            else\\n            {\\n                prev = head;\\n                head = head->next;\\n            }\\n        }\\n        \\n        return tmp->next;",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\n\\t\\tListNode* tmp = new ListNode(-1);\\n        tmp->next = head;\\n        ListNode* prev = tmp;\\n        while(head != NULL && head->next != NULL)\\n        {\\n            if(head->val == head->next->val)\\n            {\\n                while(head->next != NULL && head->val == head->next->val)\\n                    head = head->next;\\n                head = head->next;\\n                prev->next = head;\\n            }\\n            else\\n            {\\n                prev = head;\\n                head = head->next;\\n            }\\n        }\\n        \\n        return tmp->next;",
                "codeTag": "Unknown"
            },
            {
                "id": 1520823,
                "title": "javascript-solution",
                "content": "```\\nvar deleteDuplicates = function(head) {\\n    let tmpHead = new ListNode();\\n    tmpHead.next = head;\\n    let cur = tmpHead;\\n    let visted = new Set();\\n    while(cur.next){\\n       let counter = 0;\\n       let val = cur.next.val;\\n       let tmp = cur.next;\\n       while(tmp && tmp.val == val){\\n           counter++;\\n           tmp =  tmp.next\\n       }\\n       if(counter > 1) cur.next = tmp;\\n       else cur = cur.next; \\n    }\\n    return tmpHead.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteDuplicates = function(head) {\\n    let tmpHead = new ListNode();\\n    tmpHead.next = head;\\n    let cur = tmpHead;\\n    let visted = new Set();\\n    while(cur.next){\\n       let counter = 0;\\n       let val = cur.next.val;\\n       let tmp = cur.next;\\n       while(tmp && tmp.val == val){\\n           counter++;\\n           tmp =  tmp.next\\n       }\\n       if(counter > 1) cur.next = tmp;\\n       else cur = cur.next; \\n    }\\n    return tmpHead.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1403605,
                "title": "recursive-rust-short-and-easy-to-understand-0ms-beats-100",
                "content": "I find recursion to be more intuitive for this problem. Essentially, if the current node\\'s value is the same as the previous node\\'s value (`prev`) or if the next node is not `None` and both the current node and the next node have the same value, then I\\'ll skip the current node. Or else, the `next` of the current node is the result of recursively calling the function using the next node as head, and the current node\\'s value as `prev`.\\n\\n```rust\\nimpl Solution {\\n    pub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        fn go(node: Option<Box<ListNode>>, prev: Option<i32>) -> Option<Box<ListNode>> {\\n            if let Some(mut n) = node {\\n                let x = Some(n.val);\\n                if x == prev {\\n                    go(n.next, prev)\\n                } else {\\n                    match n.next {\\n                        Some(n2) if n2.val == n.val => go(Some(n2), x),\\n                        _ => {\\n                            n.next = go(n.next, x);\\n                            Some(Box::new(*n))\\n                        }\\n                    }\\n                }\\n            } else {\\n                None\\n            }\\n        }\\n\\n        go(head, None)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        fn go(node: Option<Box<ListNode>>, prev: Option<i32>) -> Option<Box<ListNode>> {\\n            if let Some(mut n) = node {\\n                let x = Some(n.val);\\n                if x == prev {\\n                    go(n.next, prev)\\n                } else {\\n                    match n.next {\\n                        Some(n2) if n2.val == n.val => go(Some(n2), x),\\n                        _ => {\\n                            n.next = go(n.next, x);\\n                            Some(Box::new(*n))\\n                        }\\n                    }\\n                }\\n            } else {\\n                None\\n            }\\n        }\\n\\n        go(head, None)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1368599,
                "title": "golang-clean-solution",
                "content": "```\\nfunc deleteDuplicates(head *ListNode) *ListNode {\\n    prev := &ListNode{-101, head}\\n    res := prev\\n    \\n    for prev.Next != nil {\\n        val := prev.Next.Val\\n        removed := false\\n        \\n        for prev.Next.Next != nil && prev.Next.Next.Val == val {\\n            prev.Next = prev.Next.Next\\n            removed = true\\n        }\\n        \\n        if removed {\\n            prev.Next = prev.Next.Next\\n            continue\\n        } \\n        prev = prev.Next\\n    }\\n    return res.Next\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc deleteDuplicates(head *ListNode) *ListNode {\\n    prev := &ListNode{-101, head}\\n    res := prev\\n    \\n    for prev.Next != nil {\\n        val := prev.Next.Val\\n        removed := false\\n        \\n        for prev.Next.Next != nil && prev.Next.Next.Val == val {\\n            prev.Next = prev.Next.Next\\n            removed = true\\n        }\\n        \\n        if removed {\\n            prev.Next = prev.Next.Next\\n            continue\\n        } \\n        prev = prev.Next\\n    }\\n    return res.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1265247,
                "title": "simplest-approach-and-explained-with-comments",
                "content": "**Idea is to count the number of nodes and if its freq is 1 connect them.**\\n```\\nListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL){\\n            return head;\\n        }\\n        \\n        ListNode *dummy = new ListNode(0);\\n        ListNode *iter = dummy;\\n        ListNode *cur = head;\\n        //itearte until cur is not NULL\\n        while(cur != NULL){\\n            //store the current node\\n           ListNode *temp = cur;\\n            //counter to store the value repeat\\n           int cnt = 0;\\n            //count number of times it is repeat\\n           while(cur != NULL and (temp -> val == cur -> val)){\\n               cur = cur -> next;\\n               cnt++;\\n           }\\n            //disconnect link with cur\\n           temp -> next = NULL;\\n            //if count is 1 \\n            //that means it is not repeated\\n           if(cnt == 1){    \\n             iter -> next = temp;\\n             iter = iter -> next;\\n           }\\n        }\\n        return dummy -> next;\\n    }\\n```\\n**If you found this approach helpful Please upvote this post :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Iterator"
                ],
                "code": "```\\nListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL){\\n            return head;\\n        }\\n        \\n        ListNode *dummy = new ListNode(0);\\n        ListNode *iter = dummy;\\n        ListNode *cur = head;\\n        //itearte until cur is not NULL\\n        while(cur != NULL){\\n            //store the current node\\n           ListNode *temp = cur;\\n            //counter to store the value repeat\\n           int cnt = 0;\\n            //count number of times it is repeat\\n           while(cur != NULL and (temp -> val == cur -> val)){\\n               cur = cur -> next;\\n               cnt++;\\n           }\\n            //disconnect link with cur\\n           temp -> next = NULL;\\n            //if count is 1 \\n            //that means it is not repeated\\n           if(cnt == 1){    \\n             iter -> next = temp;\\n             iter = iter -> next;\\n           }\\n        }\\n        return dummy -> next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261074,
                "title": "simple-and-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n       ListNode *dummy=new ListNode(0,head);\\n        ListNode *prev=dummy;\\n        while(head!=NULL)\\n        {if(head->next!=NULL && head->val==head->next->val)\\n            {while(head->next!=NULL && head->val==head->next->val)\\n                    head=head->next;   \\n             prev->next=head->next;\\n            }\\n            else\\n            prev=head;  \\n        head=head->next;\\n        }\\n        return dummy->next;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n       ListNode *dummy=new ListNode(0,head);\\n        ListNode *prev=dummy;\\n        while(head!=NULL)\\n        {if(head->next!=NULL && head->val==head->next->val)\\n            {while(head->next!=NULL && head->val==head->next->val)\\n                    head=head->next;   \\n             prev->next=head->next;\\n            }\\n            else\\n            prev=head;  \\n        head=head->next;\\n        }\\n        return dummy->next;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198277,
                "title": "c-one-pass-solution-o-n-time-o-1-space",
                "content": "Basically at each value, have a slow pointer wait there, and have another pointer go forward and see if any others have the same value.\\nSince we know that this list is sorted, if there is another node with the same value, we know that there are duplicates.\\nSimply overwrite the duplicates and set slow to fast (as fast will be set to a new value) and continue.\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (!head || !head->next) return head; // zero or one nodes in list\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* res = new ListNode(-1);\\n        ListNode* res_curr = res;\\n        \\n        while (slow) {\\n            int c = 0;\\n            \\n            while (fast && slow->val == fast->val) {\\n                fast = fast->next;\\n                c++;\\n            }\\n            \\n            if (c < 2) {\\n                res_curr->next = slow;\\n                res_curr = res_curr->next;\\n            }\\n            \\n            if (!fast) {\\n                res_curr->next = nullptr;\\n                break;\\n            }\\n            slow = fast;\\n        }\\n        \\n        return res->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (!head || !head->next) return head; // zero or one nodes in list\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* res = new ListNode(-1);\\n        ListNode* res_curr = res;\\n        \\n        while (slow) {\\n            int c = 0;\\n            \\n            while (fast && slow->val == fast->val) {\\n                fast = fast->next;\\n                c++;\\n            }\\n            \\n            if (c < 2) {\\n                res_curr->next = slow;\\n                res_curr = res_curr->next;\\n            }\\n            \\n            if (!fast) {\\n                res_curr->next = nullptr;\\n                break;\\n            }\\n            slow = fast;\\n        }\\n        \\n        return res->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179340,
                "title": "c-easy-using-maps",
                "content": "***Do upvote if it helped you to keep me motivated***  \\uD83D\\uDE0A\\u270C\\n***Explanation in the comments section***\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n      map<int,int> m;\\n      ListNode* temp = head;\\n        while(temp!=NULL)\\n        {\\n            m[temp->val]++;\\n            temp = temp->next;\\n        }\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* curr = dummy;\\n        for(auto x: m)\\n        {\\n            if(x.second==1)\\n            {\\n               curr->next = new ListNode(x.first);\\n                curr = curr->next;\\n            }\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n      map<int,int> m;\\n      ListNode* temp = head;\\n        while(temp!=NULL)\\n        {\\n            m[temp->val]++;\\n            temp = temp->next;\\n        }\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* curr = dummy;\\n        for(auto x: m)\\n        {\\n            if(x.second==1)\\n            {\\n               curr->next = new ListNode(x.first);\\n                curr = curr->next;\\n            }\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056505,
                "title": "c-0ms-two-pointers-iterative-beat-100-speed-and-96-87-memory",
                "content": "**Simple Understandable Two pointers approach. (Iterative)**\\n\\nIntializing two pointers temp and prev (previous), temp points to head and intially previous is dummy node (pointing to NULL). \\n1. Starting from head, compare every node value with its next node value.\\n2. If value is same, move temp pointer to the node until value is different. Now, temp is at present just before the node where value is different. **Point to next of this node with prev pointer ( because we want different value)** No need of extra pointer :).\\n3. Relocating the pointers to new postion and move ahead until last node.\\n\\nHere is the code for the same approach. \\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode* temp = head;\\n        ListNode* prev = new ListNode(0);\\n        while(temp != NULL && temp->next != NULL){\\n            if(temp->val== temp->next->val){\\n                while(temp->next != NULL && temp->val == temp->next->val ) {\\n                    temp->next = temp->next->next;\\n                }\\n                if(temp == head) head = temp->next;\\n                else {\\n                     prev->next = temp->next;\\n                     temp = temp->next;\\n                }\\n            }\\n            else {\\n                prev = temp;\\n                temp = temp->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode* temp = head;\\n        ListNode* prev = new ListNode(0);\\n        while(temp != NULL && temp->next != NULL){\\n            if(temp->val== temp->next->val){\\n                while(temp->next != NULL && temp->val == temp->next->val ) {\\n                    temp->next = temp->next->next;\\n                }\\n                if(temp == head) head = temp->next;\\n                else {\\n                     prev->next = temp->next;\\n                     temp = temp->next;\\n                }\\n            }\\n            else {\\n                prev = temp;\\n                temp = temp->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003849,
                "title": "swift-solution-using-two-pointers-and-a-dummy-with-comments",
                "content": "```\\nclass Solution {\\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        guard let head = head else { return nil }\\n        // Declare a dummy node to start from it and later use it to return the result.\\n        let dummy: ListNode? = ListNode(Int.min)\\n        // Connect dummy with the head\\n        dummy?.next = head\\n        // Use two pointer approach to be able to delete nodes in between them.\\n        var previous: ListNode? = dummy\\n        var current: ListNode? = dummy?.next\\n\\n        // Iterate through all nodes in the list\\n        while current != nil {\\n            // If we have a duplicate\\n            if current?.next?.val == current?.val {\\n                // Iterate until current points to the last duplicated node, needed if there\\'s more than 2 duplicates in a row\\n                while current?.next?.val == current?.val {\\n                    current = current?.next\\n                }\\n                // Remove duplicates by connecting previous with the node after last duplicate\\n                previous?.next = current?.next\\n                // Move current pointer to the next node to continue looping\\n                current = current?.next\\n            } else {\\n                // if the duplicate condition didn\\'t trigger, continue looping\\n                previous = current\\n                current = current?.next\\n            }\\n        }\\n        // The result is dummy\\'s next node\\n        return dummy?.next\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        guard let head = head else { return nil }\\n        // Declare a dummy node to start from it and later use it to return the result.\\n        let dummy: ListNode? = ListNode(Int.min)\\n        // Connect dummy with the head\\n        dummy?.next = head\\n        // Use two pointer approach to be able to delete nodes in between them.\\n        var previous: ListNode? = dummy\\n        var current: ListNode? = dummy?.next\\n\\n        // Iterate through all nodes in the list\\n        while current != nil {\\n            // If we have a duplicate\\n            if current?.next?.val == current?.val {\\n                // Iterate until current points to the last duplicated node, needed if there\\'s more than 2 duplicates in a row\\n                while current?.next?.val == current?.val {\\n                    current = current?.next\\n                }\\n                // Remove duplicates by connecting previous with the node after last duplicate\\n                previous?.next = current?.next\\n                // Move current pointer to the next node to continue looping\\n                current = current?.next\\n            } else {\\n                // if the duplicate condition didn\\'t trigger, continue looping\\n                previous = current\\n                current = current?.next\\n            }\\n        }\\n        // The result is dummy\\'s next node\\n        return dummy?.next\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003385,
                "title": "java-o-n-0ms-recursive-solution",
                "content": "```\\n/**\\n  Definition for singly-linked list.\\n  public class ListNode {\\n      int val;\\n      ListNode next;\\n      ListNode() {}\\n      ListNode(int val) { this.val = val; }\\n      ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n  }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null)\\n            return head;\\n        if(head.next==null)\\n            return head;\\n        if(head.val !=head.next.val)\\n        {\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }else{\\n            int temp = head.val;\\n            while(head!=null && head.val==temp)\\n                head=head.next;\\n            return deleteDuplicates(head);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n  Definition for singly-linked list.\\n  public class ListNode {\\n      int val;\\n      ListNode next;\\n      ListNode() {}\\n      ListNode(int val) { this.val = val; }\\n      ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n  }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null)\\n            return head;\\n        if(head.next==null)\\n            return head;\\n        if(head.val !=head.next.val)\\n        {\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }else{\\n            int temp = head.val;\\n            while(head!=null && head.val==temp)\\n                head=head.next;\\n            return deleteDuplicates(head);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003278,
                "title": "c-iteration-recursion-with-sentinel-head-predecessor",
                "content": "**Idea:**\\nSimulation.\\nJust begin with the conceret examples and try to solve them one by one: \\ni) with/without repetition,\\nii) repetition shows up in the middle, begining, ending.\\nDone.\\n\\n**Comments:**\\nWith iteration  apporach, you need address each corner cases.\\nWith recursion approach, you only need focus on the recursion pattern. Your code is only as crystal clear as your thinking. \\n\\nApproach 1: 2-pointer: Sentinel Head + Predecessor\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {        \\n        ListNode dummy(-101), *p = head, *p2=&dummy;        \\n        while(p){\\n            ListNode *l = p, *r = p->next;            \\n            while(r && l->val == r->val) r = r->next;                            \\n            if(l->next == r){ // no repetition\\n                p2->next = l;\\n                p2 = p2->next;\\n                p2->next = NULL; // break chain/list, example: [1, 2, 2]\\n            }\\n            p = r;            \\n        }\\n        return dummy.next;\\n    }\\n};\\n```\\n\\nApproach 2: Recursion\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode * p = head->next;\\n        if(p->val != head->val){\\n            head->next = deleteDuplicates(head->next);\\n            return head;\\n        }else{\\n            while(p && p-> val == head->val) p = p->next;\\n            return deleteDuplicates(p);            \\n        }        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {        \\n        ListNode dummy(-101), *p = head, *p2=&dummy;        \\n        while(p){\\n            ListNode *l = p, *r = p->next;            \\n            while(r && l->val == r->val) r = r->next;                            \\n            if(l->next == r){ // no repetition\\n                p2->next = l;\\n                p2 = p2->next;\\n                p2->next = NULL; // break chain/list, example: [1, 2, 2]\\n            }\\n            p = r;            \\n        }\\n        return dummy.next;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode * p = head->next;\\n        if(p->val != head->val){\\n            head->next = deleteDuplicates(head->next);\\n            return head;\\n        }else{\\n            while(p && p-> val == head->val) p = p->next;\\n            return deleteDuplicates(p);            \\n        }        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003000,
                "title": "simple-java-solution-with-explaination-0ms-100-faster",
                "content": "1.To avoid head null checks create dummy node and point dummy.next=head.\\n2.Take two pointers. prev and temp. prev point to dummy initially and temp point to head.\\n3. loop till temp and temp next is available. (as for single node nothing to be deleted)\\n4. if matching element found keep on incrementing temp without changing previous inside loop.\\n5. after loop finishes at point 4 we use boolean to check if some duplicates has found. if yes just point prev.next=temp.next. else just increment prev.\\n6. in any case if duplicate exists or not increment temp to point to next element. \\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy= new ListNode(101,head);\\n        ListNode prev = dummy;\\n        ListNode temp = head;\\n        boolean match=false;\\n        while(temp!=null && temp.next!=null) {\\n            match=false;\\n            while(temp.next!=null && temp.next.val==temp.val) {\\n                temp=temp.next;\\n                match=true;\\n            }   \\n            if(match) {\\n                prev.next=temp.next;\\n            } else {\\n                prev=prev.next;\\n            }\\n            temp=temp.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy= new ListNode(101,head);\\n        ListNode prev = dummy;\\n        ListNode temp = head;\\n        boolean match=false;\\n        while(temp!=null && temp.next!=null) {\\n            match=false;\\n            while(temp.next!=null && temp.next.val==temp.val) {\\n                temp=temp.next;\\n                match=true;\\n            }   \\n            if(match) {\\n                prev.next=temp.next;\\n            } else {\\n                prev=prev.next;\\n            }\\n            temp=temp.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758858,
                "title": "java-100-recursion-short-code",
                "content": "If you found the solution helpfu, kindly like or upvote. :)\\n\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null || head.next==null)\\n    \\t\\treturn head;\\n    \\tif(head.val!= head.next.val)\\n    \\t{\\n    \\t\\thead.next=deleteDuplicates(head.next);\\n    \\t\\treturn head;\\n    \\t}\\n    \\t//If there are duplicacy in head\\n    \\tListNode curr= head;\\n    \\twhile(curr !=null &&curr.val==head.val)\\n    \\t{\\n    \\t\\tcurr=curr.next;\\n    \\t}\\n    \\t\\n    \\treturn deleteDuplicates(curr);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null || head.next==null)\\n    \\t\\treturn head;\\n    \\tif(head.val!= head.next.val)\\n    \\t{\\n    \\t\\thead.next=deleteDuplicates(head.next);\\n    \\t\\treturn head;\\n    \\t}\\n    \\t//If there are duplicacy in head\\n    \\tListNode curr= head;\\n    \\twhile(curr !=null &&curr.val==head.val)\\n    \\t{\\n    \\t\\tcurr=curr.next;\\n    \\t}\\n    \\t\\n    \\treturn deleteDuplicates(curr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738462,
                "title": "c-very-important-memory-leak-handled-beats-95-speed-and-100-memory",
                "content": "The major issue when handling pointers are to check for a memory leak. \\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==nullptr) return head;\\n        ListNode* p1=head->next;\\n        if(p1 && p1->val==head->val){\\n         while(p1 && p1->val==head->val) {\\n             ListNode* p2= p1;\\n             p1=p1->next;\\n             p2->next = nullptr;\\n         }\\n            return deleteDuplicates(p1);\\n        }\\n        else \\n        head->next = deleteDuplicates(head->next);\\n        return head;\\n    } \\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==nullptr) return head;\\n        ListNode* p1=head->next;\\n        if(p1 && p1->val==head->val){\\n         while(p1 && p1->val==head->val) {\\n             ListNode* p2= p1;\\n             p1=p1->next;\\n             p2->next = nullptr;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 694199,
                "title": "java-solution-create-dummy-node",
                "content": "````\\npublic ListNode deleteDuplicates(ListNode head) {\\n        \\n        if(head==null) return null;\\n        if(head.next==null) return head;\\n        \\n        ListNode dummy=new ListNode(-1,head);\\n        ListNode p=dummy;\\n        \\n        while(p.next!=null){\\n                     \\n            ListNode n=p.next;\\n            while(n.next!=null && n.val==n.next.val){\\n                n=n.next;\\n            }\\n            \\n            if(p.next==n){\\n                p=n;\\n            }else{\\n                p.next=n.next;\\n            }\\n            \\n        }\\n        \\n        return dummy.next;\\n        \\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "````\\npublic ListNode deleteDuplicates(ListNode head) {\\n        \\n        if(head==null) return null;\\n        if(head.next==null) return head;\\n        \\n        ListNode dummy=new ListNode(-1,head);\\n        ListNode p=dummy;\\n        \\n        while(p.next!=null){\\n                     \\n            ListNode n=p.next;\\n            while(n.next!=null && n.val==n.next.val){\\n                n=n.next;\\n            }\\n            \\n            if(p.next==n){\\n                p=n;\\n            }else{\\n                p.next=n.next;\\n            }\\n            \\n        }\\n        \\n        return dummy.next;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 396679,
                "title": "easy-to-understand-recursive-approach-and-iterative-approach-in-java-with-detailed-comment",
                "content": "Solution A: Recursive way\\n```\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null) return null;\\n        if(head.next != null && head.val == head.next.val){\\n            while(head.next != null && head.val == head.next.val){ // if current node is not unique, skip it and its duplicates, then check following\\n                head = head.next;\\n            }\\n            return deleteDuplicates(head.next);\\n        }else{\\n            head.next = deleteDuplicates(head.next); // if current node is unique, keep it, and check following\\n        }\\n        return head;\\n    }\\n```\\n\\nSolution B: Iterative way\\n```\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null) return null;\\n        \\n        ListNode newDummy = new ListNode(-1); // the dummy head of the non-duplicate linked list\\n        ListNode nonDup = newDummy; // the pointer used to traverse non-duplicate linked list\\n        \\n        ListNode node = head; // the pointer used to traverse the original linked list\\n        \\n        while(node != null){\\n            if(node.next != null && node.val == node.next.val){\\n                int dupVal = node.val; // record the value of duplicates\\n                while(node != null && node.val == dupVal){\\n                    node = node.next; // skip all the duplicates\\n                }\\n            }else{\\n                nonDup.next = node;\\n                nonDup = nonDup.next;\\n                node = node.next;\\n            }\\n        }\\n        \\n        nonDup.next = null; // cut the following nodes referenced by node.next ...\\n        \\n        return newDummy.next;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null) return null;\\n        if(head.next != null && head.val == head.next.val){\\n            while(head.next != null && head.val == head.next.val){ // if current node is not unique, skip it and its duplicates, then check following\\n                head = head.next;\\n            }\\n            return deleteDuplicates(head.next);\\n        }else{\\n            head.next = deleteDuplicates(head.next); // if current node is unique, keep it, and check following\\n        }\\n        return head;\\n    }\\n```\n```\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null) return null;\\n        \\n        ListNode newDummy = new ListNode(-1); // the dummy head of the non-duplicate linked list\\n        ListNode nonDup = newDummy; // the pointer used to traverse non-duplicate linked list\\n        \\n        ListNode node = head; // the pointer used to traverse the original linked list\\n        \\n        while(node != null){\\n            if(node.next != null && node.val == node.next.val){\\n                int dupVal = node.val; // record the value of duplicates\\n                while(node != null && node.val == dupVal){\\n                    node = node.next; // skip all the duplicates\\n                }\\n            }else{\\n                nonDup.next = node;\\n                nonDup = nonDup.next;\\n                node = node.next;\\n            }\\n        }\\n        \\n        nonDup.next = null; // cut the following nodes referenced by node.next ...\\n        \\n        return newDummy.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 386437,
                "title": "4ms-c-solution",
                "content": "```\\nstruct ListNode* deleteDuplicates(struct ListNode* head) {\\n    if(head == NULL)\\n        return NULL;\\n    if(head->next && head->val == head->next->val) {\\n        /* Remove all duplicate numbers */\\n        while(head->next && head->val == head->next->val)\\n            head = head -> next;\\n        return deleteDuplicates(head->next);\\n    } else {\\n        head->next = deleteDuplicates(head->next);\\n    }\\n    return head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct ListNode* deleteDuplicates(struct ListNode* head) {\\n    if(head == NULL)\\n        return NULL;\\n    if(head->next && head->val == head->next->val) {\\n        /* Remove all duplicate numbers */\\n        while(head->next && head->val == head->next->val)\\n            head = head -> next;\\n        return deleteDuplicates(head->next);\\n    } else {\\n        head->next = deleteDuplicates(head->next);\\n    }\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 381446,
                "title": "c-best-solution-easy-simplest-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n\\n        unordered_set<int> s;\\n        \\n        ListNode *t=head;\\n        \\n        if(!head)\\n            return head;\\n        \\n        while(t->next)\\n        {\\n            if(t->next->val == t->val)\\n                s.insert(t->val);\\n            \\n            t=t->next;\\n        }\\n        \\n        t=head;\\n        \\n        \\n        {\\n            while(t->next){\\n                if(s.find(t->next->val)!=s.end())\\n                    t->next=t->next->next;\\n                else\\n                    t=t->next;\\n                \\n            }\\n        }\\n        \\n        if(s.find(head->val)!=s.end())\\n            return head->next;\\n        else\\n            return head;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n\\n        unordered_set<int> s;\\n        \\n        ListNode *t=head;\\n        \\n        if(!head)\\n            return head;\\n        \\n        while(t->next)\\n        {\\n            if(t->next->val == t->val)\\n                s.insert(t->val);\\n            \\n            t=t->next;\\n        }\\n        \\n        t=head;\\n        \\n        \\n        {\\n            while(t->next){\\n                if(s.find(t->next->val)!=s.end())\\n                    t->next=t->next->next;\\n                else\\n                    t=t->next;\\n                \\n            }\\n        }\\n        \\n        if(s.find(head->val)!=s.end())\\n            return head->next;\\n        else\\n            return head;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 322205,
                "title": "javascript-straightforward-solution",
                "content": "```\\nvar deleteDuplicates = function(head) {\\n\\n    let curr = head;\\n    let prev = null; // previous node\\n    \\n    while(curr != null && curr.next != null){\\n        let val; \\n        if(curr.val == curr.next.val){\\n            val = curr.val; // find next node not equal to val:\\n            while(curr != null && curr.val == val)\\n                curr = curr.next;\\n            // erase all \\'val\\' nodes:\\n            if(prev != null){  \\n                prev.next = curr;\\n            }\\n            else{\\n                head = curr;  // change head if it\\'s first node              \\n            }\\n        }\\n        else{\\n            prev = curr;\\n            curr = curr.next;\\n        }\\n    }\\n   \\n    return head;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar deleteDuplicates = function(head) {\\n\\n    let curr = head;\\n    let prev = null; // previous node\\n    \\n    while(curr != null && curr.next != null){\\n        let val; \\n        if(curr.val == curr.next.val){\\n            val = curr.val; // find next node not equal to val:\\n            while(curr != null && curr.val == val)\\n                curr = curr.next;\\n            // erase all \\'val\\' nodes:\\n            if(prev != null){  \\n                prev.next = curr;\\n            }\\n            else{\\n                head = curr;  // change head if it\\'s first node              \\n            }\\n        }\\n        else{\\n            prev = curr;\\n            curr = curr.next;\\n        }\\n    }\\n   \\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 315543,
                "title": "java-recursive-solution-100-time-100-space",
                "content": "Time O(n)  Space O(n)\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        if (head.val != head.next.val) {\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }\\n        while (head.next != null && head.val == head.next.val) {\\n            head = head.next;\\n        }\\n        return deleteDuplicates(head.next);\\n    }\\n}\\n```\\nIterative solution space is O(1)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        if (head.val != head.next.val) {\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }\\n        while (head.next != null && head.val == head.next.val) {\\n            head = head.next;\\n        }\\n        return deleteDuplicates(head.next);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 258435,
                "title": "c-solution-with-explanation",
                "content": "In terms of memory leak, it is dangerous to delete or free memories which are not allocated by your program.\\n\\nIn addition, modern C++ encourages programmers to use smart pointer classes, like shared_ptr, instead of pure pointers. Interviewers may be more than happy to disscuss these topics.\\n\\n```\\nclass Solution {\\npublic:\\n    // return the ptr of first non-repeating elements starting from head\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (!head || !head->next) return head; // base cases\\n        if (head->next->val == head->val) {\\n            // this head is duplicate and can not be used\\n            \\n            while (head->next && head->next->val == head->val) {\\n                // skip until a non-repeating element (or NULL) appears\\n                head = head->next;\\n            }\\n            // check that element\\n            return deleteDuplicates(head->next);\\n        }\\n        // this head can be use, check the subsequent elements \\n        // and connect them together\\n        head->next = deleteDuplicates(head->next);\\n        return head;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    // return the ptr of first non-repeating elements starting from head\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (!head || !head->next) return head; // base cases\\n        if (head->next->val == head->val) {\\n            // this head is duplicate and can not be used\\n            \\n            while (head->next && head->next->val == head->val) {\\n                // skip until a non-repeating element (or NULL) appears\\n                head = head->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 216313,
                "title": "clean-easy-to-understand-c-solution-without-memory-leaks",
                "content": "Most C/C++ solutions leak the nodes that are supposedly deleted or the \\'dummy\\' node. Here\\'s a clean, compact solution that actually doesn\\'t leak memory:\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head == nullptr || head->next == nullptr)  return head;\\n        \\n        ListNode dummyHead(0);  dummyHead.next = head;\\n        ListNode* crt = head;   ListNode* prev = &dummyHead;\\n        while (crt != nullptr && crt->next != nullptr)\\n        {\\n             if (crt->next->val == crt->val)\\n             {\\n                int duplicateVal = crt->val;\\n                while (crt != nullptr && crt->val == duplicateVal)\\n                {\\n                    prev->next = crt->next;\\n                    delete crt;\\n                    crt = prev->next;\\n                }\\n             }\\n             else\\n             {\\n                 prev = crt;\\n                 crt = crt->next;\\n             }\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head == nullptr || head->next == nullptr)  return head;\\n        \\n        ListNode dummyHead(0);  dummyHead.next = head;\\n        ListNode* crt = head;   ListNode* prev = &dummyHead;\\n        while (crt != nullptr && crt->next != nullptr)\\n        {\\n             if (crt->next->val == crt->val)\\n             {\\n                int duplicateVal = crt->val;\\n                while (crt != nullptr && crt->val == duplicateVal)\\n                {\\n                    prev->next = crt->next;\\n                    delete crt;\\n                    crt = prev->next;\\n                }\\n             }\\n             else\\n             {\\n                 prev = crt;\\n                 crt = crt->next;\\n             }\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28344,
                "title": "python-simple-solution",
                "content": "`curr` will always be the node behind, in case the next node is a duplicate that needs to be removed. Even the head can be removed. Hence having a dummy node solves this problem. \\n\\n*- Yangshun*\\n\\n```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        # Time: O(n)\\n        # Space: O(1)\\n        dummy = ListNode(None)\\n        dummy.next = head\\n        curr = dummy\\n        while curr:\\n            has_dup = False\\n            # Remove duplicates and leave the last of the duplicates.\\n            while curr.next and curr.next.next and curr.next.val == curr.next.next.val:\\n                curr.next = curr.next.next\\n                has_dup = True\\n            if has_dup:\\n                # Remove the last duplicate\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return dummy.next\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        # Time: O(n)\\n        # Space: O(1)\\n        dummy = ListNode(None)\\n        dummy.next = head\\n        curr = dummy\\n        while curr:\\n            has_dup = False\\n            # Remove duplicates and leave the last of the duplicates.\\n            while curr.next and curr.next.next and curr.next.val == curr.next.next.val:\\n                curr.next = curr.next.next\\n                has_dup = True\\n            if has_dup:\\n                # Remove the last duplicate\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return dummy.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28388,
                "title": "simple-iterative-solution-with-memory-management",
                "content": "I am not sure why none of the top C++ answers has memory deletion. Here is my simple solution with correct memory release. Would appreciate suggestions.\\n```\\nListNode* deleteDuplicates(ListNode* head) {\\n        ListNode dummy(0);\\n        dummy.next = head;\\n        ListNode *prev = &dummy;\\n        \\n        while (prev->next) {\\n            ListNode *cur = prev->next;\\n            if (cur->next && cur->next->val == cur->val) {\\n                do {\\n                    ListNode* tmp = cur->next->next;\\n                    delete cur->next;\\n                    cur->next = tmp;\\n                } while (cur->next && cur->next->val == cur->val);\\n                prev->next = cur->next;\\n                delete cur;\\n            } else {\\n                prev = prev->next;\\n            }\\n        }\\n      \\n        return dummy.next;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* deleteDuplicates(ListNode* head) {\\n        ListNode dummy(0);\\n        dummy.next = head;\\n        ListNode *prev = &dummy;\\n        \\n        while (prev->next) {\\n            ListNode *cur = prev->next;\\n            if (cur->next && cur->next->val == cur->val) {\\n                do {\\n                    ListNode* tmp = cur->next->next;\\n                    delete cur->next;\\n                    cur->next = tmp;\\n                } while (cur->next && cur->next->val == cur->val);\\n                prev->next = cur->next;\\n                delete cur;\\n            } else {\\n                prev = prev->next;\\n            }\\n        }\\n      \\n        return dummy.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28501,
                "title": "share-beat-100-python-code",
                "content": "    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        dummy = ListNode(0)\\n        pt = dummy\\n        repeated = 0\\n        while head and head.next:\\n            if head.val != head.next.val:\\n                if not repeated:\\n                    pt.next = head\\n                    pt = pt.next\\n                repeated = 0\\n            else:\\n                repeated = 1\\n            head = head.next\\n            \\n        pt.next = None if repeated else head\\n        \\n        return dummy.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        dummy = ListNode(0)\\n        pt = dummy\\n        repeated = 0\\n        while head and head.next:\\n            if head.val != head.next.val:\\n                if not repeated:\\n                    pt.next = head\\n                    pt = pt.next\\n                repeated = 0\\n            else:\\n                repeated = 1\\n            head = head.next\\n            \\n        pt.next = None if repeated else head\\n        \\n        return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 4023606,
                "title": "java-beats-100-o-n-time-complexity-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\n**O(n)**\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        head = new ListNode(0, head);\\n        ListNode curr = head, prev = head;\\n\\n        while (curr != null && curr.next != null) {\\n            if (curr == head) {\\n                curr = curr.next;\\n                continue;\\n            }\\n            if (curr.val != curr.next.val) {\\n                prev = curr;\\n            }\\n            else {\\n                while (curr.next != null && curr.val == curr.next.val) {\\n                    curr = curr.next;\\n                }\\n                prev.next = curr.next;\\n            }\\n\\n            curr = curr.next;\\n        }\\n\\n        return head.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        head = new ListNode(0, head);\\n        ListNode curr = head, prev = head;\\n\\n        while (curr != null && curr.next != null) {\\n            if (curr == head) {\\n                curr = curr.next;\\n                continue;\\n            }\\n            if (curr.val != curr.next.val) {\\n                prev = curr;\\n            }\\n            else {\\n                while (curr.next != null && curr.val == curr.next.val) {\\n                    curr = curr.next;\\n                }\\n                prev.next = curr.next;\\n            }\\n\\n            curr = curr.next;\\n        }\\n\\n        return head.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005092,
                "title": "best-recursive-solution-for-java",
                "content": "# Intuition\\nDo recursion with the given function, only need to declare a global variable. \\n\\n# Approach\\nA duplicate node is when the adjacents are holding sama value. When head is a duplicate node then store head as duplicate and check the next node for if it\\'s duplicate or not. Otherwise set head next by deleting duplicates from the head next node.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ListNode duplicate;\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) {\\n            return head;\\n        } \\n        if (duplicate != null) {\\n            if (head.val == duplicate.val) {\\n                return deleteDuplicates(head.next);\\n            } else {\\n                duplicate = null;\\n                head = deleteDuplicates(head);\\n            }\\n        } else if (head.next != null && head.val == head.next.val) {\\n            duplicate = head;\\n            return deleteDuplicates(head.next.next);\\n        } else {\\n            duplicate = null;\\n            head.next = deleteDuplicates(head.next);\\n        }\\n        return head;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ListNode duplicate;\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) {\\n            return head;\\n        } \\n        if (duplicate != null) {\\n            if (head.val == duplicate.val) {\\n                return deleteDuplicates(head.next);\\n            } else {\\n                duplicate = null;\\n                head = deleteDuplicates(head);\\n            }\\n        } else if (head.next != null && head.val == head.next.val) {\\n            duplicate = head;\\n            return deleteDuplicates(head.next.next);\\n        } else {\\n            duplicate = null;\\n            head.next = deleteDuplicates(head.next);\\n        }\\n        return head;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998727,
                "title": "easy-solution-without-extra-space-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraversing through the linked list maintaining previous pointer and connecting latest found (appearently) non duplicate node as it\\'s next.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. It first checks if the list is empty (has no elements). If it\\'s empty, there\\'s nothing to do, so it returns an empty list.\\n\\n2. It creates a special node called \\'x\\' and connects it to the beginning of the list. This helps in handling cases where the first element of the list is a duplicate.\\n\\n3. It sets up two pointers, \\'head\\' and \\'prev,\\' to traverse the list. \\'Head\\' is used to move through the list, and \\'prev\\' keeps track of the previous node.\\n\\n4. The code then goes through the list one element at a time using a loop.\\n\\n5. Inside the loop, it checks if the current element has duplicates by comparing its value with the next element\\'s value. If duplicates are found, it marks them and moves the \\'head\\' pointer past all duplicates.\\n\\n6. If duplicates were marked, it makes the \\'prev\\' node skip these duplicates by updating its \\'next\\' pointer to point to the first non-duplicate element.\\n\\n7. If no duplicates were found, it updates \\'prev\\' to the current element.\\n\\n8. It then moves the \\'head\\' pointer to the next element and repeats the process until it reaches the end of the list.\\n\\n9. Finally, it returns the modified list, which starts from \\'x->next,\\' excluding the initial \\'x\\' node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\nTraversing through entire linked list for once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\nNot using any extra space.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n    // Check if the linked list is empty, if so, return NULL\\n    if (!head) return NULL;\\n\\n    // Create a new node \\'x\\' and set its next pointer to the head of the linked list\\n    ListNode* x = new ListNode(0);\\n    x->next = head;\\n\\n    // Create a \\'prev\\' pointer to keep track of the previous node while traversing\\n    ListNode* prev = x;\\n\\n    // Loop through the linked list\\n    while (head) {\\n        // Initialize a boolean \\'dup\\' to false to track duplicate nodes\\n        bool dup = false;\\n\\n        // Check for duplicates by comparing the current node\\'s value with the next node\\'s value\\n        while (head->next && head->next->val == head->val) {\\n            head = head->next;\\n            dup = true;\\n        }\\n\\n        // If duplicates were found, update the \\'prev\\' node\\'s next pointer to skip the duplicates\\n        if (dup) {\\n            prev->next = head->next;\\n        } else {\\n            // If no duplicates were found, simply update \\'prev\\' to the current node\\n            prev = head;\\n        }\\n\\n        // Move to the next node in the linked list\\n        head = head->next;\\n    }\\n\\n    // Return the modified linked list starting from \\'x->next\\'\\n    return x->next;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n    // Check if the linked list is empty, if so, return NULL\\n    if (!head) return NULL;\\n\\n    // Create a new node \\'x\\' and set its next pointer to the head of the linked list\\n    ListNode* x = new ListNode(0);\\n    x->next = head;\\n\\n    // Create a \\'prev\\' pointer to keep track of the previous node while traversing\\n    ListNode* prev = x;\\n\\n    // Loop through the linked list\\n    while (head) {\\n        // Initialize a boolean \\'dup\\' to false to track duplicate nodes\\n        bool dup = false;\\n\\n        // Check for duplicates by comparing the current node\\'s value with the next node\\'s value\\n        while (head->next && head->next->val == head->val) {\\n            head = head->next;\\n            dup = true;\\n        }\\n\\n        // If duplicates were found, update the \\'prev\\' node\\'s next pointer to skip the duplicates\\n        if (dup) {\\n            prev->next = head->next;\\n        } else {\\n            // If no duplicates were found, simply update \\'prev\\' to the current node\\n            prev = head;\\n        }\\n\\n        // Move to the next node in the linked list\\n        head = head->next;\\n    }\\n\\n    // Return the modified linked list starting from \\'x->next\\'\\n    return x->next;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974848,
                "title": "python-3-o-1-space-solution",
                "content": "##### UPVOTE IF YOU LIKE ;)\\n![SpidermanTobeyMaguireGIF.gif](https://assets.leetcode.com/users/images/b55a37a9-a9f5-4be8-a13e-455c0a0a2714_1693289534.1989064.gif)\\n\\n# Code\\n```py\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # Base Case\\n        if not head: return None\\n        \\n        # Dummy Node\\n        dummy = ListNode(0, head)\\n\\n        # dup\\'s initial value is a value that \\n        # a node cannot have in this problem\\n        prev, cur = dummy, head\\n        dup = -101\\n        while cur.next:\\n            # If a duplicate is found, save that value\\n            if cur.val == cur.next.val:\\n                dup = cur.val\\n            \\n            # If the current node\\'s value is dup\\n            # Remove the current node\\n            if cur.val == dup:\\n                prev.next = cur.next\\n\\n            # If not just update prev to its next node                \\n            else:\\n                prev = prev.next\\n\\n            cur = cur.next\\n\\n        # Check the last node\\n        if cur.val == dup:\\n            prev.next = None\\n        \\n        return dummy.next\\n            \\n```\\n\\n# Explanation\\nCheck my blog for detailed explanations: https://gaebalogaebal.tistory.com/category/%5BLeetCode%5D\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```py\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # Base Case\\n        if not head: return None\\n        \\n        # Dummy Node\\n        dummy = ListNode(0, head)\\n\\n        # dup\\'s initial value is a value that \\n        # a node cannot have in this problem\\n        prev, cur = dummy, head\\n        dup = -101\\n        while cur.next:\\n            # If a duplicate is found, save that value\\n            if cur.val == cur.next.val:\\n                dup = cur.val\\n            \\n            # If the current node\\'s value is dup\\n            # Remove the current node\\n            if cur.val == dup:\\n                prev.next = cur.next\\n\\n            # If not just update prev to its next node                \\n            else:\\n                prev = prev.next\\n\\n            cur = cur.next\\n\\n        # Check the last node\\n        if cur.val == dup:\\n            prev.next = None\\n        \\n        return dummy.next\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961110,
                "title": "simple-c-solution",
                "content": "# Using Extra Space - Map\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        map<int,int> mp;\\n        ListNode *temp=head;\\n        while(temp!=nullptr){\\n            mp[temp->val]++;\\n            temp=temp->next;\\n        }\\n        ListNode *res=new ListNode(0);\\n        temp=res;\\n        for(auto m:mp){\\n            if(m.second==1){\\n                temp->next=new ListNode(m.first);\\n                temp=temp->next;\\n            }\\n        }\\n        return res->next;\\n    }\\n};\\n```\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode *deleteDuplicates(ListNode *head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode *res=new ListNode(0);\\n        ListNode *current=head,*prevNode=res;\\n        while(current){\\n            bool isDuplicate=false;\\n            while(current->next && current->val==current->next->val){\\n                current=current->next;\\n                isDuplicate=true;\\n            }\\n            if(!isDuplicate){\\n                prevNode->next=current;\\n                prevNode=current;\\n            }\\n            current=current->next;\\n        }\\n        prevNode->next=nullptr;\\n        return res->next;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        map<int,int> mp;\\n        ListNode *temp=head;\\n        while(temp!=nullptr){\\n            mp[temp->val]++;\\n            temp=temp->next;\\n        }\\n        ListNode *res=new ListNode(0);\\n        temp=res;\\n        for(auto m:mp){\\n            if(m.second==1){\\n                temp->next=new ListNode(m.first);\\n                temp=temp->next;\\n            }\\n        }\\n        return res->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *deleteDuplicates(ListNode *head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode *res=new ListNode(0);\\n        ListNode *current=head,*prevNode=res;\\n        while(current){\\n            bool isDuplicate=false;\\n            while(current->next && current->val==current->next->val){\\n                current=current->next;\\n                isDuplicate=true;\\n            }\\n            if(!isDuplicate){\\n                prevNode->next=current;\\n                prevNode=current;\\n            }\\n            current=current->next;\\n        }\\n        prevNode->next=nullptr;\\n        return res->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941117,
                "title": "putta-easy-solution-c-beats-95",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL) return head;\\n        ListNode* newhead = new ListNode(0);\\n        ListNode* head2 =newhead ;\\n       ListNode* temp = head;\\n       while(temp) {\\n           int val = temp->val;\\n           ListNode* dummy = temp;\\n           temp = temp->next;\\n            int flag = 0;\\n           while(temp && val == temp->val){\\n               flag = 1;\\n               temp = temp->next;\\n            }\\n           if( flag == 0) {newhead->next = dummy;\\n           newhead = newhead->next;\\n           newhead->next = NULL;}\\n       }\\n       return head2->next;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL) return head;\\n        ListNode* newhead = new ListNode(0);\\n        ListNode* head2 =newhead ;\\n       ListNode* temp = head;\\n       while(temp) {\\n           int val = temp->val;\\n           ListNode* dummy = temp;\\n           temp = temp->next;\\n            int flag = 0;\\n           while(temp && val == temp->val){\\n               flag = 1;\\n               temp = temp->next;\\n            }\\n           if( flag == 0) {newhead->next = dummy;\\n           newhead = newhead->next;\\n           newhead->next = NULL;}\\n       }\\n       return head2->next;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890977,
                "title": "use-simple-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        dummy = ListNode(0)  \\n        dummy.next = head\\n        prev = dummy\\n        current = head\\n\\n        while current:\\n            next_node = current.next\\n\\n            while next_node and next_node.val == current.val:\\n                next_node = next_node.next\\n\\n            if current.next != next_node:\\n                prev.next = next_node\\n            else:\\n                prev = current\\n            \\n            current = next_node\\n\\n        return dummy.next\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        dummy = ListNode(0)  \\n        dummy.next = head\\n        prev = dummy\\n        current = head\\n\\n        while current:\\n            next_node = current.next\\n\\n            while next_node and next_node.val == current.val:\\n                next_node = next_node.next\\n\\n            if current.next != next_node:\\n                prev.next = next_node\\n            else:\\n                prev = current\\n            \\n            current = next_node\\n\\n        return dummy.next\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890476,
                "title": "simple-iterative-c-solution",
                "content": "# Intuition\\nCompare adjacent values in the linked list and move the pointer to the next until repeated values are present. \\n\\n# Approach\\nCreate a new header for creating the new list. Iterate through the given list and if current value and value of the next pointer is same, iterate till the value repeats. If the values are not same, create a new node with the same value as the node. If header is null i.e. has not been assigned yet, then set the header equal to the new node, else, set header -> next = new node and header = header -> next.\\n\\nAt the end, if last element is not repeated create a new node with same value as that of last node and set header -> next to the last node.\\nReturn the new header which will be the new list with duplicated values removed.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n        if(head == NULL) return head;\\n\\n        if(head -> next == NULL) return head;\\n        \\n        ListNode *h = NULL;\\n        ListNode *start = head;\\n\\n        ListNode *ans = NULL;\\n\\n        bool f = false;\\n        \\n        while(start -> next != NULL) {\\n            if(start -> val == start -> next -> val) {\\n                int v = start -> val;\\n                while(start -> next -> val == v) {\\n                    start = start -> next;\\n                    if(start -> next == NULL) break;\\n                }\\n\\n                if(start -> next == NULL) {\\n                    f = true;\\n                    break;\\n                }\\n            }\\n            else{\\n                if(h == NULL) {\\n                    ListNode *new_node = new ListNode(start -> val);\\n                    new_node -> next = NULL;\\n                    h = new_node;\\n                    ans = h;\\n                }\\n                else{\\n                    ListNode *node = new ListNode(start -> val);\\n                    node -> next = NULL;\\n                    h -> next = node;\\n                    h = h -> next;\\n                }\\n            }\\n            start = start -> next;\\n        }\\n\\n        if(!f) {\\n            if(h == NULL) {\\n                ans = start;\\n            }\\n            else{\\n                h -> next = start;\\n            }\\n        }\\n\\n        h = ans;\\n\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n        if(head == NULL) return head;\\n\\n        if(head -> next == NULL) return head;\\n        \\n        ListNode *h = NULL;\\n        ListNode *start = head;\\n\\n        ListNode *ans = NULL;\\n\\n        bool f = false;\\n        \\n        while(start -> next != NULL) {\\n            if(start -> val == start -> next -> val) {\\n                int v = start -> val;\\n                while(start -> next -> val == v) {\\n                    start = start -> next;\\n                    if(start -> next == NULL) break;\\n                }\\n\\n                if(start -> next == NULL) {\\n                    f = true;\\n                    break;\\n                }\\n            }\\n            else{\\n                if(h == NULL) {\\n                    ListNode *new_node = new ListNode(start -> val);\\n                    new_node -> next = NULL;\\n                    h = new_node;\\n                    ans = h;\\n                }\\n                else{\\n                    ListNode *node = new ListNode(start -> val);\\n                    node -> next = NULL;\\n                    h -> next = node;\\n                    h = h -> next;\\n                }\\n            }\\n            start = start -> next;\\n        }\\n\\n        if(!f) {\\n            if(h == NULL) {\\n                ans = start;\\n            }\\n            else{\\n                h -> next = start;\\n            }\\n        }\\n\\n        h = ans;\\n\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884851,
                "title": "c-o-n-3ms-100-beats-easy-solution-with-proper-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n        struct ListNode *dummy = malloc(sizeof(struct ListNode));\\n        dummy->next = head;\\n        dummy->val = 0;\\n        struct ListNode *prev = dummy , *curr = head;\\n\\n        while(curr)\\n        {\\n            struct ListNode *next_node = curr->next;\\n            while(next_node && curr->val == next_node->val)\\n            {\\n                struct ListNode *temp = next_node->next;\\n                // delete next_node;\\n                next_node = temp;\\n            }\\n\\n            if(curr->next != next_node)\\n            {\\n                prev->next = next_node;\\n                // delete curr;\\n            }\\n            else\\n            {\\n                prev = curr;\\n\\n            }\\n            curr = next_node;\\n        }\\n        return dummy->next;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n        struct ListNode *dummy = malloc(sizeof(struct ListNode));\\n        dummy->next = head;\\n        dummy->val = 0;\\n        struct ListNode *prev = dummy , *curr = head;\\n\\n        while(curr)\\n        {\\n            struct ListNode *next_node = curr->next;\\n            while(next_node && curr->val == next_node->val)\\n            {\\n                struct ListNode *temp = next_node->next;\\n                // delete next_node;\\n                next_node = temp;\\n            }\\n\\n            if(curr->next != next_node)\\n            {\\n                prev->next = next_node;\\n                // delete curr;\\n            }\\n            else\\n            {\\n                prev = curr;\\n\\n            }\\n            curr = next_node;\\n        }\\n        return dummy->next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3775202,
                "title": "easy-java-solution-beats-100-in-place-solution-clean-code-o-n-o-1",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        ListNode traverse = head;\\n        ListNode temp = new ListNode();\\n        ListNode ans = temp;\\n        int flag = 0;\\n\\n        while(traverse.next != null) {\\n            if(traverse.next.val != traverse.val) {\\n                if(flag == 1) {\\n                    traverse = traverse.next;\\n                }\\n                else {\\n                temp.next = traverse;\\n                temp = temp.next;\\n                traverse = traverse.next;\\n                }\\n                flag = 0;\\n            }\\n            else if(traverse.next.val == traverse.val) {\\n                flag = 1;\\n                traverse = traverse.next;\\n            }\\n        } \\n        if(flag == 1) {\\n            temp.next = null;\\n        }\\n        else {\\n        temp.next = traverse;\\n        }\\n        \\n        return ans.next;\\n    }\\n}\\n```\\n\\n![cat.jpeg](https://assets.leetcode.com/users/images/a3de047b-a131-4982-a2f2-0013d429d217_1689535320.8316107.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        ListNode traverse = head;\\n        ListNode temp = new ListNode();\\n        ListNode ans = temp;\\n        int flag = 0;\\n\\n        while(traverse.next != null) {\\n            if(traverse.next.val != traverse.val) {\\n                if(flag == 1) {\\n                    traverse = traverse.next;\\n                }\\n                else {\\n                temp.next = traverse;\\n                temp = temp.next;\\n                traverse = traverse.next;\\n                }\\n                flag = 0;\\n            }\\n            else if(traverse.next.val == traverse.val) {\\n                flag = 1;\\n                traverse = traverse.next;\\n            }\\n        } \\n        if(flag == 1) {\\n            temp.next = null;\\n        }\\n        else {\\n        temp.next = traverse;\\n        }\\n        \\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732971,
                "title": "java-easy-solution-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere i have used concept of hash map and basic concept of linkedlist\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n   if(head==null||head.next==null){ return head;}\\n   HashMap<Integer,Integer> map=new HashMap<>();\\n   ListNode node=new ListNode(-1);\\n   ListNode prev=node;\\n   ListNode curr=head;\\n   while(curr!=null){\\n       if(map.containsKey(curr.val)){\\n           map.put(curr.val,map.get(curr.val)+1);\\n       }else{\\n           map.put(curr.val,0);\\n       }\\n       curr=curr.next;\\n   }\\ncurr=head;\\nwhile(curr!=null){\\n    if(map.get(curr.val)==0){\\n        prev.next=curr;\\n        prev=curr;\\n    }\\ncurr=curr.next;}\\nif(prev.next!=null){\\n    prev.next=null;\\n\\n    }\\n    return node.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n   if(head==null||head.next==null){ return head;}\\n   HashMap<Integer,Integer> map=new HashMap<>();\\n   ListNode node=new ListNode(-1);\\n   ListNode prev=node;\\n   ListNode curr=head;\\n   while(curr!=null){\\n       if(map.containsKey(curr.val)){\\n           map.put(curr.val,map.get(curr.val)+1);\\n       }else{\\n           map.put(curr.val,0);\\n       }\\n       curr=curr.next;\\n   }\\ncurr=head;\\nwhile(curr!=null){\\n    if(map.get(curr.val)==0){\\n        prev.next=curr;\\n        prev=curr;\\n    }\\ncurr=curr.next;}\\nif(prev.next!=null){\\n    prev.next=null;\\n\\n    }\\n    return node.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714833,
                "title": "easy-constant-space-solution-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn Linked List write the basic Solution and then try to go for the edge cases , this was one of them , you have to handle the edge cases here.\\n1) what if duplicates were in head ,you gotta handle that\\n2) what if duplicates were the last values you gotta handle that\\n\\n\\nALWAYS TRY DRAWING DIAGRAM FIRST AND SIMLUATE IT \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = head,prev = null;\\n\\n        while(temp != null){\\n            ListNode k = temp.next;\\n            \\n            if(temp.next != null && temp.val == temp.next.val){\\n                while(k != null && temp.val == k.val) {\\n                    k = k.next;\\n                }\\n                if( prev == null && k == null) {\\n                    head = null;\\n                    break;\\n                }\\n                else if(prev == null){\\n                    head = k;\\n                    temp = head;\\n                    prev = null;\\n                }\\n                else if( k == null){\\n                    prev.next = null;\\n                    break;\\n                } else {\\n                    prev.next = k;\\n                    temp = prev;\\n                }\\n                continue;\\n            }\\n\\n            prev = temp;\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = head,prev = null;\\n\\n        while(temp != null){\\n            ListNode k = temp.next;\\n            \\n            if(temp.next != null && temp.val == temp.next.val){\\n                while(k != null && temp.val == k.val) {\\n                    k = k.next;\\n                }\\n                if( prev == null && k == null) {\\n                    head = null;\\n                    break;\\n                }\\n                else if(prev == null){\\n                    head = k;\\n                    temp = head;\\n                    prev = null;\\n                }\\n                else if( k == null){\\n                    prev.next = null;\\n                    break;\\n                } else {\\n                    prev.next = k;\\n                    temp = prev;\\n                }\\n                continue;\\n            }\\n\\n            prev = temp;\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633297,
                "title": "easy-solution-in-java",
                "content": "# Java Code\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)    return head;\\n        ListNode dummy = new ListNode(-1);\\n        ListNode prev = dummy;\\n        ListNode curr = head;\\n        while(curr!=null && curr.next!=null)\\n        {\\n            boolean flag = false;\\n            if(curr.val != curr.next.val)\\n            {\\n                prev.next = curr;\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n            else\\n            {\\n                int data = curr.val;\\n                while(curr.next!=null && curr.val == curr.next.val)\\n                {\\n                    curr.next = curr.next.next;\\n                }\\n                prev.next = curr.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n```\\n---\\n##### *Please upvote if you\\'ve liked my solution : ))*",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)    return head;\\n        ListNode dummy = new ListNode(-1);\\n        ListNode prev = dummy;\\n        ListNode curr = head;\\n        while(curr!=null && curr.next!=null)\\n        {\\n            boolean flag = false;\\n            if(curr.val != curr.next.val)\\n            {\\n                prev.next = curr;\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n            else\\n            {\\n                int data = curr.val;\\n                while(curr.next!=null && curr.val == curr.next.val)\\n                {\\n                    curr.next = curr.next.next;\\n                }\\n                prev.next = curr.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533733,
                "title": "easy-c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic ListNode DeleteDuplicates(ListNode head) {\\n        var dummyHead = new ListNode(0, head);\\n        var prev = dummyHead;\\n        \\n        while (prev != null)\\n        {\\n            // Found value that has duplicates\\n            if (prev.next != null && prev.next.next != null && prev.next.val == prev.next.next.val)\\n            {\\n                var duplicateValue = prev.next.val;\\n                while (prev.next != null && prev.next.val == duplicateValue) prev.next = prev.next.next;\\n            }\\n            else prev = prev.next;\\n        }\\n\\n        return dummyHead.next;\\n    }\\n```",
                "solutionTags": [
                    "C#",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\npublic ListNode DeleteDuplicates(ListNode head) {\\n        var dummyHead = new ListNode(0, head);\\n        var prev = dummyHead;\\n        \\n        while (prev != null)\\n        {\\n            // Found value that has duplicates\\n            if (prev.next != null && prev.next.next != null && prev.next.val == prev.next.next.val)\\n            {\\n                var duplicateValue = prev.next.val;\\n                while (prev.next != null && prev.next.val == duplicateValue) prev.next = prev.next.next;\\n            }\\n            else prev = prev.next;\\n        }\\n\\n        return dummyHead.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3509136,
                "title": "great-explanation-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n   /*\\n   # concept: \\n     @ to delete all duplicate number, we must need to know dup node\\'s previous node to connect with \\n         the next unique node\\n\\n         1)if head node contains dup, then need to make the next unique node to prev.\\n           1->1->2\\n          here, cur node will be 2nd 1, so we will make cur = cur->next and  head = cur;\\n\\n          1)if other node contains dup, then need to make the next unique node to prev.\\n           0->2->2->3\\n          here, cur node will be 2nd 2, so we will make  prev->next = cur->next  and  cur = cur->next;\\n\\n    @ if node don\\'t contains dup, then need to make the node to prev..\\n      prev = curr;\\n     curr = curr->next\\n\\n   */\\n    \\n    ListNode* curr = head;\\n    ListNode* prev = NULL;\\n    //this condition satisfy the condition if(head==NUll or head->next==NULL) return head\\n    //so we don\\'t mention this condition first\\n    while(curr != NULL && curr->next != NULL) {\\n        if(curr->val == curr->next->val) {\\n            //tricky part, as we are comparing two nodes, it must need to check that 2 nodes are avaible \\n            //to check that curr->next != NULL \\n            while(curr->next != NULL && curr->val == curr->next->val) {\\n                curr = curr->next;\\n            }\\n            if(prev != NULL) { //if head not don\\'t contain duplicate\\n                prev->next = curr->next;\\n                curr = curr->next;    \\n            }else { // if head node contain deplicate & no need to change prev\\n                curr = curr->next;  \\n                head = curr;\\n                 \\n            }\\n        }else { //if  all node are unique\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n    }\\n    return head;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n   /*\\n   # concept: \\n     @ to delete all duplicate number, we must need to know dup node\\'s previous node to connect with \\n         the next unique node\\n\\n         1)if head node contains dup, then need to make the next unique node to prev.\\n           1->1->2\\n          here, cur node will be 2nd 1, so we will make cur = cur->next and  head = cur;\\n\\n          1)if other node contains dup, then need to make the next unique node to prev.\\n           0->2->2->3\\n          here, cur node will be 2nd 2, so we will make  prev->next = cur->next  and  cur = cur->next;\\n\\n    @ if node don\\'t contains dup, then need to make the node to prev..\\n      prev = curr;\\n     curr = curr->next\\n\\n   */\\n    \\n    ListNode* curr = head;\\n    ListNode* prev = NULL;\\n    //this condition satisfy the condition if(head==NUll or head->next==NULL) return head\\n    //so we don\\'t mention this condition first\\n    while(curr != NULL && curr->next != NULL) {\\n        if(curr->val == curr->next->val) {\\n            //tricky part, as we are comparing two nodes, it must need to check that 2 nodes are avaible \\n            //to check that curr->next != NULL \\n            while(curr->next != NULL && curr->val == curr->next->val) {\\n                curr = curr->next;\\n            }\\n            if(prev != NULL) { //if head not don\\'t contain duplicate\\n                prev->next = curr->next;\\n                curr = curr->next;    \\n            }else { // if head node contain deplicate & no need to change prev\\n                curr = curr->next;  \\n                head = curr;\\n                 \\n            }\\n        }else { //if  all node are unique\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n    }\\n    return head;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462736,
                "title": "simple-c-solution-using-linked-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *t1=head,*t2;\\n        if(t1==NULL || t1->next==NULL)\\n        {\\n            return head;\\n        }\\n        while(t1!=NULL)\\n        {\\n            if(t1!=NULL && t1->next!=NULL && t1->val==t1->next->val)\\n           {\\n            int x1=t1->val;\\n            while(head!=NULL && head->val==x1)\\n            {\\n                head=head->next;\\n            }\\n            t1=head;\\n          }\\n            else if(t1->next!=NULL && t1->next->next!=NULL &&      t1->next->next->val==t1->next->val)\\n            {\\n                t2=t1->next;\\n                int x=t1->next->val;\\n                while(t2!=NULL && t2->val==x)\\n                {\\n                    t2=t2->next;\\n                }\\n                t1->next=t2;\\n            }\\n            else\\n            {\\n                t1=t1->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *t1=head,*t2;\\n        if(t1==NULL || t1->next==NULL)\\n        {\\n            return head;\\n        }\\n        while(t1!=NULL)\\n        {\\n            if(t1!=NULL && t1->next!=NULL && t1->val==t1->next->val)\\n           {\\n            int x1=t1->val;\\n            while(head!=NULL && head->val==x1)\\n            {\\n                head=head->next;\\n            }\\n            t1=head;\\n          }\\n            else if(t1->next!=NULL && t1->next->next!=NULL &&      t1->next->next->val==t1->next->val)\\n            {\\n                t2=t1->next;\\n                int x=t1->next->val;\\n                while(t2!=NULL && t2->val==x)\\n                {\\n                    t2=t2->next;\\n                }\\n                t1->next=t2;\\n            }\\n            else\\n            {\\n                t1=t1->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457663,
                "title": "82-remove-duplicates-from-sorted-list-ii-java",
                "content": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode help=new ListNode(); \\n        ListNode prev=help;\\n        help.next=head;\\n        while(head!=null)\\n        {\\n            if(head.next!=null&&head.val==head.next.val)\\n            {\\n                while(head.next!=null&&head.val==head.next.val)\\n                head=head.next;\\n                prev.next=head.next;\\n            }\\n            else\\n            prev=prev.next;\\n            head=head.next;\\n        }\\n        return help.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode help=new ListNode(); \\n        ListNode prev=help;\\n        help.next=head;\\n        while(head!=null)\\n        {\\n            if(head.next!=null&&head.val==head.next.val)\\n            {\\n                while(head.next!=null&&head.val==head.next.val)\\n                head=head.next;\\n                prev.next=head.next;\\n            }\\n            else\\n            prev=prev.next;\\n            head=head.next;\\n        }\\n        return help.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444232,
                "title": "easy-c-code-using-maps",
                "content": "\\n# Approach\\nFirstly use a map to calculate frequencies of each element.\\nCreate a new linked list and insert elements into linked list if the element frequency is equal to 1.\\nWe will obtain a new linked list with no duplicate elements in it. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        map<int,int>mp;\\n        ListNode *p=head;\\n        while(p){\\n            mp[p->val]++;\\n            p=p->next;\\n        }\\n        ListNode *ans=new ListNode();\\n        ListNode *ans1=ans;\\n        for(auto it:mp){\\n            if(it.second==1){\\n                ans1->next=new ListNode(it.first);\\n                ans1=ans1->next;\\n            }\\n        }\\n        return ans->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        map<int,int>mp;\\n        ListNode *p=head;\\n        while(p){\\n            mp[p->val]++;\\n            p=p->next;\\n        }\\n        ListNode *ans=new ListNode();\\n        ListNode *ans1=ans;\\n        for(auto it:mp){\\n            if(it.second==1){\\n                ans1->next=new ListNode(it.first);\\n                ans1=ans1->next;\\n            }\\n        }\\n        return ans->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1800490,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1566621,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1865337,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1997794,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1567737,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1946391,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1935798,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1848436,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1811576,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1793403,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1800490,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1566621,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1865337,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1997794,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1567737,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1946391,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1935798,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1848436,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1811576,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1793403,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            }
        ]
    },
    {
        "title": "Duplicate Emails",
        "question_content": "<p>Table: <code>Person</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| email       | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains an email. The emails will not contain uppercase letters.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report all the duplicate emails. Note that it&#39;s guaranteed that the email&nbsp;field is not NULL.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nPerson table:\n+----+---------+\n| id | email   |\n+----+---------+\n| 1  | a@b.com |\n| 2  | c@d.com |\n| 3  | a@b.com |\n+----+---------+\n<strong>Output:</strong> \n+---------+\n| Email   |\n+---------+\n| a@b.com |\n+---------+\n<strong>Explanation:</strong> a@b.com is repeated two times.\n</pre>\n",
        "solutions": [
            {
                "id": 53528,
                "title": "i-have-this-simple-approach-anybody-has-some-other-way",
                "content": "select Email \\nfrom Person \\ngroup by Email \\nhaving count(*) > 1",
                "solutionTags": [],
                "code": "select Email \\nfrom Person \\ngroup by Email \\nhaving count(*) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 2385937,
                "title": "3-different-solutions-easy-to-understand",
                "content": "```\\n# Please upvote, if you like my solution\\n# 1\\nSELECT email from Person\\ngroup by email\\nhaving count(email) > 1;\\n\\n# 2.\\nSELECT DISTINCT(p1.email) from Person p1, Person p2\\nwhere p1.id <> p2.id AND p1.email = p2.email;\\n\\n#3. \\nSELECT DISTINCT(p1.email) from \\nPerson p1 JOIN Person p2 ON\\np1.email = p2.email AND p1.id <> p2.id;\\n# feel free to ask anything, if have any doubts\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Please upvote, if you like my solution\\n# 1\\nSELECT email from Person\\ngroup by email\\nhaving count(email) > 1;\\n\\n# 2.\\nSELECT DISTINCT(p1.email) from Person p1, Person p2\\nwhere p1.id <> p2.id AND p1.email = p2.email;\\n\\n#3. \\nSELECT DISTINCT(p1.email) from \\nPerson p1 JOIN Person p2 ON\\np1.email = p2.email AND p1.id <> p2.id;\\n# feel free to ask anything, if have any doubts\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3827277,
                "title": "100-easy-fast-clean-solution",
                "content": "# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT DISTINCT P1.Email FROM Person P1,Person P2 \\n\\nWHERE P1.id <> P2.id AND P1.Email=P2.Email\\n```\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/50510b0c-779b-4cac-99da-f40f9ee9f70e_1690526377.4372673.jpeg)\\n",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT DISTINCT P1.Email FROM Person P1,Person P2 \\n\\nWHERE P1.id <> P2.id AND P1.Email=P2.Email\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53553,
                "title": "my-simple-accepted-solution",
                "content": "    select Email\\n    from Person\\n    group by Email\\n    having count(*)>1;",
                "solutionTags": [],
                "code": "    select Email\\n    from Person\\n    group by Email\\n    having count(*)>1;",
                "codeTag": "Unknown"
            },
            {
                "id": 53531,
                "title": "a-solution-using-a-group-by-and-another-one-using-a-self-join",
                "content": "914 ms\\n\\n    SELECT Email from Person\\n    Group By Email\\n    Having Count(*) > 1;\\n\\n933 ms\\n\\n    SELECT distinct p1.Email from Person p1\\n    INNER JOIN Person p2\\n    ON p1.Email = p2.Email\\n    WHERE p1.Id <> p2.Id;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "914 ms\\n\\n    SELECT Email from Person\\n    Group By Email\\n    Having Count(*) > 1;\\n\\n933 ms\\n\\n    SELECT distinct p1.Email from Person p1\\n    INNER JOIN Person p2\\n    ON p1.Email = p2.Email\\n    WHERE p1.Id <> p2.Id;",
                "codeTag": "Unknown"
            },
            {
                "id": 1538675,
                "title": "simple-accepted-solution",
                "content": "```\\nSELECT email as Email\\nFROM Person \\nGROUP BY email\\nHAVING COUNT(*) > 1\\n```\\n\\n**Like it ? lease upvote !**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email as Email\\nFROM Person \\nGROUP BY email\\nHAVING COUNT(*) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53557,
                "title": "share-my-solution",
                "content": "    Select Email\\n    From Person\\n    GROUP BY Email\\n    Having count(Email)>1",
                "solutionTags": [],
                "code": "    Select Email\\n    From Person\\n    GROUP BY Email\\n    Having count(Email)>1",
                "codeTag": "Unknown"
            },
            {
                "id": 53548,
                "title": "simple-solution-use-group-by",
                "content": "    select Email from Person group by Email having count(Email) > 1;",
                "solutionTags": [],
                "code": "    select Email from Person group by Email having count(Email) > 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 3214788,
                "title": "182-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nTo solve this problem, we need to group the records by email and select only those that have more than one occurrence. We can use the GROUP BY clause and HAVING clause to do this. Here\\'s the SQL query:\\n\\n```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(*) > 1;\\n\\n```\\nThis will select all the duplicate emails from the Person table. The GROUP BY clause groups the records by email, and the HAVING clause selects only those groups that have more than one record, which means that the email is duplicated.",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(*) > 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3027577,
                "title": "mysql-one-line-soln",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL)>1;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2849247,
                "title": "easiest-solution-mysql-simple-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct x.email from Person x,Person y where x.email=y.email and x.id>y.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct x.email from Person x,Person y where x.email=y.email and x.id>y.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2478870,
                "title": "mysql-3-solutions-faster-than-99-71-having-join",
                "content": "\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F Hello, here are my solutions to the problem.\\nPlease upvote to motivate me post future solutions. HAPPY CODING \\u2764\\uFE0F\\nAny suggestions and improvements are always welcome.\\nSolution 1: Join, long, not good \\uD83E\\uDD26\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F\\n\\u2705 Runtime: 396 ms, faster than 61.66% of MySQL.\\n```\\nselect distinct a.email Email\\nfrom Person as a \\njoin Person as b \\non a.email = b.email and a.id != b.id\\n```\\nSolution 2: Where clause, long, not good \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F\\n\\u2705 Runtime: 588 ms, faster than 32.98% of MySQL.\\n\\n```\\nselect distinct a.email Email \\nfrom Person a, Person b\\nwhere a.email = b.email \\nand a.id <> b.id\\n```\\nSolution 3: Group by and having clause \\uD83C\\uDFAF\\n\\u2705 Runtime: 274 ms, faster than 99.71% of MySQL.\\n\\n```\\nselect email Email\\nfrom Person \\ngroup by email \\nhaving count(*) > 1\\n```\\nIf you like the solutions, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct a.email Email\\nfrom Person as a \\njoin Person as b \\non a.email = b.email and a.id != b.id\\n```\n```\\nselect distinct a.email Email \\nfrom Person a, Person b\\nwhere a.email = b.email \\nand a.id <> b.id\\n```\n```\\nselect email Email\\nfrom Person \\ngroup by email \\nhaving count(*) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3942961,
                "title": "easy-beginner-solution-using-loc-and-duplicated",
                "content": "# Intuition\\nWe want select all values that are duplicated in our email column and return those as a dataframe, ensuring that we only report each email value once. \\n\\n# Approach\\nThis is a straightforward problem using .loc(), .duplicated(), and .drop_cuplicates().\\n\\n1. We create a new dataFrame called results\\n2. We use .loc to find all elements of the person dataframe whos emails are duplicated using the .duplicated() method. This will populate our results dataframe with each duplicated email. \\n3. We then use drop_duplicates to remove any duplicated values from our results dataFrame since some entries may be duplicated more than once. \\n\\nPlease upvote and happy coding :) \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n\\n    results = pd.DataFrame()\\n\\n    results = person.loc[person.duplicated(subset=[\\'email\\']), [\\'email\\']]\\n    \\n    return results.drop_duplicates()\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n\\n    results = pd.DataFrame()\\n\\n    results = person.loc[person.duplicated(subset=[\\'email\\']), [\\'email\\']]\\n    \\n    return results.drop_duplicates()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 53546,
                "title": "simple-solution-not-bad",
                "content": "    select distinct(p.Email) \\n    from Person p, Person p1\\n    where (p.Id <> p1.Id and p.Email = p1.Email);",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "    select distinct(p.Email) \\n    from Person p, Person p1\\n    where (p.Id <> p1.Id and p.Email = p1.Email);",
                "codeTag": "Unknown"
            },
            {
                "id": 2996406,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect email from Person\\ngroup by email having count(email) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email from Person\\ngroup by email having count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1967813,
                "title": "mysql-solution",
                "content": "# Solution\\n```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(*) > 1\\n```\\nThe **HAVING** clause was added to SQL because the **WHERE** keyword cannot be used with aggregate functions.\\nIf you find this **solution** and **explanation** helpful, please **upvote** it for others people.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(*) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2582141,
                "title": "very-easy-mysql-solution-20",
                "content": "```\\nselect email from person group by email having count(id) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect email from person group by email having count(id) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1885738,
                "title": "simple-and-elegant-multiple-solutions",
                "content": "**JOIN (Slow)**:\\n```\\nSELECT DISTINCT P1.Email\\nFROM Person P1\\nJOIN Person P2 ON P1.Email = P2.Email\\nWHERE P1.Id <> P2.Id\\n```\\n\\n**Sub-query**:\\n```\\nSELECT EMAIL FROM\\n    (SELECT Email, COUNT(Email) AS EmailCount\\n     FROM Person GROUP BY Email) Q\\nWHERE EmailCount >= 2\\n```\\n\\n**HAVING**:\\n```\\nSELECT Email FROM Person\\nGROUP BY Email\\nHAVING COUNT(Email) >= 2\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\nSELECT DISTINCT P1.Email\\nFROM Person P1\\nJOIN Person P2 ON P1.Email = P2.Email\\nWHERE P1.Id <> P2.Id\\n```\n```\\nSELECT EMAIL FROM\\n    (SELECT Email, COUNT(Email) AS EmailCount\\n     FROM Person GROUP BY Email) Q\\nWHERE EmailCount >= 2\\n```\n```\\nSELECT Email FROM Person\\nGROUP BY Email\\nHAVING COUNT(Email) >= 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 802338,
                "title": "sql-easy-peasy",
                "content": "```\\nSELECT Email\\nFROM Person\\nGROUP BY Email\\nHAVING count(*)>=2\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Email\\nFROM Person\\nGROUP BY Email\\nHAVING count(*)>=2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3274978,
                "title": "easy-to-understand-sql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3271110,
                "title": "mysql-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2533631,
                "title": "oracle-plsql-3-different-solution",
                "content": "**Using Subquery**\\n```\\nSELECT EMAIL FROM \\n(SELECT EMAIL,COUNT(EMAIL) AS C FROM PERSON GROUP BY EMAIL ) TEMP \\nWHERE TEMP.C>1;\\n```\\n**Using Having Keyword**\\n*Note - Just as the **WHERE** clause can be used to select and reject the individual rows that participate in a query, the **HAVING** clause can be used to select and reject row groups.*\\n```\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL)>1;\\n```\\n**Using Self Join**\\n```\\nSELECT DISTINCT P1.EMAIL FROM PERSON P1 JOIN PERSON P2 ON P1.EMAIL = P2.EMAIL AND P1.ID <> P2.ID;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT EMAIL FROM \\n(SELECT EMAIL,COUNT(EMAIL) AS C FROM PERSON GROUP BY EMAIL ) TEMP \\nWHERE TEMP.C>1;\\n```\n```\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL)>1;\\n```\n```\\nSELECT DISTINCT P1.EMAIL FROM PERSON P1 JOIN PERSON P2 ON P1.EMAIL = P2.EMAIL AND P1.ID <> P2.ID;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2451415,
                "title": "having-and-count-simple",
                "content": "`select email from Person group By email having count(email)>1 `",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "`select email from Person group By email having count(email)>1 `",
                "codeTag": "Unknown"
            },
            {
                "id": 2421000,
                "title": "mysql-2-different-approach-one-line-solution-beginner-level-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**.*\\n______________________\\n\\u2705 **MySQL Code :**\\n***Approach 1:***\\n```\\nSELECT email FROM Person GROUP BY email HAVING count(email) > 1\\n```\\n__________________________________\\n***Approach 2***:\\n\\n```\\nSELECT Email FROM Person GROUP BY Email HAVING  COUNT(*)>1\\n```\\n______________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email FROM Person GROUP BY email HAVING count(email) > 1\\n```\n```\\nSELECT Email FROM Person GROUP BY Email HAVING  COUNT(*)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803853,
                "title": "best-easiest-mysql-2-approaches-182-duplicate-emails",
                "content": "```\\n#below are 2 mysql solutions for this question\\n\\n#First solution\\nselect email from Person \\ngroup by email\\nhaving count(email)>1;\\n\\n\\n#second solution\\nselect email from\\n(select email, count(email) as c from Person group by email) as temp\\nwhere c>1\\n\\n\\n#pls upvote if you find solution easy ...Thanks..!!\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n#below are 2 mysql solutions for this question\\n\\n#First solution\\nselect email from Person \\ngroup by email\\nhaving count(email)>1;\\n\\n\\n#second solution\\nselect email from\\n(select email, count(email) as c from Person group by email) as temp\\nwhere c>1\\n\\n\\n#pls upvote if you find solution easy ...Thanks..!!\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1765981,
                "title": "mysql-forever-group-by",
                "content": "```\\nSELECT Email FROM Person group by Email having count(Email) > 1;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Email FROM Person group by Email having count(Email) > 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1757753,
                "title": "simple-2-lines-with-explanation-you-ll-love-it-guaranteed",
                "content": "If you\\'ve Learned something new please give it upvote;\\notherwise thank you for having a look \\uD83D\\uDE4F\\uD83C\\uDFFB\\n\\nHere my appraoch is using SELF JOINS. if you don\\'t have an idea what it is you can check out my answer https://leetcode.com/problems/employees-earning-more-than-their-managers/discuss/1757621/Simple-3-Lines-with-explanation.-(-You\\'ll-love-it-guaranteed.)\\nYou\\'ll get the basic idea what is SELF JOIN.\\n\\nchecking whether the same table has same emails with different ids.\\nif there are, then using DISTINCT keyword to only show unique emails to show on screen. \\n(we don\\'t want to show all them if there are thousand duplicate emails. we want only one)\\n\\n```\\nSELECT DISTINCT p1.email AS Email FROM Person p1\\nJOIN Person p2 ON p1.id != p2.id AND p1.email = p2.email\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT p1.email AS Email FROM Person p1\\nJOIN Person p2 ON p1.id != p2.id AND p1.email = p2.email\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1527877,
                "title": "easy-self-join-only",
                "content": "```\\nselect distinct a.Email from Person as a, Person as b where a.Email=b.Email and a.Id<>b.Id",
                "solutionTags": [],
                "code": "```\\nselect distinct a.Email from Person as a, Person as b where a.Email=b.Email and a.Id<>b.Id",
                "codeTag": "Unknown"
            },
            {
                "id": 53550,
                "title": "standard-solution-with-distinct",
                "content": "    SELECT DISTINCT Person.Email \\n    FROM Person \\n    GROUP BY Person.Email\\n    HAVING COUNT(Person.Email) > 1",
                "solutionTags": [],
                "code": "    SELECT DISTINCT Person.Email \\n    FROM Person \\n    GROUP BY Person.Email\\n    HAVING COUNT(Person.Email) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 53551,
                "title": "a-simple-straightforward-solution",
                "content": "    select Email from Person group by Email having count(Id) > 1",
                "solutionTags": [],
                "code": "    select Email from Person group by Email having count(Id) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 53560,
                "title": "my-first-accepted-sql-solution-using-group-by-in-845-ms-thank-god",
                "content": "    # Write your MySQL query statement below\\n    select email \\n    from( \\n         select \\n               email, \\n               count(*) as c\\n         from Person\\n         group by email\\n    ) a\\n    where a.c > 1;\\nWe should review and think over other guys' solution frequently, especially for beginners. I think it's significantly helpful~~",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "    # Write your MySQL query statement below\\n    select email \\n    from( \\n         select \\n               email, \\n               count(*) as c\\n         from Person\\n         group by email\\n    ) a\\n    where a.c > 1;\\nWe should review and think over other guys' solution frequently, especially for beginners. I think it's significantly helpful~~",
                "codeTag": "Unknown"
            },
            {
                "id": 3939489,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT email from Person\\ngroup by email\\nhaving count(email) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email from Person\\ngroup by email\\nhaving count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3525493,
                "title": "mysql-solution-for-duplicate-emails-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe query aims to identify email addresses that are duplicated in the Person table and retrieve those addresses along with their counts.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The query uses the group by clause to group the records in the Person table based on the Email column.\\n2. The having clause is used to filter the groups and include only those groups where the count of email addresses (count(Email)) is greater than 1.\\n3. The select statement select Email retrieves the email addresses from the qualifying groups.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the SQL query depends on the size of the Person table and the efficiency of the database engine\\'s query optimization and execution. Assuming proper indexing and optimization, the time complexity can vary but is typically in the order of O(n log n) or O(n), where n is the number of rows in the Person table.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the SQL query is determined by the memory required to store the result set, which in this case is the email addresses that appear more than once. The space complexity is proportional to the number of rows returned by the query.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect Email from Person group by Email having count(Email) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect Email from Person group by Email having count(Email) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3458408,
                "title": "3-line-code-beats-80",
                "content": "# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect email from person\\ngroup by email\\nhaving count(email)>1\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect email from person\\ngroup by email\\nhaving count(email)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3329405,
                "title": "very-simple-solution-using-having-clause",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect  email from person\\ngroup by email \\nhaving count(*) >1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect  email from person\\ngroup by email \\nhaving count(*) >1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3218260,
                "title": "mysql-easy-approach",
                "content": "Here is my MYSQL code for this problem.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect email as Email from Person group by email having count(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email as Email from Person group by email having count(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2877331,
                "title": "mysql-simple-having-clause",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING count(email) > 1; \\n```\\n\\n### HAVING count(email) > 1 \\nMainly use the last line to filter out those records which appear more than one in the database.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING count(email) > 1; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2652011,
                "title": "mysql-solution-memory-usage-0b",
                "content": "```\\nSELECT EMAIL FROM Person GROUP BY EMAIL HAVING COUNT(*)>1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT EMAIL FROM Person GROUP BY EMAIL HAVING COUNT(*)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2406578,
                "title": "mysql-using-count",
                "content": "SELECT Email FROM Person \\nGROUP by Email HAVING count(*)>1",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "SELECT Email FROM Person \\nGROUP by Email HAVING count(*)>1",
                "codeTag": "Unknown"
            },
            {
                "id": 2291486,
                "title": "mysql-simple-mysql-solution-using-count-having-clause",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 322 ms, faster than 84.35% of MySQL online submissions for Duplicate Emails.\\n# Memory Usage: 0B, less than 100.00% of MySQL online submissions for Duplicate Emails.\\n\\n\\tSELECT EMAIL FROM PERSON\\n\\tGROUP BY EMAIL\\n\\tHAVING COUNT(EMAIL) > 1\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 322 ms, faster than 84.35% of MySQL online submissions for Duplicate Emails.\\n# Memory Usage: 0B, less than 100.00% of MySQL online submissions for Duplicate Emails.\\n\\n\\tSELECT EMAIL FROM PERSON\\n\\tGROUP BY EMAIL\\n\\tHAVING COUNT(EMAIL) > 1\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2226726,
                "title": "a-trick-to-solve-duplicate-values-in-sql-using-aggregate-function-and-group-by-mysql-solution",
                "content": "We have to display the duplicate values of email which means display all the mail whose occurence is greater than 1.\\n\\nNow for occurence  we use an aggregate function called as : **count()**\\n\\nA trick to solve Duplicate values in SQL:\\n\\n1.) Using the GROUP BY clause to group all rows by the target column(s) \\u2013 i.e. the column(s) you want to check for duplicate values on.<br>\\n2.) Using the COUNT function in the HAVING clause to check if any of the groups have more than 1 entry; those would be the duplicate values.<br>\\n\\n**MySQL Solution :**\\n```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING count(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING count(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2030358,
                "title": "simple-solution",
                "content": "SELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT (email) >= 2;\\n#please upvote :)",
                "solutionTags": [],
                "code": "SELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT (email) >= 2;\\n#please upvote :)",
                "codeTag": "Unknown"
            },
            {
                "id": 1728735,
                "title": "sql-easy-4-line-group-by-duplicate-emails",
                "content": "```\\nSELECT email \\nFROM person\\nGROUP BY email \\nHAVING count(email) > 1;\\n```\\nPlease **UpVote**, if you understood the problem.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email \\nFROM person\\nGROUP BY email \\nHAVING count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1581930,
                "title": "simple-mysql",
                "content": "select email from person\\ngroup by email\\nhaving count(email) > 1",
                "solutionTags": [],
                "code": "select email from person\\ngroup by email\\nhaving count(email) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 1562445,
                "title": "simple-mysql-solution-faster-than-85",
                "content": "```sql\\nSELECT \\n    email\\nFROM\\n    Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```\\n\\nGuess it\\'s pretty straight forward w/o needing explanation. Keep your good work up.",
                "solutionTags": [],
                "code": "```sql\\nSELECT \\n    email\\nFROM\\n    Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1178366,
                "title": "simple-solution-easy-understand",
                "content": "SELECT Email\\nFROM Person\\nGROUP BY Email\\nHAVING COUNT(Email)>1",
                "solutionTags": [],
                "code": "SELECT Email\\nFROM Person\\nGROUP BY Email\\nHAVING COUNT(Email)>1",
                "codeTag": "Unknown"
            },
            {
                "id": 1134229,
                "title": "mysql-2-solutions-easy-to-understand",
                "content": "```\\n#Using Sub Query\\nselect email from Person group by Email having count(Email)>=2;\\n\\n#Using Self Join\\nselect distinct P1.Email from Person as P1, Person as P2 where P1.Email=P2.Email and P1.Id<>P2.Id;\\n```",
                "solutionTags": [],
                "code": "```\\n#Using Sub Query\\nselect email from Person group by Email having count(Email)>=2;\\n\\n#Using Self Join\\nselect distinct P1.Email from Person as P1, Person as P2 where P1.Email=P2.Email and P1.Id<>P2.Id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 876543,
                "title": "by-group-by-and-having-clause",
                "content": "SELECT Email\\nFROM Person\\nGROUP BY Email \\nHAVING count(Email)>1;",
                "solutionTags": [],
                "code": "SELECT Email\\nFROM Person\\nGROUP BY Email \\nHAVING count(Email)>1;",
                "codeTag": "Unknown"
            },
            {
                "id": 170685,
                "title": "group-by-having-most-efficient-solution",
                "content": "```\\nSELECT email \\nFROM   person \\nGROUP  BY email \\nHAVING Count(email) > 1 \\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email \\nFROM   person \\nGROUP  BY email \\nHAVING Count(email) > 1 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53555,
                "title": "my-solution",
                "content": "    SELECT Email FROM Person\\n    GROUP BY Email\\n    HAVING COUNT(Email) > 1",
                "solutionTags": [],
                "code": "    SELECT Email FROM Person\\n    GROUP BY Email\\n    HAVING COUNT(Email) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 4055225,
                "title": "pandas-easy-duplicate-emails",
                "content": "First Approach:\\n[See the Accepted and Successful Submission Detail](https://leetcode.com/submissions/detail/1051666715/)\\n\\n```\\ndef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # Let\\'s first, self-join to find distinct duplicated emails\\n    merged_emails_inner = person.merge(person, on=\\'email\\', how=\\'inner\\')\\n\\n    # In the next step, rows where the IDs are not equal are filtered out\\n    filtered_equal_id = merged_emails_inner[merged_emails_inner[\\'id_x\\'] != merged_emails_inner[\\'id_y\\']]\\n\\n    # Then select distinct email addresses\\n    unique_id = filtered_equal_id[\\'email\\'].unique()\\n\\n    # Finally, we can create a new DataFrame with the distinct email addresses\\n    result_df = pd.DataFrame({\\'email\\': unique_id})\\n\\n    return result_df\\n```\\n\\t\\nSecond Approach:\\n[See the Accepted and Successful Submission Detail](https://leetcode.com/submissions/detail/1051679673/)\\n```\\n\\n\\tdef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n\\n\\t\\t# 1) First, we group by \\'email\\' and filtering using the `HAVING` clause\\n\\t\\tgrouped_emails = person.groupby(\\'email\\')\\n\\n\\t\\t# 2) Then, we can filter the groups based on the condition that the count of each group (i.e., the number of occurrences of each unique email) should be greater than 1.\\n\\t\\tfiltered_emails = grouped_emails.filter(lambda group: len(group) > 1)\\n\\n\\t\\t# 3) in the next step, the unique email addresses from the filtered Series are extracted\\n\\t\\tunique_emails = filtered_emails[\\'email\\'].unique()\\n\\n\\t\\t# 4) Then, we create a DataFrame with the unique email addresses\\n\\t\\tresult_df = pd.DataFrame({\\'email\\': unique_emails})\\n\\n\\t\\treturn result_df\\n```\\n\\nThird Appraoch\\n[See the Accepted and Successful Submission Detail](https://leetcode.com/submissions/detail/1051685938/)\\n\\n```\\n\\tdef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n\\n\\t\\t# First, we group by \\'email\\' and counting occurrences\\n\\t\\temail_counts = person.groupby(\\'email\\').size()\\n\\n\\t\\t# Next, only emails with counts greater than 1 are filtered\\n\\t\\tresult_df = pd.DataFrame({\\'Email\\': email_counts[email_counts > 1].index})\\n\\n\\t\\treturn result_df\\n```\\n\\n**SQL**\\n[See the Accepted and Successful Submission Detail](https://leetcode.com/submissions/detail/1061389573/)\\n\\n```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```\\n\\n```\\n-- Select the \\'email\\' column from the \\'Person\\' table\\n-- This query is focused on retrieving email addresses.\\n\\nSELECT email\\n\\n-- Specify the source table for the query as \\'Person\\'\\n-- The data is being retrieved from the \\'Person\\' table.\\n\\nFROM Person\\n\\n-- Use the GROUP BY clause to group the data based on the \\'email\\' column\\n-- This groups rows with the same email address together.\\n\\nGROUP BY email\\n\\n-- The HAVING clause filters the grouped results.\\n-- It selects groups (email addresses) where the count of occurrences is greater than 1.\\n-- This identifies email addresses that appear more than once in the \\'Person\\' table.\\n\\nHAVING COUNT(email) > 1;\\n```\\n\\n![image](https://assets.leetcode.com/users/images/de333cff-f88a-4d35-a3a5-e0b8d0cc2c19_1695221934.7114468.jpeg)\\n",
                "solutionTags": [
                    "Merge Sort"
                ],
                "code": "```\\ndef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # Let\\'s first, self-join to find distinct duplicated emails\\n    merged_emails_inner = person.merge(person, on=\\'email\\', how=\\'inner\\')\\n\\n    # In the next step, rows where the IDs are not equal are filtered out\\n    filtered_equal_id = merged_emails_inner[merged_emails_inner[\\'id_x\\'] != merged_emails_inner[\\'id_y\\']]\\n\\n    # Then select distinct email addresses\\n    unique_id = filtered_equal_id[\\'email\\'].unique()\\n\\n    # Finally, we can create a new DataFrame with the distinct email addresses\\n    result_df = pd.DataFrame({\\'email\\': unique_id})\\n\\n    return result_df\\n```\n```\\n\\n\\tdef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n\\n\\t\\t# 1) First, we group by \\'email\\' and filtering using the `HAVING` clause\\n\\t\\tgrouped_emails = person.groupby(\\'email\\')\\n\\n\\t\\t# 2) Then, we can filter the groups based on the condition that the count of each group (i.e., the number of occurrences of each unique email) should be greater than 1.\\n\\t\\tfiltered_emails = grouped_emails.filter(lambda group: len(group) > 1)\\n\\n\\t\\t# 3) in the next step, the unique email addresses from the filtered Series are extracted\\n\\t\\tunique_emails = filtered_emails[\\'email\\'].unique()\\n\\n\\t\\t# 4) Then, we create a DataFrame with the unique email addresses\\n\\t\\tresult_df = pd.DataFrame({\\'email\\': unique_emails})\\n\\n\\t\\treturn result_df\\n```\n```\\n\\tdef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n\\n\\t\\t# First, we group by \\'email\\' and counting occurrences\\n\\t\\temail_counts = person.groupby(\\'email\\').size()\\n\\n\\t\\t# Next, only emails with counts greater than 1 are filtered\\n\\t\\tresult_df = pd.DataFrame({\\'Email\\': email_counts[email_counts > 1].index})\\n\\n\\t\\treturn result_df\\n```\n```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```\n```\\n-- Select the \\'email\\' column from the \\'Person\\' table\\n-- This query is focused on retrieving email addresses.\\n\\nSELECT email\\n\\n-- Specify the source table for the query as \\'Person\\'\\n-- The data is being retrieved from the \\'Person\\' table.\\n\\nFROM Person\\n\\n-- Use the GROUP BY clause to group the data based on the \\'email\\' column\\n-- This groups rows with the same email address together.\\n\\nGROUP BY email\\n\\n-- The HAVING clause filters the grouped results.\\n-- It selects groups (email addresses) where the count of occurrences is greater than 1.\\n-- This identifies email addresses that appear more than once in the \\'Person\\' table.\\n\\nHAVING COUNT(email) > 1;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3934435,
                "title": "very-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT Email FROM PERSON GROUP BY EMAIL HAVING COUNT(*)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT Email FROM PERSON GROUP BY EMAIL HAVING COUNT(*)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3813525,
                "title": "an-easy-to-understand-solution-in-oracle",
                "content": "# Code\\n```\\nSELECT p2.email FROM Person p2 GROUP BY p2.email having count(*) > 1\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT p2.email FROM Person p2 GROUP BY p2.email having count(*) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3539763,
                "title": "fully-simple-for-beginners",
                "content": "\\n\\n# Code\\n```\\nSELECT \\nemail as Email \\nFROM PERSON \\nGROUP BY email HAVING count(email) > 1;  \\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT \\nemail as Email \\nFROM PERSON \\nGROUP BY email HAVING count(email) > 1;  \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3506209,
                "title": "using-group-by-having-and-count-to-identify-duplicate-values",
                "content": "# Intuition\\nMy first thought was to find all values that are not unique, but I wasn\\'t able to have that work. So then I looked into the GROUP BY and HAVING clause. \\n\\n# Approach\\nUsing the GROUP BY clause, I grouped all the email values and used the HAVING clause to identify emails that had a count greater than 1. This would mean there were duplicate values. \\n\\n# Code\\n```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING(COUNT(email)>1)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING(COUNT(email)>1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3501208,
                "title": "simplest-solution",
                "content": "# Intuition\\nThere is a fairly straightforward solution to this problem. To group the results by Email, we simply select the Email column from the Person table. Using the HAVING clause, we filter the groups to include only those with a count greater than one (i.e., those that appear more than once). Consequently, the Person table contains a list of emails that appear more than once.\\n\\nBecause this solution relies on SQL\\'s built-in GROUP BY and HAVING functions, which are optimized for this type of operation, it is efficient. It is not necessary to write any custom functions or loops to iterate over the table data.\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nSELECT email as Email\\nFROM Person\\nGROUP BY email\\nHAVING count(*) > 1\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT email as Email\\nFROM Person\\nGROUP BY email\\nHAVING count(*) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3478941,
                "title": "nested-queries",
                "content": "\\n# Code\\n```\\nSELECT email AS Email FROM (SELECT COUNT(email) AS EmailCount, email FROM Person \\nGROUP BY email) AS Temp WHERE EmailCount > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email AS Email FROM (SELECT COUNT(email) AS EmailCount, email FROM Person \\nGROUP BY email) AS Temp WHERE EmailCount > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466076,
                "title": "3-best-approach-to-solve-mysql",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n1. select email from person group by email having count(email)>1 ;\\n\\n2. select distinct p1.email from person p1 ,person p2 where p1.id != p2.id and p1.email=p2.email;\\n\\n3. select distinct p1.email from person as p1 join person as p2 on p1.id != p2.id and p1.email=p2.email;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n1. select email from person group by email having count(email)>1 ;\\n\\n2. select distinct p1.email from person p1 ,person p2 where p1.id != p2.id and p1.email=p2.email;\\n\\n3. select distinct p1.email from person as p1 join person as p2 on p1.id != p2.id and p1.email=p2.email;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3409375,
                "title": "super-easy-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect Email from Person group by email having count(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Email from Person group by email having count(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3306922,
                "title": "sql-server-clean-easy",
                "content": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(*) > 1;\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(*) > 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3294457,
                "title": "mysql-easy-approach",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect email as Email from Person group by email having count(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email as Email from Person group by email having count(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3264077,
                "title": "group-by-and-having",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3121252,
                "title": "simple-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect email as Email from Person group by email having count(email)>1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email as Email from Person group by email having count(email)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3100725,
                "title": "simple-query-duplicate-emails",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect email from Person group by email having count(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email from Person group by email having count(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3100505,
                "title": "one-line-solution",
                "content": "\\n\\n# Code\\n```\\n\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2917417,
                "title": "duplicate-emails-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT Email FROM Person GROUP BY Email HAVING Count(Email) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT Email FROM Person GROUP BY Email HAVING Count(Email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2699614,
                "title": "mysql-group-by-count",
                "content": "# Write your MySQL query statement below\\n```\\nSELECT DISTINCT email AS Email  FROM Person\\nWHERE email IN\\n(SELECT CASE WHEN COUNT(id)>1 THEN email\\nEND\\nFROM Person\\nGROUP BY email);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT email AS Email  FROM Person\\nWHERE email IN\\n(SELECT CASE WHEN COUNT(id)>1 THEN email\\nEND\\nFROM Person\\nGROUP BY email);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646313,
                "title": "simple-and-easy-explained",
                "content": "Use**GROUP BY**clause to group all the rows by selecting the particular column (*email*);\\nnext use **COUNT()** in the **HAVING** clause to check if any *email* is repeated more than once.\\n\\n```\\nselect email as Email from Person group by email having count(email) > 1;\\n```\\n\\neasy, no? cheers",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect email as Email from Person group by email having count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2580520,
                "title": "using-distinct",
                "content": "**Upvote if you feel it easy :)**\\n```\\nSELECT DISTINCT p1.email\\nFROM Person p1 INNER JOIN person p2 ON p1.email = p2.email AND p1.id <> p2.id;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT DISTINCT p1.email\\nFROM Person p1 INNER JOIN person p2 ON p1.email = p2.email AND p1.id <> p2.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2539583,
                "title": "mysql-easy-solution",
                "content": "```\\nselect email from \\n    person \\n    group by email\\n    having count(id)>1\\n```",
                "solutionTags": [],
                "code": "```\\nselect email from \\n    person \\n    group by email\\n    having count(id)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2412013,
                "title": "mysql-easy",
                "content": "\\tselect email from Person group by email having count(*)>1",
                "solutionTags": [],
                "code": "\\tselect email from Person group by email having count(*)>1",
                "codeTag": "Unknown"
            },
            {
                "id": 2115544,
                "title": "one-line-solution-easy",
                "content": "**Duplicate Emails Solution :**\\n--------------------------------\\n**In MySQL**\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT email AS Email \\n    FROM Person \\n        GROUP BY 1 \\n            HAVING COUNT(1) > 1\\n```\\n\\n**In Oracle**\\n```\\n# Write your MySQL query statement below\\nSELECT email AS Email \\n    FROM Person \\n        GROUP BY email \\n            HAVING COUNT(email) > 1 \\n```\\n\\n**Happy Coding** \\uD83D\\uDE0A!!!\\nIf you get value from this, then show some love by ***upvoting*** it !!",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT email AS Email \\n    FROM Person \\n        GROUP BY 1 \\n            HAVING COUNT(1) > 1\\n```\n```\\n# Write your MySQL query statement below\\nSELECT email AS Email \\n    FROM Person \\n        GROUP BY email \\n            HAVING COUNT(email) > 1 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2021517,
                "title": "easy-to-understand-solution",
                "content": "```\\nselect distinct(u1.email) as Email\\nfrom Person u1,Person u2\\nwhere u1.email=u2.email and u1.id!=u2.id;\\n```\\n\\n**Please Upvote to keep me motivated  :)**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct(u1.email) as Email\\nfrom Person u1,Person u2\\nwhere u1.email=u2.email and u1.id!=u2.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786364,
                "title": "faster-than-94-47-of-the-submissions",
                "content": "\\n```\\nSELECT email FROM Person GROUP BY email HAVING count(email) > 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email FROM Person GROUP BY email HAVING count(email) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1744478,
                "title": "simple-solution-for-182-duplicate-emails-using-having-and-group-by",
                "content": "```\\nselect email as Email \\nfrom person\\ngroup by email\\nhaving count(email)>1\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect email as Email \\nfrom person\\ngroup by email\\nhaving count(email)>1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1597376,
                "title": "mysql-with-explaination",
                "content": "```\\nselect email from person\\ngroup by email\\nhaving count(email) > 1;\\n```\\n\\nHere we have use group by clause which will group all the repeating and non-repeating emails disticnctly and then applying having clause in combination with aggregate function count.",
                "solutionTags": [],
                "code": "```\\nselect email from person\\ngroup by email\\nhaving count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513698,
                "title": "ms-sql",
                "content": "#### Question\\n```\\n182. Duplicate Emails\\n\\nSQL Schema\\nTable: Person\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| Id          | int     |\\n| Email       | varchar |\\n+-------------+---------+\\nId is the primary key column for this table.\\nEach row of this table contains an email. The emails will not contain uppercase letters.\\n \\n\\nWrite an SQL query to report all the duplicate emails.\\n\\nReturn the result table in any order.\\n\\nThe query result format is in the following example.\\n\\n \\n\\nExample 1:\\n\\nInput: \\nPerson table:\\n+----+---------+\\n| Id | Email   |\\n+----+---------+\\n| 1  | a@b.com |\\n| 2  | c@d.com |\\n| 3  | a@b.com |\\n+----+---------+\\nOutput: \\n+---------+\\n| Email   |\\n+---------+\\n| a@b.com |\\n+---------+\\nExplanation: a@b.com is repeated two times.\\n```\\n\\n#### Answer\\n```SQL\\n/* Write your T-SQL query statement below */\\nselect email from person\\ngroup by email\\nhaving count(*) > 1",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n182. Duplicate Emails\\n\\nSQL Schema\\nTable: Person\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| Id          | int     |\\n| Email       | varchar |\\n+-------------+---------+\\nId is the primary key column for this table.\\nEach row of this table contains an email. The emails will not contain uppercase letters.\\n \\n\\nWrite an SQL query to report all the duplicate emails.\\n\\nReturn the result table in any order.\\n\\nThe query result format is in the following example.\\n\\n \\n\\nExample 1:\\n\\nInput: \\nPerson table:\\n+----+---------+\\n| Id | Email   |\\n+----+---------+\\n| 1  | a@b.com |\\n| 2  | c@d.com |\\n| 3  | a@b.com |\\n+----+---------+\\nOutput: \\n+---------+\\n| Email   |\\n+---------+\\n| a@b.com |\\n+---------+\\nExplanation: a@b.com is repeated two times.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1510657,
                "title": "duplicate-emails-mssql-server",
                "content": "select \\nEmail\\nfrom Person\\ngroup by Email\\nhaving count(Email) > 1\\norder by Email asc",
                "solutionTags": [],
                "code": "select \\nEmail\\nfrom Person\\ngroup by Email\\nhaving count(Email) > 1\\norder by Email asc",
                "codeTag": "Unknown"
            },
            {
                "id": 1437686,
                "title": "very-simple-mysql",
                "content": "```\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) > 1;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1342332,
                "title": "simple-solution-with-group-by-and-having",
                "content": "select email from person \\ngroup by email having count(email) > 1;",
                "solutionTags": [],
                "code": "select email from person \\ngroup by email having count(email) > 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1175726,
                "title": "simple-sql-query",
                "content": "Here,\\nCheck if Ids are not equal and if email ids are equal, so the are duplicates !\\n\\n```\\nSELECT DISTINCT p1.Email\\nfrom Person p1,Person p2\\nwhere p1.Id <> p2.Id \\nand p1.Email = p2.Email\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT p1.Email\\nfrom Person p1,Person p2\\nwhere p1.Id <> p2.Id \\nand p1.Email = p2.Email\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1083314,
                "title": "using-having-clause",
                "content": "```\\nSelect Email from Person\\nGroup by Email\\nHaving count(*) > 1;\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSelect Email from Person\\nGroup by Email\\nHaving count(*) > 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1069005,
                "title": "i-believe-simple-and-human-readable-answer-is-the-best",
                "content": "SELECT Email\\nFROM PERSON\\nGROUP BY EMAIL\\nHAVING COUNT(EMAIL) > 1",
                "solutionTags": [],
                "code": "SELECT Email\\nFROM PERSON\\nGROUP BY EMAIL\\nHAVING COUNT(EMAIL) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 912151,
                "title": "mysql-use-group-by-and-count",
                "content": "```\\nSELECT email from Person GROUP by email HAVING COUNT(email) > 1;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email from Person GROUP by email HAVING COUNT(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 745392,
                "title": "mysql-using-group-by",
                "content": "If you found the solution helpful, kindly upvote :)\\n\\n```\\n# Write your MySQL query statement below\\nSELECT email FROM person group by email having count(email)>1; \\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT email FROM person group by email having count(email)>1; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 621389,
                "title": "simplest-question-on-leetcode",
                "content": "select email from person group by email having(count(id)>1)",
                "solutionTags": [],
                "code": "select email from person group by email having(count(id)>1)",
                "codeTag": "Unknown"
            },
            {
                "id": 488546,
                "title": "faster-than-99-36-of-ms-sql-server",
                "content": "SELECT Email FROM Person\\nGROUP BY Email\\nHaving count(Email)>1",
                "solutionTags": [],
                "code": "SELECT Email FROM Person\\nGROUP BY Email\\nHaving count(Email)>1",
                "codeTag": "Unknown"
            },
            {
                "id": 53538,
                "title": "i-am-a-newbie-on-sql-share-my-solution-no-having-no-join",
                "content": "```\\nSELECT CountTable.Email FROM (\\nSELECT Person.Email,COUNT(Person.Email) AS CountNum\\n\\tFROM Person\\n\\tGROUP BY Person.Email\\n) AS CountTable WHERE CountTable.CountNum>1;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT CountTable.Email FROM (\\nSELECT Person.Email,COUNT(Person.Email) AS CountNum\\n\\tFROM Person\\n\\tGROUP BY Person.Email\\n) AS CountTable WHERE CountTable.CountNum>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53556,
                "title": "min-and-max-a-different-way-to-find-duplicate",
                "content": "Just for sharing. It can also find the `duplicate` emails.\\n\\n    SELECT email \\n    FROM (  SELECT email, MIN(id) minid, MAX(id) maxid\\n            FROM Person \\n            GROUP by email ) minmax\\n    WHERE minid <> maxid\\nIf change the where condition, we can get the `unique` ones.\\n\\n    WHERE minid = maxid",
                "solutionTags": [],
                "code": "Just for sharing. It can also find the `duplicate` emails.\\n\\n    SELECT email \\n    FROM (  SELECT email, MIN(id) minid, MAX(id) maxid\\n            FROM Person \\n            GROUP by email ) minmax\\n    WHERE minid <> maxid\\nIf change the where condition, we can get the `unique` ones.\\n\\n    WHERE minid = maxid",
                "codeTag": "Unknown"
            },
            {
                "id": 4043257,
                "title": "extracting-duplicate-rows-from-a-dataframe-object-and-returning-these-rows-in-a-new-dataframe",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires extracting rows from the person DataFrame that have duplicate email addresses and returning these rows in a new DataFrame. The intuition is to use the .duplicated() method to identify rows with duplicate email addresses and then create a new DataFrame containing these rows.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Use the .duplicated() method with keep=\\'first\\' to identify rows with duplicate email addresses while keeping the first occurrence.\\n- Create a new DataFrame, duplicate_df, by filtering the rows from the person DataFrame using the boolean result from the .duplicated() operation.\\nRename the \\'email\\' column in the duplicate_df DataFrame to \\'Email\\'.\\n- Use .drop_duplicates(subset=[\\'Email\\']) to remove duplicate rows based on the \\'Email\\' column and keep only one instance of each duplicate email address.\\n- Return the resulting output_df DataFrame containing one instance of each duplicate email address.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the number of rows in the person DataFrame. The time complexity is dominated by the operations to identify duplicates and filter the DataFrame, which is proportional to the number of rows in the person DataFrame.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n\\n\\n- Space complexity: O(k), where k is the number of unique duplicate email addresses in the person DataFrame. The space complexity is determined by the space required to store the duplicate_df and output_df DataFrames. Both DataFrames will have the same number of rows as the number of duplicate email addresses. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n    \\'\\'\\'\\n    @param: DataFrame object named person \\n    @return: DataFrame object with 1 column label Email and each row is a repeated email \\n    \\'\\'\\'\\n\\n    # The .duplicated() method in pandas returns a Boolean Series that indicates whether each row in a DataFrame is a duplicate of a previous row. The resulting Series has the same number of rows as the original DataFrame, where each element is True if the corresponding row is a duplicate and False otherwise.\\n\\n\\n    # output_df = pd.DataFrame(columns=[\\'Email\\']) # Initialise an empty dataframe object \\n    duplicate_df = person[person.duplicated(subset=[\\'email\\'], keep= \\'first\\')] # Create a new dataframe with rows from the person DF\\n    # print(type(duplicate_df))\\n\\n    # extract the required columns \\n    output_df = duplicate_df.rename(columns={\\'email\\':\\'Email\\'})[[\\'Email\\']].drop_duplicates(subset=[\\'Email\\'])\\n    return output_df\\n\\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n    \\'\\'\\'\\n    @param: DataFrame object named person \\n    @return: DataFrame object with 1 column label Email and each row is a repeated email \\n    \\'\\'\\'\\n\\n    # The .duplicated() method in pandas returns a Boolean Series that indicates whether each row in a DataFrame is a duplicate of a previous row. The resulting Series has the same number of rows as the original DataFrame, where each element is True if the corresponding row is a duplicate and False otherwise.\\n\\n\\n    # output_df = pd.DataFrame(columns=[\\'Email\\']) # Initialise an empty dataframe object \\n    duplicate_df = person[person.duplicated(subset=[\\'email\\'], keep= \\'first\\')] # Create a new dataframe with rows from the person DF\\n    # print(type(duplicate_df))\\n\\n    # extract the required columns \\n    output_df = duplicate_df.rename(columns={\\'email\\':\\'Email\\'})[[\\'Email\\']].drop_duplicates(subset=[\\'Email\\'])\\n    return output_df\\n\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3820302,
                "title": "duplicate-emails-mysql-solution-code",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect email from Person\\ngroup by email\\nhaving count(email) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email from Person\\ngroup by email\\nhaving count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3550320,
                "title": "easy-sql-code-group-by-having-clause-used",
                "content": "# Intuition\\nSimply **GROUP BY-HAVING** Clause is used.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT email FROM Person GROUP BY email HAVING COUNT(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT email FROM Person GROUP BY email HAVING COUNT(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3506152,
                "title": "mysql-mega-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDon\\'t forget to write the commands in order\\n\\n# Code\\n```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3336670,
                "title": "duplicate-emails",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect email from Person group by email having count(*)>1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email from Person group by email having count(*)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3281912,
                "title": "sql-simple-solution",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct p1.email as Email from person as p1 join person as p2 \\nwhere p1.email=p2.email and p1.id!=p2.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct p1.email as Email from person as p1 join person as p2 \\nwhere p1.email=p2.email and p1.id!=p2.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3167019,
                "title": "easiest-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect email as Email from Person group by email having count(email)>=2;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect email as Email from Person group by email having count(email)>=2;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3104694,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect Email\\nfrom Person\\ngroup by Email\\nhaving count(*)>1;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Email\\nfrom Person\\ngroup by Email\\nhaving count(*)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2951670,
                "title": "easiest-way-using-self-join-and-groupby",
                "content": "**UPVOTE IF U FOUND IT HELPFUL :-)**\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct(p1.email) as Email\\nfrom Person p1,Person p2\\nwhere p1.email=p2.email and p1.id<>p2.id\\n```\\n\\n```\\nselect email as Email from Person\\nGroup by email\\nhaving count(email)>1\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct(p1.email) as Email\\nfrom Person p1,Person p2\\nwhere p1.email=p2.email and p1.id<>p2.id\\n```\n```\\nselect email as Email from Person\\nGroup by email\\nhaving count(email)>1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2813349,
                "title": "93-faster",
                "content": "![image](https://assets.leetcode.com/users/images/e946c37a-0515-4063-bd50-d6a0605dd695_1668416616.1929512.png)\\n\\n\\n```\\nSELECT email FROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email FROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2660507,
                "title": "simple-self-join",
                "content": "```\\nselect Distinct a.email as Email\\nfrom \\nPerson as a,\\nPerson as  b\\nwhere \\na.id <> b.id\\nand\\na.email = b.email\\n",
                "solutionTags": [],
                "code": "```\\nselect Distinct a.email as Email\\nfrom \\nPerson as a,\\nPerson as  b\\nwhere \\na.id <> b.id\\nand\\na.email = b.email\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2616318,
                "title": "easy-count-solution-with-explanation-2-approaches",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n```\\n# Write your MySQL query statement below\\nSELECT Email FROM Person GROUP BY Email HAVING  count(*) > 1;\\n```\\n\\nFor more detail please ref:\\n*(Note: You can bookmark it for your future ref)*\\nhttps://leet-codes.blogspot.com/2022/09/182-duplicate-emails.html",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT Email FROM Person GROUP BY Email HAVING  count(*) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588859,
                "title": "using-group-by-clause-easy-one",
                "content": "Select email from Person\\ngroup by email\\nhaving count(email)>1;",
                "solutionTags": [],
                "code": "Select email from Person\\ngroup by email\\nhaving count(email)>1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2563211,
                "title": "mysql-better-than-100-memory-and-58-time",
                "content": "SELECT email FROM Person GROUP BY email having count(email)>1",
                "solutionTags": [],
                "code": "SELECT email FROM Person GROUP BY email having count(email)>1",
                "codeTag": "Unknown"
            },
            {
                "id": 2562037,
                "title": "simple-soln-using-inner-join",
                "content": "select distinct p1.email as Email from person p1 inner join person p2\\nwhere p1.email= p2.email and p1.id<>p2.id;",
                "solutionTags": [],
                "code": "select distinct p1.email as Email from person p1 inner join person p2\\nwhere p1.email= p2.email and p1.id<>p2.id;",
                "codeTag": "Unknown"
            },
            {
                "id": 2558738,
                "title": "mysql-fundamental-approach",
                "content": "\\tSELECT Email FROM\\n    (SELECT Email, COUNT(Email) AS c\\n    FROM Person\\n    GROUP BY Email) AS Tem\\n    WHERE c > 1;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tSELECT Email FROM\\n    (SELECT Email, COUNT(Email) AS c\\n    FROM Person\\n    GROUP BY Email) AS Tem\\n    WHERE c > 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2556848,
                "title": "simplest-solution-mysql-having-clause",
                "content": "select email from Person group by email\\nhaving count(*) > 1;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select email from Person group by email\\nhaving count(*) > 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2545091,
                "title": "sql-solution-using-window-function",
                "content": "```\\nselect email as \"Email\" from(select distinct email, count(p.email) over(partition by p.email) as \"count\" from person p) x where x.count>1\\n```\\n\\nPlease upvote!!!",
                "solutionTags": [],
                "code": "```\\nselect email as \"Email\" from(select distinct email, count(p.email) over(partition by p.email) as \"count\" from person p) x where x.count>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2541900,
                "title": "ms-sql-solution",
                "content": "select email from Person group by email having count(*) > 1;\\n",
                "solutionTags": [],
                "code": "select email from Person group by email having count(*) > 1;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2537096,
                "title": "mysql-solution-simple",
                "content": "```\\n# Write your MySQL query statement below\\n    #Using group by and having\\n    SELECT email AS \\'Email\\'\\n    FROM Person\\n    GROUP BY email\\n    HAVING COUNT(email)>1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n    #Using group by and having\\n    SELECT email AS \\'Email\\'\\n    FROM Person\\n    GROUP BY email\\n    HAVING COUNT(email)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2528677,
                "title": "mysql-easy-solution-group-by",
                "content": "```\\nSELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING count(email) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2514308,
                "title": "mysql-duplicate-emails-sol-324-ms",
                "content": "```\\nselect email Email from Person group by email having count(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect email Email from Person group by email having count(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2505270,
                "title": "easy-mysql-short-and-concise-check-it",
                "content": "```\\nselect email\\nfrom person \\ngroup by email\\nhaving count(*) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect email\\nfrom person \\ngroup by email\\nhaving count(*) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2476510,
                "title": "with-explanation-comments-time-323-ms-85-63-space-0b-100-00",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\n#select all elements from the coulmn \"Email\"\\nSELECT Email\\n#from the Person table\\nFROM Person\\n#groupped by the Email field\\nGROUP BY Email\\n#having a value more than 1\\nHAVING COUNT(*) > 1;\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\n#select all elements from the coulmn \"Email\"\\nSELECT Email\\n#from the Person table\\nFROM Person\\n#groupped by the Email field\\nGROUP BY Email\\n#having a value more than 1\\nHAVING COUNT(*) > 1;\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2468168,
                "title": "mysql-solution-easy-understanding-group-by-having",
                "content": "```\\nselect email as \\'Email\\'\\nfrom Person \\nGROUP BY email\\nHAVING COUNT(email) > 1\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect email as \\'Email\\'\\nfrom Person \\nGROUP BY email\\nHAVING COUNT(email) > 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2456284,
                "title": "faster-than-70-89-using-having-and-count-easy-to-understand",
                "content": "```\\nSELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2386383,
                "title": "mysql-3-ways-super-easy",
                "content": "* **SELF JOIN**\\n```sql\\nSELECT DISTINCT A.email FROM Person A,Person B\\nWHERE A.id <> B.id\\nAND A.email = B.email;\\n```\\n\\n* **Having and Group By Clause**\\n```sql\\nSELECT email FROM Person GROUP BY email HAVING count(email) > 1;\\n```\\n\\n* **Having, Group By, Temperoary Table**\\n```sql\\nSELECT email FROM (\\n    SElECT email,count(email) as EmailCount FROM Person GROUP BY email\\n) as emailData WHERE EmailCount > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nSELECT DISTINCT A.email FROM Person A,Person B\\nWHERE A.id <> B.id\\nAND A.email = B.email;\\n```\n```sql\\nSELECT email FROM Person GROUP BY email HAVING count(email) > 1;\\n```\n```sql\\nSELECT email FROM (\\n    SElECT email,count(email) as EmailCount FROM Person GROUP BY email\\n) as emailData WHERE EmailCount > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2356926,
                "title": "can-anyone-explain-why-group-by-is-needed",
                "content": "My initial code was \\n\\n```\\nselect Email\\nfrom Person\\nhaving count(email) > 1\\n```\\nbut this only passed the test case and did not pass the submission. The submission test case wanted me to return an empty value since there are no duplicates. After looking at the discussion board, the top solution is:\\n\\n```\\nselect Email\\nfrom Person\\ngroup by Email\\nhaving count(*) > 1\\n```\\nThis does pass the submission test case but I dont understand why. \\n\\nI am trying to fully understand so maybe I am thinking to hard about it but;\\nCan anyone explain why the \\'Group By\\' allows the query to return an empty value?\\n\\n",
                "solutionTags": [],
                "code": "```\\nselect Email\\nfrom Person\\nhaving count(email) > 1\\n```\n```\\nselect Email\\nfrom Person\\ngroup by Email\\nhaving count(*) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2356055,
                "title": "solution-you-thought-first",
                "content": "```\\nSELECT EMAIL FROM PERSON\\nGROUP BY EMAIL \\nHAVING COUNT(EMAIL) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT EMAIL FROM PERSON\\nGROUP BY EMAIL \\nHAVING COUNT(EMAIL) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2337509,
                "title": "using-having-and-group-by",
                "content": "```\\n# Write your MySQL query statement below\\n\\nSELECT email FROM Person \\nGROUP BY email \\nHAVING COUNT(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT email FROM Person \\nGROUP BY email \\nHAVING COUNT(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2329912,
                "title": "simple-group-by-with-having",
                "content": "select email from person group by email having count(*)>=2",
                "solutionTags": [],
                "code": "select email from person group by email having count(*)>=2",
                "codeTag": "Unknown"
            },
            {
                "id": 2319719,
                "title": "simple-mysql-solution-easy-to-understand-group-by",
                "content": "```\\nSELECT\\n    email AS Email\\nFROM\\n    Person\\nGROUP BY\\n    email\\nHAVING\\n    COUNT(id) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    email AS Email\\nFROM\\n    Person\\nGROUP BY\\n    email\\nHAVING\\n    COUNT(id) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2270479,
                "title": "faster-than-95-simple-mysql-solution",
                "content": "```\\nSELECT\\n    email AS Email\\nFROM\\n    Person\\nGROUP BY\\n    email\\nHAVING\\n    COUNT(id) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    email AS Email\\nFROM\\n    Person\\nGROUP BY\\n    email\\nHAVING\\n    COUNT(id) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2251545,
                "title": "without-group-by",
                "content": "\\'\\'\\'\\nselect distinct p1.email from person as p1,person as p2 where p1.email=p2.email and p1.id!=p2.id;\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nselect distinct p1.email from person as p1,person as p2 where p1.email=p2.email and p1.id!=p2.id;\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2247548,
                "title": "one-line-oracle-solution-80-efficient",
                "content": "select distinct a.email from Person a inner join Person b on a.email=b.email where a.id<>b.id",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "select distinct a.email from Person a inner join Person b on a.email=b.email where a.id<>b.id",
                "codeTag": "Unknown"
            },
            {
                "id": 2179813,
                "title": "easy-solution-using-count-and-group-by",
                "content": "select email as Email\\nfrom Person \\ngroup by 1\\nhaving count(1)>1",
                "solutionTags": [],
                "code": "select email as Email\\nfrom Person \\ngroup by 1\\nhaving count(1)>1",
                "codeTag": "Unknown"
            },
            {
                "id": 2146501,
                "title": "simple-to-understand-solution",
                "content": "select email from person\\ngroup by email\\nhaving count(email)>1;\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select email from person\\ngroup by email\\nhaving count(email)>1;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2135537,
                "title": "mssql-grop-by-having",
                "content": "```\\nselect email\\nfrom Person\\ngroup by email\\nhaving count(email) > 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect email\\nfrom Person\\ngroup by email\\nhaving count(email) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2105397,
                "title": "mysql-easiest-solution",
                "content": "**Pls Upvote if you lke the Solution!**\\n```\\nSELECT DISTINCT(p1.email) \\nFROM Person p1 JOIN Person p2 \\nON p1.email=p2.email AND p1.id<>p2.id",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "**Pls Upvote if you lke the Solution!**\\n```\\nSELECT DISTINCT(p1.email) \\nFROM Person p1 JOIN Person p2 \\nON p1.email=p2.email AND p1.id<>p2.id",
                "codeTag": "Unknown"
            },
            {
                "id": 2095226,
                "title": "sql-easy-simple-solution",
                "content": "**All suggestions are welcome.\\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)**\\n\\n\\n```\\nselect distinct p1.email from Person p1, Person  p2 where p1.email=p2.email and p1.id > p2.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct p1.email from Person p1, Person  p2 where p1.email=p2.email and p1.id > p2.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2092836,
                "title": "easy-solution",
                "content": "```\\nSELECT email FROM Person GROUP BY email HAVING COUNT(email)>1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email FROM Person GROUP BY email HAVING COUNT(email)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2089925,
                "title": "simple-mysql-query-based-on-delete-duplicate-emails-192",
                "content": "[Solution](https://leetcode.com/problems/delete-duplicate-emails/discuss/55553/Simple-Solution) using which this one was developed\\n```\\nselect distinct p1.email\\nFROM Person p1, Person p2\\nWHERE p1.Email = p2.Email AND\\np1.Id > p2.Id\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct p1.email\\nFROM Person p1, Person p2\\nWHERE p1.Email = p2.Email AND\\np1.Id > p2.Id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2058479,
                "title": "simplest-answer-dont-search-for-complex-one",
                "content": "```\\nSELECT email FROM Person GROUP BY email HAVING COUNT(email) > 1 ;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email FROM Person GROUP BY email HAVING COUNT(email) > 1 ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2005850,
                "title": "mysql-100-less-memory",
                "content": "Select Email\\nFrom Person\\nGroup By Email\\nHaving Count(Email) > 1",
                "solutionTags": [],
                "code": "Select Email\\nFrom Person\\nGroup By Email\\nHaving Count(Email) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 1994343,
                "title": "extremely-simple-and-fast-solution",
                "content": "```\\nSELECT email FROM Person\\nGROUP BY email\\nHAVING  COUNT(email) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email FROM Person\\nGROUP BY email\\nHAVING  COUNT(email) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1986789,
                "title": "easy-sql-solution",
                "content": "```\\nSelect DISTINCT email AS \\'Email\\'\\nFROM Person p\\nWHERE email IN (SELECT email FROM Person p1 WHERE p.id <> p1.id)\\n```\\n\\n![image](https://assets.leetcode.com/users/images/be4a4d08-73c1-4d66-840a-f0302643c79e_1651073127.4433901.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect DISTINCT email AS \\'Email\\'\\nFROM Person p\\nWHERE email IN (SELECT email FROM Person p1 WHERE p.id <> p1.id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1973590,
                "title": "used-distinct-and-select-2-tables-71-72-time-100-00-space",
                "content": "```\\n# Write your MySQL query statement below\\nselect DISTINCT p.email as email from Person P \\nwhere P.email in (select email from Person P2 where p2.id <> p.id);  \\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect DISTINCT p.email as email from Person P \\nwhere P.email in (select email from Person P2 where p2.id <> p.id);  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1969130,
                "title": "mysql-easy-implementation",
                "content": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(id) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(id) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1960555,
                "title": "mysql-93-faster-one-line-group-by",
                "content": "```\\nselect email from Person group by 1 having count(id) > 1;\\n```",
                "solutionTags": [],
                "code": "```\\nselect email from Person group by 1 having count(id) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1959553,
                "title": "mysql-simple-solution-faster-than-93",
                "content": "```\\n# Write your MySQL query statement below\\nselect email from person group by email having count(email) > 1",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email from person group by email having count(email) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 1911436,
                "title": "ms-sql",
                "content": "Runtime: 756 ms, faster than 96.81% of MS SQL Server online submissions for Duplicate Emails.\\nMemory Usage: 0B, less than 100.00% of MS SQL Server online submissions for Duplicate Emails.\\n```\\nwith cte as\\n(SELECT email, count(id) cnt\\nfrom Person\\ngroup by email)\\nselect email from cte\\nwhere cnt > 1\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nwith cte as\\n(SELECT email, count(id) cnt\\nfrom Person\\ngroup by email)\\nselect email from cte\\nwhere cnt > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891919,
                "title": "ms-sql-server-solution",
                "content": "Runtime: 1059 ms, faster than 59.13% of MS SQL Server online submissions for Duplicate Emails.\\nMemory Usage: 0B, less than 100.00% of MS SQL Server online submissions for Duplicate Emails.\\n\\n```\\n/* Write your T-SQL query statement below */\\nselect email as Email from Person group by email having count(email) > 1;\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect email as Email from Person group by email having count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1884959,
                "title": "simple-sql-solution-using-2-approaches-self-join-and-group-by",
                "content": "```\\n# Using Group by and having clause\\nselect Email from person group by email having count(*) > 1\\n\\n# Using self join\\nselect distinct p1.Email from person p1 join person p2\\non p1.email = p2.email and p1.id != p2.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Using Group by and having clause\\nselect Email from person group by email having count(*) > 1\\n\\n# Using self join\\nselect distinct p1.Email from person p1 join person p2\\non p1.email = p2.email and p1.id != p2.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1882698,
                "title": "faster-solution",
                "content": "```\\n# Write your MySQL query statement below\\nselect distinct(email) from Person where email in (select email from Person  group by email having count(email)>1)\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct(email) from Person where email in (select email from Person  group by email having count(email)>1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1849980,
                "title": "beats-88-2-runtime-and-beats-100-memory-utilization",
                "content": "select distinct(p.email) from person p where p.email in (select s.email from person s where s.id != p.id)",
                "solutionTags": [],
                "code": "select distinct(p.email) from person p where p.email in (select s.email from person s where s.id != p.id)",
                "codeTag": "Unknown"
            },
            {
                "id": 1790478,
                "title": "easy-solution",
                "content": "select email from person group by email having count(email) > 1;",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "select email from person group by email having count(email) > 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1720147,
                "title": "mysql-solution-using-having",
                "content": "```\\nSELECT email\\nFROM   person\\nGROUP  BY email\\nHAVING Count(*) > 1 \\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email\\nFROM   person\\nGROUP  BY email\\nHAVING Count(*) > 1 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1710053,
                "title": "sql-count",
                "content": "select email\\nfrom person\\ngroup by email\\nhaving count(email)>1;",
                "solutionTags": [],
                "code": "select email\\nfrom person\\ngroup by email\\nhaving count(email)>1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1681421,
                "title": "mysql-simple-solution",
                "content": "```\\nselect distinct p1.email as \\'Email\\' from Person p1, Person p2\\nwhere p1.id != p2.id and p1.email = p2.email;\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct p1.email as \\'Email\\' from Person p1, Person p2\\nwhere p1.id != p2.id and p1.email = p2.email;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1645168,
                "title": "easy-solution-without-using-group-by",
                "content": "```\\nSELECT DISTINCT A.email\\nFROM Person AS A, Person AS B\\nWHERE A.id <> B.id\\nAND A.email = B.email;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT A.email\\nFROM Person AS A, Person AS B\\nWHERE A.id <> B.id\\nAND A.email = B.email;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1631615,
                "title": "mysql-easy",
                "content": "```\\nSelect email As Email\\nFrom Person\\nGroup By email\\nHaving Count(*) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect email As Email\\nFrom Person\\nGroup By email\\nHaving Count(*) > 1\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1575016,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1576972,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1571389,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1568481,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1570505,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1574508,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1573320,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1576741,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1576150,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1575521,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1575016,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1576972,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1571389,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1568481,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1570505,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1574508,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1573320,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1576741,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1576150,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1575521,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1574345,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 1576215,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 1575485,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 1574455,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 2076978,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 2064868,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 2022928,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 1964590,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 1896547,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 1893963,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 1881442,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1845451,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1839695,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1812094,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1808987,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1803586,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1802766,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1797654,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1797262,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1792261,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1783597,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1777337,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1776030,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1774127,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1751993,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1731142,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1724819,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1716892,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1716838,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1716295,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            }
        ]
    },
    {
        "title": "Expression Add Operators",
        "question_content": "<p>Given a string <code>num</code> that contains only digits and an integer <code>target</code>, return <em><strong>all possibilities</strong> to insert the binary operators </em><code>&#39;+&#39;</code><em>, </em><code>&#39;-&#39;</code><em>, and/or </em><code>&#39;*&#39;</code><em> between the digits of </em><code>num</code><em> so that the resultant expression evaluates to the </em><code>target</code><em> value</em>.</p>\n\n<p>Note that operands in the returned expressions <strong>should not</strong> contain leading zeros.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;123&quot;, target = 6\n<strong>Output:</strong> [&quot;1*2*3&quot;,&quot;1+2+3&quot;]\n<strong>Explanation:</strong> Both &quot;1*2*3&quot; and &quot;1+2+3&quot; evaluate to 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;232&quot;, target = 8\n<strong>Output:</strong> [&quot;2*3+2&quot;,&quot;2+3*2&quot;]\n<strong>Explanation:</strong> Both &quot;2*3+2&quot; and &quot;2+3*2&quot; evaluate to 8.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;3456237490&quot;, target = 9191\n<strong>Output:</strong> []\n<strong>Explanation:</strong> There are no expressions that can be created from &quot;3456237490&quot; to evaluate to 9191.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10</code></li>\n\t<li><code>num</code> consists of only digits.</li>\n\t<li><code>-2<sup>31</sup> &lt;= target &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 71895,
                "title": "java-standard-backtrace-ac-solutoin-short-and-clear",
                "content": "This problem has a lot of edge cases to be considered:\\n\\n1. overflow: we use a long type once it is larger than Integer.MAX_VALUE or minimum, we get over it. \\n2. 0 sequence: because we can't have numbers with multiple digits started with zero, we have to deal with it too.\\n3. a little trick is that we should save the value that is to be multiplied in the next recursion.\\n\\n---\\n\\n    public class Solution {\\n        public List<String> addOperators(String num, int target) {\\n            List<String> rst = new ArrayList<String>();\\n            if(num == null || num.length() == 0) return rst;\\n            helper(rst, \"\", num, target, 0, 0, 0);\\n            return rst;\\n        }\\n        public void helper(List<String> rst, String path, String num, int target, int pos, long eval, long multed){\\n            if(pos == num.length()){\\n                if(target == eval)\\n                    rst.add(path);\\n                return;\\n            }\\n            for(int i = pos; i < num.length(); i++){\\n                if(i != pos && num.charAt(pos) == '0') break;\\n                long cur = Long.parseLong(num.substring(pos, i + 1));\\n                if(pos == 0){\\n                    helper(rst, path + cur, num, target, i + 1, cur, cur);\\n                }\\n                else{\\n                    helper(rst, path + \"+\" + cur, num, target, i + 1, eval + cur , cur);\\n                    \\n                    helper(rst, path + \"-\" + cur, num, target, i + 1, eval -cur, -cur);\\n                    \\n                    helper(rst, path + \"*\" + cur, num, target, i + 1, eval - multed + multed * cur, multed * cur );\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<String> addOperators(String num, int target) {\\n            List<String> rst = new ArrayList<String>();\\n            if(num == null || num.length() == 0) return rst;\\n            helper(rst, \"\", num, target, 0, 0, 0);\\n            return rst;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 572099,
                "title": "c-java-python-backtracking-evaluate-on-the-fly-clean-concise",
                "content": "**\\u2714\\uFE0F Approach 1: Backtracking & Evaluate Expression**\\n- We use backtracking to generate all possible expressions by adding `+`, `-`, `*` to between the digits of `s` string.\\n- Then write a function `evaluate(string expression)` to evaluate a string expression, if the evaluated result is equal to `target`, we add that expression string to our answer.\\n<details>\\n<summary>Click to see the implementation!</summary>\\n\\n<iframe src=\"https://leetcode.com/playground/6KRPJGSj/shared\" frameBorder=\"0\" width=\"100%\" height=\"1200\"></iframe>\\n</details>\\n\\n---\\n\\n**\\u2714\\uFE0F Approach 2: Backtracking & Evaluate on the fly (Best Solution)**\\n- We use backtracking to generate all possible expressions by adding `+`, `-`, `*` to between the digits of `s` string.\\n- There is no priority since there are no parentheses `(` and `)` in our `s` string, so we can evaluate the expression on the fly to save time.\\n- There are total 3 operators:\\n\\t- `+` operator: `newResult = resSoFar + num`\\n\\t- `-` operator: `newResult = resSoFar - num`.\\n\\t- `*` operator: We need to keep the `prevNum` so that to calculate `newResult` we need to minus `prevNum` then plus with `prevNum * num`. So `newResult = resSoFar - prevNum + prevNum * num`.\\n<iframe src=\"https://leetcode.com/playground/J8AiipGK/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F Approach 1: Backtracking & Evaluate Expression**\\n- We use backtracking to generate all possible expressions by adding `+`, `-`, `*` to between the digits of `s` string.\\n- Then write a function `evaluate(string expression)` to evaluate a string expression, if the evaluated result is equal to `target`, we add that expression string to our answer.\\n<details>\\n<summary>Click to see the implementation!</summary>\\n\\n<iframe src=\"https://leetcode.com/playground/6KRPJGSj/shared\" frameBorder=\"0\" width=\"100%\" height=\"1200\"></iframe>\\n</details>\\n\\n---\\n\\n**\\u2714\\uFE0F Approach 2: Backtracking & Evaluate on the fly (Best Solution)**\\n- We use backtracking to generate all possible expressions by adding `+`, `-`, `*` to between the digits of `s` string.\\n- There is no priority since there are no parentheses `(` and `)` in our `s` string, so we can evaluate the expression on the fly to save time.\\n- There are total 3 operators:\\n\\t- `+` operator: `newResult = resSoFar + num`\\n\\t- `-` operator: `newResult = resSoFar - num`.\\n\\t- `*` operator: We need to keep the `prevNum` so that to calculate `newResult` we need to minus `prevNum` then plus with `prevNum * num`. So `newResult = resSoFar - prevNum + prevNum * num`.\\n<iframe src=\"https://leetcode.com/playground/J8AiipGK/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "codeTag": "Unknown"
            },
            {
                "id": 71968,
                "title": "clean-python-dfs-with-comments",
                "content": "dfs() parameters:  \\nnum:   remaining num string  \\ntemp:  temporally string with operators added  \\ncur:     current result of \"temp\" string  \\nlast:     last multiply-level number in \"temp\". if next operator is \"multiply\", \"cur\" and \"last\" will be updated  \\nres:      result to return\\n\\n    def addOperators(self, num, target):\\n        res, self.target = [], target\\n        for i in range(1,len(num)+1):\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], num[:i], int(num[:i]), int(num[:i]), res) # this step put first number in the string\\n        return res\\n\\n    def dfs(self, num, temp, cur, last, res):\\n        if not num:\\n            if cur == self.target:\\n                res.append(temp)\\n            return\\n        for i in range(1, len(num)+1):\\n            val = num[:i]\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], temp + \"+\" + val, cur+int(val), int(val), res)\\n                self.dfs(num[i:], temp + \"-\" + val, cur-int(val), -int(val), res)\\n                self.dfs(num[i:], temp + \"*\" + val, cur-last+last*int(val), last*int(val), res)",
                "solutionTags": [
                    "Python"
                ],
                "code": "dfs() parameters:  \\nnum:   remaining num string  \\ntemp:  temporally string with operators added  \\ncur:     current result of \"temp\" string  \\nlast:     last multiply-level number in \"temp\". if next operator is \"multiply\", \"cur\" and \"last\" will be updated  \\nres:      result to return\\n\\n    def addOperators(self, num, target):\\n        res, self.target = [], target\\n        for i in range(1,len(num)+1):\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], num[:i], int(num[:i]), int(num[:i]), res) # this step put first number in the string\\n        return res\\n\\n    def dfs(self, num, temp, cur, last, res):\\n        if not num:\\n            if cur == self.target:\\n                res.append(temp)\\n            return\\n        for i in range(1, len(num)+1):\\n            val = num[:i]\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], temp + \"+\" + val, cur+int(val), int(val), res)\\n                self.dfs(num[i:], temp + \"-\" + val, cur-int(val), -int(val), res)\\n                self.dfs(num[i:], temp + \"*\" + val, cur-last+last*int(val), last*int(val), res)",
                "codeTag": "Python3"
            },
            {
                "id": 71898,
                "title": "17-lines-solution-dfs-c",
                "content": "    class Solution {\\n    private:\\n        // cur: {string} expression generated so far.\\n        // pos: {int}    current visiting position of num.\\n        // cv:  {long}   cumulative value so far.\\n        // pv:  {long}   previous operand value.\\n        // op:  {char}   previous operator used.\\n        void dfs(std::vector<string>& res, const string& num, const int target, string cur, int pos, const long cv, const long pv, const char op) {\\n            if (pos == num.size() && cv == target) {\\n                res.push_back(cur);\\n            } else {\\n                for (int i=pos+1; i<=num.size(); i++) {\\n                    string t = num.substr(pos, i-pos);\\n                    long now = stol(t);\\n                    if (to_string(now).size() != t.size()) continue;\\n                    dfs(res, num, target, cur+'+'+t, i, cv+now, now, '+');\\n                    dfs(res, num, target, cur+'-'+t, i, cv-now, now, '-');\\n                    dfs(res, num, target, cur+'*'+t, i, (op == '-') ? cv+pv - pv*now : ((op == '+') ? cv-pv + pv*now : pv*now), pv*now, op);\\n                }\\n            }\\n        }\\n    \\n    public:\\n        vector<string> addOperators(string num, int target) {\\n            vector<string> res;\\n            if (num.empty()) return res;\\n            for (int i=1; i<=num.size(); i++) {\\n                string s = num.substr(0, i);\\n                long cur = stol(s);\\n                if (to_string(cur).size() != s.size()) continue;\\n                dfs(res, num, target, s, i, cur, cur, '#');         // no operator defined.\\n            }\\n    \\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    private:\\n        // cur: {string}",
                "codeTag": "Java"
            },
            {
                "id": 71897,
                "title": "java-ac-solution-19ms-beat-100-00",
                "content": "I am surprised that it beats 100.00% other solutions, so i have to share this.\\n\\n    void dfs(List<String> ret, char[] path, int len, long left, long cur, char[] digits, int pos, int target) {\\n        if (pos == digits.length) {\\n            if (left + cur == target) ret.add(new String(path, 0, len));\\n            return;\\n        }\\n        long n = 0;\\n        int j = len + 1;\\n        for (int i = pos; i < digits.length; i++) {\\n            n = n * 10 + digits[i] - '0';\\n            path[j++] = digits[i];\\n            path[len] = '+';\\n            dfs(ret, path, j, left + cur, n, digits, i + 1, target);\\n            path[len] = '-';\\n            dfs(ret, path, j, left + cur, -n, digits, i + 1, target);\\n            path[len] = '*';\\n            dfs(ret, path, j, left, cur * n, digits, i + 1, target);\\n            if (digits[pos] == '0') break; \\n        }\\n    }\\n    public List<String> addOperators(String num, int target) {\\n        List<String> ret = new LinkedList<>();\\n        if (num.length() == 0) return ret;\\n        char[] path = new char[num.length() * 2 - 1];\\n        char[] digits = num.toCharArray();\\n        long n = 0;\\n        for (int i = 0; i < digits.length; i++) {\\n            n = n * 10 + digits[i] - '0';\\n            path[i] = digits[i];\\n            dfs(ret, path, i + 1, 0, n, digits, i + 1, target);\\n            if (n == 0) break;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "I am surprised that it beats 100.00% other solutions, so i have to share this.\\n\\n    void dfs(List<String> ret, char[] path, int len, long left, long cur, char[] digits, int pos, int target) {\\n        if (pos == digits.length) {\\n            if (left + cur == target) ret.add(new String(path, 0, len));\\n            return;\\n        }\\n        long n = 0;\\n        int j = len + 1;\\n        for (int i = pos; i < digits.length; i++) {\\n            n = n * 10 + digits[i] - '0';\\n            path[j++] = digits[i];\\n            path[len] = '+';\\n            dfs(ret, path, j, left + cur, n, digits, i + 1, target);\\n            path[len] = '-';\\n            dfs(ret, path, j, left + cur, -n, digits, i + 1, target);\\n            path[len] = '*';\\n            dfs(ret, path, j, left, cur * n, digits, i + 1, target);\\n            if (digits[pos] == '0') break; \\n        }\\n    }\\n    public List<String> addOperators(String num, int target) {\\n        List<String> ret = new LinkedList<>();\\n        if (num.length() == 0) return ret;\\n        char[] path = new char[num.length() * 2 - 1];\\n        char[] digits = num.toCharArray();\\n        long n = 0;\\n        for (int i = 0; i < digits.length; i++) {\\n            n = n * 10 + digits[i] - '0';\\n            path[i] = digits[i];\\n            dfs(ret, path, i + 1, 0, n, digits, i + 1, target);\\n            if (n == 0) break;\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1470156,
                "title": "python-dfs-with-stack-of-monomials-explained",
                "content": "Quite diffucult problem, which is similar to Basic Calculators problem (**0224**, **0227**). Let us consider `dfs` with the following parameters:\\n\\n1. `idx` is the index of current element we traverse in `num`.\\n2. `path` is the string built so far.\\n3. `value` is current value of created path.\\n4. `last` is the value of the last monomial.\\n\\nHere we use idea of stack of monomials: imagine, that we have expression `1*2 + 3*4*5`, then we have the following steps: `[1], [2], [2, 3], [2,12], [2,60]`: each time we have `+` or `-` we add one element to the end of stack; each time we have `*` we update the last element in stack.\\n\\nThen when we traverse our string, we can have several options: each time we need to create `tmp = int(num[idx: i])` and make sure that this is valid number: `tmp` will be the next number we are going to use. Then if `last == None`, we have only one option. If `last != None`, we can have `3` options which symbol we can take: if it is `+` or `-`, we just update `value` and sign of `tmp`. If it is multiplication, we need to update both `value` and `last` should be multiplied by `tmp`.\\n\\n#### Complexity\\nIt is potentially `O(4^n * n)`, because on each step we have `4` options: `+`, `-`, `*` or no sign. Space complexity potentially the same.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def addOperators(self, num, target):\\n        def dfs(idx, path, value, last):            \\n            if idx == n and value == target:\\n                ans.append(path)\\n            \\n            for i in range(idx + 1, n + 1):\\n                tmp = int(num[idx: i])\\n                if i == idx + 1 or (i > idx + 1 and num[idx] != \"0\"):\\n                    if last is None :\\n                        dfs(i, num[idx: i], tmp, tmp)\\n                    else:\\n                        dfs(i, path + \\'+\\' + num[idx: i], value + tmp, tmp)\\n                        dfs(i, path + \\'-\\' + num[idx: i], value - tmp, -tmp)\\n                        dfs(i, path + \\'*\\' + num[idx: i], value - last + last*tmp, last*tmp)\\n        \\n        ans, n = [], len(num)\\n        dfs(0, \"\", 0, None)\\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```python\\nclass Solution:\\n    def addOperators(self, num, target):\\n        def dfs(idx, path, value, last):            \\n            if idx == n and value == target:\\n                ans.append(path)\\n            \\n            for i in range(idx + 1, n + 1):\\n                tmp = int(num[idx: i])\\n                if i == idx + 1 or (i > idx + 1 and num[idx] != \"0\"):\\n                    if last is None :\\n                        dfs(i, num[idx: i], tmp, tmp)\\n                    else:\\n                        dfs(i, path + \\'+\\' + num[idx: i], value + tmp, tmp)\\n                        dfs(i, path + \\'-\\' + num[idx: i], value - tmp, -tmp)\\n                        dfs(i, path + \\'*\\' + num[idx: i], value - last + last*tmp, last*tmp)\\n        \\n        ans, n = [], len(num)\\n        dfs(0, \"\", 0, None)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71921,
                "title": "java-simple-solution-beats-96-56",
                "content": "Inspired by [this great solution][1]. \\n\\nWhat's different is, I use backtracking with `StringBuilder` instead of directly String addition.\\n\\nThis increase speed by `20%`.\\n\\n    public List<String> addOperators(String num, int target) {\\n        List<String> res = new ArrayList<>();\\n       \\tStringBuilder sb = new StringBuilder();\\n        dfs(res, sb, num, 0, target, 0, 0);\\n        return res;\\n        \\n    }\\n    public void dfs(List<String> res, StringBuilder sb, String num, int pos, int target, long prev, long multi) { \\n    \\tif(pos == num.length()) {\\n    \\t\\tif(target == prev) res.add(sb.toString());\\n    \\t\\treturn;\\n    \\t}\\n    \\tfor(int i = pos; i < num.length(); i++) {\\n    \\t\\tif(num.charAt(pos) == '0' && i != pos) break;\\n    \\t\\tlong curr = Long.parseLong(num.substring(pos, i + 1));\\n    \\t\\tint len = sb.length();\\n    \\t\\tif(pos == 0) {\\n    \\t\\t\\tdfs(res, sb.append(curr), num, i + 1, target, curr, curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t} else {\\n    \\t\\t\\tdfs(res, sb.append(\"+\").append(curr), num, i + 1, target, prev + curr, curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t\\tdfs(res, sb.append(\"-\").append(curr), num, i + 1, target, prev - curr, -curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t\\tdfs(res, sb.append(\"*\").append(curr), num, i + 1, target, prev - multi + multi * curr, multi * curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t}\\n    \\t}\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/58614/java-standard-backtrace-ac-solutoin-short-and-clear",
                "solutionTags": [
                    "Java"
                ],
                "code": "Inspired by [this great solution][1]. \\n\\nWhat's different is, I use backtracking with `StringBuilder` instead of directly String addition.\\n\\nThis increase speed by `20%`.\\n\\n    public List<String> addOperators(String num, int target) {\\n        List<String> res = new ArrayList<>();\\n       \\tStringBuilder sb = new StringBuilder();\\n        dfs(res, sb, num, 0, target, 0, 0);\\n        return res;\\n        \\n    }\\n    public void dfs(List<String> res, StringBuilder sb, String num, int pos, int target, long prev, long multi) { \\n    \\tif(pos == num.length()) {\\n    \\t\\tif(target == prev) res.add(sb.toString());\\n    \\t\\treturn;\\n    \\t}\\n    \\tfor(int i = pos; i < num.length(); i++) {\\n    \\t\\tif(num.charAt(pos) == '0' && i != pos) break;\\n    \\t\\tlong curr = Long.parseLong(num.substring(pos, i + 1));\\n    \\t\\tint len = sb.length();\\n    \\t\\tif(pos == 0) {\\n    \\t\\t\\tdfs(res, sb.append(curr), num, i + 1, target, curr, curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t} else {\\n    \\t\\t\\tdfs(res, sb.append(\"+\").append(curr), num, i + 1, target, prev + curr, curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t\\tdfs(res, sb.append(\"-\").append(curr), num, i + 1, target, prev - curr, -curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t\\tdfs(res, sb.append(\"*\").append(curr), num, i + 1, target, prev - multi + multi * curr, multi * curr); \\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t}\\n    \\t}\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/58614/java-standard-backtrace-ac-solutoin-short-and-clear",
                "codeTag": "Unknown"
            },
            {
                "id": 352605,
                "title": "explanation-and-way-to-make-it-efficient-from-134-ms-to-9-ms-to-beat-100",
                "content": "A war against each other [ String con Vs string builder vs char [] ]\\n\\nWhole code is commented well to understand;\\n\\nAll version are same, its just the usage of String , String builder and char [] to build the expression is differ. \\n\\n\\nUsing strings connectinations \\n---------------------\\n<details>\\nRuntime: 134 ms, faster than 30.99% of Java online submissions for Expression Add Operators.\\nMemory Usage: 63.4 MB, less than 14.58% of Java online submissions for Expression Add Operators.\\n\\n```\\n\\n/**\\n * Explanation: https://leetcode.com/articles/expression-add-operators/\\n * <p>\\n * Our choices:\\n * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n * 2. we can choose only one operator between two operands\\n * <p>\\n * Our Constraints:\\n * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n * 2. We can\\'t take more operators then available in input\\n * 3. We can choose only one operator once\\n * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n * <p>\\n * Out Goal:\\n * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n * 2. if not, we discard\\n * <p>\\n * <p>\\n * Runtime: 134 ms, faster than 30.99% of Java online submissions for Expression Add Operators.\\n * Memory Usage: 63.4 MB, less than 14.58% of Java online submissions for Expression Add Operators.\\n */\\nclass AddOperatorsBacktrackingString {\\n\\n\\n//    char ops[] = {\\'+\\', \\'-\\', \\'*\\'};\\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n\\n        addOperators(num, target, 0, 0, 0, \"\", expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(String num, int target, int index, long currentValue, long lastValue, String expression, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length()) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(expression);\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length(); i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num.charAt(index) == \\'0\\')\\n                break;\\n\\n            long currentDigitsValue = Long.parseLong(num.substring(index, i + 1));\\n\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression + currentDigitsValue, result);\\n\\n            } else {\\n                //We have two operands, last and current\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression + \"+\" + currentDigitsValue, result);\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression + \"-\" + currentDigitsValue, result);\\n\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression + \"*\" + currentDigitsValue, result);\\n\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n\\n}\\n```\\n\\n\\n</details>\\n\\nUsing StringBuilder \\n---------------\\n<details>\\n\\nRuntime: 81 ms, faster than 83.65% of Java online submissions for Expression Add Operators.\\nMemory Usage: 57.9 MB, less than 53.12% of Java online submissions for Expression Add Operators.\\n\\n```\\n\\n\\n/**\\n * Instead of using String concatenation we\\'ll use strinbuilder\\n * Runtime: 81 ms, faster than 83.65% of Java online submissions for Expression Add Operators.\\n * Memory Usage: 57.9 MB, less than 53.12% of Java online submissions for Expression Add Operators.\\n * <p>\\n * StringBuilder boost it performance from 84ms to 81ms.\\n */\\nclass AddOperatorsBacktrackingStringBuilder {\\n\\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n\\n        addOperators(num, target, 0, 0, 0, new StringBuilder(), expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(String num, int target, int index, long currentValue, long lastValue, StringBuilder expression, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length()) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(expression.toString());\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length(); i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num.charAt(index) == \\'0\\')\\n                break;\\n\\n            long currentDigitsValue = Long.parseLong(num.substring(index, i + 1));\\n            int len = expression.length();\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression.append(currentDigitsValue), result);\\n                expression.setLength(len); // This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n            } else {\\n                //We have two operands, last and current\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression.append(\"+\").append(currentDigitsValue), result);\\n                expression.setLength(len);// This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression.append(\"-\").append(currentDigitsValue), result);\\n                expression.setLength(len);// This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression.append(\"*\").append(currentDigitsValue), result);\\n                expression.setLength(len);// This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n\\n}\\n```\\n\\n</details>\\n\\n\\nUsing Char [] Array\\n-------------\\n<details>\\nRuntime: 11 ms, faster than 96.45% of Java online submissions for Expression Add Operators.\\nMemory Usage: 39.4 MB, less than 95.83% of Java online submissions for Expression Add Operators.\\n\\n```\\n\\n/**\\n * Instead of using String concatenation Or strinbuilder, we\\'ll use char array\\n * Runtime: 11 ms, faster than 96.45% of Java online submissions for Expression Add Operators.\\n * Memory Usage: 39.4 MB, less than 95.83% of Java online submissions for Expression Add Operators.\\n */\\nclass AddOperatorsBacktrackingCharArray {\\n\\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n        char cache[] = new char[2 * num.length()];\\n\\n        addOperators(num, target, 0, 0, 0, cache, 0, expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(String num, int target, int index, long currentValue, long lastValue, char[] expression, int expressionEndIndex, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length()) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(new String(expression, 0, expressionEndIndex));\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Find new cache length;\\n         * the corner case, where we have no data in cache, in this case we need to push at first index (0) otherwise at the next index\\n         *\\n         */\\n        int nextExpressionEndIndex = (index == 0) ? expressionEndIndex : expressionEndIndex + 1;\\n\\n        long currentDigitsValue = 0;\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length(); i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num.charAt(index) == \\'0\\')\\n                break;\\n\\n            currentDigitsValue = currentDigitsValue * 10 + num.charAt(i) - \\'0\\';\\n\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n                //Append\\n                expression[nextExpressionEndIndex++] = num.charAt(i);\\n\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            } else {\\n                //We have two operands, last and current\\n                //Append\\n                expression[nextExpressionEndIndex++] = num.charAt(i);\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                expression[expressionEndIndex] = \\'+\\';\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                expression[expressionEndIndex] = \\'-\\';\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                expression[expressionEndIndex] = \\'*\\';\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n\\n}\\n```\\n\\n</details>\\n\\nUsing Char [] for both input and intermiddate expression\\n------------------------------------\\n\\n<details>\\n Runtime: **9 ms, faster than 99.28%** of Java online submissions for Expression Add Operators.\\n Memory Usage: 39.5 MB, less than 94.79% of Java online submissions for Expression Add Operators.\\n \\n ```\\n \\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n        char cache[] = new char[2 * num.length()];\\n\\n        addOperators(num.toCharArray(), target, 0, 0, 0, cache, 0, expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(char num[], int target, int index, long currentValue, long lastValue, char[] expression, int expressionEndIndex, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(new String(expression, 0, expressionEndIndex));\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Find new cache length;\\n         * the corner case, where we have no data in cache, in this case we need to push at first index (0) otherwise at the next index\\n         *\\n         */\\n        int nextExpressionEndIndex = (index == 0) ? expressionEndIndex : expressionEndIndex + 1;\\n\\n        long currentDigitsValue = 0;\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length; i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num[index] == \\'0\\')\\n                break;\\n\\n            currentDigitsValue = currentDigitsValue * 10 + num[i] - \\'0\\';\\n\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n                //Append\\n                expression[nextExpressionEndIndex++] = num[i];\\n\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            } else {\\n                //We have two operands, last and current\\n                //Append\\n                expression[nextExpressionEndIndex++] = num[i];\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                expression[expressionEndIndex] = \\'+\\';\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                expression[expressionEndIndex] = \\'-\\';\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                expression[expressionEndIndex] = \\'*\\';\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n ```\\n\\n\\n<details>",
                "solutionTags": [],
                "code": "```\\n\\n/**\\n * Explanation: https://leetcode.com/articles/expression-add-operators/\\n * <p>\\n * Our choices:\\n * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n * 2. we can choose only one operator between two operands\\n * <p>\\n * Our Constraints:\\n * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n * 2. We can\\'t take more operators then available in input\\n * 3. We can choose only one operator once\\n * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n * <p>\\n * Out Goal:\\n * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n * 2. if not, we discard\\n * <p>\\n * <p>\\n * Runtime: 134 ms, faster than 30.99% of Java online submissions for Expression Add Operators.\\n * Memory Usage: 63.4 MB, less than 14.58% of Java online submissions for Expression Add Operators.\\n */\\nclass AddOperatorsBacktrackingString {\\n\\n\\n//    char ops[] = {\\'+\\', \\'-\\', \\'*\\'};\\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n\\n        addOperators(num, target, 0, 0, 0, \"\", expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(String num, int target, int index, long currentValue, long lastValue, String expression, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length()) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(expression);\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length(); i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num.charAt(index) == \\'0\\')\\n                break;\\n\\n            long currentDigitsValue = Long.parseLong(num.substring(index, i + 1));\\n\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression + currentDigitsValue, result);\\n\\n            } else {\\n                //We have two operands, last and current\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression + \"+\" + currentDigitsValue, result);\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression + \"-\" + currentDigitsValue, result);\\n\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression + \"*\" + currentDigitsValue, result);\\n\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n\\n}\\n```\n```\\n\\n\\n/**\\n * Instead of using String concatenation we\\'ll use strinbuilder\\n * Runtime: 81 ms, faster than 83.65% of Java online submissions for Expression Add Operators.\\n * Memory Usage: 57.9 MB, less than 53.12% of Java online submissions for Expression Add Operators.\\n * <p>\\n * StringBuilder boost it performance from 84ms to 81ms.\\n */\\nclass AddOperatorsBacktrackingStringBuilder {\\n\\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n\\n        addOperators(num, target, 0, 0, 0, new StringBuilder(), expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(String num, int target, int index, long currentValue, long lastValue, StringBuilder expression, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length()) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(expression.toString());\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length(); i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num.charAt(index) == \\'0\\')\\n                break;\\n\\n            long currentDigitsValue = Long.parseLong(num.substring(index, i + 1));\\n            int len = expression.length();\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression.append(currentDigitsValue), result);\\n                expression.setLength(len); // This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n            } else {\\n                //We have two operands, last and current\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression.append(\"+\").append(currentDigitsValue), result);\\n                expression.setLength(len);// This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression.append(\"-\").append(currentDigitsValue), result);\\n                expression.setLength(len);// This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression.append(\"*\").append(currentDigitsValue), result);\\n                expression.setLength(len);// This will make sure that this expression won\\'t exceed otherwise we need to remove \"currentDigitsValue\" from this to backtrack.\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n\\n}\\n```\n```\\n\\n/**\\n * Instead of using String concatenation Or strinbuilder, we\\'ll use char array\\n * Runtime: 11 ms, faster than 96.45% of Java online submissions for Expression Add Operators.\\n * Memory Usage: 39.4 MB, less than 95.83% of Java online submissions for Expression Add Operators.\\n */\\nclass AddOperatorsBacktrackingCharArray {\\n\\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n        char cache[] = new char[2 * num.length()];\\n\\n        addOperators(num, target, 0, 0, 0, cache, 0, expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(String num, int target, int index, long currentValue, long lastValue, char[] expression, int expressionEndIndex, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length()) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(new String(expression, 0, expressionEndIndex));\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Find new cache length;\\n         * the corner case, where we have no data in cache, in this case we need to push at first index (0) otherwise at the next index\\n         *\\n         */\\n        int nextExpressionEndIndex = (index == 0) ? expressionEndIndex : expressionEndIndex + 1;\\n\\n        long currentDigitsValue = 0;\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length(); i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num.charAt(index) == \\'0\\')\\n                break;\\n\\n            currentDigitsValue = currentDigitsValue * 10 + num.charAt(i) - \\'0\\';\\n\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n                //Append\\n                expression[nextExpressionEndIndex++] = num.charAt(i);\\n\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            } else {\\n                //We have two operands, last and current\\n                //Append\\n                expression[nextExpressionEndIndex++] = num.charAt(i);\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                expression[expressionEndIndex] = \\'+\\';\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                expression[expressionEndIndex] = \\'-\\';\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                expression[expressionEndIndex] = \\'*\\';\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n\\n}\\n```\n```\\n \\n\\n    public List<String> addOperators(String num, int target) {\\n\\n        List<String> expressions = new ArrayList<>();\\n\\n        if (num == null || num.isEmpty())\\n            return expressions;\\n\\n        char cache[] = new char[2 * num.length()];\\n\\n        addOperators(num.toCharArray(), target, 0, 0, 0, cache, 0, expressions);\\n\\n        return expressions;\\n\\n\\n    }\\n\\n    /**\\n     * @param num\\n     * @param target\\n     * @param index\\n     * @param currentValue\\n     * @param lastValue\\n     * @param expression\\n     * @param result\\n     */\\n    private void addOperators(char num[], int target, int index, long currentValue, long lastValue, char[] expression, int expressionEndIndex, List<String> result) {\\n\\n        /**\\n         * Our Constraints:\\n         * 1. We can\\'t take more numbers than given in input string ( index >= input.length)\\n         */\\n\\n        if (index == num.length) {\\n\\n            /**\\n             * Out Goal:\\n             * 1. once we form a expression, if that expression evaluates to our \"target\" then this is our solution.\\n             */\\n\\n            if (currentValue == target) {\\n                //then this is our solution.\\n                result.add(new String(expression, 0, expressionEndIndex));\\n\\n            } //2. if not, we discard\\n\\n\\n            return;\\n\\n        }\\n\\n        /**\\n         * Find new cache length;\\n         * the corner case, where we have no data in cache, in this case we need to push at first index (0) otherwise at the next index\\n         *\\n         */\\n        int nextExpressionEndIndex = (index == 0) ? expressionEndIndex : expressionEndIndex + 1;\\n\\n        long currentDigitsValue = 0;\\n        /**\\n         * Our choices:\\n         * 1. We can choose a single digits as operands Or multi digits as operand (  1 + 2 or 12 + 34 )\\n         */\\n        for (int i = index; i < num.length; i++) {\\n\\n\\n            /**\\n             * We don\\'t consider a operand which is 0 as single digit operand, as operand like 0 or 01 , 023... does not make sense\\n             *  To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n             */\\n            if (i != index && num[index] == \\'0\\')\\n                break;\\n\\n            currentDigitsValue = currentDigitsValue * 10 + num[i] - \\'0\\';\\n\\n\\n            /**\\n             * Our Constraints:\\n             * 4. We need two operands for a operator and operator can\\'t be apply on single operand\\n             */\\n\\n            if (index == 0) {\\n                // as this is the first digit only, then don\\'t apply any operator\\n                //Append\\n                expression[nextExpressionEndIndex++] = num[i];\\n\\n\\n                addOperators(num, target, i + 1, currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            } else {\\n                //We have two operands, last and current\\n                //Append\\n                expression[nextExpressionEndIndex++] = num[i];\\n\\n                /**\\n                 * Plus operator application \\'+\\'; Current value become = so far value + current digit value and last value would be the current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 + 5 = 17\\n                 * So last value would be 5\\n                 */\\n                expression[expressionEndIndex] = \\'+\\';\\n                addOperators(num, target, i + 1, currentValue + currentDigitsValue, currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Minus operator application \\'-\\'; Current value become = so far value - current digit value and last value would be the -current digit value\\n                 * current Value = 12\\n                 * last Value = 2 ( say we did like 10 + 2 )\\n                 * currentDigitvalue = 5 then expression is 10 + 2 - 5 = 7\\n                 * So last value would be -5\\n                 */\\n                expression[expressionEndIndex] = \\'-\\';\\n                addOperators(num, target, i + 1, currentValue - currentDigitsValue, -currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n                /**\\n                 * Multiply operator application \\'*\\'; As this has the highest precedence then + and -, we simply can\\'t apply * on last and current value.\\n                 * Current value become = currentValue - lastValue + last*currentDigitvalue;\\n                 * For example\\n                 * current value = 12 ,\\n                 * last value = 2 ( let say we applied + as 10 + 2 )\\n                 * currendDigitValue = 4\\n                 * so expression become : 10 + 2 * 4\\n                 * if we simply do 12 * 4 = 24 which is wrong as 10 + 2 * 4 = 10 + 8 = 18\\n                 *\\n                 * New value = 10 + 2 * 4 = 18\\n                 * last value = 2*4 = 8\\n                 *\\n                 *\\n                 */\\n                expression[expressionEndIndex] = \\'*\\';\\n                addOperators(num, target, i + 1, currentValue - lastValue + lastValue * currentDigitsValue, lastValue * currentDigitsValue, expression, nextExpressionEndIndex, result);\\n\\n            }\\n\\n\\n        }\\n\\n\\n    }\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 71971,
                "title": "accepted-c-solution",
                "content": "    void addOperators(vector<string>& result, string nums, string t, long long last, long long curVal, int target) {\\n\\t\\tif (nums.length() == 0) {\\n\\t\\t\\tif (curVal == target)\\n\\t\\t\\t\\tresult.push_back(t);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i<=nums.length(); i++) {\\n\\t\\t\\tstring num = nums.substr(0, i);\\n\\t\\t\\tif(num.length() > 1 && num[0] == '0')\\n\\t\\t\\t    return;\\n\\t\\t\\t\\n\\t\\t\\tstring nextNum = nums.substr(i);\\n\\n\\t\\t\\tif (t.length() > 0) {\\n\\t\\t\\t\\taddOperators(result, nextNum, t + \"+\" + num, stoll(num), curVal + stoll(num), target);\\n\\t\\t\\t\\taddOperators(result, nextNum, t + \"-\" + num, -stoll(num), curVal - stoll(num), target);\\n\\t\\t\\t\\taddOperators(result, nextNum, t + \"*\" + num, last * stoll(num), (curVal - last) + (last * stoll(num)), target);\\n\\t\\t\\t}\\n\\t\\t\\telse \\n\\t\\t\\t\\taddOperators(result, nextNum, num, stoll(num), stoll(num), target);\\n\\t\\t}\\n\\t}\\n\\n\\tvector<string> addOperators(string num, int target) {\\n\\t\\tvector<string> result;\\n\\t\\taddOperators(result, num, \"\", 0, 0, target);\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [],
                "code": "    void addOperators(vector<string>& result, string nums, string t, long long last, long long curVal, int target) {\\n\\t\\tif (nums.length() == 0) {\\n\\t\\t\\tif (curVal == target)\\n\\t\\t\\t\\tresult.push_back(t);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i<=nums.length(); i++) {\\n\\t\\t\\tstring num = nums.substr(0, i);\\n\\t\\t\\tif(num.length() > 1 && num[0] == '0')\\n\\t\\t\\t    return;\\n\\t\\t\\t\\n\\t\\t\\tstring nextNum = nums.substr(i);\\n\\n\\t\\t\\tif (t.length() > 0) {\\n\\t\\t\\t\\taddOperators(result, nextNum, t + \"+\" + num, stoll(num), curVal + stoll(num), target);\\n\\t\\t\\t\\taddOperators(result, nextNum, t + \"-\" + num, -stoll(num), curVal - stoll(num), target);\\n\\t\\t\\t\\taddOperators(result, nextNum, t + \"*\" + num, last * stoll(num), (curVal - last) + (last * stoll(num)), target);\\n\\t\\t\\t}\\n\\t\\t\\telse \\n\\t\\t\\t\\taddOperators(result, nextNum, num, stoll(num), stoll(num), target);\\n\\t\\t}\\n\\t}\\n\\n\\tvector<string> addOperators(string num, int target) {\\n\\t\\tvector<string> result;\\n\\t\\taddOperators(result, num, \"\", 0, 0, target);\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 310707,
                "title": "clean-python-dfs-solution",
                "content": "Please see and vote for my solutions for these similar problems\\n[224. Basic Calculator](https://leetcode.com/problems/basic-calculator/discuss/429098/Python3-solution-after-tokenization-(60ms-beat-99.75))\\n[227. Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/discuss/429100/Python3-solution-after-tokenization-(56ms-beat-99.92))\\n[282. Expression Add Operators](https://leetcode.com/problems/expression-add-operators/discuss/310707/Clean-Python-DFS-solution)\\n[772. Basic Calculator III](https://leetcode.com/problems/basic-calculator-iii/discuss/429132/Python3-solution-after-tokenization-(40ms-beat-93.59))\\n\\n```\\n    def addOperators(self, num, target):\\n        def dfs(l, r, expr, cur, last, res):\\n            if l == r:\\n                if cur == target:\\n                    res.append(expr)\\n                return\\n            for i in range(l + 1, r + 1):\\n                if i == l + 1 or (i > l + 1 and num[l] != \"0\"): # prevent \"00\"\\n                    s, x = num[l:i], int(num[l:i])\\n                    if last == None:\\n                        dfs(i, r, s, x, x, res)\\n                    else:\\n                        dfs(i, r, expr+\"+\"+s, cur + x, x, res)\\n                        dfs(i, r, expr+\"-\"+s, cur - x, -x, res)\\n                        dfs(i, r, expr+\"*\"+s, cur-last+last*x, last*x, res)\\n        \\n        res = []\\n        dfs(0, len(num), \\'\\', 0, None, res)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def addOperators(self, num, target):\\n        def dfs(l, r, expr, cur, last, res):\\n            if l == r:\\n                if cur == target:\\n                    res.append(expr)\\n                return\\n            for i in range(l + 1, r + 1):\\n                if i == l + 1 or (i > l + 1 and num[l] != \"0\"): # prevent \"00\"\\n                    s, x = num[l:i], int(num[l:i])\\n                    if last == None:\\n                        dfs(i, r, s, x, x, res)\\n                    else:\\n                        dfs(i, r, expr+\"+\"+s, cur + x, x, res)\\n                        dfs(i, r, expr+\"-\"+s, cur - x, -x, res)\\n                        dfs(i, r, expr+\"*\"+s, cur-last+last*x, last*x, res)\\n        \\n        res = []\\n        dfs(0, len(num), \\'\\', 0, None, res)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 71975,
                "title": "some-thoughts-on-the-algorithm-slr-1-and-optimization-meet-in-the-middle-spatial-data-structure",
                "content": "Share some thoughts of mine.\\n\\nThis algorithm resembles a SLR(1) parser.\\n\\nEach parse tree can be represented by 3 semantic values: add+mul*last.\\nWhile adding a symbol and a digit on the right side, the right spine of the parse tree may change. This process resembles the linear construction algorithm of a Cartesian tree.\\n\\nIn the figure below, the 3 trees on the right are derived from the leftmost.\\n\\n      +         +         +           +\\n     / \\\\       / \\\\       / \\\\         / \\\\\\n    2   *     2   *     2   *       +   6\\n       / \\\\       / \\\\       / \\\\     / \\\\\\n      3   @     3   @     *   6   2   *\\n         / \\\\       / \\\\   / \\\\         / \\\\\\n        4   5     @   6 3   @       3   @\\n                 / \\\\       / \\\\         / \\\\\\n                4   5     4   5       4   5\\n\\nNeglecting the leading zero issue (which can be easily rectified in a recursive parser), the grammar is:\\n\\n    E ::= E \"+\" F | E \"-\" F\\n    F ::= F \"*\" L\\n    L ::= \"0\" | ... | \"9\" | L \"0\" | ... | L \"9\"\\n\\nEach production contributes one node in the right spine of the parse tree, and these productions are hierarchical, that is, a lower-priority symbol cannot occur in the subtree of a higher-priority symbol. Thus the longest distance of the rightmost node to the root is 3. On the other hand, the LR(0) item sets are acyclic and the longest distance is 3.\\n\\n`-` can be seen as `+` if we regard the following digit as the opposite number. Addition and multiplication have units, so we can attach a `+`/`*` node if there is none. Juxtaposition has the highest priority so we can reduce them immediately. Thus 3 leaves and 2 inner nodes can represent a parse tree. That is why there are 3 semantic values in most solutions.\\n\\nState sets of each position can be represented by semantic values to minimize the space consumption.\\nFor each prefix of the enumerated expression in question, the rightmost node of the partial syntax tree represents current symbol and it has no more than 3 ancestors. For each ancestor `v`, we keep the semantic value of its left subtree, thus 3 integers are sufficient to represent the state.\\n\\nThis process can also be applied from right to left, so we can use a meet-in-the-middle algorithm to accelerate. We enumerate symbols in the right half and get many suffixes, each of which contributes 3 semantic values. The sum is indispensable, the first addend is necessary if we take account of multiplication. The first number in the first addend is necessary if we take in to account juxtaposition.\\n\\nIf we combine the partial results from the left side and the right side with `+` or `-`, the enumeration is `O(4^(n/2)*2^(n/2)) = O(2^(1.5n))`, better than brute-force `O(4^n) = O(2^(2n))`.\\nThe combination of `*` is tough, as it takes 2 semantic values (juxtaposition requires 3 which is unsolvable). How can be combine `a+b` from the left with `*c+d` from the right, and let the result `a+b*c+d=result` ? We can handle it with geometry method.\\n'c,d' from the right represents a line: `y=c*x+d`, the point (b, target-a) is on the line iff `target-a=c*b+d <=> a+b*c+d=target`. We turn the problem into: given `O(4^(n/2))` points and `O(4^(n/2))` lines, for each point, find the lines passing through it.\\nOrganize those points into a spatial data structure like quad-tree may be helpful. \\n\\nIf you can read Chinese, see [http://maskray.me/blog/2015-10-16-leetcode-expression-add-operators][1] , where I have written these thoughts in detail . It also gives some examples demonstrating the limit of the length of the right spine. \\n\\n    \\n    typedef long long ll;\\n    class Solution {\\n      string a;\\n      int n, nn, target;\\n      vector<multimap<ll, string>> e_plus, e_minus;\\n      vector<string> res;\\n      void backward(int k, string s, ll add, ll mul, ll last, ll ten) {\\n        if (k < nn) return;\\n        int x = a[k-1]-'0';\\n        ll ten2 = 10*ten, sum = add+mul*last;\\n        backward(k-1, string(1, a[k-1])+s, add, mul, last+ten2*x, ten2);\\n        if (ten == 1 || last >= ten) { // `last` has no leading zero\\n          backward(k-1, string(1, a[k-1])+'*'+s, add, mul*last, x, 1);\\n          backward(k-1, string(1, a[k-1])+'+'+s, sum, 1, x, 1);\\n          backward(k-1, string(1, a[k-1])+'-'+s, add-mul*last, 1, x, 1);\\n          e_plus[k].insert(make_pair(sum, s));\\n          e_minus[k].insert(make_pair(add-mul*last, s));\\n        }\\n      }\\n      void forward(int k, string s, ll add, ll mul, ll last) {\\n        ll sum = add+mul*last;\\n        if (k == n) {\\n          if (sum == target)\\n            res.push_back(s);\\n          return;\\n        }\\n        int x = a[k]-'0';\\n        if (last) // no leading zero\\n          forward(k+1, s+a[k], add, mul, last*10+x);\\n        forward(k+1, s+'*'+a[k], add, mul*last, x);\\n        if (k < nn) {\\n          forward(k+1, s+'+'+a[k], sum, 1, x);\\n          forward(k+1, s+'-'+a[k], sum, -1, x);\\n        } else {\\n          auto rg = e_plus[k].equal_range(target-sum);\\n          for (auto it = rg.first; it != rg.second; ++it)\\n            res.push_back(s+'+'+it->second);\\n          rg = e_minus[k].equal_range(target-sum);\\n          for (auto it = rg.first; it != rg.second; ++it)\\n            res.push_back(s+'-'+it->second);\\n        }\\n      }\\n    public:\\n      vector<string> addOperators(string num, int target) {\\n        a = num;\\n        n = a.size();\\n        if (n) {\\n          nn = n/2; // 0 < nn < n\\n          this->target = target;\\n          e_plus.resize(n);\\n          e_minus.resize(n);\\n          backward(n-1, string(1, a[n-1]), 0, 1, a[n-1]-'0', 1);\\n          forward(1, string(1, a[0]), 0, 1, a[0]-'0');\\n        }\\n        return res;\\n      }\\n    };\\n\\n\\n  [1]: http://maskray.me/blog/2015-10-16-leetcode-expression-add-operators",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n      string a;\\n      int n, nn, target;\\n      vector<multimap<ll, string>> e_plus, e_minus;\\n      vector<string> res;\\n      void backward(int k, string s, ll add, ll mul, ll last, ll ten) {\\n        if (k < nn) return;\\n        int x = a[k-1]-'0';\\n        ll ten2 = 10*ten, sum = add+mul*last;\\n        backward(k-1, string(1, a[k-1])+s, add, mul, last+ten2*x, ten2);\\n        if (ten == 1 || last >= ten) { // `last` has no leading zero\\n          backward(k-1, string(1, a[k-1])+'*'+s, add, mul*last, x, 1);\\n          backward(k-1, string(1, a[k-1])+'+'+s, sum, 1, x, 1);\\n          backward(k-1, string(1, a[k-1])+'-'+s, add-mul*last, 1, x, 1);\\n          e_plus[k].insert(make_pair(sum, s));\\n          e_minus[k].insert(make_pair(add-mul*last, s));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 792406,
                "title": "super-clean-python-backtracking-soution",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        if not num:\\n            return []\\n\\t\\t\\t\\n        num_len = len(num)\\n        res = []\\n        \\n        def dfs(idx, path):\\n            if idx == num_len - 1:\\n                # num_len - 1 to prevent situations like (1+2+) or (1*3*) etc..\\n                path = path + num[idx] \\n                if eval(path) == target:\\n                    res.append(path)\\n                return\\n            \\n            dfs(idx+1, path + num[idx] + \"+\") \\n            dfs(idx+1, path + num[idx] + \"-\")\\n            dfs(idx+1, path + num[idx] + \"*\")\\n            if (path and path[-1] not in [\\'+\\', \\'-\\', \\'*\\'] and num[idx] == \\'0\\') or num[idx] != \\'0\\':\\n                \\n                # Prevent cases such as (2+05) which cannot be evaluated using the eval function\\n                # Cases such as 12+104 should be acceptable, but not 121+04\\n                \\n                dfs(idx+1, path + num[idx])\\n            \\n        dfs(0, \"\")\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        if not num:\\n            return []\\n\\t\\t\\t\\n        num_len = len(num)\\n        res = []\\n        \\n        def dfs(idx, path):\\n            if idx == num_len - 1:\\n                # num_len - 1 to prevent situations like (1+2+) or (1*3*) etc..\\n                path = path + num[idx] \\n                if eval(path) == target:\\n                    res.append(path)\\n                return\\n            \\n            dfs(idx+1, path + num[idx] + \"+\") \\n            dfs(idx+1, path + num[idx] + \"-\")\\n            dfs(idx+1, path + num[idx] + \"*\")\\n            if (path and path[-1] not in [\\'+\\', \\'-\\', \\'*\\'] and num[idx] == \\'0\\') or num[idx] != \\'0\\':\\n                \\n                # Prevent cases such as (2+05) which cannot be evaluated using the eval function\\n                # Cases such as 12+104 should be acceptable, but not 121+04\\n                \\n                dfs(idx+1, path + num[idx])\\n            \\n        dfs(0, \"\")\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 354772,
                "title": "c-concise-dfs",
                "content": "```cpp\\nvector<string> addOperators(string num, int target) {\\n\\tvector<string> res;\\n\\tdfs(num, 0, target, \"\", 0, 0, res);\\n\\treturn res;\\n}\\n\\nvoid dfs(string &num, int start, int target, string path, long prev, long cur, vector<string> &res) {\\n\\tif(start == num.size() && prev + cur == target) res.push_back(path);\\n\\n\\tfor(int i = 1; start + i <= num.size(); i++) {\\n\\t\\tstring s = num.substr(start, i);\\n\\t\\tlong n = stoll(s);\\n\\t\\tif(to_string(n).size() != s.size()) return;\\n\\t\\tif(!start) dfs(num, i, target, s, 0, n, res);\\n\\t\\telse {\\n\\t\\t\\tdfs(num, start + i, target, path + \"+\" + s, prev + cur, n, res);\\n\\t\\t\\tdfs(num, start + i, target, path + \"-\" + s, prev + cur, -n, res);\\n\\t\\t\\tdfs(num, start + i, target, path + \"*\" + s, prev, cur * n, res);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nvector<string> addOperators(string num, int target) {\\n\\tvector<string> res;\\n\\tdfs(num, 0, target, \"\", 0, 0, res);\\n\\treturn res;\\n}\\n\\nvoid dfs(string &num, int start, int target, string path, long prev, long cur, vector<string> &res) {\\n\\tif(start == num.size() && prev + cur == target) res.push_back(path);\\n\\n\\tfor(int i = 1; start + i <= num.size(); i++) {\\n\\t\\tstring s = num.substr(start, i);\\n\\t\\tlong n = stoll(s);\\n\\t\\tif(to_string(n).size() != s.size()) return;\\n\\t\\tif(!start) dfs(num, i, target, s, 0, n, res);\\n\\t\\telse {\\n\\t\\t\\tdfs(num, start + i, target, path + \"+\" + s, prev + cur, n, res);\\n\\t\\t\\tdfs(num, start + i, target, path + \"-\" + s, prev + cur, -n, res);\\n\\t\\t\\tdfs(num, start + i, target, path + \"*\" + s, prev, cur * n, res);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 140390,
                "title": "a-recursive-algorithm-with-detailed-explanation-and-proof-of-correctness",
                "content": "## Remarks\\nI think the algorithm becomes quite easy to understand once you understand the **definition and properties** I\\'ve listed below. Everything else is implementation formalities.\\n\\n## Definition\\nThe following definition and notation will help simplify the proof of correctness later\\n\\n**Eval** : Exp -> N  \\nIt\\'s a function that takes in a string of the form \"23-3\\\\*7+50\". Basically *Exp* resembles the a viable arrangement of operators (** \\\\*, +, - only**) and digits as the problem specifies. It\\'s behaves just like how we would manually calculate *Exp*.\\n\\nExample:  \\n\\n* Eval(\"5\") = 5.  \\n\\n* Eval(\"3+2*7-4\") = 13\\n\\n## Property\\nWe assume the following properties of *Eval*, and we will use them later to verify the correctness of our algorithm. I think they are all very intuitive, but I don\\'t know how to formally prove them.  \\n\\nA and B will be arbitrary *Exp*, *+* will append the two adjacent strings.\\n\\n### P1\\n    Eval(A + \\'+\\' + B) = Eval(A) + Eval(B)\\nExample:  \\nEval(\"4\\\\*3+3-2\") = Eval(\"4\\\\*3\") + Eval(\"3-2\")\\n\\n### P2\\n    Eval(A + \\'-\\' + B) = Eval(A) + Eval(\\'-1*\\' + B)\\nExample:  \\nEval(\"4\\\\*3-3-2\") = Eval(\"4\\\\*3\") + Eval(\"-1*3-2\")\\n\\n### P3\\n    Eval(A + \\'*\\' + B + \\'*\\' + C) = Eval(str(Eval(A + \\'*\\' + B)) + \\'*\\' + C)\\n\\nNote: *str* turns a number into its string representation.\\nExample:  \\nEval(\\'4\\\\*3\\\\*3+2\\') = Eval(str(Eval(4\\\\*3)) + \\'\\\\*\\' + \\'3+2\\') = Eval(\\'12\\\\*3+2\\')\\n\\n\\n### P4\\n    Eval(\\'1*\\' + A) = Eval(A)\\n\\nNote: This can be easily derived by case analysis (on A) and the previous three properties.  \\nExample:  \\nEval(\\'5+7\\') = Eval(\\'1\\\\*5+7\\')\\n\\n\\n## Algorithm\\nConsider a slightly modified version of this problem:  \\nGiven a number X, and a list of numbers lon = [N1, N2, ..., Nk], and a target number  \\n\\n**F(X, lon, target)** returns the combinations of \"X \\\\* N1N2N3\" that yields target, where the rules for inserting operator between digits is the same as problem described above  \\n\\nThe only difference being there is a multiplication operator inserted after X already.  \\n\\nOur **original problem** asks for all possible arrangements of input *lon* such that each arrangement *E* satisfies **Eval(E) = target**. Well, by property 4, that is just a special case of the more generalized **F**, namely, **F(1, lon, target)**.\\n\\nWe will show how to recursively apply **F** to compute the desired output. We do this by enumerating all cases based on the input.  \\n**Note:** We denote lon as [N1, N2, ..., Nk]. Thus len(lon) = k\\n\\n\\n### Base case\\nWhen *k == 1*, by definition of **F**, if *X \\\\* N1 == target*, this arrangement is qualified, and we return its string representation: *str(X) + \\'\\\\*\\' + str(N1)*  \\n\\n### Recursive cases\\nRemember we can either insert one of the three operators, or not insert anything. Thus we have 4 cases:\\n\\n### Insert nothing\\nWe keep N1 and N2 together in this case, but this only works if N1 is not \\'0\\', since something like \\'07\\' will not be a valid NumberString.  \\nAssume that, and by definition of **F**, we can recursively compute the output as \\n\\n**F(X, [N1 \\\\* 10 + N2, N3, ..., Nk], target)**\\n\\n### Insert +\\nThe final arrangement will look like **\\'X \\\\* N1 + E\\'**, where *E* is whatever arrangement the rest of the lon ([N2, N3, ..., Nk]) came out to be.  \\nThus, we want this string to evaluate to *target*, meaning that,  \\n**Eval(\\'X * N1\\' + \\'+\\' +  E) = target**. By property 1 we have:  \\n**target = Eval(\\'X \\\\* N1\\') + Eval(E) = X \\\\* N1 + Eval(E)**  \\nIn other words, we want **Eval(E) = target - X \\\\* N1**  \\nWhat are the possible arrangements for that? That is precisely a subproblem to the original problem, thus the answer for that is \\n\\n**F(1, [N2, N3, ..., Nk], target - X \\\\* N1**\\n\\n### Insert -\\nThis is similar to the case with \\'+\\' above, because we can use property 2 to transform \\'-\\'.  \\nWe want **Eval(\\'X * N1\\' + \\'-\\' +  E) = target**. By property 2 we have:\\n**target = Eval(\\'X \\\\* N1\\') + Eval(\\'-1\\\\*\\' + E) = X \\\\* N1 + Eval(\\'-1\\\\*\\' + E)**  \\nIn other words, we want **Eval(\\'-1\\\\*\\' + E) = target - X \\\\* N1**  \\nTo solve this subproblem, we need to utilize the definition for **F**, which suggests that the answer is \\n\\n**F(-1, [N2, N3, ..., Nk], target - X \\\\* N1**\\n\\n\\n### Insert *\\nThis follows the same pattern as the above cases.  \\nWe want **Eval(\\'X \\\\* N1\\' + \\'\\\\*\\' +  E) = target**. By property 3 we have:  \\n**target = Eval(str(Eval(\\'X \\\\* N1\\')) + \\'\\\\*\\' + E)**  \\nBy definition of **F**, we can derived the answer easily:\\n\\n**F(X \\\\* N1, [N2, N3, ..., Nk], target**\\n\\n\\n## Code\\nThe following is my implementation of the algorithm in Python3. It\\'s exactly like what I described above. \\n\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n\\n        lon = list(map(int, num))\\n        answer = []\\n\\n        # F is exactly like what we defined above, except it has\\n        # an extra argument to keep track of the partial string arrangement (including \\'X*\\')\\n        # already determined as it recurs down the search\\n        # Also lon is represented as lon[start:]\\n        # Viable arrangement will be appened into @answer in string form\\n        def F(x, start, targ, prevArrangement):\\n\\t\\t\\t\\t\\n            # notice that start increments on every recursive call, so termination is ensured. \\n            if start == len(lon) - 1:\\n                if x * lon[start] == targ:\\n                    answer.append(prevArrangement + str(lon[start]))\\n                return\\n\\n            #  case 1 (no operator insertion)\\n            # we have to modify the value of lon[start + 1]\\n            # so we restore its value after the function returns\\n            if lon[start] != 0:\\n                lon[start + 1] += lon[start] * 10\\n                F(x, start + 1, targ, prevArrangement)\\n                lon[start + 1] -= lon[start] * 10\\n\\n            # case 2, insert \\'+\\'\\n            F(1, start + 1, targ - x*lon[start], prevArrangement + str(lon[start]) + \\'+\\')\\n\\n            # case 3, insert \\'-\\'\\n            F(-1, start + 1, targ - x*lon[start], prevArrangement + str(lon[start]) + \\'-\\')\\n\\n            # case 4, insert \\'*\\'\\n            F(x * lon[start], start + 1, targ, prevArrangement + str(lon[start]) + \\'*\\')\\n\\n\\n        # since we don\\'t want to keep the \"1*\" in the front, we initialize\\n        # prevArrangement to be empty string. \\n        F(1, 0, target, \"\")\\n        return answer\\n\\n\\n",
                "solutionTags": [],
                "code": "## Remarks\\nI think the algorithm becomes quite easy to understand once you understand the **definition and properties** I\\'ve listed below. Everything else is implementation formalities.\\n\\n## Definition\\nThe following definition and notation will help simplify the proof of correctness later\\n\\n**Eval** : Exp -> N  \\nIt\\'s a function that takes in a string of the form \"23-3\\\\*7+50\". Basically *Exp* resembles the a viable arrangement of operators (** \\\\*, +, - only**) and digits as the problem specifies. It\\'s behaves just like how we would manually calculate *Exp*.\\n\\nExample:  \\n\\n* Eval(\"5\") = 5.  \\n\\n* Eval(\"3+2*7-4\") = 13\\n\\n## Property\\nWe assume the following properties of *Eval*, and we will use them later to verify the correctness of our algorithm. I think they are all very intuitive, but I don\\'t know how to formally prove them.  \\n\\nA and B will be arbitrary *Exp*, *+* will append the two adjacent strings.\\n\\n### P1\\n    Eval(A + \\'+\\' + B) = Eval(A) + Eval(B)\\nExample:  \\nEval(\"4\\\\*3+3-2\") = Eval(\"4\\\\*3\") + Eval(\"3-2\")\\n\\n### P2\\n    Eval(A + \\'-\\' + B) = Eval(A) + Eval(\\'-1*\\' + B)\\nExample:  \\nEval(\"4\\\\*3-3-2\") = Eval(\"4\\\\*3\") + Eval(\"-1*3-2\")\\n\\n### P3\\n    Eval(A + \\'*\\' + B + \\'*\\' + C) = Eval(str(Eval(A + \\'*\\' + B)) + \\'*\\' + C)\\n\\nNote: *str* turns a number into its string representation.\\nExample:  \\nEval(\\'4\\\\*3\\\\*3+2\\') = Eval(str(Eval(4\\\\*3)) + \\'\\\\*\\' + \\'3+2\\') = Eval(\\'12\\\\*3+2\\')\\n\\n\\n### P4\\n    Eval(\\'1*\\' + A) = Eval(A)\\n\\nNote: This can be easily derived by case analysis (on A) and the previous three properties.  \\nExample:  \\nEval(\\'5+7\\') = Eval(\\'1\\\\*5+7\\')\\n\\n\\n## Algorithm\\nConsider a slightly modified version of this problem:  \\nGiven a number X, and a list of numbers lon = [N1, N2, ..., Nk], and a target number  \\n\\n**F(X, lon, target)** returns the combinations of \"X \\\\* N1N2N3\" that yields target, where the rules for inserting operator between digits is the same as problem described above  \\n\\nThe only difference being there is a multiplication operator inserted after X already.  \\n\\nOur **original problem** asks for all possible arrangements of input *lon* such that each arrangement *E* satisfies **Eval(E) = target**. Well, by property 4, that is just a special case of the more generalized **F**, namely, **F(1, lon, target)**.\\n\\nWe will show how to recursively apply **F** to compute the desired output. We do this by enumerating all cases based on the input.  \\n**Note:** We denote lon as [N1, N2, ..., Nk]. Thus len(lon) = k\\n\\n\\n### Base case\\nWhen *k == 1*, by definition of **F**, if *X \\\\* N1 == target*, this arrangement is qualified, and we return its string representation: *str(X) + \\'\\\\*\\' + str(N1)*  \\n\\n### Recursive cases\\nRemember we can either insert one of the three operators, or not insert anything. Thus we have 4 cases:\\n\\n### Insert nothing\\nWe keep N1 and N2 together in this case, but this only works if N1 is not \\'0\\', since something like \\'07\\' will not be a valid NumberString.  \\nAssume that, and by definition of **F**, we can recursively compute the output as \\n\\n**F(X, [N1 \\\\* 10 + N2, N3, ..., Nk], target)**\\n\\n### Insert +\\nThe final arrangement will look like **\\'X \\\\* N1 + E\\'**, where *E* is whatever arrangement the rest of the lon ([N2, N3, ..., Nk]) came out to be.  \\nThus, we want this string to evaluate to *target*, meaning that,  \\n**Eval(\\'X * N1\\' + \\'+\\' +  E) = target**. By property 1 we have:  \\n**target = Eval(\\'X \\\\* N1\\') + Eval(E) = X \\\\* N1 + Eval(E)**  \\nIn other words, we want **Eval(E) = target - X \\\\* N1**  \\nWhat are the possible arrangements for that? That is precisely a subproblem to the original problem, thus the answer for that is \\n\\n**F(1, [N2, N3, ..., Nk], target - X \\\\* N1**\\n\\n### Insert -\\nThis is similar to the case with \\'+\\' above, because we can use property 2 to transform \\'-\\'.  \\nWe want **Eval(\\'X * N1\\' + \\'-\\' +  E) = target**. By property 2 we have:\\n**target = Eval(\\'X \\\\* N1\\') + Eval(\\'-1\\\\*\\' + E) = X \\\\* N1 + Eval(\\'-1\\\\*\\' + E)**  \\nIn other words, we want **Eval(\\'-1\\\\*\\' + E) = target - X \\\\* N1**  \\nTo solve this subproblem, we need to utilize the definition for **F**, which suggests that the answer is \\n\\n**F(-1, [N2, N3, ..., Nk], target - X \\\\* N1**\\n\\n\\n### Insert *\\nThis follows the same pattern as the above cases.  \\nWe want **Eval(\\'X \\\\* N1\\' + \\'\\\\*\\' +  E) = target**. By property 3 we have:  \\n**target = Eval(str(Eval(\\'X \\\\* N1\\')) + \\'\\\\*\\' + E)**  \\nBy definition of **F**, we can derived the answer easily:\\n\\n**F(X \\\\* N1, [N2, N3, ..., Nk], target**\\n\\n\\n## Code\\nThe following is my implementation of the algorithm in Python3. It\\'s exactly like what I described above. \\n\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n\\n        lon = list(map(int, num))\\n        answer = []\\n\\n        # F is exactly like what we defined above, except it has\\n        # an extra argument to keep track of the partial string arrangement (including \\'X*\\')\\n        # already determined as it recurs down the search\\n        # Also lon is represented as lon[start:]\\n        # Viable arrangement will be appened into @answer in string form\\n        def F(x, start, targ, prevArrangement):\\n\\t\\t\\t\\t\\n            # notice that start increments on every recursive call, so termination is ensured. \\n            if start == len(lon) - 1:\\n                if x * lon[start] == targ:\\n                    answer.append(prevArrangement + str(lon[start]))\\n                return\\n\\n            #  case 1 (no operator insertion)\\n            # we have to modify the value of lon[start + 1]\\n            # so we restore its value after the function returns\\n            if lon[start] != 0:\\n                lon[start + 1] += lon[start] * 10\\n                F(x, start + 1, targ, prevArrangement)\\n                lon[start + 1] -= lon[start] * 10\\n\\n            # case 2, insert \\'+\\'\\n            F(1, start + 1, targ - x*lon[start], prevArrangement + str(lon[start]) + \\'+\\')\\n\\n            # case 3, insert \\'-\\'\\n            F(-1, start + 1, targ - x*lon[start], prevArrangement + str(lon[start]) + \\'-\\')\\n\\n            # case 4, insert \\'*\\'\\n            F(x * lon[start], start + 1, targ, prevArrangement + str(lon[start]) + \\'*\\')\\n\\n\\n        # since we don\\'t want to keep the \"1*\" in the front, we initialize\\n        # prevArrangement to be empty string. \\n        F(1, 0, target, \"\")\\n        return answer\\n\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1068461,
                "title": "javascript-simple-backtracking-solution",
                "content": "```javascript\\nvar addOperators = function(num, target) {\\n    const output = []\\n    \\n    function permute(str, arr, total, prev) {\\n        if(!str.length && total === target) output.push(arr.join(\\'\\'));\\n        \\n        let len = str.length;\\n        if(str[0] === \\'0\\') len = 1;\\n\\n        for(let i = 1; i <= len; i++) {\\n            const curr = +str.slice(0, i);\\n            const rest = str.slice(i);\\n            \\n            if(!arr.length) permute(rest, [curr], curr, curr);\\n            else {\\n                permute(rest, [...arr, \\'+\\', curr], total+curr, curr);\\n                permute(rest, [...arr, \\'-\\', curr], total-curr, 0-curr);\\n                const prod = prev * curr;\\n                permute(rest, [...arr, \\'*\\', curr], total-prev+prod, prod);\\n            }\\n        }\\n    }\\n    permute(num, [], 0, 0);\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```javascript\\nvar addOperators = function(num, target) {\\n    const output = []\\n    \\n    function permute(str, arr, total, prev) {\\n        if(!str.length && total === target) output.push(arr.join(\\'\\'));\\n        \\n        let len = str.length;\\n        if(str[0] === \\'0\\') len = 1;\\n\\n        for(let i = 1; i <= len; i++) {\\n            const curr = +str.slice(0, i);\\n            const rest = str.slice(i);\\n            \\n            if(!arr.length) permute(rest, [curr], curr, curr);\\n            else {\\n                permute(rest, [...arr, \\'+\\', curr], total+curr, curr);\\n                permute(rest, [...arr, \\'-\\', curr], total-curr, 0-curr);\\n                const prod = prev * curr;\\n                permute(rest, [...arr, \\'*\\', curr], total-prev+prod, prod);\\n            }\\n        }\\n    }\\n    permute(num, [], 0, 0);\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1470556,
                "title": "c-backtracking-beginner-explained-easy-to-understand-clean",
                "content": "# ***Approach***\\n```\\n    This problem is a pretty good backtracking problem\\n    You can easily apply dfs to find all possible expressions , but the main problem is in evaluating that expression simultaneously!!!\\n    \\n    Points to remember:\\n        (1) First number of expression is operatorless[meaning no operator is before it]\\n        (2) string path stores : expression for a branch\\n        (3) res : it stores the result calculated so far!!!\\n        (4) prev : stores the last number of expression\\n        (5) sub_string : holds number for [index to i] , take example , index = 0 , i = 2 , num = \"1234\" then  sub_string = \"123\"\\n                take example\\n                    2 + 3 * 3\\n                    if path = \"2+3\" , prev = 3\\n                take another example\\n                    2 + 3 * 4 * 2\\n                    if path = \"2+3*4\" , prev = 12\\n                NOTE : when we pick * as operator we pick prev = prev * number\\n                \\n----------------------------------------------------------------------------------------------------------------------\\n\\n    Logic Simplified:\\n        if(index == num.size() and res is target)\\n            push path to expression and then return\\n            \\n        run loop from[index to end]\\n        {\\n            form sub_string , simultaneously form number\\n            \\n            if(a number with leading 0 is formed as sub_string)\\n                break;\\n            \\n            if(we are forming first number of expression)\\n                pick no operator and apply dfs\\n            else\\n            {\\n                pick + operator and apply dfs , prev = number\\n                pick - operator and apply dfs , prev = -number\\n                pick * operator and apply dfs , prev = prev * number [while evaluating res we first subtract prev_val because it is attached or connected to next val]\\n            }\\n        }\\n----------------------------------------------------------------------------------------------------------------------        \\n```\\n# ***Code***\\n```\\nclass Solution {\\npublic:\\n    vector<string> expressions;\\n    vector<string> addOperators(string num, int target) {\\n        dfs(num , target , 0 , \"\" , 0 , 0);\\n        return expressions;\\n    }\\n    void dfs(string &num , int target , int index , string path , long int res , long int prev)\\n    {\\n        if(index == num.size() and res == target)\\n        {\\n            expressions.push_back(path);\\n            return;\\n        }\\n        \\n        long int number = 0;\\n        string sub_string = \"\";\\n        \\n        for(int i = index ; i < num.size() ; ++i)\\n        {\\n            sub_string += num[i];\\n            number = (number * 10) + num[i] - \\'0\\';\\n            \\n            if(sub_string.size() > 1 and sub_string[0] == \\'0\\') // skipping numbers with leading 0\\'s\\n                break;\\n            \\n            if(index == 0) // first number of expression is picked without operator\\n            {\\n                dfs(num , target , i + 1 , sub_string , number, number);\\n            }\\n            else\\n            {\\n                // (1) + operation inserted\\n                dfs(num , target , i + 1 , path  + \"+\" + sub_string , res  + number , number);\\n                    \\n                // (2) - operation inserted\\n                dfs(num , target , i + 1 , path + \"-\" + sub_string , res  - number , -number);\\n                \\n                // (3) * operation inserted\\n                dfs(num , target , i + 1 , path + \"*\" + sub_string , (res - prev)  + (prev * number) , prev * number);\\n            }\\n        }\\n            \\n    }\\n    \\n};\\n```\\n# ***If you liked the solution , Please Upvote :)***",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n    This problem is a pretty good backtracking problem\\n    You can easily apply dfs to find all possible expressions , but the main problem is in evaluating that expression simultaneously!!!\\n    \\n    Points to remember:\\n        (1) First number of expression is operatorless[meaning no operator is before it]\\n        (2) string path stores : expression for a branch\\n        (3) res : it stores the result calculated so far!!!\\n        (4) prev : stores the last number of expression\\n        (5) sub_string : holds number for [index to i] , take example , index = 0 , i = 2 , num = \"1234\" then  sub_string = \"123\"\\n                take example\\n                    2 + 3 * 3\\n                    if path = \"2+3\" , prev = 3\\n                take another example\\n                    2 + 3 * 4 * 2\\n                    if path = \"2+3*4\" , prev = 12\\n                NOTE : when we pick * as operator we pick prev = prev * number\\n                \\n----------------------------------------------------------------------------------------------------------------------\\n\\n    Logic Simplified:\\n        if(index == num.size() and res is target)\\n            push path to expression and then return\\n            \\n        run loop from[index to end]\\n        {\\n            form sub_string , simultaneously form number\\n            \\n            if(a number with leading 0 is formed as sub_string)\\n                break;\\n            \\n            if(we are forming first number of expression)\\n                pick no operator and apply dfs\\n            else\\n            {\\n                pick + operator and apply dfs , prev = number\\n                pick - operator and apply dfs , prev = -number\\n                pick * operator and apply dfs , prev = prev * number [while evaluating res we first subtract prev_val because it is attached or connected to next val]\\n            }\\n        }\\n----------------------------------------------------------------------------------------------------------------------        \\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> expressions;\\n    vector<string> addOperators(string num, int target) {\\n        dfs(num , target , 0 , \"\" , 0 , 0);\\n        return expressions;\\n    }\\n    void dfs(string &num , int target , int index , string path , long int res , long int prev)\\n    {\\n        if(index == num.size() and res == target)\\n        {\\n            expressions.push_back(path);\\n            return;\\n        }\\n        \\n        long int number = 0;\\n        string sub_string = \"\";\\n        \\n        for(int i = index ; i < num.size() ; ++i)\\n        {\\n            sub_string += num[i];\\n            number = (number * 10) + num[i] - \\'0\\';\\n            \\n            if(sub_string.size() > 1 and sub_string[0] == \\'0\\') // skipping numbers with leading 0\\'s\\n                break;\\n            \\n            if(index == 0) // first number of expression is picked without operator\\n            {\\n                dfs(num , target , i + 1 , sub_string , number, number);\\n            }\\n            else\\n            {\\n                // (1) + operation inserted\\n                dfs(num , target , i + 1 , path  + \"+\" + sub_string , res  + number , number);\\n                    \\n                // (2) - operation inserted\\n                dfs(num , target , i + 1 , path + \"-\" + sub_string , res  - number , -number);\\n                \\n                // (3) * operation inserted\\n                dfs(num , target , i + 1 , path + \"*\" + sub_string , (res - prev)  + (prev * number) , prev * number);\\n            }\\n        }\\n            \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71967,
                "title": "elegant-java-solution",
                "content": "    public class Solution {\\n    List<String> result =new ArrayList<String>();\\n    public List<String> addOperators(String num, int target) {\\n        for(int i=1;i<=num.length();i++){\\n            if(i>=2 && num.charAt(0)=='0') continue;\\n            bfs(num.substring(i),num.substring(0,i),target,0,Long.parseLong(num.substring(0,i)),true);\\n        }\\n        return result;\\n    }\\n    \\n    public void bfs(String s,String trace,int target,long pre,long current,boolean sign){\\n        long sum = sign? pre+current:pre-current;\\n        if(s.length()==0){\\n            if(sum==(long) target) result.add(trace);\\n            return;\\n        }\\n        for(int i=1;i<=s.length();i++){\\n            if(i>=2 && s.charAt(0)=='0') continue;\\n            int number = Integer.parseInt(s.substring(0,i));\\n            bfs(s.substring(i),trace+\"+\"+number,target,sum,number,true);\\n            bfs(s.substring(i),trace+\"-\"+number,target,sum,number,false);\\n            bfs(s.substring(i),trace+\"*\"+number,target,pre,current*number,sign);\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    List<String> result =new ArrayList<String>();\\n    public List<String> addOperators(String num, int target) {\\n        for(int i=1;i<=num.length();i++){\\n            if(i>=2 && num.charAt(0)=='0') continue;\\n            bfs(num.substring(i),num.substring(0,i),target,0,Long.parseLong(num.substring(0,i)),true);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 71947,
                "title": "16ms-c-solution",
                "content": "The idea is to cut a value from the left of the string and then for each of operations '+', '-', '*' repeat the procedure recursively. The trick is to pass the sum of all left summands and the product of rightmost factors. This allows to calculate the left sum and the right product on the next step depending on the next chosen operation.\\n\\n    class Solution {\\n        typedef long long int i64;\\n        \\n        string myS;\\n        const char* s;\\n        i64 target;\\n        int slen;\\n        \\n    public:\\n      \\n        vector<string> addOperators(const string& num, int t) {\\n            myS = num;\\n            slen = myS.size();\\n            s = myS.c_str();\\n            target = t;\\n            \\n            vector<string> res;\\n            char buf[slen*2+1];\\n            \\n            int lmax = (s[0] == '0' ? 1 : slen);\\n            i64 v = 0;\\n            for (int l=1; l<=lmax; ++l) {\\n                int c = s[l-1];\\n                v = v*10 + (c-'0');   // add next digit\\n                buf[l-1] = c;  // only need to append the last digit\\n                processTail(0, v, l, buf, l, res);\\n            }\\n            return res;\\n        }\\n    \\n        void processTail(i64 prevsum, i64 last, int pos, char* buf, int bufpos, vector<string>& res) {\\n            if (pos == slen) {\\n                // end of string\\n                // check the value and save\\n                if (prevsum+last == target) {\\n                    buf[bufpos] = 0;\\n                    res.push_back(buf);\\n                }\\n                return;\\n            }\\n            \\n            int lmax = (s[pos] == '0' ? 1 : slen-pos); // don't allow multichar intergers starting from a '0'\\n            i64 v = 0;\\n            for (int l=1; l<=lmax; ++l) {\\n                int c = s[pos+l-1];\\n                v = v*10 + (c-'0');     // add next digit to v\\n    \\n                buf[bufpos] = '+';\\n                buf[bufpos+l] = c;      // only need to append the last digit of v\\n                processTail(prevsum+last, v, pos+l, buf, bufpos+l+1, res);\\n    \\n                buf[bufpos] = '-'; \\n                processTail(prevsum+last, -v, pos+l, buf, bufpos+l+1, res);\\n    \\n                buf[bufpos] = '*'; \\n                processTail(prevsum, last*v, pos+l, buf, bufpos+l+1, res);\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        typedef long long int i64;\\n        \\n        string myS;\\n        const char* s;\\n        i64 target;\\n        int slen;\\n        \\n    public:\\n      \\n        vector<string> addOperators(const string& num, int t) {\\n            myS = num;\\n            slen = myS.size();\\n            s = myS.c_str();\\n            target = t;\\n            \\n            vector<string> res;\\n            char buf[slen*2+1];\\n            \\n            int lmax = (s[0] == '0' ? 1 : slen);\\n            i64 v = 0;\\n            for (int l=1; l<=lmax; ++l) {\\n                int c = s[l-1];\\n                v = v*10 + (c-'0');   // add next digit\\n                buf[l-1] = c;  // only need to append the last digit\\n                processTail(0, v, l, buf, l, res);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3742718,
                "title": "c-hinglish-easy-explanation-backtracking-interview-prep",
                "content": "# Approach\\n- Explained in the code\\n\\n# Code\\n```\\nclass Solution\\n{\\n   \\t1. Numbers ke beech mein operators dalna hain +,-,*.\\n   \\t2. Teeno ko baari baari se try karna hain jisse target achieve ho to backtracking use karenge hi.\\n   \\t3. Ab isme dhyan rakhna hain ki koi \\n   \\t- leading 0 na ho \\n   \\t- BODMAS rules are followed\\n   \\t4. Subtraction and Addition rules to aasani se follow ho jayenge\\n   \\t5. Multiplication mein hame previous operation ko hatana padega jaise agar prev operation sum that to vo operation hatake multiplication dalenge.\\n   \\t6. First index pe hain to aage bad jayenge \\n   \\t7. Recursive Calls mein we will keep track of index in num,sumPath,sum,prev.\\n\\n//==============================================================================================================================\\n    public:\\n        void recursiveCall(int i, string sumPath, long sum, long prev, string num, int target, vector<string> &result)\\n        {\\n           \\t// If we have reached the end of \\'num\\'\\n            if (i == num.size())\\n            {\\n                if (sum == target)\\n                {\\n                   \\t// If the target is achieved, add the path to the result\\n                    result.push_back(sumPath);\\n                }\\n                return;\\n            }\\n\\n            for (int j = i; j < num.size(); j++)\\n            {\\n                if (j > i && num[i] == \\'0\\')\\n                {\\n                   \\t// Avoid leading zeros in the number\\n                    break;\\n                }\\n\\n                long number = stol(num.substr(i, j - i + 1));\\n               \\t// Convert the substring to a long number\\n                string tempPath = num.substr(i, j - i + 1);\\n               \\t// Temporary substring representing the path we have traversed so far\\n\\n                if (i == 0)\\n                {\\n                   \\t// If we are on the first index of \\'num\\', start a new path\\n                    recursiveCall(j + 1, tempPath, number, number, num, target, result);\\n                }\\n                else\\n                {\\n                   \\t// Addition operation\\n                    recursiveCall(j + 1, sumPath + \\'+\\' + tempPath, sum + number, number, num, target, result);\\n                   \\t// Subtraction operation\\n                    recursiveCall(j + 1, sumPath + \\'-\\' + tempPath, sum - number, -number, num, target, result);\\n                   \\t// Multiplication operation\\n                    recursiveCall(j + 1, sumPath + \\'*\\' + tempPath, sum - prev + (prev *number), prev *number, num, target, result);\\n                   \\t// While doing the multiplication operation, we remove the previous operation and update it with the multiplication operation\\n                   \\t// This is done to follow the BODMAS rules for correct precedence\\n                }\\n            }\\n        }\\n\\n    vector<string> addOperators(string num, int target)\\n    {\\n        vector<string> result;\\n        recursiveCall(0, \"\", 0, 0, num, target, result);\\n    //recursiveCall(CurrentIndex,Path,sum,prev,num,target,result)\\n        return result;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $O(3^n)$ where `n is num size` and `3 are our operations` on each char of num.\\n\\n- Space complexity: $O(n^3)$ Worst Case Scenario where `n is num size`.\\n\\nIf you *like* \\uD83D\\uDC4D this solution do *upvote* \\u2B06\\uFE0F and if there is any *improvement or suggestion* do mention it in the *comment* section \\uD83D\\uDE0A.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/1b604300-df68-46aa-a267-71f38463bb89_1684820402.7869222.jpeg\" width=\\'350\\' alt=\"Upvote Image\">\\n</p>",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution\\n{\\n   \\t1. Numbers ke beech mein operators dalna hain +,-,*.\\n   \\t2. Teeno ko baari baari se try karna hain jisse target achieve ho to backtracking use karenge hi.\\n   \\t3. Ab isme dhyan rakhna hain ki koi \\n   \\t- leading 0 na ho \\n   \\t- BODMAS rules are followed\\n   \\t4. Subtraction and Addition rules to aasani se follow ho jayenge\\n   \\t5. Multiplication mein hame previous operation ko hatana padega jaise agar prev operation sum that to vo operation hatake multiplication dalenge.\\n   \\t6. First index pe hain to aage bad jayenge \\n   \\t7. Recursive Calls mein we will keep track of index in num,sumPath,sum,prev.\\n\\n//==============================================================================================================================\\n    public:\\n        void recursiveCall(int i, string sumPath, long sum, long prev, string num, int target, vector<string> &result)\\n        {\\n           \\t// If we have reached the end of \\'num\\'\\n            if (i == num.size())\\n            {\\n                if (sum == target)\\n                {\\n                   \\t// If the target is achieved, add the path to the result\\n                    result.push_back(sumPath);\\n                }\\n                return;\\n            }\\n\\n            for (int j = i; j < num.size(); j++)\\n            {\\n                if (j > i && num[i] == \\'0\\')\\n                {\\n                   \\t// Avoid leading zeros in the number\\n                    break;\\n                }\\n\\n                long number = stol(num.substr(i, j - i + 1));\\n               \\t// Convert the substring to a long number\\n                string tempPath = num.substr(i, j - i + 1);\\n               \\t// Temporary substring representing the path we have traversed so far\\n\\n                if (i == 0)\\n                {\\n                   \\t// If we are on the first index of \\'num\\', start a new path\\n                    recursiveCall(j + 1, tempPath, number, number, num, target, result);\\n                }\\n                else\\n                {\\n                   \\t// Addition operation\\n                    recursiveCall(j + 1, sumPath + \\'+\\' + tempPath, sum + number, number, num, target, result);\\n                   \\t// Subtraction operation\\n                    recursiveCall(j + 1, sumPath + \\'-\\' + tempPath, sum - number, -number, num, target, result);\\n                   \\t// Multiplication operation\\n                    recursiveCall(j + 1, sumPath + \\'*\\' + tempPath, sum - prev + (prev *number), prev *number, num, target, result);\\n                   \\t// While doing the multiplication operation, we remove the previous operation and update it with the multiplication operation\\n                   \\t// This is done to follow the BODMAS rules for correct precedence\\n                }\\n            }\\n        }\\n\\n    vector<string> addOperators(string num, int target)\\n    {\\n        vector<string> result;\\n        recursiveCall(0, \"\", 0, 0, num, target, result);\\n    //recursiveCall(CurrentIndex,Path,sum,prev,num,target,result)\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447209,
                "title": "clean-python3-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        L = len(num)\\n        ans = set()\\n        \\n        def backtrack(i, total, last, expr):\\n            if i == L:\\n                if total == target:\\n                    ans.add(expr)\\n                return\\n            \\n            for j in range(i, L):\\n                n = int(num[i:j+1])\\n                if i == 0:\\n                    backtrack(j+1, n, n, str(n))\\n                else:\\n                    backtrack(j+1, total + n, n, expr + \\'+\\' + str(n))\\n                    backtrack(j+1, total - n, -n, expr + \\'-\\' + str(n))\\n                    backtrack(j+1, total - last + last * n, last * n, expr + \\'*\\' + str(n))\\n                if n == 0:\\n                    break\\n                    \\n        backtrack(0, 0, 0, \\'\\')\\n        return list(ans)\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        L = len(num)\\n        ans = set()\\n        \\n        def backtrack(i, total, last, expr):\\n            if i == L:\\n                if total == target:\\n                    ans.add(expr)\\n                return\\n            \\n            for j in range(i, L):\\n                n = int(num[i:j+1])\\n                if i == 0:\\n                    backtrack(j+1, n, n, str(n))\\n                else:\\n                    backtrack(j+1, total + n, n, expr + \\'+\\' + str(n))\\n                    backtrack(j+1, total - n, -n, expr + \\'-\\' + str(n))\\n                    backtrack(j+1, total - last + last * n, last * n, expr + \\'*\\' + str(n))\\n                if n == 0:\\n                    break\\n                    \\n        backtrack(0, 0, 0, \\'\\')\\n        return list(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470847,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void dfs(int i, string path, long resSoFar, long prevNum, const string &s, const int &target){\\n        if(i==s.size() and resSoFar==target){\\n            ans.push_back(path);\\n            return;\\n        }\\n        \\n        string curNumStr = \"\";\\n        long curNum=0;\\n        for(int j=i;j<s.size();++j){\\n            if(j>i and s[i]==\\'0\\') break; //leading zero not allowed\\n            //eg:105 --> 1*05=5(but 05 is now allowed)\\n            curNumStr.push_back(s[j]);\\n            curNum = (curNum*10)+(s[j]-\\'0\\');\\n            if(i==0){\\n                dfs(j+1, path+curNumStr, curNum, curNum, s, target);\\n            }else{\\n                dfs(j+1, path+\"+\"+curNumStr, resSoFar+curNum, curNum, s, target);\\n                dfs(j+1, path+\"-\"+curNumStr, resSoFar-curNum, -curNum, s, target);\\n                dfs(j+1, path+\"*\"+curNumStr, resSoFar-prevNum+(curNum*prevNum), prevNum*curNum, s, target);\\n            }\\n        }\\n        return;\\n    }\\n    \\n    vector<string> addOperators(string &num, int target) {\\n        dfs(0,\"\",0,0,num,target);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void dfs(int i, string path, long resSoFar, long prevNum, const string &s, const int &target){\\n        if(i==s.size() and resSoFar==target){\\n            ans.push_back(path);\\n            return;\\n        }\\n        \\n        string curNumStr = \"\";\\n        long curNum=0;\\n        for(int j=i;j<s.size();++j){\\n            if(j>i and s[i]==\\'0\\') break; //leading zero not allowed\\n            //eg:105 --> 1*05=5(but 05 is now allowed)\\n            curNumStr.push_back(s[j]);\\n            curNum = (curNum*10)+(s[j]-\\'0\\');\\n            if(i==0){\\n                dfs(j+1, path+curNumStr, curNum, curNum, s, target);\\n            }else{\\n                dfs(j+1, path+\"+\"+curNumStr, resSoFar+curNum, curNum, s, target);\\n                dfs(j+1, path+\"-\"+curNumStr, resSoFar-curNum, -curNum, s, target);\\n                dfs(j+1, path+\"*\"+curNumStr, resSoFar-prevNum+(curNum*prevNum), prevNum*curNum, s, target);\\n            }\\n        }\\n        return;\\n    }\\n    \\n    vector<string> addOperators(string &num, int target) {\\n        dfs(0,\"\",0,0,num,target);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142357,
                "title": "backtracking",
                "content": "> Factors to be enumerated:\\n- num can be divided into arbitrary numbers, each number can be arbitrary length, represented by `num.substring(start, end)`\\n- preceding operator of each number can be  \\'+\\', \\'-\\',  or \\'x\\'\\n```\\nTake num = \"12\" for example, state tree is as blow:\\n root\\n   /\\\\\\n  1 12 --level 1\\n /|\\\\\\n+ - *\\n| | |\\n2 2 2 -- level 2\\n```\\n\\n> If we specify an `element = num.substring(start, end)`, with any possible operator in front, we get a new value. `start` increases in next round, the problem becomes smaller.\\n\\n> The base case is: start == num.length()\\n> The special case is: the first operand doesn\\'t have`preceding operator`\\n\\n> Note: if `preceding operator` is `*`, value of current expression should be re-evaluated by restoring the `difference` first\\n```\\nTake 1 + 2 * 3 for example,\\n  val = 1 + 2 = 3\\n  diff = 2\\n// when start = 2, i.e. we meet curNum = 3\\n  val = val - diff + diff * curNum\\n      = 3 - 2 + 2 * 3 = 7\\n```\\n****\\n```\\nclass Solution {\\n    private List<String> result;\\n    \\n    public List<String> addOperators(String num, int target) {\\n        result = new ArrayList<>();\\n        addOperators(num, target, 0, 0, \"\", 0);\\n        return result;\\n    }\\n    \\n    /* \\n    @param: num\\n    @param: target\\n    @param: start  start index in num\\n    @param: val  current value of expr\\n    @param: expr  expression\\n    @param: diff  difference\\n    */\\n    private void addOperators(String num, int target, int start, long val, String expr, long diff) {\\n        if (start == num.length()) {\\n            \\n            if (target == val) {\\n                result.add(expr);\\n            } \\n            return;\\n        }\\n        \\n        for (int end = start + 1; end <= num.length(); end++) {\\n            String cur = num.substring(start, end);\\n            \\n            if (cur.charAt(0) == \\'0\\' && cur.length() > 1) {\\n                // Invalid number\\n                continue;\\n            }\\n            \\n            long curNum = Long.parseLong(cur);\\n            \\n            if (start == 0) {\\n                // The first number\\n                addOperators(num, target, end, curNum, cur, curNum);\\n            } else {\\n                // + in front\\n                addOperators(num, target, end, val + curNum, expr + \"+\" + cur, curNum);\\n            \\n                // - in front\\n                addOperators(num, target, end, val - curNum, expr + \"-\" + cur, -curNum);\\n        \\n                // * in front\\n                addOperators(num, target, end, val - diff + diff * curNum, expr + \"*\" + cur, diff * curNum);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nTake num = \"12\" for example, state tree is as blow:\\n root\\n   /\\\\\\n  1 12 --level 1\\n /|\\\\\\n+ - *\\n| | |\\n2 2 2 -- level 2\\n```\n```\\nTake 1 + 2 * 3 for example,\\n  val = 1 + 2 = 3\\n  diff = 2\\n// when start = 2, i.e. we meet curNum = 3\\n  val = val - diff + diff * curNum\\n      = 3 - 2 + 2 * 3 = 7\\n```\n```\\nclass Solution {\\n    private List<String> result;\\n    \\n    public List<String> addOperators(String num, int target) {\\n        result = new ArrayList<>();\\n        addOperators(num, target, 0, 0, \"\", 0);\\n        return result;\\n    }\\n    \\n    /* \\n    @param: num\\n    @param: target\\n    @param: start  start index in num\\n    @param: val  current value of expr\\n    @param: expr  expression\\n    @param: diff  difference\\n    */\\n    private void addOperators(String num, int target, int start, long val, String expr, long diff) {\\n        if (start == num.length()) {\\n            \\n            if (target == val) {\\n                result.add(expr);\\n            } \\n            return;\\n        }\\n        \\n        for (int end = start + 1; end <= num.length(); end++) {\\n            String cur = num.substring(start, end);\\n            \\n            if (cur.charAt(0) == \\'0\\' && cur.length() > 1) {\\n                // Invalid number\\n                continue;\\n            }\\n            \\n            long curNum = Long.parseLong(cur);\\n            \\n            if (start == 0) {\\n                // The first number\\n                addOperators(num, target, end, curNum, cur, curNum);\\n            } else {\\n                // + in front\\n                addOperators(num, target, end, val + curNum, expr + \"+\" + cur, curNum);\\n            \\n                // - in front\\n                addOperators(num, target, end, val - curNum, expr + \"-\" + cur, -curNum);\\n        \\n                // * in front\\n                addOperators(num, target, end, val - diff + diff * curNum, expr + \"*\" + cur, diff * curNum);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71984,
                "title": "ac-solution-c-short",
                "content": "    class Solution {\\n    public:\\n        vector<string> addOperators(string num, int target) {\\n    \\t\\tvector<string> ret;\\n    \\t\\tif (num.length() == 0) return ret;\\n    \\t\\thelp(num, target, ret, num[0] - '0', num.substr(0, 1), 1, 1);\\n    \\t\\treturn ret;\\n    \\t}\\n    \\n    \\tvoid help(const string num, int target, vector<string> & v, long long last, string s, int idx, int left) {\\n    \\t\\tif (target == last*left && idx == num.length())\\n    \\t\\t{\\n    \\t\\t\\tv.push_back(s);\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\telse if (idx == num.length()) return;\\n    \\t\\telse {\\n    \\t\\t\\tif(last!=0) help(num, target, v, last * 10 + num[idx] - '0', s + num.substr(idx, 1), idx + 1, left);\\n    \\t\\t\\thelp(num, target, v, num[idx] - '0', s + '*' + num.substr(idx, 1), idx + 1, last*left);\\n    \\t\\t\\thelp(num, target - left*last, v, num[idx] - '0', s + '+' + num.substr(idx, 1), idx + 1, 1);\\n    \\t\\t\\thelp(num, target - left*last, v, num[idx] - '0', s + '-' + num.substr(idx, 1), idx + 1, -1);\\n    \\t\\t}\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> addOperators(string num, int target) {\\n    \\t\\tvector<string> ret;\\n    \\t\\tif (num.length() == 0) return ret;\\n    \\t\\thelp(num, target, ret, num[0] - '0', num.substr(0, 1), 1, 1);\\n    \\t\\treturn ret;\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 1830287,
                "title": "java-recursion-backtracking",
                "content": "Here i have used two recursions.\\n1) one recursion for splitting the string\\n2) one recusion for adding operators in between\\n```\\nclass Solution {\\n    String s;\\n    List<String>result;\\n    int target;\\n    public void operator(int i,int prev,long prod,long mid,String exp,List<Long>l){\\n        if(i==l.size()){\\n            if(mid+prod==target)\\n                result.add(exp);\\n            return;\\n        }\\n        if(prev==-1){\\n            operator(i+1,0,-1*l.get(i)*l.get(i-1),mid+l.get(i-1),exp+\"*\"+l.get(i),l);\\n        }else if(prev==1){\\n            operator(i+1,0,l.get(i)*l.get(i-1),mid-l.get(i-1),exp+\"*\"+l.get(i),l);\\n        }else{\\n            operator(i+1,0,prod*l.get(i),mid,exp+\"*\"+l.get(i),l);\\n        }\\n        operator(i+1,-1,0,mid+prod-l.get(i),exp+\"-\"+l.get(i),l);\\n        operator(i+1,1,0,mid+prod+l.get(i),exp+\"+\"+l.get(i),l);\\n    }\\n    public void rec(int in,List<Long>l){\\n        if(in==s.length()){\\n            operator(1,1,0,l.get(0),l.get(0)+\"\",l);\\n            return;\\n        }\\n        if(s.charAt(in)==\\'0\\'){\\n            l.add(0L);\\n            rec(in+1,l);\\n            l.remove(l.size()-1);\\n        }else{\\n            for(int i=in;i<s.length();i++){\\n                l.add(Long.parseLong(s.substring(in,i+1)));\\n                rec(i+1,l);\\n                l.remove(l.size()-1);\\n            }\\n        }\\n    }\\n    public List<String> addOperators(String num, int target) {\\n        result=new ArrayList<>();\\n        this.s=num;\\n        this.target=target;\\n        rec(0,new ArrayList<>(30));\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    String s;\\n    List<String>result;\\n    int target;\\n    public void operator(int i,int prev,long prod,long mid,String exp,List<Long>l){\\n        if(i==l.size()){\\n            if(mid+prod==target)\\n                result.add(exp);\\n            return;\\n        }\\n        if(prev==-1){\\n            operator(i+1,0,-1*l.get(i)*l.get(i-1),mid+l.get(i-1),exp+\"*\"+l.get(i),l);\\n        }else if(prev==1){\\n            operator(i+1,0,l.get(i)*l.get(i-1),mid-l.get(i-1),exp+\"*\"+l.get(i),l);\\n        }else{\\n            operator(i+1,0,prod*l.get(i),mid,exp+\"*\"+l.get(i),l);\\n        }\\n        operator(i+1,-1,0,mid+prod-l.get(i),exp+\"-\"+l.get(i),l);\\n        operator(i+1,1,0,mid+prod+l.get(i),exp+\"+\"+l.get(i),l);\\n    }\\n    public void rec(int in,List<Long>l){\\n        if(in==s.length()){\\n            operator(1,1,0,l.get(0),l.get(0)+\"\",l);\\n            return;\\n        }\\n        if(s.charAt(in)==\\'0\\'){\\n            l.add(0L);\\n            rec(in+1,l);\\n            l.remove(l.size()-1);\\n        }else{\\n            for(int i=in;i<s.length();i++){\\n                l.add(Long.parseLong(s.substring(in,i+1)));\\n                rec(i+1,l);\\n                l.remove(l.size()-1);\\n            }\\n        }\\n    }\\n    public List<String> addOperators(String num, int target) {\\n        result=new ArrayList<>();\\n        this.s=num;\\n        this.target=target;\\n        rec(0,new ArrayList<>(30));\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71951,
                "title": "very-concise-c-solution",
                "content": "    class Solution {\\n    public:\\n        void DFS(string num, long sum, string path, int pos, long pre, int val)\\n        {\\n            pre = pre*10 + num[pos]-'0';\\n            if(pre > INT_MAX) return;\\n            if(sum+pre*val ==0 && pos== num.size()-1) result.push_back(path+num[pos]);\\n            if(pos== num.size()-1) return;\\n            if(pre) DFS(num, sum, path+num[pos], pos+1, pre, val);\\n            DFS(num, sum+pre*val, path+num[pos]+'+', pos+1, 0, 1);\\n            DFS(num, sum+pre*val, path+num[pos]+'-', pos+1, 0, -1);\\n            DFS(num, sum, path+num[pos]+'*', pos+1, 0, val*pre);\\n        }\\n    \\n        vector<string> addOperators(string num, int target) {\\n            if(num.size() ==0) return {};\\n            DFS(num, -target, \"\", 0, 0, 1);\\n            return result;\\n        }\\n    private:\\n        vector<string> result;\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void DFS(string num, long sum, string path, int pos, long pre, int val)\\n        {\\n            pre = pre*10 + num[pos]-'0';\\n            if(pre > INT_MAX) return;\\n            if(sum+pre*val ==0 && pos== num.size()-1) result.push_back(path+num[pos]);\\n            if(pos== num.size()-1) return;\\n            if(pre) DFS(num, sum, path+num[pos], pos+1, pre, val);\\n            DFS(num, sum+pre*val, path+num[pos]+'+', pos+1, 0, 1);\\n            DFS(num, sum+pre*val, path+num[pos]+'-', pos+1, 0, -1);\\n            DFS(num, sum, path+num[pos]+'*', pos+1, 0, val*pre);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 71986,
                "title": "17-line-accepted-c-dfs-solution",
                "content": "    public IList<string> AddOperators(string num, int target) {\\n        IList<string> result = new List<string>();\\n        dfs(result, \"\", 0, 0, num, target);\\n        return result;\\n    }\\n    private void dfs(IList<string> result, string curStr, long curSum, long curHead, string curNum, long target){\\n        if(curNum.Length == 0 && target - curSum - curHead == 0) result.Add(curStr);\\n        for(int i = 1; i < 11 && i <= curNum.Length; i++){\\n            string strNum = curNum.Substring(0, i); long lNum = Convert.ToInt64(strNum);\\n            if(lNum > int.MaxValue || curHead > int.MaxValue) break;\\n            if(curStr.Length == 0) dfs(result, strNum, 0, lNum, curNum.Substring(i), target);\\n            else{\\n                dfs(result, curStr + \"*\" + strNum, curSum, curHead * lNum, curNum.Substring(i), target);\\n                dfs(result, curStr + \"+\" + strNum, curSum + curHead, lNum, curNum.Substring(i), target);\\n                dfs(result, curStr + \"-\" + strNum, curSum + curHead, -lNum, curNum.Substring(i), target);\\n            }\\n            if(lNum == 0) break; // avoid result of \"000\"/\"012\" etc\\n        }\\n    }\\n\\nThe first version accepted here.\\n\\n    public IList<string> AddOperators(string num, int target) {\\n        IList<long> curList = new List<long>();\\n        IList<string> result = new List<string>();\\n        if(num.Length == 0) return result;\\n        for(int i = 1; i < 11 && i <= num.Length; i++){\\n            string curStr = num.Substring(0, i);\\n            if(Convert.ToInt64(curStr) <= int.MaxValue){\\n                curList.Add(Convert.ToInt64(curStr));\\n                dfs(result, curStr, curList, num.Substring(i), target);\\n                curList.RemoveAt(curList.Count - 1);\\n            }\\n            if(curStr == \"0\") break;\\n        }\\n        return result;\\n    }\\n    \\n    private void dfs(IList<string> result, string curStr, IList<long> curList, string curNum, long target){\\n        if(curNum.Length == 0){\\n            foreach(int i in curList) target -= i;\\n            if(target == 0) result.Add(curStr);\\n            return;\\n        }\\n        for(int i = 1; i < 11 && i <= curNum.Length; i++){\\n            string tmpNum = curNum.Substring(0, i);\\n            long lNum = Convert.ToInt64(tmpNum);\\n            if(lNum <= int.MaxValue){\\n                long tmp = curList[curList.Count - 1];\\n                curList[curList.Count - 1] *= lNum;\\n                if(Math.Abs(curList[curList.Count - 1]) <= int.MaxValue)\\n                    dfs(result, curStr + \"*\" + tmpNum, curList, curNum.Substring(i), target);\\n                curList[curList.Count - 1] = tmp;\\n\\n                curList.Add(lNum);\\n                dfs(result, curStr + \"+\" + tmpNum, curList, curNum.Substring(i), target);\\n                curList[curList.Count - 1] = -lNum;\\n                dfs(result, curStr + \"-\" + tmpNum, curList, curNum.Substring(i), target);\\n                curList.RemoveAt(curList.Count - 1);\\n            }\\n            if(lNum == 0) break;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public IList<string> AddOperators(string num, int target) {\\n        IList<string> result = new List<string>();\\n        dfs(result, \"\", 0, 0, num, target);\\n        return result;\\n    }\\n    private void dfs(IList<string> result, string curStr, long curSum, long curHead, string curNum, long target){\\n        if(curNum.Length == 0 && target - curSum - curHead == 0) result.Add(curStr);\\n        for(int i = 1; i < 11 && i <= curNum.Length; i++){\\n            string strNum = curNum.Substring(0, i); long lNum = Convert.ToInt64(strNum);\\n            if(lNum > int.MaxValue || curHead > int.MaxValue) break;\\n            if(curStr.Length == 0) dfs(result, strNum, 0, lNum, curNum.Substring(i), target);\\n            else{\\n                dfs(result, curStr + \"*\" + strNum, curSum, curHead * lNum, curNum.Substring(i), target);\\n                dfs(result, curStr + \"+\" + strNum, curSum + curHead, lNum, curNum.Substring(i), target);\\n                dfs(result, curStr + \"-\" + strNum, curSum + curHead, -lNum, curNum.Substring(i), target);\\n            }\\n            if(lNum == 0) break; // avoid result of \"000\"/\"012\" etc\\n        }\\n    }\\n\\nThe first version accepted here.\\n\\n    public IList<string> AddOperators(string num, int target) {\\n        IList<long> curList = new List<long>();\\n        IList<string> result = new List<string>();\\n        if(num.Length == 0) return result;\\n        for(int i = 1; i < 11 && i <= num.Length; i++){\\n            string curStr = num.Substring(0, i);\\n            if(Convert.ToInt64(curStr) <= int.MaxValue){\\n                curList.Add(Convert.ToInt64(curStr));\\n                dfs(result, curStr, curList, num.Substring(i), target);\\n                curList.RemoveAt(curList.Count - 1);\\n            }\\n            if(curStr == \"0\") break;\\n        }\\n        return result;\\n    }\\n    \\n    private void dfs(IList<string> result, string curStr, IList<long> curList, string curNum, long target){\\n        if(curNum.Length == 0){\\n            foreach(int i in curList) target -= i;\\n            if(target == 0) result.Add(curStr);\\n            return;\\n        }\\n        for(int i = 1; i < 11 && i <= curNum.Length; i++){\\n            string tmpNum = curNum.Substring(0, i);\\n            long lNum = Convert.ToInt64(tmpNum);\\n            if(lNum <= int.MaxValue){\\n                long tmp = curList[curList.Count - 1];\\n                curList[curList.Count - 1] *= lNum;\\n                if(Math.Abs(curList[curList.Count - 1]) <= int.MaxValue)\\n                    dfs(result, curStr + \"*\" + tmpNum, curList, curNum.Substring(i), target);\\n                curList[curList.Count - 1] = tmp;\\n\\n                curList.Add(lNum);\\n                dfs(result, curStr + \"+\" + tmpNum, curList, curNum.Substring(i), target);\\n                curList[curList.Count - 1] = -lNum;\\n                dfs(result, curStr + \"-\" + tmpNum, curList, curNum.Substring(i), target);\\n                curList.RemoveAt(curList.Count - 1);\\n            }\\n            if(lNum == 0) break;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1482147,
                "title": "java-backtracking-template-explained",
                "content": "**Idea:**\\n* Use backtracking to generate all possibilities\\n* If start = 0, there is no operand before current and no operation can be done with single operand, so just append to expression\\n* Else form the expression and calculate on the fly\\n* Multiplication is a special case because it has higher precedence over `+/-`. So subtract the previous number from the value of expression yet, then add the result to the product of previousNumber and current\\n* Calculate expression on the fly. Calculating after the genertion of complete expression is inefficient.\\n* Edge cases: \\n\\t* take` long` for calculations as the result can overflow\\n\\t* Only 0 can have a leading zero, every other number with a leading zero would be invalid (the break case)\\n\\n![image](https://assets.leetcode.com/users/images/e3298cec-e3b2-47a4-bd67-7cd9a7abcf2e_1632447794.322304.png)\\n**T/S:** O(n4\\u207F)/O(n), where n = size(num)\\n```\\npublic List<String> addOperators(String num, int target) {\\n\\tvar result = new ArrayList<String>();\\n\\taddOperators(num, target, 0, result, \"\", 0, 0);\\n\\treturn result;\\n}\\n\\nprivate void addOperators(String num, int target, int start, List<String> result, String expression, long valueYet, long previousNumber) {\\n\\tif (start == num.length() && valueYet == target)\\n\\t\\tresult.add(expression);\\n\\telse\\n\\t\\t// for each choice\\n\\t\\tfor (var i = start; i < num.length(); i++) {\\n\\t\\t\\tif (i != start && num.charAt(start) == \\'0\\')\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tvar current = Long.parseLong(num.substring(start, i + 1));\\n\\t\\n\\t\\t\\t// choose-explore-unchoose\\n\\t\\t\\tif (start == 0) {\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + current, current, current);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + \"+\" + current, valueYet + current, current);\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + \"-\" + current, valueYet - current, -current);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tvar newValue = (valueYet - previousNumber) + (previousNumber * current);\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + \"*\" + current, newValue, previousNumber * current);\\n\\t\\t\\t}\\n\\t\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\npublic List<String> addOperators(String num, int target) {\\n\\tvar result = new ArrayList<String>();\\n\\taddOperators(num, target, 0, result, \"\", 0, 0);\\n\\treturn result;\\n}\\n\\nprivate void addOperators(String num, int target, int start, List<String> result, String expression, long valueYet, long previousNumber) {\\n\\tif (start == num.length() && valueYet == target)\\n\\t\\tresult.add(expression);\\n\\telse\\n\\t\\t// for each choice\\n\\t\\tfor (var i = start; i < num.length(); i++) {\\n\\t\\t\\tif (i != start && num.charAt(start) == \\'0\\')\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tvar current = Long.parseLong(num.substring(start, i + 1));\\n\\t\\n\\t\\t\\t// choose-explore-unchoose\\n\\t\\t\\tif (start == 0) {\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + current, current, current);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + \"+\" + current, valueYet + current, current);\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + \"-\" + current, valueYet - current, -current);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tvar newValue = (valueYet - previousNumber) + (previousNumber * current);\\n\\t\\t\\t\\taddOperators(num, target, i + 1, result, expression + \"*\" + current, newValue, previousNumber * current);\\n\\t\\t\\t}\\n\\t\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1473359,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> expressions;\\n    vector<string> addOperators(string num, int target) {\\n        dfs(num , target , 0 , \"\" , 0 , 0);\\n        return expressions;\\n    }\\n    void dfs(string &num , int target , int index , string path , long int res , long int prev)\\n    {\\n        if(index == num.size() and res == target)\\n        {\\n            expressions.push_back(path);\\n            return;\\n        }\\n        \\n        long int number = 0;\\n        string sub_string = \"\";\\n        \\n        for(int i = index ; i < num.size() ; ++i)\\n        {\\n            sub_string += num[i];\\n            number = (number * 10) + num[i] - \\'0\\';\\n            \\n            if(sub_string.size() > 1 and sub_string[0] == \\'0\\') // skipping numbers with leading 0\\'s\\n                break;\\n            \\n            if(index == 0) // first number of expression is picked without operator\\n            {\\n                dfs(num , target , i + 1 , sub_string , number, number);\\n            }\\n            else\\n            {\\n                // (1) + operation inserted\\n                dfs(num , target , i + 1 , path  + \"+\" + sub_string , res  + number , number);\\n                    \\n                // (2) - operation inserted\\n                dfs(num , target , i + 1 , path + \"-\" + sub_string , res  - number , -number);\\n                \\n                // (3) * operation inserted\\n                dfs(num , target , i + 1 , path + \"*\" + sub_string , (res - prev)  + (prev * number) , prev * number);\\n            }\\n        }\\n            \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> expressions;\\n    vector<string> addOperators(string num, int target) {\\n        dfs(num , target , 0 , \"\" , 0 , 0);\\n        return expressions;\\n    }\\n    void dfs(string &num , int target , int index , string path , long int res , long int prev)\\n    {\\n        if(index == num.size() and res == target)\\n        {\\n            expressions.push_back(path);\\n            return;\\n        }\\n        \\n        long int number = 0;\\n        string sub_string = \"\";\\n        \\n        for(int i = index ; i < num.size() ; ++i)\\n        {\\n            sub_string += num[i];\\n            number = (number * 10) + num[i] - \\'0\\';\\n            \\n            if(sub_string.size() > 1 and sub_string[0] == \\'0\\') // skipping numbers with leading 0\\'s\\n                break;\\n            \\n            if(index == 0) // first number of expression is picked without operator\\n            {\\n                dfs(num , target , i + 1 , sub_string , number, number);\\n            }\\n            else\\n            {\\n                // (1) + operation inserted\\n                dfs(num , target , i + 1 , path  + \"+\" + sub_string , res  + number , number);\\n                    \\n                // (2) - operation inserted\\n                dfs(num , target , i + 1 , path + \"-\" + sub_string , res  - number , -number);\\n                \\n                // (3) * operation inserted\\n                dfs(num , target , i + 1 , path + \"*\" + sub_string , (res - prev)  + (prev * number) , prev * number);\\n            }\\n        }\\n            \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893132,
                "title": "faster-than-100-twice-optimization-explanation",
                "content": "Inspired by some great writers and code, \\nthis post is approximately faster than \\nprevious fastest DFS by 4x and previous fastest BFS by 2x. \\nIt makes time complexity from 4^(N) to 4^1/2(N). [(some ideas and analysis from MaskRay)](https://leetcode.com/problems/expression-add-operators/discuss/71975/Some-thoughts-on-the-algorithm%3A-SLR(1)-and-optimization%3A-meet-in-the-middle-(-spatial-data-structure))\\n\\nI\\'d like to share the surprising result and ideas to inspire others in simple words. \\n\\nThe basic solution is using DFS to tracking the results of each operator because the given string is not long. \\nMost writers\\' code is very short and quite understandable. \\nI suppose you have been very familiar with it. \\n\\nBut if the string is longer than current and old fashion can\\'t work well, \\nwe finally must optimize it. \\nMaybe you have found the runtime distribution is a wide range. (40ms ~7000+)\\n\\nIn short, \\nwe can ***use DP and symmetry as possible.***\\n\\nAs some posts mentioned, we can ***divide the string into first half and second half*** \\nbecause we can use operator + and -  to combine these two parts\\' results and decrease the search space. \\nIn other words, the results of the first half +(-) second half must be the target.\\nFor example, \\n(1+2) **+ (3-1)** = 5 or (1+2) **- (3-1)** = 5 is true.\\n\\nBesides, if we use DP meanwhile, it also can help ***combine some found results first.***\\n\\nAfter some attemps, I found BFS is more efficient in this task than DFS. (although using DFS is easier)\\nAt first look, I also think DFS is better. But when I tried to optimize, I found \\n***DFS is harder to deal with split concisely and manipulate index than BFS***, \\nespecially we need to create a DP table by indexes and split.\\n\\nAs for DP table, we reuse the same main function\\nto ***extract the second half\\'s results from the middle to the end*** for later check and combination. \\nAnd we ***only need to extract the results of positive +\"string\"*** because the negative -\"string\" is reverse of +\"string\".\\nFor example, \\n(1+2) **+ (3-1+2)**  and (1+2) **- (3-1+2)**, \\nbold parts\\' values are respectively +4 and -4, but combinations are the same.\\n\\nBesides, we also can use multiplication \\nbecause ***known partial result + current possible maximal operation(multiplication) must be greater than target***, \\notherwise we can\\'t use operator + or - to achieve the target afterwards. \\nThis can help us decrease the search space a lot.\\n\\nCode with clear comments step by step as below.\\nDP table, **preview**, is a nested hashmap, \\nstoring **{key string: { combination value: possible combination}}**\\n\\n```\\nclass Solution(object): # BFS, best 40 ms, most posts\\' results are around 700~6000+ ms\\n\\n    def addOperators(self, num, target):\\n        if not num: return []\\n\\n        # set the boolean for reusing the func(main search and creating DP)\\n        def BFS(num, cutEdge = False):\\n            firstValue = int(num[0])\\n            # (pre-result, pre-Sum, pre-operation, pre-Number\\'s value)\\n            queue = [(num[0], firstValue, firstValue, firstValue)]\\n\\n            for i, c in enumerate(num):\\n                if i == 0: continue\\n                newQ, v = [], int(c)\\n                for preString, preSum, preOP, preNum in queue:\\n                    # combine with previous num without operator\\n                    if preString[-1] != \\'0\\' or (len(preString) > 1 and preString[-2] not in (\\'-\\', \\'+\\', \\'*\\')):\\n                    # preOP / preNum * v: extract pre-operation to operate with current value\\n                        curOP = preOP * 10 + preOP / preNum * v\\n                        curSum = preSum - preOP + curOP\\n                        curVal = preNum * 10 + v\\n                        newQ.append([preString + c, curSum, curOP, curVal])\\n\\n                    # if current maximal possible num is less than remaining sum,\\n                    # there\\'s no result because only multiplication can create maximal num.\\n                    # use this line when main search, not creating DP\\n                    if not cutEdge and max(1, abs(preOP)) * int(num[i:]) < abs(target - preSum):\\n                        continue\\n\\n                    # new search of \"*\", \"+\", \"-\"\\n                    newQ.append([preString + \\'*\\' + c, preSum - preOP + preOP * v, preOP * v, v])\\n                    if num[i:] not in preview:\\n                        newQ.append([preString + \\'+\\' + c, preSum + v, v, v])   \\n                        newQ.append([preString + \\'-\\' + c, preSum - v, -v, v])\\n                    \\n                    # check and combine second part\\'s results of \"+\" and \"-\" when main search\\n                    if not cutEdge and i >= len(num)-half:\\n                        restSum = target - preSum\\n                        # if able to achieve target, + second part\\'s result directly\\n                        if restSum in preview[num[i:]]:\\n                            for parse in preview[num[i:]][restSum]:\\n                                parseResult.append(preString + \"+\" + parse)\\n                        # we can reverse the results in DP for \"-\",\\n                        if -restSum in preview[num[i:]]:\\n                            for parse in preview[num[i:]][-restSum]:\\n                                parse = parse.replace(\"-\", \" \").replace(\"+\", \"-\").replace(\" \", \"+\")\\n                                parseResult.append(preString + \"-\" + parse)\\n                queue = newQ\\n\\n            # collect cut edge results(DP) \\n            if cutEdge:\\n                result = defaultdict(list)\\n                for element in queue:\\n                    result[element[1]].append(element[0])\\n                return result\\n\\n            # main BFS\\'s result\\n            else: return queue         \\n        \\n        # cut string into two halves for preview(DP table)\\n        # { key string: { combination value: possible combination} } \\n        preview = {} \\n        half = len(num)//2 + 1\\n        for i in range(-half, 0):\\n            preview[num[i:]] = BFS(num[i:], True)\\n\\n        parseResult = [] \\n        return [e[0] for e in BFS(num) if e[1] == target] + parseResult\\n```\\nSome ideas are also from [bairongdong1](https://leetcode.com/problems/expression-add-operators/discuss/703797/Python-beat-100-84ms)\\n\\nThe method is similar to bidirectional BFS and works better than DFS \\nbecause we can use the partial results in the middle of the string to largely decrease the search space.\\n\\nIf we have concern about the memory, \\nwe also can adapt the DP preview, \\njust store the combinations\\' values, not including combinations. \\nIt still works well.\\n\\nBy the way,\\nSome people used eval() with string.\\nBut that\\'s less helpful.\\n```\\neval(\"1+2+3\")\\n100000 loops, best of 3: 4.6 \\xB5s per loop\\nint(\"1\")+int(\"2\")+int(\"3\")\\n1000000 loops, best of 3: 474 ns per loop\\n```\\n\\nWelcome suggestion, question and comments.\\nIf helpful, ***please upvote! Thanks a lot!***",
                "solutionTags": [],
                "code": "```\\nclass Solution(object): # BFS, best 40 ms, most posts\\' results are around 700~6000+ ms\\n\\n    def addOperators(self, num, target):\\n        if not num: return []\\n\\n        # set the boolean for reusing the func(main search and creating DP)\\n        def BFS(num, cutEdge = False):\\n            firstValue = int(num[0])\\n            # (pre-result, pre-Sum, pre-operation, pre-Number\\'s value)\\n            queue = [(num[0], firstValue, firstValue, firstValue)]\\n\\n            for i, c in enumerate(num):\\n                if i == 0: continue\\n                newQ, v = [], int(c)\\n                for preString, preSum, preOP, preNum in queue:\\n                    # combine with previous num without operator\\n                    if preString[-1] != \\'0\\' or (len(preString) > 1 and preString[-2] not in (\\'-\\', \\'+\\', \\'*\\')):\\n                    # preOP / preNum * v: extract pre-operation to operate with current value\\n                        curOP = preOP * 10 + preOP / preNum * v\\n                        curSum = preSum - preOP + curOP\\n                        curVal = preNum * 10 + v\\n                        newQ.append([preString + c, curSum, curOP, curVal])\\n\\n                    # if current maximal possible num is less than remaining sum,\\n                    # there\\'s no result because only multiplication can create maximal num.\\n                    # use this line when main search, not creating DP\\n                    if not cutEdge and max(1, abs(preOP)) * int(num[i:]) < abs(target - preSum):\\n                        continue\\n\\n                    # new search of \"*\", \"+\", \"-\"\\n                    newQ.append([preString + \\'*\\' + c, preSum - preOP + preOP * v, preOP * v, v])\\n                    if num[i:] not in preview:\\n                        newQ.append([preString + \\'+\\' + c, preSum + v, v, v])   \\n                        newQ.append([preString + \\'-\\' + c, preSum - v, -v, v])\\n                    \\n                    # check and combine second part\\'s results of \"+\" and \"-\" when main search\\n                    if not cutEdge and i >= len(num)-half:\\n                        restSum = target - preSum\\n                        # if able to achieve target, + second part\\'s result directly\\n                        if restSum in preview[num[i:]]:\\n                            for parse in preview[num[i:]][restSum]:\\n                                parseResult.append(preString + \"+\" + parse)\\n                        # we can reverse the results in DP for \"-\",\\n                        if -restSum in preview[num[i:]]:\\n                            for parse in preview[num[i:]][-restSum]:\\n                                parse = parse.replace(\"-\", \" \").replace(\"+\", \"-\").replace(\" \", \"+\")\\n                                parseResult.append(preString + \"-\" + parse)\\n                queue = newQ\\n\\n            # collect cut edge results(DP) \\n            if cutEdge:\\n                result = defaultdict(list)\\n                for element in queue:\\n                    result[element[1]].append(element[0])\\n                return result\\n\\n            # main BFS\\'s result\\n            else: return queue         \\n        \\n        # cut string into two halves for preview(DP table)\\n        # { key string: { combination value: possible combination} } \\n        preview = {} \\n        half = len(num)//2 + 1\\n        for i in range(-half, 0):\\n            preview[num[i:]] = BFS(num[i:], True)\\n\\n        parseResult = [] \\n        return [e[0] for e in BFS(num) if e[1] == target] + parseResult\\n```\n```\\neval(\"1+2+3\")\\n100000 loops, best of 3: 4.6 \\xB5s per loop\\nint(\"1\")+int(\"2\")+int(\"3\")\\n1000000 loops, best of 3: 474 ns per loop\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230225,
                "title": "python-solution",
                "content": "Time complexity: `O(n^2*3^n)`, space complexity: `O(n^2*3^n)`.\\n\\n```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        def recurse(idx, val, prev_val, ops):\\n            if idx == len(num):\\n                if val == target:\\n                    res.append(\"\".join(ops))\\n            else:\\n                curr_val = 0\\n                for i in range(idx, len(num)):\\n                    curr_val = 10*curr_val + int(num[i])\\n                    if idx == 0:\\n                        recurse(i+1, curr_val, curr_val, ops+[str(curr_val)])\\n                    else:\\n                        v = val - prev_val\\n                        recurse(i+1, v+prev_val*curr_val, prev_val*curr_val, ops+[\"*\"+str(curr_val)])\\n                        recurse(i+1, val+curr_val, curr_val, ops+[\"+\"+str(curr_val)])\\n                        recurse(i+1, val-curr_val, -curr_val, ops+[\"-\"+str(curr_val)])\\n                    if num[idx] == \"0\":\\n                        break\\n        res = []\\n        recurse(0, 0, 0, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        def recurse(idx, val, prev_val, ops):\\n            if idx == len(num):\\n                if val == target:\\n                    res.append(\"\".join(ops))\\n            else:\\n                curr_val = 0\\n                for i in range(idx, len(num)):\\n                    curr_val = 10*curr_val + int(num[i])\\n                    if idx == 0:\\n                        recurse(i+1, curr_val, curr_val, ops+[str(curr_val)])\\n                    else:\\n                        v = val - prev_val\\n                        recurse(i+1, v+prev_val*curr_val, prev_val*curr_val, ops+[\"*\"+str(curr_val)])\\n                        recurse(i+1, val+curr_val, curr_val, ops+[\"+\"+str(curr_val)])\\n                        recurse(i+1, val-curr_val, -curr_val, ops+[\"-\"+str(curr_val)])\\n                    if num[idx] == \"0\":\\n                        break\\n        res = []\\n        recurse(0, 0, 0, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71899,
                "title": "swift-implementation-with-docs-and-full-comments",
                "content": "This is a variation on some solutions in this forum but written in Swift. This problem has a large number of permutations which I attempt to capture in the comments.\\n```\\nclass Solution {\\n    \\n    // Recursion \\n    // - Parameters:\\n    //     - results: String array of valid math operation strings to return\\n    //     - result: String with current operation string being constructed\\n    //     - digits: Int array with the individual digits\\n    //     - target: Int with the target operation final value\\n    //     - offset: Current position in the digits array\\n    //     - mr:     MR like a calculator holding the result of the last operation\\n    //     - prior:  Special param to help multiplication which is backward looking due to order of operations (BOMDAS)\\n    func dfs(_ results: inout [String], _ result: String, _ digits: [Int], _ target: Int, _ offset: Int, _ mr: Int, _ prior: Int) {\\n        \\n        // if we're evaluated all the digits, we're at the end of the recrusion\\n        if offset == digits.count {\\n            // save the result string if the MR value equal to our target\\n            if target == mr {\\n                results.append(result)\\n            }\\n            return\\n        }\\n        \\n        // walk the down digit array from the current offset\\n        for i in offset..<digits.count {\\n            // zeros are handled slightly differently\\n            // to account for 10, if we see a zero but we're not at the\\n            // current offset, we need to treat it like a 10\\n            // (the question is vague about this but it's in the examples)\\n            if i != offset && digits[offset] == 0 {\\n                break\\n            }\\n\\n            // build the current number from the digits\\n            var val = 0\\n            // i+1 is not bounded, so make sure we\\n            // don't exceed the digit array bounds\\n            for x in offset..<i+1 where x < digits.count {\\n                // increase the existing value of val by a power of 10 on each iteration\\n                val *= 10\\n                val += digits[x]\\n            }\\n            \\n            // if we're at the first digit, there's no operation possible\\n            if offset == 0 {\\n                // the first digit is simple, initialize the string and MR is digit\\n                dfs(&results, result + String(val), digits, target, i + 1, val, val)\\n            } else {\\n                // addition: add the digit to the string and add it to MR, track it in case we mul next\\n                dfs(&results, result + \"+\" + String(val), digits, target, i + 1, mr + val, val)\\n                // substraction: add the digit to the string and minus it from MR, track it in case we mul next\\n                dfs(&results, result + \"-\" + String(val), digits, target, i + 1, mr - val, -val)\\n                // multiplication: add the digit to the string, but we have an order of operations to deal with\\n                // BOMDAS, so minus the prior value and add the multiplied value to MR, track the multiplied value in prior\\n                dfs(&results, result + \"*\" + String(val), digits, target, i + 1, mr - prior + (prior * val), prior * val)\\n            }\\n        }\\n    }\\n    \\n    // the problem description is a bit vague, but we don't just\\n    // care about single digits, it's all possible numbers comprised \\n    // of those digits, this greatly increases the number of permutations\\n    // to O(n^2)\\n    func addOperators(_ num: String, _ target: Int) -> [String] {\\n        var results: [String] = []\\n        \\n        // ensure we have evaluatble input\\n        if num.count == 0 {\\n            return results\\n        }\\n        \\n        // split the string into an array of digits\\n        let digits = Array(num).map({Int(String($0))!})\\n        \\n        // recurse from index zero\\n        dfs(&results, \"\", digits, target, 0, 0, 0)\\n        \\n        return results\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    // Recursion \\n    // - Parameters:\\n    //     - results: String array of valid math operation strings to return\\n    //     - result: String with current operation string being constructed\\n    //     - digits: Int array with the individual digits\\n    //     - target: Int with the target operation final value\\n    //     - offset: Current position in the digits array\\n    //     - mr:     MR like a calculator holding the result of the last operation\\n    //     - prior:  Special param to help multiplication which is backward looking due to order of operations (BOMDAS)\\n    func dfs(_ results: inout [String], _ result: String, _ digits: [Int], _ target: Int, _ offset: Int, _ mr: Int, _ prior: Int) {\\n        \\n        // if we're evaluated all the digits, we're at the end of the recrusion\\n        if offset == digits.count {\\n            // save the result string if the MR value equal to our target\\n            if target == mr {\\n                results.append(result)\\n            }\\n            return\\n        }\\n        \\n        // walk the down digit array from the current offset\\n        for i in offset..<digits.count {\\n            // zeros are handled slightly differently\\n            // to account for 10, if we see a zero but we're not at the\\n            // current offset, we need to treat it like a 10\\n            // (the question is vague about this but it's in the examples)\\n            if i != offset && digits[offset] == 0 {\\n                break\\n            }\\n\\n            // build the current number from the digits\\n            var val = 0\\n            // i+1 is not bounded, so make sure we\\n            // don't exceed the digit array bounds\\n            for x in offset..<i+1 where x < digits.count {\\n                // increase the existing value of val by a power of 10 on each iteration\\n                val *= 10\\n                val += digits[x]\\n            }\\n            \\n            // if we're at the first digit, there's no operation possible\\n            if offset == 0 {\\n                // the first digit is simple, initialize the string and MR is digit\\n                dfs(&results, result + String(val), digits, target, i + 1, val, val)\\n            } else {\\n                // addition: add the digit to the string and add it to MR, track it in case we mul next\\n                dfs(&results, result + \"+\" + String(val), digits, target, i + 1, mr + val, val)\\n                // substraction: add the digit to the string and minus it from MR, track it in case we mul next\\n                dfs(&results, result + \"-\" + String(val), digits, target, i + 1, mr - val, -val)\\n                // multiplication: add the digit to the string, but we have an order of operations to deal with\\n                // BOMDAS, so minus the prior value and add the multiplied value to MR, track the multiplied value in prior\\n                dfs(&results, result + \"*\" + String(val), digits, target, i + 1, mr - prior + (prior * val), prior * val)\\n            }\\n        }\\n    }\\n    \\n    // the problem description is a bit vague, but we don't just\\n    // care about single digits, it's all possible numbers comprised \\n    // of those digits, this greatly increases the number of permutations\\n    // to O(n^2)\\n    func addOperators(_ num: String, _ target: Int) -> [String] {\\n        var results: [String] = []\\n        \\n        // ensure we have evaluatble input\\n        if num.count == 0 {\\n            return results\\n        }\\n        \\n        // split the string into an array of digits\\n        let digits = Array(num).map({Int(String($0))!})\\n        \\n        // recurse from index zero\\n        dfs(&results, \"\", digits, target, 0, 0, 0)\\n        \\n        return results\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71960,
                "title": "shortest-c-solution",
                "content": "    //cur: current position in s\\n    //cnum: number formed by s[position of previous op...cur]\\n    //num: result of a1*a2*a3... before previous op\\n    //res: result of previous calculation, not including num\\n    //str: current string\\n    //s:   original string\\n    //when we add an op at cur:\\n    //\\t\\t1) +: num=1, res=res+num*cnum\\n    //\\t\\t2) -: num=-1, res=res+num*cnum\\n    //\\t\\t3) *: num=num*cnum, res=res\\n\\n    class Solution {\\n    public:\\n    \\tvector<string>ans;\\n    \\tvoid dfs(int cur, long long cnum, long long num, long long res, string str, string s){\\n    \\t\\tcnum = cnum * 10 + s[cur] - '0';\\n    \\t\\tif (cur+1 == s.size()){\\n    \\t\\t\\tif (res + num*cnum == 0)ans.push_back(str + s[cur]);\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\tif (cnum != 0)dfs(cur + 1, cnum, num, res, str + s[cur], s);//no op here and no leading 0\\n    \\t\\tdfs(cur + 1, 0, 1, res + num*cnum, str + s[cur] + '+', s);//+\\n    \\t\\tdfs(cur + 1, 0, -1, res + num*cnum, str + s[cur] + '-', s);//-\\n    \\t\\tdfs(cur + 1, 0, num*cnum, res, str + s[cur] + '*', s);//* \\n    \\t}\\n    \\tvector<string> addOperators(string num, int target) {\\n    \\t\\tif (num.size() > 0)dfs(0, 0, 1, -(long long)target, \"\", num);\\n    \\t\\treturn ans;\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\tvector<string>ans;\\n    \\tvoid dfs(int cur, long long cnum, long long num, long long res, string str, string s){\\n    \\t\\tcnum = cnum * 10 + s[cur] - '0';\\n    \\t\\tif (cur+1 == s.size()){\\n    \\t\\t\\tif (res + num*cnum == 0)ans.push_back(str + s[cur]);\\n    \\t\\t\\treturn;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 71980,
                "title": "accepted-java-solution-use-the-function-in-basic-calculateii",
                "content": "**The basic idea is to generate all possible expressions using backtrace.**\\n\\n    public List<String> addOperators(String num, int target) {\\n        if(num.length() == 0) return new ArrayList<String>();\\n        List<String> res = new ArrayList<String>();\\n        ArrayList<String> ops = new  ArrayList<String>();\\n        ops.add(\"+\");ops.add(\"-\");ops.add(\"*\");ops.add(\"\");\\n        gen(num,0,\"\",res,ops,target,num.charAt(0) == '0');\\n        return res;\\n    }\\n    // the last digit in num is treated separately,beacase we can not add operator after the last digit\\n    public void gen(String num,int index,String cur,List<String> res,ArrayList<String> operators,int target,boolean flag){\\n        if(index == num.length()-1){\\n            String tmp = new String(cur+num.charAt(index));\\n            // when the situation is 10+01 this is not valid, and 100+1 is valid, special case. \\n            if( (cur.length() == 0 ||  (!flag && Character.isDigit(cur.charAt(cur.length()-1))) || !Character.isDigit(cur.charAt(cur.length()-1)) )&&calculate(tmp) == target){\\n                res.add(tmp);\\n            }\\n        }else {\\n            for(int j=0;j<operators.size();j++){\\n                // the last element in operators is \"\" .If the situation is 123+03\\n                // this is not valid , but 123+10003 is valid, if the index point to last '0'\\n                // flag is used to determine whether we can use concat operator\\n                if(flag && j == operators.size()-1) continue;\\n                // set the flag if we use \"+\",\"-\",\"*\" operator\\n                gen(num,index+1,cur+num.charAt(index)+operators.get(j),res,operators,target, j== operators.size()-1 ? flag:num.charAt(index+1) == '0' );\\n            }\\n        }\\n    }\\n    //use long to pass the special case \\n    public int calculate(String s) {\\n        s = s+\"+\";\\n        long res = 0;\\n        long val = 0;\\n        char sign = '+';\\n        Stack<Long> st = new Stack<Long>();\\n        for(int i=0;i<s.length();i++){\\n            if(Character.isDigit(s.charAt(i))){\\n                val = val*10+s.charAt(i)-'0';\\n            }else if(s.charAt(i) !=' '){\\n                switch(sign){\\n                    case '+':\\n                        st.push(val);\\n                        break;\\n                    case '-':\\n                        st.push(-val);\\n                        break;\\n                    case '*':\\n                        st.push(st.pop()*val);\\n                        break;\\n                    case '/':\\n                        st.push(st.pop()/val);\\n                        break;\\n                }\\n                val = 0;\\n                sign = s.charAt(i);\\n            }\\n        }\\n        for(long x:st) res+=x;\\n        return res > Integer.MAX_VALUE ? Integer.MAX_VALUE:(int) res;\\n    }",
                "solutionTags": [],
                "code": "**The basic idea is to generate all possible expressions using backtrace.**\\n\\n    public List<String> addOperators(String num, int target) {\\n        if(num.length() == 0) return new ArrayList<String>();\\n        List<String> res = new ArrayList<String>();\\n        ArrayList<String> ops = new  ArrayList<String>();\\n        ops.add(\"+\");ops.add(\"-\");ops.add(\"*\");ops.add(\"\");\\n        gen(num,0,\"\",res,ops,target,num.charAt(0) == '0');\\n        return res;\\n    }\\n    // the last digit in num is treated separately,beacase we can not add operator after the last digit\\n    public void gen(String num,int index,String cur,List<String> res,ArrayList<String> operators,int target,boolean flag){\\n        if(index == num.length()-1){\\n            String tmp = new String(cur+num.charAt(index));\\n            // when the situation is 10+01 this is not valid, and 100+1 is valid, special case. \\n            if( (cur.length() == 0 ||  (!flag && Character.isDigit(cur.charAt(cur.length()-1))) || !Character.isDigit(cur.charAt(cur.length()-1)) )&&calculate(tmp) == target){\\n                res.add(tmp);\\n            }\\n        }else {\\n            for(int j=0;j<operators.size();j++){\\n                // the last element in operators is \"\" .If the situation is 123+03\\n                // this is not valid , but 123+10003 is valid, if the index point to last '0'\\n                // flag is used to determine whether we can use concat operator\\n                if(flag && j == operators.size()-1) continue;\\n                // set the flag if we use \"+\",\"-\",\"*\" operator\\n                gen(num,index+1,cur+num.charAt(index)+operators.get(j),res,operators,target, j== operators.size()-1 ? flag:num.charAt(index+1) == '0' );\\n            }\\n        }\\n    }\\n    //use long to pass the special case \\n    public int calculate(String s) {\\n        s = s+\"+\";\\n        long res = 0;\\n        long val = 0;\\n        char sign = '+';\\n        Stack<Long> st = new Stack<Long>();\\n        for(int i=0;i<s.length();i++){\\n            if(Character.isDigit(s.charAt(i))){\\n                val = val*10+s.charAt(i)-'0';\\n            }else if(s.charAt(i) !=' '){\\n                switch(sign){\\n                    case '+':\\n                        st.push(val);\\n                        break;\\n                    case '-':\\n                        st.push(-val);\\n                        break;\\n                    case '*':\\n                        st.push(st.pop()*val);\\n                        break;\\n                    case '/':\\n                        st.push(st.pop()/val);\\n                        break;\\n                }\\n                val = 0;\\n                sign = s.charAt(i);\\n            }\\n        }\\n        for(long x:st) res+=x;\\n        return res > Integer.MAX_VALUE ? Integer.MAX_VALUE:(int) res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2799103,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        vector<string> ans;\\n        recursion(ans, num, target, \"\", 0, 0, 0 );\\n        return ans;\\n    }\\n    \\n    void recursion(vector<string>& ans, const string& num, const int& target, string expression, int idx, int prevNum, long long curTotal){\\n        int n = num.size();\\n        if(idx==n){\\n            if(curTotal==target){\\n                ans.push_back(expression);\\n            }\\n            return;\\n        }\\n        string curNumStr = \"\";\\n        long long curNum = 0;\\n        for(int i = idx; i<n; i++){\\n            if(i>idx && num[idx]==\\'0\\')break;\\n            curNumStr+=num[i];\\n            curNum = curNum*10+(num[i]-\\'0\\');\\n            // 2345\\n            if(idx==0){\\n                recursion(ans, num, target, expression+curNumStr, i+1, curNum, curTotal+curNum);\\n            }\\n            else{\\n                recursion(ans, num, target, expression+\"+\"+curNumStr, i+1, curNum, curTotal+curNum);\\n                recursion(ans, num, target, expression+\"-\"+curNumStr, i+1, -curNum, curTotal-curNum);\\n                recursion(ans, num, target, expression+\"*\"+curNumStr, i+1, prevNum*curNum, curTotal-prevNum+prevNum*curNum);\\n            }\\n        }\\n    }\\n    \\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        vector<string> ans;\\n        recursion(ans, num, target, \"\", 0, 0, 0 );\\n        return ans;\\n    }\\n    \\n    void recursion(vector<string>& ans, const string& num, const int& target, string expression, int idx, int prevNum, long long curTotal){\\n        int n = num.size();\\n        if(idx==n){\\n            if(curTotal==target){\\n                ans.push_back(expression);\\n            }\\n            return;\\n        }\\n        string curNumStr = \"\";\\n        long long curNum = 0;\\n        for(int i = idx; i<n; i++){\\n            if(i>idx && num[idx]==\\'0\\')break;\\n            curNumStr+=num[i];\\n            curNum = curNum*10+(num[i]-\\'0\\');\\n            // 2345\\n            if(idx==0){\\n                recursion(ans, num, target, expression+curNumStr, i+1, curNum, curTotal+curNum);\\n            }\\n            else{\\n                recursion(ans, num, target, expression+\"+\"+curNumStr, i+1, curNum, curTotal+curNum);\\n                recursion(ans, num, target, expression+\"-\"+curNumStr, i+1, -curNum, curTotal-curNum);\\n                recursion(ans, num, target, expression+\"*\"+curNumStr, i+1, prevNum*curNum, curTotal-prevNum+prevNum*curNum);\\n            }\\n        }\\n    }\\n    \\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71950,
                "title": "typical-backtracking-solution-with-detailed-explanation-in-c",
                "content": "### Solution\\n\\n#### Analysis\\nTypical backtracking problem as it is. Try to split the string into small blocks and then meantime try different operators among them.\\n\\n- from a starting position, we can try different valid length for the current number but if the length is bigger than 1 and the first digit is zero then just stop;\\n- using different operators to connect the current number, calculate and then store them in a temporary string for the next number till the end;\\n- but when we try `*`, we have to be more careful since multiplier will associate its previous number and has higher precedence, so we as a result have to record its previous number; but this will require us to handle it delicately when we are inserting `+ or -`, as for `+` we can just put the number as previous but as to `-`, we will need to set `-number` as previous; because we have to subtract the previous number first when inserting `*` - inserting means we are do the calculation with the current number here;\\n- since the target is an `int`, so when the number is larger than INT_MAX, we should just stop there.\\n\\n#### Improvements\\n- there will be numbers collected larger than INT_MAX, so we have to adopt `long` - long long here is unnecessary;\\n- collecting the number one character at a time is more efficient to convert the substring directly to integer using `stol`;\\n- using temporary substring to replace `to_string(number)` will save lots of converting time;\\n- actually we can just use one temporary string and append the digit instead of retrieving the substring each time.\\n\\nThe whole solution in C++ is as follows.\\n\\n```\\nclass Solution {\\nprivate:\\n    int sLen;\\n    void traverse(const string s, int pos, long current, long pre, int sum, string path, vector<string>& v)\\n    {\\n        if(sLen == pos) { if(current == sum) v.push_back(path); return ; }\\n        long num = 0;\\n        string t;\\n        for(int i = pos; i < sLen; ++i)\\n        {\\n            if(i-pos>0 && s[pos]=='0') return ;\\n            t += s[i];\\n            num = 10*num + s[i]-'0';\\n            if(num > INT_MAX) return ;\\n            if(pos == 0) traverse(s, i+1, num, num, sum, t, v);\\n            else\\n            {\\n                traverse(s, i+1, current+num, num, sum, path+\"+\"+t, v);\\n                traverse(s, i+1, current-num, -num, sum, path+\"-\"+t, v);\\n                traverse(s, i+1, current-pre+pre*num, pre*num, sum, path+\"*\"+t, v);\\n            }\\n        }\\n    }\\npublic:\\n    vector<string> addOperators(string s, int target) {\\n        sLen = s.length();\\n        vector<string> v;\\n        traverse(s, 0, 0, 0, target, \"\", v);\\n        return v;\\n    }\\n};\\n```\\n\\n\\nAlways welcome new ideas and `practical` tricks, just leave them in the comments!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int sLen;\\n    void traverse(const string s, int pos, long current, long pre, int sum, string path, vector<string>& v)\\n    {\\n        if(sLen == pos) { if(current == sum) v.push_back(path); return ; }\\n        long num = 0;\\n        string t;\\n        for(int i = pos; i < sLen; ++i)\\n        {\\n            if(i-pos>0 && s[pos]=='0') return ;\\n            t += s[i];\\n            num = 10*num + s[i]-'0';\\n            if(num > INT_MAX) return ;\\n            if(pos == 0) traverse(s, i+1, num, num, sum, t, v);\\n            else\\n            {\\n                traverse(s, i+1, current+num, num, sum, path+\"+\"+t, v);\\n                traverse(s, i+1, current-num, -num, sum, path+\"-\"+t, v);\\n                traverse(s, i+1, current-pre+pre*num, pre*num, sum, path+\"*\"+t, v);\\n            }\\n        }\\n    }\\npublic:\\n    vector<string> addOperators(string s, int target) {\\n        sLen = s.length();\\n        vector<string> v;\\n        traverse(s, 0, 0, 0, target, \"\", v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236396,
                "title": "282-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nStep-by-step explanation:\\n\\n1. The input to the function is a string num and an integer target, representing the number to be expressed and the target value to be achieved, respectively.\\n2. The function initializes an empty list ans to store all possible expressions that evaluate to the target value.\\n3. The function defines a DFS (depth-first search) function dfs to generate all possible expressions.\\n4. The DFS function takes four parameters: start represents the current index in the string num, prev represents the previous operand value, eval represents the current evaluated value, and path represents the list of operands and operators that form the current expression.\\n5. The DFS function uses recursion to generate all possible expressions. At each recursive call, it evaluates the expression formed so far, and if the evaluation equals the target value, it adds the expression to the answer list.\\n6. The DFS function iterates over all possible operands starting from the current index start, and for each operand, it iterates over all possible operators (+, -, *) and generates new expressions by appending the current operand and operator to the current path, and updating the previous operand value, evaluated value, and current index accordingly.\\n7. The DFS function terminates when the current index reaches the end of the string num.\\n8. The main function addOperators starts the DFS with initial parameters start=0, prev=0, eval=0, and path=[], and\\n# Complexity\\n- Time complexity:\\n87.49%\\n\\n- Space complexity:\\n78.86%\\n\\n# Code\\n```\\nclass Solution:\\n  def addOperators(self, num: str, target: int) -> List[str]:\\n    ans = [] # list to store all possible expressions that evaluate to the target\\n\\n    # DFS function to generate all possible expressions\\n    # start: current index in num\\n    # prev: previous operand value\\n    # eval: current evaluated value\\n    # path: list to store current expression\\n    def dfs(start: int, prev: int, eval: int, path: List[str]) -> None:\\n      # base case: reached end of num\\n      if start == len(num):\\n        # check if current evaluation equals target\\n        if eval == target:\\n          # add current expression to the answer list\\n          ans.append(\\'\\'.join(path))\\n        return\\n\\n      # iterate over all possible operands from current index\\n      for i in range(start, len(num)):\\n        # special case: ignore operands starting with 0, except 0 itself\\n        if i > start and num[start] == \\'0\\':\\n          return\\n        s = num[start:i + 1]\\n        curr = int(s)\\n        # special case: first operand, simply add it to the path and evaluate\\n        if start == 0:\\n          path.append(s)\\n          dfs(i + 1, curr, curr, path)\\n          path.pop()\\n        # general case: iterate over all possible operators and operands\\n        else:\\n          for op in [\\'+\\', \\'-\\', \\'*\\']:\\n            path.append(op + s)\\n            # addition: add current operand to evaluated value\\n            if op == \\'+\\':\\n              dfs(i + 1, curr, eval + curr, path)\\n            # subtraction: subtract current operand from evaluated value\\n            elif op == \\'-\\':\\n              dfs(i + 1, -curr, eval - curr, path)\\n            # multiplication: multiply current operand with previous operand and update evaluated value\\n            else:\\n              dfs(i + 1, prev * curr, eval - prev + prev * curr, path)\\n            path.pop()\\n\\n    # start DFS with initial parameters\\n    dfs(0, 0, 0, [])\\n    return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n  def addOperators(self, num: str, target: int) -> List[str]:\\n    ans = [] # list to store all possible expressions that evaluate to the target\\n\\n    # DFS function to generate all possible expressions\\n    # start: current index in num\\n    # prev: previous operand value\\n    # eval: current evaluated value\\n    # path: list to store current expression\\n    def dfs(start: int, prev: int, eval: int, path: List[str]) -> None:\\n      # base case: reached end of num\\n      if start == len(num):\\n        # check if current evaluation equals target\\n        if eval == target:\\n          # add current expression to the answer list\\n          ans.append(\\'\\'.join(path))\\n        return\\n\\n      # iterate over all possible operands from current index\\n      for i in range(start, len(num)):\\n        # special case: ignore operands starting with 0, except 0 itself\\n        if i > start and num[start] == \\'0\\':\\n          return\\n        s = num[start:i + 1]\\n        curr = int(s)\\n        # special case: first operand, simply add it to the path and evaluate\\n        if start == 0:\\n          path.append(s)\\n          dfs(i + 1, curr, curr, path)\\n          path.pop()\\n        # general case: iterate over all possible operators and operands\\n        else:\\n          for op in [\\'+\\', \\'-\\', \\'*\\']:\\n            path.append(op + s)\\n            # addition: add current operand to evaluated value\\n            if op == \\'+\\':\\n              dfs(i + 1, curr, eval + curr, path)\\n            # subtraction: subtract current operand from evaluated value\\n            elif op == \\'-\\':\\n              dfs(i + 1, -curr, eval - curr, path)\\n            # multiplication: multiply current operand with previous operand and update evaluated value\\n            else:\\n              dfs(i + 1, prev * curr, eval - prev + prev * curr, path)\\n            path.pop()\\n\\n    # start DFS with initial parameters\\n    dfs(0, 0, 0, [])\\n    return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471816,
                "title": "10-lines-clean-and-easy-to-understand-solution-in-c",
                "content": "General idea would be the same as most solution but the code is much more clean, concise and easier to understand than most of the top voted solution. \\n\\nKey idea to make everything more concise is to separate the multiplier accumulated using a variable.\\n\\n```\\nclass Solution {\\nprivate:\\n    string num;\\n    int target;\\n    vector<string> allAnswer;\\n    \\npublic:\\n\\t/*\\n\\t\\ti:          current index of num to operates on\\n\\t\\texpression: current expression so far\\n\\t\\tsum:        the partial sum before the last \\'+\\' or \\'-\\' operators\\n\\t\\tcurNum:     the last operand\\n\\t\\tmultiplier: the multiplier to the last operand\\n\\t*/\\n    void add(int i, string expression, long long sum, long long curNum, long long multiplier) {\\n        if(i == num.size()) {\\n            if(sum + multiplier * curNum == target)\\n                allAnswer.push_back(expression);\\n            return;\\n        }\\n        \\n        if(curNum != 0)\\n            add(i+1, expression + num[i], sum, curNum * 10 + (num[i]-\\'0\\'), multiplier);\\n        \\n        add(i+1, expression + \"+\" + num[i], sum + multiplier * curNum, num[i]-\\'0\\', 1);\\n        add(i+1, expression + \"-\" + num[i], sum + multiplier * curNum, num[i]-\\'0\\', -1);\\n        add(i+1, expression + \"*\" + num[i], sum, num[i]-\\'0\\', multiplier * curNum);\\n    };\\n    \\n    vector<string> addOperators(string num, int target) {\\n        this->num = num;\\n        this->target = target;\\n        \\n        add(1, num.substr(0, 1), 0, num[0]-\\'0\\', 1);\\n        return allAnswer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    string num;\\n    int target;\\n    vector<string> allAnswer;\\n    \\npublic:\\n\\t/*\\n\\t\\ti:          current index of num to operates on\\n\\t\\texpression: current expression so far\\n\\t\\tsum:        the partial sum before the last \\'+\\' or \\'-\\' operators\\n\\t\\tcurNum:     the last operand\\n\\t\\tmultiplier: the multiplier to the last operand\\n\\t*/\\n    void add(int i, string expression, long long sum, long long curNum, long long multiplier) {\\n        if(i == num.size()) {\\n            if(sum + multiplier * curNum == target)\\n                allAnswer.push_back(expression);\\n            return;\\n        }\\n        \\n        if(curNum != 0)\\n            add(i+1, expression + num[i], sum, curNum * 10 + (num[i]-\\'0\\'), multiplier);\\n        \\n        add(i+1, expression + \"+\" + num[i], sum + multiplier * curNum, num[i]-\\'0\\', 1);\\n        add(i+1, expression + \"-\" + num[i], sum + multiplier * curNum, num[i]-\\'0\\', -1);\\n        add(i+1, expression + \"*\" + num[i], sum, num[i]-\\'0\\', multiplier * curNum);\\n    };\\n    \\n    vector<string> addOperators(string num, int target) {\\n        this->num = num;\\n        this->target = target;\\n        \\n        add(1, num.substr(0, 1), 0, num[0]-\\'0\\', 1);\\n        return allAnswer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470261,
                "title": "python3-a-super-easy-cheat-solution-a-general-approach-for-all-languages",
                "content": "Using the `eval` function makes this question from hard to medium.\\n- `i` is the current index\\n- `s` is the current temporary string\\n- leading is the leading character, right after \\n\\t- the start, or,\\n\\t- an operator like `+` or `-` or `*`\\n\\n`leading` is important since it let\\'s us skip over sequences starting from 0, as in `05` or `009`. And the rest is classic recursion.\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        ans = []\\n        def recurse(i, s, leading):\\n            if i > n-1:\\n                if eval(s) == target:\\n                    ans.append(s)\\n                return\\n            \\n            if leading != \\'0\\':\\n                recurse(i+1, s+num[i], leading)\\n            recurse(i+1, s+\"+\"+num[i], num[i])\\n            recurse(i+1, s+\"-\"+num[i], num[i])\\n            recurse(i+1, s+\"*\"+num[i], num[i])\\n            \\n        recurse(1, num[0], num[0])\\n        \\n        return ans\\n```\\n\\nWe can do a manual computation for `eval` and write our own function\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        def evaluate(s):\\n            a = []\\n            temp = \"\"\\n            for c in s:\\n                if \\'0\\' <= c <= \\'9\\': \\n                    temp += c\\n                else:\\n                    a.append(int(temp))\\n                    a.append(c)\\n                    temp = \"\"\\n            a.append(int(temp))\\n            \\n            total = a[0]\\n            prev = a[0]\\n            for i in range(len(a)-1):\\n                item = a[i]\\n                if item == \\'+\\':\\n                    total = total + a[i+1]\\n                    prev = a[i+1]\\n                elif item == \\'-\\':\\n                    total = total - a[i+1]\\n                    prev = -a[i+1]\\n                elif item == \\'*\\':\\n                    total = total - prev + prev * a[i+1]\\n                    prev = prev * a[i+1]\\n            return total\\n        \\n        n = len(num)\\n        ans = []\\n        def recurse(i, s, leading):\\n            if i > n-1:\\n                if evaluate(s) == target:\\n                    ans.append(s)\\n                return\\n            \\n            if leading != \\'0\\':\\n                recurse(i+1, s+num[i], leading)\\n            recurse(i+1, s+\"+\"+num[i], num[i])\\n            recurse(i+1, s+\"-\"+num[i], num[i])\\n            recurse(i+1, s+\"*\"+num[i], num[i])\\n            \\n            \\n        \\n        recurse(1, num[0], num[0])\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        ans = []\\n        def recurse(i, s, leading):\\n            if i > n-1:\\n                if eval(s) == target:\\n                    ans.append(s)\\n                return\\n            \\n            if leading != \\'0\\':\\n                recurse(i+1, s+num[i], leading)\\n            recurse(i+1, s+\"+\"+num[i], num[i])\\n            recurse(i+1, s+\"-\"+num[i], num[i])\\n            recurse(i+1, s+\"*\"+num[i], num[i])\\n            \\n        recurse(1, num[0], num[0])\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        def evaluate(s):\\n            a = []\\n            temp = \"\"\\n            for c in s:\\n                if \\'0\\' <= c <= \\'9\\': \\n                    temp += c\\n                else:\\n                    a.append(int(temp))\\n                    a.append(c)\\n                    temp = \"\"\\n            a.append(int(temp))\\n            \\n            total = a[0]\\n            prev = a[0]\\n            for i in range(len(a)-1):\\n                item = a[i]\\n                if item == \\'+\\':\\n                    total = total + a[i+1]\\n                    prev = a[i+1]\\n                elif item == \\'-\\':\\n                    total = total - a[i+1]\\n                    prev = -a[i+1]\\n                elif item == \\'*\\':\\n                    total = total - prev + prev * a[i+1]\\n                    prev = prev * a[i+1]\\n            return total\\n        \\n        n = len(num)\\n        ans = []\\n        def recurse(i, s, leading):\\n            if i > n-1:\\n                if evaluate(s) == target:\\n                    ans.append(s)\\n                return\\n            \\n            if leading != \\'0\\':\\n                recurse(i+1, s+num[i], leading)\\n            recurse(i+1, s+\"+\"+num[i], num[i])\\n            recurse(i+1, s+\"-\"+num[i], num[i])\\n            recurse(i+1, s+\"*\"+num[i], num[i])\\n            \\n            \\n        \\n        recurse(1, num[0], num[0])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1275613,
                "title": "recursive-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> result;\\n\\n    vector<string> addOperators(string num, int target) \\n    {     \\n        solve(num, target, 0, \"\", 0, 0);\\n        return result;\\n    }\\n    \\n    void solve(string num, int target, int start, string str, long sum, long last)\\n    {\\n        if(num.size() == start)\\n        {\\n            if(target == sum)\\n                result.push_back(str);\\n            return;\\n        }\\n        \\n        long x = 0;\\n        string ret = \"\";\\n        \\n        for(int i=start; i<num.size(); ++i)\\n        {\\n            x = x*10 + num[i]-\\'0\\';\\n            ret += num[i]; \\n            \\n            if(start == 0)\\n                solve(num, target, i+1, str+ret, x, x);\\n            \\n            else\\n            {\\n                solve(num, target, i+1, str+\"*\"+ret, sum-last+x*last, x*last);\\n                solve(num, target, i+1, str+\"+\"+ret, sum+x, x);\\n                solve(num, target, i+1, str+\"-\"+ret, sum-x, -x);\\n            } \\n            \\n            if(x == 0)\\n                break; \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> result;\\n\\n    vector<string> addOperators(string num, int target) \\n    {     \\n        solve(num, target, 0, \"\", 0, 0);\\n        return result;\\n    }\\n    \\n    void solve(string num, int target, int start, string str, long sum, long last)\\n    {\\n        if(num.size() == start)\\n        {\\n            if(target == sum)\\n                result.push_back(str);\\n            return;\\n        }\\n        \\n        long x = 0;\\n        string ret = \"\";\\n        \\n        for(int i=start; i<num.size(); ++i)\\n        {\\n            x = x*10 + num[i]-\\'0\\';\\n            ret += num[i]; \\n            \\n            if(start == 0)\\n                solve(num, target, i+1, str+ret, x, x);\\n            \\n            else\\n            {\\n                solve(num, target, i+1, str+\"*\"+ret, sum-last+x*last, x*last);\\n                solve(num, target, i+1, str+\"+\"+ret, sum+x, x);\\n                solve(num, target, i+1, str+\"-\"+ret, sum-x, -x);\\n            } \\n            \\n            if(x == 0)\\n                break; \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395651,
                "title": "python-solution-with-step-by-step-inline-explanation",
                "content": "```python\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:        \\n        def recurse(i, pre, cur, val, eq):\\n            \"\"\"\\n            There are four types of operations:\\n                1. Digit concatenation to form a number\\n                2. Addition\\n                3. Subtraction\\n                4. Multiplication\\n\\n            i int: cursor\\n            pre int: previous operand\\n            cur int: current operand\\n            val int: final result so far\\n            eq list: equation components\\n            \"\"\"\\n            # when the cursor reaches to the end of the given string\\n            if i == len(num):\\n                # we check:\\n                #   1. if the final result is equal to the target\\n                #   2. if the current operand is already evaluated\\n                # if both requirements met, the equation is qualified\\n                if val == target and cur == 0:\\n                    res.append(\\'\\'.join(map(str, eq[1:])))\\n                return\\n            \\n            # append the new digit to the current operand\\n            cur = cur * 10 + int(num[i])\\n            i += 1\\n\\n            # 1. Digit concatenation\\n            # it is only possible when the current operand is greater than 0, in \\n            # which case the operand is led by a non-zero digit. \\n            if cur > 0:\\n                # by concatenating digits, the previous operand, final result and \\n                # equation remain the same, while the current operand is updated \\n                # but yet evaluated\\n                recurse(i, pre, cur, val, eq)\\n            \\n            # For the rest operations, the current operand will be evaluated w/ \\n            # different operators, and the result will be reflected in the final \\n            # result and the equation. Meanwhile, the current operand will be \\n            # used as the previous operand for the next recursion\\n\\n            # 2. Addition\\n            # append the addition sign and current operand to the equation\\n            eq += [\\'+\\', cur]\\n            # add the current operand to the final result, use it as the \\n            # previous operand and clear the current operand for the next \\n            # recursion\\n            recurse(i, cur, 0, val + cur, eq)\\n            # pop out the previous oprand and operator to reuse the equation \\n            # list\\n            eq.pop()\\n            eq.pop()\\n            \\n            # note that the first operand in the equation is treated as being \\n            # added to 0. So for the first operand, only addition is available. \\n            # When the equation is empty, it means the first operand is being \\n            # dealt with, and we should stop here\\n            if not eq:\\n                return\\n            \\n            # 3. Subtraction\\n            eq += [\\'-\\', cur]\\n            # similar to addition, but we subtract the current operand from the \\n            # final result, and use the reverse of the current operand as the \\n            # previous operand for the next recursion\\n            recurse(i, -cur, 0, val - cur, eq)\\n            eq.pop()\\n            eq.pop()\\n            \\n            # 4. Multiplication\\n            eq += [\\'*\\', cur]\\n            # the key difference is that multiplication has the priority over \\n            # additions and subtractions, and it is commutative (i.e. the order \\n            # of the operands doesn\\'t matter). Hence, regardless of the type of \\n            # operation done previously, we always reverse it and prioritize the \\n            # evaluation of the current one, since it enforces the priority if \\n            # the previous operation is addition or subtraction, but do no harm \\n            # if multiplication (`a*b*c` will becomes `c*b*a`, which gives the \\n            # same result)\\n            cur *= pre \\n            # in practice, we subtract the previous operand from the final \\n            # result to reverse the previous operation and multiply it with the \\n            # current one. Then we add the result to the final result. \\n            recurse(i, cur, 0, val - pre + cur, eq)\\n            eq.pop()\\n            eq.pop()\\n        \\n        res = []\\n        recurse(0, 0, 0, 0, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:        \\n        def recurse(i, pre, cur, val, eq):\\n            \"\"\"\\n            There are four types of operations:\\n                1. Digit concatenation to form a number\\n                2. Addition\\n                3. Subtraction\\n                4. Multiplication\\n\\n            i int: cursor\\n            pre int: previous operand\\n            cur int: current operand\\n            val int: final result so far\\n            eq list: equation components\\n            \"\"\"\\n            # when the cursor reaches to the end of the given string\\n            if i == len(num):\\n                # we check:\\n                #   1. if the final result is equal to the target\\n                #   2. if the current operand is already evaluated\\n                # if both requirements met, the equation is qualified\\n                if val == target and cur == 0:\\n                    res.append(\\'\\'.join(map(str, eq[1:])))\\n                return\\n            \\n            # append the new digit to the current operand\\n            cur = cur * 10 + int(num[i])\\n            i += 1\\n\\n            # 1. Digit concatenation\\n            # it is only possible when the current operand is greater than 0, in \\n            # which case the operand is led by a non-zero digit. \\n            if cur > 0:\\n                # by concatenating digits, the previous operand, final result and \\n                # equation remain the same, while the current operand is updated \\n                # but yet evaluated\\n                recurse(i, pre, cur, val, eq)\\n            \\n            # For the rest operations, the current operand will be evaluated w/ \\n            # different operators, and the result will be reflected in the final \\n            # result and the equation. Meanwhile, the current operand will be \\n            # used as the previous operand for the next recursion\\n\\n            # 2. Addition\\n            # append the addition sign and current operand to the equation\\n            eq += [\\'+\\', cur]\\n            # add the current operand to the final result, use it as the \\n            # previous operand and clear the current operand for the next \\n            # recursion\\n            recurse(i, cur, 0, val + cur, eq)\\n            # pop out the previous oprand and operator to reuse the equation \\n            # list\\n            eq.pop()\\n            eq.pop()\\n            \\n            # note that the first operand in the equation is treated as being \\n            # added to 0. So for the first operand, only addition is available. \\n            # When the equation is empty, it means the first operand is being \\n            # dealt with, and we should stop here\\n            if not eq:\\n                return\\n            \\n            # 3. Subtraction\\n            eq += [\\'-\\', cur]\\n            # similar to addition, but we subtract the current operand from the \\n            # final result, and use the reverse of the current operand as the \\n            # previous operand for the next recursion\\n            recurse(i, -cur, 0, val - cur, eq)\\n            eq.pop()\\n            eq.pop()\\n            \\n            # 4. Multiplication\\n            eq += [\\'*\\', cur]\\n            # the key difference is that multiplication has the priority over \\n            # additions and subtractions, and it is commutative (i.e. the order \\n            # of the operands doesn\\'t matter). Hence, regardless of the type of \\n            # operation done previously, we always reverse it and prioritize the \\n            # evaluation of the current one, since it enforces the priority if \\n            # the previous operation is addition or subtraction, but do no harm \\n            # if multiplication (`a*b*c` will becomes `c*b*a`, which gives the \\n            # same result)\\n            cur *= pre \\n            # in practice, we subtract the previous operand from the final \\n            # result to reverse the previous operation and multiply it with the \\n            # current one. Then we add the result to the final result. \\n            recurse(i, cur, 0, val - pre + cur, eq)\\n            eq.pop()\\n            eq.pop()\\n        \\n        res = []\\n        recurse(0, 0, 0, 0, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191083,
                "title": "python-backtracking-solution-beating-95-with-time-complexity-proof",
                "content": "```python\\nclass Solution(object):\\n    ans = []\\n    \\n    def addOperators(self, num, target):\\n        \"\"\"\\n        This is one clarification in this question i.e. a number can\\'t start with 0. Like if we are given 105 and target\\n        5, 1 X 05 is not possible. It\\'s a simple backtracking algorithm without any optimization or DP.\\n        \\n        Proof Of Runtime is given in is given below i.e.\\n        \\n        T(N) = Total Number of Valid Expressions = 3 * 4^(N - 2) so that\\'s why runtime is O(4^N). \\n        \\n\\tRun Time complexity can also been proved by following intuitive approach.\\n\\t\\t\\t\\t\\n        If we just allow single digits so each digit can have 3 possible operators before it i.e. +, -, *\\n        which means total number of combinations to be checked are O(3^N). If we allow non-single digits as well then\\n        each digit has 4 possible values before it i.e. +, -, *, None. None means we don\\'t have any operations before\\n        digit and current digit is considered part of previous digit and they both form a number. So total combinations\\n        to be checked are O(4^N)\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        self.ans = []\\n        num = list(map(int, list(num)))\\n        \\n        def __addOperators(exp_val=0, last_val=0, index=0, prefix=\"\"):\\n            if index < len(num):\\n                number = 0\\n                prev_index = index\\n                while index < len(num):\\n                    number *= 10\\n                    number += num[index]\\n                    \\n                    if not prefix:\\n                        __addOperators(exp_val + number, number, index + 1, str(number))\\n                    else:\\n                        new_prefix = prefix + \\'{}\\' + str(number)\\n                        __addOperators(exp_val + number, number, index + 1, new_prefix.format(\\'+\\'))\\n                        __addOperators(exp_val - number, -1 * number, index + 1, new_prefix.format(\\'-\\'))\\n\\n                        multiply_val = exp_val + last_val * (number - 1)\\n                        __addOperators(multiply_val, last_val * number, index + 1, new_prefix.format(\\'*\\'))\\n                    \\n                    if prev_index == index and number == 0:\\n                        break\\n                    else:\\n                        index += 1\\n            elif exp_val == target:\\n                self.ans.append(prefix)\\n                \\n        \\n        if num:\\n            __addOperators()\\n        \\n        print(len(self.ans))\\n        return self.ans\\n        \\n```\\n\\n\\n#### Run Time\\n\\nTotal number of valid expressions as per author are O(N^2 x 3^N). But following proof says otherwise.\\n\\nT(N) = Total Number of Valid Expressions\\n\\nT(N) = 3T(N - 1) + 3T(N - 2) + 3T(N - 3) + .... 3T(0)\\n\\nIf we use first digit as an operand, total number of valid expressions would be T(N - 1) x 3. Three accounts\\nfor our three operations. If we use first two digits as an operand, total number of valid expressions would be T(N - 2) x 3 and so on.\\n\\nNow T(N - 1) = 3T(N - 2) + 3T(N - 3) + 3T(N - 4) + .... 3T(0)\\n\\nif we put T(N - 1) in T(N) we\\'ll get\\n\\nT(N) = 3 x 4 ( T(N - 2) + T(N - 3) + T(N - 4) + .... T(0) )\\n\\nIf we put T(N - 2) in T(N) we\\'ll get\\n\\nT(N) = 3 x 4^2 ( T(N - 3) + T(N - 4) + T(N - 5) + .... T(0) )\\n\\nIf we generalize it, we\\'ll get\\n\\nT(N) = 3 x 4^k ( T(N - (k + 1)) + T(N - (k + 2)) + .... T(0))\\n\\nIf we put k = N - 1, we\\'ll get\\n\\nT(N) = 3 x 4^(N - 1) (T(0)) = O(4^N)\\n\\nSo Total valid expressions are O(4^N). Not sure how author deduced O(N^2 x 3^N)\\n\\nFor the worst case of an array of 0s and target 0, length of our output would be O(4^N). I\\'m not sure then how author is claiming a O(N^2 x 3^N) runtime.\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    ans = []\\n    \\n    def addOperators(self, num, target):\\n        \"\"\"\\n        This is one clarification in this question i.e. a number can\\'t start with 0. Like if we are given 105 and target\\n        5, 1 X 05 is not possible. It\\'s a simple backtracking algorithm without any optimization or DP.\\n        \\n        Proof Of Runtime is given in is given below i.e.\\n        \\n        T(N) = Total Number of Valid Expressions = 3 * 4^(N - 2) so that\\'s why runtime is O(4^N). \\n        \\n\\tRun Time complexity can also been proved by following intuitive approach.\\n\\t\\t\\t\\t\\n        If we just allow single digits so each digit can have 3 possible operators before it i.e. +, -, *\\n        which means total number of combinations to be checked are O(3^N). If we allow non-single digits as well then\\n        each digit has 4 possible values before it i.e. +, -, *, None. None means we don\\'t have any operations before\\n        digit and current digit is considered part of previous digit and they both form a number. So total combinations\\n        to be checked are O(4^N)\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        self.ans = []\\n        num = list(map(int, list(num)))\\n        \\n        def __addOperators(exp_val=0, last_val=0, index=0, prefix=\"\"):\\n            if index < len(num):\\n                number = 0\\n                prev_index = index\\n                while index < len(num):\\n                    number *= 10\\n                    number += num[index]\\n                    \\n                    if not prefix:\\n                        __addOperators(exp_val + number, number, index + 1, str(number))\\n                    else:\\n                        new_prefix = prefix + \\'{}\\' + str(number)\\n                        __addOperators(exp_val + number, number, index + 1, new_prefix.format(\\'+\\'))\\n                        __addOperators(exp_val - number, -1 * number, index + 1, new_prefix.format(\\'-\\'))\\n\\n                        multiply_val = exp_val + last_val * (number - 1)\\n                        __addOperators(multiply_val, last_val * number, index + 1, new_prefix.format(\\'*\\'))\\n                    \\n                    if prev_index == index and number == 0:\\n                        break\\n                    else:\\n                        index += 1\\n            elif exp_val == target:\\n                self.ans.append(prefix)\\n                \\n        \\n        if num:\\n            __addOperators()\\n        \\n        print(len(self.ans))\\n        return self.ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 146166,
                "title": "swift-4-1-2",
                "content": "```\\nclass Solution {\\n    \\n    var res = [String]()\\n    func addOperators(_ num: String, _ target: Int) -> [String] {\\n        guard num.count != 0 else { return [] }\\n        search(num, num.startIndex, \"\", target, 0, 0)\\n        return res\\n    }\\n    \\n    func search(_ num: String, _ start: String.Index, _ path: String, _ target: Int, _ sum: Int, _ last: Int) {\\n        \\n        if start == num.endIndex {\\n            if target == sum {\\n                res.append(path)\\n            }\\n            return\\n        }\\n        \\n        var index = start\\n        while index < num.endIndex {\\n            let x = Int(String(num[start...index]))!\\n            \\n            if start == num.startIndex {\\n                search(num, num.index(after: index), String(x), target, x, x)\\n            }\\n            else {\\n                search(num, num.index(after: index), path + \"*\" + String(x), target, sum - last + last * x, last * x)\\n                search(num, num.index(after: index), path + \"+\" + String(x), target, sum + x, x)\\n                search(num, num.index(after: index), path + \"-\" + String(x), target, sum - x, -x)\\n            }\\n            \\n            if x == 0 {\\n                break\\n            }\\n            \\n            index = num.index(after: index)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    var res = [String]()\\n    func addOperators(_ num: String, _ target: Int) -> [String] {\\n        guard num.count != 0 else { return [] }\\n        search(num, num.startIndex, \"\", target, 0, 0)\\n        return res\\n    }\\n    \\n    func search(_ num: String, _ start: String.Index, _ path: String, _ target: Int, _ sum: Int, _ last: Int) {\\n        \\n        if start == num.endIndex {\\n            if target == sum {\\n                res.append(path)\\n            }\\n            return\\n        }\\n        \\n        var index = start\\n        while index < num.endIndex {\\n            let x = Int(String(num[start...index]))!\\n            \\n            if start == num.startIndex {\\n                search(num, num.index(after: index), String(x), target, x, x)\\n            }\\n            else {\\n                search(num, num.index(after: index), path + \"*\" + String(x), target, sum - last + last * x, last * x)\\n                search(num, num.index(after: index), path + \"+\" + String(x), target, sum + x, x)\\n                search(num, num.index(after: index), path + \"-\" + String(x), target, sum - x, -x)\\n            }\\n            \\n            if x == 0 {\\n                break\\n            }\\n            \\n            index = num.index(after: index)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128460,
                "title": "simple-python-dfs-that-beats-100",
                "content": "Scan number in num one by one. Each time seeing a new number we have 4 options:\\n1. add a +\\n2. add a - \\n3. add a *\\n4. append it to end of previous number\\nFor example, if current expression is 20+2 and we encounter 1, we can construct:\\n(1) 20+2+1\\n(2) 20+2-1\\n(3) 20+2*1\\n(4) 20+21\\nAll expressions can be expressed as the sum of another expression and a product of one or multiple numbers\\nExpr = Expr\\' + product, where Expr\\' can be null.\\n\\n```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        if not num:\\n            return []\\n        if len(num) == 1:\\n            if int(num) == target:\\n                return [num]\\n            return []\\n\\n        nums = [int(i) for i in num]\\n        res = []\\n        \\n        def dfs(i, expr, prod, prevSum, curr):\\n            \"\"\"\\n            previous result can be interpreted as: a product of a sequence of numbers + a prevous result\\n            :param i: position in num\\n            :param expr: current expression\\n            :param prod: current product, e.g. 2*1*3 for \\'2*4+0+2*1*3\\'\\n            :param prevSum: value of expression before product, e.g. 2*4+0=0 for \\'2*4+0+2*1*3\\'\\n            :param curr: most recent number, e.g. 21 in expression \\'20+21\\' \\n            \"\"\"\\n            if i == len(nums)-1:\\n                if prevSum + prod + nums[i] == target:\\n                    res.append(expr + \\'+\\' + str(nums[i]))\\n                if prevSum + prod - nums[i] == target:\\n                    res.append(expr + \\'-\\' + str(nums[i]))\\n                if prevSum + prod*nums[i] == target:\\n                    res.append(expr + \\'*\\' + str(nums[i]))\\n                # prod = prevProd*curr; \\n                # new_prod = prevProd*(curr*10+nums[i]) = 10*prod + prod//curr*nums[i]\\n                if curr and 10*prod + prod//curr*nums[i] + prevSum == target:\\n                    res.append(expr+str(nums[i]))\\n            else:\\n                dfs(i+1, expr+\\'+\\'+str(nums[i]), nums[i], prod+prevSum, nums[i])\\n                dfs(i+1, expr+\\'-\\'+str(nums[i]), -nums[i], prod+prevSum, nums[i])\\n                dfs(i+1, expr+\\'*\\'+str(nums[i]), nums[i]*prod, prevSum, nums[i])\\n                if curr:\\n                    # append nums[i] directly to last number, impossible when last number is 0\\n                    dfs(i+1, expr+str(nums[i]), 10*prod + prod//curr*nums[i], prevSum, 10*curr+nums[i])\\n        \\n        dfs(1, str(nums[0]), nums[0], 0, nums[0])\\n        return res\\n```\\n\\nRun time: 417ms(100%)",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        if not num:\\n            return []\\n        if len(num) == 1:\\n            if int(num) == target:\\n                return [num]\\n            return []\\n\\n        nums = [int(i) for i in num]\\n        res = []\\n        \\n        def dfs(i, expr, prod, prevSum, curr):\\n            \"\"\"\\n            previous result can be interpreted as: a product of a sequence of numbers + a prevous result\\n            :param i: position in num\\n            :param expr: current expression\\n            :param prod: current product, e.g. 2*1*3 for \\'2*4+0+2*1*3\\'\\n            :param prevSum: value of expression before product, e.g. 2*4+0=0 for \\'2*4+0+2*1*3\\'\\n            :param curr: most recent number, e.g. 21 in expression \\'20+21\\' \\n            \"\"\"\\n            if i == len(nums)-1:\\n                if prevSum + prod + nums[i] == target:\\n                    res.append(expr + \\'+\\' + str(nums[i]))\\n                if prevSum + prod - nums[i] == target:\\n                    res.append(expr + \\'-\\' + str(nums[i]))\\n                if prevSum + prod*nums[i] == target:\\n                    res.append(expr + \\'*\\' + str(nums[i]))\\n                # prod = prevProd*curr; \\n                # new_prod = prevProd*(curr*10+nums[i]) = 10*prod + prod//curr*nums[i]\\n                if curr and 10*prod + prod//curr*nums[i] + prevSum == target:\\n                    res.append(expr+str(nums[i]))\\n            else:\\n                dfs(i+1, expr+\\'+\\'+str(nums[i]), nums[i], prod+prevSum, nums[i])\\n                dfs(i+1, expr+\\'-\\'+str(nums[i]), -nums[i], prod+prevSum, nums[i])\\n                dfs(i+1, expr+\\'*\\'+str(nums[i]), nums[i]*prod, prevSum, nums[i])\\n                if curr:\\n                    # append nums[i] directly to last number, impossible when last number is 0\\n                    dfs(i+1, expr+str(nums[i]), 10*prod + prod//curr*nums[i], prevSum, 10*curr+nums[i])\\n        \\n        dfs(1, str(nums[0]), nums[0], 0, nums[0])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631886,
                "title": "python-3-282-expression-add-operators-t-m-87-88",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n\\n        def dfs(num: str, tmp: str, curr:int, prev:int) -> None:\\n            nonlocal target\\n            if not num:\\n                if curr == target:\\n                    ans.append(tmp)\\n                return\\n\\n            for i in range(len(num)):\\n                pref, suff = num[i+1:], num[:i+1]\\n                if i == 0 or i > 0 and num[0] != \"0\":\\n                    dfs(pref, tmp + \"+\" + suff, curr+int(suff), int(suff))\\n                    dfs(pref, tmp + \"-\" + suff, curr-int(suff), -int(suff))\\n                    dfs(pref, tmp + \"*\" + suff, curr-prev+prev*int(suff), prev*int(suff))\\n            return\\n\\n        ans, target = [], target\\n\\n        for i in range(len(num)):\\n            if i == 0 or i > 0 and num[0] != \\'0\\':\\n                dfs(num[i+1:], num[:i+1], int(num[:i+1]), int(num[:i+1]))\\n\\n        return ans\\n```\\n[https://leetcode.com/submissions/detail/809999125/](http://)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n\\n        def dfs(num: str, tmp: str, curr:int, prev:int) -> None:\\n            nonlocal target\\n            if not num:\\n                if curr == target:\\n                    ans.append(tmp)\\n                return\\n\\n            for i in range(len(num)):\\n                pref, suff = num[i+1:], num[:i+1]\\n                if i == 0 or i > 0 and num[0] != \"0\":\\n                    dfs(pref, tmp + \"+\" + suff, curr+int(suff), int(suff))\\n                    dfs(pref, tmp + \"-\" + suff, curr-int(suff), -int(suff))\\n                    dfs(pref, tmp + \"*\" + suff, curr-prev+prev*int(suff), prev*int(suff))\\n            return\\n\\n        ans, target = [], target\\n\\n        for i in range(len(num)):\\n            if i == 0 or i > 0 and num[0] != \\'0\\':\\n                dfs(num[i+1:], num[:i+1], int(num[:i+1]), int(num[:i+1]))\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726419,
                "title": "short-python-solution-using-backtracking-and-on-the-fly-evaluation",
                "content": "The idea is to iterate through the number string, form a number out of the digits encountered till that point, and test all three signs with that and the accumulated list of numbers, called the trace.\\n\\nI have tried to add comprehensive comments. However, if there is any lack of clarity or possible improvement, please feel free to comment.\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n\\t\\n        # Initializing the resulting list\\n        res = []\\n\\t\\t\\n        def backtrack(num, path, trace):\\n            nonlocal res\\n\\t\\t\\t\\n            # Here, we have reached the end of the number string, i.e., there is no digit left\\n            if not num:\\n                # Our trace contains only +ve/-ve numbers that can simply be summed up to get the evaluated value.\\n                # If the sum is equal to the target, we add the path (expression string) to the result list.\\n                if sum(trace) == target: res.append(path)\\n                return\\n\\t\\t\\t\\t\\n            # curr is the current value of the candidate integer\\n            # i is the position in the number string\\n            # Since we are passing only the remaining part of the String to the next recursive call, i starts from 0\\n            # rlim is the range which handles the case where we don\\'t include numbers with leading zeros like 05, 012 etc\\n            curr, i, rlim = 0, 0, len(num) if num[0] != \\'0\\' else 1\\n\\t\\t\\t\\n            # This loop iterates through the number string and includes a new digit into the candidate number at each iteration\\n            # This would ensure that we are trying 1, 12, 123 for a string that starts with \"123\"\\n            while i < rlim:\\n\\t\\t\\t\\n                curr = curr*10 + int(num[i])\\n                i += 1\\n\\t\\t\\t\\t\\n                # If we have already got some numbers, we enter this condition\\n                if trace:\\n                    # If the operation is simple \\'+\\' or \\'-\\', we can add the number with the sign to the trace\\n                    backtrack(num[i:], path+\\'+\\'+num[:i], trace+[curr])\\n                    backtrack(num[i:], path+\\'-\\'+num[:i], trace+[-curr])\\n                    # If the sign is *, we have to pick up the last element of the trace, multiply it with the current number, and append it back to the trace\\n                    backtrack(num[i:], path+\\'*\\'+num[:i], trace[:-1]+[curr*trace[-1]])\\n\\t\\t\\t\\t\\t\\n                # If there is no trace, we simply have to add the positive number to the same\\n                else:\\n                    backtrack(num[i:], num[:i], [curr])\\n\\t\\t\\t\\t\\t\\n        backtrack(num, \\'\\', [])\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n\\t\\n        # Initializing the resulting list\\n        res = []\\n\\t\\t\\n        def backtrack(num, path, trace):\\n            nonlocal res\\n\\t\\t\\t\\n            # Here, we have reached the end of the number string, i.e., there is no digit left\\n            if not num:\\n                # Our trace contains only +ve/-ve numbers that can simply be summed up to get the evaluated value.\\n                # If the sum is equal to the target, we add the path (expression string) to the result list.\\n                if sum(trace) == target: res.append(path)\\n                return\\n\\t\\t\\t\\t\\n            # curr is the current value of the candidate integer\\n            # i is the position in the number string\\n            # Since we are passing only the remaining part of the String to the next recursive call, i starts from 0\\n            # rlim is the range which handles the case where we don\\'t include numbers with leading zeros like 05, 012 etc\\n            curr, i, rlim = 0, 0, len(num) if num[0] != \\'0\\' else 1\\n\\t\\t\\t\\n            # This loop iterates through the number string and includes a new digit into the candidate number at each iteration\\n            # This would ensure that we are trying 1, 12, 123 for a string that starts with \"123\"\\n            while i < rlim:\\n\\t\\t\\t\\n                curr = curr*10 + int(num[i])\\n                i += 1\\n\\t\\t\\t\\t\\n                # If we have already got some numbers, we enter this condition\\n                if trace:\\n                    # If the operation is simple \\'+\\' or \\'-\\', we can add the number with the sign to the trace\\n                    backtrack(num[i:], path+\\'+\\'+num[:i], trace+[curr])\\n                    backtrack(num[i:], path+\\'-\\'+num[:i], trace+[-curr])\\n                    # If the sign is *, we have to pick up the last element of the trace, multiply it with the current number, and append it back to the trace\\n                    backtrack(num[i:], path+\\'*\\'+num[:i], trace[:-1]+[curr*trace[-1]])\\n\\t\\t\\t\\t\\t\\n                # If there is no trace, we simply have to add the positive number to the same\\n                else:\\n                    backtrack(num[i:], num[:i], [curr])\\n\\t\\t\\t\\t\\t\\n        backtrack(num, \\'\\', [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324527,
                "title": "worst-problem-i-have-seen-on-lc-took-me-3-hours-to-ac-java-backtracking",
                "content": "1. Just backtrack every possible combination\\n2. Maintain a set of outputs to avoid duplicacy\\n3. Keep track of previous operator and operand. This will help you reverse the previous action when you will encounter * operation.\\n\\nHappy to explain.\\n\\n```\\nclass Solution {\\n    final char[] operators = {\\'+\\', \\'-\\', \\'*\\'};\\n    public List<String> addOperators(String num, int target) {\\n        Set<String> result = new HashSet<>();\\n        util(result, new StringBuilder(), num, target, -1, 0, num.length(), 3, 0, true);\\n        return result.stream().collect(Collectors.toList());\\n    }\\n    \\n    private void util(Set<String> result, StringBuilder sb, String num, int target, int current, int start, int len, int operatorLen, int prev, boolean isPositive) {\\n        if(current == target && start == len) {\\n            result.add(sb.toString());\\n            return;\\n        }\\n        for(int i = start; i < len; ++i) {\\n            String tempStr = num.substring(start, i + 1);\\n            if(tempStr.length() > 1 && tempStr.charAt(0) == \\'0\\') continue;\\n            if(Long.parseLong(tempStr) > Integer.MAX_VALUE) continue;\\n            int currentNum = Integer.parseInt(tempStr);\\n            for(int j = 0; j < operatorLen; ++j) {\\n                int sbLen = sb.length();\\n                int prevCurrent = current;\\n                int prevPrev = prev;\\n                boolean prevIsPositive = isPositive;\\n                if(sbLen > 0) {\\n                    sb.append(operators[j]);\\n                    switch(operators[j]) {\\n                        case \\'+\\':\\n                            current += currentNum;\\n                            prev = currentNum;\\n                            isPositive = true;\\n                            break;\\n                        case \\'-\\':\\n                            current -= currentNum;\\n                            prev = currentNum;\\n                            isPositive = false;\\n                            break;\\n                        case \\'*\\':\\n                            if(isPositive) {\\n                                current -= prev;\\n                                prev *= currentNum;\\n                                current += (prev);\\n                            } else {\\n                                current += prev;\\n                                prev *= currentNum;\\n                                current -= (prev);\\n                            }\\n                            break;\\n                    }\\n                } else {\\n                    current = currentNum;\\n                    prev = currentNum;\\n                }\\n                sb.append(tempStr);\\n                util(result, sb, num, target, current, i + 1, len, operatorLen, prev, isPositive);\\n                sb.setLength(sbLen);\\n                current = prevCurrent;\\n                prev = prevPrev;\\n                isPositive = prevIsPositive;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    final char[] operators = {\\'+\\', \\'-\\', \\'*\\'};\\n    public List<String> addOperators(String num, int target) {\\n        Set<String> result = new HashSet<>();\\n        util(result, new StringBuilder(), num, target, -1, 0, num.length(), 3, 0, true);\\n        return result.stream().collect(Collectors.toList());\\n    }\\n    \\n    private void util(Set<String> result, StringBuilder sb, String num, int target, int current, int start, int len, int operatorLen, int prev, boolean isPositive) {\\n        if(current == target && start == len) {\\n            result.add(sb.toString());\\n            return;\\n        }\\n        for(int i = start; i < len; ++i) {\\n            String tempStr = num.substring(start, i + 1);\\n            if(tempStr.length() > 1 && tempStr.charAt(0) == \\'0\\') continue;\\n            if(Long.parseLong(tempStr) > Integer.MAX_VALUE) continue;\\n            int currentNum = Integer.parseInt(tempStr);\\n            for(int j = 0; j < operatorLen; ++j) {\\n                int sbLen = sb.length();\\n                int prevCurrent = current;\\n                int prevPrev = prev;\\n                boolean prevIsPositive = isPositive;\\n                if(sbLen > 0) {\\n                    sb.append(operators[j]);\\n                    switch(operators[j]) {\\n                        case \\'+\\':\\n                            current += currentNum;\\n                            prev = currentNum;\\n                            isPositive = true;\\n                            break;\\n                        case \\'-\\':\\n                            current -= currentNum;\\n                            prev = currentNum;\\n                            isPositive = false;\\n                            break;\\n                        case \\'*\\':\\n                            if(isPositive) {\\n                                current -= prev;\\n                                prev *= currentNum;\\n                                current += (prev);\\n                            } else {\\n                                current += prev;\\n                                prev *= currentNum;\\n                                current -= (prev);\\n                            }\\n                            break;\\n                    }\\n                } else {\\n                    current = currentNum;\\n                    prev = currentNum;\\n                }\\n                sb.append(tempStr);\\n                util(result, sb, num, target, current, i + 1, len, operatorLen, prev, isPositive);\\n                sb.setLength(sbLen);\\n                current = prevCurrent;\\n                prev = prevPrev;\\n                isPositive = prevIsPositive;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031229,
                "title": "python-simple-heavily-commented-and-accepted-recursive-solution",
                "content": "Simple and easy to understand solution. This solution evaluates the expression on the fly so it saves additonal computation of evaluating the value in the end\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        exprs = []\\n        \\n        def recurse(idx, value, delta, exp):\\n            # base case here\\n            if idx == len(num):\\n                if value == target:\\n                    exprs.append(\"\".join(exp))\\n            \\n            # the loop will create the current operand and recursively call\\n            # the next set of actions to be executed\\n            for i in range(idx, len(num)):\\n                # this is to avoid cases where the operand starts with a 0\\n                # we need to have a case with just the 0 but not something like\\n                # 05, so the condition will return early if we find such cases\\n                if num[idx] == \\'0\\' and i > idx:\\n                    return\\n                \\n                curr = int(num[idx:i+1])\\n                curr_str = num[idx:i+1]\\n                \\n                # when we start the problem we dont have a preceding operator or operand\\n                if idx == 0:\\n                    recurse(i+1, curr, curr, exp + [curr_str])\\n                else:\\n                    # We need to do 3 different recursions for each operator\\n                    # value stores the running value of the expression evaluated so far\\n                    # the crux of the logic lies in how we use and pass delta\\n                    # when the operation is \\'+\\' or \\'-\\' we don\\'t care much about it and can just\\n                    # add or subtract it from the value \\n                    # when \\'*\\' is involved, we need to follow the precedence relation,\\n                    # but we have already evaluated the previous operator. We know the\\n                    # previous operation that was performed and how much it contributed to the value i.e., delta\\n                    # so, we can revert that operation by subtracting delta from value and reapplying the multiplication\\n                    recurse(i+1, value+curr, curr, exp + [\\'+\\', curr_str])\\n                    recurse(i+1, value-curr, -curr, exp + [\\'-\\', curr_str])\\n                    recurse(i+1, (value-delta)+curr*delta, curr*delta, exp + [\\'*\\', curr_str])\\n                            \\n        recurse(0, 0, 0, [])\\n        return exprs\\n                            \\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        exprs = []\\n        \\n        def recurse(idx, value, delta, exp):\\n            # base case here\\n            if idx == len(num):\\n                if value == target:\\n                    exprs.append(\"\".join(exp))\\n            \\n            # the loop will create the current operand and recursively call\\n            # the next set of actions to be executed\\n            for i in range(idx, len(num)):\\n                # this is to avoid cases where the operand starts with a 0\\n                # we need to have a case with just the 0 but not something like\\n                # 05, so the condition will return early if we find such cases\\n                if num[idx] == \\'0\\' and i > idx:\\n                    return\\n                \\n                curr = int(num[idx:i+1])\\n                curr_str = num[idx:i+1]\\n                \\n                # when we start the problem we dont have a preceding operator or operand\\n                if idx == 0:\\n                    recurse(i+1, curr, curr, exp + [curr_str])\\n                else:\\n                    # We need to do 3 different recursions for each operator\\n                    # value stores the running value of the expression evaluated so far\\n                    # the crux of the logic lies in how we use and pass delta\\n                    # when the operation is \\'+\\' or \\'-\\' we don\\'t care much about it and can just\\n                    # add or subtract it from the value \\n                    # when \\'*\\' is involved, we need to follow the precedence relation,\\n                    # but we have already evaluated the previous operator. We know the\\n                    # previous operation that was performed and how much it contributed to the value i.e., delta\\n                    # so, we can revert that operation by subtracting delta from value and reapplying the multiplication\\n                    recurse(i+1, value+curr, curr, exp + [\\'+\\', curr_str])\\n                    recurse(i+1, value-curr, -curr, exp + [\\'-\\', curr_str])\\n                    recurse(i+1, (value-delta)+curr*delta, curr*delta, exp + [\\'*\\', curr_str])\\n                            \\n        recurse(0, 0, 0, [])\\n        return exprs\\n                            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 71923,
                "title": "some-thougths",
                "content": "The following DFS is similar to top solutions.\\n* c++\\n```\\n    vector<string> addOperators(string num, int target) {\\n        vector<string> exp;\\n        string cur;\\n        dfs(0,0,0,target,cur,num,exp);\\n        return exp;\\n    }\\n    void dfs(int p, int prod, long res, int target, string& cur, string &num,vector<string>& exp) {\\n        int n = num.size();\\n        if(p==n && res==target) exp.push_back(cur);\\n        long v = 0;\\n        int sz = cur.size(); \\n        string s;\\n        for(int i=p;i<n;i++) {\\n            v=v*10+num[i]-\\'0\\';\\n            s+=num[i];\\n            if(cur.empty()) dfs(i+1,v,res+v,target,cur+=s,num,exp);\\n            else {\\n                dfs(i+1,v,res+v,target,cur+=\\'+\\'+s,num,exp);\\n                cur.resize(sz);\\n                dfs(i+1,-v,res-v,target,cur+=\\'-\\'+s,num,exp);\\n                cur.resize(sz);\\n                dfs(i+1,prod*v,res-prod+prod*v,target,cur+=\\'*\\'+s,num,exp);\\n            }\\n            cur.resize(sz);\\n            if(!v) return;\\n        }\\n    }\\n``` \\n* java\\n```\\n\\tList<String> res;\\n    public List<String> addOperators(String num, int target) {\\n        res=new ArrayList<>();\\n        dfs(0,0,0,target,num,new StringBuilder());\\n        return res;\\n    }\\n    private void dfs(int p, long eval, long mult, int target, String num, StringBuilder sb) {\\n        int n=num.length();\\n        if(p==n) {\\n            if(eval==target) {\\n                res.add(sb.toString());\\n            }\\n        }\\n        int len=sb.length();\\n        long number=0;\\n        for(int i=p;i<n;i++) {\\n            number = number*10 + num.charAt(i)-\\'0\\';\\n            if(p==0) {//no sign before first number\\n                dfs(i+1,number,number,target,num,sb.append(number));\\n                sb.setLength(len);\\n            } else {\\n                dfs(i+1,eval+number,number,target,num,sb.append(\\'+\\').append(number));\\n                sb.setLength(len);\\n                dfs(i+1,eval-number,-number,target,num,sb.append(\\'-\\').append(number));\\n                sb.setLength(len);\\n                dfs(i+1,eval-mult+mult*number,mult*number,target,num,sb.append(\\'*\\').append(number));\\n                sb.setLength(len);\\n            }\\n            if(num.charAt(p)==\\'0\\') { //01 is invalid\\n                return;\\n            }\\n        }\\n    }\\n```\\nTime complexity O(4^n)\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1);\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1);\\nThus T(n) = 4T(n-1);\\n\\nSpace complexity O(n)\\nIgnoring the large output, space complexity is depth of the recursion.\\n\\nMost recursions can be speeded up by memorization. How about this one? No, because there is no duplicate states.\\n\\nHow about BFS? If a problem can be solved by one, we can solve it by the other. DFS has much lower memory requirements than BFS because it is not necessary to store all the children at each level. The search space is exponential so BFS space complexity is exponential which makes it not acceptable.",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n    vector<string> addOperators(string num, int target) {\\n        vector<string> exp;\\n        string cur;\\n        dfs(0,0,0,target,cur,num,exp);\\n        return exp;\\n    }\\n    void dfs(int p, int prod, long res, int target, string& cur, string &num,vector<string>& exp) {\\n        int n = num.size();\\n        if(p==n && res==target) exp.push_back(cur);\\n        long v = 0;\\n        int sz = cur.size(); \\n        string s;\\n        for(int i=p;i<n;i++) {\\n            v=v*10+num[i]-\\'0\\';\\n            s+=num[i];\\n            if(cur.empty()) dfs(i+1,v,res+v,target,cur+=s,num,exp);\\n            else {\\n                dfs(i+1,v,res+v,target,cur+=\\'+\\'+s,num,exp);\\n                cur.resize(sz);\\n                dfs(i+1,-v,res-v,target,cur+=\\'-\\'+s,num,exp);\\n                cur.resize(sz);\\n                dfs(i+1,prod*v,res-prod+prod*v,target,cur+=\\'*\\'+s,num,exp);\\n            }\\n            cur.resize(sz);\\n            if(!v) return;\\n        }\\n    }\\n```\n```\\n\\tList<String> res;\\n    public List<String> addOperators(String num, int target) {\\n        res=new ArrayList<>();\\n        dfs(0,0,0,target,num,new StringBuilder());\\n        return res;\\n    }\\n    private void dfs(int p, long eval, long mult, int target, String num, StringBuilder sb) {\\n        int n=num.length();\\n        if(p==n) {\\n            if(eval==target) {\\n                res.add(sb.toString());\\n            }\\n        }\\n        int len=sb.length();\\n        long number=0;\\n        for(int i=p;i<n;i++) {\\n            number = number*10 + num.charAt(i)-\\'0\\';\\n            if(p==0) {//no sign before first number\\n                dfs(i+1,number,number,target,num,sb.append(number));\\n                sb.setLength(len);\\n            } else {\\n                dfs(i+1,eval+number,number,target,num,sb.append(\\'+\\').append(number));\\n                sb.setLength(len);\\n                dfs(i+1,eval-number,-number,target,num,sb.append(\\'-\\').append(number));\\n                sb.setLength(len);\\n                dfs(i+1,eval-mult+mult*number,mult*number,target,num,sb.append(\\'*\\').append(number));\\n                sb.setLength(len);\\n            }\\n            if(num.charAt(p)==\\'0\\') { //01 is invalid\\n                return;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 71959,
                "title": "c-solution-with-explanation",
                "content": "We can consider a number \"12\" or a product of numbers \"1*2\" as a subset, '+' or '-' will be the separator for subsets. Whenever we inserts a '+' or '-', product will be reset to be 1. \\n\\n\\n    Pattern: \\n    sumSofar + sign(1/-1) * [product * concatenate(lastNum, num[pos]) operator]\\n\\ne.g. num: \"1142356\" \\n    \\n    One possible sequence till position 5:    1+142*35[*/-/+/none]\\n    Before position 5:\\n    sumSofar = 1, product = 142, lastNum = 3, curNum = 35, sign = 1\\n    Now, so here, one of the three operators '*', '-', '+' or none of them can be inserted after 3.\\n    '*':  path-> `1+142*35*`, lastNum -> 0, product -> 142 * 35 * 1\\n    '+':  path-> `1+142*35+`, lastNum -> 0, product -> 1, sumSofar += 142 * 35 * 1, sign -> 1 \\n    '-':  path-> `1+142*35-`, lastNum -> 0, product -> 1, sumSofar += 142 * 35 * 1, sign -> -1\\n    none: path-> `1+142*35`, lastNum -> curNum = 35 \\n\\n \\n\\n\\nCode\\n\\n    class Solution {\\n    public:\\n        vector<string> addOperators(string num, int target) {\\n            vector<string> answer;\\n            if(num.size()) dfs(num, 0, target, 0, 1, 0, \"\", answer, 1); // pos: next to process position num[pos]\\n            return answer;\\n        }\\n        \\n        void dfs(string &num, int pos, int target, long long lastNum, long long product, long long sumSofar, string path, vector<string> &answer, int sign){\\n            \\n            long long curNum = lastNum * 10 + num[pos] - '0'; \\n            if(pos + 1 == num.size()){\\n                if(sumSofar + product * curNum * sign == target)\\n                    answer.push_back(path + num[pos]);\\n                return; \\n            }\\n            // for pos < num.size() - 1, \\u201c*\\u201d / \\u201c+\\u201d / \\u201c-\\u201d / no op / can be inserted after num[pos]\\n            dfs(num, pos + 1, target, 0, product * curNum, sumSofar, path + num[pos] + \"*\", answer, sign); // *\\n            dfs(num, pos + 1, target, 0, 1, sumSofar + product * curNum * sign, path + num[pos] + \"+\", answer, 1); // +\\n            dfs(num, pos + 1, target, 0, 1, sumSofar + product * curNum * sign, path + num[pos] + \"-\", answer, -1); // -\\n            if(curNum != 0) dfs(num, pos + 1, target, curNum, product, sumSofar, path + num[pos], answer, sign); // no operator\\n        } \\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> addOperators(string num, int target) {\\n            vector<string> answer;\\n            if(num.size()) dfs(num, 0, target, 0, 1, 0, \"\", answer, 1); // pos: next to process position num[pos]\\n            return answer;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 71966,
                "title": "my-20ms-c-dfs-solution",
                "content": "    typedef long long int Int64;\\n    \\n    class Solution {\\n    private:\\n        const char *numstr;\\n        Int64 target64;\\n        int n;\\n        \\n        void dfs(Int64 prev, Int64 curr, int next, char* buffer, int buffernext, vector<string>& res)\\n        {\\n            if(next == n)\\n            {\\n                buffer[buffernext] = '\\\\0';\\n                if(prev+curr == target64)\\n                {\\n                    string s = buffer;\\n                    res.push_back(s);\\n                }\\n                return;\\n            }\\n            \\n            int lm;\\n            if(numstr[next] == '0')\\n                lm = next+1;\\n            else\\n                lm = n;\\n            \\n            int l;\\n            Int64 v=0;\\n            for(l=next; l<lm; l++)\\n            {\\n                buffer[buffernext+l-next+1] = numstr[l];\\n                v = v*10 + (numstr[l] - '0');\\n                \\n                buffer[buffernext] = '+';\\n                dfs(prev+curr, v, l+1, buffer, buffernext+l-next+2, res);\\n                \\n                buffer[buffernext] = '-';\\n                dfs(prev+curr, -v, l+1, buffer, buffernext+l-next+2, res);\\n                \\n                buffer[buffernext] = '*';\\n                dfs(prev, curr*v, l+1, buffer, buffernext+l-next+2, res);\\n            }\\n        }\\n    public:\\n        vector<string> addOperators(string num, int target) {\\n            vector<string> result;\\n            \\n            n = num.size();\\n            target64 = (Int64) target;\\n            numstr = num.c_str();\\n            \\n            char buf[2*n];\\n            int lmax;\\n            if(numstr[0] == '0') // A number starts with '0' must be 0\\n                lmax = 1;\\n            else\\n                lmax = n;\\n            int i;\\n            Int64 previous = 0;\\n            Int64 current = 0;\\n            for(i=0; i<lmax; i++)\\n            {\\n                current = current*10 + (numstr[i] - '0');\\n                buf[i] = numstr[i];\\n                dfs(previous, current, i+1, buf, i+1, result);\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    private:\\n        const char *numstr;\\n        Int64 target64;\\n        int n;\\n        \\n        void dfs(Int64 prev, Int64 curr, int next, char* buffer, int buffernext, vector<string>& res)\\n        {\\n            if(next == n)\\n            {\\n                buffer[buffernext] = '\\\\0';\\n                if(prev+curr == target64)\\n                {\\n                    string s = buffer;\\n                    res.push_back(s);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3330455,
                "title": "well-explained-python-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def addOperators(self, s: str, target: int) -> List[str]:\\n        # need to traverse through s\\n        # backtrack each case of  start index and then +,*,-\\n        # need empty array ofcourse\\n        # need curidx = i\\n        # need the str path to append to the arr if my --> cur_num == target\\n        # need the prevNum access for multiplication\\n        # 1 2 3 4 5 --> 1 + 2 + 3 + 4 * 5\\n        #               ^ ^ ^ ^ ^ ^ ^ == 10 but we wanna do 4*5 so ---\\n        # just do 1 + 2 + 3 + 4 + (- 4) + (4 * 5)\\n        # return ans\\n        \\n        res = []\\n\\n        def dfs(i, path, cur_num, prevNum):\\n            if i == len(s):\\n                if cur_num == target:\\n                    res.append(path)\\n                return\\n            \\n            for j in range(i, len(s)):\\n                # starting with zero?\\n                if j > i and s[i] == \\'0\\':\\n                    break\\n                num = int(s[i:j+1])\\n\\n                # if cur index is 0 then simple add that number\\n                if i == 0:\\n                    dfs(j + 1, path + str(num), cur_num + num, num)\\n                else:\\n                    dfs(j + 1, path + \"+\" + str(num), cur_num + num, num)\\n                    dfs(j + 1, path + \"-\" + str(num), cur_num - num, -num)\\n                    dfs(j + 1, path + \"*\" + str(num), cur_num - prevNum + prevNum * num, prevNum * num)\\n        \\n        dfs(0, \"\", 0, 0)\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, s: str, target: int) -> List[str]:\\n        # need to traverse through s\\n        # backtrack each case of  start index and then +,*,-\\n        # need empty array ofcourse\\n        # need curidx = i\\n        # need the str path to append to the arr if my --> cur_num == target\\n        # need the prevNum access for multiplication\\n        # 1 2 3 4 5 --> 1 + 2 + 3 + 4 * 5\\n        #               ^ ^ ^ ^ ^ ^ ^ == 10 but we wanna do 4*5 so ---\\n        # just do 1 + 2 + 3 + 4 + (- 4) + (4 * 5)\\n        # return ans\\n        \\n        res = []\\n\\n        def dfs(i, path, cur_num, prevNum):\\n            if i == len(s):\\n                if cur_num == target:\\n                    res.append(path)\\n                return\\n            \\n            for j in range(i, len(s)):\\n                # starting with zero?\\n                if j > i and s[i] == \\'0\\':\\n                    break\\n                num = int(s[i:j+1])\\n\\n                # if cur index is 0 then simple add that number\\n                if i == 0:\\n                    dfs(j + 1, path + str(num), cur_num + num, num)\\n                else:\\n                    dfs(j + 1, path + \"+\" + str(num), cur_num + num, num)\\n                    dfs(j + 1, path + \"-\" + str(num), cur_num - num, -num)\\n                    dfs(j + 1, path + \"*\" + str(num), cur_num - prevNum + prevNum * num, prevNum * num)\\n        \\n        dfs(0, \"\", 0, 0)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511436,
                "title": "python-recursive-dfs-step-by-step-walkthrough-long-post",
                "content": "**Intuition**\\n\\n1. We start off the problem by enumerating all possible ways to split up our numbers:\\n\\t```\\n\\tdef dfs(i: int, expr: List[str]):\\n\\t\\tif i == n:\\n\\t\\t\\t# evaluate expression\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t    # for every position in between digits\\n\\t\\t\\t# we add a break\\n\\t\\t\\tdfs(j + 1, expr + [num[i:j + 1]])\\n\\t```\\n\\t\\n2. Not too bad so far. Then we add our operators:\\n\\t```\\n\\tdef dfs(i: int, expr: List[str]):\\n\\t\\tif i == n:\\n\\t\\t\\t# evaluate expression\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t\\tif not expr:\\n\\t\\t\\t\\t# we are at the beginning of the num\\n\\t\\t\\t\\t# we cannot add operators before any\\n\\t\\t\\t\\t# digits\\n\\t\\t\\t\\tdfs(j + 1, expr + [num[i:j + 1]])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"+\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"-\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"*\"] + [num[i:j + 1]])\\n\\t```\\n\\n3. You will notice that the above doesn\\'t account for numbers with leading zeroes. So we add that edge case check in our DFS:\\n\\t```\\n\\tdef dfs(i: int, expr: List[str]):\\n\\t\\tif i == n:\\n\\t\\t\\t# evaluate expression\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t\\tif not expr:\\n\\t\\t\\t\\tdfs(j + 1, expr + [num[i:j + 1]])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"+\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"-\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"*\"] + [num[i:j + 1]])\\n\\n\\t\\t\\tif num[i] == \"0\":\\n\\t\\t\\t\\t# we have a leading zero, only allow a single DFS call\\n\\t\\t\\t\\t# then break\\n\\t\\t\\t\\tbreak\\n\\t```\\n\\n4. If the problem is a bit easier, we might get away with calling `eval(expr)` once we generate the permutations. However Python is slow and the problem is LC Hard for a reason. So we need to evaluate our expression on-the-fly\\n\\n5. Let\\'s imagine we ONLY had \"+\" and \"-\". We might evaluate our values like so:\\n\\t```\\n\\tdef dfs(i: int, expr: List[str], val):\\n\\t\\tif i == n:\\n            if val == target:\\n\\t\\t\\t    res.append(\"\".join(expr))\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t    operand_str = num[i:j + 1]\\n\\t\\t\\toperand = int(operand_str)\\n\\t\\t\\t\\n\\t\\t\\tif not expr:\\n\\t\\t\\t\\tdfs(j + 1, expr + [operand_str])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"+\"] + [operand_str], val + operand)\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"-\"] + [operand_str], val - operand)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# let\\'s ignore multiplying for now\\n\\t\\t\\t\\t# dfs(j + 1, expr + [\"*\"] + [operand_str])\\n\\n\\t\\t\\tif num[i] == \"0\":\\n\\t\\t\\t\\tbreak\\n\\t```\\n\\n6. Almost there! But what about multiplication? It takes precedence over add/subtract. Imagine if we have: `A+B*D`. Using our method in step #5, we might end up with `(A+B)*D`. How do we correct this?\\n\\n7. Let\\'s assume we are stuck with `(A+B)`. Algebraically, we would need to \"undo\" the previous addition like so:\\n\\t```\\n\\t(A + B) - B + B * D = A + (B * D)\\n\\t```\\n\\n8. With this new observation, we have our final DFS implementation:\\n\\n**Solution**\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        \\n        res = []\\n        \\n        def dfs(i: int, expr: List[str], val, prev):\\n            if i == n:\\n                if val == target:\\n                    res.append(\"\".join(expr))\\n                return\\n        \\n            for j in range(i, n):\\n                operand_s = num[i:j + 1]\\n                operand_i = int(operand_s)\\n                \\n                if not expr:\\n                    # we are reading the first number\\n                    # so we do not add any operators yet\\n                    dfs(j + 1, [operand_s], operand_i, operand_i)\\n                    \\n                else:\\n                    dfs(j + 1, expr + [\"+\"] + [operand_s], val + operand_i, operand_i)\\n                    dfs(j + 1, expr + [\"-\"] + [operand_s], val - operand_i, -operand_i)\\n                    \\n                    # when we DFS with a multiply, we need to \"undo\" a previous calculation\\n                    dfs(j + 1, expr + [\"*\"] + [operand_s], val - prev + operand_i * prev, operand_i * prev)\\n                    \\n                if num[i] == \"0\":\\n                    # we only want to dfs ONCE if we are\\n                    # currently reading a zero.\\n                    #\\n                    # for example 0 + 0 + 1 is valid\\n                    # however, 00 + 1 is not valid\\n                    break\\n        \\n        dfs(0, [], 0, 0)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\tdef dfs(i: int, expr: List[str]):\\n\\t\\tif i == n:\\n\\t\\t\\t# evaluate expression\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t    # for every position in between digits\\n\\t\\t\\t# we add a break\\n\\t\\t\\tdfs(j + 1, expr + [num[i:j + 1]])\\n\\t```\n```\\n\\tdef dfs(i: int, expr: List[str]):\\n\\t\\tif i == n:\\n\\t\\t\\t# evaluate expression\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t\\tif not expr:\\n\\t\\t\\t\\t# we are at the beginning of the num\\n\\t\\t\\t\\t# we cannot add operators before any\\n\\t\\t\\t\\t# digits\\n\\t\\t\\t\\tdfs(j + 1, expr + [num[i:j + 1]])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"+\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"-\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"*\"] + [num[i:j + 1]])\\n\\t```\n```\\n\\tdef dfs(i: int, expr: List[str]):\\n\\t\\tif i == n:\\n\\t\\t\\t# evaluate expression\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t\\tif not expr:\\n\\t\\t\\t\\tdfs(j + 1, expr + [num[i:j + 1]])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"+\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"-\"] + [num[i:j + 1]])\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"*\"] + [num[i:j + 1]])\\n\\n\\t\\t\\tif num[i] == \"0\":\\n\\t\\t\\t\\t# we have a leading zero, only allow a single DFS call\\n\\t\\t\\t\\t# then break\\n\\t\\t\\t\\tbreak\\n\\t```\n```\\n\\tdef dfs(i: int, expr: List[str], val):\\n\\t\\tif i == n:\\n            if val == target:\\n\\t\\t\\t    res.append(\"\".join(expr))\\n\\t\\t\\treturn\\n\\n\\t\\tfor j in range(i, n):\\n\\t\\t    operand_str = num[i:j + 1]\\n\\t\\t\\toperand = int(operand_str)\\n\\t\\t\\t\\n\\t\\t\\tif not expr:\\n\\t\\t\\t\\tdfs(j + 1, expr + [operand_str])\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"+\"] + [operand_str], val + operand)\\n\\t\\t\\t\\tdfs(j + 1, expr + [\"-\"] + [operand_str], val - operand)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# let\\'s ignore multiplying for now\\n\\t\\t\\t\\t# dfs(j + 1, expr + [\"*\"] + [operand_str])\\n\\n\\t\\t\\tif num[i] == \"0\":\\n\\t\\t\\t\\tbreak\\n\\t```\n```\\n\\t(A + B) - B + B * D = A + (B * D)\\n\\t```\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        \\n        res = []\\n        \\n        def dfs(i: int, expr: List[str], val, prev):\\n            if i == n:\\n                if val == target:\\n                    res.append(\"\".join(expr))\\n                return\\n        \\n            for j in range(i, n):\\n                operand_s = num[i:j + 1]\\n                operand_i = int(operand_s)\\n                \\n                if not expr:\\n                    # we are reading the first number\\n                    # so we do not add any operators yet\\n                    dfs(j + 1, [operand_s], operand_i, operand_i)\\n                    \\n                else:\\n                    dfs(j + 1, expr + [\"+\"] + [operand_s], val + operand_i, operand_i)\\n                    dfs(j + 1, expr + [\"-\"] + [operand_s], val - operand_i, -operand_i)\\n                    \\n                    # when we DFS with a multiply, we need to \"undo\" a previous calculation\\n                    dfs(j + 1, expr + [\"*\"] + [operand_s], val - prev + operand_i * prev, operand_i * prev)\\n                    \\n                if num[i] == \"0\":\\n                    # we only want to dfs ONCE if we are\\n                    # currently reading a zero.\\n                    #\\n                    # for example 0 + 0 + 1 is valid\\n                    # however, 00 + 1 is not valid\\n                    break\\n        \\n        dfs(0, [], 0, 0)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910325,
                "title": "expression-add-operators-solution-java",
                "content": "class Solution {\\n  public List<String> addOperators(String num, int target) {\\n    List<String> ans = new ArrayList<>();\\n    dfs(num, target, 0, 0, 0, new StringBuilder(), ans);\\n    return ans;\\n  }\\n\\n  private void dfs(String num, int target, int s, long prev, long eval, StringBuilder sb,\\n                   List<String> ans) {\\n    if (s == num.length()) {\\n      if (eval == target)\\n        ans.add(sb.toString());\\n      return;\\n    }\\n\\n    for (int i = s; i < num.length(); ++i) {\\n      if (i > s && num.charAt(s) == \\'0\\')\\n        return;\\n      final long curr = Long.parseLong(num.substring(s, i + 1));\\n      final int length = sb.length();\\n      if (s == 0) { // first num\\n        dfs(num, target, i + 1, curr, curr, sb.append(curr), ans);\\n        sb.setLength(length);\\n      } else {\\n        dfs(num, target, i + 1, curr, eval + curr, sb.append(\"+\").append(curr), ans);\\n        sb.setLength(length);\\n        dfs(num, target, i + 1, -curr, eval - curr, sb.append(\"-\").append(curr), ans);\\n        sb.setLength(length);\\n        dfs(num, target, i + 1, prev * curr, eval - prev + prev * curr, sb.append(\"*\").append(curr),\\n            ans);\\n        sb.setLength(length);\\n      }\\n    }\\n  }\\n}\\n",
                "solutionTags": [
                    "Math",
                    "String",
                    "Backtracking"
                ],
                "code": "class Solution {\\n  public List<String> addOperators(String num, int target) {\\n    List<String> ans = new ArrayList<>();\\n    dfs(num, target, 0, 0, 0, new StringBuilder(), ans);\\n    return ans;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1449082,
                "title": "simple-clean-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> result = new ArrayList<>();\\n        addOperators(num, target, result, 0, 0, 0, \"\");\\n        return result;\\n    }\\n    \\n    private void addOperators(String num, int target, List<String> result, int index, long value, long previous, String current) {\\n        if(index == num.length()) {\\n            if(value + previous == target) {\\n                result.add(current);\\n            }\\n            return;\\n        }\\n        \\n        int end = num.length();\\n        if(num.charAt(index) == \\'0\\') {\\n            end = index + 1;\\n        }\\n        \\n        for(int i = index + 1; i <= end; i ++) {\\n            long currentValue = Long.valueOf(num.substring(index, i));\\n            \\n            if(index == 0) {\\n                addOperators(num, target, result, i, 0, currentValue, String.valueOf(currentValue));\\n                continue;\\n            } \\n            \\n            // Add +\\n            addOperators(num, target, result, i, value + previous, currentValue, current + \"+\" + currentValue);\\n            // Add -\\n            addOperators(num, target, result, i, value + previous, -currentValue, current + \"-\" + currentValue);\\n            // Add *\\n            addOperators(num, target, result, i, value, previous * currentValue, current + \"*\" + currentValue);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> result = new ArrayList<>();\\n        addOperators(num, target, result, 0, 0, 0, \"\");\\n        return result;\\n    }\\n    \\n    private void addOperators(String num, int target, List<String> result, int index, long value, long previous, String current) {\\n        if(index == num.length()) {\\n            if(value + previous == target) {\\n                result.add(current);\\n            }\\n            return;\\n        }\\n        \\n        int end = num.length();\\n        if(num.charAt(index) == \\'0\\') {\\n            end = index + 1;\\n        }\\n        \\n        for(int i = index + 1; i <= end; i ++) {\\n            long currentValue = Long.valueOf(num.substring(index, i));\\n            \\n            if(index == 0) {\\n                addOperators(num, target, result, i, 0, currentValue, String.valueOf(currentValue));\\n                continue;\\n            } \\n            \\n            // Add +\\n            addOperators(num, target, result, i, value + previous, currentValue, current + \"+\" + currentValue);\\n            // Add -\\n            addOperators(num, target, result, i, value + previous, -currentValue, current + \"-\" + currentValue);\\n            // Add *\\n            addOperators(num, target, result, i, value, previous * currentValue, current + \"*\" + currentValue);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356498,
                "title": "python-recursive-with-stack",
                "content": "It\\'s the same idea as the basic calculator implementation using stack.\\n\\n* if the operator is `+` or `-`, push to stack as is.\\n* if the operator is `*` , pop the stack and multiplly it by the current number, then push the result to the stack\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        size = len(num)\\n        \\n        def solve(index: int, stack: list = None, built: str = None) -> List[str]:\\n            if index >= size:\\n                if sum(stack) == target:\\n                    return [built]\\n                else:\\n                    return []\\n            \\n            res = []\\n            \\n            for i in range(index + 1, size + 1):\\n                ns = num[index: i]\\n                if ns[0] == \\'0\\' and i - index > 1:\\n                    break\\n                    \\n                n = int(ns)\\n                \\n                if index == 0:\\n                    res += solve(i, stack=[n], built=ns)\\n                else:\\n                    res += solve(i, stack=stack + [n], built=built + \\'+\\' + ns)\\n                    res += solve(i, stack=stack + [-n], built=built + \\'-\\' + ns)\\n                    res += solve(i, stack=stack[:-1] + [stack[-1] * n], built=built + \\'*\\' + ns)\\n                \\n            return res\\n        \\n        return solve(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        size = len(num)\\n        \\n        def solve(index: int, stack: list = None, built: str = None) -> List[str]:\\n            if index >= size:\\n                if sum(stack) == target:\\n                    return [built]\\n                else:\\n                    return []\\n            \\n            res = []\\n            \\n            for i in range(index + 1, size + 1):\\n                ns = num[index: i]\\n                if ns[0] == \\'0\\' and i - index > 1:\\n                    break\\n                    \\n                n = int(ns)\\n                \\n                if index == 0:\\n                    res += solve(i, stack=[n], built=ns)\\n                else:\\n                    res += solve(i, stack=stack + [n], built=built + \\'+\\' + ns)\\n                    res += solve(i, stack=stack + [-n], built=built + \\'-\\' + ns)\\n                    res += solve(i, stack=stack[:-1] + [stack[-1] * n], built=built + \\'*\\' + ns)\\n                \\n            return res\\n        \\n        return solve(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325327,
                "title": "c-easy-to-understand-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> res;\\n    \\n    void solve(string str, int idx, string temp, long long last, long long  value, int target) {\\n        \\n        if(idx == str.length()) {\\n            if(value == target)\\n                res.push_back(temp);\\n            return;\\n        }\\n        \\n        \\n        for(int i=idx; i<str.length(); i++) {\\n            \\n            string s = str.substr(idx, i - idx + 1);\\n            \\n            if(s.length() > 1 and s[0] == \\'0\\')\\n                return;\\n            \\n            long long curr = stoll(s);\\n            \\n            if(temp.empty()) {\\n                solve(str, i+1, temp + s, curr, curr, target);\\n            }\\n\\n            else {\\n                solve(str, i+1, temp + \"+\" + s, curr, value + curr, target);\\n                solve(str, i+1, temp + \"-\" + s, -curr, value - curr, target);\\n                solve(str, i+1, temp + \"*\" + s, curr*last, (value - last) + (curr*last) , target);                \\n            }\\n        }\\n    }\\n        \\n        \\n    vector<string> addOperators(string str, int target) {\\n        \\n        solve(str,0,\"\",0,0,target);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> res;\\n    \\n    void solve(string str, int idx, string temp, long long last, long long  value, int target) {\\n        \\n        if(idx == str.length()) {\\n            if(value == target)\\n                res.push_back(temp);\\n            return;\\n        }\\n        \\n        \\n        for(int i=idx; i<str.length(); i++) {\\n            \\n            string s = str.substr(idx, i - idx + 1);\\n            \\n            if(s.length() > 1 and s[0] == \\'0\\')\\n                return;\\n            \\n            long long curr = stoll(s);\\n            \\n            if(temp.empty()) {\\n                solve(str, i+1, temp + s, curr, curr, target);\\n            }\\n\\n            else {\\n                solve(str, i+1, temp + \"+\" + s, curr, value + curr, target);\\n                solve(str, i+1, temp + \"-\" + s, -curr, value - curr, target);\\n                solve(str, i+1, temp + \"*\" + s, curr*last, (value - last) + (curr*last) , target);                \\n            }\\n        }\\n    }\\n        \\n        \\n    vector<string> addOperators(string str, int target) {\\n        \\n        solve(str,0,\"\",0,0,target);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070001,
                "title": "why-do-i-get-tle-again-starting-from-examples-cpp-solution-with-analysis",
                "content": "Key point: store temp value & move terms to the right( why don\\'t we change the value right of \"=\")\\nFor those who only needs the solution, go to part IV directly. \\nIf you have any questions or suggestions, feel free to write below.\\n\\n**I. Introduction**\\n\\tTo better explain what I did, please allow me to introduce a new operator \"~\", which means literally combine two numbers. For instance, 1~3 = 13, 67~89 = 6789, -7~8 = -78( pay extra attention to this! ). Noticed that it\\'s different from x*10+y, we need to write a specific function implementing this operator, see function \"combine\" for details.\\n\\t\\n![image](https://assets.leetcode.com/users/images/86455c2f-4687-435e-8aaa-dd19737bdf3d_1619089354.4731524.png)\\n\\n\\nSo for a string containing n digits, there are n-1 blanks to fill and there are 4 possibilities for every blank, so the total possibilities is 4^(n-1). \\n\\n**II. A Straight-forward solution and why it results in TLE**\\nTo try all the possibilities, we can easily devise a solution using recursion: try + - * ~ one by one in each blank and move forward. Unfortunately, this solution give you TLE because you only calculate the value after you fully build the expression, which involves too much redundant calculation. \\n\\nTo get some intuition, take this half finished equation (left part) as an example\\n\\n![image](https://assets.leetcode.com/users/images/080acc6f-780f-45f4-8821-e8a2aff181c3_1619089502.8828244.png)\\n\\n\\nThere\\'re two blanks left, so there\\'re 4^2=16 possibilities left. So1*2+3~4 would be calculate 16 times. \\n\\n\\n\\n**III. A revised solution**\\nShown as above, redundant computation gives you TLE in return. A naive approach is to calculate the \\u201Cpartial answer\\u201D or \\u201Cvalue so far\\u201D, that is, the output of the part we have finished. \\n\\n\\nFor instance, in the equation given above, we could directly compute the value of 1*2+34 = 36 and use this \"value so far\" for future attempts. \\n\\n![image](https://assets.leetcode.com/users/images/a94b1185-1682-4c51-80be-cf5cc1135f03_1619089538.4591494.png)\\n\\n\\n\\nActaully, why don\\'t we move this 36 to the right part since no matter what operator between 5 and 8 is, the \"value so far\" is fixed.\\n![image](https://assets.leetcode.com/users/images/5c55a2e1-9b0d-4a9c-a350-d4e8b918f0b2_1619089570.8583777.png)\\n\\n\\nFurther look at the following equation, we find that once we decide to use \"+\" between two digits, the value of the part left of \"+\" is always fixed and we should move this part to the right.\\n![image](https://assets.leetcode.com/users/images/ed0d13c0-ed78-45b6-b1e2-b774b5e29e63_1619081561.0559442.png)\\n![image](https://assets.leetcode.com/users/images/069edc53-a92a-4e29-a330-1b9e799df708_1619081714.311086.png)\\n\\nActually, we can also do this when we decide to use \"-\" for the same reason. The only thing we need to care is to keep the \"-\" inside of the right part.\\n\\n![image](https://assets.leetcode.com/users/images/44b5ae95-82a8-450d-bd36-3d4b16286ec1_1619082005.560652.png)\\n\\nThen the question come: what if we decide to use * between two digits?\\nIndeed, we cannot move the left part to the right in this circumstance, what\\'s worse, we cannot even calculate the left part because of \"~\". \\n![image](https://assets.leetcode.com/users/images/d154422f-a2bd-4c07-97dd-7f6100bd2ef1_1619082782.6420016.png)\\n\\n\\nAssume we merge \"5*8\" into 40, just like the picture shows. If we decide to use \"~\" between 8 and 9, them the 40 would be  meaningless and there\\'s no way to fix it (the solution leetcode gives couldn\\'t handle this). In order to handle this, some special tricks are used. The following content talks about how to handle * and ~.\\n\\nWe utilize two \"registers\" reg1, reg2 (reg1 is set to be the first digit and reg2 is initialized to 1) to the save two factors and a special \"pointer\" pointing at one of them, telling us which one is \"active\". The pointer points to reg1 from the begining. Let\\'s start with an example:\\nFrom the very begining, reg1 = the first digit = 5, reg2 = 1, ptr = reg1. \\n\\nFirst blank:\\n![image](https://assets.leetcode.com/users/images/cde1f912-6be2-46aa-8b55-99c98b167770_1619084518.2493339.png)\\nWe decide to use \"*\" between 5 and 8: we update the two registers in a fixed way: reg1 = reg1 * reg2, reg2 = next digits. Change the ptr to reg2. Now the reg1 = 5 * 1 = 5,  reg2 = 8,  ptr = reg2\\n\\n\\nSecond blank:\\n![image](https://assets.leetcode.com/users/images/050361bf-df4a-48c9-a281-97857ec75bc6_1619084858.448591.png)\\nIn the second blank, we choose * anew. Again, update two registers with the same rule and change the ptr to 2(not changed). After that, \\nreg1 = 5 * 8 = 40    reg2 = 9  ptr = reg2\\n\\n\\nThrid blank:\\n![image](https://assets.leetcode.com/users/images/a4037de7-6378-4a5e-8306-10119c915ecc_1619086227.804287.png)\\nHere we decide to use \"-\". As we said before, move the left part to the right and the left part is given by reg1 * reg2 = 360. Then we change reg1 to next digit -6; set reg2 = 1, and set ptr back to reg1. The equation becomes:\\n![image](https://assets.leetcode.com/users/images/d7a86855-04fe-41a5-82f1-77320ad01271_1619086504.715896.png)\\n\\n\\nFifth blank:\\n![image](https://assets.leetcode.com/users/images/fe1c4598-a9db-424a-bf42-ec64182b48ad_1619086668.9973226.png)\\nIf we choose \"~\" for this blank, we need to merge the next digit (2 here) with the register pointer by ptr, that is, reg1.\\nThen we have: reg1=  -62  reg2 = 1  ptr = reg1.\\n\\n...\\n\\nSo in a nutshell, \\nwhen we use \"+\" or \"-\", we should move the left part to the right by set right -= reg1 * reg2, and set reg1=reg2=1, ptr = reg1;\\nwhen we use \"*\", set reg1 *= reg2, and reg2 = next digits, ptr = reg2;\\nwhen we use \"~\", set the reg? pointed by ptr to combine(reg?, next digit).\\n\\nIn the end, if we find reg1 * reg2 = right, this combination of operators is valid.\\n\\n**IV. The final solution**\\n\\tThis solution owns nice performance.\\n\\t![image](https://assets.leetcode.com/users/images/f79db340-220c-45e8-9511-d9215c8c31ce_1613575140.6618643.png)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> res;\\n\\n    long long combine(long long a, long long b){\\n        /**\\n         * you need to make sure: a ! = 0\\n         * combine(54,8) = 548 combine(-42,8) = -428\\n        */\\n        bool negative = (a<0);\\n        a = abs(a);\\n        return (negative)? -(a*10 + b) : (a*10 + b);\\n    }\\n\\n    void handle(const string& num, const long long& target, const int& index, \\n\\t\\t\\t\\tconst long long B1, const long long B2,const int ptr, char* op_rec){\\n        if(index == num.size()-1){\\n            // reach the end\\n            if(target - B1*B2 == 0){\\n                // this is a feasible solution! Store it in res.\\n                string temp = to_string(num[0]-\\'0\\');\\n                for(int i=0;i<num.size()-1;++i){\\n                    if(op_rec[i] == \\'~\\')\\n                        temp += num[i+1];\\n                    else {\\n                        temp += op_rec[i];\\n                        temp += num[i+1];  \\n                    }\\n                }\\n                res.push_back(temp);\\n            }\\n            // nope, do nothing.\\n            return;\\n        }\\n        long long next_target;\\n        int digit = num[index + 1] - \\'0\\';\\n        // not the end\\n        // \"+\"\\n        op_rec[index] = \\'+\\';\\n        next_target = target - B1 * B2;\\n        handle(num,next_target,index+1,digit,1,1,op_rec);\\n\\n        // \"-\"\\n        op_rec[index] = \\'-\\';\\n        //next_target = target - B1 * B2; same as above\\n        handle(num,next_target,index+1,-digit,1,1,op_rec);\\n\\n        // \"*\"\\n        op_rec[index] = \\'*\\';\\n        handle(num,target,index+1,B1*B2,digit,2,op_rec);\\n\\n        // \"~\"\\n        op_rec[index] = \\'~\\';\\n        long long B1_copy = B1;\\n        long long B2_copy = B2;\\n        if(ptr == 1 && B1 != 0)\\n            // you cannot combine 0 and 9 to 09\\n            B1_copy = combine(B1_copy,digit);\\n        else if(ptr == 2 & B2 != 0)\\n            B2_copy = combine(B2_copy,digit);\\n        else\\n            return;\\n        handle(num,target,index+1,B1_copy,B2_copy,ptr,op_rec);\\n    }\\n\\n    vector<string> addOperators(string num, int target) {\\n        if(num.empty())\\n            return res;\\n        char *op_rec = new char[num.size()-1];\\n        int index = 0;\\n        long long B1 = num[0] - \\'0\\', B2 = 1;\\n        int ptr = 1;\\n\\n        handle(num,target,index,B1,B2,ptr,op_rec);\\n        delete[] op_rec;\\n        return res;\\n    }\\n    \\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> res;\\n\\n    long long combine(long long a, long long b){\\n        /**\\n         * you need to make sure: a ! = 0\\n         * combine(54,8) = 548 combine(-42,8) = -428\\n        */\\n        bool negative = (a<0);\\n        a = abs(a);\\n        return (negative)? -(a*10 + b) : (a*10 + b);\\n    }\\n\\n    void handle(const string& num, const long long& target, const int& index, \\n\\t\\t\\t\\tconst long long B1, const long long B2,const int ptr, char* op_rec){\\n        if(index == num.size()-1){\\n            // reach the end\\n            if(target - B1*B2 == 0){\\n                // this is a feasible solution! Store it in res.\\n                string temp = to_string(num[0]-\\'0\\');\\n                for(int i=0;i<num.size()-1;++i){\\n                    if(op_rec[i] == \\'~\\')\\n                        temp += num[i+1];\\n                    else {\\n                        temp += op_rec[i];\\n                        temp += num[i+1];  \\n                    }\\n                }\\n                res.push_back(temp);\\n            }\\n            // nope, do nothing.\\n            return;\\n        }\\n        long long next_target;\\n        int digit = num[index + 1] - \\'0\\';\\n        // not the end\\n        // \"+\"\\n        op_rec[index] = \\'+\\';\\n        next_target = target - B1 * B2;\\n        handle(num,next_target,index+1,digit,1,1,op_rec);\\n\\n        // \"-\"\\n        op_rec[index] = \\'-\\';\\n        //next_target = target - B1 * B2; same as above\\n        handle(num,next_target,index+1,-digit,1,1,op_rec);\\n\\n        // \"*\"\\n        op_rec[index] = \\'*\\';\\n        handle(num,target,index+1,B1*B2,digit,2,op_rec);\\n\\n        // \"~\"\\n        op_rec[index] = \\'~\\';\\n        long long B1_copy = B1;\\n        long long B2_copy = B2;\\n        if(ptr == 1 && B1 != 0)\\n            // you cannot combine 0 and 9 to 09\\n            B1_copy = combine(B1_copy,digit);\\n        else if(ptr == 2 & B2 != 0)\\n            B2_copy = combine(B2_copy,digit);\\n        else\\n            return;\\n        handle(num,target,index+1,B1_copy,B2_copy,ptr,op_rec);\\n    }\\n\\n    vector<string> addOperators(string num, int target) {\\n        if(num.empty())\\n            return res;\\n        char *op_rec = new char[num.size()-1];\\n        int index = 0;\\n        long long B1 = num[0] - \\'0\\', B2 = 1;\\n        int ptr = 1;\\n\\n        handle(num,target,index,B1,B2,ptr,op_rec);\\n        delete[] op_rec;\\n        return res;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954157,
                "title": "simple-go-solution-with-backtracking",
                "content": "```golang\\nimport (\\n    \"strconv\"\\n)\\n\\n\\nfunc addOperators(num string, target int) []string {\\n    out := []string{}\\n    \\n    var backtrack func(string, string, int, int)\\n    \\n    backtrack = func(num, prefix string, val, last int) {\\n        if len(num) == 0 {\\n            if val == target {\\n                out = append(out, prefix)\\n            }\\n            return\\n        }\\n        \\n        for i := 1; i <= len(num); i++ {\\n            str := num[:i]\\n            digit, _ := strconv.Atoi(str)\\n            \\n\\t\\t\\t// prevent numbers starting with 0 except the number 0 itself\\n            if num[0] == \\'0\\'&& i != 1 {\\n                continue\\n            }\\n            \\n\\t\\t\\t// for the first call\\n            if prefix == \"\" {\\n                backtrack(num[i:], str, digit, digit)\\n            } else {\\n                backtrack(num[i:], prefix + \"+\" + str, val + digit, digit)\\n                backtrack(num[i:], prefix + \"-\" + str, val - digit, -digit)\\n                backtrack(num[i:], prefix + \"*\" + str, val - last + last * digit, last * digit)\\n            }\\n        }\\n    }\\n    \\n    backtrack(num, \"\", 0, 0)\\n    \\n    return out\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```golang\\nimport (\\n    \"strconv\"\\n)\\n\\n\\nfunc addOperators(num string, target int) []string {\\n    out := []string{}\\n    \\n    var backtrack func(string, string, int, int)\\n    \\n    backtrack = func(num, prefix string, val, last int) {\\n        if len(num) == 0 {\\n            if val == target {\\n                out = append(out, prefix)\\n            }\\n            return\\n        }\\n        \\n        for i := 1; i <= len(num); i++ {\\n            str := num[:i]\\n            digit, _ := strconv.Atoi(str)\\n            \\n\\t\\t\\t// prevent numbers starting with 0 except the number 0 itself\\n            if num[0] == \\'0\\'&& i != 1 {\\n                continue\\n            }\\n            \\n\\t\\t\\t// for the first call\\n            if prefix == \"\" {\\n                backtrack(num[i:], str, digit, digit)\\n            } else {\\n                backtrack(num[i:], prefix + \"+\" + str, val + digit, digit)\\n                backtrack(num[i:], prefix + \"-\" + str, val - digit, -digit)\\n                backtrack(num[i:], prefix + \"*\" + str, val - last + last * digit, last * digit)\\n            }\\n        }\\n    }\\n    \\n    backtrack(num, \"\", 0, 0)\\n    \\n    return out\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 887544,
                "title": "c-simple",
                "content": "```\\n vector<string> arr;\\n    \\n    void helper(string & num, int target, int start, int end, long sum, string s, int last){\\n        if(target == sum && start == num.length()){\\n            arr.push_back(s);\\n            return;\\n        }\\n        if(start <= end){\\n            string temp = \"\";\\n            for(int i=start;i<=end;i++){\\n                if(i!=start && num[start] == \\'0\\')\\n                    break;\\n                temp+=num[i];\\n                long n = stol(temp);\\n                if(start == 0)\\n                    helper(num, target, i+1, end, n, temp, n);\\n                else{\\n                    helper(num, target, i+1, end, sum+n,  s+\"+\"+temp, n);\\n                    helper(num, target, i+1, end, sum-n,  s+\"-\"+temp, -1*n);\\n                    helper(num, target, i+1, end, sum - last +last*n,  s+\"*\"+temp, last*n);\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n    }\\n    \\n    \\n    vector<string> addOperators(string num, int target) {\\n        helper(num, target, 0, num.length()-1, 0, \"\", 0);\\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n vector<string> arr;\\n    \\n    void helper(string & num, int target, int start, int end, long sum, string s, int last){\\n        if(target == sum && start == num.length()){\\n            arr.push_back(s);\\n            return;\\n        }\\n        if(start <= end){\\n            string temp = \"\";\\n            for(int i=start;i<=end;i++){\\n                if(i!=start && num[start] == \\'0\\')\\n                    break;\\n                temp+=num[i];\\n                long n = stol(temp);\\n                if(start == 0)\\n                    helper(num, target, i+1, end, n, temp, n);\\n                else{\\n                    helper(num, target, i+1, end, sum+n,  s+\"+\"+temp, n);\\n                    helper(num, target, i+1, end, sum-n,  s+\"-\"+temp, -1*n);\\n                    helper(num, target, i+1, end, sum - last +last*n,  s+\"*\"+temp, last*n);\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n    }\\n    \\n    \\n    vector<string> addOperators(string num, int target) {\\n        helper(num, target, 0, num.length()-1, 0, \"\", 0);\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 797728,
                "title": "python-dfs-intuitive-no-helper-function",
                "content": "We store such information in each node: next_index to add in our path, current path and if our current expression has a leading zero.\\n\\nSince we can not have expressions like (1+05), we need to keep track of if our current path has a leading zero. This can be done by judging if num[index] is zero because we are adding path+ops+num[index] to the stack.\\n\\nHowever, my implementation is very slow, any suggestions to improve would be appreciated. Current implementation is O(N^4) because in between each number we have to decide among +, -, * and no operator (4 possible chocies). And there are n-1 such decisions we have to make since there are n numbers. I don\\'t think we can get around this amount of cost. However, I do believe there might be some ways to optimize from implementation point of view.\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        if not num:\\n            return []\\n        stack = [(1, num[0], num[0]==\\'0\\')] # next_index, path, has_leading_zero\\n        ans = []\\n        while stack:\\n            index, path, zero = stack.pop()\\n            if index == len(num):\\n                if eval(path) == target:\\n                    ans.append(path)\\n            if index < len(num):\\n                if not zero:\\n                    stack.append((index+1, path+num[index], zero))\\n                stack.append((index+1, path+\\'+\\'+num[index], num[index]==\\'0\\'))\\n                stack.append((index+1, path+\\'-\\'+num[index], num[index]==\\'0\\'))\\n                stack.append((index+1, path+\\'*\\'+num[index], num[index]==\\'0\\'))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        if not num:\\n            return []\\n        stack = [(1, num[0], num[0]==\\'0\\')] # next_index, path, has_leading_zero\\n        ans = []\\n        while stack:\\n            index, path, zero = stack.pop()\\n            if index == len(num):\\n                if eval(path) == target:\\n                    ans.append(path)\\n            if index < len(num):\\n                if not zero:\\n                    stack.append((index+1, path+num[index], zero))\\n                stack.append((index+1, path+\\'+\\'+num[index], num[index]==\\'0\\'))\\n                stack.append((index+1, path+\\'-\\'+num[index], num[index]==\\'0\\'))\\n                stack.append((index+1, path+\\'*\\'+num[index], num[index]==\\'0\\'))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696519,
                "title": "python-backtracking-very-simple-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        ## RC ##\\n\\t\\t## APPROACH : BACKTRACKING ##\\n\\t\\t## LOGIC ##\\n\\t\\t#\\t1. Draw backtracking tree starting with \"\" and 1st level being number for num 123: its 1 or 12 or 123 (attach *, -, + and send for dfs)\\n\\t\\t#\\t2. When you are the last digit, donot send for dfs, compute the result\\n        #   3. Check out for some interesting edge cases, interviewer is looking for those you to solve.\\n\\t\\t# edge cases : 105 5, 100009 9, 569 45\\n        \\n        ## TIME COMPLEXICITY : O(4^N) ## (each level you are creating 4 branches)\\n\\t\\t## SPACE COMPLEXICITY : O(4^N) ##\\n        \\n        def dfs( curr, num ):\\n            if curr in visited:\\n                return\\n            visited.add(curr)\\n            for i, ch in enumerate(num):\\n                if i == len(num) - 1:     # when you are at last digit, calculate the result\\n                    if eval(curr + num) == target:\\n                        result.append(curr + num)\\n                else:\\n                    dfs( curr + num[:i+1] + \"*\", num[i+1:])\\n                    dfs( curr + num[:i+1] + \"-\", num[i+1:])\\n                    dfs( curr + num[:i+1] + \"+\", num[i+1:])\\n                \\n                if num[:i+1] == \"0\":     # edge case, in the number you are sending in if the first digit is 0, donot send further. ex: 105, send 0 but not 05.\\n                    break\\n        result = []\\n        visited = set()\\n        dfs( \"\", num )\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        ## RC ##\\n\\t\\t## APPROACH : BACKTRACKING ##\\n\\t\\t## LOGIC ##\\n\\t\\t#\\t1. Draw backtracking tree starting with \"\" and 1st level being number for num 123: its 1 or 12 or 123 (attach *, -, + and send for dfs)\\n\\t\\t#\\t2. When you are the last digit, donot send for dfs, compute the result\\n        #   3. Check out for some interesting edge cases, interviewer is looking for those you to solve.\\n\\t\\t# edge cases : 105 5, 100009 9, 569 45\\n        \\n        ## TIME COMPLEXICITY : O(4^N) ## (each level you are creating 4 branches)\\n\\t\\t## SPACE COMPLEXICITY : O(4^N) ##\\n        \\n        def dfs( curr, num ):\\n            if curr in visited:\\n                return\\n            visited.add(curr)\\n            for i, ch in enumerate(num):\\n                if i == len(num) - 1:     # when you are at last digit, calculate the result\\n                    if eval(curr + num) == target:\\n                        result.append(curr + num)\\n                else:\\n                    dfs( curr + num[:i+1] + \"*\", num[i+1:])\\n                    dfs( curr + num[:i+1] + \"-\", num[i+1:])\\n                    dfs( curr + num[:i+1] + \"+\", num[i+1:])\\n                \\n                if num[:i+1] == \"0\":     # edge case, in the number you are sending in if the first digit is 0, donot send further. ex: 105, send 0 but not 05.\\n                    break\\n        result = []\\n        visited = set()\\n        dfs( \"\", num )\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441680,
                "title": "accepted-c-backtracking-solution-easy-to-understand-w-comments-fast-93-14-memory-100",
                "content": "\\npublic class Solution \\n{\\n\\n    private List<string> answers;\\n    private string num;\\n    private int target;\\n    \\n    public IList<string> AddOperators(string num, int target) {        \\n        if (num == null || num.Length == 0)\\n            return new List<string>();\\n        \\n        // class member usage for readability\\n        this.num = num;\\n        this.target = target;\\n        this.answers = new List<string>();        \\n        \\n        process(0, 0, 0, 0, new StringBuilder());\\n        \\n        return answers;\\n    }\\n    \\n    // Retrieving answers during recursive procedure call\\n    // Type long is used to avoid integer overflows\\n    // StringBuilder is used to speed up the execution and reduce memory consumption\\n    private void process(int index, long previousOperand, long currentOperand, long value, StringBuilder expression)\\n    {\\n        if (index == num.Length)\\n        {\\n            // new answer found\\n            // value 0 is used for expression validation\\n            if (value == target && currentOperand == 0)\\n                answers.Add(expression.ToString());\\n            return;\\n        }\\n                \\n        // Case 0 - create multi-digit number\\n        currentOperand = currentOperand * 10 + int.Parse(num[index].ToString());\\n        string sop = currentOperand.ToString();\\n\\n        if (currentOperand > 0)\\n        {\\n            // Case 1 - proceed with no operation only if it does not start with 0 e.g. 05\\n            process(index + 1, previousOperand, currentOperand, value, expression);\\n        }\\n         \\n        if (expression.Length == 0)\\n        {\\n            // Case 2 - proceed with first number\\n            process(index + 1, currentOperand, 0, currentOperand, expression.Append(sop));\\n            expression.Length = expression.Length - sop.Length;\\n        }\\n        else\\n        {\\n            // Case 3 - proceed with addition\\n            process(index + 1, currentOperand, 0, value + currentOperand, expression.Append(\"+\").Append(sop));\\n            expression.Length = expression.Length - sop.Length - 1;\\n\\n            // Case 4 - proceed with subtraction\\n            process(index + 1, -currentOperand, 0, value - currentOperand, expression.Append(\"-\").Append(sop));\\n            expression.Length = expression.Length - sop.Length - 1;\\n\\n            // Case 5 - proceed with multiplication\\n            process(index + 1, previousOperand * currentOperand, 0, value - previousOperand + (previousOperand * currentOperand), expression.Append(\"*\").Append(sop));            \\n            expression.Length = expression.Length - sop.Length - 1;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution \\n{\\n\\n    private List<string> answers;\\n    private string num;\\n    private int target;\\n    \\n    public IList<string> AddOperators(string num, int target) {        \\n        if (num == null || num.Length == 0)\\n            return new List<string>();\\n        \\n        // class member usage for readability\\n        this.num = num;\\n        this.target = target;\\n        this.answers = new List<string>();        \\n        \\n        process(0, 0, 0, 0, new StringBuilder());\\n        \\n        return answers;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 404755,
                "title": "c-easy-to-understand-backtracking",
                "content": "```C++\\nvector<string> addOperators(string num, int target) {\\n\\tvector<string> res;\\n\\tstring cur = \"\";\\n\\taddOperators(num, 0, target, 0, 1, cur, res);\\n\\treturn res;\\n}\\n\\nvoid addOperators(string num, int index, int target, long val, long mult, string &cur,\\n\\t\\t\\t\\t  vector<string> &res) {\\n\\tif (index == num.length()) {\\n\\t\\tif (val == target) {\\n\\t\\t\\tres.push_back(cur);\\n\\t\\t}\\n\\t\\treturn;\\n\\t}\\n\\n\\tint len = cur.size();\\n\\tfor (int i = index; i < num.length(); i++) {\\n\\t\\tstring sVal = num.substr(index, i - index + 1);\\n\\t\\tlong n = stol(sVal);\\n\\t\\tif (index == 0) {\\n\\t\\t\\tcur += sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, n, n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t} else {\\n\\t\\t\\t// +\\n\\t\\t\\tcur += \"+\" + sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, val + n, n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t\\t// -\\n\\t\\t\\tcur += \"-\" + sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, val - n, -n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t\\t// *\\n\\t\\t\\tcur += \"*\" + sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, val - mult + mult * n, mult * n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t}\\n\\t\\tif (n == 0) return;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nvector<string> addOperators(string num, int target) {\\n\\tvector<string> res;\\n\\tstring cur = \"\";\\n\\taddOperators(num, 0, target, 0, 1, cur, res);\\n\\treturn res;\\n}\\n\\nvoid addOperators(string num, int index, int target, long val, long mult, string &cur,\\n\\t\\t\\t\\t  vector<string> &res) {\\n\\tif (index == num.length()) {\\n\\t\\tif (val == target) {\\n\\t\\t\\tres.push_back(cur);\\n\\t\\t}\\n\\t\\treturn;\\n\\t}\\n\\n\\tint len = cur.size();\\n\\tfor (int i = index; i < num.length(); i++) {\\n\\t\\tstring sVal = num.substr(index, i - index + 1);\\n\\t\\tlong n = stol(sVal);\\n\\t\\tif (index == 0) {\\n\\t\\t\\tcur += sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, n, n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t} else {\\n\\t\\t\\t// +\\n\\t\\t\\tcur += \"+\" + sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, val + n, n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t\\t// -\\n\\t\\t\\tcur += \"-\" + sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, val - n, -n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t\\t// *\\n\\t\\t\\tcur += \"*\" + sVal;\\n\\t\\t\\taddOperators(num, i + 1, target, val - mult + mult * n, mult * n, cur, res);\\n\\t\\t\\tcur.resize(len);\\n\\t\\t}\\n\\t\\tif (n == 0) return;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 385450,
                "title": "python-solution-320ms-18-lines-with-easy-to-understand-variable-names-and-explanation",
                "content": "Reference: https://leetcode.com/problems/expression-add-operators/discuss/128460/simple-Python-DFS-that-beats-100\\n```\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        if not num: return []\\n        res = []\\n\\n        def helper(start, expr, val, prev):\\n            if val == target and start == len(num):\\n                res.append(expr); return\\n\\t\\t\\tif start < len(num) and max(1, abs(prev)) * (int(num[start:])) < abs(target - val): return   # target not reachable\\n            for i in range(start, len(num)):\\n                curr = num[start: i+1]\\n                if len(curr) != len(str(int(curr))): break   # prevent \\'00\\',\\'01\\',... treated as one number\\n                if start == 0:\\n                    helper(i+1, curr, int(curr), int(curr))\\n                else:\\n                    helper(i+1, expr+\\'+\\'+curr, val+int(curr), int(curr))\\n                    helper(i+1, expr+\\'-\\'+curr, val-int(curr), -int(curr))   # -curr is interpreted as +(-curr)\\n                    helper(i+1, expr+\\'*\\'+curr, val-prev+prev*int(curr), prev*int(curr))   # since * has precedence over + we have to roll back +prev\\n        \\n        helper(0, \\'\\', 0, 0)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        if not num: return []\\n        res = []\\n\\n        def helper(start, expr, val, prev):\\n            if val == target and start == len(num):\\n                res.append(expr); return\\n\\t\\t\\tif start < len(num) and max(1, abs(prev)) * (int(num[start:])) < abs(target - val): return   # target not reachable\\n            for i in range(start, len(num)):\\n                curr = num[start: i+1]\\n                if len(curr) != len(str(int(curr))): break   # prevent \\'00\\',\\'01\\',... treated as one number\\n                if start == 0:\\n                    helper(i+1, curr, int(curr), int(curr))\\n                else:\\n                    helper(i+1, expr+\\'+\\'+curr, val+int(curr), int(curr))\\n                    helper(i+1, expr+\\'-\\'+curr, val-int(curr), -int(curr))   # -curr is interpreted as +(-curr)\\n                    helper(i+1, expr+\\'*\\'+curr, val-prev+prev*int(curr), prev*int(curr))   # since * has precedence over + we have to roll back +prev\\n        \\n        helper(0, \\'\\', 0, 0)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 317731,
                "title": "java-dfs-139-ms-faster-than-20-95-61-1-mb-less-than-40-86",
                "content": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> res = new ArrayList<>();\\n        dfs(num, target, 0, \"\", 0, 0, res);\\n        return res;\\n    }\\n    \\n    private void dfs(String num, int target, int pos, String str, long sum, long last, List<String> res) {\\n        if (pos == num.length()) {\\n            if (sum == target) {\\n                res.add(str);\\n            }\\n            return;\\n        }\\n        for (int i = pos; i < num.length(); ++i) {\\n            long x = Long.valueOf(num.substring(pos, i + 1));\\n            if (pos == 0) {\\n                dfs(num, target, i + 1, str + x, x, x, res);\\n            } else {\\n                dfs(num, target, i + 1, str + \"*\" + x, sum - last + last * x, last * x, res);\\n                dfs(num, target, i + 1, str + \"-\" + x, sum - x, -x, res);\\n                dfs(num, target, i + 1, str + \"+\" + x, sum + x, x, res);\\n            }\\n            if (x == 0) {\\n                break;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> res = new ArrayList<>();\\n        dfs(num, target, 0, \"\", 0, 0, res);\\n        return res;\\n    }\\n    \\n    private void dfs(String num, int target, int pos, String str, long sum, long last, List<String> res) {\\n        if (pos == num.length()) {\\n            if (sum == target) {\\n                res.add(str);\\n            }\\n            return;\\n        }\\n        for (int i = pos; i < num.length(); ++i) {\\n            long x = Long.valueOf(num.substring(pos, i + 1));\\n            if (pos == 0) {\\n                dfs(num, target, i + 1, str + x, x, x, res);\\n            } else {\\n                dfs(num, target, i + 1, str + \"*\" + x, sum - last + last * x, last * x, res);\\n                dfs(num, target, i + 1, str + \"-\" + x, sum - x, -x, res);\\n                dfs(num, target, i + 1, str + \"+\" + x, sum + x, x, res);\\n            }\\n            if (x == 0) {\\n                break;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71906,
                "title": "c-backtracking",
                "content": "C++ version of this [solution](https://discuss.leetcode.com/topic/24523/java-standard-backtrace-ac-solutoin-short-and-clear/12).\\n```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        vector<string>res;\\n        backtrack(res, num, target, 0, 0, 0, \"\");\\n        return res;\\n    }\\n    \\n    void backtrack(vector<string>& res, string num, int target, int pos, long sum, long multiply, string path){\\n        if(pos == num.size()){\\n            if(target == sum) res.push_back(path);\\n            return;\\n        }\\n        for(int i = pos; i < num.size(); i++){\\n            if(i != pos && num[pos] == '0') break;\\n            long cur = stol(num.substr(pos, i - pos + 1));\\n            if(pos == 0){\\n                backtrack(res, num, target, i + 1, cur, cur, path + to_string(cur));\\n            }\\n            else{\\n                backtrack(res, num, target, i + 1, sum + cur, cur, path + \"+\" + to_string(cur));\\n                backtrack(res, num, target, i + 1, sum - cur, -cur, path + \"-\" + to_string(cur));\\n                backtrack(res, num, target, i + 1, sum - multiply + multiply * cur, multiply * cur, path + \"*\" + to_string(cur));    \\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        vector<string>res;\\n        backtrack(res, num, target, 0, 0, 0, \"\");\\n        return res;\\n    }\\n    \\n    void backtrack(vector<string>& res, string num, int target, int pos, long sum, long multiply, string path){\\n        if(pos == num.size()){\\n            if(target == sum) res.push_back(path);\\n            return;\\n        }\\n        for(int i = pos; i < num.size(); i++){\\n            if(i != pos && num[pos] == '0') break;\\n            long cur = stol(num.substr(pos, i - pos + 1));\\n            if(pos == 0){\\n                backtrack(res, num, target, i + 1, cur, cur, path + to_string(cur));\\n            }\\n            else{\\n                backtrack(res, num, target, i + 1, sum + cur, cur, path + \"+\" + to_string(cur));\\n                backtrack(res, num, target, i + 1, sum - cur, -cur, path + \"-\" + to_string(cur));\\n                backtrack(res, num, target, i + 1, sum - multiply + multiply * cur, multiply * cur, path + \"*\" + to_string(cur));    \\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71930,
                "title": "clean-c-dfs-solution-beating-96",
                "content": "Base on Basic Calculator II, the handling for * is that, we keep a prev variable to keep track of the previous addition or subtraction operation, when we what to use * operator, we can do:\\n\\ncurrent_sum = current_sum - prev + prev * operand,\\nprev = prev * operand\\n\\nThen we just need to use DFS to enumerate all possibilities of adding multiplication, addition, subtraction operators at each possible positions.\\n\\nOne thing we need to pay attention is that if the current number has more than 1 digits, and it's starting with a 0, then this is not a valid case.\\n\\n```\\n    vector<string> addOperators(string num, int target) {\\n        string path;\\n        vector<string> result;\\n        dfs(num, 0, 0, target, 0, path, result);\\n        return result;\\n    }\\n    \\n    void dfs(const string& num, int pos, long long sum, int target, long long prev, string& path, vector<string>& result) {\\n        if (pos >= num.size()) {\\n            if (sum == target) result.push_back(path);\\n            return;\\n        }\\n        \\n        long long left = 0;\\n        int size = path.size();\\n        string buffer;\\n        for (int i=pos; i<num.size(); i++) {\\n            left = left * 10 + num[i] - '0';\\n            buffer.push_back(num[i]);\\n            if (pos == 0) {\\n                path += buffer;\\n                dfs(num, i+1, sum+left, target, left, path, result);\\n                path.resize(size);\\n            } else {\\n                path += \"+\";\\n                path += buffer;\\n                dfs(num, i+1, sum+left, target, left, path, result);\\n                path.resize(size);\\n                \\n                path += \"-\";\\n                path += buffer;\\n                dfs(num, i+1, sum-left, target, -left, path, result);\\n                path.resize(size);\\n                \\n                path += \"*\";\\n                path += buffer;\\n                dfs(num, i+1, sum-prev+prev*left, target, prev*left, path, result);\\n                path.resize(size);\\n            }\\n            if (num[pos] == '0') break;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<string> addOperators(string num, int target) {\\n        string path;\\n        vector<string> result;\\n        dfs(num, 0, 0, target, 0, path, result);\\n        return result;\\n    }\\n    \\n    void dfs(const string& num, int pos, long long sum, int target, long long prev, string& path, vector<string>& result) {\\n        if (pos >= num.size()) {\\n            if (sum == target) result.push_back(path);\\n            return;\\n        }\\n        \\n        long long left = 0;\\n        int size = path.size();\\n        string buffer;\\n        for (int i=pos; i<num.size(); i++) {\\n            left = left * 10 + num[i] - '0';\\n            buffer.push_back(num[i]);\\n            if (pos == 0) {\\n                path += buffer;\\n                dfs(num, i+1, sum+left, target, left, path, result);\\n                path.resize(size);\\n            } else {\\n                path += \"+\";\\n                path += buffer;\\n                dfs(num, i+1, sum+left, target, left, path, result);\\n                path.resize(size);\\n                \\n                path += \"-\";\\n                path += buffer;\\n                dfs(num, i+1, sum-left, target, -left, path, result);\\n                path.resize(size);\\n                \\n                path += \"*\";\\n                path += buffer;\\n                dfs(num, i+1, sum-prev+prev*left, target, prev*left, path, result);\\n                path.resize(size);\\n            }\\n            if (num[pos] == '0') break;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 71931,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Expression Add Operators** https://leetcode.com/problems/expression-add-operators/\\n\\n**Recursion and Backtracking**\\n1. Make sure you understand the problem: 1234 does not mean adding brackets, we just need to add operators.\\n2. 1234 = Processed \"12\" and now handle the substring \"34\".\\n3. We could have processed \"12\" in many ways. But when we reach the part of \"34\", we just care about the value computed so far and the immediate prev value.\\n4. For example: \"1+2\", \"1-2\", \"1\\\\*2\" would have a so_far value as 3,-1,2 and previous value as 2,-2,2.\\n5. When we reach \"34\", we would have arrived from one of the paths like \"1+2\", \"1-2\", \"1\\\\*2\". We therefore know the prev value. This is needed for multiplication part since (1+2)\\\\*3 should be really 1+2\\\\*3 since we dont have any brackets. Hence we do 1+2-2+2\\\\*3\\n```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        results = []\\n        self.helper(0, num, 0, 0, \"\", target, results)\\n        return results\\n    \\n    def helper(self, k, num, ssum, prev, e, t, res):\\n        if k == len(num):\\n            if ssum == t:\\n                res.append(\"\".join([x for x in e]))\\n        else:\\n            for i in range(k, len(num)):\\n                left = num[k:i+1]\\n                ileft = int(left)\\n                if left[0] == \"0\" and len(left) > 1: ### IGNORE INPUT LIKE \"00\", \"005\", \"0006\"\\n                    continue\\n                if k == 0:\\n                    self.helper(i+1, num, ileft, ileft, left, t, res)\\n                else:\\n                    self.helper(i+1, num, ssum+ileft, ileft, e+\"+\"+left, t, res)\\n                    self.helper(i+1, num, ssum-ileft, ileft*-1, e+\"-\"+left, t, res)\\n                    self.helper(i+1, num, ssum-prev+ileft*prev, ileft*prev, e+\"*\"+left, t, res)\\n            return\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        results = []\\n        self.helper(0, num, 0, 0, \"\", target, results)\\n        return results\\n    \\n    def helper(self, k, num, ssum, prev, e, t, res):\\n        if k == len(num):\\n            if ssum == t:\\n                res.append(\"\".join([x for x in e]))\\n        else:\\n            for i in range(k, len(num)):\\n                left = num[k:i+1]\\n                ileft = int(left)\\n                if left[0] == \"0\" and len(left) > 1: ### IGNORE INPUT LIKE \"00\", \"005\", \"0006\"\\n                    continue\\n                if k == 0:\\n                    self.helper(i+1, num, ileft, ileft, left, t, res)\\n                else:\\n                    self.helper(i+1, num, ssum+ileft, ileft, e+\"+\"+left, t, res)\\n                    self.helper(i+1, num, ssum-ileft, ileft*-1, e+\"-\"+left, t, res)\\n                    self.helper(i+1, num, ssum-prev+ileft*prev, ileft*prev, e+\"*\"+left, t, res)\\n            return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71987,
                "title": "my-short-python-accepted-code",
                "content": "    class Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        def solve(target, pos, negate, prod):\\n            expr = []\\n\\n            for i in xrange(pos, len(num)):\\n                if i > pos and num[pos] == \"0\":\\n                    break\\n\\n                if i == len(num) -1:\\n                    if negate * prod * int(num[pos:i+1]) == target:\\n                        expr.extend([num[pos:i+1]])\\n                    break\\n                \\n                add_expr = solve(target - prod * negate * long(num[pos:i+1]), i+1, 1, 1)\\n                expr.extend([num[pos:i+1] + \"+\" + e for e in add_expr])\\n\\n                sub_expr = solve(target - prod * negate * long(num[pos:i+1]), i+1, -1, 1)     \\n                expr.extend([num[pos:i+1] + \"-\" + e for e in sub_expr])\\n\\n                mul_expr = solve(target, i+1, 1, prod * negate * long(num[pos:i+1]))\\n                expr.extend([num[pos:i+1] + \"*\" + e for e in mul_expr])\\n\\n            return expr\\n        \\n        return solve(target, 0, 1, 1)",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        def solve(target, pos, negate, prod):\\n            expr = []\\n\\n            for i in xrange(pos, len(num)):\\n                if i > pos and num[pos] == \"0\":\\n                    break\\n\\n                if i == len(num) -1:\\n                    if negate * prod * int(num[pos:i+1]) == target:\\n                        expr.extend([num[pos:i+1]])\\n                    break\\n                \\n                add_expr = solve(target - prod * negate * long(num[pos:i+1]), i+1, 1, 1)\\n                expr.extend([num[pos:i+1] + \"+\" + e for e in add_expr])\\n\\n                sub_expr = solve(target - prod * negate * long(num[pos:i+1]), i+1, -1, 1)     \\n                expr.extend([num[pos:i+1] + \"-\" + e for e in sub_expr])\\n\\n                mul_expr = solve(target, i+1, 1, prod * negate * long(num[pos:i+1]))\\n                expr.extend([num[pos:i+1] + \"*\" + e for e in mul_expr])\\n\\n            return expr\\n        \\n        return solve(target, 0, 1, 1)",
                "codeTag": "Java"
            },
            {
                "id": 2449863,
                "title": "c-code-for-beginners-backtracking-evaluate-on-the-fly-simple-code",
                "content": "```\\nclass Solution {\\npublic:    \\n    void generate(string &num, int target, int curr, vector<string> &res, string build, long long int prevNumber, long long int currSum, int n){\\n        if(curr==num.size()){\\n            if(currSum==target){\\n                res.push_back(build);\\n            }\\n            return;\\n        }\\n        for(int len=1;len<=(n-curr);len++){  // n-curr is the remaining length of the string num\\n            string number=num.substr(curr,len);\\n            if(number[0]==\\'0\\' && number.size()>1){  // can not be having leading zeroes in size>1\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,curr+len,res,build+\"+\"+number,currNum,currSum+currNum,n); // ADD\\n            generate(num,target,curr+len,res,build+\"-\"+number,-currNum,currSum-currNum,n);  //SUBTRACT\\n            generate(num,target,curr+len,res,build+\"*\"+number,currNum*prevNumber,currSum-prevNumber+currNum*prevNumber,n);  \\n\\t\\t\\t// MULTIPLY, Notice:- the previous Number is currNum*prevNumber, this is because a multiplication will take the previous number with it, and then proceed\\n        }\\n    }\\n    vector<string> addOperators(string num, int target) {\\n        vector<string> res;\\n        int n=num.size();\\n        for(int len=1;len<=n;len++){\\n            string number=num.substr(0,len);\\n            if(number[0]==\\'0\\' && number.size()>1){\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,len,res,number,currNum,currNum,n);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    void generate(string &num, int target, int curr, vector<string> &res, string build, long long int prevNumber, long long int currSum, int n){\\n        if(curr==num.size()){\\n            if(currSum==target){\\n                res.push_back(build);\\n            }\\n            return;\\n        }\\n        for(int len=1;len<=(n-curr);len++){  // n-curr is the remaining length of the string num\\n            string number=num.substr(curr,len);\\n            if(number[0]==\\'0\\' && number.size()>1){  // can not be having leading zeroes in size>1\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,curr+len,res,build+\"+\"+number,currNum,currSum+currNum,n); // ADD\\n            generate(num,target,curr+len,res,build+\"-\"+number,-currNum,currSum-currNum,n);  //SUBTRACT\\n            generate(num,target,curr+len,res,build+\"*\"+number,currNum*prevNumber,currSum-prevNumber+currNum*prevNumber,n);  \\n\\t\\t\\t// MULTIPLY, Notice:- the previous Number is currNum*prevNumber, this is because a multiplication will take the previous number with it, and then proceed\\n        }\\n    }\\n    vector<string> addOperators(string num, int target) {\\n        vector<string> res;\\n        int n=num.size();\\n        for(int len=1;len<=n;len++){\\n            string number=num.substr(0,len);\\n            if(number[0]==\\'0\\' && number.size()>1){\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,len,res,number,currNum,currNum,n);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092254,
                "title": "c-concise-recursive-solution",
                "content": "**[C++] Solution for finding expressions with operators that gives target as result:**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        addOperatorsAndEvaluate(num, target, 0, \"\", 0, 0);\\n        return expressions;\\n    }\\n    \\nprivate:\\n    vector<string> expressions;\\n    void addOperatorsAndEvaluate(string& nums, int& target, int index, string exp, long value, long prev) {\\n        if (index==nums.size()) {\\n            if (value == target) {\\n                expressions.push_back(exp);\\n            }\\n            return;\\n        }\\n        \\n        string numStr = \"\";\\n        long num = 0;\\n        for(int j=index; j<nums.size(); j++) {\\n            // Handling the case for avoiding numbers with leading 0\\n            if (j>index && nums[index]==\\'0\\') break;\\n            \\n            numStr += nums[j];\\n            num = num*10 + (nums[j]-\\'0\\');\\n            \\n            if (exp.size()==0) {\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+numStr, num, num);\\n            } else {\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+\\'+\\'+numStr, value+num, num);\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+\\'-\\'+numStr, value-num, -num);\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+\\'*\\'+numStr, (value-prev)+(prev*num), prev*num);\\n            }\\n        }\\n    }\\n};\\n```\\n\\nPlease do **upvote** if you find this helpful.\\nFeel free to add your comments or ask queries.",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        addOperatorsAndEvaluate(num, target, 0, \"\", 0, 0);\\n        return expressions;\\n    }\\n    \\nprivate:\\n    vector<string> expressions;\\n    void addOperatorsAndEvaluate(string& nums, int& target, int index, string exp, long value, long prev) {\\n        if (index==nums.size()) {\\n            if (value == target) {\\n                expressions.push_back(exp);\\n            }\\n            return;\\n        }\\n        \\n        string numStr = \"\";\\n        long num = 0;\\n        for(int j=index; j<nums.size(); j++) {\\n            // Handling the case for avoiding numbers with leading 0\\n            if (j>index && nums[index]==\\'0\\') break;\\n            \\n            numStr += nums[j];\\n            num = num*10 + (nums[j]-\\'0\\');\\n            \\n            if (exp.size()==0) {\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+numStr, num, num);\\n            } else {\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+\\'+\\'+numStr, value+num, num);\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+\\'-\\'+numStr, value-num, -num);\\n                addOperatorsAndEvaluate(nums, target, j+1, exp+\\'*\\'+numStr, (value-prev)+(prev*num), prev*num);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963629,
                "title": "easy-to-understand-c-code",
                "content": "* ***Using Backtracking***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<string> res;\\n    \\n    void helper(string str, int target, int i, string curr, long long res_so_far, long long prev_num)\\n    {\\n        if(i == str.size())\\n        {\\n            if(res_so_far == target)\\n            {\\n                res.push_back(curr);\\n            }\\n            \\n            return;\\n        }\\n        \\n        for(int j = i; j < str.size(); j++)\\n        {\\n            if(j > i && str[i] == \\'0\\')\\n            {\\n                break;\\n            }\\n            \\n            string curr_str = str.substr(i, j - i + 1);\\n            \\n            long long curr_num = stoll(curr_str);\\n            \\n            if(i == 0)\\n            {\\n                helper(str, target, j + 1, curr + curr_str, curr_num, curr_num);\\n            }\\n            else\\n            {\\n                helper(str, target, j + 1, curr + \"+\" + curr_str, res_so_far + curr_num, curr_num);\\n                \\n                helper(str, target, j + 1, curr + \"-\" + curr_str, res_so_far - curr_num, -curr_num);\\n                \\n                helper(str, target, j + 1, curr + \"*\" + curr_str, res_so_far - prev_num + prev_num * curr_num, prev_num * curr_num);\\n            }\\n        }\\n    }\\n    \\n    vector<string> addOperators(string str, int target) {\\n        \\n        int n = str.size();\\n        \\n        helper(str, target, 0, \"\", 0, 0);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> res;\\n    \\n    void helper(string str, int target, int i, string curr, long long res_so_far, long long prev_num)\\n    {\\n        if(i == str.size())\\n        {\\n            if(res_so_far == target)\\n            {\\n                res.push_back(curr);\\n            }\\n            \\n            return;\\n        }\\n        \\n        for(int j = i; j < str.size(); j++)\\n        {\\n            if(j > i && str[i] == \\'0\\')\\n            {\\n                break;\\n            }\\n            \\n            string curr_str = str.substr(i, j - i + 1);\\n            \\n            long long curr_num = stoll(curr_str);\\n            \\n            if(i == 0)\\n            {\\n                helper(str, target, j + 1, curr + curr_str, curr_num, curr_num);\\n            }\\n            else\\n            {\\n                helper(str, target, j + 1, curr + \"+\" + curr_str, res_so_far + curr_num, curr_num);\\n                \\n                helper(str, target, j + 1, curr + \"-\" + curr_str, res_so_far - curr_num, -curr_num);\\n                \\n                helper(str, target, j + 1, curr + \"*\" + curr_str, res_so_far - prev_num + prev_num * curr_num, prev_num * curr_num);\\n            }\\n        }\\n    }\\n    \\n    vector<string> addOperators(string str, int target) {\\n        \\n        int n = str.size();\\n        \\n        helper(str, target, 0, \"\", 0, 0);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897046,
                "title": "c-back-tracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(const string& s, int idx, long long curr, long long val, int target, string& expr, vector<string>& res) {\\n        if (idx == s.size()) {\\n            if (curr == target) {\\n                res.push_back(expr);\\n            }\\n            return;\\n        }\\n        \\n        size_t sz = expr.size();\\n        long long int v = 0;\\n        for (int i = idx; i < s.size(); ++i) {\\n            v = v * 10 + s[i] - \\'0\\';\\n            \\n            string&& sub = s.substr(idx, i - idx + 1);\\n            if (idx == 0) {\\n                expr += sub;\\n                dfs(s, i + 1, curr + v, v, target, expr, res);\\n                expr.resize(sz);\\n            } else {\\n                expr += \\'+\\';\\n                expr += sub;\\n                dfs(s, i + 1, curr + v, v, target, expr, res);\\n                expr.resize(sz);\\n                \\n                expr += \\'-\\';\\n                expr += sub;\\n                dfs(s, i + 1, curr - v, -v, target, expr, res);\\n                expr.resize(sz);\\n                \\n                expr += \\'*\\';\\n                expr += sub;\\n                dfs(s, i + 1, curr - val + v * val, v * val, target, expr, res);\\n                expr.resize(sz);\\n            }\\n            \\n            if (!v) {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    vector<string> addOperators(string num, int target) {\\n        string expr;\\n        vector<string> res;\\n        dfs(num, 0, 0, 0, target, expr, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(const string& s, int idx, long long curr, long long val, int target, string& expr, vector<string>& res) {\\n        if (idx == s.size()) {\\n            if (curr == target) {\\n                res.push_back(expr);\\n            }\\n            return;\\n        }\\n        \\n        size_t sz = expr.size();\\n        long long int v = 0;\\n        for (int i = idx; i < s.size(); ++i) {\\n            v = v * 10 + s[i] - \\'0\\';\\n            \\n            string&& sub = s.substr(idx, i - idx + 1);\\n            if (idx == 0) {\\n                expr += sub;\\n                dfs(s, i + 1, curr + v, v, target, expr, res);\\n                expr.resize(sz);\\n            } else {\\n                expr += \\'+\\';\\n                expr += sub;\\n                dfs(s, i + 1, curr + v, v, target, expr, res);\\n                expr.resize(sz);\\n                \\n                expr += \\'-\\';\\n                expr += sub;\\n                dfs(s, i + 1, curr - v, -v, target, expr, res);\\n                expr.resize(sz);\\n                \\n                expr += \\'*\\';\\n                expr += sub;\\n                dfs(s, i + 1, curr - val + v * val, v * val, target, expr, res);\\n                expr.resize(sz);\\n            }\\n            \\n            if (!v) {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    vector<string> addOperators(string num, int target) {\\n        string expr;\\n        vector<string> res;\\n        dfs(num, 0, 0, 0, target, expr, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888167,
                "title": "java-dsf-solution",
                "content": "```\\n\\tpublic List<String> addOperators(String num, int target) {\\n        result = new ArrayList<String>();\\n        helper(num,0,0,\"\",target,0);\\n        return result;\\n    }\\n    private void helper(String num,int index,long soFar,String temp,int target,long prev){\\n        if(index == num.length()){\\n            if(soFar == target){\\n                result.add(temp);    \\n            }\\n        } else {\\n            for(int i = index; i < num.length(); i ++){\\n                if(i != index && num.charAt(index) == \\'0\\') break;//Any other number can not start with 0\\n                \\n                long curr = Long.valueOf(num.substring(index,i+1));\\n                if(index == 0){//If its first, no need to calculate\\n                    helper(num,i+1,curr,temp+curr,target,curr);\\n                } else {\\n                    long plusValue = curr;\\n                    helper(num,i+1,soFar+plusValue,temp+\"+\"+curr,target,plusValue);\\n                    \\n                    long minusValue = -curr;\\n                    helper(num,i+1,soFar+minusValue,temp+\"-\"+curr,target,minusValue);\\n                    \\n                    long mulValue = prev*curr;\\n                    //subtract previously added value from mulValue\\n                    helper(num,i+1,soFar+mulValue - prev,temp+\"*\"+curr,target,mulValue);\\n                }\\n            }\\n        }\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\n\\tpublic List<String> addOperators(String num, int target) {\\n        result = new ArrayList<String>();\\n        helper(num,0,0,\"\",target,0);\\n        return result;\\n    }\\n    private void helper(String num,int index,long soFar,String temp,int target,long prev){\\n        if(index == num.length()){\\n            if(soFar == target){\\n                result.add(temp);    \\n            }\\n        } else {\\n            for(int i = index; i < num.length(); i ++){\\n                if(i != index && num.charAt(index) == \\'0\\') break;//Any other number can not start with 0\\n                \\n                long curr = Long.valueOf(num.substring(index,i+1));\\n                if(index == 0){//If its first, no need to calculate\\n                    helper(num,i+1,curr,temp+curr,target,curr);\\n                } else {\\n                    long plusValue = curr;\\n                    helper(num,i+1,soFar+plusValue,temp+\"+\"+curr,target,plusValue);\\n                    \\n                    long minusValue = -curr;\\n                    helper(num,i+1,soFar+minusValue,temp+\"-\"+curr,target,minusValue);\\n                    \\n                    long mulValue = prev*curr;\\n                    //subtract previously added value from mulValue\\n                    helper(num,i+1,soFar+mulValue - prev,temp+\"*\"+curr,target,mulValue);\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1846436,
                "title": "python-bfs-not-the-fastest-but-easy-to-understand",
                "content": "Disclaimer: I\\'m using the `eval()` built-in. Feel free to replace it with your solution in https://leetcode.com/problems/basic-calculator/\\n\\n#### Idea\\n\\n- Iterate all character `n` in `num`. Between each digit, we can either insert an operater `+`, `-`, `*`, or do nothing.\\n- Keep expanding the list of all possible formula\\n- At the end of the iteration, evaluate each formula, and keep the ones that are equal to `target`\\n \\n```python\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        result = []\\n        candidates = deque()\\n        candidates.append(num[0])\\n        for i in range(1, len(num)):\\n            size = len(candidates)\\n            next_char = num[i]\\n            for _ in range(size):\\n                c = candidates.popleft()\\n                for op in [\"+\", \"-\", \"*\"]:\\n                    candidates.append(c + op + next_char)\\n                if c.endswith(\"0\") and (len(c) == 1 or not c[-2].isnumeric()):\\n                    continue\\n                candidates.append(c + next_char)\\n        return [c for c in candidates if eval(c) == target]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        result = []\\n        candidates = deque()\\n        candidates.append(num[0])\\n        for i in range(1, len(num)):\\n            size = len(candidates)\\n            next_char = num[i]\\n            for _ in range(size):\\n                c = candidates.popleft()\\n                for op in [\"+\", \"-\", \"*\"]:\\n                    candidates.append(c + op + next_char)\\n                if c.endswith(\"0\") and (len(c) == 1 or not c[-2].isnumeric()):\\n                    continue\\n                candidates.append(c + next_char)\\n        return [c for c in candidates if eval(c) == target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791871,
                "title": "python-soln-backtrack",
                "content": "\\tclass Solution:\\n\\t\\tdef addOperators(self, num: str, target: int) -> List[str]:\\n\\t\\t\\t# Time O(4^n), Space O(n)\\n\\t\\t\\tdef backtrack(idx, prev,curr,value,s):\\n\\t\\t\\t\\tif idx == n:\\n\\t\\t\\t\\t\\tif value == target and curr == 0:\\n\\t\\t\\t\\t\\t\\tself.result.append(s)\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tcurr = curr * 10 + int(num[idx])\\n\\n\\t\\t\\t\\tif curr > 0:\\n\\t\\t\\t\\t\\tbacktrack(idx+1, prev,curr,value,s)\\n\\n\\t\\t\\t\\tif not s:\\n\\t\\t\\t\\t\\tbacktrack(idx+1, curr, 0, value+curr, str(curr))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tbacktrack(idx+1, curr, 0, value+curr, s+\"+\"+str(curr))\\n\\t\\t\\t\\t\\tbacktrack(idx+1, -curr, 0, value-curr, s+\"-\"+str(curr))\\n\\t\\t\\t\\t\\tbacktrack(idx+1, prev*curr, 0, value-prev+prev*curr, s+\"*\"+str(curr))\\n\\n\\t\\t\\tn = len(num)\\n\\t\\t\\tself.result = []\\n\\t\\t\\tbacktrack(0,0,0,0,\"\")\\n\\n\\t\\t\\treturn self.result",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef addOperators(self, num: str, target: int) -> List[str]:\\n\\t\\t\\t# Time O(4^n), Space O(n)\\n\\t\\t\\tdef backtrack(idx, prev,curr,value,s):\\n\\t\\t\\t\\tif idx == n:\\n\\t\\t\\t\\t\\tif value == target and curr == 0:\\n\\t\\t\\t\\t\\t\\tself.result.append(s)\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tcurr = curr * 10 + int(num[idx])\\n\\n\\t\\t\\t\\tif curr > 0:\\n\\t\\t\\t\\t\\tbacktrack(idx+1, prev,curr,value,s)\\n\\n\\t\\t\\t\\tif not s:\\n\\t\\t\\t\\t\\tbacktrack(idx+1, curr, 0, value+curr, str(curr))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tbacktrack(idx+1, curr, 0, value+curr, s+\"+\"+str(curr))\\n\\t\\t\\t\\t\\tbacktrack(idx+1, -curr, 0, value-curr, s+\"-\"+str(curr))\\n\\t\\t\\t\\t\\tbacktrack(idx+1, prev*curr, 0, value-prev+prev*curr, s+\"*\"+str(curr))\\n\\n\\t\\t\\tn = len(num)\\n\\t\\t\\tself.result = []\\n\\t\\t\\tbacktrack(0,0,0,0,\"\")\\n\\n\\t\\t\\treturn self.result",
                "codeTag": "Java"
            },
            {
                "id": 1566064,
                "title": "c-clean-and-concise-code",
                "content": "class Solution {\\npublic:\\n    \\n    void func(vector<string>&res,string curExp,string input,long long target,long long pos,long long curVal,long long last){\\n        \\n        if(pos==input.length()){\\n            \\n            if(curVal==target){\\n                res.push_back(curExp);\\n            }\\n            \\n            return;\\n            \\n        }\\n        \\n        for(int i=pos;i<input.length();i++){\\n            \\n            if(i!=pos && input[pos]==\\'0\\'){\\n                break;\\n            }\\n            \\n            string part=input.substr(pos,i+1-pos);\\n            \\n            long long curr=stoll(part);\\n            \\n            if(pos==0){\\n                \\n                func(res,curExp+part,input,target,i+1,curr,curr);\\n                \\n            }\\n            \\n            \\n            else{\\n                \\n                \\n                 func(res,curExp+\"+\"+part,input,target,i+1,curVal+curr,curr);\\n                \\n                 func(res,curExp+\"-\"+part,input,target,i+1,curVal-curr,-curr);\\n                \\n                 func(res,curExp+\"*\"+part,input,target,i+1,curVal-last+last*curr,last*curr);\\n                \\n                \\n            }\\n            \\n        }\\n        \\n        \\n    }\\n    \\n    vector<string> addOperators(string num, int target) {\\n        \\n        vector<string>res;\\n        \\n        func(res,\"\",num,target,0,0,0);\\n        \\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    void func(vector<string>&res,string curExp,string input,long long target,long long pos,long long curVal,long long last){\\n        \\n        if(pos==input.length()){\\n            \\n            if(curVal==target){\\n                res.push_back(curExp);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1541067,
                "title": "python-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        \\n        res = []\\n        \\n        def recurse(sidx, path, result_so_far, prev_num):\\n            if sidx == len(num):\\n                if result_so_far == target:\\n                    res.append(path[:]) \\n                return\\n            \\n            for i in range(sidx, len(num)):\\n                prefix = num[sidx:i+1]\\n                curr_num = int(prefix)\\n                \\n                if len(prefix) > 1 and prefix[0] == \"0\": return # don\\'t process if there is a leading 0. \\n                \\n                if prev_num is None:\\n                    recurse(i+1, path + prefix, result_so_far + curr_num, curr_num)\\n                else:\\n                    # consider +\\n                    recurse(i+1, path+\\'+\\'+prefix, result_so_far + curr_num, curr_num)\\n                    # consider -\\n                    recurse(i+1, path+\\'-\\'+prefix, result_so_far - curr_num, -curr_num)\\n                    # consider *\\n                    #temp = result_so_far - prev_num\\n                    #result_so_far = temp + curr_num * prev_num\\n                    #prev_num = (curr_num * prev_num) THIS IS THE CRUX of this Problem\\n                    recurse(i+1, path+\\'*\\'+prefix, result_so_far - prev_num + (curr_num * prev_num), (curr_num * prev_num))\\n\\n        recurse(0,\"\", 0, None)\\n        return res\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        \\n        res = []\\n        \\n        def recurse(sidx, path, result_so_far, prev_num):\\n            if sidx == len(num):\\n                if result_so_far == target:\\n                    res.append(path[:]) \\n                return\\n            \\n            for i in range(sidx, len(num)):\\n                prefix = num[sidx:i+1]\\n                curr_num = int(prefix)\\n                \\n                if len(prefix) > 1 and prefix[0] == \"0\": return # don\\'t process if there is a leading 0. \\n                \\n                if prev_num is None:\\n                    recurse(i+1, path + prefix, result_so_far + curr_num, curr_num)\\n                else:\\n                    # consider +\\n                    recurse(i+1, path+\\'+\\'+prefix, result_so_far + curr_num, curr_num)\\n                    # consider -\\n                    recurse(i+1, path+\\'-\\'+prefix, result_so_far - curr_num, -curr_num)\\n                    # consider *\\n                    #temp = result_so_far - prev_num\\n                    #result_so_far = temp + curr_num * prev_num\\n                    #prev_num = (curr_num * prev_num) THIS IS THE CRUX of this Problem\\n                    recurse(i+1, path+\\'*\\'+prefix, result_so_far - prev_num + (curr_num * prev_num), (curr_num * prev_num))\\n\\n        recurse(0,\"\", 0, None)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536328,
                "title": "python3-strightforward-and-consice",
                "content": "Similar idea with \\'calculators\\' problems, we record previous value for the multiply and check every possible symble/number combinations.\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n        prev = None\\n        def dfs(i, val, path, prev):\\n            if i == len(num):\\n                if val == target:\\n                    res.append(path)\\n                return\\n            cur_val = 0\\n            for j in range(i, len(num)):\\n                cur_val = cur_val * 10 + int(num[j])\\n                if prev == None:\\n                    dfs(j+1, val+cur_val, path+num[i:j+1],cur_val)\\n                else:\\n                    dfs(j+1, val+cur_val,path+\\'+\\'+num[i:j+1],cur_val)\\n                    dfs(j+1, val-cur_val,path+\\'-\\'+num[i:j+1],-cur_val)\\n                    dfs(j+1, val+cur_val*prev-prev,path+\\'*\\'+num[i:j+1],cur_val*prev)\\n                \\n                if num[i] == \\'0\\':#prevent leading zeros\\n                    break\\n        dfs(0, 0, \\'\\', None)\\n        return res\\n                ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n        prev = None\\n        def dfs(i, val, path, prev):\\n            if i == len(num):\\n                if val == target:\\n                    res.append(path)\\n                return\\n            cur_val = 0\\n            for j in range(i, len(num)):\\n                cur_val = cur_val * 10 + int(num[j])\\n                if prev == None:\\n                    dfs(j+1, val+cur_val, path+num[i:j+1],cur_val)\\n                else:\\n                    dfs(j+1, val+cur_val,path+\\'+\\'+num[i:j+1],cur_val)\\n                    dfs(j+1, val-cur_val,path+\\'-\\'+num[i:j+1],-cur_val)\\n                    dfs(j+1, val+cur_val*prev-prev,path+\\'*\\'+num[i:j+1],cur_val*prev)\\n                \\n                if num[i] == \\'0\\':#prevent leading zeros\\n                    break\\n        dfs(0, 0, \\'\\', None)\\n        return res\\n                ```",
                "codeTag": "Java"
            },
            {
                "id": 1471556,
                "title": "javascript-backtracking-99-93",
                "content": "![image](https://assets.leetcode.com/users/images/55b2671b-75dc-4252-ac72-e6c0a1d38e2e_1632000773.7629488.png)\\n\\nNot even going to lie to you, this one\\'s Hard.  See LC solution tab for basic approach.\\n\\n```\\nvar addOperators = function(num, target) {\\n  const res = [];\\n  backtrack();\\n  return res;\\n  \\n  function backtrack(ind = 0, tot = 0, exp = \\'\\', curNum = 0, befMult = 0) {\\n    //If at end and curNum is still a value or we didn\\'t find the total\\n    //Return because it\\'s not a correct solution path.\\n    if (ind === num.length && (curNum || tot !== target)) return;\\n\\t\\n    //If at end and total === target, push answer and return.\\n    if (ind === num.length && tot === target) return res.push(exp);\\n\\t\\n    //num[ind]-0 converts string at current index to a number.\\n    //*10 grow cur.  Two lines below just give possible number permutations.\\n    //Note that all recursive calls other than this one set curNum = 0.\\n    //This one calls with curNum = next.  What is next though?\\n    //First time this runs, next = 0 * 10 + (num[ind]-0).  Let\\'s say we get 1 in num[ind],\\n    //0*10 + 1 = 1.  Then we invoke backtrack again, but we only increment index and \\n    //pass in our 1.  Now, next time, next = 1 * 10 + num[idx].  Let\\'s say 5 this time.\\n    //This sets next to 15.  In this way, we have built up 15 from 1,5.  Combinations\\n    //of all the above are now in recursive paths.  The if(next) ensures we aren\\'t recursing\\n\\t//down erroneous paths - Ie. \\'10122\\' could lead us to build up \\'01\\', \\'012\\', \\'0122\\' which \\n\\t//just turns out to be the same as if we skipped the 0 and started building up at the 1.\\n    const next = curNum * 10 + (num[ind]-0);\\n    if (next) backtrack(ind+1, tot, exp, next, befMult);\\n\\t\\n    //Here we add.  We start with adding because if expression is empty (as in when invoked),\\n    //we can\\'t just subtract or multiply out of the gate.  We need to get at least one number in expression\\n    //before doing those operations, else \\'-5\\' or \\'*5\\' is going to end up at the start of our exp.\\n    //Here, we can check if there\\'s expression length or not, if not, we just add next num as a string (+\\'\\').\\n    //This is allowed because 0 + num still equals the num.  0 - 5 doesn\\'t equal the original num, and 0*5\\n    //certainly doesn\\'t either.  Ergo, we have to add first in order to attain a valid starting number to recurse on.\\n\\t//If total = -5 or 0 after just having a \\'5\\' in expression, our expression and total are out of sync.  Adding first\\n\\t//avoids this issue.\\n    backtrack(ind+1, tot + next, exp.length ? exp+\"+\"+next : next + \\'\\', 0, next);\\n\\t\\n    //If we are in a recursion level After initial invocation, there will be exp.length.\\n    //Now that we know we already have at least one num in the exp, we can use\\n    //the other operators to alter total / expression.\\n    if (exp.length) {\\n      backtrack(ind+1, tot - next, exp+\"-\"+next, 0, -next);\\n\\t\\t\\n      //This is the trickiest part of the problem imo.  If you could just use eval(exp) every time to \\n      //calculate total not on-the-fly, it\\'s Way easier.  Butttttt, I suppose when you get a number\\n      //like 999879687348598, and have expressions like \\'9+9*9-8*7-9+6-8*3-4-8*5+9-8\\'...\\n      //and you\\'re evaluating on Every permutation / recursion level... That is a little taxing.  \\n      //Keeping track of the total Before multiplying last is very clever and definitely the right way \\n      //to do it, but that\\'s not an easy intuitive leap to make imo.  Hopefully my future interviewer\\'s fine \\n      //with the terrible eval() runtime or generous with the hints. lol...  Because I\\'m not sure I\\'d get\\n      //this without at least a nudge.\\n      backtrack(ind+1, tot - befMult + (befMult * next), exp+\"*\"+next, 0, (befMult * next));\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addOperators = function(num, target) {\\n  const res = [];\\n  backtrack();\\n  return res;\\n  \\n  function backtrack(ind = 0, tot = 0, exp = \\'\\', curNum = 0, befMult = 0) {\\n    //If at end and curNum is still a value or we didn\\'t find the total\\n    //Return because it\\'s not a correct solution path.\\n    if (ind === num.length && (curNum || tot !== target)) return;\\n\\t\\n    //If at end and total === target, push answer and return.\\n    if (ind === num.length && tot === target) return res.push(exp);\\n\\t\\n    //num[ind]-0 converts string at current index to a number.\\n    //*10 grow cur.  Two lines below just give possible number permutations.\\n    //Note that all recursive calls other than this one set curNum = 0.\\n    //This one calls with curNum = next.  What is next though?\\n    //First time this runs, next = 0 * 10 + (num[ind]-0).  Let\\'s say we get 1 in num[ind],\\n    //0*10 + 1 = 1.  Then we invoke backtrack again, but we only increment index and \\n    //pass in our 1.  Now, next time, next = 1 * 10 + num[idx].  Let\\'s say 5 this time.\\n    //This sets next to 15.  In this way, we have built up 15 from 1,5.  Combinations\\n    //of all the above are now in recursive paths.  The if(next) ensures we aren\\'t recursing\\n\\t//down erroneous paths - Ie. \\'10122\\' could lead us to build up \\'01\\', \\'012\\', \\'0122\\' which \\n\\t//just turns out to be the same as if we skipped the 0 and started building up at the 1.\\n    const next = curNum * 10 + (num[ind]-0);\\n    if (next) backtrack(ind+1, tot, exp, next, befMult);\\n\\t\\n    //Here we add.  We start with adding because if expression is empty (as in when invoked),\\n    //we can\\'t just subtract or multiply out of the gate.  We need to get at least one number in expression\\n    //before doing those operations, else \\'-5\\' or \\'*5\\' is going to end up at the start of our exp.\\n    //Here, we can check if there\\'s expression length or not, if not, we just add next num as a string (+\\'\\').\\n    //This is allowed because 0 + num still equals the num.  0 - 5 doesn\\'t equal the original num, and 0*5\\n    //certainly doesn\\'t either.  Ergo, we have to add first in order to attain a valid starting number to recurse on.\\n\\t//If total = -5 or 0 after just having a \\'5\\' in expression, our expression and total are out of sync.  Adding first\\n\\t//avoids this issue.\\n    backtrack(ind+1, tot + next, exp.length ? exp+\"+\"+next : next + \\'\\', 0, next);\\n\\t\\n    //If we are in a recursion level After initial invocation, there will be exp.length.\\n    //Now that we know we already have at least one num in the exp, we can use\\n    //the other operators to alter total / expression.\\n    if (exp.length) {\\n      backtrack(ind+1, tot - next, exp+\"-\"+next, 0, -next);\\n\\t\\t\\n      //This is the trickiest part of the problem imo.  If you could just use eval(exp) every time to \\n      //calculate total not on-the-fly, it\\'s Way easier.  Butttttt, I suppose when you get a number\\n      //like 999879687348598, and have expressions like \\'9+9*9-8*7-9+6-8*3-4-8*5+9-8\\'...\\n      //and you\\'re evaluating on Every permutation / recursion level... That is a little taxing.  \\n      //Keeping track of the total Before multiplying last is very clever and definitely the right way \\n      //to do it, but that\\'s not an easy intuitive leap to make imo.  Hopefully my future interviewer\\'s fine \\n      //with the terrible eval() runtime or generous with the hints. lol...  Because I\\'m not sure I\\'d get\\n      //this without at least a nudge.\\n      backtrack(ind+1, tot - befMult + (befMult * next), exp+\"*\"+next, 0, (befMult * next));\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1470697,
                "title": "python-dfs-solution-for-loop-clear",
                "content": "Idea:\\n- We start with the first digit then add other digits with operators `\\'+\\',\\'-\\',\\'*\\',\\'\\'` in front. \\n- We need empty operator to add more digits to the digit. At the end we evall all the operations in stack and if it\\'s equal to target we return it.\\n\\n- The trickiest part is to avoid making oprations like \\'1+00\\'. The way to slove that if previous number is \\'0\\' and operator is \\'\\' we go back until we can and meet non \\'0\\' or operators `\\'+\\',\\'-\\',\\'*\\'`. Depending on the way we stopped we proceed with adding more 0s or skip.\\n\\n\\n```python\\nclass Solution:\\n    def addOperators(self, S: str, target: int) -> List[str]:\\n        q = [S[0]]\\n        \\n        for n in S[1:]:\\n            updated_q = []\\n            while q:\\n                node = q.pop()\\n                for o in {\\'*\\',\\'+\\',\\'-\\',\\'\\'}:\\n                    # check if node before == 0 \\n                    # then we need to force adding operator if number is \\'0\\' to avoid \\'00\\'\\n                    # otherwise if number ends with 0 but starts with other digit like 1 (\\'1000\\') we are fine\\n                    if node[-1] == \\'0\\' and o == \\'\\':\\n                        i = len(node)-1\\n                        while i >= 0 and node[i] == \\'0\\':\\n                            i -= 1\\n                        if i < 0 or node[i] in {\\'*\\',\\'+\\',\\'-\\'}:\\n                            continue\\n                            \\n                    updated_q.append(node + o + n)\\n            q = updated_q[:]\\n        \\n        return [e for e in q if eval(e) == target]       \\n```\\nTime coplexity: `O(N 4^N)`\\nSpace: `O(4 ^ N)`",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def addOperators(self, S: str, target: int) -> List[str]:\\n        q = [S[0]]\\n        \\n        for n in S[1:]:\\n            updated_q = []\\n            while q:\\n                node = q.pop()\\n                for o in {\\'*\\',\\'+\\',\\'-\\',\\'\\'}:\\n                    # check if node before == 0 \\n                    # then we need to force adding operator if number is \\'0\\' to avoid \\'00\\'\\n                    # otherwise if number ends with 0 but starts with other digit like 1 (\\'1000\\') we are fine\\n                    if node[-1] == \\'0\\' and o == \\'\\':\\n                        i = len(node)-1\\n                        while i >= 0 and node[i] == \\'0\\':\\n                            i -= 1\\n                        if i < 0 or node[i] in {\\'*\\',\\'+\\',\\'-\\'}:\\n                            continue\\n                            \\n                    updated_q.append(node + o + n)\\n            q = updated_q[:]\\n        \\n        return [e for e in q if eval(e) == target]       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402499,
                "title": "backtracking-c-solution",
                "content": "Here\\'s my solution. It gives correct results but also produces duplicate strings. Can anybody please tell me how to prevent the duplicacy?\\n```\\nclass Solution {\\npublic:\\n    void solve(unordered_set<string> &res, string num, int target, int ind, int n, string temp){\\n        if(ind == n){\\n            temp.pop_back();\\n            int a = temp[0]-\\'0\\', op;\\n            for(int i = 1; i < temp.length(); i++){\\n                if(temp[i] != \\'+\\' && temp[i] != \\'-\\' && temp[i] != \\'*\\'){\\n                    if(op == \\'+\\'){\\n                        a += (temp[i]-\\'0\\');\\n                    }\\n                    if(op == \\'*\\'){\\n                        a *= (temp[i]-\\'0\\');\\n                    }\\n                    if(op == \\'-\\'){\\n                        a -= (temp[i]-\\'0\\');\\n                    }\\n                }\\n                else{\\n                    op = temp[i];\\n                }\\n            }\\n            if(a == target){\\n                res.insert(temp);\\n            }\\n            return;\\n        }\\n        \\n        temp += num.substr(ind, 1) + \"+\";\\n        solve(res, num, target, ind+1, n, temp);\\n        temp.erase(temp.end()-2, temp.end());\\n        \\n        temp += num.substr(ind, 1) + \"-\";\\n        solve(res, num, target, ind+1, n, temp);\\n        temp.erase(temp.end()-2, temp.end());\\n        \\n        temp += num.substr(ind, 1) + \"*\";\\n        solve(res, num, target, ind+1, n, temp);\\n        temp.erase(temp.end()-2, temp.end());\\n    }\\n    vector<string> addOperators(string num, int target) {\\n        unordered_set<string> res;\\n        vector<string> ans;\\n        int n = num.length();\\n        \\n        solve(res, num, target, 0, n, \"\");\\n        \\n        for(auto i : res){\\n            ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(unordered_set<string> &res, string num, int target, int ind, int n, string temp){\\n        if(ind == n){\\n            temp.pop_back();\\n            int a = temp[0]-\\'0\\', op;\\n            for(int i = 1; i < temp.length(); i++){\\n                if(temp[i] != \\'+\\' && temp[i] != \\'-\\' && temp[i] != \\'*\\'){\\n                    if(op == \\'+\\'){\\n                        a += (temp[i]-\\'0\\');\\n                    }\\n                    if(op == \\'*\\'){\\n                        a *= (temp[i]-\\'0\\');\\n                    }\\n                    if(op == \\'-\\'){\\n                        a -= (temp[i]-\\'0\\');\\n                    }\\n                }\\n                else{\\n                    op = temp[i];\\n                }\\n            }\\n            if(a == target){\\n                res.insert(temp);\\n            }\\n            return;\\n        }\\n        \\n        temp += num.substr(ind, 1) + \"+\";\\n        solve(res, num, target, ind+1, n, temp);\\n        temp.erase(temp.end()-2, temp.end());\\n        \\n        temp += num.substr(ind, 1) + \"-\";\\n        solve(res, num, target, ind+1, n, temp);\\n        temp.erase(temp.end()-2, temp.end());\\n        \\n        temp += num.substr(ind, 1) + \"*\";\\n        solve(res, num, target, ind+1, n, temp);\\n        temp.erase(temp.end()-2, temp.end());\\n    }\\n    vector<string> addOperators(string num, int target) {\\n        unordered_set<string> res;\\n        vector<string> ans;\\n        int n = num.length();\\n        \\n        solve(res, num, target, 0, n, \"\");\\n        \\n        for(auto i : res){\\n            ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193048,
                "title": "swift-clean-code",
                "content": "```swift\\nclass Solution {\\n    func addOperators(_ num: String, _ target: Int) -> [String] {\\n        var res = [String]()\\n        let sArr = Array(num)\\n        func dfs(_ path: String, _ index: Int, _ value: Int, _ multed: Int) {\\n            if index == sArr.endIndex {\\n                if value == target {\\n                    res.append(path)    \\n                }\\n                return\\n            }\\n            var curr = 0\\n            for i in index..<sArr.endIndex {\\n                if i != index && sArr[index] == \"0\" {break}\\n                curr = curr*10 + Int(String(sArr[i]))!\\n                if index == 0 {\\n                    dfs(path+\"\\\\(curr)\", i+1, curr, curr)\\n                } else {\\n                    dfs(path+\"+\\\\(curr)\", i+1, value + curr, curr)\\n                    dfs(path+\"-\\\\(curr)\", i+1, value - curr, -curr)\\n                    dfs(path+\"*\\\\(curr)\", i+1, value - multed + multed * curr, multed * curr)\\n                }\\n            }\\n        }\\n        dfs(\"\",0,0,0)\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func addOperators(_ num: String, _ target: Int) -> [String] {\\n        var res = [String]()\\n        let sArr = Array(num)\\n        func dfs(_ path: String, _ index: Int, _ value: Int, _ multed: Int) {\\n            if index == sArr.endIndex {\\n                if value == target {\\n                    res.append(path)    \\n                }\\n                return\\n            }\\n            var curr = 0\\n            for i in index..<sArr.endIndex {\\n                if i != index && sArr[index] == \"0\" {break}\\n                curr = curr*10 + Int(String(sArr[i]))!\\n                if index == 0 {\\n                    dfs(path+\"\\\\(curr)\", i+1, curr, curr)\\n                } else {\\n                    dfs(path+\"+\\\\(curr)\", i+1, value + curr, curr)\\n                    dfs(path+\"-\\\\(curr)\", i+1, value - curr, -curr)\\n                    dfs(path+\"*\\\\(curr)\", i+1, value - multed + multed * curr, multed * curr)\\n                }\\n            }\\n        }\\n        dfs(\"\",0,0,0)\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1041628,
                "title": "c-using-backtracking-template-with-explaination",
                "content": "I have used standard backtracking template to solve the problem with optimizations to calculate the value of expressiom on the fly.\\nindex variable is the starting point of second operand, except when index == 0 (as first operator has not been selected yet).\\n\\nThere are 3 operators that can be applied to second operand: +, - , *\\nWe take care of concatenating digits when calculating operand.\\n\\nThe idea here is to reduce the expression as a + b. We are storing 2 varibales for calculations. Add denotes a, and Mul denotes b.\\nAs * has higher precedence over + and -, we want to store operand, if next operator is *\\nMul dentotes operand if next operator is *\\nAdd denotes operand for +\\n\\nTotal value for expression = add + mul\\n\\n```\\ne.g. 1 * 2 + 5 - 3 * 4 * 3 + 1\\n\\t\\t\\t\\t   A          M\\n1                  0          1\\n1*2                0          2\\n1*2+5              2          5 (If * is next operator, it will get multiplied to 5 only, so we apply + operator, Add = Mul + Add)\\n1*2+5-3            7         -3 (similarly, for * to be next operator, -3 will be first operand, so Add = Add + Mul)\\n1*2+5-3*4          7         -12 (If * is next operator, it should get multiplied to -3*4) \\n1*2+5-3*4*3        7         -36\\n1*2+5-3*4*3+1     -31         1\\n```\\n\\n```\\nclass Solution {\\n    vector<string> result;\\n    int target;\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        this->target = target;\\n        string s = \"\";\\n        getComb(num, 0, 0, 0, s);\\n        return result;\\n    }\\n    \\n    void getComb(string& num, int index, long add, long mul, string s) {\\n        if (add > INT_MAX || mul > INT_MAX) {\\n            return;\\n        }\\n        \\n        if (index == num.size()) {\\n            if (add + mul == target) {\\n                result.push_back(s);\\n            }\\n            return;\\n        }\\n        \\n        for (int i = index; i < num.size(); i++) {\\n            if (num.at(index) == \\'0\\' && i > index) {\\n                return;\\n            }\\n            \\n            long x = stol(num.substr(index, i - index + 1));\\n            if (index == 0) {\\n                getComb(num, i + 1, 0, x, s + to_string(x));\\n                continue;\\n            }\\n            \\n            getComb(num, i + 1, add + mul, x, s + \"+\" + to_string(x));\\n            getComb(num, i + 1, add + mul, -x, s + \"-\" + to_string(x));            \\n            getComb(num, i + 1, add, mul * x, s + \"*\" + to_string(x));\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\ne.g. 1 * 2 + 5 - 3 * 4 * 3 + 1\\n\\t\\t\\t\\t   A          M\\n1                  0          1\\n1*2                0          2\\n1*2+5              2          5 (If * is next operator, it will get multiplied to 5 only, so we apply + operator, Add = Mul + Add)\\n1*2+5-3            7         -3 (similarly, for * to be next operator, -3 will be first operand, so Add = Add + Mul)\\n1*2+5-3*4          7         -12 (If * is next operator, it should get multiplied to -3*4) \\n1*2+5-3*4*3        7         -36\\n1*2+5-3*4*3+1     -31         1\\n```\n```\\nclass Solution {\\n    vector<string> result;\\n    int target;\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        this->target = target;\\n        string s = \"\";\\n        getComb(num, 0, 0, 0, s);\\n        return result;\\n    }\\n    \\n    void getComb(string& num, int index, long add, long mul, string s) {\\n        if (add > INT_MAX || mul > INT_MAX) {\\n            return;\\n        }\\n        \\n        if (index == num.size()) {\\n            if (add + mul == target) {\\n                result.push_back(s);\\n            }\\n            return;\\n        }\\n        \\n        for (int i = index; i < num.size(); i++) {\\n            if (num.at(index) == \\'0\\' && i > index) {\\n                return;\\n            }\\n            \\n            long x = stol(num.substr(index, i - index + 1));\\n            if (index == 0) {\\n                getComb(num, i + 1, 0, x, s + to_string(x));\\n                continue;\\n            }\\n            \\n            getComb(num, i + 1, add + mul, x, s + \"+\" + to_string(x));\\n            getComb(num, i + 1, add + mul, -x, s + \"-\" + to_string(x));            \\n            getComb(num, i + 1, add, mul * x, s + \"*\" + to_string(x));\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992834,
                "title": "c-solution-beats-80",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> result;\\n\\n    vector<string> addOperators(string &num, int target) {\\n        dfs(num, target, 0, \"\", 0, 0);\\n        return result;\\n    }\\n\\n    void dfs(string &num, int target, int start, string str, long long sum, long long last) {\\n        if (num.size() == start) {\\n            if (target == sum) result.push_back(str);\\n            return;\\n        }\\n        \\n        long long x = 0;\\n        string ret = \"\";\\n        \\n        for (int i = start; i < num.size(); ++i) {\\n            x = x * 10 + num[i] - \\'0\\';\\n            ret += num[i];\\n            \\n            if (start == 0) {\\n                dfs(num, target, i + 1, str + ret, x, x);\\n            } else {\\n                dfs(num, target, i + 1, str + \"*\" + ret, sum - last + x * last, x * last);\\n                dfs(num, target, i + 1, str + \"+\" + ret, sum + x, x);\\n                dfs(num, target, i + 1, str + \"-\" + ret, sum - x, -x);\\n            }\\n            \\n            if (x == 0) break;            \\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> result;\\n\\n    vector<string> addOperators(string &num, int target) {\\n        dfs(num, target, 0, \"\", 0, 0);\\n        return result;\\n    }\\n\\n    void dfs(string &num, int target, int start, string str, long long sum, long long last) {\\n        if (num.size() == start) {\\n            if (target == sum) result.push_back(str);\\n            return;\\n        }\\n        \\n        long long x = 0;\\n        string ret = \"\";\\n        \\n        for (int i = start; i < num.size(); ++i) {\\n            x = x * 10 + num[i] - \\'0\\';\\n            ret += num[i];\\n            \\n            if (start == 0) {\\n                dfs(num, target, i + 1, str + ret, x, x);\\n            } else {\\n                dfs(num, target, i + 1, str + \"*\" + ret, sum - last + x * last, x * last);\\n                dfs(num, target, i + 1, str + \"+\" + ret, sum + x, x);\\n                dfs(num, target, i + 1, str + \"-\" + ret, sum - x, -x);\\n            }\\n            \\n            if (x == 0) break;            \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 962682,
                "title": "simplified-python-solution-backtracking-w-o-eval",
                "content": "Example by leetcode was excessively complicated, so simplified\\n\\n````\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n\\n        def backtrack(idx,prev,value,path):\\n            nonlocal res\\n\\n            if idx == len(num):\\n                if value == target:\\n\\t\\t\\t\\t\\t# trim first char as it will be +\\n                    res.append(path[1:])\\n                return\\n\\n            curr = 0\\n            curr_s = \\'\\'\\n\\n            # create all prefixes e.g. 1, 12, 123\\n            for i in range(idx,len(num)):\\n                curr *= 10\\n                curr += int(num[i])  \\n                curr_s += num[i]\\n\\n                # add to current total\\n                backtrack(i+1, curr, value + curr, path + \\'+\\' + curr_s)\\n\\n                if path:\\n                    # minus from current total\\n                    backtrack(i+1, -curr, value - curr, path + \\'-\\' + curr_s)\\n                    \\n                    # multiply is a special case\\n                    # as * has precedence we need\\n                    # to remove the previous value\\n                    # and multiply with the current\\n                    backtrack(i+1, prev * curr, value - prev + prev * curr, path + \\'*\\' + curr_s)\\n\\n                # nothing else can be created as prefix is 0 (01)\\n                if curr == 0:\\n                    break\\n\\n        backtrack(0,0,0,\\'\\')\\n        return res\\n```",
                "solutionTags": [],
                "code": "````\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n\\n        def backtrack(idx,prev,value,path):\\n            nonlocal res\\n\\n            if idx == len(num):\\n                if value == target:\\n\\t\\t\\t\\t\\t# trim first char as it will be +\\n                    res.append(path[1:])\\n                return\\n\\n            curr = 0\\n            curr_s = \\'\\'\\n\\n            # create all prefixes e.g. 1, 12, 123\\n            for i in range(idx,len(num)):\\n                curr *= 10\\n                curr += int(num[i])  \\n                curr_s += num[i]\\n\\n                # add to current total\\n                backtrack(i+1, curr, value + curr, path + \\'+\\' + curr_s)\\n\\n                if path:\\n                    # minus from current total\\n                    backtrack(i+1, -curr, value - curr, path + \\'-\\' + curr_s)\\n                    \\n                    # multiply is a special case\\n                    # as * has precedence we need\\n                    # to remove the previous value\\n                    # and multiply with the current\\n                    backtrack(i+1, prev * curr, value - prev + prev * curr, path + \\'*\\' + curr_s)\\n\\n                # nothing else can be created as prefix is 0 (01)\\n                if curr == 0:\\n                    break\\n\\n        backtrack(0,0,0,\\'\\')\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 837116,
                "title": "simple-and-easy-python-solution-backtracking",
                "content": "```\\nclass Solution:\\n    def Util(self, num, target, ind, l, mem, exp):\\n        if ind == l - 1:\\n            exp += num[ind]\\n            if eval(exp) == target:\\n                return [exp]\\n        if ind >= l:\\n            return []\\n        ret1 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]) + \\'+\\')\\n        ret2 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]) + \\'-\\')\\n        ret3 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]) + \\'*\\')\\n        if (exp and exp[-1].isdigit() is True and num[ind] == \\'0\\') or num[ind] != \\'0\\':\\n            ret4 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]))\\n            ret = ret1 + ret2 + ret3 + ret4\\n        else:\\n            ret = ret1 + ret2 + ret3\\n        return ret\\n        \\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        return self.Util(num, target, 0, len(num), dict(), \\'\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def Util(self, num, target, ind, l, mem, exp):\\n        if ind == l - 1:\\n            exp += num[ind]\\n            if eval(exp) == target:\\n                return [exp]\\n        if ind >= l:\\n            return []\\n        ret1 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]) + \\'+\\')\\n        ret2 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]) + \\'-\\')\\n        ret3 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]) + \\'*\\')\\n        if (exp and exp[-1].isdigit() is True and num[ind] == \\'0\\') or num[ind] != \\'0\\':\\n            ret4 = self.Util(num, target, ind + 1, l, mem, exp + str(num[ind]))\\n            ret = ret1 + ret2 + ret3 + ret4\\n        else:\\n            ret = ret1 + ret2 + ret3\\n        return ret\\n        \\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        return self.Util(num, target, 0, len(num), dict(), \\'\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724989,
                "title": "bfs-and-dfs-with-intuitive-figure-and-explanations-python3",
                "content": "the example figure for DFS, input is \\'123\\' and target=6\\n![image](https://assets.leetcode.com/users/images/115f3d0f-c186-4ce4-822c-21e4fea6cf2e_1594172504.141081.png)\\n\\nspecial case:\\n![image](https://assets.leetcode.com/users/images/558c2bf1-4c09-47e2-a094-6c2806b77549_1594523624.2076805.png)\\n\\n\\n\\n```\\nclass Solution:\\n    \\n    # bfs\\n    def addOperators_bfs(self, numstr, target):\\n        res = []\\n        q = collections.deque() # try to use deque here, if use [], it will be too slow to pass OJ\\n        for i in range(1, len(numstr)+1):\\n            if i == 1 or (i>1 and numstr[0] != \\'0\\'):\\n                q.append([numstr[i:], numstr[:i], int(numstr[:i]), int(numstr[:i])]) \\n                # remain str, current formula, the value of current formula, the last.vale of the formula\\n        \\n        while q:\\n            qsize = len(q)\\n            for i in range(qsize):\\n                atuple = q.popleft() # collections.deque() or popleft() is also fine\\n                remainstr, fstr, fval, flast = atuple[0], atuple[1], atuple[2], atuple[3]\\n                if len(remainstr) == 0 and fval == target:\\n                    res.append(fstr)\\n                    continue\\n                \\n                for j in range(1, len(remainstr)+1):\\n                    if j==1 or (j>1 and remainstr[0] != \\'0\\'):\\n                        # +, -, *\\n                        val = remainstr[:j]\\n                        q.append([remainstr[j:], fstr + \\'+\\' + val, fval + int(val), int(val)])\\n                        q.append([remainstr[j:], fstr + \\'-\\' + val, fval - int(val), -int(val)])\\n                        q.append([remainstr[j:], fstr + \\'*\\' + val, fval - flast + flast*int(val), flast*int(val)])\\n        return res\\n    \\n    # dfs\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n        self.target = target\\n        \\n        for i in range(1, len(num) + 1):\\n            if i==1 or (i>1 and num[0] != \\'0\\'):\\n                self.dfs(num[i:], num[:i], int(num[:i]), int(num[:i]), res)\\n        return res\\n    \\n    def dfs(self, num, fstr, fval, flast, res):\\n        # fstr = string of current formula\\n        # fval = value of current formula\\n        # flast = last value for +- and last computing result for * in formula. For example, if fstr=2+3, then flast=3, if fstr=2-3, then flast=-3, if fstr=2+3*4, then flast=3*4=12\\n        if not num:\\n            if fval == self.target:\\n                res.append(fstr)\\n            return\\n        \\n        for i in range(1, len(num)+1):\\n            val=num[:i]\\n            if i == 1 or (i>1 and num[0] != \\'0\\'):\\n                self.dfs(num[i:], fstr + \\'+\\' + val, fval + int(val), int(val), res)\\n                self.dfs(num[i:], fstr + \\'-\\' + val, fval - int(val), -int(val), res)\\n                self.dfs(num[i:], fstr + \\'*\\' + val, fval-flast+flast*int(val), flast*int(val), res)\\n               \\n            # 2+3*2: currently coming is *2, current formula = 2+3, its value is 5, the last vale of this formula is 3, thus: 5-3+3*2 is fine\\n            # 2-3*5: currently coming is *5, current formula = 2-3, its value is -1, the last vale of this formula is -3, thus: -1-(-3) + (-3)*5 = -1+3-15=-13\\n            # 3*5*2: currently coming is *2, current formula = 3*5, its value is 15, the last vale of this formula is 3*5=15!, thus: 15-15+15*2=30, result is okay as well\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    # bfs\\n    def addOperators_bfs(self, numstr, target):\\n        res = []\\n        q = collections.deque() # try to use deque here, if use [], it will be too slow to pass OJ\\n        for i in range(1, len(numstr)+1):\\n            if i == 1 or (i>1 and numstr[0] != \\'0\\'):\\n                q.append([numstr[i:], numstr[:i], int(numstr[:i]), int(numstr[:i])]) \\n                # remain str, current formula, the value of current formula, the last.vale of the formula\\n        \\n        while q:\\n            qsize = len(q)\\n            for i in range(qsize):\\n                atuple = q.popleft() # collections.deque() or popleft() is also fine\\n                remainstr, fstr, fval, flast = atuple[0], atuple[1], atuple[2], atuple[3]\\n                if len(remainstr) == 0 and fval == target:\\n                    res.append(fstr)\\n                    continue\\n                \\n                for j in range(1, len(remainstr)+1):\\n                    if j==1 or (j>1 and remainstr[0] != \\'0\\'):\\n                        # +, -, *\\n                        val = remainstr[:j]\\n                        q.append([remainstr[j:], fstr + \\'+\\' + val, fval + int(val), int(val)])\\n                        q.append([remainstr[j:], fstr + \\'-\\' + val, fval - int(val), -int(val)])\\n                        q.append([remainstr[j:], fstr + \\'*\\' + val, fval - flast + flast*int(val), flast*int(val)])\\n        return res\\n    \\n    # dfs\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n        self.target = target\\n        \\n        for i in range(1, len(num) + 1):\\n            if i==1 or (i>1 and num[0] != \\'0\\'):\\n                self.dfs(num[i:], num[:i], int(num[:i]), int(num[:i]), res)\\n        return res\\n    \\n    def dfs(self, num, fstr, fval, flast, res):\\n        # fstr = string of current formula\\n        # fval = value of current formula\\n        # flast = last value for +- and last computing result for * in formula. For example, if fstr=2+3, then flast=3, if fstr=2-3, then flast=-3, if fstr=2+3*4, then flast=3*4=12\\n        if not num:\\n            if fval == self.target:\\n                res.append(fstr)\\n            return\\n        \\n        for i in range(1, len(num)+1):\\n            val=num[:i]\\n            if i == 1 or (i>1 and num[0] != \\'0\\'):\\n                self.dfs(num[i:], fstr + \\'+\\' + val, fval + int(val), int(val), res)\\n                self.dfs(num[i:], fstr + \\'-\\' + val, fval - int(val), -int(val), res)\\n                self.dfs(num[i:], fstr + \\'*\\' + val, fval-flast+flast*int(val), flast*int(val), res)\\n               \\n            # 2+3*2: currently coming is *2, current formula = 2+3, its value is 5, the last vale of this formula is 3, thus: 5-3+3*2 is fine\\n            # 2-3*5: currently coming is *5, current formula = 2-3, its value is -1, the last vale of this formula is -3, thus: -1-(-3) + (-3)*5 = -1+3-15=-13\\n            # 3*5*2: currently coming is *2, current formula = 3*5, its value is 15, the last vale of this formula is 3*5=15!, thus: 15-15+15*2=30, result is okay as well\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632105,
                "title": "java-backtrack-just-brutal-force-dfs",
                "content": "Orig: https://leetcode.com/problems/expression-add-operators/discuss/71895/Java-Standard-Backtrace-AC-Solutoin-short-and-clear\\n```\\nclass Solution {\\n    List<String> res = new ArrayList<>();\\n    long m, t;\\n    String num;\\n    public List<String> addOperators(String num, int target) {\\n        this.num = num;\\n        if (num == null || num.length() == 0) return res;\\n        m = num.length();\\n        t = target;\\n        dfs(\"\", 0, 0, 0);\\n        return res;\\n    }\\n    \\n    private void dfs(String s, int idx, long sum, long mul) {\\n        if (idx == m) {\\n            if (sum == t) res.add(s);\\n            return;\\n        }\\n        for (int i = idx; i < m; i++) {\\n            if (i != idx && num.charAt(idx) == \\'0\\') break;  //invalid number format, for example, \"03\".\\n            long n = Long.parseLong(num.substring(idx, i+1));  // must use long to avoid overflow\\n            if (idx == 0) {    // first must be \"+\"\\n                dfs(n + \"\", i + 1, n, n);\\n                continue;\\n            }\\n            dfs(s + \"+\" + n, i + 1, sum + n, n);\\n            dfs(s + \"-\" + n, i + 1, sum - n, -n);\\n            dfs(s + \"*\" + n, i + 1, sum - mul + mul * n, mul * n);\\n            // if (i == idx && num.charAt(idx) == \\'0\\') break;  // must put before \"if (idx == 0) {\"\"\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<String> res = new ArrayList<>();\\n    long m, t;\\n    String num;\\n    public List<String> addOperators(String num, int target) {\\n        this.num = num;\\n        if (num == null || num.length() == 0) return res;\\n        m = num.length();\\n        t = target;\\n        dfs(\"\", 0, 0, 0);\\n        return res;\\n    }\\n    \\n    private void dfs(String s, int idx, long sum, long mul) {\\n        if (idx == m) {\\n            if (sum == t) res.add(s);\\n            return;\\n        }\\n        for (int i = idx; i < m; i++) {\\n            if (i != idx && num.charAt(idx) == \\'0\\') break;  //invalid number format, for example, \"03\".\\n            long n = Long.parseLong(num.substring(idx, i+1));  // must use long to avoid overflow\\n            if (idx == 0) {    // first must be \"+\"\\n                dfs(n + \"\", i + 1, n, n);\\n                continue;\\n            }\\n            dfs(s + \"+\" + n, i + 1, sum + n, n);\\n            dfs(s + \"-\" + n, i + 1, sum - n, -n);\\n            dfs(s + \"*\" + n, i + 1, sum - mul + mul * n, mul * n);\\n            // if (i == idx && num.charAt(idx) == \\'0\\') break;  // must put before \"if (idx == 0) {\"\"\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482137,
                "title": "self-explanatory-beats-96-submissions",
                "content": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        res = []\\n        n = len(num)\\n        def dfs(currIndex,prevVal,currVal,expr):\\n          if currIndex==n:\\n            if currVal==target:\\n              res.append(expr)\\n            return\\n          for i in range(currIndex,n):\\n            operand = num[currIndex:i+1]\\n            if len(operand)>1 and operand[0]==\\'0\\':\\n              break\\n            integerOp = int(operand)\\n            if currIndex==0:\\n              dfs(i+1,integerOp,integerOp,operand)\\n            else:\\n              #addition\\n              dfs(i+1,integerOp,currVal+integerOp,expr+\\'+\\'+operand)\\n              #substraction\\n              dfs(i+1,-integerOp,currVal-integerOp,expr+\\'-\\'+operand)\\n              #multiply\\n              dfs(i+1, prevVal*integerOp,\\n                  (currVal-prevVal)+(prevVal*integerOp),\\n                 expr+\\'*\\'+operand)\\n              \\n        dfs(0,0,0,\"\")\\n        # print res\\n        return res\\n    ```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        res = []\\n        n = len(num)\\n        def dfs(currIndex,prevVal,currVal,expr):\\n          if currIndex==n:\\n            if currVal==target:\\n              res.append(expr)\\n            return\\n          for i in range(currIndex,n):\\n            operand = num[currIndex:i+1]\\n            if len(operand)>1 and operand[0]==\\'0\\':\\n              break\\n            integerOp = int(operand)\\n            if currIndex==0:\\n              dfs(i+1,integerOp,integerOp,operand)\\n            else:\\n              #addition\\n              dfs(i+1,integerOp,currVal+integerOp,expr+\\'+\\'+operand)\\n              #substraction\\n              dfs(i+1,-integerOp,currVal-integerOp,expr+\\'-\\'+operand)\\n              #multiply\\n              dfs(i+1, prevVal*integerOp,\\n                  (currVal-prevVal)+(prevVal*integerOp),\\n                 expr+\\'*\\'+operand)\\n              \\n        dfs(0,0,0,\"\")\\n        # print res\\n        return res\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 359405,
                "title": "easy-understand-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> res = new ArrayList<>();\\n        dfs(res, 0, 0, 0, \"\", num, target);\\n        return res;\\n    }\\n    \\n    private void dfs(List<String> res, int idx, long bufVal, long sum,\\n                     String path, String num, int target) {\\n        if (idx == num.length()) {\\n            if (sum + bufVal == target) {\\n                res.add(path);\\n            }\\n            return;\\n        } \\n        \\n        for (int i = idx; i < num.length(); i++) {\\n            if (i != idx && num.charAt(idx) == \\'0\\') {\\n                break;\\n            }\\n            \\n            long cur = Long.parseLong(num.substring(idx, i + 1));\\n            if (idx == 0) {\\n                dfs(res, i + 1, cur, sum, path + cur, num, target);   \\n            } else {\\n                dfs(res, i + 1, cur, sum + bufVal, path + \"+\" + cur, num, target);\\n                dfs(res, i + 1, -cur, sum + bufVal, path + \"-\" + cur, num, target);\\n                dfs(res, i + 1, bufVal * cur, sum, path + \"*\" + cur, num, target);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> res = new ArrayList<>();\\n        dfs(res, 0, 0, 0, \"\", num, target);\\n        return res;\\n    }\\n    \\n    private void dfs(List<String> res, int idx, long bufVal, long sum,\\n                     String path, String num, int target) {\\n        if (idx == num.length()) {\\n            if (sum + bufVal == target) {\\n                res.add(path);\\n            }\\n            return;\\n        } \\n        \\n        for (int i = idx; i < num.length(); i++) {\\n            if (i != idx && num.charAt(idx) == \\'0\\') {\\n                break;\\n            }\\n            \\n            long cur = Long.parseLong(num.substring(idx, i + 1));\\n            if (idx == 0) {\\n                dfs(res, i + 1, cur, sum, path + cur, num, target);   \\n            } else {\\n                dfs(res, i + 1, cur, sum + bufVal, path + \"+\" + cur, num, target);\\n                dfs(res, i + 1, -cur, sum + bufVal, path + \"-\" + cur, num, target);\\n                dfs(res, i + 1, bufVal * cur, sum, path + \"*\" + cur, num, target);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 225907,
                "title": "python-backtracking-dfs",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        self.N = len(num)\\n        self.target = target\\n        self.num = num\\n        self.ans = []\\n        self.dfs(0, 0, 0, \\'\\')\\n        return self.ans\\n        \\n    def dfs(self, idx, total_val, prev_num, path):\\n        if idx == self.N:\\n            if total_val == self.target:\\n                self.ans.append(path)\\n            return\\n        \\n        cur_num = 0\\n        for i in range(idx, self.N):\\n            cur_num = cur_num * 10 + int(self.num[i])\\n            if idx == 0:\\n                self.dfs(i+1, cur_num, cur_num, path + str(cur_num))\\n            else:\\n                val = total_val - prev_num\\n                self.dfs(i+1, val + prev_num * cur_num, prev_num * cur_num, path + \\'*\\' + str(cur_num))\\n                self.dfs(i+1, val + prev_num + cur_num, cur_num, path + \\'+\\' + str(cur_num))\\n                self.dfs(i+1, val + prev_num - cur_num, -cur_num, path + \\'-\\' + str(cur_num))\\n            \\n            if self.num[idx] == \\'0\\':\\n                break\\n       \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        self.N = len(num)\\n        self.target = target\\n        self.num = num\\n        self.ans = []\\n        self.dfs(0, 0, 0, \\'\\')\\n        return self.ans\\n        \\n    def dfs(self, idx, total_val, prev_num, path):\\n        if idx == self.N:\\n            if total_val == self.target:\\n                self.ans.append(path)\\n            return\\n        \\n        cur_num = 0\\n        for i in range(idx, self.N):\\n            cur_num = cur_num * 10 + int(self.num[i])\\n            if idx == 0:\\n                self.dfs(i+1, cur_num, cur_num, path + str(cur_num))\\n            else:\\n                val = total_val - prev_num\\n                self.dfs(i+1, val + prev_num * cur_num, prev_num * cur_num, path + \\'*\\' + str(cur_num))\\n                self.dfs(i+1, val + prev_num + cur_num, cur_num, path + \\'+\\' + str(cur_num))\\n                self.dfs(i+1, val + prev_num - cur_num, -cur_num, path + \\'-\\' + str(cur_num))\\n            \\n            if self.num[idx] == \\'0\\':\\n                break\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 161121,
                "title": "slow-but-easy-understand-python-code",
                "content": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        results = []\\n        self.helper(num, 0, target, 0, 0, \"\", results)\\n        return results\\n    \\n    def helper(self, string, start, target, sum_so_far, last, path, results):\\n        if start == len(string) and sum_so_far == target:\\n            results.append(path)\\n        \\n        for end in range(start+1, len(string)+1):\\n            sub_string = string[start:end]\\n            if len(sub_string) > 1 and sub_string[0] == \\'0\\':\\n                break\\n            cur = int(sub_string)\\n            if start == 0:\\n                self.helper(string, end, target, sum_so_far + cur, cur, path + sub_string, results)\\n            else:\\n                self.helper(string, end, target, sum_so_far + cur, cur, path + \"+\" + sub_string, results)\\n                self.helper(string, end, target, sum_so_far - cur, -cur, path + \"-\" + sub_string, results)\\n                self.helper(string, end, target, sum_so_far - last + cur * last, cur * last, path + \"*\" + sub_string, results)\\n                \\n   ```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        \"\"\"\\n        :type num: str\\n        :type target: int\\n        :rtype: List[str]\\n        \"\"\"\\n        results = []\\n        self.helper(num, 0, target, 0, 0, \"\", results)\\n        return results\\n    \\n    def helper(self, string, start, target, sum_so_far, last, path, results):\\n        if start == len(string) and sum_so_far == target:\\n            results.append(path)\\n        \\n        for end in range(start+1, len(string)+1):\\n            sub_string = string[start:end]\\n            if len(sub_string) > 1 and sub_string[0] == \\'0\\':\\n                break\\n            cur = int(sub_string)\\n            if start == 0:\\n                self.helper(string, end, target, sum_so_far + cur, cur, path + sub_string, results)\\n            else:\\n                self.helper(string, end, target, sum_so_far + cur, cur, path + \"+\" + sub_string, results)\\n                self.helper(string, end, target, sum_so_far - cur, -cur, path + \"-\" + sub_string, results)\\n                self.helper(string, end, target, sum_so_far - last + cur * last, cur * last, path + \"*\" + sub_string, results)\\n                \\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 159507,
                "title": "easy-to-understand-kotlin-solution",
                "content": "The only language you use should be Kotlin\\n\\n```\\n    fun addOperators(num: String, target: Int): List<String> {\\n        val goodList : MutableList<String> = mutableListOf()\\n        fun eval(s : String, output : String, acc : Long, lastTerm : Long, start : Boolean) {\\n            if(s.isEmpty()) {\\n                if(acc + lastTerm == target.toLong()) {\\n                    goodList.add(output)\\n                }\\n                return\\n            }\\n            for (i in (1..s.length)) {\\n                val firstString = s.substring(0, i)\\n                if(firstString.length > 1 && firstString[0] == \\'0\\') {\\n                    return\\n                }\\n                val first = firstString.toLong()\\n                val rest = s.drop(i)\\n                //Case one, add the first int\\n                eval(rest, \"$output+$firstString\", acc + lastTerm, first, false)\\n                if(!start) {\\n                    eval(rest, \"$output-$firstString\", acc + lastTerm, -first, false)\\n                    eval(rest, \"$output*$firstString\", acc, lastTerm * first, false)\\n                }\\n            }\\n        }\\n        eval(num, \"\", 0, 0, true)\\n        return goodList.map {it.drop(1)}.toList()\\n    }\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n    fun addOperators(num: String, target: Int): List<String> {\\n        val goodList : MutableList<String> = mutableListOf()\\n        fun eval(s : String, output : String, acc : Long, lastTerm : Long, start : Boolean) {\\n            if(s.isEmpty()) {\\n                if(acc + lastTerm == target.toLong()) {\\n                    goodList.add(output)\\n                }\\n                return\\n            }\\n            for (i in (1..s.length)) {\\n                val firstString = s.substring(0, i)\\n                if(firstString.length > 1 && firstString[0] == \\'0\\') {\\n                    return\\n                }\\n                val first = firstString.toLong()\\n                val rest = s.drop(i)\\n                //Case one, add the first int\\n                eval(rest, \"$output+$firstString\", acc + lastTerm, first, false)\\n                if(!start) {\\n                    eval(rest, \"$output-$firstString\", acc + lastTerm, -first, false)\\n                    eval(rest, \"$output*$firstString\", acc, lastTerm * first, false)\\n                }\\n            }\\n        }\\n        eval(num, \"\", 0, 0, true)\\n        return goodList.map {it.drop(1)}.toList()\\n    }\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 121113,
                "title": "why-simple-dfs-is-so-slow-python",
                "content": "Consider two solutions:\\n```\\n# solution 1\\ndef addOperators(self, num, target):\\n    \\n    def dfs(tail, path, tot, prev):\\n        if not tail and tot == target:\\n            paths.append(path)\\n        else:\\n            for i in range(1, len(tail) + 1):\\n                if i == 1 or tail[0] != \\'0\\':\\n                    val = int(tail[:i])\\n                    dfs(tail[i:], path + \\'+\\' + tail[:i], tot + val, val)\\n                    dfs(tail[i:], path + \\'-\\' + tail[:i], tot - val, -val)\\n                    dfs(tail[i:], path + \\'*\\' + tail[:i], tot - prev + prev * val, prev * val)\\n\\n    paths = []\\n    for i in range(1, len(num) + 1):\\n        if i == 1 or num[0] != \\'0\\':\\n            head = int(num[:i])\\n            dfs(num[i:], num[:i], head, head)\\n\\n    return paths\\n```\\nand\\n```\\n# solution 2\\ndef addOperators(self, num, target):\\n    if not num: \\n        return []\\n    \\n    def dfs(path, s):\\n        if not s :\\n            if eval(path) == target:\\n                paths.append(path)\\n        else:\\n            ops = [\\'+\\', \\'-\\', \\'*\\'] if s[0] == \\'0\\' else [\\'+\\', \\'-\\', \\'*\\', \\'\\']\\n            for op in ops:\\n                dfs(path + op + s[0], s[1:])\\n\\n    paths = []\\n    dfs(num[0], num[1:])\\n\\n    return paths\\n```\\n\\nI think the time complexity are both O(N^4):\\nFor solution1: T(N) = 3*(T(N-1) + T(N-2) + ...), T(N-1) = 3*(T(N-2)+ ...) => T(N) = 4T(N-1) => O(N^4)\\nFor solution2: T(N) = 4T(N-1) => O(N^4)\\nBoth solution requires string slicing, in fact, more slicing operations in solution1. I don\\'t see any significant differences on time complexity in the both solution.\\n\\nBut in reality: the run time for the following test cases are:\\n(\"3456237\", 10000): 38ms vs 80ms\\n(\"34562374\", 10000): 54ms vs 229ms\\n(\"345623749\", 10000): 127ms vs 986ms\\nwhich clearly shows solution1 and solution2 is vastly different. \\nWhat are the operation overhead in solution2 make it so slow?",
                "solutionTags": [],
                "code": "```\\n# solution 1\\ndef addOperators(self, num, target):\\n    \\n    def dfs(tail, path, tot, prev):\\n        if not tail and tot == target:\\n            paths.append(path)\\n        else:\\n            for i in range(1, len(tail) + 1):\\n                if i == 1 or tail[0] != \\'0\\':\\n                    val = int(tail[:i])\\n                    dfs(tail[i:], path + \\'+\\' + tail[:i], tot + val, val)\\n                    dfs(tail[i:], path + \\'-\\' + tail[:i], tot - val, -val)\\n                    dfs(tail[i:], path + \\'*\\' + tail[:i], tot - prev + prev * val, prev * val)\\n\\n    paths = []\\n    for i in range(1, len(num) + 1):\\n        if i == 1 or num[0] != \\'0\\':\\n            head = int(num[:i])\\n            dfs(num[i:], num[:i], head, head)\\n\\n    return paths\\n```\n```\\n# solution 2\\ndef addOperators(self, num, target):\\n    if not num: \\n        return []\\n    \\n    def dfs(path, s):\\n        if not s :\\n            if eval(path) == target:\\n                paths.append(path)\\n        else:\\n            ops = [\\'+\\', \\'-\\', \\'*\\'] if s[0] == \\'0\\' else [\\'+\\', \\'-\\', \\'*\\', \\'\\']\\n            for op in ops:\\n                dfs(path + op + s[0], s[1:])\\n\\n    paths = []\\n    dfs(num[0], num[1:])\\n\\n    return paths\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 71900,
                "title": "18-line-clean-python-solution-dfs-with-comment",
                "content": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        def dfs(remain, curr_str, curr, prev):\\n            if not remain and curr == target:\\n                res.append(curr_str)\\n                \\n            for i in range(1, len(remain) + 1):\\n                if len(curr_str) == 0:   #avoid generate str begin with +-*\\n                    if not (i > 1 and remain[0] == '0'):   # avoid '0X' case be counted\\n                        dfs(remain[i:], remain[:i], int(remain[:i]), int(remain[:i]))\\n                else:\\n                    if not (i > 1 and remain[0] == '0'):\\n                        dfs(remain[i:], curr_str + '+' + remain[:i], curr + int(remain[:i]), int(remain[:i]))\\n                        dfs(remain[i:], curr_str + '-' + remain[:i], curr - int(remain[:i]), -int(remain[:i]))\\n                        # need take extra care for '*' case, a+b*c = a+b-b+b*c\\n                        dfs(remain[i:], curr_str + '*' + remain[:i], curr - prev + prev * int(remain[:i]), prev * int(remain[:i]))\\n            \\n        res = []\\n        dfs(num, '', 0, 0)\\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def addOperators(self, num, target):\\n        def dfs(remain, curr_str, curr, prev):\\n            if not remain and curr == target:\\n                res.append(curr_str)\\n                \\n            for i in range(1, len(remain) + 1):\\n                if len(curr_str) == 0:   #avoid generate str begin with +-*\\n                    if not (i > 1 and remain[0] == '0'):   # avoid '0X' case be counted\\n                        dfs(remain[i:], remain[:i], int(remain[:i]), int(remain[:i]))\\n                else:\\n                    if not (i > 1 and remain[0] == '0'):\\n                        dfs(remain[i:], curr_str + '+' + remain[:i], curr + int(remain[:i]), int(remain[:i]))\\n                        dfs(remain[i:], curr_str + '-' + remain[:i], curr - int(remain[:i]), -int(remain[:i]))\\n                        # need take extra care for '*' case, a+b*c = a+b-b+b*c\\n                        dfs(remain[i:], curr_str + '*' + remain[:i], curr - prev + prev * int(remain[:i]), prev * int(remain[:i]))\\n            \\n        res = []\\n        dfs(num, '', 0, 0)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71926,
                "title": "my-brilliant-solution-different-and-easy-to-understand-with-explanation",
                "content": "Suppose that our input string is \"1234\". The length is 4.\\nthere are 3 spots between these 4 digits: 1_2_3_4.\\n\\non each spot, we can either put one of the operator s ( -, +, * ) or put nothing. For example, if I put ' * ' in the first spot, + in the second spot and nothing in the third spot, I will have: 1*2+34.\\nSo each spot can have 4 options. So overall, there can be 4^3 choices.\\n\\nDon't you think there is a reason behind not having ' / ' as an option? There is a reason: we can show any of our choices as a binary from 0 to 3:\\n\\n00: put nothing between two numbers\\n01: put '+' between two numbers\\n10: put '*' between two numbers\\n11: put '-' between two numbers\\n\\nNow I can iterate between 0 to 4^3 and decide for each spot which number I should choose. For example, for the expression discussed above (1*2+34) the generated code to choose operators looks like this:\\n100100\\n\\n(I actually start from 1, because 0 is: 000000 which will give me: 1234 which doesn't have any operator)\\n\\nThen I can read through the code and decide which operator to put and form a string called expression. Then I will send the expression to a calculator which is simply a 'Expression calculator' and check if the result of the current expression equals to target. If yes, I will add it to the result list.\\n\\nSo let's make it for n. If the length of the input string is n, we have n-1 spots, so 4^n-1 choices.\\nWe iterate between 1 to 4^n-1 and parse the number to binary and if it has leading zeros, make sure to include the zeros in our operators string. Then check the operators string 2 by to and add the operator (or don't add anything) by comparing the number to its corresponding operator.\\n\\n```\\nstatic List<string> AddOperators(string num, int target, List<string> total_strings)\\n        {\\n            int n = num.Length;\\n            for (int i = 1; i < Math.Pow(4, n - 1); i++)\\n            {\\n\\t\\t//parsing to binary, then add leading zeros until we have enough length. for example, if n=4, we have 3 spots to fill\\n\\t\\t//if the current number code is 000011, we make sure to include 4 leading zeros to our string.\\n                string operators = Convert.ToString(i, 2).PadLeft((n - 1) * 2, '0'); \\n                string expression = num[0].ToString();\\n                for (int j = 1; j <= n-1 ; j ++)\\n                {\\n                    string Operator = operators.Substring((j-1)*2, 2);\\n                    //if (Operator == \"00\") SKIP; //not necessary\\n                    if (Operator == \"01\") expression += '+';\\n                    if (Operator == \"10\") expression += '*';\\n                    if (Operator == \"11\") expression += '-';\\n                    expression += num[j];\\n                }\\n                if (Calculator(expression) == target)\\n                    total_strings.Add(expression);\\n\\n            }\\n            return total_strings;\\n        }\\n        static int Calculator(string exp)\\n        {\\n            Stack<int> st = new Stack<int>();\\n            int current_num = 0;\\n            char sign = '+';\\n            int result = 0;\\n\\n            for(int i=0; i<exp.Length; i++)\\n            {\\n                if (char.IsDigit(exp[i]))\\n                    current_num = current_num * 10 +int.Parse(exp[i].ToString());\\n                if(!char.IsDigit(exp[i]) || i==exp.Length-1)\\n                {\\n                    if (sign == '+')\\n                        st.Push(current_num);\\n                    if (sign == '-')\\n                        st.Push(-1 * current_num);\\n                    if(sign=='*')\\n                    {\\n                        int temp = st.Pop();\\n                        st.Push(temp * current_num);\\n                    }\\n                    sign = exp[i];\\n                    current_num = 0;\\n                }\\n            }\\n            while(st.Any())\\n            {\\n                result += st.Pop();\\n            }\\n            return result;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\nstatic List<string> AddOperators(string num, int target, List<string> total_strings)\\n        {\\n            int n = num.Length;\\n            for (int i = 1; i < Math.Pow(4, n - 1); i++)\\n            {\\n\\t\\t//parsing to binary, then add leading zeros until we have enough length. for example, if n=4, we have 3 spots to fill\\n\\t\\t//if the current number code is 000011, we make sure to include 4 leading zeros to our string.\\n                string operators = Convert.ToString(i, 2).PadLeft((n - 1) * 2, '0'); \\n                string expression = num[0].ToString();\\n                for (int j = 1; j <= n-1 ; j ++)\\n                {\\n                    string Operator = operators.Substring((j-1)*2, 2);\\n                    //if (Operator == \"00\") SKIP; //not necessary\\n                    if (Operator == \"01\") expression += '+';\\n                    if (Operator == \"10\") expression += '*';\\n                    if (Operator == \"11\") expression += '-';\\n                    expression += num[j];\\n                }\\n                if (Calculator(expression) == target)\\n                    total_strings.Add(expression);\\n\\n            }\\n            return total_strings;\\n        }\\n        static int Calculator(string exp)\\n        {\\n            Stack<int> st = new Stack<int>();\\n            int current_num = 0;\\n            char sign = '+';\\n            int result = 0;\\n\\n            for(int i=0; i<exp.Length; i++)\\n            {\\n                if (char.IsDigit(exp[i]))\\n                    current_num = current_num * 10 +int.Parse(exp[i].ToString());\\n                if(!char.IsDigit(exp[i]) || i==exp.Length-1)\\n                {\\n                    if (sign == '+')\\n                        st.Push(current_num);\\n                    if (sign == '-')\\n                        st.Push(-1 * current_num);\\n                    if(sign=='*')\\n                    {\\n                        int temp = st.Pop();\\n                        st.Push(temp * current_num);\\n                    }\\n                    sign = exp[i];\\n                    current_num = 0;\\n                }\\n            }\\n            while(st.Any())\\n            {\\n                result += st.Pop();\\n            }\\n            return result;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 71937,
                "title": "simple-and-straight-forward-ruby-solution",
                "content": "uncomment the line for 'puts' to see the output per recursion.\\n````\\ndef add_operators(num, target)\\n    @sets = []\\n    @num = num\\n    @target = target\\n    add_forward(\"\", nil, nil, 0)\\n    @sets\\nend\\n\\ndef add_forward(expression_str, expression_val, mult, counter)\\n    #puts \"counter: #{counter}, expression_str: #{expression_str}, #{eval(expression_str)}\"\\n    if counter == @num.length && expression_val == @target\\n        @sets << expression_str\\n        return\\n    end\\n    size = @num[counter] == \"0\" ? counter + 1 : @num.length\\n    for i in (counter+1)..size\\n        current_num = @num[counter...i].to_i\\n        if expression_str == \"\"\\n            add_forward(current_num.to_s, current_num, current_num, i)\\n            next\\n        end\\n\\n        add_forward(expression_str+\"+\"+current_num.to_s, expression_val+current_num, current_num, i)\\n        add_forward(expression_str+\"-\"+current_num.to_s, expression_val-current_num, -current_num, i)\\n        add_forward(expression_str+\"*\"+current_num.to_s, (expression_val-mult)+(mult*current_num), (mult*current_num), i)\\n    end\\nend\\n````",
                "solutionTags": [],
                "code": "````\\ndef add_operators(num, target)\\n    @sets = []\\n    @num = num\\n    @target = target\\n    add_forward(\"\", nil, nil, 0)\\n    @sets\\nend\\n\\ndef add_forward(expression_str, expression_val, mult, counter)\\n    #puts \"counter: #{counter}, expression_str: #{expression_str}, #{eval(expression_str)}\"\\n    if counter == @num.length && expression_val == @target\\n        @sets << expression_str\\n        return\\n    end\\n    size = @num[counter] == \"0\" ? counter + 1 : @num.length\\n    for i in (counter+1)..size\\n        current_num = @num[counter...i].to_i\\n        if expression_str == \"\"\\n            add_forward(current_num.to_s, current_num, current_num, i)\\n            next\\n        end\\n\\n        add_forward(expression_str+\"+\"+current_num.to_s, expression_val+current_num, current_num, i)\\n        add_forward(expression_str+\"-\"+current_num.to_s, expression_val-current_num, -current_num, i)\\n        add_forward(expression_str+\"*\"+current_num.to_s, (expression_val-mult)+(mult*current_num), (mult*current_num), i)\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 71938,
                "title": "python-dfs-beats-98",
                "content": "I didn't look at other solutions so not sure if others are better, but here's what I came up with. Basically it does a DFS on the search space of all the possible combinations of arithmetic expressions, building the expression string as it goes along. To handle the higher operator precedence of multiplication I keep a running total of the previous left and right operands, so that the current result isn't calculated prematurely.  Below is my code.  Comments and suggestions appreciated\\n\\n```\\nclass Solution(object):\\n    def search(self,left,right, si,num,target,expr,res):\\n        if si >= len(num):\\n            if left+right == target:\\n                res.append(expr)\\n            return\\n        curr = 0\\n        for i in xrange(si,len(num)):\\n            curr = curr*10 + ord(num[i])-ord('0')\\n            currNum = num[si:i+1]\\n            if currNum[0]=='0' and len(currNum) > 1:\\n                continue # skip numbers with leading zeroes\\n            if si==0:\\n                self.search(0,curr,i+1,num,target,currNum,res)\\n            else:\\n                self.search(left+right,curr,i+1,num,target,expr+'+'+currNum,res) # plus\\n                self.search(left+right,-curr,i+1,num,target,expr+'-'+currNum,res) # minus\\n                self.search(left,right*curr,i+1,num,target,expr+'*'+currNum,res) # multiply\\n            \\n    def addOperators(self, num, target):\\n        res = []\\n        self.search(0,0,0,num,target,\"\",res)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def search(self,left,right, si,num,target,expr,res):\\n        if si >= len(num):\\n            if left+right == target:\\n                res.append(expr)\\n            return\\n        curr = 0\\n        for i in xrange(si,len(num)):\\n            curr = curr*10 + ord(num[i])-ord('0')\\n            currNum = num[si:i+1]\\n            if currNum[0]=='0' and len(currNum) > 1:\\n                continue # skip numbers with leading zeroes\\n            if si==0:\\n                self.search(0,curr,i+1,num,target,currNum,res)\\n            else:\\n                self.search(left+right,curr,i+1,num,target,expr+'+'+currNum,res) # plus\\n                self.search(left+right,-curr,i+1,num,target,expr+'-'+currNum,res) # minus\\n                self.search(left,right*curr,i+1,num,target,expr+'*'+currNum,res) # multiply\\n            \\n    def addOperators(self, num, target):\\n        res = []\\n        self.search(0,0,0,num,target,\"\",res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71948,
                "title": "short-java-solution-without-loop",
                "content": "Maintain three numbers: **sum, mulL, mulR**. Attempt to reach the point that **sum + mulL * mulR == target**\\nStringBuilder is not used, because String is shorter and the solution is fast enough to fit the time limit.\\n\\n```\\npublic class Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> ans = new ArrayList<>();\\n        search(ans, num, target, \"\", 0, 0, 1, 0);\\n        return ans;\\n    }\\n    private void search(List<String> ans, String num, int target, String literal, int idx, long sum, long mulL, long mulR) {\\n        if (idx < num.length()) {\\n            int digit = num.charAt(idx) - '0';\\n            if (idx > 0) {\\n                search(ans, num, target, literal + \"+\" + digit, idx + 1, sum + mulL * mulR, 1, digit);\\n                search(ans, num, target, literal + \"-\" + digit, idx + 1, sum + mulL * mulR, 1, -digit);\\n                search(ans, num, target, literal + \"*\" + digit, idx + 1, sum, mulL * mulR, digit);\\n            }\\n            if (idx == 0 || mulR != 0) {\\n                search(ans, num, target, literal + digit, idx + 1, sum, mulL, mulR * 10 + (mulR >= 0 ? digit : -digit));\\n            }\\n        } else if (sum + mulL * mulR == target) {\\n            ans.add(literal);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> ans = new ArrayList<>();\\n        search(ans, num, target, \"\", 0, 0, 1, 0);\\n        return ans;\\n    }\\n    private void search(List<String> ans, String num, int target, String literal, int idx, long sum, long mulL, long mulR) {\\n        if (idx < num.length()) {\\n            int digit = num.charAt(idx) - '0';\\n            if (idx > 0) {\\n                search(ans, num, target, literal + \"+\" + digit, idx + 1, sum + mulL * mulR, 1, digit);\\n                search(ans, num, target, literal + \"-\" + digit, idx + 1, sum + mulL * mulR, 1, -digit);\\n                search(ans, num, target, literal + \"*\" + digit, idx + 1, sum, mulL * mulR, digit);\\n            }\\n            if (idx == 0 || mulR != 0) {\\n                search(ans, num, target, literal + digit, idx + 1, sum, mulL, mulR * 10 + (mulR >= 0 ? digit : -digit));\\n            }\\n        } else if (sum + mulL * mulR == target) {\\n            ans.add(literal);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71952,
                "title": "clear-c-solution-with-some-explanations",
                "content": "    vector<string> addOperators(string num, int target) {\\n    \\tvector<string> res;\\n    \\thelp(res, num, target, 0, \"\", 0);\\n    \\treturn res;\\n    }\\n    //use long long to avoid overflow\\n    void help(vector<string> &res, string num, long long target, int pos, string pre, long long last) {   \\n    \\tif (pos == num.size() && target == 0) {\\n    \\t\\tres.push_back(pre);\\n    \\t\\treturn;\\n    \\t}\\n    \\tfor (int i = pos; i < num.size(); i++) {\\n    \\t\\tif (num[pos] == '0' && i > pos)                  //strings like \"05\" are not correct expression \\n    \\t\\t\\tbreak;\\n    \\t\\tstring temp = num.substr(pos, i - pos + 1);\\n    \\t\\tlong long cur = stoll(temp);                  \\n    \\t\\tif (pos == 0)\\n    \\t\\t\\thelp(res, num, target - cur, i + 1, temp, cur);\\n    \\t\\telse {\\n    \\t\\t\\thelp(res, num, target - cur, i + 1, pre + \"+\" + temp, cur);\\n    \\t\\t\\thelp(res, num, target + cur, i + 1, pre + \"-\" + temp, -cur);\\n    \\t\\t\\thelp(res, num, target + last - last*cur, i + 1, pre + \"*\" + temp, last*cur);\\n                //'*'is not same to '+-', we should plus \"last\" that we shouldn't have + or -.(* with high priority)\\n    \\t\\t}\\n    \\t}\\n    }\\n\\n\\nThis is not a difficult problem but it really confuses me a lot.",
                "solutionTags": [],
                "code": "    vector<string> addOperators(string num, int target) {\\n    \\tvector<string> res;\\n    \\thelp(res, num, target, 0, \"\", 0);\\n    \\treturn res;\\n    }\\n    //use long long to avoid overflow\\n    void help(vector<string> &res, string num, long long target, int pos, string pre, long long last) {   \\n    \\tif (pos == num.size() && target == 0) {\\n    \\t\\tres.push_back(pre);\\n    \\t\\treturn;\\n    \\t}\\n    \\tfor (int i = pos; i < num.size(); i++) {\\n    \\t\\tif (num[pos] == '0' && i > pos)                  //strings like \"05\" are not correct expression \\n    \\t\\t\\tbreak;\\n    \\t\\tstring temp = num.substr(pos, i - pos + 1);\\n    \\t\\tlong long cur = stoll(temp);                  \\n    \\t\\tif (pos == 0)\\n    \\t\\t\\thelp(res, num, target - cur, i + 1, temp, cur);\\n    \\t\\telse {\\n    \\t\\t\\thelp(res, num, target - cur, i + 1, pre + \"+\" + temp, cur);\\n    \\t\\t\\thelp(res, num, target + cur, i + 1, pre + \"-\" + temp, -cur);\\n    \\t\\t\\thelp(res, num, target + last - last*cur, i + 1, pre + \"*\" + temp, last*cur);\\n                //'*'is not same to '+-', we should plus \"last\" that we shouldn't have + or -.(* with high priority)\\n    \\t\\t}\\n    \\t}\\n    }\\n\\n\\nThis is not a difficult problem but it really confuses me a lot.",
                "codeTag": "Unknown"
            },
            {
                "id": 71961,
                "title": "far-beating-all-submissions-in-c-accepted-with-16ms-well-explained",
                "content": "Always recursive method will a nice choice to handle this kind of DFS problem but meantime we should record some variables to move to the next round (in each round we will store the operator and then the selected number):\\n\\n- the current result -> sum;\\n- the previous number or partial result -> we need to handle <font color=\"#ff0000\">multiplication</font> unlike addition or subtraction it should be handled separately -> this is the <font color=\"#ff0000\">only reason</font> why we need this variable -> pre;\\n\\nOthers will be easily understood, I think with the help of the detailed comments in code.\\n\\nB.T.W. the complexity analysis is not quite easy here, but in a rough way:\\n\\n- space cost O(n^2)\\n- time cost O(2^n)\\n\\nIf some one gets some clear idea of this, please share with me. Thanks in advance!\\n\\n----------\\n\\n\\n       void helper(char* num, int len, int start, int target, long long sum, long long pre, char* stack, int top, char*** arr, int* returnSize)\\n    {\\n        if(start == len) //end of the string;\\n        {\\n            if(target == sum) //check whether it's valid;\\n            {\\n                stack[++top] = '\\\\0'; //terminate the string;\\n                *returnSize += 1; \\n                *arr = (char**)realloc(*arr, sizeof(char*)*(*returnSize));\\n                (*arr)[*returnSize-1] = (char*)malloc(sizeof(char)*(top+1));\\n                for(int i = 0; i <= top; i++)\\n                    (*arr)[*returnSize-1][i] = stack[i];\\n            }\\n            return ; \\n        }\\n        long long val = 0; //in case of INT_MAX or INT_MIN;\\n        int index = top+1; //record the index for the operator;\\n        for(int i = start; i < len; i++)\\n        {\\n            val = 10*val + num[i] - '0'; //collect the number;\\n            if(start == 0) //if it's the first number, no operator should be added;\\n            {\\n                stack[top+1] = num[i];\\n                helper(num, len, i+1, target, val, val, stack, top+1, arr, returnSize);\\n            }\\n            else\\n            {\\n                stack[top+2] = num[i];\\n                stack[index] = '-'; //get the sum directly by sum-val and record -1*val as pre in case the next operator is '*';\\n                helper(num, len, i+1, target, sum-val, -1*val, stack, top+2, arr, returnSize);\\n                stack[index] = '+'; //store val as pre in case the next operator is '*';\\n                helper(num, len, i+1, target, sum+val, val, stack, top+2, arr, returnSize);\\n                stack[index] = '*'; //we have to delete the pre first and then add the product of pre and var and then store pre*val in case the next operator is '*';\\n                helper(num, len, i+1, target, sum-pre+pre*val, pre*val, stack, top+2, arr, returnSize);\\n            }\\n            if(num[start] == '0') break; //no number starts with 0;\\n            top++;\\n        }\\n    }\\n    char** addOperators(char* num, int target, int* returnSize)\\n    {\\n        char** arr = (char**)malloc(sizeof(char*));\\n        *returnSize = 0;\\n        int len = strlen(num);\\n        if(len == 0) return arr;\\n        char* stack = (char*)malloc(sizeof(char)*2*len);\\n        int top = -1;\\n        helper(num, len, 0, target, 0, 0, stack, top, &arr, returnSize);\\n        return arr;\\n    }",
                "solutionTags": [],
                "code": "Always recursive method will a nice choice to handle this kind of DFS problem but meantime we should record some variables to move to the next round (in each round we will store the operator and then the selected number):\\n\\n- the current result -> sum;\\n- the previous number or partial result -> we need to handle <font color=\"#ff0000\">multiplication</font> unlike addition or subtraction it should be handled separately -> this is the <font color=\"#ff0000\">only reason</font> why we need this variable -> pre;\\n\\nOthers will be easily understood, I think with the help of the detailed comments in code.\\n\\nB.T.W. the complexity analysis is not quite easy here, but in a rough way:\\n\\n- space cost O(n^2)\\n- time cost O(2^n)\\n\\nIf some one gets some clear idea of this, please share with me. Thanks in advance!\\n\\n----------\\n\\n\\n       void helper(char* num, int len, int start, int target, long long sum, long long pre, char* stack, int top, char*** arr, int* returnSize)\\n    {\\n        if(start == len) //end of the string;\\n        {\\n            if(target == sum) //check whether it's valid;\\n            {\\n                stack[++top] = '\\\\0'; //terminate the string;\\n                *returnSize += 1; \\n                *arr = (char**)realloc(*arr, sizeof(char*)*(*returnSize));\\n                (*arr)[*returnSize-1] = (char*)malloc(sizeof(char)*(top+1));\\n                for(int i = 0; i <= top; i++)\\n                    (*arr)[*returnSize-1][i] = stack[i];\\n            }\\n            return ; \\n        }\\n        long long val = 0; //in case of INT_MAX or INT_MIN;\\n        int index = top+1; //record the index for the operator;\\n        for(int i = start; i < len; i++)\\n        {\\n            val = 10*val + num[i] - '0'; //collect the number;\\n            if(start == 0) //if it's the first number, no operator should be added;\\n            {\\n                stack[top+1] = num[i];\\n                helper(num, len, i+1, target, val, val, stack, top+1, arr, returnSize);\\n            }\\n            else\\n            {\\n                stack[top+2] = num[i];\\n                stack[index] = '-'; //get the sum directly by sum-val and record -1*val as pre in case the next operator is '*';\\n                helper(num, len, i+1, target, sum-val, -1*val, stack, top+2, arr, returnSize);\\n                stack[index] = '+'; //store val as pre in case the next operator is '*';\\n                helper(num, len, i+1, target, sum+val, val, stack, top+2, arr, returnSize);\\n                stack[index] = '*'; //we have to delete the pre first and then add the product of pre and var and then store pre*val in case the next operator is '*';\\n                helper(num, len, i+1, target, sum-pre+pre*val, pre*val, stack, top+2, arr, returnSize);\\n            }\\n            if(num[start] == '0') break; //no number starts with 0;\\n            top++;\\n        }\\n    }\\n    char** addOperators(char* num, int target, int* returnSize)\\n    {\\n        char** arr = (char**)malloc(sizeof(char*));\\n        *returnSize = 0;\\n        int len = strlen(num);\\n        if(len == 0) return arr;\\n        char* stack = (char*)malloc(sizeof(char)*2*len);\\n        int top = -1;\\n        helper(num, len, 0, target, 0, 0, stack, top, &arr, returnSize);\\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 71964,
                "title": "there-seems-not-any-c-solution-post-share-mine",
                "content": "    void ao( char* num, int cur, double left, double sum, char* sol, char*** res, int* resEnd, int* resCap, int target ){\\n        if( cur == strlen(num) && left * sum == target ){\\n            if( *resEnd == *resCap ){\\n                *resCap *= 2;\\n                *res = realloc( *res, (*resCap) * sizeof( **res ) );\\n            }\\n            ( *res )[ *resEnd ] = sol;\\n            ( *resEnd )++;\\n            return;\\n        }\\n        \\n        if( cur == strlen(num) ){\\n            return;\\n        }\\n        \\n        int oldLen = strlen( sol );\\n        if( sum != 0 ){\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = num[cur];\\n            ao( num, cur+1, left, sum * 10 + ( num[ cur ] - '0' ), newSol, res, resEnd, resCap, target );\\n        }\\n        {\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = '*';\\n            newSol[ oldLen + 1 ] = num[cur];\\n            ao( num, cur+1, left * sum, num[ cur ] - '0', newSol, res, resEnd, resCap, target );\\n        }\\n        {\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = '+';\\n            newSol[ oldLen+1 ] = num[cur];\\n            ao( num, cur+1, 1, num[cur] - '0', newSol, res, resEnd, resCap, target - left * sum );\\n        }\\n        {\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = '-';\\n            newSol[ oldLen+1 ] = num[cur];\\n            ao( num, cur+1, -1, num[cur] - '0', newSol, res, resEnd, resCap, target - left * sum );\\n        }\\n        \\n        free( sol );\\n    } \\n    \\n    char** addOperators(char* num, int target, int* returnSize) {\\n        int resCap = 16;\\n        char** res = calloc( resCap, sizeof( *res ) );\\n        int resEnd = 0; // 0 .. resEnd-1 is the current result we have\\n    \\n        int n = strlen( num );\\n    \\n        if( n== 0 ){\\n            return res;\\n        }\\n        \\n        char* sol = calloc( 2 * n - 1, sizeof( *sol ) );\\n        memset( sol, '\\\\0', 2 * n - 1);\\n        sol[0] = num[0];\\n        \\n        ao( num, 1, 1, num[0] - '0', sol, &res, &resEnd, &resCap, target );\\n        \\n        *returnSize = resEnd;\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    void ao( char* num, int cur, double left, double sum, char* sol, char*** res, int* resEnd, int* resCap, int target ){\\n        if( cur == strlen(num) && left * sum == target ){\\n            if( *resEnd == *resCap ){\\n                *resCap *= 2;\\n                *res = realloc( *res, (*resCap) * sizeof( **res ) );\\n            }\\n            ( *res )[ *resEnd ] = sol;\\n            ( *resEnd )++;\\n            return;\\n        }\\n        \\n        if( cur == strlen(num) ){\\n            return;\\n        }\\n        \\n        int oldLen = strlen( sol );\\n        if( sum != 0 ){\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = num[cur];\\n            ao( num, cur+1, left, sum * 10 + ( num[ cur ] - '0' ), newSol, res, resEnd, resCap, target );\\n        }\\n        {\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = '*';\\n            newSol[ oldLen + 1 ] = num[cur];\\n            ao( num, cur+1, left * sum, num[ cur ] - '0', newSol, res, resEnd, resCap, target );\\n        }\\n        {\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = '+';\\n            newSol[ oldLen+1 ] = num[cur];\\n            ao( num, cur+1, 1, num[cur] - '0', newSol, res, resEnd, resCap, target - left * sum );\\n        }\\n        {\\n            char* newSol = calloc( oldLen, sizeof( *newSol ) );\\n            strcpy( newSol, sol );\\n            newSol[ oldLen ] = '-';\\n            newSol[ oldLen+1 ] = num[cur];\\n            ao( num, cur+1, -1, num[cur] - '0', newSol, res, resEnd, resCap, target - left * sum );\\n        }\\n        \\n        free( sol );\\n    } \\n    \\n    char** addOperators(char* num, int target, int* returnSize) {\\n        int resCap = 16;\\n        char** res = calloc( resCap, sizeof( *res ) );\\n        int resEnd = 0; // 0 .. resEnd-1 is the current result we have\\n    \\n        int n = strlen( num );\\n    \\n        if( n== 0 ){\\n            return res;\\n        }\\n        \\n        char* sol = calloc( 2 * n - 1, sizeof( *sol ) );\\n        memset( sol, '\\\\0', 2 * n - 1);\\n        sol[0] = num[0];\\n        \\n        ao( num, 1, 1, num[0] - '0', sol, &res, &resEnd, &resCap, target );\\n        \\n        *returnSize = resEnd;\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3817648,
                "title": "c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\nvoid generate(string &num, int target, int curr, vector<string> &res, string build, long long int prevNumber, long long int currSum, int n){\\n        if(curr==num.size()){\\n            if(currSum==target){\\n                res.push_back(build);\\n            }\\n            return;\\n        }\\n        for(int len=1;len<=(n-curr);len++){\\n            string number=num.substr(curr,len);\\n            if(number[0]==\\'0\\' && number.size()>1){\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,curr+len,res,build+\"+\"+number,currNum,currSum+currNum,n);\\n            generate(num,target,curr+len,res,build+\"-\"+number,-currNum,currSum-currNum,n);\\n            generate(num,target,curr+len,res,build+\"*\"+number,currNum*prevNumber,currSum-prevNumber+currNum*prevNumber,n);\\n        }\\n    }\\n    vector<string> addOperators(string num, int target) {\\n          vector<string> res;\\n        int n=num.size();\\n        for(int len=1;len<=n;len++){\\n            string number=num.substr(0,len);\\n            if(number[0]==\\'0\\' && number.size()>1){\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,len,res,number,currNum,currNum,n);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid generate(string &num, int target, int curr, vector<string> &res, string build, long long int prevNumber, long long int currSum, int n){\\n        if(curr==num.size()){\\n            if(currSum==target){\\n                res.push_back(build);\\n            }\\n            return;\\n        }\\n        for(int len=1;len<=(n-curr);len++){\\n            string number=num.substr(curr,len);\\n            if(number[0]==\\'0\\' && number.size()>1){\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,curr+len,res,build+\"+\"+number,currNum,currSum+currNum,n);\\n            generate(num,target,curr+len,res,build+\"-\"+number,-currNum,currSum-currNum,n);\\n            generate(num,target,curr+len,res,build+\"*\"+number,currNum*prevNumber,currSum-prevNumber+currNum*prevNumber,n);\\n        }\\n    }\\n    vector<string> addOperators(string num, int target) {\\n          vector<string> res;\\n        int n=num.size();\\n        for(int len=1;len<=n;len++){\\n            string number=num.substr(0,len);\\n            if(number[0]==\\'0\\' && number.size()>1){\\n                continue;\\n            }\\n            long long int currNum=stoll(number);\\n            generate(num,target,len,res,number,currNum,currNum,n);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696293,
                "title": "c-expression-evaluation-with-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nApproach is to use a backtracking technique with memoization. We can recursively build the expressions by trying out different operators at each step and keeping track of the current sum. The memoization technique can help avoid redundant calculations and improve efficiency by storing intermediate results. This approach would require careful handling of operators and their precedence.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAddition: We make a recursive call with the updated currentSum by adding the current number and the updated currentExpr by appending the \\'+\\' operator and the current number.\\n\\nSubtraction: We make a recursive call with the updated currentSum by subtracting the current number and the updated currentExpr by appending the \\'-\\' operator and the current number.\\n\\nMultiplication: We make a recursive call with the updated currentSum by subtracting the previous number and adding the product of the previous number and the current number. We also update the currentExpr accordingly.\\n\\nWhen considering the multiplication operation, we need to take into account its precedence over addition and subtraction. In other words, multiplication should be evaluated before addition and subtraction in the expression.\\n\\nTo incorporate multiplication into our backtracking algorithm, we need to keep track of the previous number (operand) and update the current sum accordingly when encountering the multiplication operator.\\n\\n# Complexity\\n- Time complexity:\\nthe number of possible expressions can be approximated as 3^(n-1) since each digit (except the first one) can be preceded by three different operators. Therefore, the time complexity of the backtracking algorithm can be considered as O(3^(n-1)).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nspace complexity due to the recursive stack is O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool> memo;\\n    vector<string> result;\\n    \\n    void backtrack(string num, int target, int index, long currentSum, long prevNum, string currentExpr) {\\n        if (index == num.length()) {\\n            if (currentSum == target) {\\n                result.push_back(currentExpr);\\n            }\\n            return;\\n        }\\n        \\n        for (int i = index; i < num.length(); i++) {\\n            string currentStr = num.substr(index, i - index + 1);\\n            \\n            if (currentStr.length() > 1 && currentStr[0] == \\'0\\') {\\n                // Avoid leading zeros\\n                break;\\n            }\\n            \\n            long currentNum = stol(currentStr);\\n            \\n            if (index == 0) {\\n                backtrack(num, target, i + 1, currentNum, currentNum, currentExpr + currentStr);\\n            } else {\\n                // \\'+\\'\\n                backtrack(num, target, i + 1, currentSum + currentNum, currentNum, currentExpr + \"+\" + currentStr);\\n                \\n                // \\'-\\'\\n                backtrack(num, target, i + 1, currentSum - currentNum, -currentNum, currentExpr + \"-\" + currentStr);\\n                \\n                // \\'*\\'\\n                backtrack(num, target, i + 1, currentSum - prevNum + prevNum * currentNum, prevNum * currentNum, currentExpr + \"*\" + currentStr);\\n            }\\n        }\\n    }\\n    \\n    vector<string> addOperators(string num, int target) {\\n        backtrack(num, target, 0, 0, 0, \"\");\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool> memo;\\n    vector<string> result;\\n    \\n    void backtrack(string num, int target, int index, long currentSum, long prevNum, string currentExpr) {\\n        if (index == num.length()) {\\n            if (currentSum == target) {\\n                result.push_back(currentExpr);\\n            }\\n            return;\\n        }\\n        \\n        for (int i = index; i < num.length(); i++) {\\n            string currentStr = num.substr(index, i - index + 1);\\n            \\n            if (currentStr.length() > 1 && currentStr[0] == \\'0\\') {\\n                // Avoid leading zeros\\n                break;\\n            }\\n            \\n            long currentNum = stol(currentStr);\\n            \\n            if (index == 0) {\\n                backtrack(num, target, i + 1, currentNum, currentNum, currentExpr + currentStr);\\n            } else {\\n                // \\'+\\'\\n                backtrack(num, target, i + 1, currentSum + currentNum, currentNum, currentExpr + \"+\" + currentStr);\\n                \\n                // \\'-\\'\\n                backtrack(num, target, i + 1, currentSum - currentNum, -currentNum, currentExpr + \"-\" + currentStr);\\n                \\n                // \\'*\\'\\n                backtrack(num, target, i + 1, currentSum - prevNum + prevNum * currentNum, prevNum * currentNum, currentExpr + \"*\" + currentStr);\\n            }\\n        }\\n    }\\n    \\n    vector<string> addOperators(string num, int target) {\\n        backtrack(num, target, 0, 0, 0, \"\");\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636686,
                "title": "backtracking-solution-without-pruning-easy-to-understand-go-solution",
                "content": "# Intuition\\nBack track to form all the possible expressions. Don\\'t prune as it might elminate possible solutions. Use stack to evaluate the expression.\\n\\n# Approach\\n* multiplication operation has higher precedence than addion(+) or substraction(-)\\n\\n# Code\\n```\\nimport \"strconv\"\\nimport \"strings\"\\n// -1 = +\\n// -2 = -\\n// -3 = *\\n\\nfunc addOperators(num string, target int) []string {\\n\\tfinalResults := []string{}\\n\\tnumber, _ := strconv.Atoi(num)\\n\\texpr := make([]int, len(num))\\n\\tl := len(num) - 1\\n\\tfor number != 0 {\\n\\t\\texpr[l] = number % 10\\n\\t\\tl--\\n\\t\\t//expr = append(expr, number%10)\\n\\t\\tnumber = number / 10\\n\\t}\\n\\t//reverse := func(s string) string {\\n\\t//\\trns := []rune(s) // convert to rune\\n\\t//\\tfor i, j := 0, len(rns)-1; i < j; i, j = i+1, j-1 {\\n\\t//\\n\\t//\\t\\t// swap the letters of the string,\\n\\t//\\t\\t// like first with last and so on.\\n\\t//\\t\\trns[i], rns[j] = rns[j], rns[i]\\n\\t//\\t}\\n\\t//\\n\\t//\\t// return the reversed string.\\n\\t//\\treturn string(rns)\\n\\t//}\\n\\taddToResults := func(expression []int) {\\n\\t\\tvar r strings.Builder\\n\\t\\tfor _, v := range expression {\\n\\t\\t\\tif v == -1 {\\n\\t\\t\\t\\tr.WriteString(\"+\")\\n\\t\\t\\t} else if v == -2 {\\n\\t\\t\\t\\tr.WriteString(\"-\")\\n\\t\\t\\t} else if v == -3 {\\n\\t\\t\\t\\tr.WriteString(\"*\")\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tr.WriteString(strconv.Itoa(v))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinalResults = append(finalResults, r.String())\\n\\t}\\n\\n\\tvalidExpression := func(expression []int, target int) int {\\n\\t\\tstack := []int{}\\n\\t\\t//fmt.Println(\"Expression : \", expression)\\n\\t\\tfor _, val := range expression {\\n\\t\\t\\tif val >= 0 && len(stack) > 0 && stack[len(stack)-1] == -3 {\\n\\t\\t\\t\\tstack[len(stack)-2] = val * stack[len(stack)-2]\\n\\t\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstack = append(stack, val)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif len(stack) > 1 {\\n\\t\\t\\tresult := stack[0]\\n\\t\\t\\toperation := stack[1]\\n\\t\\t\\tfor i := 2; i < len(stack); i++ {\\n\\t\\t\\t\\tif stack[i] > 0 {\\n\\t\\t\\t\\t\\tif operation == -1 {\\n\\t\\t\\t\\t\\t\\tresult = result + stack[i]\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult = result - stack[i]\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\toperation = stack[i]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//fmt.Println(\"Result: \", result)\\n\\t\\t\\treturn result\\n\\t\\t}\\n\\t\\t//fmt.Println(\"Result: \", stack[0])\\n\\t\\treturn stack[0]\\n\\t}\\n\\n\\tvar add func([]int, []int, int, int)\\n\\tadd = func(num []int, expression []int, target int, index int) {\\n\\t\\tif index == len(num) {\\n\\t\\t\\tif validExpression(expression, target) == target {\\n\\t\\t\\t\\taddToResults(expression)\\n\\t\\t\\t}\\n\\t\\t} else {\\n            // Add\\n            copyExp := make([]int, len(expression))\\n\\t\\t\\tcopy(copyExp, expression)\\n\\t\\t\\tcopyExp = append(copyExp, -1)\\n\\t\\t\\tcopyExp = append(copyExp, num[index])\\n\\t\\t\\tadd(num, copyExp, target, index+1)\\n\\n            //Substract\\n\\t\\t\\tcopyExp = make([]int, len(expression))\\n\\t\\t\\tcopy(copyExp, expression)\\n\\t\\t\\tcopyExp = append(copyExp, -2)\\n\\t\\t\\tcopyExp = append(copyExp, num[index])\\n            add(num, copyExp, target, index+1)\\n\\n            // Multiplication\\n\\t\\t\\tcopyExp = make([]int, len(expression))\\n\\t\\t\\tcopy(copyExp, expression)\\n\\t\\t\\tcopyExp = append(copyExp, -3)\\n\\t\\t\\tcopyExp = append(copyExp, num[index])\\n            add(num, copyExp, target, index+1)\\n\\n            // Combine current digit with last operand\\n            if expression[len(expression)-1] != 0 {\\n                expression[len(expression)-1] = (expression[len(expression)-1]*10)+num[index];\\n                add(num, expression,target, index+1)\\n            }\\n\\n\\t\\t}\\n\\t}\\n\\tadd(expr, []int{expr[0]}, target, 1)\\n\\treturn finalResults\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "String",
                    "Backtracking",
                    "Stack"
                ],
                "code": "```\\nimport \"strconv\"\\nimport \"strings\"\\n// -1 = +\\n// -2 = -\\n// -3 = *\\n\\nfunc addOperators(num string, target int) []string {\\n\\tfinalResults := []string{}\\n\\tnumber, _ := strconv.Atoi(num)\\n\\texpr := make([]int, len(num))\\n\\tl := len(num) - 1\\n\\tfor number != 0 {\\n\\t\\texpr[l] = number % 10\\n\\t\\tl--\\n\\t\\t//expr = append(expr, number%10)\\n\\t\\tnumber = number / 10\\n\\t}\\n\\t//reverse := func(s string) string {\\n\\t//\\trns := []rune(s) // convert to rune\\n\\t//\\tfor i, j := 0, len(rns)-1; i < j; i, j = i+1, j-1 {\\n\\t//\\n\\t//\\t\\t// swap the letters of the string,\\n\\t//\\t\\t// like first with last and so on.\\n\\t//\\t\\trns[i], rns[j] = rns[j], rns[i]\\n\\t//\\t}\\n\\t//\\n\\t//\\t// return the reversed string.\\n\\t//\\treturn string(rns)\\n\\t//}\\n\\taddToResults := func(expression []int) {\\n\\t\\tvar r strings.Builder\\n\\t\\tfor _, v := range expression {\\n\\t\\t\\tif v == -1 {\\n\\t\\t\\t\\tr.WriteString(\"+\")\\n\\t\\t\\t} else if v == -2 {\\n\\t\\t\\t\\tr.WriteString(\"-\")\\n\\t\\t\\t} else if v == -3 {\\n\\t\\t\\t\\tr.WriteString(\"*\")\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tr.WriteString(strconv.Itoa(v))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfinalResults = append(finalResults, r.String())\\n\\t}\\n\\n\\tvalidExpression := func(expression []int, target int) int {\\n\\t\\tstack := []int{}\\n\\t\\t//fmt.Println(\"Expression : \", expression)\\n\\t\\tfor _, val := range expression {\\n\\t\\t\\tif val >= 0 && len(stack) > 0 && stack[len(stack)-1] == -3 {\\n\\t\\t\\t\\tstack[len(stack)-2] = val * stack[len(stack)-2]\\n\\t\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstack = append(stack, val)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif len(stack) > 1 {\\n\\t\\t\\tresult := stack[0]\\n\\t\\t\\toperation := stack[1]\\n\\t\\t\\tfor i := 2; i < len(stack); i++ {\\n\\t\\t\\t\\tif stack[i] > 0 {\\n\\t\\t\\t\\t\\tif operation == -1 {\\n\\t\\t\\t\\t\\t\\tresult = result + stack[i]\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult = result - stack[i]\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\toperation = stack[i]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//fmt.Println(\"Result: \", result)\\n\\t\\t\\treturn result\\n\\t\\t}\\n\\t\\t//fmt.Println(\"Result: \", stack[0])\\n\\t\\treturn stack[0]\\n\\t}\\n\\n\\tvar add func([]int, []int, int, int)\\n\\tadd = func(num []int, expression []int, target int, index int) {\\n\\t\\tif index == len(num) {\\n\\t\\t\\tif validExpression(expression, target) == target {\\n\\t\\t\\t\\taddToResults(expression)\\n\\t\\t\\t}\\n\\t\\t} else {\\n            // Add\\n            copyExp := make([]int, len(expression))\\n\\t\\t\\tcopy(copyExp, expression)\\n\\t\\t\\tcopyExp = append(copyExp, -1)\\n\\t\\t\\tcopyExp = append(copyExp, num[index])\\n\\t\\t\\tadd(num, copyExp, target, index+1)\\n\\n            //Substract\\n\\t\\t\\tcopyExp = make([]int, len(expression))\\n\\t\\t\\tcopy(copyExp, expression)\\n\\t\\t\\tcopyExp = append(copyExp, -2)\\n\\t\\t\\tcopyExp = append(copyExp, num[index])\\n            add(num, copyExp, target, index+1)\\n\\n            // Multiplication\\n\\t\\t\\tcopyExp = make([]int, len(expression))\\n\\t\\t\\tcopy(copyExp, expression)\\n\\t\\t\\tcopyExp = append(copyExp, -3)\\n\\t\\t\\tcopyExp = append(copyExp, num[index])\\n            add(num, copyExp, target, index+1)\\n\\n            // Combine current digit with last operand\\n            if expression[len(expression)-1] != 0 {\\n                expression[len(expression)-1] = (expression[len(expression)-1]*10)+num[index];\\n                add(num, expression,target, index+1)\\n            }\\n\\n\\t\\t}\\n\\t}\\n\\tadd(expr, []int{expr[0]}, target, 1)\\n\\treturn finalResults\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2518924,
                "title": "share-my-c-ac-code",
                "content": "```cpp\\nclass Solution {\\n  public:\\n    vector<string> addOperators(string num, int target) {\\n      string prev;\\n      vector<string> ans;\\n      foo(num, 0, 0, target, prev, ans);\\n      return ans;\\n    }\\n    void eval(long long a, char op, long long b, long long& res, long long& mul_res) {\\n      switch(op) {\\n        case \\'+\\':\\n          res = a + b + mul_res;\\n          mul_res = 0;\\n          break;\\n        case \\'-\\':\\n          res = a - b + mul_res;\\n          mul_res = 0;\\n          break;\\n        case \\'*\\':\\n          //don\\'t know previous sign, deal in calling function\\n          //if (mul_res == 0) mul_res = a;\\n          mul_res *= b;\\n          res += mul_res;\\n          break;\\n        case \\' \\':\\n          res = b;\\n          break;\\n        default:\\n          cerr << \"invalid operator\\\\n\";\\n          exit(1);\\n      }\\n      \\n    }\\n    void foo(string nums, long long cur, long long mul_cur, int target, string& prev, vector<string>& ans) {\\n      char last_op = prev.empty() ? \\' \\' : prev.back();\\n      if (nums.length() == 1 || nums[0] != \\'0\\') { //except leading zero\\n        long long num = stol(nums);\\n        long long tmp = cur, mul_tmp = mul_cur;\\n        eval(cur, last_op, num, tmp, mul_tmp);\\n        //cout << prev  << nums << \" == \" << tmp << \" #\" << cur << \" \" << mul_cur << \" \" << target << endl; //use python eval to test\\n        if (tmp == target) ans.push_back(prev + nums);\\n      }\\n      const size_t nums_len = nums.length();\\n      if (nums.length() < 2) return;\\n      \\n      const size_t cur_prev_len = prev.length();\\n      for (size_t i = 1; i < nums_len; i++) {\\n        string fronts = nums.substr(0, i);\\n        if (i > 1 && nums[0] == \\'0\\') break;//leading zero\\n        string backs = nums.substr(i);\\n        long long front = stol(fronts);\\n        long long new_cur = cur, new_mul = mul_cur;\\n        eval(cur, last_op, front, new_cur, new_mul);\\n        \\n        prev += fronts;\\n        prev.push_back(\\'+\\');\\n        foo(backs, new_cur, 0, target, prev, ans);\\n        \\n        prev.back() = \\'-\\';\\n        foo(backs, new_cur, 0, target, prev, ans);\\n        \\n        prev.back() = \\'*\\';\\n        if (last_op != \\'*\\') //last_op is not \\'*\\'\\n          new_mul = ((last_op == \\'-\\') * -2 + 1) * front;\\n        foo(backs, cur, new_mul, target, prev, ans);\\n        \\n        prev.resize(cur_prev_len);\\n      }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n  public:\\n    vector<string> addOperators(string num, int target) {\\n      string prev;\\n      vector<string> ans;\\n      foo(num, 0, 0, target, prev, ans);\\n      return ans;\\n    }\\n    void eval(long long a, char op, long long b, long long& res, long long& mul_res) {\\n      switch(op) {\\n        case \\'+\\':\\n          res = a + b + mul_res;\\n          mul_res = 0;\\n          break;\\n        case \\'-\\':\\n          res = a - b + mul_res;\\n          mul_res = 0;\\n          break;\\n        case \\'*\\':\\n          //don\\'t know previous sign, deal in calling function\\n          //if (mul_res == 0) mul_res = a;\\n          mul_res *= b;\\n          res += mul_res;\\n          break;\\n        case \\' \\':\\n          res = b;\\n          break;\\n        default:\\n          cerr << \"invalid operator\\\\n\";\\n          exit(1);\\n      }\\n      \\n    }\\n    void foo(string nums, long long cur, long long mul_cur, int target, string& prev, vector<string>& ans) {\\n      char last_op = prev.empty() ? \\' \\' : prev.back();\\n      if (nums.length() == 1 || nums[0] != \\'0\\') { //except leading zero\\n        long long num = stol(nums);\\n        long long tmp = cur, mul_tmp = mul_cur;\\n        eval(cur, last_op, num, tmp, mul_tmp);\\n        //cout << prev  << nums << \" == \" << tmp << \" #\" << cur << \" \" << mul_cur << \" \" << target << endl; //use python eval to test\\n        if (tmp == target) ans.push_back(prev + nums);\\n      }\\n      const size_t nums_len = nums.length();\\n      if (nums.length() < 2) return;\\n      \\n      const size_t cur_prev_len = prev.length();\\n      for (size_t i = 1; i < nums_len; i++) {\\n        string fronts = nums.substr(0, i);\\n        if (i > 1 && nums[0] == \\'0\\') break;//leading zero\\n        string backs = nums.substr(i);\\n        long long front = stol(fronts);\\n        long long new_cur = cur, new_mul = mul_cur;\\n        eval(cur, last_op, front, new_cur, new_mul);\\n        \\n        prev += fronts;\\n        prev.push_back(\\'+\\');\\n        foo(backs, new_cur, 0, target, prev, ans);\\n        \\n        prev.back() = \\'-\\';\\n        foo(backs, new_cur, 0, target, prev, ans);\\n        \\n        prev.back() = \\'*\\';\\n        if (last_op != \\'*\\') //last_op is not \\'*\\'\\n          new_mul = ((last_op == \\'-\\') * -2 + 1) * front;\\n        foo(backs, cur, new_mul, target, prev, ans);\\n        \\n        prev.resize(cur_prev_len);\\n      }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2394320,
                "title": "python-recursive-solution",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        answer = set()\\n        \\n        def dp(idx, total, path, last_number):\\n            if idx == len(num) and total == target:\\n                answer.add(path)\\n                \\n            if idx >= len(num):\\n                return\\n            \\n            for i in range(idx, len(num)):\\n                if len(num[idx:i+1]) > 1 and num[idx:i+1][0] == \"0\":\\n                    continue\\n                    \\n                tmp_number = num[idx:i+1]\\n                \\n                if last_number == \"\":\\n                    dp(i + 1, int(tmp_number), tmp_number, tmp_number)\\n                else:\\n                    # addition\\n                    dp(i + 1,total + int(tmp_number), path + \"+\" + tmp_number, tmp_number)\\n                    \\n                    # subtraction\\n                    dp(i + 1,total - int(tmp_number), path + \"-\" + tmp_number, \"-\" + tmp_number)\\n                    \\n                    # multiplication\\n                    dp(i + 1, total-int(last_number) + (int(last_number) * int(tmp_number)), path + \"*\" + tmp_number, str(int(tmp_number) * int(last_number)))\\n\\n        dp(0,-1,\"\", \"\")\\n        return answer\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        answer = set()\\n        \\n        def dp(idx, total, path, last_number):\\n            if idx == len(num) and total == target:\\n                answer.add(path)\\n                \\n            if idx >= len(num):\\n                return\\n            \\n            for i in range(idx, len(num)):\\n                if len(num[idx:i+1]) > 1 and num[idx:i+1][0] == \"0\":\\n                    continue\\n                    \\n                tmp_number = num[idx:i+1]\\n                \\n                if last_number == \"\":\\n                    dp(i + 1, int(tmp_number), tmp_number, tmp_number)\\n                else:\\n                    # addition\\n                    dp(i + 1,total + int(tmp_number), path + \"+\" + tmp_number, tmp_number)\\n                    \\n                    # subtraction\\n                    dp(i + 1,total - int(tmp_number), path + \"-\" + tmp_number, \"-\" + tmp_number)\\n                    \\n                    # multiplication\\n                    dp(i + 1, total-int(last_number) + (int(last_number) * int(tmp_number)), path + \"*\" + tmp_number, str(int(tmp_number) * int(last_number)))\\n\\n        dp(0,-1,\"\", \"\")\\n        return answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301093,
                "title": "python3",
                "content": "class Solution:\\n\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        result = []\\n        \\n        def Helper(i,prev,curr,val,expr):\\n            if i == n:\\n                if val == target and curr==0:\\n                    result.append(expr)\\n                return\\n            \\n            curr = curr*10 + int(num[i])\\n            \\n            if curr>0:\\n                Helper(i+1,prev,curr,val,expr)\\n                \\n            if not expr:\\n                Helper(i+1,curr,0,val+curr,str(curr))\\n            else:\\n                Helper(i+1,curr,0,val+curr,expr+\\'+\\'+str(curr))\\n                Helper(i+1,-curr,0,val-curr,expr+\\'-\\'+str(curr))\\n                Helper(i+1,prev*curr,0,val-prev+prev*curr,expr+\\'*\\'+str(curr))\\n           \\n        Helper(0,0,0,0,\"\")\\n        return result",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        result = []\\n        \\n        def Helper(i,prev,curr,val,expr):\\n            if i == n:\\n                if val == target and curr==0:\\n                    result.append(expr)\\n                return\\n            \\n            curr = curr*10 + int(num[i])\\n            \\n            if curr>0:\\n                Helper(i+1,prev,curr,val,expr)\\n                \\n            if not expr:\\n                Helper(i+1,curr,0,val+curr,str(curr))\\n            else:\\n                Helper(i+1,curr,0,val+curr,expr+\\'+\\'+str(curr))\\n                Helper(i+1,-curr,0,val-curr,expr+\\'-\\'+str(curr))\\n                Helper(i+1,prev*curr,0,val-prev+prev*curr,expr+\\'*\\'+str(curr))\\n           \\n        Helper(0,0,0,0,\"\")\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 2210626,
                "title": "c-backtrack-clean-code",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<string> res;\\n\\t\\tstring s;\\n\\t\\tint target, n;\\n\\t\\tvoid solve(int it,  string path, long long resSoFar, long long prev){\\n\\t\\t\\tif(it == n){\\n\\t\\t\\t\\tif(resSoFar == target) res.push_back(path);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tlong long num = 0;\\n\\t\\t\\tstring tmp;\\n\\n\\t\\t\\tfor(auto j = it; j < n; j++){\\n\\t\\t\\t\\tif(j > it && s[it] == \\'0\\') break;\\n\\n\\t\\t\\t\\tnum = num * 10 + (s[j] - \\'0\\');\\n\\t\\t\\t\\ttmp.push_back(s[j]);\\n\\n\\t\\t\\t\\tif(it == 0) solve(j + 1, tmp, num, num);\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tsolve(j + 1, path + \"+\" + tmp, resSoFar + num, num);\\n\\t\\t\\t\\t\\tsolve(j + 1, path + \\'-\\' + tmp, resSoFar - num, -num);\\n\\t\\t\\t\\t\\tsolve(j + 1, path + \\'*\\' + tmp, resSoFar - prev + prev * num, prev * num);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tvector<string> addOperators(string num, int target) {\\n\\t\\t\\tthis -> target = target;\\n\\t\\t\\ts = num, n = num.size();\\n\\n\\t\\t\\tsolve(0, \"\", 0, 0);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<string> res;\\n\\t\\tstring s;\\n\\t\\tint target, n;\\n\\t\\tvoid solve(int it,  string path, long long resSoFar, long long prev){\\n\\t\\t\\tif(it == n){\\n\\t\\t\\t\\tif(resSoFar == target) res.push_back(path);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2157952,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    \\n    vector<string> ans;\\n    \\n    string num;\\n    int target;\\n    \\n    vector<string> addOperators(string num, int target) {\\n        \\n        this->num = num;\\n        \\n        this->target = target;\\n        \\n        backtrack( 0, \"\", 0, 0);\\n        \\n        return ans;\\n    }\\n    void backtrack(int i, const string& path, long resSoFar, long prevNum) {\\n        \\n        if (i == num.size()) {\\n            \\n            if (resSoFar == target)   \\n            {\\n                ans.push_back(path);\\n                \\n            }\\n            \\n            return;\\n        \\n        }\\n        \\n        string numStr;\\n        \\n        long num1 = 0;\\n        \\n        for (int j = i; j < num.length(); j++) {\\n            \\n            if (j > i && num[i] == \\'0\\')\\n            {\\n                break;\\n            }\\n            numStr += num[j];\\n            \\n            num1 = num1 * 10 + num[j] - \\'0\\';\\n            \\n            if (i == 0) {\\n                \\n                backtrack(j + 1, path + numStr, num1, num1);\\n                \\n            } else {\\n                \\n                backtrack(j + 1, path + \"+\" + numStr, resSoFar + num1, num1);\\n                \\n                backtrack(j + 1, path + \"-\" + numStr, resSoFar - num1, -num1);\\n                \\n                backtrack(j + 1, path + \"*\" + numStr, resSoFar - prevNum + prevNum * num1, prevNum * num1);\\n            }\\n        }\\n    }\\n};    \\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    vector<string> ans;\\n    \\n    string num;\\n    int target;\\n    \\n    vector<string> addOperators(string num, int target) {\\n        \\n        this->num = num;\\n        \\n        this->target = target;\\n        \\n        backtrack( 0, \"\", 0, 0);\\n        \\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2109805,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        res, self.target = [], target\\n        for i in range(1,len(num)+1):\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], num[:i], int(num[:i]), int(num[:i]), res) # this step put first number in the string\\n        return res\\n\\n    def dfs(self, num, temp, cur, last, res):\\n        if not num:\\n            if cur == self.target:\\n                res.append(temp)\\n            return\\n        for i in range(1, len(num)+1):\\n            val = num[:i]\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], temp + \"+\" + val, cur+int(val), int(val), res)\\n                self.dfs(num[i:], temp + \"-\" + val, cur-int(val), -int(val), res)\\n                self.dfs(num[i:], temp + \"*\" + val, cur-last+last*int(val), last*int(val), res)        \\n\\t\\t\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        res, self.target = [], target\\n        for i in range(1,len(num)+1):\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], num[:i], int(num[:i]), int(num[:i]), res) # this step put first number in the string\\n        return res\\n\\n    def dfs(self, num, temp, cur, last, res):\\n        if not num:\\n            if cur == self.target:\\n                res.append(temp)\\n            return\\n        for i in range(1, len(num)+1):\\n            val = num[:i]\\n            if i == 1 or (i > 1 and num[0] != \"0\"): # prevent \"00*\" as a number\\n                self.dfs(num[i:], temp + \"+\" + val, cur+int(val), int(val), res)\\n                self.dfs(num[i:], temp + \"-\" + val, cur-int(val), -int(val), res)\\n                self.dfs(num[i:], temp + \"*\" + val, cur-last+last*int(val), last*int(val), res)        \\n\\t\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1999699,
                "title": "python-naive-recursion",
                "content": "Can pass. Although it is slow. but the code cleaner. Replace - with +-, so that the final string will only have + and * two operations. \\nFirst split by + to get all parts. \\nThen split by * to get each part value. Super clean to code.\\nAlso, each part split by + can be cached to avoid duplicate calculation.\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        \\n        ans = []\\n        \\n        @cache\\n        def subcheck(s):            \\n            parts = s.split(\\'*\\')\\n            res = int(parts[0])\\n            for p in parts[1:]:\\n                res *= int(p)\\n            return res\\n        \\n        def check(s):      \\n            ss = \\'\\'.join(s)\\n            # print(s)\\n            parts = ss.split(\\'+\\')\\n            sumv = sum(map(subcheck, parts))\\n            if sumv == target:\\n                ss = ss.replace(\\'+-\\', \\'-\\')\\n                ans.append(ss)\\n        \\n        def bt(cur, i):\\n            if i == n:\\n                check(cur)\\n                return\\n            if i == 0:\\n                bt(cur + [num[i]], i + 1)\\n            else:\\n                if cur[-1] == \\'0\\' and (len(cur)< 2 or (not (\\'0\\'<= cur[-2] <= \\'9\\'))): # for leading 0\\n                    bt(cur + [\\'+\\', num[i]], i + 1)\\n                    bt(cur + [\\'+-\\', num[i]], i + 1)\\n                    bt(cur + [\\'*\\', num[i]], i + 1)\\n                else:\\n                    bt(cur + [num[i]], i + 1)\\n                    bt(cur + [\\'+\\', num[i]], i + 1)\\n                    bt(cur + [\\'+-\\', num[i]], i + 1)\\n                    bt(cur + [\\'*\\', num[i]], i + 1)            \\n            \\n        bt([], 0)\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        \\n        ans = []\\n        \\n        @cache\\n        def subcheck(s):            \\n            parts = s.split(\\'*\\')\\n            res = int(parts[0])\\n            for p in parts[1:]:\\n                res *= int(p)\\n            return res\\n        \\n        def check(s):      \\n            ss = \\'\\'.join(s)\\n            # print(s)\\n            parts = ss.split(\\'+\\')\\n            sumv = sum(map(subcheck, parts))\\n            if sumv == target:\\n                ss = ss.replace(\\'+-\\', \\'-\\')\\n                ans.append(ss)\\n        \\n        def bt(cur, i):\\n            if i == n:\\n                check(cur)\\n                return\\n            if i == 0:\\n                bt(cur + [num[i]], i + 1)\\n            else:\\n                if cur[-1] == \\'0\\' and (len(cur)< 2 or (not (\\'0\\'<= cur[-2] <= \\'9\\'))): # for leading 0\\n                    bt(cur + [\\'+\\', num[i]], i + 1)\\n                    bt(cur + [\\'+-\\', num[i]], i + 1)\\n                    bt(cur + [\\'*\\', num[i]], i + 1)\\n                else:\\n                    bt(cur + [num[i]], i + 1)\\n                    bt(cur + [\\'+\\', num[i]], i + 1)\\n                    bt(cur + [\\'+-\\', num[i]], i + 1)\\n                    bt(cur + [\\'*\\', num[i]], i + 1)            \\n            \\n        bt([], 0)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940237,
                "title": "python-code",
                "content": "```\\n    def addOperators(self, num: str, T: int) -> List[str]:\\n\\n\\t\\tdef f(i, exp, prev, expval):\\n\\n\\t\\t\\tif i == len(num):\\n\\t\\t\\t\\tif expval == T:\\n\\t\\t\\t\\t\\tself.res.append(exp)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tfor j in range(i, len(num)):\\n\\t\\t\\t\\tcur = int(num[i:j+1])\\n\\t\\t\\t\\tif num[i] == \\'0\\' and i < j: # 1* 05 = 1*5 is not allowed so 05 has to be skipped. IMP\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tif i == 0:\\n\\t\\t\\t\\t\\tf(j+1, str(cur), cur, cur) # IMP: 1st number will not use any operators. Each subsequent number will be <op> num\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tf(j+1, exp + \\'+\\' + str(cur), cur, expval+cur)\\n\\t\\t\\t\\t\\tf(j+1, exp + \\'-\\' + str(cur), -cur, expval-cur) # IMP: -cur is passed to reverse this calulation on encountering \\'*\\'\\n\\t\\t\\t\\t\\tf(j+1, exp + \\'*\\' + str(cur), prev*cur, expval - prev + prev*cur) #IMP\\n\\n\\t\\tself.res = []\\n\\t\\tf(0, \"\", 0, 0)\\n\\t\\treturn self.res\\n\\n# To tackle the problem of order of evalution (calculating the product before sum), we always calculate sum but change the exp val when we encounter the \\'*\\'\\n```",
                "solutionTags": [],
                "code": "```\\n    def addOperators(self, num: str, T: int) -> List[str]:\\n\\n\\t\\tdef f(i, exp, prev, expval):\\n\\n\\t\\t\\tif i == len(num):\\n\\t\\t\\t\\tif expval == T:\\n\\t\\t\\t\\t\\tself.res.append(exp)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tfor j in range(i, len(num)):\\n\\t\\t\\t\\tcur = int(num[i:j+1])\\n\\t\\t\\t\\tif num[i] == \\'0\\' and i < j: # 1* 05 = 1*5 is not allowed so 05 has to be skipped. IMP\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tif i == 0:\\n\\t\\t\\t\\t\\tf(j+1, str(cur), cur, cur) # IMP: 1st number will not use any operators. Each subsequent number will be <op> num\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tf(j+1, exp + \\'+\\' + str(cur), cur, expval+cur)\\n\\t\\t\\t\\t\\tf(j+1, exp + \\'-\\' + str(cur), -cur, expval-cur) # IMP: -cur is passed to reverse this calulation on encountering \\'*\\'\\n\\t\\t\\t\\t\\tf(j+1, exp + \\'*\\' + str(cur), prev*cur, expval - prev + prev*cur) #IMP\\n\\n\\t\\tself.res = []\\n\\t\\tf(0, \"\", 0, 0)\\n\\t\\treturn self.res\\n\\n# To tackle the problem of order of evalution (calculating the product before sum), we always calculate sum but change the exp val when we encounter the \\'*\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1926405,
                "title": "java-99-fast-solution-with-full-detailed-explanations",
                "content": "```\\nclass Solution\\n{\\n    public List<String> addOperators(String num, int target)\\n    {\\n        List<String> result = new ArrayList<>();\\n        if (target == Integer.MIN_VALUE) return result;\\n        \\n        // using char array to avoid more space consuming by string\\n        char[] originalChars = num.toCharArray();\\n        int len = num.length();\\n        \\n        // the maximum length of the new string with operators is 2 * len - 1(1 + 1 + 2)\\n        // add an operator in between each character\\n        char[] newChars = new char[len + len - 1];\\n        \\n        // originalIndex: the index we use to track in original num.\\n        int originalIndex = 0;\\n        \\n        // newIndex: the index we use to track in new formed string with operators.\\n        int newIndex = 0;\\n        \\n        int currentValue = 0;   // the current operand value.\\n        \\n        long targetL = target;  // avoid overflow.\\n        \\n        // The first operand is without operator before it.\\n        for (int i = 0; i < len; i++)\\n        {\\n            // current value can be multiple digits.\\n            currentValue = 10 * currentValue + (originalChars[i] - \\'0\\');\\n            \\n            // form new string with operators.\\n            newChars[newIndex++] = originalChars[i];\\n            \\n            // using helper function formOperator to process the rest (recursion)\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, 0, currentValue, targetL);\\n            \\n            if (currentValue == 0) break;   // can only has single digit: 0 if value == 0, no need to calculate multiple digits.\\n        }\\n        \\n        return result;\\n    }\\n    \\n    // ......pre_preSum (+) preValue <operator> currentValue;\\n    // if (+) is (-), the preValue will be -preValue;\\n    // if <operator> is (*), then pre_presSum stays, first calculate preValue * currentValue;\\n    \\n    private void formOperator(List<String> result, char[] originalChars, char[] newChars, \\n                              int originalIndex, int newIndex, int len,\\n                              long pre_preSum, long preValue, long targetL)\\n    {\\n        // already reach to the end of the original chars.\\n        if (originalIndex == len)\\n        {\\n            if (pre_preSum + preValue == targetL)\\n            {\\n                result.add(new String(newChars, 0, newIndex));\\n            }\\n            \\n            return;\\n        }\\n        \\n        long currentValue = 0;\\n        int operatorIndex = newIndex++;\\n        \\n        for (int i = originalIndex; i < len; i++)\\n        {\\n            // current value can be multiple digits.\\n            currentValue = 10 * currentValue + (originalChars[i] - \\'0\\');\\n            \\n            // form new string with operators.\\n            newChars[newIndex++] = originalChars[i];\\n            \\n            newChars[operatorIndex] = \\'+\\';\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, pre_preSum + preValue, currentValue, targetL);\\n            \\n            newChars[operatorIndex] = \\'-\\';\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, pre_preSum + preValue, -currentValue, targetL);\\n            \\n            newChars[operatorIndex] = \\'*\\';\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, pre_preSum, preValue * currentValue, targetL);\\n            \\n            if (currentValue == 0) break;   // no leading zeros(multiple digits).\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution\\n{\\n    public List<String> addOperators(String num, int target)\\n    {\\n        List<String> result = new ArrayList<>();\\n        if (target == Integer.MIN_VALUE) return result;\\n        \\n        // using char array to avoid more space consuming by string\\n        char[] originalChars = num.toCharArray();\\n        int len = num.length();\\n        \\n        // the maximum length of the new string with operators is 2 * len - 1(1 + 1 + 2)\\n        // add an operator in between each character\\n        char[] newChars = new char[len + len - 1];\\n        \\n        // originalIndex: the index we use to track in original num.\\n        int originalIndex = 0;\\n        \\n        // newIndex: the index we use to track in new formed string with operators.\\n        int newIndex = 0;\\n        \\n        int currentValue = 0;   // the current operand value.\\n        \\n        long targetL = target;  // avoid overflow.\\n        \\n        // The first operand is without operator before it.\\n        for (int i = 0; i < len; i++)\\n        {\\n            // current value can be multiple digits.\\n            currentValue = 10 * currentValue + (originalChars[i] - \\'0\\');\\n            \\n            // form new string with operators.\\n            newChars[newIndex++] = originalChars[i];\\n            \\n            // using helper function formOperator to process the rest (recursion)\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, 0, currentValue, targetL);\\n            \\n            if (currentValue == 0) break;   // can only has single digit: 0 if value == 0, no need to calculate multiple digits.\\n        }\\n        \\n        return result;\\n    }\\n    \\n    // ......pre_preSum (+) preValue <operator> currentValue;\\n    // if (+) is (-), the preValue will be -preValue;\\n    // if <operator> is (*), then pre_presSum stays, first calculate preValue * currentValue;\\n    \\n    private void formOperator(List<String> result, char[] originalChars, char[] newChars, \\n                              int originalIndex, int newIndex, int len,\\n                              long pre_preSum, long preValue, long targetL)\\n    {\\n        // already reach to the end of the original chars.\\n        if (originalIndex == len)\\n        {\\n            if (pre_preSum + preValue == targetL)\\n            {\\n                result.add(new String(newChars, 0, newIndex));\\n            }\\n            \\n            return;\\n        }\\n        \\n        long currentValue = 0;\\n        int operatorIndex = newIndex++;\\n        \\n        for (int i = originalIndex; i < len; i++)\\n        {\\n            // current value can be multiple digits.\\n            currentValue = 10 * currentValue + (originalChars[i] - \\'0\\');\\n            \\n            // form new string with operators.\\n            newChars[newIndex++] = originalChars[i];\\n            \\n            newChars[operatorIndex] = \\'+\\';\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, pre_preSum + preValue, currentValue, targetL);\\n            \\n            newChars[operatorIndex] = \\'-\\';\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, pre_preSum + preValue, -currentValue, targetL);\\n            \\n            newChars[operatorIndex] = \\'*\\';\\n            formOperator(result, originalChars, newChars, i + 1, newIndex, len, pre_preSum, preValue * currentValue, targetL);\\n            \\n            if (currentValue == 0) break;   // no leading zeros(multiple digits).\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883703,
                "title": "c-dfs-solution-very-easy-to-understand-with-comment",
                "content": "Many thanks to this post, I was inspired and fully understand the process after thinking it through\\nhttps://leetcode.com/problems/expression-add-operators/discuss/1553905/C-DFS-Easy-to-understand\\n\\n\\n\\n    \\n\\n    \\n    public class Solution {\\n    List<string> result;\\n    string s;\\n    int target;\\n\\t// inspired from this post https://leetcode.com/problems/expression-add-operators/discuss/1553905/C-DFS-Easy-to-understand\\n    public IList<string> AddOperators(string num, int target) \\n    {\\n        result = new List<string>();\\n        this.s=num;\\n        this.target=target;\\n        \\n        dfs(0, string.Empty, 0, 0);\\n        return result;\\n    }\\n    \\n    public void dfs(int startIndex, string temp, long prev, long curResult)\\n    {\\n        if(startIndex == s.Length)\\n        {\\n            if(prev+curResult == target)\\n                result.Add(temp);  \\n            return;\\n        }\\n        \\n        // start from startIndex again for next number\\n        for(int i=startIndex; i < s.Length; i++)\\n        {\\n            // i+1 - startIndex was length from startIndex\\n            // get every substring from startIndex\\n            var cur = s.Substring(startIndex, i+1-startIndex);\\n            \\n            // leading 0\\n            if(cur.Length > 1 && cur[0] == \\'0\\')\\n                continue;\\n            \\n            var curNum = Int64.Parse(cur);\\n            \\n            if(startIndex == 0)\\n                dfs(i+1, cur, curNum, 0);\\n            else\\n            {\\n                // please refer to 227. Basic Calculator II\\'s optimal solution about defered calculation \\n                    //  \\'*\\')\\n                        dfs(i+1, temp + \"*\" + cur, prev*curNum, curResult);\\n                    // \\'+\\')\\n                        dfs(i+1, temp + \"+\" + cur, curNum,  curResult + prev);\\n                    // \\'-\\')\\n                        dfs(i+1, temp + \"-\" + cur, -curNum, curResult + prev);\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    List<string> result;\\n    string s;\\n    int target;\\n\\t// inspired from this post https://leetcode.com/problems/expression-add-operators/discuss/1553905/C-DFS-Easy-to-understand\\n    public IList<string> AddOperators(string num, int target) \\n    {\\n        result = new List<string>();\\n        this.s=num;\\n        this.target=target;\\n        \\n        dfs(0, string.Empty, 0, 0);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1832360,
                "title": "c-learning-opportunities",
                "content": "March 8, 2022\\n**Introduction**\\nIt is a hard level algorithm. The tip is to learn how to handle multiplication and put it\\'s precedence before \"+\" and \"-\". \\n\\n**Case study I** \\nFor example, if you have a sequence of 12345 and you have proceeded to 1 + 2 + 3, now your eval is 6 right? If you want to add a * between 3 and 4, you would take 3 as the digit to be multiplied, so you want to take it out from the existing eval. You have 1 + 2 + 3 * 4 and the eval now is (1 + 2 + 3) - 3 + (3 * 4). \\n\\n**Case study II**\\nWe need to maintain the value of consecutive * result, if we want to do another * operation, just minus consecutive * result, and use that to multiply the new number.\\n\\nfor 1 + 2 * 3 if we want to *4, so it should 1 + 2 * 3 - 2 * 3 + 2 * 3  *  4\\n\\nThe following code uses the above idea to handle multiplication. Try to debug second test case and see if it is true to have -2 * 3, followed by 2 * 3 * 4. \\n\\nThe following C# code passes online judge. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _228_epxression_and_operator_B\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var test = new Program();\\n            var result = test.AddOperators(\"123\", 6);\\n        }\\n\\n        public IList<string> AddOperators(string num, int target)\\n        {           \\n            if (num == null || num.Length == 0)\\n            {\\n                return new List<string>();\\n            }\\n\\n            var result = new List<string>();\\n\\n            runDFS(result, \"\", num, target, 0, 0, 0);\\n            return result;\\n        }\\n\\n        /// <summary>\\n        /// study code\\n        /// https://leetcode.com/problems/expression-add-operators/discuss/71895/Java-Standard-Backtrace-AC-Solutoin-short-and-clear\\n        /// </summary>\\n        /// <param name=\"expressions\"></param>\\n        /// <param name=\"path\"></param>\\n        /// <param name=\"num\"></param>\\n        /// <param name=\"target\"></param>\\n        /// <param name=\"pos\"></param>\\n        /// <param name=\"eval\"></param>\\n        /// <param name=\"multed\"></param>\\n        private void runDFS(List<string> expressions, string path, string num, int target, int pos, long eval, long multed)\\n        {\\n            if (pos == num.Length)\\n            {\\n                if (target == eval)\\n                {\\n                    expressions.Add(path);\\n                }\\n\\n                return;\\n            }\\n\\n            for (int i = pos; i < num.Length; i++)\\n            {\\n                if (i != pos && num[pos] == \\'0\\')\\n                {\\n                    break;\\n                }\\n\\n                long operand = Convert.ToInt64(num.Substring(pos, i - pos + 1));\\n\\n                if (pos == 0)\\n                {\\n                    runDFS(expressions, path + operand, num, target, i + 1, operand, operand);\\n                }\\n                else\\n                {\\n                    runDFS(expressions, path + \"+\" + operand, num, target, i + 1, eval + operand, operand);\\n                    runDFS(expressions, path + \"-\" + operand, num, target, i + 1, eval - operand, -operand);\\n                    runDFS(expressions, path + \"*\" + operand, num, target, i + 1, eval - multed + multed * operand, multed * operand);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _228_epxression_and_operator_B\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var test = new Program();\\n            var result = test.AddOperators(\"123\", 6);\\n        }\\n\\n        public IList<string> AddOperators(string num, int target)\\n        {           \\n            if (num == null || num.Length == 0)\\n            {\\n                return new List<string>();\\n            }\\n\\n            var result = new List<string>();\\n\\n            runDFS(result, \"\", num, target, 0, 0, 0);\\n            return result;\\n        }\\n\\n        /// <summary>\\n        /// study code\\n        /// https://leetcode.com/problems/expression-add-operators/discuss/71895/Java-Standard-Backtrace-AC-Solutoin-short-and-clear\\n        /// </summary>\\n        /// <param name=\"expressions\"></param>\\n        /// <param name=\"path\"></param>\\n        /// <param name=\"num\"></param>\\n        /// <param name=\"target\"></param>\\n        /// <param name=\"pos\"></param>\\n        /// <param name=\"eval\"></param>\\n        /// <param name=\"multed\"></param>\\n        private void runDFS(List<string> expressions, string path, string num, int target, int pos, long eval, long multed)\\n        {\\n            if (pos == num.Length)\\n            {\\n                if (target == eval)\\n                {\\n                    expressions.Add(path);\\n                }\\n\\n                return;\\n            }\\n\\n            for (int i = pos; i < num.Length; i++)\\n            {\\n                if (i != pos && num[pos] == \\'0\\')\\n                {\\n                    break;\\n                }\\n\\n                long operand = Convert.ToInt64(num.Substring(pos, i - pos + 1));\\n\\n                if (pos == 0)\\n                {\\n                    runDFS(expressions, path + operand, num, target, i + 1, operand, operand);\\n                }\\n                else\\n                {\\n                    runDFS(expressions, path + \"+\" + operand, num, target, i + 1, eval + operand, operand);\\n                    runDFS(expressions, path + \"-\" + operand, num, target, i + 1, eval - operand, -operand);\\n                    runDFS(expressions, path + \"*\" + operand, num, target, i + 1, eval - multed + multed * operand, multed * operand);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724667,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        \\n        # required = is there a leading 0 to the current expression?\\n        def backtracking(solution, pos, num, target, expression, required):\\n            if pos == len(num):\\n                S = 0\\n                operators = []\\n                for c in expression:\\n                    if not c.isnumeric():\\n                        operators.append(c)\\n                \\n                if len(operators) == 0:\\n                    if target == int(expression):\\n                        solution.append(expression)\\n                else:\\n                    oldExp = expression\\n                    for o in \"*+-\":\\n                        expression = expression.replace(o, \" \")\\n                    \\n                    values = expression.split()\\n                    j = len(values) - 1\\n                    k = len(operators) - 1\\n                    while j > 0: # and k >= 0:\\n                        if operators[k] == \\'+\\':\\n                            S += int(values[j])\\n                        elif operators[k] == \\'-\\':\\n                            S -= int(values[j])\\n                        else:\\n                            P = int(values[j])\\n                            k -= 1\\n                            j -= 1\\n                            while j > 0 and operators[k] == \\'*\\': # and k >= 0 :\\n                                P *= int(values[j])\\n                                j -= 1\\n                                k -= 1\\n                            P *= int(values[j])\\n                            if j == 0:\\n                                S += P\\n                            else:\\n                                if operators[k] == \\'-\\':\\n                                    S -= P\\n                                else:\\n                                    S += P\\n                        j -= 1\\n                        k -= 1\\n                    if j == 0:\\n                        S += int(values[0])\\n                    if S == target:\\n                        solution.append(oldExp)\\n            else:\\n                r = False\\n                if num[pos] == \\'0\\':\\n                    r = True\\n                \\n                if required == False:\\n                    backtracking(solution, pos + 1, num, target, expression + num[pos], False)\\n                backtracking(solution, pos + 1, num, target, expression + \\'+\\' + num[pos], r)\\n                backtracking(solution, pos + 1, num, target, expression + \\'-\\' + num[pos], r)\\n                backtracking(solution, pos + 1, num, target, expression + \\'*\\' + num[pos], r)\\n                \\n        \\n        solution = []\\n        if num[0] == \\'0\\':\\n            backtracking(solution, 1, num, target, num[0], True)\\n        else:\\n            backtracking(solution, 1, num, target, num[0], False)\\n        \\n        return solution\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        \\n        # required = is there a leading 0 to the current expression?\\n        def backtracking(solution, pos, num, target, expression, required):\\n            if pos == len(num):\\n                S = 0\\n                operators = []\\n                for c in expression:\\n                    if not c.isnumeric():\\n                        operators.append(c)\\n                \\n                if len(operators) == 0:\\n                    if target == int(expression):\\n                        solution.append(expression)\\n                else:\\n                    oldExp = expression\\n                    for o in \"*+-\":\\n                        expression = expression.replace(o, \" \")\\n                    \\n                    values = expression.split()\\n                    j = len(values) - 1\\n                    k = len(operators) - 1\\n                    while j > 0: # and k >= 0:\\n                        if operators[k] == \\'+\\':\\n                            S += int(values[j])\\n                        elif operators[k] == \\'-\\':\\n                            S -= int(values[j])\\n                        else:\\n                            P = int(values[j])\\n                            k -= 1\\n                            j -= 1\\n                            while j > 0 and operators[k] == \\'*\\': # and k >= 0 :\\n                                P *= int(values[j])\\n                                j -= 1\\n                                k -= 1\\n                            P *= int(values[j])\\n                            if j == 0:\\n                                S += P\\n                            else:\\n                                if operators[k] == \\'-\\':\\n                                    S -= P\\n                                else:\\n                                    S += P\\n                        j -= 1\\n                        k -= 1\\n                    if j == 0:\\n                        S += int(values[0])\\n                    if S == target:\\n                        solution.append(oldExp)\\n            else:\\n                r = False\\n                if num[pos] == \\'0\\':\\n                    r = True\\n                \\n                if required == False:\\n                    backtracking(solution, pos + 1, num, target, expression + num[pos], False)\\n                backtracking(solution, pos + 1, num, target, expression + \\'+\\' + num[pos], r)\\n                backtracking(solution, pos + 1, num, target, expression + \\'-\\' + num[pos], r)\\n                backtracking(solution, pos + 1, num, target, expression + \\'*\\' + num[pos], r)\\n                \\n        \\n        solution = []\\n        if num[0] == \\'0\\':\\n            backtracking(solution, 1, num, target, num[0], True)\\n        else:\\n            backtracking(solution, 1, num, target, num[0], False)\\n        \\n        return solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714422,
                "title": "20-lines-ez-to-understand-python-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        result = []\\n        self.add_helper(num, 0, \"\", 0, target, result, 0)\\n        return result\\n    \\n    def add_helper(self, num, cur_idx, candidate, value, target, result, last):\\n\\t    # add to result when proceeding the whole string and value equals to target\\n        if value == target and cur_idx == len(num):\\n            result.append(candidate)\\n            return\\n        \\n        # slice a number between current position to the end of string\\n        for i in range(cur_idx, len(num)):\\n            # if number is not a single digit 0 (0 at current index but have numbers in the following), just dont slice any more\\n            if num[cur_idx] == \"0\" and i != cur_idx:\\n                break\\n            cur_num = num[cur_idx : i + 1]\\n            \\n            # if it\\'s slicing number from beginning\\n            if cur_idx == 0:\\n                self.add_helper(num, i + 1, cur_num, value + int(cur_num), target, result, int(cur_num))\\n            else:\\n                # use last to record last number proceeded\\n                self.add_helper(num, i + 1, candidate + \"+\" + cur_num, value + int(cur_num), target, result, int(cur_num))\\n                self.add_helper(num, i + 1, candidate + \"-\" + cur_num, value - int(cur_num), target, result, -int(cur_num))                \\n                self.add_helper(num, i + 1, candidate + \"*\" + cur_num, value - last + last * int(cur_num), target, result, last * int(cur_num))\\n\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        result = []\\n        self.add_helper(num, 0, \"\", 0, target, result, 0)\\n        return result\\n    \\n    def add_helper(self, num, cur_idx, candidate, value, target, result, last):\\n\\t    # add to result when proceeding the whole string and value equals to target\\n        if value == target and cur_idx == len(num):\\n            result.append(candidate)\\n            return\\n        \\n        # slice a number between current position to the end of string\\n        for i in range(cur_idx, len(num)):\\n            # if number is not a single digit 0 (0 at current index but have numbers in the following), just dont slice any more\\n            if num[cur_idx] == \"0\" and i != cur_idx:\\n                break\\n            cur_num = num[cur_idx : i + 1]\\n            \\n            # if it\\'s slicing number from beginning\\n            if cur_idx == 0:\\n                self.add_helper(num, i + 1, cur_num, value + int(cur_num), target, result, int(cur_num))\\n            else:\\n                # use last to record last number proceeded\\n                self.add_helper(num, i + 1, candidate + \"+\" + cur_num, value + int(cur_num), target, result, int(cur_num))\\n                self.add_helper(num, i + 1, candidate + \"-\" + cur_num, value - int(cur_num), target, result, -int(cur_num))                \\n                self.add_helper(num, i + 1, candidate + \"*\" + cur_num, value - last + last * int(cur_num), target, result, last * int(cur_num))\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688637,
                "title": "python3-naive-way-backtrack-with-eval",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        \\n        ans = []\\n        \\n        def backtrack(start, path):\\n            if len(path) == 1 and path == \"0\":\\n                return\\n            if len(path) >= 2 and path[-2:] in [\"+0\", \"-0\", \"*0\"]:\\n                return\\n            if start == len(num) - 1:\\n                if eval(path+num[-1]) == target:\\n                    ans.append(path+num[-1])\\n                return\\n            backtrack(start+1, path+num[start]+\"*\")\\n            backtrack(start+1, path+num[start]+\"+\")\\n            backtrack(start+1, path+num[start]+\"-\")\\n            backtrack(start+1, path+num[start])\\n\\n            \\n        backtrack(0, \"\")\\n        \\n        return ans\\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        \\n        ans = []\\n        \\n        def backtrack(start, path):\\n            if len(path) == 1 and path == \"0\":\\n                return\\n            if len(path) >= 2 and path[-2:] in [\"+0\", \"-0\", \"*0\"]:\\n                return\\n            if start == len(num) - 1:\\n                if eval(path+num[-1]) == target:\\n                    ans.append(path+num[-1])\\n                return\\n            backtrack(start+1, path+num[start]+\"*\")\\n            backtrack(start+1, path+num[start]+\"+\")\\n            backtrack(start+1, path+num[start]+\"-\")\\n            backtrack(start+1, path+num[start])\\n\\n            \\n        backtrack(0, \"\")\\n        \\n        return ans\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1685789,
                "title": "python-straightforward-w-explanation",
                "content": "This problem involves some basic recursion however the challenge arises from following order of operations. For instance, take the following expression: `4 + 2 * 5`. The way our program would calculate without following order of ops would be: `4 + 2 * 5 = 6 * 5 = 30` which is obviously wrong. \\n\\nWhat we need to do when we see a multiplication is reverse our previous operation and then do the multiplication. For instance, `4 + 2 * 5 => 6 * 5 => (6 - 2) + 2 * 5 = 14`. What we did is keep track of the previous number that would help us reverse the previous operation. When we subtract that number from the current result, we get the value of the previous expression and then we can simply add the product. \\n\\nIn the above example, at the multiplication step, the previous value was `2`. When `2` was subtracted from the current sum of `6`, we got our previous sum of `4` to which we could add `2 * 5`. If the expression to evaluate were instead `4 - 2 * 5`, we would store `-2` as our previous value as that would allow us to reverse the subtraction: `4 - 2 * 5 => 2 * 5 => (2 - -2) + -2 * 5 = -6`.\\n\\nIf the expression were `4 * 2 * 5`, we would just store the current number times the previous number: `4 * 2 * 5 = 8 * 5 = 40`.\\n\\nTo skip leading zeroes, we check if the first digit at the current index is a 0 and if so, we can stop after the first iteration of the loop.\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n        \\n        def recurse(curIdx=0, curExpr=[], curSum=0, prevNum=0):\\n            if curIdx >= len(num):\\n                if curSum == target:\\n                    res.append(\\'\\'.join(curExpr))\\n                return\\n            \\n            for i in range(curIdx, len(num)):\\n                curNum = int(num[curIdx:i+1])\\n                if not curExpr:\\n                    recurse(i + 1, [str(curNum)], curNum, curNum)\\n                else:\\n                    recurse(i + 1, [*curExpr, \\'+\\', str(curNum)], curSum + curNum, curNum)\\n                    recurse(i + 1, [*curExpr, \\'-\\', str(curNum)], curSum - curNum, -curNum)\\n                    \\n                    prevSum = curSum - prevNum\\n                    recurse(i + 1, [*curExpr, \\'*\\', str(curNum)], \\n                            prevSum + curNum * prevNum, curNum * prevNum)\\n                \\n                if num[curIdx] == \\'0\\':\\n                    break\\n        \\n        recurse()\\n        return res",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "This problem involves some basic recursion however the challenge arises from following order of operations. For instance, take the following expression: `4 + 2 * 5`. The way our program would calculate without following order of ops would be: `4 + 2 * 5 = 6 * 5 = 30` which is obviously wrong. \\n\\nWhat we need to do when we see a multiplication is reverse our previous operation and then do the multiplication. For instance, `4 + 2 * 5 => 6 * 5 => (6 - 2) + 2 * 5 = 14`. What we did is keep track of the previous number that would help us reverse the previous operation. When we subtract that number from the current result, we get the value of the previous expression and then we can simply add the product. \\n\\nIn the above example, at the multiplication step, the previous value was `2`. When `2` was subtracted from the current sum of `6`, we got our previous sum of `4` to which we could add `2 * 5`. If the expression to evaluate were instead `4 - 2 * 5`, we would store `-2` as our previous value as that would allow us to reverse the subtraction: `4 - 2 * 5 => 2 * 5 => (2 - -2) + -2 * 5 = -6`.\\n\\nIf the expression were `4 * 2 * 5`, we would just store the current number times the previous number: `4 * 2 * 5 = 8 * 5 = 40`.\\n\\nTo skip leading zeroes, we check if the first digit at the current index is a 0 and if so, we can stop after the first iteration of the loop.\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        res = []\\n        \\n        def recurse(curIdx=0, curExpr=[], curSum=0, prevNum=0):\\n            if curIdx >= len(num):\\n                if curSum == target:\\n                    res.append(\\'\\'.join(curExpr))\\n                return\\n            \\n            for i in range(curIdx, len(num)):\\n                curNum = int(num[curIdx:i+1])\\n                if not curExpr:\\n                    recurse(i + 1, [str(curNum)], curNum, curNum)\\n                else:\\n                    recurse(i + 1, [*curExpr, \\'+\\', str(curNum)], curSum + curNum, curNum)\\n                    recurse(i + 1, [*curExpr, \\'-\\', str(curNum)], curSum - curNum, -curNum)\\n                    \\n                    prevSum = curSum - prevNum\\n                    recurse(i + 1, [*curExpr, \\'*\\', str(curNum)], \\n                            prevSum + curNum * prevNum, curNum * prevNum)\\n                \\n                if num[curIdx] == \\'0\\':\\n                    break\\n        \\n        recurse()\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1621590,
                "title": "python-backtracking",
                "content": "* at every digit, we have an option of either adding it to the prev no, or use it with some operand\\n* in total we have 4 different operations which we have to accomplish, +, - , * and adding cur digit to prev digit\\n```\\n def addOperators(self, num: \\'str\\', target: \\'int\\') -> \\'List[str]\\':\\n        N = len(num)\\n        answers = []\\n        def recurse(idx, prev, cur, value, path):\\n            if idx == N:\\n                if value == target and cur == 0:\\n                    answers.append(\"\".join(path[1:]))\\n                return\\n            cur = cur*10 + int(num[idx])\\n            str_op = str(cur)\\n            if cur > 0:\\n\\t\\t\\t\\t# Add nothing to path, since added digit to cur\\n                recurse(idx + 1, prev, cur, value, path)\\n\\t\\t\\t# Perform addition \\n            recurse(idx + 1, cur, 0, value + cur, path +[\"+\", str_op])\\n\\t\\t\\t# can only perform subtraction, multiplication when our path not empty\\n            if path:\\n\\t\\t\\t\\t# Perform subtraction \\n                recurse(idx + 1, -cur, 0, value - cur, path +[\\'-\\', str_op])\\n\\t\\t\\t\\t# Perform multiplication\\n                recurse(idx + 1, cur * prev, 0, value - prev + (cur * prev), path +[\\'*\\', str_op])\\n                \\n        recurse(0, 0, 0, 0, [])    \\n        return answers\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\n def addOperators(self, num: \\'str\\', target: \\'int\\') -> \\'List[str]\\':\\n        N = len(num)\\n        answers = []\\n        def recurse(idx, prev, cur, value, path):\\n            if idx == N:\\n                if value == target and cur == 0:\\n                    answers.append(\"\".join(path[1:]))\\n                return\\n            cur = cur*10 + int(num[idx])\\n            str_op = str(cur)\\n            if cur > 0:\\n\\t\\t\\t\\t# Add nothing to path, since added digit to cur\\n                recurse(idx + 1, prev, cur, value, path)\\n\\t\\t\\t# Perform addition \\n            recurse(idx + 1, cur, 0, value + cur, path +[\"+\", str_op])\\n\\t\\t\\t# can only perform subtraction, multiplication when our path not empty\\n            if path:\\n\\t\\t\\t\\t# Perform subtraction \\n                recurse(idx + 1, -cur, 0, value - cur, path +[\\'-\\', str_op])\\n\\t\\t\\t\\t# Perform multiplication\\n                recurse(idx + 1, cur * prev, 0, value - prev + (cur * prev), path +[\\'*\\', str_op])\\n                \\n        recurse(0, 0, 0, 0, [])    \\n        return answers\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1611458,
                "title": "javascript-clean-concise-code-backtracking",
                "content": "```\\nvar addOperators = function(num, target) {\\n    let ans = [];\\n    \\n    const backtracking = (index, left, right, string) => {\\n        if (index === num.length) {\\n            if (left + right === target)\\n                ans.push(string); \\n            return;\\n        }\\n\\n        let val = 0;\\n        for (let i = index; i < num.length; i++) {\\n            val = val * 10 + Number(num[i]);\\n            backtracking(i + 1, left + right, val, string + \"+\" + val);\\n            backtracking(i + 1, left + right, -val, string + \"-\" + val);\\n            backtracking(i + 1, left, right * val, string + \"*\" + val);\\n            if (num[index] === \"0\")\\n                break;\\n        }  \\n    };\\n\\n    let val = 0;\\n    for (let i = 0; i < num.length; i++) {\\n        val = val * 10 + Number(num[i]);\\n        backtracking(i + 1, 0, val, val.toString());\\n        if (num[0] === \"0\")\\n            break;\\n    }\\n    \\n    return ans;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar addOperators = function(num, target) {\\n    let ans = [];\\n    \\n    const backtracking = (index, left, right, string) => {\\n        if (index === num.length) {\\n            if (left + right === target)\\n                ans.push(string); \\n            return;\\n        }\\n\\n        let val = 0;\\n        for (let i = index; i < num.length; i++) {\\n            val = val * 10 + Number(num[i]);\\n            backtracking(i + 1, left + right, val, string + \"+\" + val);\\n            backtracking(i + 1, left + right, -val, string + \"-\" + val);\\n            backtracking(i + 1, left, right * val, string + \"*\" + val);\\n            if (num[index] === \"0\")\\n                break;\\n        }  \\n    };\\n\\n    let val = 0;\\n    for (let i = 0; i < num.length; i++) {\\n        val = val * 10 + Number(num[i]);\\n        backtracking(i + 1, 0, val, val.toString());\\n        if (num[0] === \"0\")\\n            break;\\n    }\\n    \\n    return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1596238,
                "title": "clean-commented-dfs-python-beats-98-time-78-memory",
                "content": "# Initially\\n0th index, prev is 0, val is 0 and expression string is empty\\nAt each step:-\\n## Addition\\ncur become prev, \\nadd cur to sum, \\nadd info to expression\\n## Subtraction\\n-cur become prev,\\nsubtract cur from sum,\\nadd info to expression \\n## Multiplication\\ncur\\\\*prev becomes prev,\\nsubtract prev from sum(to undo what was done by adding prev) & add cur*prev,\\nadd info to expression \\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        ans = []\\n        \\n        def dfs(start,prev_operand,expr_val,expr_str):\\n            if start==n:\\n                if expr_val==target:\\n                    ans.append(expr_str[1:]) # remove + sign at start\\n                return\\n            \\n            # To handle leading zeros condition\\n            endPtr = n+1 if num[start]!=\\'0\\' else start+2\\n            \\n            for end in range(start+1,endPtr):\\n                cur_operand_str = num[start:end]\\n                cur_operand = int(cur_operand_str)\\n                dfs(end,cur_operand,expr_val+cur_operand,expr_str+\\'+\\'+cur_operand_str) # addition\\n                if expr_str: # sub & mult only possible if previous operand\\n                    dfs(end,-cur_operand,expr_val-cur_operand,expr_str+\\'-\\'+cur_operand_str) # subtraction\\n                    product = cur_operand*prev_operand\\n                    dfs(end,product,expr_val-prev_operand+product, expr_str+\\'*\\'+cur_operand_str) # multiplication\\n        \\n        dfs(0,0,0,\\'\\' )\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        n = len(num)\\n        ans = []\\n        \\n        def dfs(start,prev_operand,expr_val,expr_str):\\n            if start==n:\\n                if expr_val==target:\\n                    ans.append(expr_str[1:]) # remove + sign at start\\n                return\\n            \\n            # To handle leading zeros condition\\n            endPtr = n+1 if num[start]!=\\'0\\' else start+2\\n            \\n            for end in range(start+1,endPtr):\\n                cur_operand_str = num[start:end]\\n                cur_operand = int(cur_operand_str)\\n                dfs(end,cur_operand,expr_val+cur_operand,expr_str+\\'+\\'+cur_operand_str) # addition\\n                if expr_str: # sub & mult only possible if previous operand\\n                    dfs(end,-cur_operand,expr_val-cur_operand,expr_str+\\'-\\'+cur_operand_str) # subtraction\\n                    product = cur_operand*prev_operand\\n                    dfs(end,product,expr_val-prev_operand+product, expr_str+\\'*\\'+cur_operand_str) # multiplication\\n        \\n        dfs(0,0,0,\\'\\' )\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579560,
                "title": "simple-c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<string> &ans,string currstr,string input,int t,int pos,long long currval,long long last)\\n    {\\n        if(pos==input.length())\\n        {\\n            if(currval==t)\\n                ans.push_back(currstr);\\n            return;\\n        }\\n        for(int i=pos;i<input.length();i++)\\n        {\\n            if(pos!=i && input[pos]==\\'0\\')\\n                break;\\n            string part=input.substr(pos,i+1-pos);\\n            long long curr=stoll(part);\\n            if(pos==0)\\n            {\\n                solve(ans,currstr+part,input,t,i+1,curr,curr);\\n            }\\n            else\\n            {\\n                solve(ans,currstr+\"+\"+part,input,t,i+1,currval+curr,curr);\\n                solve(ans,currstr+\"-\"+part,input,t,i+1,currval-curr,-curr);\\n                solve(ans,currstr+\"*\"+part,input,t,i+1,currval-last+last*curr,last*curr);\\n            }\\n        }\\n    }\\n    vector<string> addOperators(string num, int t) {\\n        vector<string> ans;\\n        solve(ans,\"\",num,t,0,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<string> &ans,string currstr,string input,int t,int pos,long long currval,long long last)\\n    {\\n        if(pos==input.length())\\n        {\\n            if(currval==t)\\n                ans.push_back(currstr);\\n            return;\\n        }\\n        for(int i=pos;i<input.length();i++)\\n        {\\n            if(pos!=i && input[pos]==\\'0\\')\\n                break;\\n            string part=input.substr(pos,i+1-pos);\\n            long long curr=stoll(part);\\n            if(pos==0)\\n            {\\n                solve(ans,currstr+part,input,t,i+1,curr,curr);\\n            }\\n            else\\n            {\\n                solve(ans,currstr+\"+\"+part,input,t,i+1,currval+curr,curr);\\n                solve(ans,currstr+\"-\"+part,input,t,i+1,currval-curr,-curr);\\n                solve(ans,currstr+\"*\"+part,input,t,i+1,currval-last+last*curr,last*curr);\\n            }\\n        }\\n    }\\n    vector<string> addOperators(string num, int t) {\\n        vector<string> ans;\\n        solve(ans,\"\",num,t,0,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553905,
                "title": "c-dfs-easy-to-understand",
                "content": "Got the idea for calculating the value on the fly from \\nhttps://leetcode.com/problems/expression-add-operators/discuss/441680/Accepted-C-backtracking-solution%3A-Easy-to-understand-w-comments-fast-93.14-memory-100\\n\\n```\\npublic class Solution \\n{\\n    List<char> ops;\\n    IList<string> lst;\\n    \\n    public IList<string> AddOperators(string num, int target) \\n    {\\n        ops = new List<char>();\\n        lst = new List<string>();\\n        ops.Add(\\'+\\');\\n        ops.Add(\\'-\\');\\n        ops.Add(\\'*\\');\\n        dfs(num, 0, \"\", 0, 0, target);\\n        return lst;\\n    }\\n    \\n    public void dfs(string s, int index, string calc, long prev, long sofar, int target)\\n    {\\n        if(index == s.Length)\\n        {\\n            if(sofar == target)\\n                lst.Add(calc);\\n            \\n            return;\\n        }\\n        \\n        int count = 1;\\n        for(int i = index; i < s.Length; i++)\\n        {\\n            var nextindex = index + count;\\n            var cur = s.Substring(index, count);\\n            \\n            if(cur.Length > 1 && cur[0] == \\'0\\')\\n                continue;\\n            \\n            var curnum = Convert.ToInt64(cur);\\n            \\n            if(index == 0)\\n            {\\n                dfs(s, nextindex, cur, curnum, curnum, target);\\n            }\\n            else\\n            {\\n                foreach(var op in ops)\\n                {\\n                    if(op == \\'*\\')\\n                        dfs(s, nextindex, calc + \"*\" + cur, curnum*prev, ((sofar - prev) + prev * curnum), target);\\n                    else if(op == \\'+\\')\\n                        dfs(s, nextindex, calc + \"+\" + cur, curnum, sofar + curnum, target);\\n                    else if(op == \\'-\\')\\n                        dfs(s, nextindex, calc + \"-\" + cur, -curnum, sofar - curnum, target);\\n                } \\n            }\\n            \\n            count++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    List<char> ops;\\n    IList<string> lst;\\n    \\n    public IList<string> AddOperators(string num, int target) \\n    {\\n        ops = new List<char>();\\n        lst = new List<string>();\\n        ops.Add(\\'+\\');\\n        ops.Add(\\'-\\');\\n        ops.Add(\\'*\\');\\n        dfs(num, 0, \"\", 0, 0, target);\\n        return lst;\\n    }\\n    \\n    public void dfs(string s, int index, string calc, long prev, long sofar, int target)\\n    {\\n        if(index == s.Length)\\n        {\\n            if(sofar == target)\\n                lst.Add(calc);\\n            \\n            return;\\n        }\\n        \\n        int count = 1;\\n        for(int i = index; i < s.Length; i++)\\n        {\\n            var nextindex = index + count;\\n            var cur = s.Substring(index, count);\\n            \\n            if(cur.Length > 1 && cur[0] == \\'0\\')\\n                continue;\\n            \\n            var curnum = Convert.ToInt64(cur);\\n            \\n            if(index == 0)\\n            {\\n                dfs(s, nextindex, cur, curnum, curnum, target);\\n            }\\n            else\\n            {\\n                foreach(var op in ops)\\n                {\\n                    if(op == \\'*\\')\\n                        dfs(s, nextindex, calc + \"*\" + cur, curnum*prev, ((sofar - prev) + prev * curnum), target);\\n                    else if(op == \\'+\\')\\n                        dfs(s, nextindex, calc + \"+\" + cur, curnum, sofar + curnum, target);\\n                    else if(op == \\'-\\')\\n                        dfs(s, nextindex, calc + \"-\" + cur, -curnum, sofar - curnum, target);\\n                } \\n            }\\n            \\n            count++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539532,
                "title": "python-using-eval",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n    \\n        def backtrack(index,stack):\\n            \\n            if index == len(num)-1:\\n                stack.append(num[index])\\n                expres = \"\".join(stack[:])\\n                if eval(expres) == target:\\n                    out.append(expres)\\n                return\\n            \\n            leadZero = False\\n            \\n            if not (stack and stack[-1].isdigit()) and num[index] == \\'0\\':\\n                \\n                leadZero = True\\n                \\n            stack.append(num[index])\\n            \\n            for op in [\"+\",\"-\",\"*\"]:\\n                stack.append(op)  \\n                backtrack(index+1,stack[:])\\n                stack.pop()\\n            \\n            if not leadZero:\\n                \\n                backtrack(index+1,stack[:])\\n        \\n        out = []\\n        \\n        backtrack(0,[])\\n        \\n        return out\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n    \\n        def backtrack(index,stack):\\n            \\n            if index == len(num)-1:\\n                stack.append(num[index])\\n                expres = \"\".join(stack[:])\\n                if eval(expres) == target:\\n                    out.append(expres)\\n                return\\n            \\n            leadZero = False\\n            \\n            if not (stack and stack[-1].isdigit()) and num[index] == \\'0\\':\\n                \\n                leadZero = True\\n                \\n            stack.append(num[index])\\n            \\n            for op in [\"+\",\"-\",\"*\"]:\\n                stack.append(op)  \\n                backtrack(index+1,stack[:])\\n                stack.pop()\\n            \\n            if not leadZero:\\n                \\n                backtrack(index+1,stack[:])\\n        \\n        out = []\\n        \\n        backtrack(0,[])\\n        \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498795,
                "title": "js-simple-dfs",
                "content": "```\\nvar addOperators = function(num, target) {\\n    const res = [];\\n    \\n    const dfs = (pos, exp, result, prevNum) => {\\n        \\n        if(pos >= num.length) {\\n            if (result == target) {\\n                res.push(exp);\\n            }\\n            return;\\n        }\\n        for(let i=pos;i<num.length;i++) {\\n            if (i > pos &&  num[pos] == \\'0\\') break;\\n            const n = parseInt(num.substring(pos, i+1));\\n            if (pos == 0) {\\n                dfs(i+1, n+\"\", n, n);\\n            } else {\\n                dfs(i+1, exp+\\'+\\'+n, result+n, n);\\n                dfs(i+1, exp+\\'-\\'+n, result-n, -n);\\n                dfs(i+1, exp+\\'*\\'+n, result-prevNum+prevNum *n  , prevNum * n);\\n                \\n            }\\n        }\\n    }\\n    \\n    dfs(0, \\'\\', 0, 0);\\n       \\n    return res;\\n      \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar addOperators = function(num, target) {\\n    const res = [];\\n    \\n    const dfs = (pos, exp, result, prevNum) => {\\n        \\n        if(pos >= num.length) {\\n            if (result == target) {\\n                res.push(exp);\\n            }\\n            return;\\n        }\\n        for(let i=pos;i<num.length;i++) {\\n            if (i > pos &&  num[pos] == \\'0\\') break;\\n            const n = parseInt(num.substring(pos, i+1));\\n            if (pos == 0) {\\n                dfs(i+1, n+\"\", n, n);\\n            } else {\\n                dfs(i+1, exp+\\'+\\'+n, result+n, n);\\n                dfs(i+1, exp+\\'-\\'+n, result-n, -n);\\n                dfs(i+1, exp+\\'*\\'+n, result-prevNum+prevNum *n  , prevNum * n);\\n                \\n            }\\n        }\\n    }\\n    \\n    dfs(0, \\'\\', 0, 0);\\n       \\n    return res;\\n      \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1479596,
                "title": "javascript-dfs-116ms-89-74",
                "content": "```\\nlet s, n, t;\\nconst addOperators = (num, target) => {\\n    s = num, n = s.length, t = target;\\n    let res = [];\\n    dfs(0, \\'\\', 0, 0, res);\\n    return res;\\n};\\n\\nconst dfs = (pos, exp, pre, cur, res) => {\\n    if (pos == n) {\\n        if (cur == t) return res.push(exp);\\n    }\\n    for (let i = 1; i <= n - pos; i++) {\\n        let tmp = s.substr(pos, i);\\n        if (tmp[0] == \\'0\\' && tmp.length > 1) break;\\n        let x = tmp - \\'0\\';\\n        if (pos == 0) {\\n            dfs(i, tmp, x, x, res);\\n            continue;\\n        }\\n        dfs(pos + i, exp + \\'+\\' + tmp, x, cur + x, res);\\n        dfs(pos + i, exp + \\'-\\' + tmp, -x, cur - x, res);\\n        dfs(pos + i, exp + \\'*\\' + tmp, pre * x, cur - pre + pre * x, res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nlet s, n, t;\\nconst addOperators = (num, target) => {\\n    s = num, n = s.length, t = target;\\n    let res = [];\\n    dfs(0, \\'\\', 0, 0, res);\\n    return res;\\n};\\n\\nconst dfs = (pos, exp, pre, cur, res) => {\\n    if (pos == n) {\\n        if (cur == t) return res.push(exp);\\n    }\\n    for (let i = 1; i <= n - pos; i++) {\\n        let tmp = s.substr(pos, i);\\n        if (tmp[0] == \\'0\\' && tmp.length > 1) break;\\n        let x = tmp - \\'0\\';\\n        if (pos == 0) {\\n            dfs(i, tmp, x, x, res);\\n            continue;\\n        }\\n        dfs(pos + i, exp + \\'+\\' + tmp, x, cur + x, res);\\n        dfs(pos + i, exp + \\'-\\' + tmp, -x, cur - x, res);\\n        dfs(pos + i, exp + \\'*\\' + tmp, pre * x, cur - pre + pre * x, res);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1479092,
                "title": "python-iterative-solution-beats-96",
                "content": "There are plenty of recursive solutions, but I found an iterative approach to be quite intuitive as well.\\n\\n1. Iterate over each digit\\n2. Maintain a list of all possible states from the previous digit\\n3. Create a list of all possible states after using this digit\\n\\t4. Concatenate the digits together (\"...12\")\\n\\t5. Addition (\"...1+2\")\\n\\t6. Subtraction (\"...1-2\")\\n\\t7. Multiplication (\"...1*2)\\n\\nOur state has 4 components\\n\\n1. Digits since the last operation (123 in \"9-99+123...\" or -123 in \"9-99-123...\")\\n2. Multiplier since the last +/- (value 6 in \"9-99+1\\\\*2\\\\*3...\")\\n3. Sum up to the previous +/- (value -90 in \"9-99+1\\\\*2\\\\*3...\")\\n4. String representation (\"9-99+123\")\\n\\nFor some reason this solution exceeds the time limit with C++, but beats 96% with Python. I guess recursion is just that inefficient with Python?\\n\\n```py\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        # digits since last +/-/*, multiplier, sum up to previous +/-, string representation\\n        states = [(int(num[0]), 1, 0, num[0])]\\n        \\n        for d in num[1:]:\\n            d = int(d)\\n            next_states = []\\n            \\n            for last_digits, multiplier, sum_before, s in states:\\n                # concatenate with last_digits\\n                if last_digits > 0:\\n                    next_states.append((last_digits*10+d, multiplier, sum_before, f\"{s}{d}\"))\\n                elif last_digits < 0:\\n                    next_states.append((last_digits*10-d, multiplier, sum_before, f\"{s}{d}\"))\\n\\t\\t\\t\\t# ignore 0 to avoid leading zeros\\n                    \\n                # addition sign\\n                next_states.append((d, 1, sum_before+last_digits*multiplier, f\"{s}+{d}\"))\\n                # subtraction sign\\n                next_states.append((-d, 1, sum_before+last_digits*multiplier, f\"{s}-{d}\"))\\n                # multiplication sign\\n                next_states.append((d, last_digits*multiplier, sum_before, f\"{s}*{d}\"))\\n                \\n            states = next_states\\n\\n        result = []\\n        for last_digits, multiplier, sum_before, s in states:\\n            val = sum_before + multiplier * last_digits\\n            if val == target:\\n                result.append(s)\\n\\n        return result\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        # digits since last +/-/*, multiplier, sum up to previous +/-, string representation\\n        states = [(int(num[0]), 1, 0, num[0])]\\n        \\n        for d in num[1:]:\\n            d = int(d)\\n            next_states = []\\n            \\n            for last_digits, multiplier, sum_before, s in states:\\n                # concatenate with last_digits\\n                if last_digits > 0:\\n                    next_states.append((last_digits*10+d, multiplier, sum_before, f\"{s}{d}\"))\\n                elif last_digits < 0:\\n                    next_states.append((last_digits*10-d, multiplier, sum_before, f\"{s}{d}\"))\\n\\t\\t\\t\\t# ignore 0 to avoid leading zeros\\n                    \\n                # addition sign\\n                next_states.append((d, 1, sum_before+last_digits*multiplier, f\"{s}+{d}\"))\\n                # subtraction sign\\n                next_states.append((-d, 1, sum_before+last_digits*multiplier, f\"{s}-{d}\"))\\n                # multiplication sign\\n                next_states.append((d, last_digits*multiplier, sum_before, f\"{s}*{d}\"))\\n                \\n            states = next_states\\n\\n        result = []\\n        for last_digits, multiplier, sum_before, s in states:\\n            val = sum_before + multiplier * last_digits\\n            if val == target:\\n                result.append(s)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1475043,
                "title": "c-282-expression-add-operators",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        int n = num.size(); \\n        vector<string> ans; \\n        \\n        function<void(int, long, long, string)> fn = [&](int i, long total, long last, string expr) {\\n            if (i == n) {\\n                if (total == target) ans.push_back(expr); \\n            } else {\\n                for (int ii = i; ii < (num[i] == \\'0\\' ? i+1 : n); ++ii) {\\n                    string ss = num.substr(i, ii-i+1); \\n                    long val = stol(ss); \\n                    if (i == 0) fn(ii+1, val, val, ss); \\n                    else {\\n                        fn(ii+1, total - last + last * val, last * val, expr + \"*\" + ss); \\n                        fn(ii+1, total + val, val, expr + \"+\" + ss); \\n                        fn(ii+1, total - val, -val, expr + \"-\" + ss); \\n                    }\\n                }\\n            }\\n        }; \\n        \\n        fn(0, 0, 0, \"\"); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        int n = num.size(); \\n        vector<string> ans; \\n        \\n        function<void(int, long, long, string)> fn = [&](int i, long total, long last, string expr) {\\n            if (i == n) {\\n                if (total == target) ans.push_back(expr); \\n            } else {\\n                for (int ii = i; ii < (num[i] == \\'0\\' ? i+1 : n); ++ii) {\\n                    string ss = num.substr(i, ii-i+1); \\n                    long val = stol(ss); \\n                    if (i == 0) fn(ii+1, val, val, ss); \\n                    else {\\n                        fn(ii+1, total - last + last * val, last * val, expr + \"*\" + ss); \\n                        fn(ii+1, total + val, val, expr + \"+\" + ss); \\n                        fn(ii+1, total - val, -val, expr + \"-\" + ss); \\n                    }\\n                }\\n            }\\n        }; \\n        \\n        fn(0, 0, 0, \"\"); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1474313,
                "title": "python3-recursion",
                "content": "```\\nclass Solution:\\n    \\n    def solve(self, i, cur):\\n        if i == self.n:\\n            if eval(cur) == self.v:\\n                self.ans.append(cur)\\n            return\\n        if self.s[i] == \\'0\\':    # No leading zeros\\n            if i == self.n-1:\\n                self.solve(i+1, cur + \"0\")\\n            else:\\n                self.solve(i+1, cur + \"0*\")\\n                self.solve(i+1, cur + \"0+\")\\n                self.solve(i+1, cur + \"0-\")\\n            return\\n        s = \"\"\\n        for j in range(i, self.n - 1):\\n            s += self.s[j]\\n            self.solve(j+1, cur + s + \"*\")\\n            self.solve(j+1, cur + s + \"+\")\\n            self.solve(j+1, cur + s + \"-\")\\n        if self.s[i] != \\'0\\':\\n            self.solve(self.n, cur + self.s[i:])\\n        \\n    def addOperators(self, s: str, v: int) -> List[str]:\\n        self.v = v\\n        self.s = s\\n        self.n = len(s)\\n        self.ans = []\\n        self.solve(0, \"\")\\n        # print(self.ans)\\n        return self.ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def solve(self, i, cur):\\n        if i == self.n:\\n            if eval(cur) == self.v:\\n                self.ans.append(cur)\\n            return\\n        if self.s[i] == \\'0\\':    # No leading zeros\\n            if i == self.n-1:\\n                self.solve(i+1, cur + \"0\")\\n            else:\\n                self.solve(i+1, cur + \"0*\")\\n                self.solve(i+1, cur + \"0+\")\\n                self.solve(i+1, cur + \"0-\")\\n            return\\n        s = \"\"\\n        for j in range(i, self.n - 1):\\n            s += self.s[j]\\n            self.solve(j+1, cur + s + \"*\")\\n            self.solve(j+1, cur + s + \"+\")\\n            self.solve(j+1, cur + s + \"-\")\\n        if self.s[i] != \\'0\\':\\n            self.solve(self.n, cur + self.s[i:])\\n        \\n    def addOperators(self, s: str, v: int) -> List[str]:\\n        self.v = v\\n        self.s = s\\n        self.n = len(s)\\n        self.ans = []\\n        self.solve(0, \"\")\\n        # print(self.ans)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1473865,
                "title": "java-easy-to-understand-solution-with-comments",
                "content": "Tried to explain all the cases and situations, let me know if anything is unclear or wrong. Hope it helps! :) \\n\\n```\\nclass Solution {\\n    String num;\\n    int len;\\n    List<String> ans;\\n    int target;\\n    \\n    public void dfs_helper(String build, long prev_no, long total, int pos){\\n        if(pos == len)\\n        {\\n            if(total == target)\\n                ans.add(build);\\n            return;\\n        }\\n        for(int i = pos;i<len;i++)\\n        {\\n            if(i>pos && num.charAt(pos) == \\'0\\')\\n                break; // needed to avoid cases like 00* (leading 0\\'s)\\n            // if you dont do this lets take an example\\n            // 105\\n            // 1 is added, string build = 1 and then we are at 0, i.e, pos == 1\\n            // if we go to i = 2 for pos and implement without this\\n            // we will get 1*5 as an answer which is wrong, as curr_num will be parsed as 5!\\n            // \"05\" will be 5!\\n            long curr_num = Long.parseLong(num.substring(pos,i+1)); // get the number\\n            if(pos == 0)\\n            {\\n                // have to add the 1st number to start the recursion.\\n                String to_send = build+curr_num;\\n                dfs_helper(to_send,curr_num,curr_num,i+1);\\n            }\\n            else\\n            {\\n                String to_send = build+\"+\"+curr_num;\\n                long t = total+curr_num;\\n                dfs_helper(to_send,curr_num,t,i+1);\\n                \\n                to_send = build+\"-\"+curr_num;\\n                t = total-curr_num;\\n                dfs_helper(to_send,(-1)*curr_num,t,i+1);\\n                // add and subtract are simple cases\\n                to_send = build+\"*\"+curr_num;\\n                t = total-prev_no+prev_no*curr_num;\\n                dfs_helper(to_send,curr_num*prev_no,t,i+1);\\n                // this is a tricky one lets say you have 1+2*3-5\\n                // if you do 2*3 then effective current number is 6 (consider it as 6 and pass it on)\\n                // to calculate the value now (total val) undo the effect of previous op by total-prev_no\\n                // and add the new evaluated val [prev_no*curr_num]\\n            }\\n        }\\n    }\\n    \\n    public List<String> addOperators(String num, int target) {\\n        /**\\n        Inputs that are req. for rec fn:\\n        a) string so far: 1+2*3\\n        b) prev number: 1+2*3 ==> prev number for next call from 3 will be 3\\n        c) value till that point: 1+2*3 ==> val till that point will be 7 [long]\\n        d) return list which will have the final output [make this global]\\n        e) postion pointer\\n        f) target to compare [make this global]\\n        g) length of total num string [make this global]\\n        h) the num string [make this global]\\n        */\\n        this.ans = new ArrayList<> ();\\n        this.len = num.length();\\n        this.target = target;\\n        this.num = num;\\n        dfs_helper(\"\",0,0,0);\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    String num;\\n    int len;\\n    List<String> ans;\\n    int target;\\n    \\n    public void dfs_helper(String build, long prev_no, long total, int pos){\\n        if(pos == len)\\n        {\\n            if(total == target)\\n                ans.add(build);\\n            return;\\n        }\\n        for(int i = pos;i<len;i++)\\n        {\\n            if(i>pos && num.charAt(pos) == \\'0\\')\\n                break; // needed to avoid cases like 00* (leading 0\\'s)\\n            // if you dont do this lets take an example\\n            // 105\\n            // 1 is added, string build = 1 and then we are at 0, i.e, pos == 1\\n            // if we go to i = 2 for pos and implement without this\\n            // we will get 1*5 as an answer which is wrong, as curr_num will be parsed as 5!\\n            // \"05\" will be 5!\\n            long curr_num = Long.parseLong(num.substring(pos,i+1)); // get the number\\n            if(pos == 0)\\n            {\\n                // have to add the 1st number to start the recursion.\\n                String to_send = build+curr_num;\\n                dfs_helper(to_send,curr_num,curr_num,i+1);\\n            }\\n            else\\n            {\\n                String to_send = build+\"+\"+curr_num;\\n                long t = total+curr_num;\\n                dfs_helper(to_send,curr_num,t,i+1);\\n                \\n                to_send = build+\"-\"+curr_num;\\n                t = total-curr_num;\\n                dfs_helper(to_send,(-1)*curr_num,t,i+1);\\n                // add and subtract are simple cases\\n                to_send = build+\"*\"+curr_num;\\n                t = total-prev_no+prev_no*curr_num;\\n                dfs_helper(to_send,curr_num*prev_no,t,i+1);\\n                // this is a tricky one lets say you have 1+2*3-5\\n                // if you do 2*3 then effective current number is 6 (consider it as 6 and pass it on)\\n                // to calculate the value now (total val) undo the effect of previous op by total-prev_no\\n                // and add the new evaluated val [prev_no*curr_num]\\n            }\\n        }\\n    }\\n    \\n    public List<String> addOperators(String num, int target) {\\n        /**\\n        Inputs that are req. for rec fn:\\n        a) string so far: 1+2*3\\n        b) prev number: 1+2*3 ==> prev number for next call from 3 will be 3\\n        c) value till that point: 1+2*3 ==> val till that point will be 7 [long]\\n        d) return list which will have the final output [make this global]\\n        e) postion pointer\\n        f) target to compare [make this global]\\n        g) length of total num string [make this global]\\n        h) the num string [make this global]\\n        */\\n        this.ans = new ArrayList<> ();\\n        this.len = num.length();\\n        this.target = target;\\n        this.num = num;\\n        dfs_helper(\"\",0,0,0);\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472505,
                "title": "easy-to-understand",
                "content": "If the operands were only single digits then it would be so much easier!\\n*But they aren\\'t*\\nOkay, then what if we already knew what the operands would be? Then we would only have to check for the 3 possible operators between every 2 operands which would be 3^(number of operands-1)\\n*How to get these pre-decided operands then..*\\nBit-Manipulation to the rescue:-\\n\\tWe only have to divide num into all possible operands and for each of these divisions check all the possible expressions it makes.\\n```\\nFinding all possible operand divisions from num and store them in a list -> 2^(length of num-1){\\n\\tchecking all the expressions these operands make -> 3^(size of the list of operands-1)\\n}\\nI dont know how to find the exact complexity but it would be something like ->\\n2^(length(num)-1) * 3^(m) where m ranges from [0,length(num)-1]\\n```\\n\\nJava Implementation : \\n```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        int n = num.length()-1;\\n        t = target;\\n        list = new ArrayList<>();\\n        outer : for(int i=0;i<(1<<n);i++){\\n            List<Long> arr = new ArrayList<>();\\n            long cur = num.charAt(0)-\\'0\\';\\n            for(int j=0;j<n;j++){\\n                if((i&(1<<j))!=0){\\n                    arr.add(cur);\\n                    cur = num.charAt(j+1)-\\'0\\';\\n                }   \\n                else{\\n                    if(cur==0) continue outer;\\n                    cur = cur*10 + (num.charAt(j+1)-\\'0\\');\\n                }\\n            }\\n            arr.add(cur);\\n            rec(arr.get(0),1,arr.get(0),arr.size(),\"\"+arr.get(0),0,arr);\\n        }\\n        return list;\\n    }\\n    \\n    public void rec(long eval, int i, long prev, int n, String exp, int type, List<Long> num){\\n        if(i==n){\\n            if(eval==t) list.add(exp);\\n            return;\\n        }\\n        long cur = num.get(i);\\n        rec(eval+cur,i+1,cur,n,exp+(\"+\"+cur),0,num);\\n        rec(eval-cur,i+1,cur,n,exp+(\"-\"+cur),1,num);\\n        if(type==0) rec(eval-prev+prev*cur,i+1,prev*cur,n,exp+(\"*\"+cur),0,num);\\n        else rec(eval+prev-prev*cur,i+1,prev*cur,n,exp+(\"*\"+cur),1,num); \\n    }\\n    \\n    public List<String> list;\\n    public int t;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nFinding all possible operand divisions from num and store them in a list -> 2^(length of num-1){\\n\\tchecking all the expressions these operands make -> 3^(size of the list of operands-1)\\n}\\nI dont know how to find the exact complexity but it would be something like ->\\n2^(length(num)-1) * 3^(m) where m ranges from [0,length(num)-1]\\n```\n```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        int n = num.length()-1;\\n        t = target;\\n        list = new ArrayList<>();\\n        outer : for(int i=0;i<(1<<n);i++){\\n            List<Long> arr = new ArrayList<>();\\n            long cur = num.charAt(0)-\\'0\\';\\n            for(int j=0;j<n;j++){\\n                if((i&(1<<j))!=0){\\n                    arr.add(cur);\\n                    cur = num.charAt(j+1)-\\'0\\';\\n                }   \\n                else{\\n                    if(cur==0) continue outer;\\n                    cur = cur*10 + (num.charAt(j+1)-\\'0\\');\\n                }\\n            }\\n            arr.add(cur);\\n            rec(arr.get(0),1,arr.get(0),arr.size(),\"\"+arr.get(0),0,arr);\\n        }\\n        return list;\\n    }\\n    \\n    public void rec(long eval, int i, long prev, int n, String exp, int type, List<Long> num){\\n        if(i==n){\\n            if(eval==t) list.add(exp);\\n            return;\\n        }\\n        long cur = num.get(i);\\n        rec(eval+cur,i+1,cur,n,exp+(\"+\"+cur),0,num);\\n        rec(eval-cur,i+1,cur,n,exp+(\"-\"+cur),1,num);\\n        if(type==0) rec(eval-prev+prev*cur,i+1,prev*cur,n,exp+(\"*\"+cur),0,num);\\n        else rec(eval+prev-prev*cur,i+1,prev*cur,n,exp+(\"*\"+cur),1,num); \\n    }\\n    \\n    public List<String> list;\\n    public int t;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472173,
                "title": "c-dfs-backtracking",
                "content": "```\\nclass Solution {\\n    private:vector<string> ans;\\npublic:\\n    void dfs(int i,string path,long ressofar,long prevno,string s,int target)\\n    {\\n        if (i==s.length())\\n        {\\n            if (ressofar==target)  ans.push_back(path);\\n            \\n            return ;\\n        }\\n        long  no=0;\\n        for (int j=i;j<s.length();j++)\\n        {\\n            if (j>i && s[i]==\\'0\\')  break;\\n            no=no*10+(s[j]-48);\\n            //cout<<no<<\\' \\';\\n            int len= j-i+1;\\n            string subpath=s.substr(i,len);\\n            if (i==0)\\n            {\\n                dfs(j+1,path+subpath,no,no,s,target);\\n            }\\n            else\\n            {\\n                dfs(j+1,path + \"+\" + subpath,ressofar+no,no,s,target);\\n                 dfs(j+1,path + \"-\" + subpath,ressofar-no,-1* no,s,target);\\n                 dfs(j+1,path + \"*\" + subpath,ressofar-prevno+prevno*no,prevno*no,s,target);\\n            }\\n            \\n        }\\n    }\\n    \\n    vector<string> addOperators(string num, int target) {\\n     \\n        dfs(0,\"\",0,0,num,target);\\n          return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    private:vector<string> ans;\\npublic:\\n    void dfs(int i,string path,long ressofar,long prevno,string s,int target)\\n    {\\n        if (i==s.length())\\n        {\\n            if (ressofar==target)  ans.push_back(path);\\n            \\n            return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1471696,
                "title": "python-clean-simple",
                "content": "```python\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        results = []\\n        n = len(num)\\n        \\n        def dfs(i: int, expression: str, value: int, last: Optional[int]):\\n            if i == n and value == target:\\n                results.append(expression)\\n            \\n            for j in range(i+1, n+1):\\n                itoj = num[i:j]\\n                curr = int(itoj)\\n                if j == i + 1 or not itoj.startswith(\\'0\\'):\\n                    if last is None:\\n                        dfs(j, itoj, curr, curr)\\n                    else:\\n                        dfs(j, f\\'{expression}+{itoj}\\', value + curr, curr)\\n                        dfs(j, f\\'{expression}-{itoj}\\', value - curr, -curr)\\n                        dfs(j, f\\'{expression}*{itoj}\\', value - last + last * curr, last * curr)\\n        \\n        dfs(0, \\'\\', 0, None)\\n        return results\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        results = []\\n        n = len(num)\\n        \\n        def dfs(i: int, expression: str, value: int, last: Optional[int]):\\n            if i == n and value == target:\\n                results.append(expression)\\n            \\n            for j in range(i+1, n+1):\\n                itoj = num[i:j]\\n                curr = int(itoj)\\n                if j == i + 1 or not itoj.startswith(\\'0\\'):\\n                    if last is None:\\n                        dfs(j, itoj, curr, curr)\\n                    else:\\n                        dfs(j, f\\'{expression}+{itoj}\\', value + curr, curr)\\n                        dfs(j, f\\'{expression}-{itoj}\\', value - curr, -curr)\\n                        dfs(j, f\\'{expression}*{itoj}\\', value - last + last * curr, last * curr)\\n        \\n        dfs(0, \\'\\', 0, None)\\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471638,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public IList<string> AddOperators(string num, int target) {\\n        \\n        List<string> res = new List<string>();\\n        if(string.IsNullOrEmpty(num))\\n            return res;\\n        \\n        dfs(num, target, 0, \"\", 0, 0, res);\\n        return res;\\n    }\\n    \\n    private void dfs(string num, int target, int idx, string expression, long expressionVal, long lastMonomial, List<string> res)\\n    {\\n        if(idx == num.Length)\\n        {\\n            if(expressionVal == target)\\n                res.Add(expression);\\n            return;\\n        }\\n        \\n        for(int i = idx; i < num.Length; i++)\\n        {\\n            string currStr = num.Substring(idx, i - idx + 1);\\n            \\n            if(currStr.Length > 1 && num[idx] == \\'0\\') break;  \\n            long currVal = long.Parse(currStr);\\n            \\n            if(idx == 0)\\n            {\\n                dfs(num, target, i + 1, expression + currStr, currVal, currVal, res);\\n            }\\n            else\\n            {\\n                // \\'+\\' and \\'-\\'\\n                dfs(num, target, i + 1, expression + \"+\" + currStr, expressionVal + currVal, currVal, res);\\n                dfs(num, target, i + 1, expression + \"-\" + currStr, expressionVal - currVal, -currVal, res);\\n\\n                // \\'*\\'\\n                dfs(num, target, i + 1, expression + \"*\" + currStr, expressionVal - lastMonomial + lastMonomial * currVal, lastMonomial* currVal, res);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> AddOperators(string num, int target) {\\n        \\n        List<string> res = new List<string>();\\n        if(string.IsNullOrEmpty(num))\\n            return res;\\n        \\n        dfs(num, target, 0, \"\", 0, 0, res);\\n        return res;\\n    }\\n    \\n    private void dfs(string num, int target, int idx, string expression, long expressionVal, long lastMonomial, List<string> res)\\n    {\\n        if(idx == num.Length)\\n        {\\n            if(expressionVal == target)\\n                res.Add(expression);\\n            return;\\n        }\\n        \\n        for(int i = idx; i < num.Length; i++)\\n        {\\n            string currStr = num.Substring(idx, i - idx + 1);\\n            \\n            if(currStr.Length > 1 && num[idx] == \\'0\\') break;  \\n            long currVal = long.Parse(currStr);\\n            \\n            if(idx == 0)\\n            {\\n                dfs(num, target, i + 1, expression + currStr, currVal, currVal, res);\\n            }\\n            else\\n            {\\n                // \\'+\\' and \\'-\\'\\n                dfs(num, target, i + 1, expression + \"+\" + currStr, expressionVal + currVal, currVal, res);\\n                dfs(num, target, i + 1, expression + \"-\" + currStr, expressionVal - currVal, -currVal, res);\\n\\n                // \\'*\\'\\n                dfs(num, target, i + 1, expression + \"*\" + currStr, expressionVal - lastMonomial + lastMonomial * currVal, lastMonomial* currVal, res);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471275,
                "title": "java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    public List<String> res = new ArrayList<>();\\n    public List<String> addOperators(String num, int target) {\\n        backtracking(num, 0, target, \"\", 0, 0);\\n        return res;\\n    }\\n    \\n    public void backtracking(String num, int ind, long target, String temp, long tot, long pre) {\\n        if (ind == num.length() && tot == target) {\\n            res.add(temp);\\n            return;\\n        }\\n        long cur = 0;\\n        for (int end = ind; end < num.length(); end++) {\\n            if (end > ind && num.charAt(ind) == \\'0\\') return;\\n            cur = cur * 10 + num.charAt(end) - \\'0\\';\\n            String sub = num.substring(ind, end + 1);\\n            if (ind == 0) {\\n                backtracking(num, end + 1, target, sub, cur, cur);\\n                continue;\\n            }\\n            backtracking(num, end + 1, target, temp + \"+\" + sub, tot + cur, cur);\\n            backtracking(num, end + 1, target, temp + \"-\" + sub, tot - cur, -cur);\\n            backtracking(num, end + 1, target, temp + \"*\" + sub, tot + (cur - 1) * pre, cur * pre);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> res = new ArrayList<>();\\n    public List<String> addOperators(String num, int target) {\\n        backtracking(num, 0, target, \"\", 0, 0);\\n        return res;\\n    }\\n    \\n    public void backtracking(String num, int ind, long target, String temp, long tot, long pre) {\\n        if (ind == num.length() && tot == target) {\\n            res.add(temp);\\n            return;\\n        }\\n        long cur = 0;\\n        for (int end = ind; end < num.length(); end++) {\\n            if (end > ind && num.charAt(ind) == \\'0\\') return;\\n            cur = cur * 10 + num.charAt(end) - \\'0\\';\\n            String sub = num.substring(ind, end + 1);\\n            if (ind == 0) {\\n                backtracking(num, end + 1, target, sub, cur, cur);\\n                continue;\\n            }\\n            backtracking(num, end + 1, target, temp + \"+\" + sub, tot + cur, cur);\\n            backtracking(num, end + 1, target, temp + \"-\" + sub, tot - cur, -cur);\\n            backtracking(num, end + 1, target, temp + \"*\" + sub, tot + (cur - 1) * pre, cur * pre);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470576,
                "title": "c-simple-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ValidExp;\\n    void calc(string &num,int index,long last,long result,int &target,string expression)\\n    {\\n        if(index==num.length())\\n        {\\n            if(result==target)\\n              ValidExp.push_back(expression);\\n            return;\\n        }\\n        for(int i=index;i<num.length();i++)\\n        {\\n            string subStr=num.substr(index,i-index+1);\\n            long val=stol(subStr);\\n            calc(num,i+1,val,result+val,target,index==0?expression+subStr:expression+\"+\"+subStr);\\n            if(index!=0)\\n            {\\n                calc(num,i+1,-1*val,result-val,target,expression+\"-\"+subStr);\\n                calc(num,i+1,last*val,result-last+last*val,target,expression+\"*\"+subStr);\\n            }\\n            if(num[index]==\\'0\\')\\n                break;\\n        }\\n    }\\n    \\n    vector<string> addOperators(string num, int target) \\n    {\\n        calc(num,0,0,0,target,\"\");\\n        return ValidExp;\\n    }\\n};\\n```\\n\\n***Little complex but much optimised solution***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> ValidExp;\\n    void calc(string &num,int index,long last,long &result,int &target,string &expression)\\n    {\\n        if(index==num.length())\\n        {\\n            if(result==target)\\n              ValidExp.push_back(expression);\\n            return;\\n        }\\n        for(int i=index;i<num.length();i++)\\n        {\\n            string subStr=num.substr(index,i-index+1);\\n            long val=stol(subStr);\\n            long newResult=result+val;\\n            expression+=index==0?subStr:\"+\"+subStr;\\n            calc(num,i+1,val,newResult,target,expression);\\n            index==0?expression.erase():expression.erase(expression.length()-(i-index+2)); \\n            if(index!=0)\\n            {\\n                newResult=result-val;\\n                expression+=\"-\"+subStr;\\n                calc(num,i+1,-1*val,newResult,target,expression);\\n                expression.erase(expression.length()-(i-index+2));\\n                newResult=result-last+last*val;\\n                expression+=\"*\"+subStr;\\n                calc(num,i+1,last*val,newResult,target,expression);\\n                expression.erase(expression.length()-(i-index+2));\\n            }\\n            if(num[index]==\\'0\\')\\n                break;\\n        }\\n    }\\n    \\n    \\n    vector<string> addOperators(string num, int target) \\n    {\\n        string exp;\\n        long result=0;\\n        calc(num,0,0,result,target,exp);\\n        return ValidExp;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ValidExp;\\n    void calc(string &num,int index,long last,long result,int &target,string expression)\\n    {\\n        if(index==num.length())\\n        {\\n            if(result==target)\\n              ValidExp.push_back(expression);\\n            return;\\n        }\\n        for(int i=index;i<num.length();i++)\\n        {\\n            string subStr=num.substr(index,i-index+1);\\n            long val=stol(subStr);\\n            calc(num,i+1,val,result+val,target,index==0?expression+subStr:expression+\"+\"+subStr);\\n            if(index!=0)\\n            {\\n                calc(num,i+1,-1*val,result-val,target,expression+\"-\"+subStr);\\n                calc(num,i+1,last*val,result-last+last*val,target,expression+\"*\"+subStr);\\n            }\\n            if(num[index]==\\'0\\')\\n                break;\\n        }\\n    }\\n    \\n    vector<string> addOperators(string num, int target) \\n    {\\n        calc(num,0,0,0,target,\"\");\\n        return ValidExp;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> ValidExp;\\n    void calc(string &num,int index,long last,long &result,int &target,string &expression)\\n    {\\n        if(index==num.length())\\n        {\\n            if(result==target)\\n              ValidExp.push_back(expression);\\n            return;\\n        }\\n        for(int i=index;i<num.length();i++)\\n        {\\n            string subStr=num.substr(index,i-index+1);\\n            long val=stol(subStr);\\n            long newResult=result+val;\\n            expression+=index==0?subStr:\"+\"+subStr;\\n            calc(num,i+1,val,newResult,target,expression);\\n            index==0?expression.erase():expression.erase(expression.length()-(i-index+2)); \\n            if(index!=0)\\n            {\\n                newResult=result-val;\\n                expression+=\"-\"+subStr;\\n                calc(num,i+1,-1*val,newResult,target,expression);\\n                expression.erase(expression.length()-(i-index+2));\\n                newResult=result-last+last*val;\\n                expression+=\"*\"+subStr;\\n                calc(num,i+1,last*val,newResult,target,expression);\\n                expression.erase(expression.length()-(i-index+2));\\n            }\\n            if(num[index]==\\'0\\')\\n                break;\\n        }\\n    }\\n    \\n    \\n    vector<string> addOperators(string num, int target) \\n    {\\n        string exp;\\n        long result=0;\\n        calc(num,0,0,result,target,exp);\\n        return ValidExp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470358,
                "title": "javascript-backtracking-commented-solution-with-explanation",
                "content": "**Idea** \\nwe want to do backtracking and calculate the the sum of the expression on the fly so when we get to the end of num array we will have sum ready and calculated, so we know if it is equal to target and we want to insert it to result array.\\n\\nwe have 4 options when we backtrack:\\n1. we don\\'t want to proccess the number yet, we want to enlarge it, create a new number with more than one digit \"124\", so we backtrack with the new number we created and we don\\'t calculate the expression yet, so we just send `newNumToAdd` to the backtracking func and do nothing.\\n2. we want to proccess the number with Addtion.\\n3. we want to proccess the number with Substraction.\\n4. we want to proccess the number with Multiplication, this is the tricky part:\\nTo be able to calculate the multiplications expression on the fly, to do that we keep track of the previous number  (`prevExp`) we proccessed and if we want to do a multiplication we do `sum - prevExp + (prevExp * newNumToAdd)`\\n\\n```\\nvar addOperators = function(num, target) {\\n    const res = [];\\n    backtracking(num, target, 0, 0, \"\", 0, 0, res);\\n    return res;\\n};\\n\\nvar backtracking = function(num, target, index, sum, expression, currNumToAdd, prevExp, res) {\\n\\tif(index > num.length) {\\n        return;\\n    }\\n    // If we are at end of num AND the final value == target expected AND no currNumToAdd is left unprocessed\\n    if(index === num.length && sum === target && currNumToAdd === 0) {\\n        res.push(expression.slice(1));\\n        return;\\n    }\\n    const newNumToAdd = currNumToAdd*10 + (+num[index]);\\n    // To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n    // valid operand. Hence this check. we only create number with more than 1 digit if (newNumToAdd > 0)\\n    if(newNumToAdd > 0) {\\n        backtracking(num, target, index+1, sum, expression, newNumToAdd, prevExp, res);\\n    }\\n    // ADDITION\\n    backtracking(num, target, index+1, sum + newNumToAdd, expression+\"+\"+newNumToAdd, 0, +newNumToAdd, res);\\n    // to avoid SUBTRACTION/MULTIPLICATION on first numToAdd when expression is empty(we asume we can only add)\\n    if(expression.length > 0) {\\n        // SUBTRACTION\\n        backtracking(num, target, index+1, sum - newNumToAdd, expression+\"-\"+newNumToAdd, 0, -newNumToAdd, res);\\n        // MULTIPLICATION\\n        const multSum = sum - prevExp + (prevExp * newNumToAdd);\\n        backtracking(num, target, index+1, multSum, expression+\"*\"+newNumToAdd, 0, (prevExp * newNumToAdd), res);\\n    }\\n    return;\\n}\\n\\n```\\n\\n**time comp**: O(4^N), where N length of num. O(4^N) because for every step in backtracking we have 4 paths.\\n**space comp**: O(N) for expression\\'s length string. also recursive stack space is O(N).",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar addOperators = function(num, target) {\\n    const res = [];\\n    backtracking(num, target, 0, 0, \"\", 0, 0, res);\\n    return res;\\n};\\n\\nvar backtracking = function(num, target, index, sum, expression, currNumToAdd, prevExp, res) {\\n\\tif(index > num.length) {\\n        return;\\n    }\\n    // If we are at end of num AND the final value == target expected AND no currNumToAdd is left unprocessed\\n    if(index === num.length && sum === target && currNumToAdd === 0) {\\n        res.push(expression.slice(1));\\n        return;\\n    }\\n    const newNumToAdd = currNumToAdd*10 + (+num[index]);\\n    // To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\\'t be a\\n    // valid operand. Hence this check. we only create number with more than 1 digit if (newNumToAdd > 0)\\n    if(newNumToAdd > 0) {\\n        backtracking(num, target, index+1, sum, expression, newNumToAdd, prevExp, res);\\n    }\\n    // ADDITION\\n    backtracking(num, target, index+1, sum + newNumToAdd, expression+\"+\"+newNumToAdd, 0, +newNumToAdd, res);\\n    // to avoid SUBTRACTION/MULTIPLICATION on first numToAdd when expression is empty(we asume we can only add)\\n    if(expression.length > 0) {\\n        // SUBTRACTION\\n        backtracking(num, target, index+1, sum - newNumToAdd, expression+\"-\"+newNumToAdd, 0, -newNumToAdd, res);\\n        // MULTIPLICATION\\n        const multSum = sum - prevExp + (prevExp * newNumToAdd);\\n        backtracking(num, target, index+1, multSum, expression+\"*\"+newNumToAdd, 0, (prevExp * newNumToAdd), res);\\n    }\\n    return;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1470337,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    enum class Operator {\\n        NONE, ADD, SUB, MUL\\n    }\\n    data class Result(\\n        val resValue: Long, \\n        val resString: String, \\n        val lastBlockMultiplier: Long,\\n        val lastNumber: Long) {\\n        \\n        private val lastBlockRes: Long = lastBlockMultiplier * lastNumber\\n        \\n        fun add(op: Operator, num: Long): Result? {\\n            return when (op) {\\n                Operator.ADD -> Result(resValue + num, \"$resString+$num\", 1, num)\\n                Operator.SUB -> Result(resValue - num, \"$resString-$num\", -1, num)\\n                Operator.MUL -> Result(resValue - lastBlockRes + lastBlockRes * num,\\n                                       \"$resString*$num\", lastBlockRes, num)\\n                Operator.NONE -> if (lastNumber == 0L) { null } else {\\n                    Result(resValue - lastBlockRes + lastBlockMultiplier * (lastNumber * 10 + num),\\n                           \"$resString$num\", lastBlockMultiplier, lastNumber * 10 + num)\\n                }\\n            }\\n        }\\n    }\\n    fun addOperators(num: String, target: Int): List<String> {\\n        val res = mutableListOf<String>()\\n        \\n        fun addOperatorBefore(index: Int, prevResult: Result) {\\n            if (index == num.length) {\\n                if (prevResult.resValue == target.toLong()) {\\n                    res.add(prevResult.resString)\\n                }\\n                return\\n            }\\n            val digitNum = (num[index] - \\'0\\').toLong()\\n            val results = Operator.values().fold(mutableListOf<Result>()) { acc, op ->\\n                acc.apply { prevResult.add(op, digitNum)?.let { add(it) } }\\n            }\\n            results.forEach {\\n                addOperatorBefore(index + 1, it)\\n            }\\n        }\\n        \\n        val digitNum = (num[0] - \\'0\\').toLong()\\n        addOperatorBefore(1, Result(digitNum, \"${num[0]}\", 1L, digitNum))\\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    enum class Operator {\\n        NONE, ADD, SUB, MUL\\n    }\\n    data class Result(\\n        val resValue: Long, \\n        val resString: String, \\n        val lastBlockMultiplier: Long,\\n        val lastNumber: Long) {\\n        \\n        private val lastBlockRes: Long = lastBlockMultiplier * lastNumber\\n        \\n        fun add(op: Operator, num: Long): Result? {\\n            return when (op) {\\n                Operator.ADD -> Result(resValue + num, \"$resString+$num\", 1, num)\\n                Operator.SUB -> Result(resValue - num, \"$resString-$num\", -1, num)\\n                Operator.MUL -> Result(resValue - lastBlockRes + lastBlockRes * num,\\n                                       \"$resString*$num\", lastBlockRes, num)\\n                Operator.NONE -> if (lastNumber == 0L) { null } else {\\n                    Result(resValue - lastBlockRes + lastBlockMultiplier * (lastNumber * 10 + num),\\n                           \"$resString$num\", lastBlockMultiplier, lastNumber * 10 + num)\\n                }\\n            }\\n        }\\n    }\\n    fun addOperators(num: String, target: Int): List<String> {\\n        val res = mutableListOf<String>()\\n        \\n        fun addOperatorBefore(index: Int, prevResult: Result) {\\n            if (index == num.length) {\\n                if (prevResult.resValue == target.toLong()) {\\n                    res.add(prevResult.resString)\\n                }\\n                return\\n            }\\n            val digitNum = (num[index] - \\'0\\').toLong()\\n            val results = Operator.values().fold(mutableListOf<Result>()) { acc, op ->\\n                acc.apply { prevResult.add(op, digitNum)?.let { add(it) } }\\n            }\\n            results.forEach {\\n                addOperatorBefore(index + 1, it)\\n            }\\n        }\\n        \\n        val digitNum = (num[0] - \\'0\\').toLong()\\n        addOperatorBefore(1, Result(digitNum, \"${num[0]}\", 1L, digitNum))\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465105,
                "title": "java-solution-backtracking",
                "content": "class Solution {\\n\\n    List<String> sol;\\n     public List<String> addOperators(String num, int target) {\\n        sol = new ArrayList<>();\\n\\n         if(Long.parseLong(num) > Integer.MAX_VALUE) return sol;\\n        \\n        recursion(num, target, 0, new StringBuilder());\\n        return sol;\\n    }\\n    \\n    \\n    public void recursion(String num, int target, int start, StringBuilder sb) {        \\n        if(start == num.length()) {\\n            // calculate opeartaion from String \\n            if(Integer.compare(calculate(sb.toString()), target) == 0) sol.add(sb.toString());\\n            return;\\n        }\\n          \\n        for(int i = start; i < num.length(); i++) {\\n            \\n            if(i-start> 0 && num.charAt(start) == \\'0\\') continue;  // number like: \"05\", \"00\".. \\n            \\n            if(start == 0 ) {\\n                sb.append(num.substring(start,i+1)+\"\"); // First number, example:  -> (1) + 2 + 3\\n                recursion(num, target, i + 1, sb);\\n                \\n            } else{\\n                // Addition (add the \"x\" and number)\\n                sb.append(\"+\");\\n                sb.append(num.substring(start,i+1)+\"\");\\n                recursion(num, target, i + 1, sb);\\n\\n                // Substraction (change \"+\" to \"-\")\\n                sb.replace(sb.length()-2-(i-start),sb.length()-1-(i-start), \"-\");\\n                recursion(num, target, i + 1, sb);\\n\\n                //Multiplication (change \"-\" to \"*\")\\n                sb.replace(sb.length()-2-(i-start),sb.length()-1-(i-start), \"*\");\\n                recursion(num, target, i + 1, sb);\\n            }\\n            //delete the added elements to backtrack\\n            if(sb.length()-2-(i-start) >= 0) sb.delete(sb.length()-2-(i-start),sb.length());\\n            else sb.delete(0, sb.length());\\n        }\\n        \\n    }\\n    \\n    \\n    \\n    public int calculate(String expression) {\\n        Stack<Integer> stack = new Stack<>();\\n        \\n        boolean isMultiplication = false;\\n        int pointer = 0;\\n        int sign = 1;\\n        int number = 0;\\n        \\n        while(pointer < expression.length()) {\\n\\n            if(expression.charAt(pointer) == \\'*\\') {\\n                isMultiplication = true;\\n                pointer++;\\n            }\\n            if(expression.charAt(pointer) == \\'-\\') {\\n                sign = -1;\\n                pointer++;\\n            } \\n            if(expression.charAt(pointer) == \\'+\\') {\\n                sign = 1;\\n                pointer++;\\n            } \\n            while(pointer < expression.length() && expression.charAt(pointer) >= \\'0\\' \\n                  && expression.charAt(pointer) <= \\'9\\') {\\n                number = number * 10 + Integer.parseInt(expression.charAt(pointer) + \"\");\\n                pointer++;\\n            }\\n            if(isMultiplication) {\\n                number *= stack.pop();\\n                isMultiplication = false;\\n            } \\n            stack.add(number*sign);\\n            number = 0;\\n            sign = 1;\\n        }\\n        \\n        int result = 0;\\n        for(int x: stack) result += x;\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    List<String> sol;\\n     public List<String> addOperators(String num, int target) {\\n        sol = new ArrayList<>();\\n\\n         if(Long.parseLong(num) > Integer.MAX_VALUE) return sol;\\n        \\n        recursion(num, target, 0, new StringBuilder());\\n        return sol;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1414131,
                "title": "python-simple-and-clear-dfs-solution-with-detailed-comments-beating-97",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        result = []\\n        n = len(num)\\n        \\n        def dfs(pos, path, val, last_operand):\\n            if pos == n:\\n                if val == target:\\n                    result.append(path)\\n            else:\\n                for i in range(pos, n):\\n                    # try [pos..i] as an operand\\n                    if num[pos] == \\'0\\' and i != pos:\\n                        # For example \"0555\", Only consider \"0\" as possible operand\\n                        break\\n                    s = num[pos : i + 1]\\n                    v = int(s)\\n                    if pos == 0:\\n                        # no possible left operand\\n                        dfs(i + 1, s, v, v)\\n                    else:\\n                        dfs(i + 1, path + \\'+\\' + s, val + v, v)\\n                        dfs(i + 1, path + \\'-\\' + s, val - v, -v)\\n                        dfs(i + 1, path + \\'*\\' + s, val - last_operand + last_operand * v, last_operand * v)\\n        \\n        dfs(0, \\'\\', 0, 0)\\n        return result",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        result = []\\n        n = len(num)\\n        \\n        def dfs(pos, path, val, last_operand):\\n            if pos == n:\\n                if val == target:\\n                    result.append(path)\\n            else:\\n                for i in range(pos, n):\\n                    # try [pos..i] as an operand\\n                    if num[pos] == \\'0\\' and i != pos:\\n                        # For example \"0555\", Only consider \"0\" as possible operand\\n                        break\\n                    s = num[pos : i + 1]\\n                    v = int(s)\\n                    if pos == 0:\\n                        # no possible left operand\\n                        dfs(i + 1, s, v, v)\\n                    else:\\n                        dfs(i + 1, path + \\'+\\' + s, val + v, v)\\n                        dfs(i + 1, path + \\'-\\' + s, val - v, -v)\\n                        dfs(i + 1, path + \\'*\\' + s, val - last_operand + last_operand * v, last_operand * v)\\n        \\n        dfs(0, \\'\\', 0, 0)\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 1404761,
                "title": "java-backtracking",
                "content": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> result = new LinkedList<String>();\\n        helper(num, target, 0, 0, \\'!\\', 0, \"\", result);\\n        return result;\\n    }\\n    \\n    private void helper(String num, int target, long curSum, long prevNum, char prevOp, int pos, String local, List<String> result) {\\n        if (pos == num.length()) {\\n            if (curSum == (long)target) result.add(local);\\n            return ;\\n        }\\n        \\n        long curNum = 0;\\n        for(int i = pos; i < num.length(); i++) {\\n            if (i == pos || curNum > 0) {\\n                curNum = curNum*10 + Integer.valueOf(num.charAt(i)-\\'0\\');  \\n                if (pos == 0) {\\n                    helper(num, target, curNum, curNum, prevOp, i+1, String.valueOf(curNum), result);\\n                } else {\\n                    // +\\n                    helper(num, target, curSum+curNum, curNum, \\'+\\', i+1, local+\"+\"+curNum, result);\\n                    // -\\n                    helper(num, target, curSum-curNum, curNum, \\'-\\', i+1, local+\"-\"+curNum, result);\\n                    // *\\n                    if (prevOp == \\'-\\') {\\n                        helper(num, target, curSum+prevNum-(prevNum*curNum), prevNum*curNum, prevOp, i+1, local+\"*\"+curNum, result);\\n                    } else if (prevOp == \\'+\\') {\\n                        helper(num, target, curSum-prevNum+(prevNum*curNum), prevNum*curNum, prevOp, i+1, local+\"*\"+curNum, result);\\n                    } else {\\n                        helper(num, target, curSum*curNum, curNum, prevOp, i+1, local+\"*\"+curNum, result);    \\n                    }\\n                }   \\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        List<String> result = new LinkedList<String>();\\n        helper(num, target, 0, 0, \\'!\\', 0, \"\", result);\\n        return result;\\n    }\\n    \\n    private void helper(String num, int target, long curSum, long prevNum, char prevOp, int pos, String local, List<String> result) {\\n        if (pos == num.length()) {\\n            if (curSum == (long)target) result.add(local);\\n            return ;\\n        }\\n        \\n        long curNum = 0;\\n        for(int i = pos; i < num.length(); i++) {\\n            if (i == pos || curNum > 0) {\\n                curNum = curNum*10 + Integer.valueOf(num.charAt(i)-\\'0\\');  \\n                if (pos == 0) {\\n                    helper(num, target, curNum, curNum, prevOp, i+1, String.valueOf(curNum), result);\\n                } else {\\n                    // +\\n                    helper(num, target, curSum+curNum, curNum, \\'+\\', i+1, local+\"+\"+curNum, result);\\n                    // -\\n                    helper(num, target, curSum-curNum, curNum, \\'-\\', i+1, local+\"-\"+curNum, result);\\n                    // *\\n                    if (prevOp == \\'-\\') {\\n                        helper(num, target, curSum+prevNum-(prevNum*curNum), prevNum*curNum, prevOp, i+1, local+\"*\"+curNum, result);\\n                    } else if (prevOp == \\'+\\') {\\n                        helper(num, target, curSum-prevNum+(prevNum*curNum), prevNum*curNum, prevOp, i+1, local+\"*\"+curNum, result);\\n                    } else {\\n                        helper(num, target, curSum*curNum, curNum, prevOp, i+1, local+\"*\"+curNum, result);    \\n                    }\\n                }   \\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388352,
                "title": "very-simple-python-dfs-solution",
                "content": "start: start index\\nl: path\\ntot: sum\\nprev: previous value\\n\\n```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        \\n        res = []\\n        \\n        def dfs(start = 0, l = \"\", tot = 0, prev = 0):\\n            if start == len(num):\\n                if tot == target:\\n                    res.append(l)\\n                return\\n            \\n            for i in range(start, len(num)):\\n                \\n                if i - start and int(num[start]) == 0:\\n                    continue\\n                \\n                cur = int(num[start:i + 1])\\n                if start == 0:\\n                    dfs(i + 1, l + str(cur), tot + cur, cur)\\n                else:\\n                    dfs(i + 1, l + \"+\" + str(cur), tot + cur, cur)\\n                    dfs(i + 1, l + \"-\" + str(cur), tot - cur, -cur)\\n                    dfs(i + 1, l + \"*\" + str(cur), tot - prev + prev * cur, prev * cur)\\n        \\n        dfs()\\n        \\n        return res\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num, target):\\n        \\n        res = []\\n        \\n        def dfs(start = 0, l = \"\", tot = 0, prev = 0):\\n            if start == len(num):\\n                if tot == target:\\n                    res.append(l)\\n                return\\n            \\n            for i in range(start, len(num)):\\n                \\n                if i - start and int(num[start]) == 0:\\n                    continue\\n                \\n                cur = int(num[start:i + 1])\\n                if start == 0:\\n                    dfs(i + 1, l + str(cur), tot + cur, cur)\\n                else:\\n                    dfs(i + 1, l + \"+\" + str(cur), tot + cur, cur)\\n                    dfs(i + 1, l + \"-\" + str(cur), tot - cur, -cur)\\n                    dfs(i + 1, l + \"*\" + str(cur), tot - prev + prev * cur, prev * cur)\\n        \\n        dfs()\\n        \\n        return res\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1284423,
                "title": "java-clean-code-dfs",
                "content": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        ArrayList<String> res = new ArrayList<>();\\n        dfs(0,0,0,0,num, target,\"\",res);\\n        return res;\\n    }\\n    \\n    void dfs(int ci, long val, long prev, long cur, String num,long target, String str, ArrayList<String> res){\\n        if(ci == num.length()){\\n            if(val == target && cur == 0) {\\n                res.add(str);\\n            }\\n            return;\\n        }\\n\\n        int cd= num.charAt(ci) - \\'0\\';\\n        cur = 10 * cur; \\n        cur += cd;\\n\\n        //no op\\n        if(cur > 0)\\n            dfs(ci+1, val, prev, cur, num, target, str , res );\\n        \\n        // + \\n        if(str.equals(\"\")) {\\n             dfs(ci+1, val+cur, cur, 0, num, target, str + cur, res );\\n            return;\\n        }\\n         dfs(ci+1, val+cur, cur, 0, num, target, str +\"+\" + cur, res );\\n          // -\\n        dfs(ci+1, val -cur, -cur, 0, num, target, str +\"-\" + cur, res );\\n\\n        // *\\n        dfs(ci+1, val -prev + (prev * cur), prev * cur, 0, num, target, str +\"*\" + cur, res );\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> addOperators(String num, int target) {\\n        ArrayList<String> res = new ArrayList<>();\\n        dfs(0,0,0,0,num, target,\"\",res);\\n        return res;\\n    }\\n    \\n    void dfs(int ci, long val, long prev, long cur, String num,long target, String str, ArrayList<String> res){\\n        if(ci == num.length()){\\n            if(val == target && cur == 0) {\\n                res.add(str);\\n            }\\n            return;\\n        }\\n\\n        int cd= num.charAt(ci) - \\'0\\';\\n        cur = 10 * cur; \\n        cur += cd;\\n\\n        //no op\\n        if(cur > 0)\\n            dfs(ci+1, val, prev, cur, num, target, str , res );\\n        \\n        // + \\n        if(str.equals(\"\")) {\\n             dfs(ci+1, val+cur, cur, 0, num, target, str + cur, res );\\n            return;\\n        }\\n         dfs(ci+1, val+cur, cur, 0, num, target, str +\"+\" + cur, res );\\n          // -\\n        dfs(ci+1, val -cur, -cur, 0, num, target, str +\"-\" + cur, res );\\n\\n        // *\\n        dfs(ci+1, val -prev + (prev * cur), prev * cur, 0, num, target, str +\"*\" + cur, res );\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245293,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        def dfs(pos, cur, pre, exp):\\n\\n            if pos == n:\\n                if cur == target:\\n                    res.append(exp)\\n                return\\n        \\n            for right in range(pos + 1, n + 1):\\n                tmp = num[pos:right]\\n                if tmp[0] == \\'0\\' and len(tmp) > 1:\\n                    break\\n                    \\n                val = int(tmp)\\n                if pos == 0:\\n                    dfs(right, val, val, tmp)\\n                else:\\n                    dfs(right, cur + val, val, exp + \"+\" + tmp)\\n                    dfs(right, cur - val, -val, exp + \"-\" + tmp)\\n                    dfs(right, cur - pre + pre * val, pre * val, exp + \"*\" + tmp)\\n            \\n        \\n        res = list()\\n        if not num or len(num) == 0:\\n            return res\\n        n = len(num)\\n        dfs(0, 0, 0, \"\")\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        def dfs(pos, cur, pre, exp):\\n\\n            if pos == n:\\n                if cur == target:\\n                    res.append(exp)\\n                return\\n        \\n            for right in range(pos + 1, n + 1):\\n                tmp = num[pos:right]\\n                if tmp[0] == \\'0\\' and len(tmp) > 1:\\n                    break\\n                    \\n                val = int(tmp)\\n                if pos == 0:\\n                    dfs(right, val, val, tmp)\\n                else:\\n                    dfs(right, cur + val, val, exp + \"+\" + tmp)\\n                    dfs(right, cur - val, -val, exp + \"-\" + tmp)\\n                    dfs(right, cur - pre + pre * val, pre * val, exp + \"*\" + tmp)\\n            \\n        \\n        res = list()\\n        if not num or len(num) == 0:\\n            return res\\n        n = len(num)\\n        dfs(0, 0, 0, \"\")\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238289,
                "title": "c-clean-and-concise-beats-98-28",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    string buf;\\n    long t;\\n    int last;\\n    \\n    vector<string> addOperators(string num, int target) {\\n        buf.resize(20);\\n        t = target;\\n        last = num.size()-1;\\n        \\n        dfs(num, 0, 0, 0, 0, \\'+\\');\\n        \\n        return ans;\\n    }\\n    \\n    void dfs(string& num, int i, int j, long sum, long sumtmp, char prevop){                \\n        long v = 0;\\n        \\n        for (int k = i ; ; k++){\\n            v *= 10;\\n            v += long(num[k]-\\'0\\');\\n            buf[j] = num[k];\\n            j++;\\n            \\n            long sumtmptmp = (prevop == \\'*\\'?sumtmp*v: (prevop == \\'+\\'?sumtmp+v:sumtmp-v));\\n            \\n            if (k == last){\\n                if (sum+sumtmptmp == t) ans.push_back(buf.substr(0, j));\\n\\n                return;\\n            }\\n            \\n            buf[j] = \\'*\\';\\n            dfs(num, k+1, j+1, sum, sumtmptmp, \\'*\\');\\n            buf[j] = \\'+\\';\\n            dfs(num, k+1, j+1, sum+sumtmptmp, 0, \\'+\\');\\n            buf[j] = \\'-\\';\\n            dfs(num, k+1, j+1, sum+sumtmptmp, 0, \\'-\\');\\n            \\n            if (!v) return;\\n        }\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    string buf;\\n    long t;\\n    int last;\\n    \\n    vector<string> addOperators(string num, int target) {\\n        buf.resize(20);\\n        t = target;\\n        last = num.size()-1;\\n        \\n        dfs(num, 0, 0, 0, 0, \\'+\\');\\n        \\n        return ans;\\n    }\\n    \\n    void dfs(string& num, int i, int j, long sum, long sumtmp, char prevop){                \\n        long v = 0;\\n        \\n        for (int k = i ; ; k++){\\n            v *= 10;\\n            v += long(num[k]-\\'0\\');\\n            buf[j] = num[k];\\n            j++;\\n            \\n            long sumtmptmp = (prevop == \\'*\\'?sumtmp*v: (prevop == \\'+\\'?sumtmp+v:sumtmp-v));\\n            \\n            if (k == last){\\n                if (sum+sumtmptmp == t) ans.push_back(buf.substr(0, j));\\n\\n                return;\\n            }\\n            \\n            buf[j] = \\'*\\';\\n            dfs(num, k+1, j+1, sum, sumtmptmp, \\'*\\');\\n            buf[j] = \\'+\\';\\n            dfs(num, k+1, j+1, sum+sumtmptmp, 0, \\'+\\');\\n            buf[j] = \\'-\\';\\n            dfs(num, k+1, j+1, sum+sumtmptmp, 0, \\'-\\');\\n            \\n            if (!v) return;\\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069896,
                "title": "clean-python-solution",
                "content": "The trick of this solution is to record the `last` calculated value for current  multiple (`*`) operation.\\n\\n```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        ret = []\\n        def dfs(subtotal, last, path, start):\\n            if start == len(num):\\n                if subtotal == target:\\n                    ret.append(\\'\\'.join(path))\\n                return\\n            for i in range(start, len(num)):\\n                ch = num[start:i + 1]\\n                if len(ch) > 1 and ch[0] == \\'0\\':\\n                    continue\\n                integer = int(ch)\\n                if not path:\\n                    dfs( integer, integer, [ch], i + 1 )\\n                else:\\n                    dfs( subtotal + integer, integer, path + [\\'+\\', ch], i + 1 )\\n                    dfs( subtotal - integer, -integer, path + [\\'-\\', ch],i + 1 )\\n\\t\\t\\t\\t\\t# the most interesting part:\\n\\t\\t\\t\\t\\t# e.g. 1+2*3, we record last as 2, so: 3-2+2*3 = 7\\n                    dfs( subtotal - last + last * integer, last * integer, path + [\\'*\\', ch], i + 1 ) \\n        dfs(0, 0, [], 0)\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def addOperators(self, num: str, target: int) -> List[str]:\\n        ret = []\\n        def dfs(subtotal, last, path, start):\\n            if start == len(num):\\n                if subtotal == target:\\n                    ret.append(\\'\\'.join(path))\\n                return\\n            for i in range(start, len(num)):\\n                ch = num[start:i + 1]\\n                if len(ch) > 1 and ch[0] == \\'0\\':\\n                    continue\\n                integer = int(ch)\\n                if not path:\\n                    dfs( integer, integer, [ch], i + 1 )\\n                else:\\n                    dfs( subtotal + integer, integer, path + [\\'+\\', ch], i + 1 )\\n                    dfs( subtotal - integer, -integer, path + [\\'-\\', ch],i + 1 )\\n\\t\\t\\t\\t\\t# the most interesting part:\\n\\t\\t\\t\\t\\t# e.g. 1+2*3, we record last as 2, so: 3-2+2*3 = 7\\n                    dfs( subtotal - last + last * integer, last * integer, path + [\\'*\\', ch], i + 1 ) \\n        dfs(0, 0, [], 0)\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044199,
                "title": "java-basic-calculator-ii",
                "content": "This takes the Solution 2 of Basic Calculator II and modifies it. \\nThe idea is that we generate the string we are evaluating on the previous call and evaluate it in the next call. So basically Basic Calculator II + generate the next part of the string and call again Basic Calculator II.\\n\\n```\\n\\tint target;\\n    List<String> answer = new ArrayList<>();\\n    \\n    public List<String> addOperators(String num, int target) {\\n        this.target = target;\\n        addOp(num, 0, new StringBuilder(), 0, 0, \\'+\\', 0);\\n        return answer;\\n    }\\n    \\n    public void addOp(String num, int i, StringBuilder sb, long lOp, long rOp, char prevOp, long sum) {\\n        int numLen = num.length();\\n        int resLen = sb.length();\\n        \\n        // Get the current char of the result\\n        char c = resLen > 0 ? sb.charAt(resLen - 1) : \\'+\\';\\n        \\n        // Have this because we have multiple calls\\n        boolean isDigit = Character.isDigit(c);\\n        \\n        // Check this here in case we reach i==numLen and there is still a digit we haven\\'t added to rOp\\n        if(isDigit) {\\n            rOp = rOp * 10 + (c - \\'0\\');\\n        }\\n         \\n        // We want to to this once before ending at i==numLen\\n        if(resLen == 0 || i == numLen || c == \\'*\\' || c == \\'+\\' || c == \\'-\\') {\\n            if(prevOp == \\'+\\') {\\n                sum += lOp;\\n                lOp = rOp;\\n            } else if(prevOp == \\'-\\') {\\n                sum += lOp;\\n                lOp = -rOp;\\n            } else {\\n                lOp = lOp * rOp;\\n            }\\n            rOp = 0;\\n            prevOp = c;            \\n        } else if(isDigit) {           \\n            // Add operations and evaluate\\n            addOp(num, i, new StringBuilder(sb).append(\\'+\\'), lOp, rOp, prevOp, sum);\\n            addOp(num, i, new StringBuilder(sb).append(\\'-\\'), lOp, rOp, prevOp, sum);\\n            addOp(num, i, new StringBuilder(sb).append(\\'*\\'), lOp, rOp, prevOp, sum);                \\n        }\\n        \\n        // If we havent reached the end, we try NOT adding an operation.\\n        if(i < numLen) {\\n            // This prevent 05, 00. Catches leading zeros.\\n            if(!isDigit || (isDigit && (rOp != 0))) {\\n                addOp(num, i+1, sb.append(num.charAt(i)), lOp, rOp, prevOp, sum);                \\n            }            \\n        } else {\\n            // Base case is here. When we reached the end but already did all operations above.\\n            long result = sum + lOp;\\n            if(result == this.target) {\\n                this.answer.add(sb.toString());\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint target;\\n    List<String> answer = new ArrayList<>();\\n    \\n    public List<String> addOperators(String num, int target) {\\n        this.target = target;\\n        addOp(num, 0, new StringBuilder(), 0, 0, \\'+\\', 0);\\n        return answer;\\n    }\\n    \\n    public void addOp(String num, int i, StringBuilder sb, long lOp, long rOp, char prevOp, long sum) {\\n        int numLen = num.length();\\n        int resLen = sb.length();\\n        \\n        // Get the current char of the result\\n        char c = resLen > 0 ? sb.charAt(resLen - 1) : \\'+\\';\\n        \\n        // Have this because we have multiple calls\\n        boolean isDigit = Character.isDigit(c);\\n        \\n        // Check this here in case we reach i==numLen and there is still a digit we haven\\'t added to rOp\\n        if(isDigit) {\\n            rOp = rOp * 10 + (c - \\'0\\');\\n        }\\n         \\n        // We want to to this once before ending at i==numLen\\n        if(resLen == 0 || i == numLen || c == \\'*\\' || c == \\'+\\' || c == \\'-\\') {\\n            if(prevOp == \\'+\\') {\\n                sum += lOp;\\n                lOp = rOp;\\n            } else if(prevOp == \\'-\\') {\\n                sum += lOp;\\n                lOp = -rOp;\\n            } else {\\n                lOp = lOp * rOp;\\n            }\\n            rOp = 0;\\n            prevOp = c;            \\n        } else if(isDigit) {           \\n            // Add operations and evaluate\\n            addOp(num, i, new StringBuilder(sb).append(\\'+\\'), lOp, rOp, prevOp, sum);\\n            addOp(num, i, new StringBuilder(sb).append(\\'-\\'), lOp, rOp, prevOp, sum);\\n            addOp(num, i, new StringBuilder(sb).append(\\'*\\'), lOp, rOp, prevOp, sum);                \\n        }\\n        \\n        // If we havent reached the end, we try NOT adding an operation.\\n        if(i < numLen) {\\n            // This prevent 05, 00. Catches leading zeros.\\n            if(!isDigit || (isDigit && (rOp != 0))) {\\n                addOp(num, i+1, sb.append(num.charAt(i)), lOp, rOp, prevOp, sum);                \\n            }            \\n        } else {\\n            // Base case is here. When we reached the end but already did all operations above.\\n            long result = sum + lOp;\\n            if(result == this.target) {\\n                this.answer.add(sb.toString());\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564924,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1565668,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1747503,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1576894,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1568041,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1570495,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1569873,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1569747,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1569054,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1570615,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1564924,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1565668,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1747503,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1576894,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1568041,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1570495,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1569873,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1569747,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1569054,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1570615,
                "content": [
                    {
                        "username": "Israfel",
                        "content": "My input:\\n\\n\\u201c105\\u201d\\n5\\n\\nMy answer:\\n\\n    [\"10-5\",\"1*05\",\"1*0+5\"]\\n\\nExpected answer:\\n\\n    [\"1*0+5\",\"10-5\"]"
                    },
                    {
                        "username": "mike1029",
                        "content": "no leading 0 is required\\n"
                    },
                    {
                        "username": "turbocv",
                        "content": "who knows divide and conquer solution for this problem?"
                    },
                    {
                        "username": "manideepak650",
                        "content": "One of the misleading problems that I ever faced. The description clearly mentioned the operators must be placed between the digits. Yet, one of the testcases for 105 illustrated that 10 - 5."
                    },
                    {
                        "username": "MoRatio",
                        "content": "[@cartesPerforees](/cartesPerforees) \"But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho\"\n\n\nNot really. Nothing should be \"indicated\" or \"implied\" anyway. The problem statement is formatted poorly. Simply state that individual digits in the string can be combined to form larger numbers and give an example."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "the \"-\" is between 0 and 5. 0 is a digit and so is 5, so it is placed between two digits. I don't see a contradiction.\nDo you mean that it is not clear whether we have the right to consider more than a single digit in the partition? Maybe it is not totally clear on that point. But the prohibition to have leading zeroes does indicate that we can take more than a single digit tho"
                    },
                    {
                        "username": "Student2091",
                        "content": "The way this problem phrases \\'+\\', \\'-\\', and/or \\'*\\' is really misleading. \\nI read it as \\'+\\', \\'-\\', and \\'/\\' or \\'\\\\*\\'. I then assumed the `/` is double division because \"72\" 3 expected answer is []. I also tried to come up with a DP solution because it is a tad slow. \\n\\nI wasted like 30 minutes on this. I took me a long time to realize `/` is not included."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don;t know how it was in 2022, but as of 2023, the formatting leaves little ambiguity. Visually, it is hard to  confuse \n\" `+`,`-` and/or `*` \" \nfor \" `+`,`-` and `/` or `*` \""
                    },
                    {
                        "username": "mustafabar",
                        "content": "for the test case 105 and target = 5, why is 1 * 05 not equal to 5? isn\\'t it leading 0 negligible ?"
                    },
                    {
                        "username": "abhinavsalar",
                        "content": "As far I have noticed if the dig is zero than it can not be include directly or as a prefix for some others digits. It can only be included as a suffix part of a digit."
                    },
                    {
                        "username": "zack0927",
                        "content": "Time Complexity:\\nT(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1) + O(n)\\nT(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1) + O(n)\\nT(0) = O(n)\\n\\nThe O(n) part is because of string copying. Thus T(n) = 4T(n-1) = 4 * 4^(n-1) * T(0) = O(n * 4 ^ n)\\nPlease correct me if I am wrong!!!"
                    },
                    {
                        "username": "paltech",
                        "content": "When the given string is 105 and target value is 5, i am not sure why \"1 * 05\" not considered as value eventhough  10 - 5 is value"
                    },
                    {
                        "username": "Adetomiwa",
                        "content": "According to the question, each number is expected to have no leading zeros. Basically, \"5\" is not considered the same as \"05\"."
                    },
                    {
                        "username": "HappyCerberus",
                        "content": "My solution found these two matches which indeed evaluate to 9191.\\n\\n\\t[\"34/5+62*37*4+9+0\",\"34/5+62*37*4+9-0\"]\\n\\t"
                    },
                    {
                        "username": "biciclub",
                        "content": "It appears division is not allowed"
                    },
                    {
                        "username": "kabir_singh",
                        "content": "for \"105\" the answer should be [1*0+5, 10-5, 1*05]. The last option has not been included in the question but is a valid answer"
                    },
                    {
                        "username": "doverbeach",
                        "content": "The output from Example 3 includes \"10-5\" which contains no operator between the digits 1 and 0. If this is permissable, would it be fair to say that the output from Example 4 should also include \"00\" which has the same value as the target?\\n*apologies for nitpicking lol"
                    }
                ]
            },
            {
                "id": 1861633,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1575220,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1574526,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1572513,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1571989,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1571525,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1571526,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 2040002,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1994199,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            },
            {
                "id": 1979861,
                "content": [
                    {
                        "username": "prshntvrm1",
                        "content": "I am bit  confused with  the question\\nwhat if input is [\"123\"] and the target is 9\\nthe only expected ans is [12-3] \\nwhy not [1+2 * 3]"
                    },
                    {
                        "username": "avijain14",
                        "content": "the expression is evaluated according to BODMAS rule"
                    },
                    {
                        "username": "doudoukuaipao",
                        "content": "I am wondering Why can\\'t this question use DFS with memorization? Could someone help explain? THanks!"
                    },
                    {
                        "username": "miracle84",
                        "content": "Regarding 105 and 5 example, also possible answer is 1*05, of course in usual representation we use 5 without leading zero, but anyway 05 equals 5, than 1*05 is also possible solution. \\nOr if we must use only numbers without leading zero, may be it should be clearly mentioned in description?\\nOr correct me please, if i am wrong."
                    },
                    {
                        "username": "vikas5",
                        "content": "Hi,\\nFor input parameters\"105\" and 5, my algorithm is getting an additional answer as \"1*05\". Why is this not an valid answer? Can someone help me here?"
                    },
                    {
                        "username": "atruecubsfan",
                        "content": "I believe the runtime complexity for the vanilla DFS approach is O(4 ^ n).  However there are many subproblems that can be memo-ized.  Whats the complexity of the memoized version?  "
                    },
                    {
                        "username": "Blink_fw",
                        "content": "Do we need to handle the case where the input string is very long? For example, we have \"99....99\", where there are 100 '9' in the string and the target value is 0? I don't see any restriction on the string length."
                    },
                    {
                        "username": "Decision",
                        "content": "It seems taking exponential time: O(4^n) by DFS solution. \\n\\nDoes this problem have polynomial time solution?"
                    },
                    {
                        "username": "thanir10",
                        "content": "The question is misleading here. The question did not mention whether there could be operation between multiple digit \\nEx : 10 - 5 (Accepted)"
                    },
                    {
                        "username": "marknaman05",
                        "content": "Input\nnum =\n\"105\"\ntarget =\n5\nOutput\n`[\"1*0+5\",\"1*05\",\"10-5\"]`\nExpected\n`[\"1*0+5\",\"10-5\"]`\n\nWhy this case is wrong?"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Description is not clear. Examples should include a testcase where more than one digit is taken to form a number."
                    }
                ]
            }
        ]
    }
]