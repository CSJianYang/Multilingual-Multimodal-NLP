[
    {
        "title": "Remove Nth Node From End of List",
        "question_content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n&nbsp;\nExample 1:\n\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n\nExample 2:\n\nInput: head = [1], n = 1\nOutput: []\n\nExample 3:\n\nInput: head = [1,2], n = 1\nOutput: [1]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the list is sz.\n\t1 <= sz <= 30\n\t0 <= Node.val <= 100\n\t1 <= n <= sz\n\n&nbsp;\nFollow up: Could you do this in one pass?",
        "solutions": [
            {
                "id": 1164542,
                "title": "js-python-java-c-easy-two-pointer-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nWith a singly linked list, the _only_ way to find the end of the list, and thus the **n**\\'th node from the end, is to actually iterate all the way to the end. The challenge here is attemping to find the solution in only one pass. A naive approach here might be to store pointers to each node in an array, allowing us to calculate the **n**\\'th from the end once we reach the end, but that would take **O(M) extra space**, where **M** is the length of the linked list.\\n\\nA slightly less naive approach would be to only store only the last **n+1** node pointers in the array. This could be achieved by overwriting the elements of the storage array in circlular fashion as we iterate through the list. This would lower the **space complexity** to **O(N+1)**.\\n\\nIn order to solve this problem in only one pass and **O(1) extra space**, however, we would need to find a way to _both_ reach the end of the list with one pointer _and also_ reach the **n**\\'th node from the end simultaneously with a second pointer.\\n\\nTo do that, we can simply stagger our two pointers by **n** nodes by giving the first pointer (**fast**) a head start before starting the second pointer (**slow**). Doing this will cause **slow** to reach the **n**\\'th node from the end at the same time that **fast** reaches the end.\\n\\n![Visual 1](https://i.imgur.com/BSiLKj0.png)\\n\\nSince we will need access to the node _before_ the target node in order to remove the target node, we can use **fast.next == null** as our exit condition, rather than **fast == null**, so that we stop one node earlier.\\n\\nThis will unfortunately cause a problem when **n** is the same as the length of the list, which would make the first node the target node, and thus make it impossible to find the node _before_ the target node. If that\\'s the case, however, we can just **return head.next** without needing to stitch together the two sides of the target node.\\n\\nOtherwise, once we succesfully find the node _before_ the target, we can then stitch it together with the node _after_ the target, and then **return head**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences between the code of all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **60ms / 40.6MB** (beats 100% / 13%).\\n```javascript\\nvar removeNthFromEnd = function(head, n) {\\n    let fast = head, slow = head\\n    for (let i = 0; i < n; i++) fast = fast.next\\n    if (!fast) return head.next\\n    while (fast.next) fast = fast.next, slow = slow.next\\n    slow.next = slow.next.next\\n    return head\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **28ms / 13.9MB** (beats 92% / 99%).\\n```python\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast, slow = head, head\\n        for _ in range(n): fast = fast.next\\n        if not fast: return head.next\\n        while fast.next: fast, slow = fast.next, slow.next\\n        slow.next = slow.next.next\\n        return head\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 36.5MB** (beats 100% / 97%).\\n```java\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head, slow = head;\\n        for (int i = 0; i < n; i++) fast = fast.next;\\n        if (fast == null) return head.next;\\n        while (fast.next != null) {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 10.6MB** (beats 100% / 93%).\\n```c++\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n        for (int i = 0; i < n; i++) fast = fast->next;\\n        if (!fast) return head->next;\\n        while (fast->next) fast = fast->next, slow = slow->next;\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar removeNthFromEnd = function(head, n) {\\n    let fast = head, slow = head\\n    for (let i = 0; i < n; i++) fast = fast.next\\n    if (!fast) return head.next\\n    while (fast.next) fast = fast.next, slow = slow.next\\n    slow.next = slow.next.next\\n    return head\\n};\\n```\n```python\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast, slow = head, head\\n        for _ in range(n): fast = fast.next\\n        if not fast: return head.next\\n        while fast.next: fast, slow = fast.next, slow.next\\n        slow.next = slow.next.next\\n        return head\\n```\n```java\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head, slow = head;\\n        for (int i = 0; i < n; i++) fast = fast.next;\\n        if (fast == null) return head.next;\\n        while (fast.next != null) {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n        for (int i = 0; i < n; i++) fast = fast->next;\\n        if (!fast) return head->next;\\n        while (fast->next) fast = fast->next, slow = slow->next;\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8804,
                "title": "simple-java-solution-in-one-pass",
                "content": "A one pass solution can be done using  pointers. Move one pointer **fast** -->  **n+1** places forward, to maintain a gap of n between the two pointers and then move both at the same speed. Finally, when the fast pointer reaches the end, the slow pointer will be **n+1** places behind - just the right spot for it to be able to skip the next node.\\n\\nSince the question gives that **n** is valid, not too many checks have to be put in place. Otherwise, this would be necessary.\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n        ListNode start = new ListNode(0);\\n        ListNode slow = start, fast = start;\\n        slow.next = head;\\n        \\n        //Move fast in front so that the gap between slow and fast becomes n\\n        for(int i=1; i<=n+1; i++)   {\\n            fast = fast.next;\\n        }\\n        //Move fast to the end, maintaining the gap\\n        while(fast != null) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        //Skip the desired node\\n        slow.next = slow.next.next;\\n        return start.next;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "A one pass solution can be done using  pointers. Move one pointer **fast** -->  **n+1** places forward, to maintain a gap of n between the two pointers and then move both at the same speed. Finally, when the fast pointer reaches the end, the slow pointer will be **n+1** places behind - just the right spot for it to be able to skip the next node.\\n\\nSince the question gives that **n** is valid, not too many checks have to be put in place. Otherwise, this would be necessary.\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n        ListNode start = new ListNode(0);\\n        ListNode slow = start, fast = start;\\n        slow.next = head;\\n        \\n        //Move fast in front so that the gap between slow and fast becomes n\\n        for(int i=1; i<=n+1; i++)   {\\n            fast = fast.next;\\n        }\\n        //Move fast to the end, maintaining the gap\\n        while(fast != null) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        //Skip the desired node\\n        slow.next = slow.next.next;\\n        return start.next;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 8802,
                "title": "3-short-python-solutions",
                "content": "**Value-Shifting - AC in 64 ms**\\n\\nMy first solution is \"cheating\" a little. Instead of really removing the nth *node*, I remove the nth *value*. I recursively determine the indexes (counting from back), then shift the values for all indexes larger than n, and then always drop the head.\\n\\n    class Solution:\\n        def removeNthFromEnd(self, head, n):\\n            def index(node):\\n                if not node:\\n                    return 0\\n                i = index(node.next) + 1\\n                if i > n:\\n                    node.next.val = node.val\\n                return i\\n            index(head)\\n            return head.next\\n\\n---\\n\\n**Index and Remove - AC in 56 ms**\\n\\nIn this solution I recursively determine the indexes again, but this time my helper function removes the nth node. It returns two values. The index, as in my first solution, and the possibly changed head of the remaining list.\\n\\n    class Solution:\\n        def removeNthFromEnd(self, head, n):\\n            def remove(head):\\n                if not head:\\n                    return 0, head\\n                i, head.next = remove(head.next)\\n                return i+1, (head, head.next)[i+1 == n]\\n            return remove(head)[1]\\n\\n---\\n\\n**n ahead - AC in 48 ms**\\n\\nThe standard solution, but without a dummy extra node. Instead, I simply handle the special case of removing the head right after the fast cursor got its head start.\\n\\n    class Solution:\\n        def removeNthFromEnd(self, head, n):\\n            fast = slow = head\\n            for _ in range(n):\\n                fast = fast.next\\n            if not fast:\\n                return head.next\\n            while fast.next:\\n                fast = fast.next\\n                slow = slow.next\\n            slow.next = slow.next.next\\n            return head",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Value-Shifting - AC in 64 ms**\\n\\nMy first solution is \"cheating\" a little. Instead of really removing the nth *node*, I remove the nth *value*. I recursively determine the indexes (counting from back), then shift the values for all indexes larger than n, and then always drop the head.\\n\\n    class Solution:\\n        def removeNthFromEnd(self, head, n):\\n            def index(node):\\n                if not node:\\n                    return 0\\n                i = index(node.next) + 1\\n                if i > n:\\n                    node.next.val = node.val\\n                return i\\n            index(head)\\n            return head.next\\n\\n---\\n\\n**Index and Remove - AC in 56 ms**\\n\\nIn this solution I recursively determine the indexes again, but this time my helper function removes the nth node. It returns two values. The index, as in my first solution, and the possibly changed head of the remaining list.\\n\\n    class Solution:\\n        def removeNthFromEnd(self, head, n):\\n            def remove(head):\\n                if not head:\\n                    return 0, head\\n                i, head.next = remove(head.next)\\n                return i+1, (head, head.next)[i+1 == n]\\n            return remove(head)[1]\\n\\n---\\n\\n**n ahead - AC in 48 ms**\\n\\nThe standard solution, but without a dummy extra node. Instead, I simply handle the special case of removing the head right after the fast cursor got its head start.\\n\\n    class Solution:\\n        def removeNthFromEnd(self, head, n):\\n            fast = slow = head\\n            for _ in range(n):\\n                fast = fast.next\\n            if not fast:\\n                return head.next\\n            while fast.next:\\n                fast = fast.next\\n                slow = slow.next\\n            slow.next = slow.next.next\\n            return head",
                "codeTag": "Java"
            },
            {
                "id": 1164537,
                "title": "short-simple-one-pass-solution-w-explanation-beats-100-no-dummy-node-required",
                "content": "This problem is very similar to the **[1721. Swapping Nodes in a Linked List](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/)** , just that we have to **remove** the kth node from the end instead of swapping it.\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (One-Pointer, Two-Pass)***\\n\\nThis approach is very intuitive and easy to get. \\n\\n* We just iterate in the first-pass to find the length of the linked list - **`len`**.\\n\\n* In the next pass, iterate **`len - n - 1`** nodes from start and delete the next node (which would be *`nth`* node from end).\\n\\n---\\n\\n**C++**\\n```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode* iter = head;\\n\\tint len = 0, i = 1;\\n\\twhile(iter) iter = iter -> next, len++;    // finding the length of linked list\\n\\tif(len == n) return head -> next;          // if head itself is to be deleted, just return head -> next\\n\\tfor(iter = head; i < len - n; i++) iter = iter -> next; // iterate first len-n nodes\\n\\titer -> next = iter -> next -> next;      // remove the nth node from the end\\n\\treturn head;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tptr, length = head, 0\\n\\twhile ptr:\\n\\t\\tptr, length = ptr.next, length + 1\\n\\tif length == n : return head.next\\n\\tptr = head\\n\\tfor i in range(1, length - n):\\n\\t\\tptr = ptr.next\\n\\tptr.next = ptr.next.next\\n\\treturn head\\n```\\n\\n\\n***Time Complexity :*** **`O(N)`**, where, `N` is the number of nodes in the given list. \\n***Space Complexity :*** **`O(1)`**, since only constant space is used.\\n\\n---\\n---\\n\\n\\u2714\\uFE0F ***Solution (Two-Pointer, One-Pass)***\\n\\nWe are required to remove the nth node from the end of list. For this, we need to traverse *`N - n`* nodes from the start of the list, where *`N`* is the length of linked list. We can do this in one-pass as follows -\\n\\n* Let\\'s assign two pointers - **`fast`** and **`slow`** to head. We will first iterate for *`n`* nodes from start using the *`fast`* pointer. \\n\\n* Now, between the *`fast`*  and *`slow`* pointers, **there is a gap of `n` nodes**. Now, just Iterate and increment both the pointers till `fast` reaches the last node. The gap between `fast` and `slow` is still of `n` nodes, meaning that **`slow` is nth node from the last node (which currently is `fast`)**.\\n\\n```\\nFor eg. let the list be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9, and n = 4.\\n\\n1. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n   ^slow               ^fast\\n   |<--gap of n nodes-->|\\n \\n => Now traverse till fast reaches end\\n \\n 2. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n                        ^slow               ^fast\\n                        |<--gap of n nodes-->|\\n\\t\\t\\t\\t\\t\\t\\n\\'slow\\' is at (n+1)th node from end.\\nSo just delete nth node from end by assigning slow -> next as slow -> next -> next (which would remove nth node from end of list).\\n```\\n\\n * Since we have to **delete the nth node from end of list** (And not nth from the last of list!), we just delete the next node to **`slow`** pointer and return the head.\\n\\n---\\n\\n**C++**\\n```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode *fast = head, *slow = head;\\n\\twhile(n--) fast = fast -> next;      // iterate first n nodes using fast\\n\\tif(!fast) return head -> next;       // if fast is already null, it means we have to delete head itself. So, just return next of head\\n\\twhile(fast -> next)                  // iterate till fast reaches the last node of list\\n\\t\\tfast = fast -> next, slow = slow -> next;            \\n\\tslow -> next = slow -> next -> next; // remove the nth node from last\\n\\treturn head;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tfast = slow = head\\n\\tfor i in range(n):\\n\\t\\tfast = fast.next\\n\\tif not fast: return head.next\\n\\twhile fast.next:\\n\\t\\tfast, slow = fast.next, slow.next\\n\\tslow.next = slow.next.next\\n\\treturn head\\n```\\n\\n\\n\\n***Time Complexity :*** **`O(N)`**, where, `N` is the number of nodes in the given list. Although, the time complexity is same as above solution, we have reduced the constant factor in it to half.\\n***Space Complexity :*** **`O(1)`**, since only constant space is used.\\n\\n---\\n\\n**Note :** The Problem only asks us to **remove the node from the linked list and not delete it**. A good question to ask in an interview for this problem would be whether we just need to remove the node from linked list or completely delete it from the memory. Since it has not been stated in this problem if the node is required somewhere else later on, its better to just remove the node from linked list as asked.\\n\\nIf we want to delete the node altogether, then we can just free its memory and point it to NULL before returning from the function.\\n\\n\\n---\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/6c81d074-139d-4de5-96f5-5943f62a2cca_1618736585.2373421.png /></td></tr></table>\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any questions or mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode* iter = head;\\n\\tint len = 0, i = 1;\\n\\twhile(iter) iter = iter -> next, len++;    // finding the length of linked list\\n\\tif(len == n) return head -> next;          // if head itself is to be deleted, just return head -> next\\n\\tfor(iter = head; i < len - n; i++) iter = iter -> next; // iterate first len-n nodes\\n\\titer -> next = iter -> next -> next;      // remove the nth node from the end\\n\\treturn head;\\n}\\n```\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tptr, length = head, 0\\n\\twhile ptr:\\n\\t\\tptr, length = ptr.next, length + 1\\n\\tif length == n : return head.next\\n\\tptr = head\\n\\tfor i in range(1, length - n):\\n\\t\\tptr = ptr.next\\n\\tptr.next = ptr.next.next\\n\\treturn head\\n```\n```\\nFor eg. let the list be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9, and n = 4.\\n\\n1. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n   ^slow               ^fast\\n   |<--gap of n nodes-->|\\n \\n => Now traverse till fast reaches end\\n \\n 2. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n                        ^slow               ^fast\\n                        |<--gap of n nodes-->|\\n\\t\\t\\t\\t\\t\\t\\n\\'slow\\' is at (n+1)th node from end.\\nSo just delete nth node from end by assigning slow -> next as slow -> next -> next (which would remove nth node from end of list).\\n```\n```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode *fast = head, *slow = head;\\n\\twhile(n--) fast = fast -> next;      // iterate first n nodes using fast\\n\\tif(!fast) return head -> next;       // if fast is already null, it means we have to delete head itself. So, just return next of head\\n\\twhile(fast -> next)                  // iterate till fast reaches the last node of list\\n\\t\\tfast = fast -> next, slow = slow -> next;            \\n\\tslow -> next = slow -> next -> next; // remove the nth node from last\\n\\treturn head;\\n}\\n```\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tfast = slow = head\\n\\tfor i in range(n):\\n\\t\\tfast = fast.next\\n\\tif not fast: return head.next\\n\\twhile fast.next:\\n\\t\\tfast, slow = fast.next, slow.next\\n\\tslow.next = slow.next.next\\n\\treturn head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1037986,
                "title": "python-two-pointer-solution-with-comments-easy-to-understand",
                "content": "Please upvote once you get this :)\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast = head\\n        slow = head\\n        # advance fast to nth position\\n        for i in range(n):\\n            fast = fast.next\\n            \\n        if not fast:\\n            return head.next\\n        # then advance both fast and slow now they are nth postions apart\\n        # when fast gets to None, slow will be just before the item to be deleted\\n        while fast.next:\\n            slow = slow.next\\n            fast = fast.next\\n        # delete the node\\n        slow.next = slow.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast = head\\n        slow = head\\n        # advance fast to nth position\\n        for i in range(n):\\n            fast = fast.next\\n            \\n        if not fast:\\n            return head.next\\n        # then advance both fast and slow now they are nth postions apart\\n        # when fast gets to None, slow will be just before the item to be deleted\\n        while fast.next:\\n            slow = slow.next\\n            fast = fast.next\\n        # delete the node\\n        slow.next = slow.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8812,
                "title": "my-short-c-solution",
                "content": "    class Solution\\n    {\\n    public:\\n        ListNode* removeNthFromEnd(ListNode* head, int n)\\n        {\\n            ListNode** t1 = &head, *t2 = head;\\n            for(int i = 1; i < n; ++i)\\n            {\\n                t2 = t2->next;\\n            }\\n            while(t2->next != NULL)\\n            {\\n                t1 = &((*t1)->next);\\n                t2 = t2->next;\\n            }\\n            *t1 = (*t1)->next;\\n            return head;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n    public:\\n        ListNode* removeNthFromEnd(ListNode* head, int n)\\n        {\\n            ListNode** t1 = &head, *t2 = head;\\n            for(int i = 1; i < n; ++i)\\n            {\\n                t2 = t2->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 8843,
                "title": "c-solution-easy-to-understand-with-explanations",
                "content": "<h1>Renewed Solution</h1>\\n\\nThe difference between the final node and the `to_be_delete` node is N. And here the assumption is that n is <b>always</b> valid.\\n\\n`fast` pointer points to the node which is N step away from the `to_be_delete` node.<br>\\n`slow` pointer points to the `to_be_delete` node.\\n\\nThe algorithms is described as below:\\n\\n<b>Firstly</b>, move `fast` pointer N step forward.<br>\\n<b>Secondly</b>,move `fast` and `slow` pointers simultaneously <b>one step a time</b> forward till the `fast` pointer reach the end, which will cause the `slow` pointer points to the previous node of the `to_be_delete` node.\\n\\n<b>Finally</b>, `slow->next = slow->next->next`.\\n\\n    ListNode *removeNthFromEnd(ListNode *head, int n) \\n    {\\n        if (!head)\\n            return nullptr;\\n    \\n        ListNode new_head(-1);\\n        new_head.next = head;\\n\\n        ListNode *slow = &new_head, *fast = &new_head;\\n\\n        for (int i = 0; i < n; i++)\\n            fast = fast->next;\\n\\n        while (fast->next) \\n        {\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n\\n        ListNode *to_de_deleted = slow->next;\\n        slow->next = slow->next->next;\\n        \\n        delete to_be_deleted;\\n\\n        return new_head.next;\\n    }\\n**Fixed : Added code for deleting the N-th node.**",
                "solutionTags": [
                    "C++"
                ],
                "code": "<h1>Renewed Solution</h1>\\n\\nThe difference between the final node and the `to_be_delete` node is N. And here the assumption is that n is <b>always</b> valid.\\n\\n`fast` pointer points to the node which is N step away from the `to_be_delete` node.<br>\\n`slow` pointer points to the `to_be_delete` node.\\n\\nThe algorithms is described as below:\\n\\n<b>Firstly</b>, move `fast` pointer N step forward.<br>\\n<b>Secondly</b>,move `fast` and `slow` pointers simultaneously <b>one step a time</b> forward till the `fast` pointer reach the end, which will cause the `slow` pointer points to the previous node of the `to_be_delete` node.\\n\\n<b>Finally</b>, `slow->next = slow->next->next`.\\n\\n    ListNode *removeNthFromEnd(ListNode *head, int n) \\n    {\\n        if (!head)\\n            return nullptr;\\n    \\n        ListNode new_head(-1);\\n        new_head.next = head;\\n\\n        ListNode *slow = &new_head, *fast = &new_head;\\n\\n        for (int i = 0; i < n; i++)\\n            fast = fast->next;\\n\\n        while (fast->next) \\n        {\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n\\n        ListNode *to_de_deleted = slow->next;\\n        slow->next = slow->next->next;\\n        \\n        delete to_be_deleted;\\n\\n        return new_head.next;\\n    }\\n**Fixed : Added code for deleting the N-th node.**",
                "codeTag": "Unknown"
            },
            {
                "id": 589304,
                "title": "clear-java-solution-with-detailed-explanation",
                "content": "ok lets do this!!\\nso we are given a linked list and an number \\'n\\'\\nthis n is the number of root from last which needs to be removed!!\\nfor example\\n1->2->3->4->5->6->7\\nn=3\\nmeans we have to delete the 3rd node from the last(5th node from the beginning).\\nnow that the question is clear !\\n\\nlets move to the answer!\\npiece of advice-whenever you see a linked list removal type question ,always make a dummy node at the beginning!\\nanyways!\\n\\nLOGIC-\\n1>we keep two pointer slow and fast(both move one at a time)both initially at start of list(at the dummy node)\\n2>we move the fast to n+1 places away from the slow pointer\\n3>we then traverse the list we check if fast is equal to null or not,if it is null we know that the slow pointer has reached just one node  before the node we need to delete!\\n4>then we slow.next=slow.next.next!\\n\\nshould we do a dry run!\\nwhy not!\\nsuppose:\\n1->2->3->4->5->6\\nn=2\\nmake a dummy node with val=0;(we call this start)\\nso now our list looks like\\n0->1->2->3->4->5->6\\nslow ,start , fast all are pointing to 0 valued node!\\nafter executing step 2 of our algorithm we have \\nslow and start still at 0\\nbut fast is at node with val 3;\\nnow we execute step 3\\ndifferent positions of slow and fast is shown below!\\n[slow=1,fast=4]->[slow=2,fast=5]->[slow=3,fast=6]->[slow=4,fast=null]\\nwow!!slow have reached  one node before out target node\\nnow just do slow.next=slow.next.next;\\n\\ndo a couple of dry runs on your own to get the logic!\\n```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n    \\n    ListNode start = new ListNode(0);\\n    ListNode slow = start, fast = start;\\n    start.next = head;\\n    \\n    \\n    for(int i=1; i<=n+1; i++)   {\\n        fast = fast.next;\\n    }\\n    \\n    while(fast != null) {\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n\\n    slow.next = slow.next.next;\\n    return start.next;\\n}\\n```\\n\\nhope it helps!\\nupvote the answer if you like it so that more people can benefit !\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n    \\n    ListNode start = new ListNode(0);\\n    ListNode slow = start, fast = start;\\n    start.next = head;\\n    \\n    \\n    for(int i=1; i<=n+1; i++)   {\\n        fast = fast.next;\\n    }\\n    \\n    while(fast != null) {\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n\\n    slow.next = slow.next.next;\\n    return start.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3492814,
                "title": "beats-100-full-proper-explanation-with-images",
                "content": "# Intuition\\nwe can find the nth node just by one traversal by using two pointer approach.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTake two dummy nodes, who\\u2019s next will be pointing to the head.\\nTake another node to store the head, initially,s a dummy node(start), and the next node will be pointing to the head. The reason why we are using this extra dummy node is that there is an edge case. If the node is equal to the length of the LinkedList, then this slow will point to slow\\u2019s next\\u2192 next. And we can say our dummy start node will be broken and will be connected to the slow next\\u2192 next.\\n\\nStart traversing until the fast pointer reaches the nth node.\\n![image.png](https://assets.leetcode.com/users/images/6d30920b-bf59-4564-897d-869a54148190_1683371160.3817167.png)\\n\\nNow start traversing by one step both of the pointers until the fast pointers reach the end.\\n    \\n![image.png](https://assets.leetcode.com/users/images/6e6e1af9-8863-4eff-988c-decc91e86746_1683371181.7739182.png)\\n\\nWhen the traversal is done, just do the deleting part. Make slow pointers next to the next of the slow pointer to ignore/disconnect the given node.\\n![image.png](https://assets.leetcode.com/users/images/8fd772c7-a44b-4569-99bd-293d4c5dcd32_1683371203.3690717.png)\\n\\n\\nLast, return to the next start.\\nDry Run:  We will be taking the first example for the dry run, so, the LinkedList is [1,2,3,4,5] and the node which has to be deleted is 2 from the last. For the first time, fast ptr starts traversing from node 1 and reaches 2, as it traverses for node number 2, then the slow ptr starts increasing one, and as well as the fast ptr until it reaches the end.\\n\\n1st traversal : fast=3, slow=1\\n2nd traversal : fast=4, slow=2\\n3rd traversal : fast=5, slow=3\\nNow, the slow->next->next will be pointed to the slow->next\\n\\nSo , the new linked list will be [1,2,3,5]\\n\\nNote that the above approach is provided by Striver on Youtube I highly recommend to checkout  his video solutions.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n       ListNode start = new ListNode();\\n        start.next = head;\\n        ListNode fast = start;\\n        ListNode slow = start;     \\n\\n        for(int i = 1; i <= n; ++i)\\n            fast = fast.next;\\n    \\n        while(fast.next != null)\\n        {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        \\n        slow.next = slow.next.next;\\n        \\n        return start.next;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n       ListNode start = new ListNode();\\n        start.next = head;\\n        ListNode fast = start;\\n        ListNode slow = start;     \\n\\n        for(int i = 1; i <= n; ++i)\\n            fast = fast.next;\\n    \\n        while(fast.next != null)\\n        {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        \\n        slow.next = slow.next.next;\\n        \\n        return start.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757145,
                "title": "c-del-n-th-node-from-the-end",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1) .\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* temp=new ListNode();\\n        temp->next=head;\\n\\n        ListNode* fast=temp;\\n        ListNode* slow=temp;\\n\\n        for(int i=1;i<=n;i++){\\n             fast=fast->next;\\n        }\\n\\n        while(fast->next!=NULL){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n\\n        ListNode* gaya=slow->next;\\n        slow->next=slow->next->next;\\n        delete(gaya);\\n        \\n        return temp->next;\\n    }\\n};\\nif it helps plzz don\\'t Forget to upvote it :)\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* temp=new ListNode();\\n        temp->next=head;\\n\\n        ListNode* fast=temp;\\n        ListNode* slow=temp;\\n\\n        for(int i=1;i<=n;i++){\\n             fast=fast->next;\\n        }\\n\\n        while(fast->next!=NULL){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n\\n        ListNode* gaya=slow->next;\\n        slow->next=slow->next->next;\\n        delete(gaya);\\n        \\n        return temp->next;\\n    }\\n};\\nif it helps plzz don\\'t Forget to upvote it :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8806,
                "title": "my-one-pass-solution",
                "content": "    public ListNode RemoveNthFromEnd(ListNode head, int n) {\\n        ListNode h1=head, h2=head;\\n        while(n-->0) h2=h2.next;\\n        if(h2==null)return head.next;  // The head need to be removed, do it.\\n        h2=h2.next;\\n        \\n        while(h2!=null){\\n            h1=h1.next;\\n            h2=h2.next;\\n        }\\n        h1.next=h1.next.next;   // the one after the h1 need to be removed\\n        return head;\\n    }",
                "solutionTags": [],
                "code": "    public ListNode RemoveNthFromEnd(ListNode head, int n) {\\n        ListNode h1=head, h2=head;\\n        while(n-->0) h2=h2.next;\\n        if(h2==null)return head.next;  // The head need to be removed, do it.\\n        h2=h2.next;\\n        \\n        while(h2!=null){\\n            h1=h1.next;\\n            h2=h2.next;\\n        }\\n        h1.next=h1.next.next;   // the one after the h1 need to be removed\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 9032,
                "title": "python-concise-one-pass-solution-with-dummy-head",
                "content": "\\n    def removeNthFromEnd(self, head, n):\\n        fast = slow = dummy = ListNode(0)\\n        dummy.next = head\\n        for _ in xrange(n):\\n            fast = fast.next\\n        while fast and fast.next:\\n            fast = fast.next\\n            slow = slow.next\\n        slow.next = slow.next.next\\n        return dummy.next",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "\\n    def removeNthFromEnd(self, head, n):\\n        fast = slow = dummy = ListNode(0)\\n        dummy.next = head\\n        for _ in xrange(n):\\n            fast = fast.next\\n        while fast and fast.next:\\n            fast = fast.next\\n            slow = slow.next\\n        slow.next = slow.next.next\\n        return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 1401309,
                "title": "single-pass-python-solution-o-n-easy-sr",
                "content": "**Please upvote if you get this**\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        i,j=head, head\\n        for k in range(n):\\n            j = j.next\\n        #now i and j will be at difference n\\n        if j == None: #Only happens when we are supposed to remove the first element\\n            return head.next\\n        while j.next != None:\\n            i = i.next\\n            j = j.next\\n        i.next = i.next.next\\n        return head\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        i,j=head, head\\n        for k in range(n):\\n            j = j.next\\n        #now i and j will be at difference n\\n        if j == None: #Only happens when we are supposed to remove the first element\\n            return head.next\\n        while j.next != None:\\n            i = i.next\\n            j = j.next\\n        i.next = i.next.next\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632794,
                "title": "c-diagram-related-problems",
                "content": "**Approach**\\n- Take two pointers p and q at the head of linked list.\\n- Move q pointers by n to the right. Here n = 2.\\n- Then move both p and q pointers to right until q reaches the end.\\n- Then change pointer of p node to its next to next node.\\n- Don\\'t forget to delete the last nth node.\\n\\n**Digram Representation**\\n\\n![image](https://assets.leetcode.com/users/images/295d90c6-c36f-48b5-a83a-7028b8640f4e_1664330424.1773272.png)\\n\\n**C++ Code**\\n\\n```cpp\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p = head, *q = head;\\n        while (n--) q = q->next;\\n        if (!q) return head->next;\\n        while (q->next) {\\n            p = p->next;\\n            q = q->next;\\n        }\\n        ListNode* toDelete = p->next;\\n        p->next = p->next->next;\\n        delete toDelete;\\n        return head;\\n}\\n```\\n\\n**Related Problems**\\n[1. Linked List Cycle ](https://leetcode.com/problems/linked-list-cycle/)\\n[2. Linked List Cycle II ](https://leetcode.com/problems/linked-list-cycle-ii/)\\n[3. Reorder List ](https://leetcode.com/problems/reorder-list/)\\n[4. Sort List ](https://leetcode.com/problems/sort-list/)\\n[5. Swapping Nodes in a Linked List ](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```cpp\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p = head, *q = head;\\n        while (n--) q = q->next;\\n        if (!q) return head->next;\\n        while (q->next) {\\n            p = p->next;\\n            q = q->next;\\n        }\\n        ListNode* toDelete = p->next;\\n        p->next = p->next->next;\\n        delete toDelete;\\n        return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9000,
                "title": "a-simple-2ms-c-solution",
                "content": "struct ListNode *removeNthFromEnd(struct ListNode *head, int n) {\\n\\n    struct ListNode* front = head;\\n    struct ListNode* behind = head;\\n    \\n    while (front != NULL) {\\n        front = front->next;\\n        \\n        if (n-- < 0) behind = behind->next;\\n    }\\n    if (n == 0) head = head->next;\\n    else behind->next = behind->next->next;\\n    return head;\\n}",
                "solutionTags": [],
                "code": "struct ListNode *removeNthFromEnd(struct ListNode *head, int n) {\\n\\n    struct ListNode* front = head;\\n    struct ListNode* behind = head;\\n    \\n    while (front != NULL) {\\n        front = front->next;\\n        \\n        if (n-- < 0) behind = behind->next;\\n    }\\n    if (n == 0) head = head->next;\\n    else behind->next = behind->next->next;\\n    return head;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 8822,
                "title": "java-solution-1ms-u5bb9-u6613-u7406-u89e3",
                "content": "    //\\u8fd8\\u662f\\u8d70\\u7684\\u5feb\\u7684\\u70b9(fastNode)\\u4e0e\\u8d70\\u5f97\\u6162\\u7684\\u70b9(slowNode)\\u8def\\u7a0b\\u5dee\\u7684\\u95ee\\u9898\\n    \\tpublic static ListNode removeNthFromEnd(ListNode head, int n) {\\n            ListNode headNode = new ListNode(9527);\\n            headNode.next = head;\\n            ListNode fastNode = headNode;\\n            ListNode slowNode = headNode;\\n            while(fastNode.next != null){\\n            \\tif(n <= 0)\\n            \\t\\tslowNode = slowNode.next;\\n            \\tfastNode = fastNode.next;\\n            \\tn--;\\n            }\\n            if(slowNode.next != null)\\n            \\tslowNode.next = slowNode.next.next;\\n            return headNode.next;\\n        }",
                "solutionTags": [],
                "code": "    //\\u8fd8\\u662f\\u8d70\\u7684\\u5feb\\u7684\\u70b9(fastNode)\\u4e0e\\u8d70\\u5f97\\u6162\\u7684\\u70b9(slowNode)\\u8def\\u7a0b\\u5dee\\u7684\\u95ee\\u9898\\n    \\tpublic static ListNode removeNthFromEnd(ListNode head, int n) {\\n            ListNode headNode = new ListNode(9527);\\n            headNode.next = head;\\n            ListNode fastNode = headNode;\\n            ListNode slowNode = headNode;\\n            while(fastNode.next != null){\\n            \\tif(n <= 0)\\n            \\t\\tslowNode = slowNode.next;\\n            \\tfastNode = fastNode.next;\\n            \\tn--;\\n            }\\n            if(slowNode.next != null)\\n            \\tslowNode.next = slowNode.next.next;\\n            return headNode.next;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 510175,
                "title": "python-solution-using-two-pointers",
                "content": "```\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n\\t\\n        slow = head # finally point to the previous node of the target node\\n        fast = head # finally point to the last node\\n        for i in range(n): # let the fast pointer move n steps ahead of the slow pointer\\n            fast = fast.next\\n        \\n        # This situation would happen when we are required to del the first node (n = len(List))\\n        # Also, it can handle the [] case\\n        if not fast:\\n            return slow.next\\n        \\n        while fast.next:\\n            fast = fast.next\\n            slow = slow.next\\n            \\n        slow.next = slow.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n\\t\\n        slow = head # finally point to the previous node of the target node\\n        fast = head # finally point to the last node\\n        for i in range(n): # let the fast pointer move n steps ahead of the slow pointer\\n            fast = fast.next\\n        \\n        # This situation would happen when we are required to del the first node (n = len(List))\\n        # Also, it can handle the [] case\\n        if not fast:\\n            return slow.next\\n        \\n        while fast.next:\\n            fast = fast.next\\n            slow = slow.next\\n            \\n        slow.next = slow.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307508,
                "title": "100-faster-java-code-you-will-not-get-this-much-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n![Screenshot 2023-03-15 185755.png](https://assets.leetcode.com/users/images/7db3581c-70aa-44f5-a6ad-bbc9a83cd0c9_1679056324.048882.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n\\n        // Create a temporary node and a counter to find the length of the linked list\\n        ListNode temp = head;\\n        int count = 0;\\n\\n        // Traverse the linked list and count the number of nodes\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n\\n        // Calculate the index of the node to be removed from the beginning of the list\\n        int len = count - n;\\n\\n        // If the first node needs to be removed, update the head and return\\n        if (len == 0) {\\n            head = head.next;\\n        } \\n        else {\\n             // Traverse the list until the node before the one to be removed\\n            ListNode prev = head;\\n            while (len - 1 != 0) {\\n                prev = prev.next;\\n                len--;\\n            }\\n        // Remove the node by updating the previous node\\'s next pointer\\n        prev.next = prev.next.next;\\n        }\\n\\n    // Return the head node of the modified list\\n    return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n\\n        // Create a temporary node and a counter to find the length of the linked list\\n        ListNode temp = head;\\n        int count = 0;\\n\\n        // Traverse the linked list and count the number of nodes\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n\\n        // Calculate the index of the node to be removed from the beginning of the list\\n        int len = count - n;\\n\\n        // If the first node needs to be removed, update the head and return\\n        if (len == 0) {\\n            head = head.next;\\n        } \\n        else {\\n             // Traverse the list until the node before the one to be removed\\n            ListNode prev = head;\\n            while (len - 1 != 0) {\\n                prev = prev.next;\\n                len--;\\n            }\\n        // Remove the node by updating the previous node\\'s next pointer\\n        prev.next = prev.next.next;\\n        }\\n\\n    // Return the head node of the modified list\\n    return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644146,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\\n        let node = ListNode(0)\\n        node.next = head\\n        \\n        var prev: ListNode? = node\\n        var post: ListNode? = node\\n        \\n        for _ in 0..<n {\\n            guard let next = post?.next else { continue }\\n            post = next\\n        }\\n        \\n        while let postNext = post?.next, let prevNext = prev?.next {\\n            prev = prevNext\\n            post = postNext\\n        }\\n        \\n        prev!.next = prev!.next!.next\\n        \\n        return node.next\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<p>\\n<details>\\n<summary><b>ListNode + Extension</b></summary>\\n\\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n    \\n    // An additional initializer that can be used to implement nodes from an array\\n    public init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```\\n\\n```swift\\nextension ListNode: Equatable {\\n    public static func == (lhs: ListNode, rhs: ListNode) -> Bool {\\n        return lhs.val == rhs.val && lhs.next == rhs.next\\n    }\\n}\\n```\\n\\n</details>\\n</p>\\n\\n<hr>\\n\\n<p>\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<br>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.034 (0.036) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.removeNthFromEnd(ListNode([1,2,3,4,5]), 2)\\n        XCTAssertEqual(value, ListNode([1,2,3,5]))\\n    }\\n    func test1() {\\n        let value = solution.removeNthFromEnd(ListNode([1]), 1)\\n        XCTAssertEqual(value, ListNode([]))\\n    }\\n    func test2() {\\n        let value = solution.removeNthFromEnd(ListNode([1,2]), 1)\\n        XCTAssertEqual(value, ListNode([1]))\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\\n        let node = ListNode(0)\\n        node.next = head\\n        \\n        var prev: ListNode? = node\\n        var post: ListNode? = node\\n        \\n        for _ in 0..<n {\\n            guard let next = post?.next else { continue }\\n            post = next\\n        }\\n        \\n        while let postNext = post?.next, let prevNext = prev?.next {\\n            prev = prevNext\\n            post = postNext\\n        }\\n        \\n        prev!.next = prev!.next!.next\\n        \\n        return node.next\\n    }\\n}\\n```\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n    \\n    // An additional initializer that can be used to implement nodes from an array\\n    public init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```\n```swift\\nextension ListNode: Equatable {\\n    public static func == (lhs: ListNode, rhs: ListNode) -> Bool {\\n        return lhs.val == rhs.val && lhs.next == rhs.next\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.removeNthFromEnd(ListNode([1,2,3,4,5]), 2)\\n        XCTAssertEqual(value, ListNode([1,2,3,5]))\\n    }\\n    func test1() {\\n        let value = solution.removeNthFromEnd(ListNode([1]), 1)\\n        XCTAssertEqual(value, ListNode([]))\\n    }\\n    func test2() {\\n        let value = solution.removeNthFromEnd(ListNode([1,2]), 1)\\n        XCTAssertEqual(value, ListNode([1]))\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 612328,
                "title": "python-go-js-c-o-n-by-two-pointers-w-visualization",
                "content": "O(n) one-pass by two-pointers and delay\\n\\n---\\n\\n**Hint**:\\n\\nThink of **two-pointers** with **n-step delay**.\\n\\nFirst pointer keeps going till the end.\\nSecond pointer traverses to the previous node of the one being removed with n-step delay.\\n\\nWhen first pointer reach the end, the second one will be on the right position.\\nThen update linkage of second pointer and remove the N-th node from the end.\\n\\n---\\n\\n**Visualization & Diagram**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588588180.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588588255.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588588288.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588588310.png)\\n\\n---\\n\\n**Implementation** by two-pointers and delay in Python:\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        \\n        # use dummy head will make the removal of head node easier\\n        dummy_head = ListNode(-1)\\n        dummy_head.next = head\\n        \\n        # cur keeps iteration till the end\\n        # prev_of_removal traverses to the previous node of the one of being removed\\n        cur, prev_of_removal = dummy_head, dummy_head\\n        \\n        \\n        while cur.next != None:\\n            \\n            # n-step delay for prev_of_removal\\n            if n <= 0:\\n                prev_of_removal = prev_of_removal.next\\n                \\n            cur = cur.next\\n            \\n            n -=1\\n        \\n        \\n        # Remove the N-th node from end of list\\n        n_th_node = prev_of_removal.next\\n        prev_of_removal.next = n_th_node.next\\n        \\n        del n_th_node\\n        \\n        return dummy_head.next\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    \\n    // use dummy head will make the removal of head node easier\\n    let dummyHead = new ListNode( -1, head);\\n    \\n    // cur keeps iteration till the end\\n    // prev_of_removal traverses to the previous node of the one of being removed    \\n    let cur = dummyHead;\\n    let prevOfRemoval = dummyHead;\\n    \\n    while( cur.next != null ){\\n        \\n        // n-step delay for prevOfRemoval\\n        if( n <= 0 ){\\n            prevOfRemoval = prevOfRemoval.next;\\n        }\\n        \\n        cur = cur.next;\\n        \\n        // update counter of n-step delay\\n        n -= 1;\\n    }\\n    \\n    \\n    nThNode = prevOfRemoval.next;\\n    prevOfRemoval.next = nThNode.next;\\n    \\n    return dummyHead.next;\\n    \\n};\\n```\\n\\n---\\n\\n**Implementation** by two-pointers and delay in Go:\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\n\\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\\n    \\n    dummyHead := &ListNode{-1, head}\\n    \\n    cur, prevOfRemoval := dummyHead, dummyHead\\n    \\n    for cur.Next != nil{\\n        \\n        // n step delay for prevOfRemoval\\n        if n <= 0 {\\n            prevOfRemoval = prevOfRemoval.Next\\n        }\\n        \\n        cur = cur.Next\\n        \\n        n -= 1\\n    }\\n    \\n    // Remove the N-th node from end of list\\n    nthNode := prevOfRemoval.Next\\n    prevOfRemoval.Next = nthNode.Next\\n    \\n    return dummyHead.Next\\n    \\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        \\n        // use dummy head will make the removal of head node easier\\n        ListNode* dummyHead = new ListNode(-1, head);\\n        \\n        // cur keeps iteration till the end\\n        // prevOfRemoval traverses to the previous node of the one of being removied\\n        ListNode* cur = dummyHead;\\n        ListNode* prevOfRemoval = dummyHead;\\n        \\n        while( cur->next != nullptr ){\\n            \\n            // n-step delay for prevOfRemoval\\n            if( n <= 0 ){\\n                prevOfRemoval = prevOfRemoval->next;\\n            }\\n            \\n            cur = cur->next;\\n            \\n            // update counter of n step delay\\n            n -= 1;\\n        }\\n        \\n        // Remove the n-th node from end of list\\n        ListNode* nThNode = prevOfRemoval->next;\\n        prevOfRemoval->next = nThNode->next;\\n        \\n        delete nThNode;\\n        \\n        return dummyHead->next;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        \\n        # use dummy head will make the removal of head node easier\\n        dummy_head = ListNode(-1)\\n        dummy_head.next = head\\n        \\n        # cur keeps iteration till the end\\n        # prev_of_removal traverses to the previous node of the one of being removed\\n        cur, prev_of_removal = dummy_head, dummy_head\\n        \\n        \\n        while cur.next != None:\\n            \\n            # n-step delay for prev_of_removal\\n            if n <= 0:\\n                prev_of_removal = prev_of_removal.next\\n                \\n            cur = cur.next\\n            \\n            n -=1\\n        \\n        \\n        # Remove the N-th node from end of list\\n        n_th_node = prev_of_removal.next\\n        prev_of_removal.next = n_th_node.next\\n        \\n        del n_th_node\\n        \\n        return dummy_head.next\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    \\n    // use dummy head will make the removal of head node easier\\n    let dummyHead = new ListNode( -1, head);\\n    \\n    // cur keeps iteration till the end\\n    // prev_of_removal traverses to the previous node of the one of being removed    \\n    let cur = dummyHead;\\n    let prevOfRemoval = dummyHead;\\n    \\n    while( cur.next != null ){\\n        \\n        // n-step delay for prevOfRemoval\\n        if( n <= 0 ){\\n            prevOfRemoval = prevOfRemoval.next;\\n        }\\n        \\n        cur = cur.next;\\n        \\n        // update counter of n-step delay\\n        n -= 1;\\n    }\\n    \\n    \\n    nThNode = prevOfRemoval.next;\\n    prevOfRemoval.next = nThNode.next;\\n    \\n    return dummyHead.next;\\n    \\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\n\\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\\n    \\n    dummyHead := &ListNode{-1, head}\\n    \\n    cur, prevOfRemoval := dummyHead, dummyHead\\n    \\n    for cur.Next != nil{\\n        \\n        // n step delay for prevOfRemoval\\n        if n <= 0 {\\n            prevOfRemoval = prevOfRemoval.Next\\n        }\\n        \\n        cur = cur.Next\\n        \\n        n -= 1\\n    }\\n    \\n    // Remove the N-th node from end of list\\n    nthNode := prevOfRemoval.Next\\n    prevOfRemoval.Next = nthNode.Next\\n    \\n    return dummyHead.Next\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        \\n        // use dummy head will make the removal of head node easier\\n        ListNode* dummyHead = new ListNode(-1, head);\\n        \\n        // cur keeps iteration till the end\\n        // prevOfRemoval traverses to the previous node of the one of being removied\\n        ListNode* cur = dummyHead;\\n        ListNode* prevOfRemoval = dummyHead;\\n        \\n        while( cur->next != nullptr ){\\n            \\n            // n-step delay for prevOfRemoval\\n            if( n <= 0 ){\\n                prevOfRemoval = prevOfRemoval->next;\\n            }\\n            \\n            cur = cur->next;\\n            \\n            // update counter of n step delay\\n            n -= 1;\\n        }\\n        \\n        // Remove the n-th node from end of list\\n        ListNode* nThNode = prevOfRemoval->next;\\n        prevOfRemoval->next = nThNode->next;\\n        \\n        delete nThNode;\\n        \\n        return dummyHead->next;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734524,
                "title": "0ms-faster-than-100-java-easy-sol-only-iteration-no-stacks",
                "content": "Please **Upvote** if it helped you.\\n\\n```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n        int count = 0; // creating a counter variable to get the number of Nodes\\n        \\n        ListNode list = head;  // here creating a Node that will point to the head Node, so the list is now pointing to the head Node\\n        \\n        while(list != null) {    // as list is pointing to head Node and I wanna reach to the end Node, \\n                                // I will run a loop starting from head Node until the end of the list i.e. until the list becomes null\\n            \\n            list = list.next;   // this statement will make \"list\" point to the next Node ( like in i++, if i is 1 then it will become 2 )\\n                                // before list ---> head..... now list ---> head.next ( for easy understanding )\\n            count++;            // as we\\'ll go forward, we\\'ll keep on increasing our counter variable to know the size of the list\\n        }\\n        \\n        int node = count - n;   // this is position of required Node from the start \\n                                // if list.size() == 9 and we need to delete 2nd element from end\\n                                // node = 9 (size) - 2 (end position)  == 7 (position from start)\\n        \\n        if( node == 0) {        // suppose in above example position from end is 9\\n                                // means position from start ==> 9-9 = 0\\n                                // we have to delete the first element that is head so we\\'ll simply return head.next \\n                                \\n            return head.next;   // list that will pass the whole list except head because we wanna delete it so head.next \\n                                // as mentioned earlier head.next will point to second Node head here\\n\\n        }\\n        list = head;            // now if you remember, we have iterated through this list pointer to know the size, so it will be pointing to the \\n                                // last Node, in this statement I made sure that it again will point to the head Node ( Now you can understand why \\n                                // we created a seperate Node \"list\" and not used the head Node in the argument\\n        \\n        while(node-- > 1) {     // here I\\'m simply running a loop till node becomes less than 1 (not 0 because we need to go the Node before the \\n                                // Node we wanna delete ( like if we wanna delete 7th Node so we\\'ll go to Node 6 ) you\\'ll see why\\n            list = list.next;   // now the list Node will point to the 6th Node if we wanna delete 7th, after this loop completes\\n        }\\n        list.next = list.next.next;     // simply understand it by the notations below\\n                                        // current situation :-  list ----> Node (6th)\\n                                        //                       list.next = 7th Node\\n                                        //                       list.next.next = 8th Node ( null if not present )\\n                                        //  so here\\'s the basic logic  :- if we wanna remove 7th Node we\\'ll just cut it\\'s link from 6th Node \\n                                        //  and we\\'ll make our 8th Node as 7th by pointing 6th Node\\'s next to the 8th Node so 6th ----> 8th \\n                                        \\n        return head;                    // we can\\'t return \"list\" for reasons explained earlier beacaue currently list is pointing to 6th Node\\n                                        // and we have to return the starting Node so we\\'ll return head Node\\n                                        // if you\\'re wondering how? then let me make this also clear that \"list\" is not a copy of head, it\\'s just pointing \\n                                        // to head Node, so the changes made will also reflect in the head Node\\n                                        // I hope I explained everything, so Please Upvote if you haven\\'t already\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n        int count = 0; // creating a counter variable to get the number of Nodes\\n        \\n        ListNode list = head;  // here creating a Node that will point to the head Node, so the list is now pointing to the head Node\\n        \\n        while(list != null) {    // as list is pointing to head Node and I wanna reach to the end Node, \\n                                // I will run a loop starting from head Node until the end of the list i.e. until the list becomes null\\n            \\n            list = list.next;   // this statement will make \"list\" point to the next Node ( like in i++, if i is 1 then it will become 2 )\\n                                // before list ---> head..... now list ---> head.next ( for easy understanding )\\n            count++;            // as we\\'ll go forward, we\\'ll keep on increasing our counter variable to know the size of the list\\n        }\\n        \\n        int node = count - n;   // this is position of required Node from the start \\n                                // if list.size() == 9 and we need to delete 2nd element from end\\n                                // node = 9 (size) - 2 (end position)  == 7 (position from start)\\n        \\n        if( node == 0) {        // suppose in above example position from end is 9\\n                                // means position from start ==> 9-9 = 0\\n                                // we have to delete the first element that is head so we\\'ll simply return head.next \\n                                \\n            return head.next;   // list that will pass the whole list except head because we wanna delete it so head.next \\n                                // as mentioned earlier head.next will point to second Node head here\\n\\n        }\\n        list = head;            // now if you remember, we have iterated through this list pointer to know the size, so it will be pointing to the \\n                                // last Node, in this statement I made sure that it again will point to the head Node ( Now you can understand why \\n                                // we created a seperate Node \"list\" and not used the head Node in the argument\\n        \\n        while(node-- > 1) {     // here I\\'m simply running a loop till node becomes less than 1 (not 0 because we need to go the Node before the \\n                                // Node we wanna delete ( like if we wanna delete 7th Node so we\\'ll go to Node 6 ) you\\'ll see why\\n            list = list.next;   // now the list Node will point to the 6th Node if we wanna delete 7th, after this loop completes\\n        }\\n        list.next = list.next.next;     // simply understand it by the notations below\\n                                        // current situation :-  list ----> Node (6th)\\n                                        //                       list.next = 7th Node\\n                                        //                       list.next.next = 8th Node ( null if not present )\\n                                        //  so here\\'s the basic logic  :- if we wanna remove 7th Node we\\'ll just cut it\\'s link from 6th Node \\n                                        //  and we\\'ll make our 8th Node as 7th by pointing 6th Node\\'s next to the 8th Node so 6th ----> 8th \\n                                        \\n        return head;                    // we can\\'t return \"list\" for reasons explained earlier beacaue currently list is pointing to 6th Node\\n                                        // and we have to return the starting Node so we\\'ll return head Node\\n                                        // if you\\'re wondering how? then let me make this also clear that \"list\" is not a copy of head, it\\'s just pointing \\n                                        // to head Node, so the changes made will also reflect in the head Node\\n                                        // I hope I explained everything, so Please Upvote if you haven\\'t already\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 449061,
                "title": "simple-and-fast-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n\\t\\t// move fast pointer to the n + 1 element\\n        while (n--) { fast = fast->next; }\\n        \\n        // handle edge case: given n is always valid, \\n        // if fast reached the end, we need to remove the first element\\n        if (fast == nullptr) return head->next;\\n\\n        // move both pointers at the same time maintaing the difference\\n        while (fast->next != nullptr) {\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        \\n        // slow will be pointing to the element before the one we want to remove\\n        slow->next = slow->next->next;\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n\\t\\t// move fast pointer to the n + 1 element\\n        while (n--) { fast = fast->next; }\\n        \\n        // handle edge case: given n is always valid, \\n        // if fast reached the end, we need to remove the first element\\n        if (fast == nullptr) return head->next;\\n\\n        // move both pointers at the same time maintaing the difference\\n        while (fast->next != nullptr) {\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        \\n        // slow will be pointing to the element before the one we want to remove\\n        slow->next = slow->next->next;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524116,
                "title": "javascript-one-pass-two-pointer",
                "content": "**algorithm**\\n1. To remove n-th node from the end, send node `hare` as far as `n`.\\n2. Move node `curr` and `hare` in same speed until `hare` gets the last node.\\n3. Since `curr` and `hare` has gap as `n`, `curr` has n+1-th node from the end when `hare` has 1th node from the end. So change `curr.next` to `curr.next.next`.\\n\\n**edge case**\\n`n = 3` `linked list = [1,2,3]`\\n- When `n` is same with the length of the list. We need to remove first element, instead remove next element of `curr`.\\n- In this case, you can find that `hare` would be `null`, because the last element of list points `null` such as `[1,2,3,null]`\\n\\n**complexity**\\n- Time complexity: **O(N)**\\n- Space complexity: **O(1)**\\n```JavaScript\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    let hare = head, curr = head;\\n    while (n--) {\\n        hare = hare.next;\\n    }\\n    while (hare && hare.next) {\\n        curr = curr.next;\\n        hare = hare.next;\\n    }\\n    if (!hare) {\\n        head = head.next;\\n    } else {\\n        curr.next = curr.next ? curr.next.next : null;\\n    }\\n    return head;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    let hare = head, curr = head;\\n    while (n--) {\\n        hare = hare.next;\\n    }\\n    while (hare && hare.next) {\\n        curr = curr.next;\\n        hare = hare.next;\\n    }\\n    if (!hare) {\\n        head = head.next;\\n    } else {\\n        curr.next = curr.next ? curr.next.next : null;\\n    }\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1651738,
                "title": "c-simplest-solution-one-pass-two-pointer-technique",
                "content": "* To solve this problem in one-pass & O(n) space, we need to find a way to both reach the end of the linked list & reach the nth node from the end simultaneoulsy.\\n* To do that, we initialize 2 pointers ```*fast``` & ```*slow``` both pointing to the head of the linked lits, the stagger the both by ```n``` nodes, so that ```fast``` is ```n``` nodes ahead of ```slow```.\\n* Doing this will cause ```slow``` to reach the ```n```\\'th node from the end at the same time that ```fast``` reaches the end.\\n* Since we will need access to the node before the target node in order to remove the target node, we are going to loop until ```fast->next != NULL``` rather than until ```fast != null```, so that we stop one node earlier.\\n* This method will be a problem when ```n``` is same as the no. of nodes in the linked list, which would make the first node the target node, and hence it\\'s not possible to find the node before the target node. If that\\'s the case, we can just return ```head->next```\\n\\n**Time Complexity :** O(N) - N = sz\\n\\n**Auxiliary Space :** O(1)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n        \\n        for(int i=0; i<n; i++) fast = fast->next;\\n        \\n        if(!fast) return head->next;\\n        \\n        while(fast->next) fast = fast->next, slow = slow->next;\\n        \\n        slow->next = slow->next->next;\\n        \\n        return head;\\n    }\\n};\\n```\\n\\n**If you like my solution & explanation, please upvote my post :)**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```*fast```\n```*slow```\n```n```\n```fast```\n```n```\n```slow```\n```slow```\n```n```\n```fast```\n```fast->next != NULL```\n```fast != null```\n```n```\n```head->next```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n        \\n        for(int i=0; i<n; i++) fast = fast->next;\\n        \\n        if(!fast) return head->next;\\n        \\n        while(fast->next) fast = fast->next, slow = slow->next;\\n        \\n        slow->next = slow->next->next;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 9090,
                "title": "my-simple-java-solution-in-one-pass",
                "content": "     public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode fast=dummy;\\n        ListNode slow=dummy;\\n        int temp=n;\\n        for(;fast.next!=null;temp--){\\n            if(temp<=0){ //control\\n                slow=slow.next;\\n            }\\n            fast=fast.next;\\n        }\\n        slow.next=slow.next.next;//delete Nth\\n        return dummy.next;\\n    }",
                "solutionTags": [],
                "code": "     public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode fast=dummy;\\n        ListNode slow=dummy;\\n        int temp=n;\\n        for(;fast.next!=null;temp--){\\n            if(temp<=0){ //control\\n                slow=slow.next;\\n            }\\n            fast=fast.next;\\n        }\\n        slow.next=slow.next.next;//delete Nth\\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2633625,
                "title": "c-dear-deleted-node-rest-in-peace",
                "content": "### Approach 1: actually delete the removed node\\n\\nThis solution is similar to many others, with one difference: actually delete the removed node. :)\\n\\n```cpp\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode prehead(-1, head);\\n        ListNode* prev = &prehead;\\n        for (int i = 0; i < n; ++i) {\\n            head = head->next;\\n        }\\n        while (head) {\\n            head = head->next;\\n            prev = prev->next;\\n        }\\n        ListNode* rip = prev->next;\\n        prev->next = prev->next->next;\\n        // Don\\'t be that person that leaks memory. :)\\n        delete rip;\\n        return prehead.next;\\n    }\\n```\\n\\n_As always: Feedback, questions, and comments are welcome._\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/Nqm4jJcyBf)!**",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```cpp\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode prehead(-1, head);\\n        ListNode* prev = &prehead;\\n        for (int i = 0; i < n; ++i) {\\n            head = head->next;\\n        }\\n        while (head) {\\n            head = head->next;\\n            prev = prev->next;\\n        }\\n        ListNode* rip = prev->next;\\n        prev->next = prev->next->next;\\n        // Don\\'t be that person that leaks memory. :)\\n        delete rip;\\n        return prehead.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1708527,
                "title": "java-solution-100-faster-with-explanation-also-asked-in-interviews",
                "content": "**Upvote if you found this use full**\\n\\n**Also asked in Adobe, Amazon, Arcesium, Factset, Intuit, Zoho, HCL**\\n\\n```\\n// Steps-\\n    \\n// Use a dummy variable pointing to head\\n\\n// Use two pointer fast and slow pointing to dummy variable . Move first pointer for n steps\\n\\n// Then start moving both until first pointer reaches the last node and slow pointer reaches (size of list - n)th node.\\n    \\n// Then delete the next node of slow and return dummy.next;\\n\\n\\n// Concept-\\n    \\n// When you move the fast pointer to nth node, the remaining nodes to traverse is (size_of_linked_list - n).     \\n// After that, when you start moving slow pointer and fast pointer by 1 node each, \\n// it is guaranteed that slow pointer will cover a distance of (size_of_linked_list - n) nodes. And that\\'s node we want to remove.\\n\\n\\nclass Solution \\n{\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        if(head.next==null)\\n            return null;\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n        ListNode slow=dummy;\\n        ListNode fast=dummy;\\n        \\n        for(int i=1;i<=n;i++)\\n            fast=fast.next;\\n        \\n        while(fast.next!=null)\\n        {\\n            fast=fast.next;\\n            slow=slow.next;\\n        }\\n        \\n        slow.next=slow.next.next;\\n        return dummy.next;\\n    }\\n}\\n\\n```\\n\\n**Without using dummy node**\\n\\n```\\nclass Solution \\n{\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        if(head.next==null)\\n            return null;\\n        \\n        ListNode slow=head;\\n        ListNode fast=head;\\n        \\n        for(int i=1;i<=n;i++)\\n            fast=fast.next;\\n        \\n        // edge case handeled when we have to delete the 1st node i.e n=size of linked list\\n        \\n        if(fast==null)\\n            return head.next;\\n        \\n        while(fast!=null && fast.next!=null)\\n        {\\n            fast=fast.next;\\n            slow=slow.next;\\n        }\\n        \\n        slow.next=slow.next.next;\\n        return head;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Steps-\\n    \\n// Use a dummy variable pointing to head\\n\\n// Use two pointer fast and slow pointing to dummy variable . Move first pointer for n steps\\n\\n// Then start moving both until first pointer reaches the last node and slow pointer reaches (size of list - n)th node.\\n    \\n// Then delete the next node of slow and return dummy.next;\\n\\n\\n// Concept-\\n    \\n// When you move the fast pointer to nth node, the remaining nodes to traverse is (size_of_linked_list - n).     \\n// After that, when you start moving slow pointer and fast pointer by 1 node each, \\n// it is guaranteed that slow pointer will cover a distance of (size_of_linked_list - n) nodes. And that\\'s node we want to remove.\\n\\n\\nclass Solution \\n{\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        if(head.next==null)\\n            return null;\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n        ListNode slow=dummy;\\n        ListNode fast=dummy;\\n        \\n        for(int i=1;i<=n;i++)\\n            fast=fast.next;\\n        \\n        while(fast.next!=null)\\n        {\\n            fast=fast.next;\\n            slow=slow.next;\\n        }\\n        \\n        slow.next=slow.next.next;\\n        return dummy.next;\\n    }\\n}\\n\\n```\n```\\nclass Solution \\n{\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        if(head.next==null)\\n            return null;\\n        \\n        ListNode slow=head;\\n        ListNode fast=head;\\n        \\n        for(int i=1;i<=n;i++)\\n            fast=fast.next;\\n        \\n        // edge case handeled when we have to delete the 1st node i.e n=size of linked list\\n        \\n        if(fast==null)\\n            return head.next;\\n        \\n        while(fast!=null && fast.next!=null)\\n        {\\n            fast=fast.next;\\n            slow=slow.next;\\n        }\\n        \\n        slow.next=slow.next.next;\\n        return head;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588515,
                "title": "go",
                "content": "```\\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {    \\n    dummy := &ListNode{Next: head}\\n    slow, fast := dummy, dummy\\n    \\n    for i := 0; i <= n; i++ {\\n        fast = fast.Next\\n    }\\n    \\n    for fast != nil {\\n        fast = fast.Next\\n        slow = slow.Next\\n    }\\n    \\n    slow.Next = slow.Next.Next\\n    \\n    return dummy.Next\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {    \\n    dummy := &ListNode{Next: head}\\n    slow, fast := dummy, dummy\\n    \\n    for i := 0; i <= n; i++ {\\n        fast = fast.Next\\n    }\\n    \\n    for fast != nil {\\n        fast = fast.Next\\n        slow = slow.Next\\n    }\\n    \\n    slow.Next = slow.Next.Next\\n    \\n    return dummy.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9094,
                "title": "here-is-my-solution-in-c-one-pass-2-pointers-with-comments",
                "content": "    struct ListNode* removeNthFromEnd(struct ListNode* head, int n) {\\n    struct ListNode* HEAD1;\\n    struct ListNode* HEAD2;\\n    HEAD1=head;\\n    HEAD2=head;\\n    for(int i=0;i<n;i++) //take pointer HEAD1 n places ahead of HEAD2\\n    {   \\n        HEAD1=HEAD1->next;\\n        if(!HEAD1)          // when we have to delete the first node\\n        return head->next;\\n    }  \\n    while(HEAD1->next)   //take HEAD1 to last node so that HEAD2 is 1 behind the node we want to delete\\n    {   \\n        HEAD2=HEAD2->next;\\n        HEAD1=HEAD1->next;\\n        \\n    }\\n    HEAD2->next=HEAD2->next->next; // delete the node next to HEAD2\\n    \\n    \\n    return head;\\n    \\n}",
                "solutionTags": [],
                "code": "    struct ListNode* removeNthFromEnd(struct ListNode* head, int n) {\\n    struct ListNode* HEAD1;\\n    struct ListNode* HEAD2;\\n    HEAD1=head;\\n    HEAD2=head;\\n    for(int i=0;i<n;i++) //take pointer HEAD1 n places ahead of HEAD2\\n    {   \\n        HEAD1=HEAD1->next;\\n        if(!HEAD1)          // when we have to delete the first node\\n        return head->next;\\n    }  \\n    while(HEAD1->next)   //take HEAD1 to last node so that HEAD2 is 1 behind the node we want to delete\\n    {   \\n        HEAD2=HEAD2->next;\\n        HEAD1=HEAD1->next;\\n        \\n    }\\n    HEAD2->next=HEAD2->next->next; // delete the node next to HEAD2\\n    \\n    \\n    return head;\\n    \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1164532,
                "title": "remove-nth-node-from-end-of-list-simple-one-pass-solution-w-explanation",
                "content": "This problem is very similar to the **[1721. Swapping Nodes in a Linked List](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/)** (which was given in *March LeetCoding Challenge 2021* as well), just that we have to **remove** the kth node from the end instead of swapping it.\\n\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (One-Pointer, Two-Pass)***\\n\\nThis approach is very intuitive and easy to get. \\n\\n* We just iterate in the first-pass to find the length of the linked list - **`len`**.\\n\\n* In the next pass, iterate **`len - n - 1`** nodes from start and delete the next node (which would be *`nth`* node from end).\\n\\n---\\n\\n**C++**\\n```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode* iter = head;\\n\\tint len = 0, i = 1;\\n\\twhile(iter) iter = iter -> next, len++;    // finding the length of linked list\\n\\tif(len == n) return head -> next;          // if head itself is to be deleted, just return head -> next\\n\\tfor(iter = head; i < len - n; i++) iter = iter -> next; // iterate first len-n nodes\\n\\titer -> next = iter -> next -> next;      // remove the nth node from the end\\n\\treturn head;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tptr, length = head, 0\\n\\twhile ptr:\\n\\t\\tptr, length = ptr.next, length + 1\\n\\tif length == n : return head.next\\n\\tptr = head\\n\\tfor i in range(1, length - n):\\n\\t\\tptr = ptr.next\\n\\tptr.next = ptr.next.next\\n\\treturn head\\n```\\n\\n\\n***Time Complexity :*** **`O(N)`**, where, `N` is the number of nodes in the given list. \\n***Space Complexity :*** **`O(1)`**, since only constant space is used.\\n\\n---\\n---\\n\\n\\u2714\\uFE0F ***Solution (Two-Pointer, One-Pass)***\\n\\nWe are required to remove the nth node from the end of list. For this, we need to traverse *`N - n`* nodes from the start of the list, where *`N`* is the length of linked list. We can do this in one-pass as follows -\\n\\n* Let\\'s assign two pointers - **`fast`** and **`slow`** to head. We will first iterate for *`n`* nodes from start using the *`fast`* pointer. \\n\\n* Now, between the *`fast`*  and *`slow`* pointers, **there is a gap of `n` nodes**. Now, just Iterate and increment both the pointers till `fast` reaches the last node. The gap between `fast` and `slow` is still of `n` nodes, meaning that **`slow` is nth node from the last node (which currently is `fast`)**.\\n\\n```\\nFor eg. let the list be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9, and n = 4.\\n\\n1. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n   ^slow               ^fast\\n   |<--gap of n nodes-->|\\n \\n => Now traverse till fast reaches end\\n \\n 2. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n                        ^slow               ^fast\\n                        |<--gap of n nodes-->|\\n\\t\\t\\t\\t\\t\\t\\n\\'slow\\' is at (n+1)th node from end.\\nSo just delete nth node from end by assigning slow -> next as slow -> next -> next (which would remove nth node from end of list).\\n```\\n\\n * Since we have to **delete the nth node from end of list** (And not nth from the last of list!), we just delete the next node to **`slow`** pointer and return the head.\\n\\n---\\n\\n**C++**\\n```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode *fast = head, *slow = head;\\n\\twhile(n--) fast = fast -> next;      // iterate first n nodes using fast\\n\\tif(!fast) return head -> next;       // if fast is already null, it means we have to delete head itself. So, just return next of head\\n\\twhile(fast -> next)                  // iterate till fast reaches the last node of list\\n\\t\\tfast = fast -> next, slow = slow -> next;            \\n\\tslow -> next = slow -> next -> next; // remove the nth node from last\\n\\treturn head;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tfast = slow = head\\n\\tfor i in range(n):\\n\\t\\tfast = fast.next\\n\\tif not fast: return head.next\\n\\twhile fast.next:\\n\\t\\tfast, slow = fast.next, slow.next\\n\\tslow.next = slow.next.next\\n\\treturn head\\n```\\n\\n\\n\\n***Time Complexity :*** **`O(N)`**, where, `N` is the number of nodes in the given list. Although, the time complexity is same as above solution, we have reduced the constant factor in it to half.\\n***Space Complexity :*** **`O(1)`**, since only constant space is used.\\n\\n---\\n\\n**Note :** The Problem only asks us to **remove the node from the linked list and not delete it**. A good question to ask in an interview for this problem would be whether we just need to remove the node from linked list or completely delete it from the memory. Since it has not been stated in this problem if the node is required somewhere else later on, its better to just remove the node from linked list as asked.\\n\\nIf we want to delete the node altogether, then we can just free its memory and point it to NULL before returning from the function.\\n\\n\\n---\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/6c81d074-139d-4de5-96f5-5943f62a2cca_1618736585.2373421.png /></td></tr></table>\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any questions or mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode* iter = head;\\n\\tint len = 0, i = 1;\\n\\twhile(iter) iter = iter -> next, len++;    // finding the length of linked list\\n\\tif(len == n) return head -> next;          // if head itself is to be deleted, just return head -> next\\n\\tfor(iter = head; i < len - n; i++) iter = iter -> next; // iterate first len-n nodes\\n\\titer -> next = iter -> next -> next;      // remove the nth node from the end\\n\\treturn head;\\n}\\n```\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tptr, length = head, 0\\n\\twhile ptr:\\n\\t\\tptr, length = ptr.next, length + 1\\n\\tif length == n : return head.next\\n\\tptr = head\\n\\tfor i in range(1, length - n):\\n\\t\\tptr = ptr.next\\n\\tptr.next = ptr.next.next\\n\\treturn head\\n```\n```\\nFor eg. let the list be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9, and n = 4.\\n\\n1. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n   ^slow               ^fast\\n   |<--gap of n nodes-->|\\n \\n => Now traverse till fast reaches end\\n \\n 2. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n                        ^slow               ^fast\\n                        |<--gap of n nodes-->|\\n\\t\\t\\t\\t\\t\\t\\n\\'slow\\' is at (n+1)th node from end.\\nSo just delete nth node from end by assigning slow -> next as slow -> next -> next (which would remove nth node from end of list).\\n```\n```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode *fast = head, *slow = head;\\n\\twhile(n--) fast = fast -> next;      // iterate first n nodes using fast\\n\\tif(!fast) return head -> next;       // if fast is already null, it means we have to delete head itself. So, just return next of head\\n\\twhile(fast -> next)                  // iterate till fast reaches the last node of list\\n\\t\\tfast = fast -> next, slow = slow -> next;            \\n\\tslow -> next = slow -> next -> next; // remove the nth node from last\\n\\treturn head;\\n}\\n```\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tfast = slow = head\\n\\tfor i in range(n):\\n\\t\\tfast = fast.next\\n\\tif not fast: return head.next\\n\\twhile fast.next:\\n\\t\\tfast, slow = fast.next, slow.next\\n\\tslow.next = slow.next.next\\n\\treturn head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1164545,
                "title": "remove-nth-node-from-end-of-list-js-python-java-c-easy-two-pointer-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nWith a singly linked list, the _only_ way to find the end of the list, and thus the **n**\\'th node from the end, is to actually iterate all the way to the end. The challenge here is attemping to find the solution in only one pass. A naive approach here might be to store pointers to each node in an array, allowing us to calculate the **n**\\'th from the end once we reach the end, but that would take **O(M) extra space**, where **M** is the length of the linked list.\\n\\nA slightly less naive approach would be to only store only the last **n+1** node pointers in the array. This could be achieved by overwriting the elements of the storage array in circlular fashion as we iterate through the list. This would lower the **space complexity** to **O(N+1)**.\\n\\nIn order to solve this problem in only one pass and **O(1) extra space**, however, we would need to find a way to _both_ reach the end of the list with one pointer _and also_ reach the **n**\\'th node from the end simultaneously with a second pointer.\\n\\nTo do that, we can simply stagger our two pointers by **n** nodes by giving the first pointer (**fast**) a head start before starting the second pointer (**slow**). Doing this will cause **slow** to reach the **n**\\'th node from the end at the same time that **fast** reaches the end.\\n\\n![Visual 1](https://i.imgur.com/BSiLKj0.png)\\n\\nSince we will need access to the node _before_ the target node in order to remove the target node, we can use **fast.next == null** as our exit condition, rather than **fast == null**, so that we stop one node earlier.\\n\\nThis will unfortunately cause a problem when **n** is the same as the length of the list, which would make the first node the target node, and thus make it impossible to find the node _before_ the target node. If that\\'s the case, however, we can just **return head.next** without needing to stitch together the two sides of the target node.\\n\\nOtherwise, once we succesfully find the node _before_ the target, we can then stitch it together with the node _after_ the target, and then **return head**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences between the code of all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **60ms / 40.6MB** (beats 100% / 13%).\\n```javascript\\nvar removeNthFromEnd = function(head, n) {\\n    let fast = head, slow = head\\n    for (let i = 0; i < n; i++) fast = fast.next\\n    if (!fast) return head.next\\n    while (fast.next) fast = fast.next, slow = slow.next\\n    slow.next = slow.next.next\\n    return head\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **28ms / 13.9MB** (beats 92% / 99%).\\n```python\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast, slow = head, head\\n        for _ in range(n): fast = fast.next\\n        if not fast: return head.next\\n        while fast.next: fast, slow = fast.next, slow.next\\n        slow.next = slow.next.next\\n        return head\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 36.5MB** (beats 100% / 97%).\\n```java\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head, slow = head;\\n        for (int i = 0; i < n; i++) fast = fast.next;\\n        if (fast == null) return head.next;\\n        while (fast.next != null) {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 10.6MB** (beats 100% / 93%).\\n```c++\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n        for (int i = 0; i < n; i++) fast = fast->next;\\n        if (!fast) return head->next;\\n        while (fast->next) fast = fast->next, slow = slow->next;\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar removeNthFromEnd = function(head, n) {\\n    let fast = head, slow = head\\n    for (let i = 0; i < n; i++) fast = fast.next\\n    if (!fast) return head.next\\n    while (fast.next) fast = fast.next, slow = slow.next\\n    slow.next = slow.next.next\\n    return head\\n};\\n```\n```python\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast, slow = head, head\\n        for _ in range(n): fast = fast.next\\n        if not fast: return head.next\\n        while fast.next: fast, slow = fast.next, slow.next\\n        slow.next = slow.next.next\\n        return head\\n```\n```java\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head, slow = head;\\n        for (int i = 0; i < n; i++) fast = fast.next;\\n        if (fast == null) return head.next;\\n        while (fast.next != null) {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n        for (int i = 0; i < n; i++) fast = fast->next;\\n        if (!fast) return head->next;\\n        while (fast->next) fast = fast->next, slow = slow->next;\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512706,
                "title": "c-java-python-javascript-with-explanation-linked-list",
                "content": "# Intuition:\\nThe problem is to remove the nth node from the end of a linked list. We can find the total number of nodes in the linked list and then traverse the list again to find the nth node from the end. We can then remove the node by updating the pointer of the previous node.\\n\\n# Approach:\\n\\n1. Initialize a pointer to the head of the linked list and a count variable to 0.\\n2. Traverse the linked list and increment the count for each node until the end of the list is reached.\\n3. If the count is equal to n, remove the head node and return the next node as the new head.\\n4. Otherwise, initialize the pointer to the head of the linked list again and set n to count - n - 1.\\n5. Traverse the linked list again and update the pointer of the previous node to remove the nth node from the end.\\n6. Return the head of the linked list.\\n\\n# Complexity:\\n\\n- Time Complexity: O(n), where n is the total number of nodes in the linked list. We need to traverse the linked list twice - once to count the total number of nodes and then to find the nth node from the end.\\n\\n- Space Complexity: O(1), as we are not using any extra space and only using constant space for the pointers and count variable.\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==NULL){\\n            return head;\\n        }\\n        ListNode* ptr=head;\\n        int count = 0;\\n        while(ptr){\\n            count++;\\n            ptr=ptr->next;\\n        }\\n        if(count==n){\\n            head=head->next;\\n            return head;\\n        }\\n        ptr=head;\\n        n=count-n-1;\\n        count=0;\\n        while(ptr){\\n            if(count==n){\\n                ptr->next=ptr->next->next;\\n            }\\n            count++;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if (head == null) {\\n            return head;\\n        }\\n        \\n        ListNode ptr = head;\\n        int count = 0;\\n        while (ptr != null) {\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        if (count == n) {\\n            head = head.next;\\n            return head;\\n        }\\n        \\n        ptr = head;\\n        n = count - n - 1;\\n        count = 0;\\n        while (ptr != null) {\\n            if (count == n) {\\n                ptr.next = ptr.next.next;\\n            }\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        return head;\\n    }\\n}\\n\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        if head is None:\\n            return head\\n        \\n        ptr = head\\n        count = 0\\n        while ptr is not None:\\n            count += 1\\n            ptr = ptr.next\\n        \\n        if count == n:\\n            head = head.next\\n            return head\\n        \\n        ptr = head\\n        n = count - n - 1\\n        count = 0\\n        while ptr is not None:\\n            if count == n:\\n                ptr.next = ptr.next.next\\n            count += 1\\n            ptr = ptr.next\\n        \\n        return head\\n\\n```\\n---\\n\\n# JavaScript\\n```\\nvar removeNthFromEnd = function(head, n) {\\n        if (head === null) {\\n            return head;\\n        }\\n        \\n        let ptr = head;\\n        let count = 0;\\n        while (ptr !== null) {\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        if (count === n) {\\n            head = head.next;\\n            return head;\\n        }\\n        \\n        ptr = head;\\n        n = count - n - 1;\\n        count = 0;\\n        while (ptr !== null) {\\n            if (count === n) {\\n                ptr.next = ptr.next.next;\\n            }\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        return head;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==NULL){\\n            return head;\\n        }\\n        ListNode* ptr=head;\\n        int count = 0;\\n        while(ptr){\\n            count++;\\n            ptr=ptr->next;\\n        }\\n        if(count==n){\\n            head=head->next;\\n            return head;\\n        }\\n        ptr=head;\\n        n=count-n-1;\\n        count=0;\\n        while(ptr){\\n            if(count==n){\\n                ptr->next=ptr->next->next;\\n            }\\n            count++;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if (head == null) {\\n            return head;\\n        }\\n        \\n        ListNode ptr = head;\\n        int count = 0;\\n        while (ptr != null) {\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        if (count == n) {\\n            head = head.next;\\n            return head;\\n        }\\n        \\n        ptr = head;\\n        n = count - n - 1;\\n        count = 0;\\n        while (ptr != null) {\\n            if (count == n) {\\n                ptr.next = ptr.next.next;\\n            }\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        return head;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        if head is None:\\n            return head\\n        \\n        ptr = head\\n        count = 0\\n        while ptr is not None:\\n            count += 1\\n            ptr = ptr.next\\n        \\n        if count == n:\\n            head = head.next\\n            return head\\n        \\n        ptr = head\\n        n = count - n - 1\\n        count = 0\\n        while ptr is not None:\\n            if count == n:\\n                ptr.next = ptr.next.next\\n            count += 1\\n            ptr = ptr.next\\n        \\n        return head\\n\\n```\n```\\nvar removeNthFromEnd = function(head, n) {\\n        if (head === null) {\\n            return head;\\n        }\\n        \\n        let ptr = head;\\n        let count = 0;\\n        while (ptr !== null) {\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        if (count === n) {\\n            head = head.next;\\n            return head;\\n        }\\n        \\n        ptr = head;\\n        n = count - n - 1;\\n        count = 0;\\n        while (ptr !== null) {\\n            if (count === n) {\\n                ptr.next = ptr.next.next;\\n            }\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        return head;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993889,
                "title": "c-solution-with-complexity-analysis-two-methods-two-pointers",
                "content": "### T = O(m) where m is number of iterations\\n### S = O(1) no extra space used\\n```\\n  // approach using single pass using fast and slow pointer\\n\\n\\tListNode* fast = head;\\n\\tListNode* slow = head;\\n\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tfast= fast->next;\\n\\t}\\n\\n\\tif (fast == nullptr) return head->next;\\n\\n\\twhile(fast->next) {\\n\\t\\tslow = slow->next;\\n\\t\\tfast = fast->next;\\n\\t}\\n\\n\\tslow->next = slow->next->next;\\n\\treturn head;\\n```\\n\\n```\\n// approach using double pass\\nListNode* temp = head;\\nint l = 0;\\nwhile(temp) {\\n   temp = temp->next;\\n   l++;\\n}\\n\\n// corner case\\nif(l == n) {\\n\\treturn head->next;\\n}\\nListNode* p = head;\\nint j = 0;\\nfor(int i = 0; i < l-n-1; i++) {\\n\\tp = p->next;\\n\\tj++;\\n}\\n\\ncout << j;\\nListNode* del = p->next;\\np->next = del->next;\\ndelete del;\\nreturn head;\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n  // approach using single pass using fast and slow pointer\\n\\n\\tListNode* fast = head;\\n\\tListNode* slow = head;\\n\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tfast= fast->next;\\n\\t}\\n\\n\\tif (fast == nullptr) return head->next;\\n\\n\\twhile(fast->next) {\\n\\t\\tslow = slow->next;\\n\\t\\tfast = fast->next;\\n\\t}\\n\\n\\tslow->next = slow->next->next;\\n\\treturn head;\\n```\n```\\n// approach using double pass\\nListNode* temp = head;\\nint l = 0;\\nwhile(temp) {\\n   temp = temp->next;\\n   l++;\\n}\\n\\n// corner case\\nif(l == n) {\\n\\treturn head->next;\\n}\\nListNode* p = head;\\nint j = 0;\\nfor(int i = 0; i < l-n-1; i++) {\\n\\tp = p->next;\\n\\tj++;\\n}\\n\\ncout << j;\\nListNode* del = p->next;\\np->next = del->next;\\ndelete del;\\nreturn head;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 982619,
                "title": "4-simple-solutions-explained-recursion-two-pointers-100-stack-two-runs",
                "content": "In the time complexity, I will refer to the length of the list as `m` and n and the index from the end.\\nNote: all of the solutions are run in less than  or equal to O(2 * n) but with closer look some are faster than others\\n\\nSolution 1:\\nThis solution runs in O(m + (m - n)) time with two runs once to count length second to get to the n -1 node from the end.\\nSpace O(1).\\n```\\nListNode *removeNthFromEnd(ListNode *head, int &n) // exection with two runs\\n    {\\n        int length = 0;\\n        ListNode *p = head;\\n\\n        while (p) // find length\\n        {\\n            length++;\\n            p = p->next;\\n        }\\n\\n        if (n == length) // check if need to remove the first node\\n            return head->next;\\n\\n        length -= n;\\n        length--;\\n\\n        p = head;\\n        while (length--) // get p the node before the n-th from the end\\n            p = p->next;\\n        p->next = p->next->next; // the move the node\\n\\n        return head;\\n    }\\n```\\n\\nSolution 2:\\nThis solution runs in O(m + n) time using a stack.\\nspace O(m).\\n```\\nListNode *removeNthFromEnd(ListNode *head, int &n) // excution using stack\\n{\\n\\tstack<ListNode *> s;\\n\\tint length = 0;\\n\\n\\tListNode *t = head;\\n\\twhile (t) // push all nodes\\n\\t{\\n\\t\\ts.push(t);\\n\\t\\tt = t->next;\\n\\t\\tlength++;\\n\\t}\\n\\n\\tif (length == n) // if need to remove the first node\\n\\t\\treturn head->next;\\n\\n\\twhile (n--) // get the n-1 node from the end\\n\\t\\ts.pop();\\n\\tt = s.top();\\n\\tt->next = t->next->next; // remove the node\\n\\n\\treturn head;\\n}\\n```\\n\\nSolution 3:\\nThis solution runs in O(m) time using backtracking and rebuilding the list.\\nSpace O(m)\\n```\\nListNode *removeNthFromEnd(ListNode *head, int &n)\\n{\\n\\tif(head == NULL) // if end\\n\\t\\treturn NULL;\\n\\n\\thead->next = removeNthFromEnd(head->next,n);// set to the next node\\n\\n\\tif(--n == 0) // do I need to remove this node\\n\\t\\treturn head->next;\\n\\treturn head;\\n}\\n```\\n\\n\\n\\nSolution 4:\\nThis solution runs in O(m) time with two pointers with space between them thus when the one before the end the other can remove the node.\\nspace O(1).\\n```\\nListNode *removeNthFromEnd(ListNode *head, int &n) // execution with two pointers\\n{\\n\\tListNode *t1 = head;\\n\\n\\twhile (t1 && n--) // get t1 to the  n+1 node thus the difference between t1 and t2 is n at all times\\n\\t\\tt1 = t1->next;\\n\\n\\tif (t1 == NULL) // if need to remove teh first Node\\n\\t\\treturn head->next;\\n\\n\\tListNode *t2 = head;\\n\\twhile (t1->next) // find the node before n-th from the end\\n\\t{\\n\\t\\tt1 = t1->next;\\n\\t\\tt2 = t2->next;\\n\\t}\\n\\tt2->next = t2->next->next;\\n\\n\\treturn head;\\n}\\n```\\nIf it helps vote up so it will reach others!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nListNode *removeNthFromEnd(ListNode *head, int &n) // exection with two runs\\n    {\\n        int length = 0;\\n        ListNode *p = head;\\n\\n        while (p) // find length\\n        {\\n            length++;\\n            p = p->next;\\n        }\\n\\n        if (n == length) // check if need to remove the first node\\n            return head->next;\\n\\n        length -= n;\\n        length--;\\n\\n        p = head;\\n        while (length--) // get p the node before the n-th from the end\\n            p = p->next;\\n        p->next = p->next->next; // the move the node\\n\\n        return head;\\n    }\\n```\n```\\nListNode *removeNthFromEnd(ListNode *head, int &n) // excution using stack\\n{\\n\\tstack<ListNode *> s;\\n\\tint length = 0;\\n\\n\\tListNode *t = head;\\n\\twhile (t) // push all nodes\\n\\t{\\n\\t\\ts.push(t);\\n\\t\\tt = t->next;\\n\\t\\tlength++;\\n\\t}\\n\\n\\tif (length == n) // if need to remove the first node\\n\\t\\treturn head->next;\\n\\n\\twhile (n--) // get the n-1 node from the end\\n\\t\\ts.pop();\\n\\tt = s.top();\\n\\tt->next = t->next->next; // remove the node\\n\\n\\treturn head;\\n}\\n```\n```\\nListNode *removeNthFromEnd(ListNode *head, int &n)\\n{\\n\\tif(head == NULL) // if end\\n\\t\\treturn NULL;\\n\\n\\thead->next = removeNthFromEnd(head->next,n);// set to the next node\\n\\n\\tif(--n == 0) // do I need to remove this node\\n\\t\\treturn head->next;\\n\\treturn head;\\n}\\n```\n```\\nListNode *removeNthFromEnd(ListNode *head, int &n) // execution with two pointers\\n{\\n\\tListNode *t1 = head;\\n\\n\\twhile (t1 && n--) // get t1 to the  n+1 node thus the difference between t1 and t2 is n at all times\\n\\t\\tt1 = t1->next;\\n\\n\\tif (t1 == NULL) // if need to remove teh first Node\\n\\t\\treturn head->next;\\n\\n\\tListNode *t2 = head;\\n\\twhile (t1->next) // find the node before n-th from the end\\n\\t{\\n\\t\\tt1 = t1->next;\\n\\t\\tt2 = t2->next;\\n\\t}\\n\\tt2->next = t2->next->next;\\n\\n\\treturn head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 222301,
                "title": "javascript",
                "content": "```\\nvar removeNthFromEnd = function(head, n) {\\n  let root = head;\\n  let clone = head;\\n  let len = 0;\\n \\n  while (clone) {\\n    len++;\\n    clone = clone.next;\\n  }\\n  \\n  let count = len - n;\\n  if (count === 0) return head.next;\\n  while (root && count > 1) {\\n    root = root.next;\\n    count--;\\n  }\\n\\n  root.next = root.next && root.next.next;\\n  return head;\\n};\\n```\\n\\n```\\nvar removeNthFromEnd = function(head, n) {\\n  const help = (root, count) => {\\n    if (root.next) count = help(root.next, count);\\n    \\n    if (count === n) root.next = root.next.next;\\n    return ++count;\\n  }\\n  const count = help(head, 0);\\n  return count === n ? head.next : head;\\n};\\n```\\n\\n```\\nvar removeNthFromEnd = function(head, n) {\\n  const root = new ListNode(0);\\n  root.next = head;\\n  let front = root;\\n  let back = root;\\n  while (n >= 0) {\\n    front = front.next;\\n    n--;\\n  }\\n  while (front) {\\n    front = front.next;\\n    back = back.next;\\n  }\\n  back.next = back.next.next;\\n  return root.next;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar removeNthFromEnd = function(head, n) {\\n  let root = head;\\n  let clone = head;\\n  let len = 0;\\n \\n  while (clone) {\\n    len++;\\n    clone = clone.next;\\n  }\\n  \\n  let count = len - n;\\n  if (count === 0) return head.next;\\n  while (root && count > 1) {\\n    root = root.next;\\n    count--;\\n  }\\n\\n  root.next = root.next && root.next.next;\\n  return head;\\n};\\n```\n```\\nvar removeNthFromEnd = function(head, n) {\\n  const help = (root, count) => {\\n    if (root.next) count = help(root.next, count);\\n    \\n    if (count === n) root.next = root.next.next;\\n    return ++count;\\n  }\\n  const count = help(head, 0);\\n  return count === n ? head.next : head;\\n};\\n```\n```\\nvar removeNthFromEnd = function(head, n) {\\n  const root = new ListNode(0);\\n  root.next = head;\\n  let front = root;\\n  let back = root;\\n  while (n >= 0) {\\n    front = front.next;\\n    n--;\\n  }\\n  while (front) {\\n    front = front.next;\\n    back = back.next;\\n  }\\n  back.next = back.next.next;\\n  return root.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9112,
                "title": "javascript-solution",
                "content": "    var removeNthFromEnd = function(head, n) {\\n        var nullHead = new ListNode(null);\\n        nullHead.next = head;\\n        var p1 = nullHead;\\n        var p2 = nullHead;\\n        \\n        for(var i = 0; i < n + 1; i++)\\n            p1 = p1.next;\\n        while(p1 !== null){\\n            p2 = p2.next;\\n            p1 = p1.next;\\n        }\\n        p2.next = p2.next.next;\\n        return nullHead.next;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var removeNthFromEnd = function(head, n) {\\n        var nullHead = new ListNode(null);\\n        nullHead.next = head;\\n        var p1 = nullHead;\\n        var p2 = nullHead;\\n        \\n        for(var i = 0; i < n + 1; i++)\\n            p1 = p1.next;\\n        while(p1 !== null){\\n            p2 = p2.next;\\n            p1 = p1.next;\\n        }\\n        p2.next = p2.next.next;\\n        return nullHead.next;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1899619,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\\n        var fast = head\\n        var slow = head\\n        var count = n\\n\\n        while count > 0 {\\n            count -= 1\\n            fast = fast?.next\\n        }\\n\\n        if fast == nil { return head?.next }\\n\\n        while slow != nil && fast != nil {\\n            if fast?.next == nil { slow?.next = slow?.next?.next } // end\\n            slow = slow?.next\\n            fast = fast?.next\\n        }\\n\\n        return head\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\\n        var fast = head\\n        var slow = head\\n        var count = n\\n\\n        while count > 0 {\\n            count -= 1\\n            fast = fast?.next\\n        }\\n\\n        if fast == nil { return head?.next }\\n\\n        while slow != nil && fast != nil {\\n            if fast?.next == nil { slow?.next = slow?.next?.next } // end\\n            slow = slow?.next\\n            fast = fast?.next\\n        }\\n\\n        return head\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698834,
                "title": "19-c-solution-easy-to-understand-with-explanation-conceptual-knowledgable",
                "content": "**Knockcat**\\n```\\n* Detailed Understanding of each Case.\\n* Conceptual Approach.\\n* Worth it Approach.\\n* C syntax also given.\\n```\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *temp = new ListNode;                 //Allocating Memory For New Node using new Keyword;\\n        temp = head;                                   //Initializing it to head;\\n        int cnt = 0;\\n        \\n        while(temp != NULL)\\n        {\\n            cnt++;\\n            temp = temp->next;\\n        }\\n        \\n        if(cnt == 0)\\n            return head;\\n        \\n        int cnt_first = (cnt - n) + 1;               //position of nth node from head\\n        \\n        head = Delete(head , cnt_first , cnt);       //function Delete to Delete the Node\\n        \\n        return head;\\n    }\\n    \\n    ListNode *Delete(ListNode *head, int  pos,int cnt)\\n    {\\n        if(head == NULL)\\n            return head;\\n        \\n        //If Deleted Node happen to be first Node\\n        else if(head != NULL && pos == 1)\\n        {\\n            ListNode *curr = new ListNode;      //Allocating memory using keyword new & then initializing node to head\\n            curr = head;\\n            // ListNode *curr = head;           //C syntax\\n            head = head -> next;\\n            // free(curr);                      //C syntax\\n            delete curr;\\n            curr = NULL;\\n        }\\n        \\n        //If Deleted Node happen to be Last Node\\n        else if(head != NULL && pos == cnt )    \\n        {\\n            ListNode *curr = new ListNode;      //Allocating memory using keyword new & then initializing node to head;\\n            curr = head;\\n            while (curr->next->next != NULL)\\n            {\\n                curr = curr->next;\\n            }\\n            ListNode *temp = new ListNode;\\n            temp = curr->next;\\n            // free(temp);                      //C syntax\\n            delete temp;\\n            temp = NULL;\\n            curr->next = NULL;\\n        }\\n        \\n        else if(cnt < pos || cnt < 1)\\n        {\\n            // cout<<\"Not a valid position\"<<end;\\n        }\\n        \\n        //If Deleted Node happen to be the Intermediate Node\\n        else\\n        {\\n            ListNode *curr = new ListNode;      //Allocating memory using keyword new & then initializing node to head;\\n            curr = head;\\n            ListNode *prev = new ListNode;\\n            prev = head;\\n            // ListNode *prev = NULL, *curr = head; //C syntax\\n            while(pos > 1)\\n            {\\n                prev = curr;\\n                curr = curr -> next;\\n                pos--;\\n            }\\n            prev -> next = curr -> next;\\n            // free(curr);                      //C syntax\\n            delete curr;\\n            curr = NULL;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n* Detailed Understanding of each Case.\\n* Conceptual Approach.\\n* Worth it Approach.\\n* C syntax also given.\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *temp = new ListNode;                 //Allocating Memory For New Node using new Keyword;\\n        temp = head;                                   //Initializing it to head;\\n        int cnt = 0;\\n        \\n        while(temp != NULL)\\n        {\\n            cnt++;\\n            temp = temp->next;\\n        }\\n        \\n        if(cnt == 0)\\n            return head;\\n        \\n        int cnt_first = (cnt - n) + 1;               //position of nth node from head\\n        \\n        head = Delete(head , cnt_first , cnt);       //function Delete to Delete the Node\\n        \\n        return head;\\n    }\\n    \\n    ListNode *Delete(ListNode *head, int  pos,int cnt)\\n    {\\n        if(head == NULL)\\n            return head;\\n        \\n        //If Deleted Node happen to be first Node\\n        else if(head != NULL && pos == 1)\\n        {\\n            ListNode *curr = new ListNode;      //Allocating memory using keyword new & then initializing node to head\\n            curr = head;\\n            // ListNode *curr = head;           //C syntax\\n            head = head -> next;\\n            // free(curr);                      //C syntax\\n            delete curr;\\n            curr = NULL;\\n        }\\n        \\n        //If Deleted Node happen to be Last Node\\n        else if(head != NULL && pos == cnt )    \\n        {\\n            ListNode *curr = new ListNode;      //Allocating memory using keyword new & then initializing node to head;\\n            curr = head;\\n            while (curr->next->next != NULL)\\n            {\\n                curr = curr->next;\\n            }\\n            ListNode *temp = new ListNode;\\n            temp = curr->next;\\n            // free(temp);                      //C syntax\\n            delete temp;\\n            temp = NULL;\\n            curr->next = NULL;\\n        }\\n        \\n        else if(cnt < pos || cnt < 1)\\n        {\\n            // cout<<\"Not a valid position\"<<end;\\n        }\\n        \\n        //If Deleted Node happen to be the Intermediate Node\\n        else\\n        {\\n            ListNode *curr = new ListNode;      //Allocating memory using keyword new & then initializing node to head;\\n            curr = head;\\n            ListNode *prev = new ListNode;\\n            prev = head;\\n            // ListNode *prev = NULL, *curr = head; //C syntax\\n            while(pos > 1)\\n            {\\n                prev = curr;\\n                curr = curr -> next;\\n                pos--;\\n            }\\n            prev -> next = curr -> next;\\n            // free(curr);                      //C syntax\\n            delete curr;\\n            curr = NULL;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1164614,
                "title": "python-two-pointers-approch-explained",
                "content": "Two passes solution is straightforward. For one pass solution we use the idea of `2` iterators, let one of them start at the beginning, another at index `n`, then when the second one is finished, the first one will be on the right place.\\n\\n#### Complexity\\nTime complexity is `O(L)`, more precisely we make `2L-n` steps, where `L` is length of list, space complexity is `O(1)`. So it the end it is exactly the same as staightforward two passes solution. So, if you meet this problem in real interview, you can just explain two pass solution, and when interviewer say can you do better: explain him that another one pass solution in fact is exaclty the same time and space.\\n\\n#### Code\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        P1, P2 = dummy, dummy\\n        for _ in range(n): P2 = P2.next\\n        \\n        while P2.next:\\n            P1 = P1.next\\n            P2 = P2.next\\n            \\n        P1.next = P1.next.next\\n        \\n        return dummy.next\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        P1, P2 = dummy, dummy\\n        for _ in range(n): P2 = P2.next\\n        \\n        while P2.next:\\n            P1 = P1.next\\n            P2 = P2.next\\n            \\n        P1.next = P1.next.next\\n        \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222616,
                "title": "java-solution-for-beginners-linkedlist-easy-to-understand",
                "content": "Please **UPVOTE** if you like my solution!\\n\\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        int count = 1;\\n        ListNode c = head;\\n        while(c.next!=null){\\n            count++;\\n            c=c.next;\\n        }\\n        \\n        if(n == count){\\n            head = head.next;\\n            return head;\\n        }\\n        \\n        ListNode ln = head;\\n        int i= 0;\\n        while(++i<count-n){\\n            ln = ln.next;  \\n        }\\n        ln.next = ln.next.next;\\n        \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        int count = 1;\\n        ListNode c = head;\\n        while(c.next!=null){\\n            count++;\\n            c=c.next;\\n        }\\n        \\n        if(n == count){\\n            head = head.next;\\n            return head;\\n        }\\n        \\n        ListNode ln = head;\\n        int i= 0;\\n        while(++i<count-n){\\n            ln = ln.next;  \\n        }\\n        ln.next = ln.next.next;\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552644,
                "title": "faster-than-100-c-code",
                "content": "idea is to take two pointers and traverse the first pointer n nodes\\ntill the time 2nd pointer will be as it is\\nnow when you\\'ll traverse the both poniters simultaneously then definitely first pointer\\nis gonna be at the position last and 2nd pointer will be just before the node we\\'ve to delete\\n\\nhere first pointer is fast and 2nd pointer is slow; \\nhere is the code implementation os the above approach------------------------\\n```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *start=new ListNode(); \\n        start->next=head;\\n        ListNode *slow=start,*fast=start;\\n        for(int i=0;i<n;i++)\\n            fast=fast->next; //traverse n nodes\\n        \\n        while(fast->next!=nullptr){  //as i told fast will be at the last node\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        ListNode *del=slow->next; //step to finish matlab khatam krna hai node ko\\n        slow->next=slow->next->next; //next pointer of the slow will point on just after the victim node\\n        delete(del); //Khatam \\uD83D\\uDC7B\\n        return start->next;\\n    }\\n```\\n\\nmy english ;P\\n\\uD83D\\uDE42 why you guys always forget to upvote, it motivates me to post such answers.\\n<a href=\"https://cutt.ly/KalyanChannel\">You can checkout the Youtube channel \\uD83D\\uDCF1  </a>",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *start=new ListNode(); \\n        start->next=head;\\n        ListNode *slow=start,*fast=start;\\n        for(int i=0;i<n;i++)\\n            fast=fast->next; //traverse n nodes\\n        \\n        while(fast->next!=nullptr){  //as i told fast will be at the last node\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        ListNode *del=slow->next; //step to finish matlab khatam krna hai node ko\\n        slow->next=slow->next->next; //next pointer of the slow will point on just after the victim node\\n        delete(del); //Khatam \\uD83D\\uDC7B\\n        return start->next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8874,
                "title": "golang-solution-3ms",
                "content": "Example Input:\\n```\\n| 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |\\n\\nFig 1\\n```\\n#### First Approach \\n- The idea is to use two pointers `left` and `right`.\\n- `right` will advance `n` nodes into the list.\\n- At this point `left` will point to the head of the list. (Figure 2)\\n- Then, we walk `left` and `right` in tandem, until `right` reaches the end of the list.\\n- At this point `left` will point to the *Nth node from the end*, which we want to remove.  (Figure 3)\\n```\\nleft                       right\\n| 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |\\n\\nFig 2\\n```\\n```\\n                  left                    right\\n| 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |   *\\n\\nFig 3\\n```\\nThis will work. However, we have to maintain a previous pointer to `left`, in order to delete `left`. We also need to take care of the corner case where, the node to be deleted is the `head` of our list. i.e when `n` = 5 in our example.\\n\\nWe'll instead follow a cleaner approach which is discussed next.\\n#### Second Approach\\n- We employ a node called the `preHeader` node, whose `Next` pointer points to the head of our list.\\n- Then we point our `left` pointer to the `preHeader` to start off with. (Figure 4)\\n- The advantage of this approach is that, when our `right` pointer gets to the end of our list, `left` will be pointing to the node just before the *Nth node from the end*, which makes deleting that node very straight forward.  (Figure 5/6)\\n- Another advantage is that, we do not need to code anything special for handling the corner case where `n` = 5 in our example. \\n```\\nleft                                 right\\n| ph | -> | 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |\\n\\nFig 4\\n```\\n```\\n                   left                             right\\n| ph | -> | 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |   *\\n\\nFig 5\\n```\\n```\\n                   left                    right\\n| ph | -> | 1 | -> | 2 | -> | 4 | -> | 5 |   *\\n\\nFig 6\\n```\\n\\n```c\\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\\n    if head == nil || n <= 0 {return head}\\n    preHeader := &ListNode{Next: head}\\n    left, right := preHeader, head\\n\\n    for i := 0; right != nil && i < n; i++ {\\n        right = right.Next\\n    }\\n    for right != nil {\\n        left, right = left.Next, right.Next\\n    }\\n    left.Next = left.Next.Next\\n    return preHeader.Next\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n| 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |\\n\\nFig 1\\n```\n```\\nleft                       right\\n| 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |\\n\\nFig 2\\n```\n```\\n                  left                    right\\n| 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |   *\\n\\nFig 3\\n```\n```\\nleft                                 right\\n| ph | -> | 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |\\n\\nFig 4\\n```\n```\\n                   left                             right\\n| ph | -> | 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |   *\\n\\nFig 5\\n```\n```\\n                   left                    right\\n| ph | -> | 1 | -> | 2 | -> | 4 | -> | 5 |   *\\n\\nFig 6\\n```\n```c\\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\\n    if head == nil || n <= 0 {return head}\\n    preHeader := &ListNode{Next: head}\\n    left, right := preHeader, head\\n\\n    for i := 0; right != nil && i < n; i++ {\\n        right = right.Next\\n    }\\n    for right != nil {\\n        left, right = left.Next, right.Next\\n    }\\n    left.Next = left.Next.Next\\n    return preHeader.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9028,
                "title": "my-java-solution",
                "content": "    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode voidHead = new ListNode(-1);\\n        voidHead.next = head;\\n        ListNode p1 = voidHead;\\n        ListNode p2 = voidHead;\\n        while (p1.next!=null){\\n            p1=p1.next;\\n            if (n--<=0)p2=p2.next;\\n        }\\n        if (p2.next!=null) p2.next=p2.next.next;\\n        return voidHead.next;\\n    }",
                "solutionTags": [],
                "code": "    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode voidHead = new ListNode(-1);\\n        voidHead.next = head;\\n        ListNode p1 = voidHead;\\n        ListNode p2 = voidHead;\\n        while (p1.next!=null){\\n            p1=p1.next;\\n            if (n--<=0)p2=p2.next;\\n        }\\n        if (p2.next!=null) p2.next=p2.next.next;\\n        return voidHead.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1668618,
                "title": "python-one-pass-o-n-faster-than-93-19",
                "content": "```class Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow, fast = head, head\\n        \\n        while n > 0:\\n            fast = fast.next\\n            n -= 1\\n        \\n        while fast is not None and fast.next is not None:\\n            slow = slow.next\\n            fast = fast.next\\n\\n        if fast is not None:\\n            slow.next = slow.next.next\\n        else:\\n            head = head.next\\n        \\n        return head",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```class Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow, fast = head, head\\n        \\n        while n > 0:\\n            fast = fast.next\\n            n -= 1\\n        \\n        while fast is not None and fast.next is not None:\\n            slow = slow.next\\n            fast = fast.next\\n\\n        if fast is not None:\\n            slow.next = slow.next.next\\n        else:\\n            head = head.next\\n        \\n        return head",
                "codeTag": "Java"
            },
            {
                "id": 723171,
                "title": "2-pointer-with-original-submission-and-thought-process-faster-than-98",
                "content": "So this is the original code in my submission. I\\'d apparently visited this a few months back and made a hash of it, but after revisiting having learnt some base techniques it\\'s much easier.\\n\\n**(1)** \\nOk obviously need to delete a node. So best know how to do that. Already in my mind i\\'m seeing:\\n\\n``` \\nconst deleteNextNode = (node) => node.next = node.next.next\\n```\\n\\nWhich means if we want to delete a node, we need to get the node before it.\\n\\n**(2)**\\nThen the other bit, which actually comes before in the description, is to get the `Nth` node from the end. In our case, as we want to get the `Nth` node from the end of the linked list to delete it, we actually want to get the `Nth+1` node **from the end**. Seems like a slow/fast 2 pointer solution.\\n\\nTo do this, i\\'m seeing the beginning of the answer to the entire question:\\n\\n```\\nvar removeNthFromEnd = function(head, n) {\\n\\n    if(!head) return head\\n\\n    let [slow, fast] = [head, head]\\n\\t\\n    // move fast ahead by n\\n\\t// have to be careful about --n or n-- here. \\n\\t// As we want the node before the one we are deleting,\\n\\t// we want fast to be ahead by an additional node\\n\\t// if the question was just to return slow, i\\'d probably use --n instead\\n    while(n--){\\n        fast = fast.next\\n    }\\n    \\n\\t// we want to stop when fast.next is null\\n\\t// we move both along the linked list \\n\\t// keeping the same distance between them\\n    while(fast.next){\\n        [slow, fast] = [slow.next, fast.next]\\n    }\\n\\t...\\n}\\n```\\n\\nOne final issue came up when submitting. What happens when `n` is equal to the length of the linked list. We\\'ll we run into problems. Easiest solution I could think of is to create a dummy node that is before the linked list. That allows us to remove the head node if the Nth node from the end is the head node.\\n\\n**Final submission:**\\n```\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    if(!head) return head\\n    let begin = { val: -1, next: head }\\n       \\n    let [slow, fast] = [begin, begin]\\n    // move fast ahead by n\\n    while(n--){\\n        fast = fast.next\\n    }\\n    \\n    while(fast.next){\\n        [slow, fast] = [slow.next, fast.next]\\n    }\\n    \\n    // remove slow.next\\n    removeNextNode(slow)\\n    \\n    return begin.next\\n};\\n\\nconst removeNextNode = (node) => { \\n    node.next = node.next.next\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "``` \\nconst deleteNextNode = (node) => node.next = node.next.next\\n```\n```\\nvar removeNthFromEnd = function(head, n) {\\n\\n    if(!head) return head\\n\\n    let [slow, fast] = [head, head]\\n\\t\\n    // move fast ahead by n\\n\\t// have to be careful about --n or n-- here. \\n\\t// As we want the node before the one we are deleting,\\n\\t// we want fast to be ahead by an additional node\\n\\t// if the question was just to return slow, i\\'d probably use --n instead\\n    while(n--){\\n        fast = fast.next\\n    }\\n    \\n\\t// we want to stop when fast.next is null\\n\\t// we move both along the linked list \\n\\t// keeping the same distance between them\\n    while(fast.next){\\n        [slow, fast] = [slow.next, fast.next]\\n    }\\n\\t...\\n}\\n```\n```\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    if(!head) return head\\n    let begin = { val: -1, next: head }\\n       \\n    let [slow, fast] = [begin, begin]\\n    // move fast ahead by n\\n    while(n--){\\n        fast = fast.next\\n    }\\n    \\n    while(fast.next){\\n        [slow, fast] = [slow.next, fast.next]\\n    }\\n    \\n    // remove slow.next\\n    removeNextNode(slow)\\n    \\n    return begin.next\\n};\\n\\nconst removeNextNode = (node) => { \\n    node.next = node.next.next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 337245,
                "title": "simple-and-easy-to-understand-c-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int size=0;\\n        ListNode* ans=head;\\n        ListNode* check=head;\\n        while(head){\\n            size++;\\n            head=head->next;\\n        }\\n        if(size==1) return NULL;\\n        if(size <= n){\\n            return ans->next;\\n        }\\n        for(int i=1;i<size-n;i++){\\n            check=check->next;\\n        }\\n        check->next=check->next->next;\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int size=0;\\n        ListNode* ans=head;\\n        ListNode* check=head;\\n        while(head){\\n            size++;\\n            head=head->next;\\n        }\\n        if(size==1) return NULL;\\n        if(size <= n){\\n            return ans->next;\\n        }\\n        for(int i=1;i<size-n;i++){\\n            check=check->next;\\n        }\\n        check->next=check->next->next;\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632933,
                "title": "c-0ms-short-simple-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!***\\n\\nLL = **1 -> 2 -> 3 -> 4-> 5 -> null** & n=2\\n\\n1. Initially slow = head, fast = head\\n2. Fast is initialised **\\'n+1\\' positions ahead**.\\n3. Thus, **slow = 1 and fast = 4** (n+1 positions ahead i.e. 2+1 = 3 positions ahead). \\n4. While fast!=NULL, increment **both slow and fast by one**.\\n5. Therefore, slow = 2, fast = 5\\n6. Now, slow = 3, fast = NULL, hence exit form while loop\\n7. Now update **slow->next = slow->next->next.**\\n\\n**TC** = O(N), **SC** = O(1)\\n\\n\\t  ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        \\n        if(head==NULL) return head;\\n        \\n        ListNode *s=head, *f=head;          //2 pointers, slow=head\\n        \\n        for(int i=1;i<=n+1;i++){            //fast is initialised \\'n+1\\' positions ahead\\n            if(f==NULL) return head->next;  \\n            f=f->next;\\n        }\\n        \\n        while(f!=NULL){                     //when fast is NULL, exit\\n            s=s->next;\\n            f=f->next;\\n        }\\n        \\n        s->next=s->next->next;              //update connection\\n        return head;\\n    }",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!***\\n\\nLL = **1 -> 2 -> 3 -> 4-> 5 -> null** & n=2\\n\\n1. Initially slow = head, fast = head\\n2. Fast is initialised **\\'n+1\\' positions ahead**.\\n3. Thus, **slow = 1 and fast = 4** (n+1 positions ahead i.e. 2+1 = 3 positions ahead). \\n4. While fast!=NULL, increment **both slow and fast by one**.\\n5. Therefore, slow = 2, fast = 5\\n6. Now, slow = 3, fast = NULL, hence exit form while loop\\n7. Now update **slow->next = slow->next->next.**\\n\\n**TC** = O(N), **SC** = O(1)\\n\\n\\t  ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        \\n        if(head==NULL) return head;\\n        \\n        ListNode *s=head, *f=head;          //2 pointers, slow=head\\n        \\n        for(int i=1;i<=n+1;i++){            //fast is initialised \\'n+1\\' positions ahead\\n            if(f==NULL) return head->next;  \\n            f=f->next;\\n        }\\n        \\n        while(f!=NULL){                     //when fast is NULL, exit\\n            s=s->next;\\n            f=f->next;\\n        }\\n        \\n        s->next=s->next->next;              //update connection\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2428116,
                "title": "one-pass-simple-c-solution-w-comments-and-explanation",
                "content": "Here\\'s a one-pass solution with the following algorithm:\\n1. Create a dummy node and let the 2 pointers, `fast` and `slow` point to that node. Dummy nodes make things easier, especially when we delete the **first node/head**.\\n2. Position `fast` so that the gap between them is `n`\\n3. To position `slow` just **behind/before the node-to-delete**, move both pointers until `fast.next` is `null` \\n4. After the pointers are positioned where they should, delete the node by pointing `slow.next` to `slow.next.next`\\n5. Return the head via `dummy.next`\\n\\n**Implementation**\\n\\n```\\npublic ListNode RemoveNthFromEnd(ListNode head, int n) {\\n\\tListNode dummy = new(0, head); // Create a dummy node\\n\\tListNode slow = dummy, fast = dummy;\\n\\n\\t// Gap of fast and slow is n\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tfast = fast.next;\\n\\t}\\n\\n\\t// Move slow to the node behind the node to delete\\n\\twhile (fast?.next != null) {\\n\\t\\tslow = slow.next;\\n\\t\\tfast = fast.next;\\n\\t}\\n\\n\\t\\t\\t// Delete the node\\n\\tslow.next = slow.next.next;\\n\\n\\treturn dummy.next;\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Two Pointers"
                ],
                "code": "```\\npublic ListNode RemoveNthFromEnd(ListNode head, int n) {\\n\\tListNode dummy = new(0, head); // Create a dummy node\\n\\tListNode slow = dummy, fast = dummy;\\n\\n\\t// Gap of fast and slow is n\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tfast = fast.next;\\n\\t}\\n\\n\\t// Move slow to the node behind the node to delete\\n\\twhile (fast?.next != null) {\\n\\t\\tslow = slow.next;\\n\\t\\tfast = fast.next;\\n\\t}\\n\\n\\t\\t\\t// Delete the node\\n\\tslow.next = slow.next.next;\\n\\n\\treturn dummy.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1658772,
                "title": "rust-0ms-faster-than-100-recursive-solution-with-backtracking-no-cloning",
                "content": "I want to make a shout out to the online booklet [Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial.github.io/too-many-lists/) -- it\\'s a good way to learn how to use Rust\\'s built-in tools to massage code to satisfy the borrow chcker. It provides a nice exlaination for using `mem::replace`, when to use it, and `Option\\'s` helpful `take()` function.\\n\\n\\n```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        remove_nth_from_end_recr(head, n).0\\n    }\\n}\\n    \\nfn remove_nth_from_end_recr(head: Option<Box<ListNode>>, n: i32) -> (Option<Box<ListNode>>, usize) {\\n    match head {\\n        None => (None, 1),\\n        Some(mut node) => {\\n            let (prev, num) = remove_nth_from_end_recr(node.next.take(), n);\\n            if n == num as i32 {\\n                (prev, num+1)\\n            } else {\\n                node.next = prev;\\n                (Some(node), num+1)\\n            }\\n        }\\n    }\\n}\\n```\\n\\n\\n```\\nRuntime: 0 ms, faster than 100.00% of Rust online submissions for Remove Nth Node From End of List.\\nMemory Usage: 2.1 MB, less than 37.35% of Rust online submissions for Remove Nth Node From End of List.\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        remove_nth_from_end_recr(head, n).0\\n    }\\n}\\n    \\nfn remove_nth_from_end_recr(head: Option<Box<ListNode>>, n: i32) -> (Option<Box<ListNode>>, usize) {\\n    match head {\\n        None => (None, 1),\\n        Some(mut node) => {\\n            let (prev, num) = remove_nth_from_end_recr(node.next.take(), n);\\n            if n == num as i32 {\\n                (prev, num+1)\\n            } else {\\n                node.next = prev;\\n                (Some(node), num+1)\\n            }\\n        }\\n    }\\n}\\n```\n```\\nRuntime: 0 ms, faster than 100.00% of Rust online submissions for Remove Nth Node From End of List.\\nMemory Usage: 2.1 MB, less than 37.35% of Rust online submissions for Remove Nth Node From End of List.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1472058,
                "title": "javascript-99-single-loop-clean-code",
                "content": "1. dummy head to keep the \\'prev\\' for the real head.\\n2. counting in the single loop to avoid the second loop many other solutions used.\\n\\n```\\nvar removeNthFromEnd = function(head, n) { \\n    let dummy = new ListNode(0, head);\\n    let prev = dummy;\\n    let node = head;\\n    let count = 1;\\n    while (node.next) {\\n        if (count === n) {\\n            prev = prev.next;\\n        } else {\\n            count++;\\n        }\\n        node = node.next;\\n    }\\n    prev.next = prev.next.next;\\n    return dummy.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeNthFromEnd = function(head, n) { \\n    let dummy = new ListNode(0, head);\\n    let prev = dummy;\\n    let node = head;\\n    let count = 1;\\n    while (node.next) {\\n        if (count === n) {\\n            prev = prev.next;\\n        } else {\\n            count++;\\n        }\\n        node = node.next;\\n    }\\n    prev.next = prev.next.next;\\n    return dummy.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168502,
                "title": "simple-javascript-99-solution-with-comments",
                "content": "```\\nvar removeNthFromEnd = function(head, n) {\\n    let nodeToReturn = head;\\n    \\n    //Have two pointers, one that is n ahead of the other\\n    let pointer1 = head;\\n    let pointer2 = head;\\n    \\n    //Move pointer2 to be n ahead\\n    for(let i = 0; i<n;i++){\\n        pointer2 = pointer2.next;\\n    }\\n    \\n    //If pointer2 doesn\\'t exist, that means we must remove the head of the list\\n    if(!pointer2){\\n        return nodeToReturn.next;\\n    }\\n    \\n    //Move both pointers until pointer2 reaches the end\\n    while(pointer2.next){\\n        pointer1 = pointer1.next;\\n        pointer2 = pointer2.next;\\n    }\\n\\n    //Save the node two places ahead of pointer1;    \\n    pointer1.next = pointer1.next.next;\\n    \\n    return nodeToReturn;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar removeNthFromEnd = function(head, n) {\\n    let nodeToReturn = head;\\n    \\n    //Have two pointers, one that is n ahead of the other\\n    let pointer1 = head;\\n    let pointer2 = head;\\n    \\n    //Move pointer2 to be n ahead\\n    for(let i = 0; i<n;i++){\\n        pointer2 = pointer2.next;\\n    }\\n    \\n    //If pointer2 doesn\\'t exist, that means we must remove the head of the list\\n    if(!pointer2){\\n        return nodeToReturn.next;\\n    }\\n    \\n    //Move both pointers until pointer2 reaches the end\\n    while(pointer2.next){\\n        pointer1 = pointer1.next;\\n        pointer2 = pointer2.next;\\n    }\\n\\n    //Save the node two places ahead of pointer1;    \\n    pointer1.next = pointer1.next.next;\\n    \\n    return nodeToReturn;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8971,
                "title": "simple-6-line-java-one-pass-solution",
                "content": "public class Solution {\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode start=new ListNode(0),slow=start,fast=start;\\n        start.next=head;\\n        for(int i=0;i<n;i++) fast=fast.next;\\n        while(fast.next!=null) {fast=fast.next;slow=slow.next;}\\n        slow.next=slow.next.next;\\n        return start.next;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode start=new ListNode(0),slow=start,fast=start;\\n        start.next=head;\\n        for(int i=0;i<n;i++) fast=fast.next;\\n        while(fast.next!=null) {fast=fast.next;slow=slow.next;}",
                "codeTag": "Java"
            },
            {
                "id": 9007,
                "title": "python-solution-one-pass",
                "content": "nearly one pass, O(1) space. 44 ms\\n\\n    def removeNthFromEnd(self, head, n):\\n        slow = fast = self\\n        self.next = head\\n        while fast.next:\\n            if n:\\n                n -= 1\\n            else:\\n                slow = slow.next\\n            fast = fast.next\\n        slow.next = slow.next.next\\n        return self.next   \\n\\nreal one pass, but O(n) space,  44 ms  \\n\\n    def removeNthFromEnd(self, head, n):\\n        self.next, nodelist  = head, [self]\\n        while head.next:\\n            if len(nodelist) == n:\\n                nodelist.pop(0)\\n            nodelist += head,\\n            head = head.next\\n        nodelist[0].next = nodelist[0].next.next \\n        return self.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "nearly one pass, O(1) space. 44 ms\\n\\n    def removeNthFromEnd(self, head, n):\\n        slow = fast = self\\n        self.next = head\\n        while fast.next:\\n            if n:\\n                n -= 1\\n            else:\\n                slow = slow.next\\n            fast = fast.next\\n        slow.next = slow.next.next\\n        return self.next   \\n\\nreal one pass, but O(n) space,  44 ms  \\n\\n    def removeNthFromEnd(self, head, n):\\n        self.next, nodelist  = head, [self]\\n        while head.next:\\n            if len(nodelist) == n:\\n                nodelist.pop(0)\\n            nodelist += head,\\n            head = head.next\\n        nodelist[0].next = nodelist[0].next.next \\n        return self.next",
                "codeTag": "Python3"
            },
            {
                "id": 3469283,
                "title": "c-easy-explanation-simple",
                "content": "/* question me dia apko ek linked list di h or bola h Nth node from the end delete krdo  mtlb agar linked list h \\nL1 = [1,2,3,4,5] or N=2 to last 2nd node delete krdo to vo konsi hogi vo hogi vo node jiska data h 4 to hme 4 ko delete krna h iske lia hmne kya kia hmne ek fast pointer lia jo head pe khada h ek slow ha vo bhi head pe h to phle fast ko jb tk chala lo jb tk fast \\'n\\' nhi ho jata fir hmne kya kia ek slow pointer lia usko chlao fast ke sath jb tk fast null nhi ho jata (slow bhi ek step , fast bhi ek step) jse hi fast null ho jae to appka slow us position pe ho jisko delete krna h to abb kya kro slow ke next ko krdo slow ke next ka next */\\n\\n\\n\\n\\nclass Solution {\\n\\npublic:\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\t\\n        ListNode* fast = head;\\n\\t\\t\\n        if(head == NULL)\\n\\t\\t\\n            return NULL;\\n\\t\\t\\t\\n        ListNode* slow = head;\\n        \\n        int count = 1;\\n        while(n--){\\n            cout<<fast->val<<\" \";\\n           fast = fast->next;\\n        }\\n        if(fast== NULL)\\n            return slow->next;\\n            \\n        while(fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n          slow->next = slow->next->next;\\n          return head;\\n       }\\n  \\n};",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\npublic:\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\t\\n        ListNode* fast = head;\\n\\t\\t\\n        if(head == NULL)\\n\\t\\t\\n            return NULL;\\n\\t\\t\\t\\n        ListNode* slow = head;\\n        \\n        int count = 1;\\n        while(n--){\\n            cout<<fast->val<<\" \";\\n           fast = fast->next;\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 2632802,
                "title": "java-2-solutions-explained",
                "content": "```\\n// 1. In one traversal : using slow and fast pointer\\n/*\\ntake two pointer slow and fast\\n- fast will move n position forwards\\n- now move forwards slow and fast both, till fast not reach to end of LL\\n- after performing upper operations, slow will reach to the previous node to the node which we want to delete\\n*/\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n        ListNode slow = head, fast = head;\\n        \\n        // move fast n position forwards\\n        while(n != 0){\\n            fast = fast.next;\\n            n--;\\n        }\\n        \\n        // now move slow and fast both till fast not reach to end of LL\\n        while(fast != null && fast.next != null){\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        \\n        // if fast is null, its mean we want to delete head node\\n        if(fast == null) return head.next;\\n        \\n        // remove node\\n        slow.next = slow.next.next;\\n        \\n        return head;\\n    }\\n}\\n\\n\\n// 2. In two traversal\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n        // find length\\n        int len = 0;\\n        ListNode temp = head;\\n        while(temp != null){\\n            temp = temp.next;\\n            len++;\\n        }\\n        \\n        if(len == n) return head.next;\\n        \\n        // Reach to the previous node of the last node\\n        temp = head;\\n        n = len-n-1;\\n        while(temp.next != null && n != 0){\\n            temp = temp.next;\\n            n--;\\n        }\\n        \\n        // remove \\n        if(temp.next != null)\\n            temp.next = temp.next.next;\\n        \\n        \\n        return head;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n        ListNode slow = head, fast = head;\\n        \\n        // move fast n position forwards\\n        while(n != 0){\\n            fast = fast.next;\\n            n--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2599256,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        if head.next is None:\\n            return None\\n        \\n        size=0\\n        curr= head\\n        while curr!= None:\\n            curr= curr.next\\n            size+=1\\n        if n== size:\\n            return head.next\\n        \\n        indexToSearch= size-n\\n        prev= head\\n        i=1\\n        while i< indexToSearch:\\n            prev= prev.next\\n            i+=1\\n        prev.next= prev.next.next\\n        return head\\n```\\n\\n**UPVOTE** *is the best encouragement for me... Thank you*\\uD83D\\uDE01",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        if head.next is None:\\n            return None\\n        \\n        size=0\\n        curr= head\\n        while curr!= None:\\n            curr= curr.next\\n            size+=1\\n        if n== size:\\n            return head.next\\n        \\n        indexToSearch= size-n\\n        prev= head\\n        i=1\\n        while i< indexToSearch:\\n            prev= prev.next\\n            i+=1\\n        prev.next= prev.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768626,
                "title": "c-efficient-two-pointers-with-comments-explanation",
                "content": "##### If you understand the approach please please upvote!!!\\uD83D\\uDC4D\\n***Thanks :)***\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *slow=head;\\n        ListNode *fast=head;\\n        while(n--) fast = fast -> next;//iterate first n nodes using fast\\n\\t    if(!fast) return head -> next; //if fast is already null, it means we have to delete head itself. So, just return next of head\\n        while(fast->next){//iterate till fast reaches the last node of list\\n            slow=slow->next; \\n            fast=fast->next;\\n        }\\n        slow->next=slow->next->next;// remove the nth node from last\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *slow=head;\\n        ListNode *fast=head;\\n        while(n--) fast = fast -> next;//iterate first n nodes using fast\\n\\t    if(!fast) return head -> next; //if fast is already null, it means we have to delete head itself. So, just return next of head\\n        while(fast->next){//iterate till fast reaches the last node of list\\n            slow=slow->next; \\n            fast=fast->next;\\n        }\\n        slow->next=slow->next->next;// remove the nth node from last\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563061,
                "title": "python-2-simple-solutions",
                "content": "**Python :**\\n\\n**1 :**\\n\\n```\\nclass Solution:\\n    def getLengthOfLL(self, head: Optional[ListNode]) -> int:\\n        length = 0\\n        \\n        while head:\\n            length += 1\\n            head = head.next\\n            \\n        return length\\n            \\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        temp = head\\n        length = self.getLengthOfLL(temp)\\n        if n == length:\\n            return head.next\\n        \\n        if length == 1:\\n            return None\\n        \\n        i = 1\\n        \\n        while temp and i < (length - n):\\n            temp = temp.next\\n            i += 1\\n        \\n        temp.next = temp.next.next        \\n        return head\\n```\\n\\n**2 :**\\n```\\ndef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\tfast = head\\n\\tslow = head\\n\\n\\twhile n:\\n\\t\\tfast = fast.next\\n\\t\\tn -= 1\\n\\n\\tif not fast:\\n\\t\\treturn head.next\\n\\n\\twhile fast.next:\\n\\t\\tslow = slow.next\\n\\t\\tfast = fast.next\\n\\n\\tslow.next = slow.next.next\\n\\treturn head\\n```\\n\\n**Like it ? please upvote !**\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getLengthOfLL(self, head: Optional[ListNode]) -> int:\\n        length = 0\\n        \\n        while head:\\n            length += 1\\n            head = head.next\\n            \\n        return length\\n            \\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        temp = head\\n        length = self.getLengthOfLL(temp)\\n        if n == length:\\n            return head.next\\n        \\n        if length == 1:\\n            return None\\n        \\n        i = 1\\n        \\n        while temp and i < (length - n):\\n            temp = temp.next\\n            i += 1\\n        \\n        temp.next = temp.next.next        \\n        return head\\n```\n```\\ndef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\tfast = head\\n\\tslow = head\\n\\n\\twhile n:\\n\\t\\tfast = fast.next\\n\\t\\tn -= 1\\n\\n\\tif not fast:\\n\\t\\treturn head.next\\n\\n\\twhile fast.next:\\n\\t\\tslow = slow.next\\n\\t\\tfast = fast.next\\n\\n\\tslow.next = slow.next.next\\n\\treturn head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726055,
                "title": "rust-0ms",
                "content": "```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n         let mut dummy = Box::new(ListNode {\\n            val: -1,\\n            next: head,\\n        });\\n\\n        let mut right = dummy.clone();\\n        let mut left = dummy.as_mut();\\n\\n        for _ in 0..n {\\n            right = right.next.unwrap();\\n        }\\n\\n        while let Some(node) = right.next {\\n            right = node;\\n            left = left.next.as_mut().unwrap();\\n        }\\n\\n        left.next = left.next.as_mut().unwrap().next.clone();\\n\\n        dummy.next\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n         let mut dummy = Box::new(ListNode {\\n            val: -1,\\n            next: head,\\n        });\\n\\n        let mut right = dummy.clone();\\n        let mut left = dummy.as_mut();\\n\\n        for _ in 0..n {\\n            right = right.next.unwrap();\\n        }\\n\\n        while let Some(node) = right.next {\\n            right = node;\\n            left = left.next.as_mut().unwrap();\\n        }\\n\\n        left.next = left.next.as_mut().unwrap().next.clone();\\n\\n        dummy.next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 414563,
                "title": "rust-safe-code-one-pass-has-to-use-clone-to-bypass-borrow-checker",
                "content": "```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        let mut dummy = ListNode::new(0);\\n        dummy.next = head;\\n        let mut dummy = Box::new(dummy);\\n        let mut fast = dummy.clone();\\n        let mut slow =  dummy.as_mut();\\n        // move fast n forward\\n        for _ in 0..n {\\n            fast = fast.next.unwrap();\\n        }\\n\\n        while fast.next.is_some() {\\n            fast = fast.next.unwrap();\\n            slow = slow.next.as_mut().unwrap();\\n        }\\n        let next = slow.next.as_mut().unwrap();\\n        slow.next = next.next.clone();\\n        dummy.next\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        let mut dummy = ListNode::new(0);\\n        dummy.next = head;\\n        let mut dummy = Box::new(dummy);\\n        let mut fast = dummy.clone();\\n        let mut slow =  dummy.as_mut();\\n        // move fast n forward\\n        for _ in 0..n {\\n            fast = fast.next.unwrap();\\n        }\\n\\n        while fast.next.is_some() {\\n            fast = fast.next.unwrap();\\n            slow = slow.next.as_mut().unwrap();\\n        }\\n        let next = slow.next.as_mut().unwrap();\\n        slow.next = next.next.clone();\\n        dummy.next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8996,
                "title": "easy-java-o-1-space-complexity-solution",
                "content": "    public ListNode removeNthFromEnd(ListNode head, int n) {\\n\\n        ListNode start = new ListNode(0);\\n        ListNode n1 = start, n2 = start;\\n        n2.next = head;\\n        \\n        for(int i =0;i<n+1;i++){\\n            n2 = n2.next; // trying o create gab n between two pointers\\n        }\\n        \\n        while(n2 != null){\\n            n1 = n1.next;\\n            n2 = n2.next;\\n        }\\n        \\n        //time to change\\n        n1.next = n1.next.next;\\n        return start.next;\\n    }",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "    public ListNode removeNthFromEnd(ListNode head, int n) {\\n\\n        ListNode start = new ListNode(0);\\n        ListNode n1 = start, n2 = start;\\n        n2.next = head;\\n        \\n        for(int i =0;i<n+1;i++){\\n            n2 = n2.next; // trying o create gab n between two pointers\\n        }\\n        \\n        while(n2 != null){\\n            n1 = n1.next;\\n            n2 = n2.next;\\n        }\\n        \\n        //time to change\\n        n1.next = n1.next.next;\\n        return start.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 9040,
                "title": "simple-one-pass-4ms-c-implementation",
                "content": "    class Solution {\\n    public:\\n        ListNode* removeNthFromEnd(ListNode* head, int n) {\\n            ListNode realHead(0);\\n            realHead.next = head;\\n            head = &realHead;\\n            ListNode *curr = &realHead;\\n            while (n-- > 0)\\n                curr = curr->next;\\n            while (curr->next != nullptr) {\\n                curr = curr->next;\\n                head = head->next;\\n            }\\n    \\n            head->next = head->next->next;\\n            return realHead.next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* removeNthFromEnd(ListNode* head, int n) {\\n            ListNode realHead(0);\\n            realHead.next = head;\\n            head = &realHead;\\n            ListNode *curr = &realHead;\\n            while (n-- > 0)\\n                curr = curr->next;\\n            while (curr->next != nullptr) {\\n                curr = curr->next;\\n                head = head->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3916930,
                "title": "python3-beats-95-efficient-removal-of-nth-node-from-the-end-of-a-linked-list",
                "content": "# Solution no. 01\\nThe first solution helps you understand the basics with simple steps. \\n\\n# Intuition\\n\\nTo determine the node to remove, which is n positions from the end, we need to figure out how many positions we should move from the front to reach the desired node. By counting the total number of nodes in the linked list, we gain this insight and can then adjust the connections accordingly to remove the targeted node from the end.\\n\\n# Approach\\n1. Count the total number of nodes in the linked list by traversing it with a curr pointer.\\n1. Calculate the position to move from the front to reach the node n positions from the end.\\n1. Reset the count and curr to traverse the list again.\\n1. If the node to be removed is the first node, return head.next.\\n1. Traverse the list while keeping track of the count.\\n1. When the count matches the calculated position before the node to be removed, update the connection to skip the node.\\n1. Exit the loop after performing the removal.\\n1. Return the updated head.\\n\\n# Complexity\\n- Time complexity:\\nWe traverse the linked list twice, so the time complexity is O(n), where n is the number of nodes in the list.\\n\\n- Space complexity:\\nWe only use a few variables, so the space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        count = 0\\n        curr = head\\n        while curr:\\n            count += 1\\n            curr = curr.next\\n\\n        check = count - n - 1\\n        count = 0\\n        curr = head\\n\\n        # Removing the first node\\n        if check == -1:  \\n            return head.next\\n\\n        while curr:\\n            if count == check:\\n                curr.next = curr.next.next\\n                # As the removal is done, Exit the loop\\n                break  \\n            curr = curr.next\\n            count += 1\\n\\n        return head\\n\\n```\\n\\n\\n---\\n\\n# Solution no. 02\\n\\n# Intuition\\nIn our first approach we counted the total number of nodes in the linked list and then identify the n-th node from the end by its position from the beginning. While this counting approach could work, it involves traversing the list twice: once to count the nodes and once to find the node to remove. This double traversal can be inefficient, especially for large lists.\\n\\nA more efficient approach comes from recognizing that we don\\'t really need to know the total number of nodes in the list to solve this problem. Instead, we can utilize two pointers to maintain a specific gap between them as they traverse the list. This gap will be the key to identifying the n-th node from the end.\\n\\n# Approach\\n1. We\\'ll use two pointers, first and second, initialized to a dummy node at the beginning of the linked list. The goal is to maintain a gap of n+1 nodes between the two pointers as we traverse the list.\\n\\n1. Move the first pointer n+1 steps ahead, creating a gap of n nodes between first and second.\\n\\n1. Now, move both first and second pointers one step at a time until the first pointer reaches the end of the list. This ensures that the gap between the two pointers remains constant at n nodes.\\n\\n1. When first reaches the end, the second pointer will be pointing to the node right before the node we want to remove (n-th node from the end).\\n\\n1. Update the second.next pointer to skip the n-th node, effectively removing it from the list.\\n\\n# Complexity\\n- Time complexity:\\n The solution involves a single pass through the linked list, so the time complexity is **O(N)**, where N is the number of nodes in the linked list.\\n\\n- Space complexity:\\nWe are using a constant amount of extra space to store the dummy, first, and second pointers, so the space complexity is **O(1)**.\\n\\n# Code\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        \\n        first = dummy\\n        second = dummy\\n        \\n        # Advance first pointer so that the gap between first and second is n+1 nodes apart\\n        for i in range(n+1):\\n            first = first.next\\n        \\n        # Move first to the end, maintaining the gap\\n        while first:\\n            first = first.next\\n            second = second.next\\n        \\n        # Remove the nth node from the end\\n        second.next = second.next.next\\n        \\n        return dummy.next \\n\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        count = 0\\n        curr = head\\n        while curr:\\n            count += 1\\n            curr = curr.next\\n\\n        check = count - n - 1\\n        count = 0\\n        curr = head\\n\\n        # Removing the first node\\n        if check == -1:  \\n            return head.next\\n\\n        while curr:\\n            if count == check:\\n                curr.next = curr.next.next\\n                # As the removal is done, Exit the loop\\n                break  \\n            curr = curr.next\\n            count += 1\\n\\n        return head\\n\\n```\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        \\n        first = dummy\\n        second = dummy\\n        \\n        # Advance first pointer so that the gap between first and second is n+1 nodes apart\\n        for i in range(n+1):\\n            first = first.next\\n        \\n        # Move first to the end, maintaining the gap\\n        while first:\\n            first = first.next\\n            second = second.next\\n        \\n        # Remove the nth node from the end\\n        second.next = second.next.next\\n        \\n        return dummy.next \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558592,
                "title": "2-different-python-solutions-with-explanation",
                "content": "# Solution 1: Two Passes\\nThe reason why this problem is a medium and not an easy one is because we need to remove the nth node **from the end**. To do this, we need to find the length of the linked list. That is why we need 2 passes: one to find the length of the linked list and another to actually remove the node.\\n\\nWe first set `i` as the head and iterate the entire list, with each iteration adding 1 to the length. That is really basic.\\n\\nNow that we have our length, we can remove the node. To remove a node, you set the previous node\\'s link to the node after the one we remove. \\n\\nSay we want to remove node 2: we set 1\\'s next link to 3 instead of 2. Therefore the linked list becomes 0, 1, 3.\\n```txt\\n 0------->1------->2------->3\\n 0        1        2        3\\n|_|----->|_|-------------->|_|\\n```\\n\\nAlso, the corner case is that `n` is the length, in which we don\\'t do anything but return the node after `head`.\\n\\nNow onto removing the node:\\nWe move our `j` pointer to the node **before** the node we want to remove. To do that, we need to mvoe it `length-n-1` times. \\n\\nOnce we are at that desired node, we just set `j`\\'s next pointer to the node after the node we want to remove. \\n\\nFor those of you who are worried about memory leaks: python has a garbage collection system that\\'s automated, so you don\\'t have to take care of that.\\n```py\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        i = head\\n        length = 0\\n        while i:\\n            i = i.next\\n            length += 1\\n            \\n        if length == n:\\n            return head.next\\n        j = head\\n        for x in range(length-n-1):\\n            j = j.next\\n        j.next = j.next.next\\n        return head\\n```\\n\\n# Solution 2: One Pass\\nThis is the optimal solution: we maintain two pointers and are able to do the entire thing (find length and remove node) in **one pass**.\\n\\nThe trick is that the distance between the 2 pointers is `n`, so when we have the right pointer at the end, the left pointer will be exactly at the node before the node we want to remove. \\n\\nNote: to prevent the right node from becoming None (go after the last node), I use `while right.next` instead of `while right` as my loop definition\\n\\nWe first move the right pointer `n` times, so that the distance between the left and right pointers is `n`.\\n\\nNow we maintain this \"window\" and move both pointers until the right pointer is at the end of the list. Now, the left pointer is at the node before the node we want to remove, so we can just remove the node. \\n\\nIf you want to know how to remove a node, I explain it in the first solution (so scroll up). \\n```py\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        left = right = head\\n        for i in range(n):\\n            right = right.next\\n            \\n        if not right:\\n            return left.next\\n        \\n        while right.next:\\n            left = left.next\\n            right = right.next\\n        left.next = left.next.next\\n        return head\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```txt\\n 0------->1------->2------->3\\n 0        1        2        3\\n|_|----->|_|-------------->|_|\\n```\n```py\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        i = head\\n        length = 0\\n        while i:\\n            i = i.next\\n            length += 1\\n            \\n        if length == n:\\n            return head.next\\n        j = head\\n        for x in range(length-n-1):\\n            j = j.next\\n        j.next = j.next.next\\n        return head\\n```\n```py\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        left = right = head\\n        for i in range(n):\\n            right = right.next\\n            \\n        if not right:\\n            return left.next\\n        \\n        while right.next:\\n            left = left.next\\n            right = right.next\\n        left.next = left.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109517,
                "title": "python3-beats-99-97-remove-nth-node-from-list-s-end",
                "content": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        first = second = head\\n        for _ in range(n):\\n            first = first.next\\n            \\n        if not first:\\n            return head.next\\n        while first.next:\\n            first = first.next\\n            second = second.next\\n        \\n        second.next = second.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        first = second = head\\n        for _ in range(n):\\n            first = first.next\\n            \\n        if not first:\\n            return head.next\\n        while first.next:\\n            first = first.next\\n            second = second.next\\n        \\n        second.next = second.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504455,
                "title": "my-c-solution-one-pass",
                "content": "Runtime: 92 ms, faster than 75.77% of C# online submissions for Remove Nth Node From End of List.\\nMemory Usage: 24.8 MB, less than 10.00% of C# online submissions for Remove Nth Node From End of List.\\n\\n```\\npublic ListNode RemoveNthFromEnd(ListNode head, int n) {\\n    var left = head;\\n    var right = head;\\n\\n    while(right != null) {\\n        right = right.next;\\n        if (n-- < 0) left = left.next; \\n    } \\n\\n    if (n == 0) head = head.next;\\n    else left.next = left.next.next;\\n\\n    return head;        \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode RemoveNthFromEnd(ListNode head, int n) {\\n    var left = head;\\n    var right = head;\\n\\n    while(right != null) {\\n        right = right.next;\\n        if (n-- < 0) left = left.next; \\n    } \\n\\n    if (n == 0) head = head.next;\\n    else left.next = left.next.next;\\n\\n    return head;        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9025,
                "title": "simple-python-solution-one-pass",
                "content": "    # Definition for singly-linked list.\\n    # class ListNode(object):\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.next = None\\n    \\n    class Solution(object):\\n        def removeNthFromEnd(self, head, n):\\n            \"\"\"\\n            :type head: ListNode\\n            :type n: int\\n            :rtype: ListNode\\n            \"\"\"\\n            runner = head\\n            slow = head\\n            for i in xrange(n):\\n                runner = runner.next\\n            if runner is None:       # case where n is the length of the list -- remove first node\\n                head = head.next\\n                return head\\n            while runner.next != None:\\n                runner = runner.next\\n                slow = slow.next\\n            slow.next = slow.next.next\\n            return head",
                "solutionTags": [
                    "Python"
                ],
                "code": "    # Definition for singly-linked list.\\n    # class ListNode(object):\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.next = None\\n    \\n    class Solution(object):\\n        def removeNthFromEnd(self, head, n):\\n            \"\"\"\\n            :type head: ListNode\\n            :type n: int\\n            :rtype: ListNode\\n            \"\"\"\\n            runner = head\\n            slow = head\\n            for i in xrange(n):\\n                runner = runner.next\\n            if runner is None:       # case where n is the length of the list -- remove first node\\n                head = head.next\\n                return head\\n            while runner.next != None:\\n                runner = runner.next\\n                slow = slow.next\\n            slow.next = slow.next.next\\n            return head",
                "codeTag": "Java"
            },
            {
                "id": 9095,
                "title": "my-simple-java-solution",
                "content": "    public class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\t\\twhile(fast != null) {\\n\\t\\t\\tfast = fast.next;\\n        \\tif(n-- < 0) {\\n        \\t\\tslow = slow.next;\\n        \\t}\\n        }\\n\\t\\t\\n\\t\\tif(n == 0) {\\n\\t\\t\\thead = head.next;\\n\\t\\t} else if(n < 0) {\\n\\t\\t\\tslow.next = slow.next.next;\\n\\t\\t} else {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn head;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\t\\twhile(fast != null) {\\n\\t\\t\\tfast = fast.next;\\n        \\tif(n-- < 0) {\\n        \\t\\tslow = slow.next;\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3748032,
                "title": "c-2-pointers",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int k) {\\n        ListNode *pre_slow, *slow, *fast;\\n        pre_slow=NULL;\\n        slow=fast=head;\\n        \\n        for(int i=0;i<k;i++) fast=fast->next;\\n        \\n        while(fast!=NULL){\\n            pre_slow=slow;\\n            slow=slow->next;\\n            fast=fast->next;\\n        }\\n        \\n        if(pre_slow==NULL){\\n            ListNode* new_head = head->next;\\n            delete head;\\n            return new_head;\\n        }\\n    \\n        pre_slow->next=slow->next;\\n        slow->next=NULL;\\n        delete slow;\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int k) {\\n        ListNode *pre_slow, *slow, *fast;\\n        pre_slow=NULL;\\n        slow=fast=head;\\n        \\n        for(int i=0;i<k;i++) fast=fast->next;\\n        \\n        while(fast!=NULL){\\n            pre_slow=slow;\\n            slow=slow->next;\\n            fast=fast->next;\\n        }\\n        \\n        if(pre_slow==NULL){\\n            ListNode* new_head = head->next;\\n            delete head;\\n            return new_head;\\n        }\\n    \\n        pre_slow->next=slow->next;\\n        slow->next=NULL;\\n        delete slow;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257400,
                "title": "c-python-easy-one-pass-0-ms-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> nodes;\\n        ListNode* temp = head;\\n        while (temp)\\n        {\\n            nodes.push_back(temp);\\n            temp = temp->next;\\n        }\\n        if (nodes.size()==1) return NULL;\\n        if (nodes.size()-n<=0) return nodes[1];\\n        ListNode* node = nodes[nodes.size()-1-n];\\n        node->next = node->next->next;\\n        return head;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        nodes = []\\n        temp = head\\n        while (temp):\\n            nodes.append(temp)\\n            temp = temp.next\\n        if (len(nodes)==1): return None\\n        if (len(nodes)-n<=0): return nodes[1]\\n        node = nodes[len(nodes)-1-n]\\n        node.next= node.next.next\\n        return head\\n```\\n\\nUpvote if this helps please \\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> nodes;\\n        ListNode* temp = head;\\n        while (temp)\\n        {\\n            nodes.push_back(temp);\\n            temp = temp->next;\\n        }\\n        if (nodes.size()==1) return NULL;\\n        if (nodes.size()-n<=0) return nodes[1];\\n        ListNode* node = nodes[nodes.size()-1-n];\\n        node->next = node->next->next;\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        nodes = []\\n        temp = head\\n        while (temp):\\n            nodes.append(temp)\\n            temp = temp.next\\n        if (len(nodes)==1): return None\\n        if (len(nodes)-n<=0): return nodes[1]\\n        node = nodes[len(nodes)-1-n]\\n        node.next= node.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198611,
                "title": "python-two-pointer-clean-simple-o-n-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode()\\n        dummy.next = head\\n\\n        pnt1, pnt2 = dummy, head\\n        for _ in range(n):\\n            pnt2 = pnt2.next\\n\\n        while pnt2:\\n            pnt1, pnt2 = pnt1.next, pnt2.next\\n        \\n        pnt1.next = pnt1.next.next\\n        return dummy.next\\n\\n```\\n\\n## Easy To Understand Solution :\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        trav = head\\n        size = 0\\n        while True:\\n            size += 1\\n            trav = trav.next\\n            if trav == None:\\n                break\\n        \\n        if size == 1:\\n            return None\\n        \\n        if size == n:\\n            return head.next\\n        \\n        \\n        trav = head\\n        while size != n + 1:# or you can write size - n - 1 != 0 :\\n            trav = trav.next\\n            n+=1\\n        \\n        trav.next = trav.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode()\\n        dummy.next = head\\n\\n        pnt1, pnt2 = dummy, head\\n        for _ in range(n):\\n            pnt2 = pnt2.next\\n\\n        while pnt2:\\n            pnt1, pnt2 = pnt1.next, pnt2.next\\n        \\n        pnt1.next = pnt1.next.next\\n        return dummy.next\\n\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        trav = head\\n        size = 0\\n        while True:\\n            size += 1\\n            trav = trav.next\\n            if trav == None:\\n                break\\n        \\n        if size == 1:\\n            return None\\n        \\n        if size == n:\\n            return head.next\\n        \\n        \\n        trav = head\\n        while size != n + 1:# or you can write size - n - 1 != 0 :\\n            trav = trav.next\\n            n+=1\\n        \\n        trav.next = trav.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061329,
                "title": "javascript-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\n\\n\\nhttps://youtu.be/yvYtR-KPD6c\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    let arr = []\\n    let res = new ListNode()\\n    let copy = res;\\n    while(head){\\n        arr.push(head.val)\\n        head = head.next;\\n    }\\n    for(let i =0; i<arr.length;i++){\\n        if(arr.length-i == n) continue;\\n        copy.next = new ListNode(arr[i])\\n        copy = copy.next;\\n    }\\n    return res.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    let arr = []\\n    let res = new ListNode()\\n    let copy = res;\\n    while(head){\\n        arr.push(head.val)\\n        head = head.next;\\n    }\\n    for(let i =0; i<arr.length;i++){\\n        if(arr.length-i == n) continue;\\n        copy.next = new ListNode(arr[i])\\n        copy = copy.next;\\n    }\\n    return res.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2632628,
                "title": "python3-19-remove-nth-node-from-end-of-list-t-m-93-70",
                "content": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        \\n        sz, ptr = 0, head\\n        \\n        while ptr:\\n            ptr = ptr.next\\n            sz+=1\\n\\n        if n==sz:\\n            return head.next\\n\\n        sz -= n+1\\n        ptr = head \\n          \\n        while sz > 0:\\n            ptr = ptr.next\\n            sz-=1\\n            \\n        ptr.next = ptr.next.next   \\n        \\n        return head\\n\\t\\t\\n```\\t\\n\\n[https://leetcode.com/submissions/detail/787596599/](http://)\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        \\n        sz, ptr = 0, head\\n        \\n        while ptr:\\n            ptr = ptr.next\\n            sz+=1\\n\\n        if n==sz:\\n            return head.next\\n\\n        sz -= n+1\\n        ptr = head \\n          \\n        while sz > 0:\\n            ptr = ptr.next\\n            sz-=1\\n            \\n        ptr.next = ptr.next.next   \\n        \\n        return head\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632561,
                "title": "daily-leetcoding-challenge-september-day-28",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-nth-node-from-end-of-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two pass algorithm\n\n  \n**Approach 2:** One pass algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-nth-node-from-end-of-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1460289,
                "title": "java-solution-using-two-pointer-and-in-one-pass",
                "content": "Idea:- For solving this question in one pass we can use two pointer approach. In this approach we make two pointer and maintain a gap of size n-1 between these two pointers. \\nWhen first pointer is at the end of the list we sure that second pointer at n+1 position from end . Now we need only remove nth element with the help of second pointer.\\nThe Only edge case is when (n==size of list).\\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode p1=head,p2=head;\\n        while(p1!=null&&p1.next!=null){\\n            if(n<=0){\\n                p2=p2.next;\\n            }\\n            p1=p1.next;\\n            --n;\\n        }\\n        if(n>0){                      // The only edge case removed with this condition\\n            head=head.next;\\n        }else{\\n            p2.next=p2.next.next;\\n        }\\n        return head;\\n    }\\n}\\n// If you like the code and concept than Please UpVote me :)",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode p1=head,p2=head;\\n        while(p1!=null&&p1.next!=null){\\n            if(n<=0){\\n                p2=p2.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1376782,
                "title": "simple-one-pass-solution-in-java-explained-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        // Create two nodes pointing to head;\\n        var first = head;\\n        var second = head;\\n        \\n        // make second node n nodes ahead of first node;\\n        for (int i =0; i <n; i++)\\n            second = second.next;\\n        \\n        // If second node is null, that mean n == list.size-1;\\n        // that means we have to remove the head of the list;\\n        if (second == null)\\n            return first.next;\\n        \\n        // if second node is not null, lets move both first and second nodes\\n        // until second.next == null;\\n        // remember after this, first node will n+1 nodes from the end;\\n        while(second.next != null) {\\n            first = first.next;\\n            second = second.next;\\n        }\\n        \\n        // we can easily skip nth node and make first.next point to n.next;\\n        first.next = first.next.next;\\n        \\n        return head;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        // Create two nodes pointing to head;\\n        var first = head;\\n        var second = head;\\n        \\n        // make second node n nodes ahead of first node;\\n        for (int i =0; i <n; i++)\\n            second = second.next;\\n        \\n        // If second node is null, that mean n == list.size-1;\\n        // that means we have to remove the head of the list;\\n        if (second == null)\\n            return first.next;\\n        \\n        // if second node is not null, lets move both first and second nodes\\n        // until second.next == null;\\n        // remember after this, first node will n+1 nodes from the end;\\n        while(second.next != null) {\\n            first = first.next;\\n            second = second.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 922955,
                "title": "clean-c-solution",
                "content": "```c\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    struct ListNode *p=head, *q=head;\\n\\t// delay by n nodes.\\n    for(int i=0; i<n; i++) {\\n        p = p->next;\\n    }\\n    if(!p) {\\n        //remove head\\n        return head->next;\\n    }\\n\\t// pass through\\n    while(p->next) {\\n        p = p->next;\\n        q = q->next;\\n    }\\n    q->next = q->next->next;\\n    return head;\\n}\\n```\\n\\nAlthough there are two loop, but it is still a one pass solution.",
                "solutionTags": [],
                "code": "```c\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    struct ListNode *p=head, *q=head;\\n\\t// delay by n nodes.\\n    for(int i=0; i<n; i++) {\\n        p = p->next;\\n    }\\n    if(!p) {\\n        //remove head\\n        return head->next;\\n    }\\n\\t// pass through\\n    while(p->next) {\\n        p = p->next;\\n        q = q->next;\\n    }\\n    q->next = q->next->next;\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 913192,
                "title": "two-pointers-farer-than-99-67-memory-less-than-99-98",
                "content": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast = head\\n        while n > 0:\\n            fast = fast.next\\n            n -= 1\\n        if not fast: return head.next\\n        slow = head\\n        while fast.next:\\n            fast = fast.next\\n            slow = slow.next\\n        slow.next = slow.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast = head\\n        while n > 0:\\n            fast = fast.next\\n            n -= 1\\n        if not fast: return head.next\\n        slow = head\\n        while fast.next:\\n            fast = fast.next\\n            slow = slow.next\\n        slow.next = slow.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 288895,
                "title": "unsafe-rust-single-pass-solution",
                "content": "The fastest solution is to use two pointers, one in front and the other n step back. When the front pointer hits the end of the list, the tail pointer points at the node to remove. So the front pointer can be immutable while the tail one must be mutable. \\n\\nHowever, we cannot have both an immutable and a mutable reference to the same object in safe rust --- I spent quite some time fighting with the borrow checker and realised this is impossible (correct me if I\\'m wrong) --- so the safe rust solution requires two passes: one for the length of list, the other for removing the node.\\n\\nHere is a solution with unsafe rust which should be the most performant.\\n```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        unsafe {\\n            let mut head = head;\\n            let mut front: *mut Option<Box<ListNode>> = &mut head;\\n            let mut tail: *mut Option<Box<ListNode>> = &mut head;\\n            for _ in 0..n {\\n                front = &mut (*front).as_mut().unwrap().next;\\n            }\\n            if (*front).is_none() {\\n                return head.take().unwrap().next;\\n            }\\n            loop {\\n                front = &mut (*front).as_mut().unwrap().next;\\n                if (*front).is_none() {\\n                    break;\\n                }\\n                tail = &mut (*tail).as_mut().unwrap().next;\\n            }\\n            (*tail).as_mut().unwrap().next = (*tail).as_mut().unwrap().next.as_mut().unwrap().next.take();\\n            head\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        unsafe {\\n            let mut head = head;\\n            let mut front: *mut Option<Box<ListNode>> = &mut head;\\n            let mut tail: *mut Option<Box<ListNode>> = &mut head;\\n            for _ in 0..n {\\n                front = &mut (*front).as_mut().unwrap().next;\\n            }\\n            if (*front).is_none() {\\n                return head.take().unwrap().next;\\n            }\\n            loop {\\n                front = &mut (*front).as_mut().unwrap().next;\\n                if (*front).is_none() {\\n                    break;\\n                }\\n                tail = &mut (*tail).as_mut().unwrap().next;\\n            }\\n            (*tail).as_mut().unwrap().next = (*tail).as_mut().unwrap().next.as_mut().unwrap().next.take();\\n            head\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 247310,
                "title": "python-one-pass",
                "content": "Suppose the length of linked list is L, the distance between the node to delete and the tail is **|node-tail| = N**. Then **|node-head| = L-N**. So we can use two pointers here to get that **L-N**.\\n\\nPointer **a** first walks N units and there are L-N units left that **a** can walk. Then we have **b** start walking from the head and **a** keep walking simultaneously. \\nAfter **L-N** rounds,  **a** will reach the tail and **b** has walked L-N from the head, with a distance N away from the tail. So when **a** reaches the tail, we know the node that **b** is pointing at is what to delete.\\n\\nIn case the head node is what to delete, we can create a dummy head whose next node is the **head**. Then we have both a and b point at the dummy and eventually return **dummy.next**.\\n```\\ndef removeNthFromEnd(head, n):\\n\\ta = b = dummy = ListNode(0)\\n\\tdummy.next = head\\n\\tfor _ in range(n): \\n\\t\\ta = a.next\\n\\twhile a.next: \\n\\t\\ta, b = a.next, b.next\\n\\tb.next = b.next.next\\n\\treturn dummy.next\\n```\\nIt\\'s a one pass O(n) time O(1) space solution.",
                "solutionTags": [],
                "code": "```\\ndef removeNthFromEnd(head, n):\\n\\ta = b = dummy = ListNode(0)\\n\\tdummy.next = head\\n\\tfor _ in range(n): \\n\\t\\ta = a.next\\n\\twhile a.next: \\n\\t\\ta, b = a.next, b.next\\n\\tb.next = b.next.next\\n\\treturn dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 220627,
                "title": "rust-0-ms-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        let mut dummy_head = Some(Box::new(ListNode {\\n            val: 0, next: head,\\n        }));\\n        let mut len = 0;\\n        {\\n            let mut p = dummy_head.as_ref();\\n            while p.unwrap().next.is_some() {\\n                len += 1;\\n                p = p.unwrap().next.as_ref();\\n            }\\n        }\\n        let idx = len - n;\\n        {\\n            let mut p = dummy_head.as_mut();\\n            for _ in 0..(idx) {\\n                p = p.unwrap().next.as_mut();\\n            }\\n            let next = p.as_mut().unwrap().next.as_mut().unwrap().next.take();\\n            p.as_mut().unwrap().next = next;\\n        }\\n        dummy_head.unwrap().next\\n    }\\n}\\n```\\nAfter hours figting with borrow checker, I think the \"One Pass\" algorithm cannot be written in Rust without `unsafe`. \\nBut actually the two pass solution is just as fast as one pass solution (times of moving pointer should be same), so just take it.",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        let mut dummy_head = Some(Box::new(ListNode {\\n            val: 0, next: head,\\n        }));\\n        let mut len = 0;\\n        {\\n            let mut p = dummy_head.as_ref();\\n            while p.unwrap().next.is_some() {\\n                len += 1;\\n                p = p.unwrap().next.as_ref();\\n            }\\n        }\\n        let idx = len - n;\\n        {\\n            let mut p = dummy_head.as_mut();\\n            for _ in 0..(idx) {\\n                p = p.unwrap().next.as_mut();\\n            }\\n            let next = p.as_mut().unwrap().next.as_mut().unwrap().next.take();\\n            p.as_mut().unwrap().next = next;\\n        }\\n        dummy_head.unwrap().next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9101,
                "title": "my-c-solution",
                "content": "    class Solution {\\n    public:\\n        ListNode *removeNthFromEnd(ListNode *head, int n) {\\n            ListNode* front = new ListNode(0);\\n    \\t\\tfront->next = head;\\n    \\t\\tListNode* prev = front;\\n    \\t\\tListNode* post = front;\\n    \\t\\twhile (prev != nullptr){\\n    \\t\\t\\tprev = prev->next;\\n    \\t\\t\\tif (n<0)\\tpost = post->next;\\n    \\t\\t\\tn--;\\n    \\t\\t}\\n    \\t\\tListNode* temp = post->next;\\n    \\t\\tpost->next = temp->next;\\n    \\t\\tdelete temp;\\n    \\t\\treturn front->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *removeNthFromEnd(ListNode *head, int n) {\\n            ListNode* front = new ListNode(0);\\n    \\t\\tfront->next = head;\\n    \\t\\tListNode* prev = front;\\n    \\t\\tListNode* post = front;\\n    \\t\\twhile (prev != nullptr){\\n    \\t\\t\\tprev = prev->next;\\n    \\t\\t\\tif (n<0)\\tpost = post->next;\\n    \\t\\t\\tn--;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 8819,
                "title": "my-one-pass-solution-with-two-pointers",
                "content": "    class Solution:\\n\\tdef removeNthFromEnd(self, head, n):\\n\\t\\tcur = head\\n\\t\\tnpre= head\\n\\t\\tdis = 0\\n\\t\\tcount = 1\\n\\t\\twhile cur.next is not None:\\n\\t\\t\\tcur = cur.next\\n\\t\\t\\tcount += 1\\n\\t\\t\\tdis += 1\\n\\t\\t\\twhile dis > n:\\n\\t\\t\\t\\tnpre = npre.next\\n\\t\\t\\t\\tdis -= 1\\n\\t\\tif count <= n:\\n\\t\\t\\treturn head.next\\n\\t\\tnpre.next = npre.next.next\\n\\t\\treturn head\\n\\nYou should pay attention to the case which removes the first node.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n\\tdef removeNthFromEnd(self, head, n):\\n\\t\\tcur = head\\n\\t\\tnpre= head\\n\\t\\tdis = 0\\n\\t\\tcount = 1\\n\\t\\twhile cur.next is not None:\\n\\t\\t\\tcur = cur.next\\n\\t\\t\\tcount += 1\\n\\t\\t\\tdis += 1\\n\\t\\t\\twhile dis > n:\\n\\t\\t\\t\\tnpre = npre.next\\n\\t\\t\\t\\tdis -= 1\\n\\t\\tif count <= n:\\n\\t\\t\\treturn head.next\\n\\t\\tnpre.next = npre.next.next\\n\\t\\treturn head\\n\\nYou should pay attention to the case which removes the first node.",
                "codeTag": "Java"
            },
            {
                "id": 3145684,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nTwo Pass\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if (head->next == NULL && n == 1)\\n            return NULL;\\n        ListNode* curr = head;\\n        int count = 0;\\n        while (curr != NULL) {\\n            count++;\\n            curr = curr->next;\\n        }\\n        if (count == n)\\n            return head->next;\\n        int cnt = count - n - 1;\\n        curr = head;\\n        while (cnt--) \\n            curr = curr->next;\\n        curr->next = curr->next->next;\\n        return head;\\n    }\\n};\\n```\\n\\n# Approach 2\\nOne Pass\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if (head->next == NULL && n == 1)\\n            return NULL;\\n        ListNode* slow = head, * fast = head;\\n        while (n--) \\n            fast = fast->next;\\n        if (fast == NULL)\\n            return head->next;    \\n        while (fast->next != NULL) {\\n            slow = slow->next;\\n            fast = fast->next;\\n        }    \\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if (head->next == NULL && n == 1)\\n            return NULL;\\n        ListNode* curr = head;\\n        int count = 0;\\n        while (curr != NULL) {\\n            count++;\\n            curr = curr->next;\\n        }\\n        if (count == n)\\n            return head->next;\\n        int cnt = count - n - 1;\\n        curr = head;\\n        while (cnt--) \\n            curr = curr->next;\\n        curr->next = curr->next->next;\\n        return head;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if (head->next == NULL && n == 1)\\n            return NULL;\\n        ListNode* slow = head, * fast = head;\\n        while (n--) \\n            fast = fast->next;\\n        if (fast == NULL)\\n            return head->next;    \\n        while (fast->next != NULL) {\\n            slow = slow->next;\\n            fast = fast->next;\\n        }    \\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100048,
                "title": "beats-100-c-easy-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake a gap of N between two pointers, \\nthen increment both pointer one step at a time, until succeeding pointer reaches the end!\\nThe preceding pointer will automatically be pointing at \\n(LL.size() - n)th position.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(!head->next){\\n            return head->next;\\n        }\\n        ListNode* prevHold = NULL;\\n        ListNode* prev = head;\\n        ListNode* fwd = head;\\n        --n;\\n        while(n--){\\n            fwd = fwd->next;\\n        }\\n        if(!fwd->next){\\n            return head->next;\\n        }\\n        while(fwd->next){\\n            prevHold = prev;\\n            prev = prev->next;\\n            fwd = fwd->next;\\n        }\\n        prevHold->next = prev->next;\\n        delete prev;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(!head->next){\\n            return head->next;\\n        }\\n        ListNode* prevHold = NULL;\\n        ListNode* prev = head;\\n        ListNode* fwd = head;\\n        --n;\\n        while(n--){\\n            fwd = fwd->next;\\n        }\\n        if(!fwd->next){\\n            return head->next;\\n        }\\n        while(fwd->next){\\n            prevHold = prev;\\n            prev = prev->next;\\n            fwd = fwd->next;\\n        }\\n        prevHold->next = prev->next;\\n        delete prev;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637475,
                "title": "simple-beginner-friendly-easy-to-understand-0ms",
                "content": "```class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* dummynode = new ListNode(0);  // creating dummy node;\\n\\t\\t\\n\\t\\t// if head has only one node (base case)\\n        if(head->next==NULL){\\n            head=head->next;\\n            delete(head);\\n            return dummynode->next;\\n        }\\n        dummynode->next=head; // dummy node pointing to head\\n        ListNode* prev=head;  // previous pointer to store previous node\\n        ListNode* curr=head; // current poninter to point current node\\n        int count=1;\\n        while(curr->next!=NULL){\\n                if(count!=n){\\n                    count++;\\n                    curr=curr->next;\\n                    continue;\\n                }\\n            curr=curr->next;\\n            prev=prev->next;\\n        }\\n        \\n\\t\\t\\n\\t\\t//if we have to delete head;\\n\\t\\t\\n        if(dummynode->next==head && count!=1 && prev==head){\\n            dummynode->next=head->next;\\n            return dummynode->next;\\n        }\\n\\t\\t// traversing till one node begind prev node\\n        while(head->next!=prev && head!=prev){\\n            head=head->next;\\n        }\\n        head->next=prev->next;\\n        \\n        return dummynode->next;\\n        \\n    }\\n};```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* dummynode = new ListNode(0);  // creating dummy node;\\n\\t\\t\\n\\t\\t// if head has only one node (base case)\\n        if(head->next==NULL){\\n            head=head->next;\\n            delete(head);\\n            return dummynode->next;\\n        }\\n        dummynode->next=head; // dummy node pointing to head\\n        ListNode* prev=head;  // previous pointer to store previous node\\n        ListNode* curr=head; // current poninter to point current node\\n        int count=1;\\n        while(curr->next!=NULL){\\n                if(count!=n){\\n                    count++;\\n                    curr=curr->next;\\n                    continue;\\n                }\\n            curr=curr->next;\\n            prev=prev->next;\\n        }\\n        \\n\\t\\t\\n\\t\\t//if we have to delete head;\\n\\t\\t\\n        if(dummynode->next==head && count!=1 && prev==head){\\n            dummynode->next=head->next;\\n            return dummynode->next;\\n        }\\n\\t\\t// traversing till one node begind prev node\\n        while(head->next!=prev && head!=prev){\\n            head=head->next;\\n        }\\n        head->next=prev->next;\\n        \\n        return dummynode->next;\\n        \\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2423563,
                "title": "python-simple-and-clean-beats-90-69",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n**Runner Method**\\n1. Instantiate the fast and slow runner\\n2. *fast* runner moves *n* steps ahead of the *slow* runner\\n3. Meanwhile, the *fast* runner reaches the end, *slow* runner will be at the prev node of the target node.\\n4. Then we just delete the target node and return the head the of the LL.\\n\\n***Implementation***\\n\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        #Step 1\\n\\t\\tslow = fast = head\\n\\t\\t\\n\\t\\t#Step 2\\n        while(n>0):\\n            fast = fast.next\\n            n-=1\\n\\t\\t\\t\\n\\t\\t#Step 3\\n        while(fast and fast.next):\\n            slow = slow.next\\n            fast = fast.next\\n\\t\\t\\t\\n\\t\\t#Step 4\\n        if(fast):\\n            slow.next = slow.next.next\\n        else:\\n            head = head.next\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        #Step 1\\n\\t\\tslow = fast = head\\n\\t\\t\\n\\t\\t#Step 2\\n        while(n>0):\\n            fast = fast.next\\n            n-=1\\n\\t\\t\\t\\n\\t\\t#Step 3\\n        while(fast and fast.next):\\n            slow = slow.next\\n            fast = fast.next\\n\\t\\t\\t\\n\\t\\t#Step 4\\n        if(fast):\\n            slow.next = slow.next.next\\n        else:\\n            head = head.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706885,
                "title": "my-single-loop-solution-in-c-o-n-time-o-1-space-complexity",
                "content": "```\\nListNode *removeNthFromEnd(ListNode *head, int n){\\n    ListNode *p = head, *q = head;\\n    while (q) {\\n        if (n < 0)  p = p->next;\\n        else  n--;\\n        q = q->next;\\n    }\\n    if (n == 0) head = head->next;\\n    else  p->next = p->next->next;\\n    return head;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode *removeNthFromEnd(ListNode *head, int n){\\n    ListNode *p = head, *q = head;\\n    while (q) {\\n        if (n < 0)  p = p->next;\\n        else  n--;\\n        q = q->next;\\n    }\\n    if (n == 0) head = head->next;\\n    else  p->next = p->next->next;\\n    return head;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677829,
                "title": "c-two-pointer-easy-to-understand-time-o-n-space-o-1",
                "content": "![image](https://assets.leetcode.com/users/images/aa9908c4-58aa-4d16-a850-5885515a9064_1642417916.7980297.jpeg)\\n**Please Upvote if it helps...!**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        int count = n;\\n        while(count > 0)\\n        {\\n            fast = fast->next;\\n            count--;\\n        }      \\n        if(fast == NULL)\\n        {\\n            return head->next; // edge case handled\\n        }   \\n        while(fast->next!=NULL)\\n        {\\n            slow=slow->next; \\n            fast=fast->next;\\n        }\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        int count = n;\\n        while(count > 0)\\n        {\\n            fast = fast->next;\\n            count--;\\n        }      \\n        if(fast == NULL)\\n        {\\n            return head->next; // edge case handled\\n        }   \\n        while(fast->next!=NULL)\\n        {\\n            slow=slow->next; \\n            fast=fast->next;\\n        }\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529913,
                "title": "c-one-pass-100-fast-recursion-solution-with-picture",
                "content": "\\n![image](https://assets.leetcode.com/users/images/263aacc8-9c23-403b-b1b0-4ea6dd31b992_1634740578.2843018.jpeg)\\n\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n    int remove(ListNode* head, int n)\\n    {\\n        if(head==NULL)\\n            return 0;\\n        \\n        int steps = remove(head->next, n); //steps to reach the last node from head->next node\\n            \\n        if(steps == n)   //if head->next is the node that we need to remove\\n            head->next = head->next->next;   //then remove it\\n        \\n        return steps+1;\\n    }\\n\\t\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        \\n        if(remove(head, n) == n)   //if head is the node that we need to remove \\n            head = head->next;     \\n        \\n        return head;\\n    }\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int remove(ListNode* head, int n)\\n    {\\n        if(head==NULL)\\n            return 0;\\n        \\n        int steps = remove(head->next, n); //steps to reach the last node from head->next node\\n            \\n        if(steps == n)   //if head->next is the node that we need to remove\\n            head->next = head->next->next;   //then remove it\\n        \\n        return steps+1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1517658,
                "title": "javascript-100-very-simple-tortoise-hare-array-versions",
                "content": "![image](https://assets.leetcode.com/users/images/200ef282-0c57-426a-885e-d02d887785ab_1634065405.0991726.png)\\n\\n\\nEDIT: Upon further testing, the Array tracking version at the bottom seems to consistently score better runtimes here on LC.  They\\'re both O(n).  I still think that this is a classic Tortoise and Hare problem, and that\\'s what they\\'ll be looking for.  But you can Easily defend the Array version as well imo (On Time Complexity at least.  It\\'s still worse on space because it\\'s O(n) space whereas Tortoise and Hare is O(1).).  Take your pick. \\n\\nI wrote two solutions for this problem.  First is the most performant, and the most \\'clever\\' solution that they\\'ll probably want in an interview.  First solution uses tortoise and hare pointers to locate the node which needs to be removed.  Second is FAR easier to code imo, but I\\'m not sure they would consider it optimal in an interview if they\\'re looking for constant space.  Second stores linked list nodes in an array and then we can locate which nodes we need Very easily and remove them.  That said, it does take extra space to store in the array and this is a classic \\'tortoise and hare\\' problem - so if they\\'re asking it, they\\'re likely looking for the first solution.  If you strugle to implement it on the spot though, the second version might save face in a pinch.\\n\\nEitherway though, the basic intuition is to \\'locate\\' the node Before the one to be removed.  There are three possibilities here.  1.) Node to be removed is the head node.  I.E. - The one we need to locate Before it doesn\\'t exist.  In this case, our hare will end up at null after it loops. Or in the Array version, llMap.length - n - 1 will be -1.  We then just simply return head.next which \\'removes\\' the original head node.  2.) Node to be removed is at the End of the list.  In this case, our node Before it has a node.next, but node.next.next = null.  Here our code for case 3 works as well because it will just set node.next = null, which \\'removes\\' our node.next (The last node.) 3.)  Normal Linked List node removal.  There is a node.next (One to be removed since we located the node Before it.), and there is a node.next.next.  In this case, we just set node.next = node.next.next and the node is removed.  Hardest part about this problem is locating the correct node.  Tortoise and Hare both start at head.  We then move hare forward n.  After moving hare, we check to see if hare === null (!hare).  If it does, we know the node to remove is the first and we go with case 1.  Then we begin to move tortoise and hare in tandem until hare.next === null.  This means hare is now at the end of the list and turtle is one before the node we need to remove. We have located the correct node.  The storing in an array one is pretty simple, we just store them, and can instantly look up the nth from the end by its array index.\\n\\n```\\nconst removeNthFromEnd = (head, n) => {  \\n  let tortoise = head, hare = head;\\n  \\n  while (n) hare = hare.next, n--;\\n  if (!hare) return head.next;\\n  \\n  while (hare.next) hare = hare.next, tortoise = tortoise.next;       \\n         \\n  tortoise.next = tortoise.next.next\\n  \\n  return head\\n}\\n```\\n\\nTrack by array version.\\n\\n```\\nconst removeNthFromEnd = (head, n) => {\\n  const llMap = [];\\n  \\n  while (head) {\\n    llMap.push(head);\\n    head = head.next;\\n  }\\n    \\n  const prevNode = llMap[llMap.length - n - 1];\\n  \\n  if (!prevNode) return llMap[0].next;\\n  \\n  prevNode.next = prevNode.next.next;\\n    \\n  return llMap[0];\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst removeNthFromEnd = (head, n) => {  \\n  let tortoise = head, hare = head;\\n  \\n  while (n) hare = hare.next, n--;\\n  if (!hare) return head.next;\\n  \\n  while (hare.next) hare = hare.next, tortoise = tortoise.next;       \\n         \\n  tortoise.next = tortoise.next.next\\n  \\n  return head\\n}\\n```\n```\\nconst removeNthFromEnd = (head, n) => {\\n  const llMap = [];\\n  \\n  while (head) {\\n    llMap.push(head);\\n    head = head.next;\\n  }\\n    \\n  const prevNode = llMap[llMap.length - n - 1];\\n  \\n  if (!prevNode) return llMap[0].next;\\n  \\n  prevNode.next = prevNode.next.next;\\n    \\n  return llMap[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1406874,
                "title": "java-brute-force-appraoch",
                "content": "**This is not most optimise!!**\\n1.First we find out the length of linkedlist ;\\n2.then we will loop till the length - n ;\\n3.then we change the **curr.next** to **curr.next.next** ;\\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode p = head;\\n        head = dummy;\\n            \\n        ListNode temp  = head;\\n        int len = size(head);\\n        int i = 0;\\n        if(len <= 1){\\n            return null;\\n        }\\n        \\n        while( i < len - n-1){\\n            temp = temp.next;\\n            i += 1;\\n        }\\n        temp.next = temp.next.next;\\n        return head.next;\\n        \\n    }\\n    public int size(ListNode head){\\n        int size = 0;\\n        while(head != null){\\n            head = head.next;\\n            size++;\\n        }\\n        return size;\\n    }\\n}\\n//This is not most optimise but still we get 0ms Runtime\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode p = head;\\n        head = dummy;\\n            \\n        ListNode temp  = head;\\n        int len = size(head);\\n        int i = 0;\\n        if(len <= 1){\\n            return null;\\n        }\\n        \\n        while( i < len - n-1){\\n            temp = temp.next;\\n            i += 1;\\n        }\\n        temp.next = temp.next.next;\\n        return head.next;\\n        \\n    }\\n    public int size(ListNode head){\\n        int size = 0;\\n        while(head != null){\\n            head = head.next;\\n            size++;\\n        }\\n        return size;\\n    }\\n}\\n//This is not most optimise but still we get 0ms Runtime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304109,
                "title": "c-edge-case-handled-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n//         making three pointers to listNode curr,prev and fi\\n        ListNode* curr=head,*prev=head;\\n        ListNode* fi=NULL;\\n\\n        int x=n;\\n        int count=0;\\n//         incrementing curr n times\\n        while(n--)\\n        {\\n            curr=curr->next;\\n            count++;\\n        }\\n//         check if the number is first to delete or not\\n          if(curr==NULL && x==count)\\n                return head->next;\\n//         if its not the first to delete and the nth node is out of bound\\n            else if(curr==NULL)\\n                return head;\\n       \\n//        simply increment curr till NULL and increment prev as well mainaining a previous pointer\\n        while(curr!=NULL)\\n        {\\n            curr=curr->next;\\n            fi=prev;\\n            prev=prev->next;\\n        }\\n//         deleting the pointer\\n        fi->next=prev->next;\\n//         return the head \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n//         making three pointers to listNode curr,prev and fi\\n        ListNode* curr=head,*prev=head;\\n        ListNode* fi=NULL;\\n\\n        int x=n;\\n        int count=0;\\n//         incrementing curr n times\\n        while(n--)\\n        {\\n            curr=curr->next;\\n            count++;\\n        }\\n//         check if the number is first to delete or not\\n          if(curr==NULL && x==count)\\n                return head->next;\\n//         if its not the first to delete and the nth node is out of bound\\n            else if(curr==NULL)\\n                return head;\\n       \\n//        simply increment curr till NULL and increment prev as well mainaining a previous pointer\\n        while(curr!=NULL)\\n        {\\n            curr=curr->next;\\n            fi=prev;\\n            prev=prev->next;\\n        }\\n//         deleting the pointer\\n        fi->next=prev->next;\\n//         return the head \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867059,
                "title": "c-recursion-faster-than-92-78",
                "content": "```\\n    private int m = 0;\\n    \\n    public ListNode RemoveNthFromEnd(ListNode head, int n) {\\n            \\n        if (head == null)\\n        {\\n            return null;\\n        }\\n\\n        var h = RemoveNthFromEnd(head.next, n);\\n\\n        m++;\\n        if (m == n) return h;\\n\\n        head.next = h;\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int m = 0;\\n    \\n    public ListNode RemoveNthFromEnd(ListNode head, int n) {\\n            \\n        if (head == null)\\n        {\\n            return null;\\n        }\\n\\n        var h = RemoveNthFromEnd(head.next, n);\\n\\n        m++;\\n        if (m == n) return h;\\n\\n        head.next = h;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 609269,
                "title": "javascript-solution",
                "content": "```\\nlet removeNthFromEnd = function(head, n) {\\n    let p = head, node = head\\n    \\n    while(n--){\\n        p = p.next\\n    }\\n    while(p && p.next ) {\\n        p = p.next\\n        node = node.next\\n    }\\n    \\n    if(!p)  head = head.next\\n    else node.next = node.next.next\\n\\n    return head\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet removeNthFromEnd = function(head, n) {\\n    let p = head, node = head\\n    \\n    while(n--){\\n        p = p.next\\n    }\\n    while(p && p.next ) {\\n        p = p.next\\n        node = node.next\\n    }\\n    \\n    if(!p)  head = head.next\\n    else node.next = node.next.next\\n\\n    return head\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 364537,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode newHead = new ListNode(0);\\n        newHead.next = head;\\n        ListNode a = newHead;\\n        ListNode b = newHead;\\n        while(n > 0){\\n            b = b.next;\\n            n--;\\n        }\\n        while(b.next != null){\\n            b = b.next;\\n            a = a.next;\\n        }\\n        a.next = a.next.next;\\n        return newHead.next;\\n    }\\n}\\n```\\n\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Remove Nth Node From End of List.\\nMemory Usage: 34.8 MB, less than 100.00% of Java online submissions for Remove Nth Node From End of List.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode newHead = new ListNode(0);\\n        newHead.next = head;\\n        ListNode a = newHead;\\n        ListNode b = newHead;\\n        while(n > 0){\\n            b = b.next;\\n            n--;\\n        }\\n        while(b.next != null){\\n            b = b.next;\\n            a = a.next;\\n        }\\n        a.next = a.next.next;\\n        return newHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295314,
                "title": "c-brute-force-to-clean-solution-with-explanation",
                "content": "When displaying these problems, developers should show the thought process. \\nHere I show the brute force solution and the cleaner solution. \\n\\n\\nNote the similarities:\\n1. Intialization - Creating that first empty node handles the zero condition\\n2. Deletion - Basic principle of a linked list\\n\\n--------------------------------\\n\\n**BRUTE FORCE**\\nThe brute force uses getting a count first. \\nIt\\'s not pretty but the biggest issue is looping through the list twice. \\n\\n```\\npublic class Solution {\\n    public ListNode RemoveNthFromEnd(ListNode head, int n) {\\n        var start = new ListNode(0);\\n        var node = start;\\n        node.next = head;\\n\\t\\t\\n        // Get Count\\n        var count = GetCount(head);\\n\\t\\t\\n        // Iterate to node to Skip\\n        for(int i = 0; i < count - n; i++) {\\n            node = node.next;\\n        }\\n\\t\\t\\n        // Remove Node\\n        node.next = node.next.next;\\n\\n        return start.next;\\n    }\\n    \\n    private int GetCount(ListNode head) {\\n        var count = 0;\\n        var current = head;\\n        while(current != null) {\\n            count++;\\n            current = current.next;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n------------------------------------------------------------------\\n\\n**DOUBLE POINTER**\\n\\nIf you understand the method to get the count, this becomes more feasible. \\n\\nThe solution that everyone has posted repeatedly. \\n1. Fast pointer - exactly n ahead slow\\n2. Slow pointer - the pointer that will hit length - n\\n\\n```\\npublic class Solution {\\n    public ListNode RemoveNthFromEnd(ListNode head, int n) { \\n        var start = new ListNode(0);\\n        var slow = start;\\n        var fast = start;\\n        slow.next = head;\\n    \\n        // Fast is n in front of slow\\n        for(int i = 0; i <= n;  i++)   {\\n            fast = fast.next;\\n        }\\n        \\n        // When Fast is at end, Slow is at end - n\\n        while(fast != null) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        \\n        // Remove Node\\n        slow.next = slow.next.next;\\n\\n        return start.next;\\n    }    \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode RemoveNthFromEnd(ListNode head, int n) {\\n        var start = new ListNode(0);\\n        var node = start;\\n        node.next = head;\\n\\t\\t\\n        // Get Count\\n        var count = GetCount(head);\\n\\t\\t\\n        // Iterate to node to Skip\\n        for(int i = 0; i < count - n; i++) {\\n            node = node.next;\\n        }\\n\\t\\t\\n        // Remove Node\\n        node.next = node.next.next;\\n\\n        return start.next;\\n    }\\n    \\n    private int GetCount(ListNode head) {\\n        var count = 0;\\n        var current = head;\\n        while(current != null) {\\n            count++;\\n            current = current.next;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public ListNode RemoveNthFromEnd(ListNode head, int n) { \\n        var start = new ListNode(0);\\n        var slow = start;\\n        var fast = start;\\n        slow.next = head;\\n    \\n        // Fast is n in front of slow\\n        for(int i = 0; i <= n;  i++)   {\\n            fast = fast.next;\\n        }\\n        \\n        // When Fast is at end, Slow is at end - n\\n        while(fast != null) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        \\n        // Remove Node\\n        slow.next = slow.next.next;\\n\\n        return start.next;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229716,
                "title": "rust-recursion-0ms",
                "content": "```rust\\npub fn remove(head: Option<Box<ListNode>>, n: i32) -> (i32, Option<Box<ListNode>>) {\\n    if let Some(boxed) = head {\\n        let (mut tail_index, tail) = remove(boxed.next, n);\\n        tail_index += 1;\\n\\n        if tail_index == n {\\n            (tail_index, tail)\\n        } else {\\n            (tail_index, Some(Box::new(ListNode {\\n                val: boxed.val,\\n                next: tail\\n            })))\\n        }\\n    } else {\\n        (0, None)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        remove(head, n).1\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\npub fn remove(head: Option<Box<ListNode>>, n: i32) -> (i32, Option<Box<ListNode>>) {\\n    if let Some(boxed) = head {\\n        let (mut tail_index, tail) = remove(boxed.next, n);\\n        tail_index += 1;\\n\\n        if tail_index == n {\\n            (tail_index, tail)\\n        } else {\\n            (tail_index, Some(Box::new(ListNode {\\n                val: boxed.val,\\n                next: tail\\n            })))\\n        }\\n    } else {\\n        (0, None)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        remove(head, n).1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9034,
                "title": "java-solution-using-recursion",
                "content": "      public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode cur = head;\\n\\t    int count = helper(cur, 0, n);\\n\\t    if (count+1 == n) head = head.next;\\n\\t    return head; \\n    }\\n    \\n    public int helper(ListNode head, int count, int target) {\\n        if (head == null || head.next == null) {\\n            return 0;\\n        }\\n        count = helper(head.next, count, target);\\n        count++;\\n        if (count == target) {\\n            head.next = head.next.next;\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "      public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode cur = head;\\n\\t    int count = helper(cur, 0, n);\\n\\t    if (count+1 == n) head = head.next;\\n\\t    return head; \\n    }\\n    \\n    public int helper(ListNode head, int count, int target) {\\n        if (head == null || head.next == null) {\\n            return 0;\\n        }\\n        count = helper(head.next, count, target);\\n        count++;\\n        if (count == target) {\\n            head.next = head.next.next;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 9039,
                "title": "share-my-4ms-solution",
                "content": "    /**\\n     * Definition for singly-linked list.\\n     * struct ListNode {\\n     *     int val;\\n     *     ListNode *next;\\n     *     ListNode(int x) : val(x), next(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        ListNode* removeNthFromEnd(ListNode* head, int n) {//\\u5f00\\u8f9f\\u4e00\\u4e2a\\u5934\\u7ed3\\u70b9\\u5c31\\u53ef\\u4ee5\\u89e3\\u51b3\\u95ee\\u9898\\u5566\\uff01\\n            if(!head -> next) return NULL;\\n            ListNode* headt = new ListNode(0);\\n            headt -> next = head;\\n            ListNode* forward = headt;\\n            ListNode* tail = headt;\\n            for(int i = 0; i < n; i++){\\n                if(forward -> next) forward = forward -> next;\\n            }\\n            while(forward -> next){\\n                forward = forward -> next;\\n                tail = tail -> next;\\n            }\\n            tail -> next = tail -> next -> next;\\n            return headt -> next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* removeNthFromEnd(ListNode* head, int n) {//\\u5f00\\u8f9f\\u4e00\\u4e2a\\u5934\\u7ed3\\u70b9\\u5c31\\u53ef\\u4ee5\\u89e3\\u51b3\\u95ee\\u9898\\u5566\\uff01\\n            if(!head -> next) return NULL;\\n            ListNode* headt = new ListNode(0);\\n            headt -> next = head;\\n            ListNode* forward = headt;\\n            ListNode* tail = headt;\\n            for(int i = 0; i < n; i++){\\n                if(forward -> next) forward = forward -> next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 9051,
                "title": "java-short-and-clean-solution",
                "content": "    public class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head, slow = head;\\n        while (fast != null) {\\n        \\tif (n-- < 0) {\\n        \\t\\tslow = slow.next;\\n        \\t}\\n        \\tfast = fast.next;\\n        }\\n        if (n < 0) \\n        \\tslow.next = slow.next.next;\\n        else \\n        \\thead = head.next;\\n        \\n        return head;\\n    } }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head, slow = head;\\n        while (fast != null) {\\n        \\tif (n-- < 0) {\\n        \\t\\tslow = slow.next;\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 9163,
                "title": "python-solution-with-dummy-head-less-edge-cases-make-life-easier",
                "content": "Try to consider the extreme case. What if n = len(list)? What if n = 0? (impossible, but you need to demonstrate that you have thought of the edge cases)\\n\\nUsing the dummy head ensures that you can always return something, as the head itself could be removed.\\n\\n    class Solution:\\n        # @return a ListNode\\n        '''\\n        n = 5\\n        (-1)->1->2->3->4->5\\n        \\n        i    =    0->1->2->3->4->5\\n        fast = (-1)->1->2->3->4->5\\n        \\n        fast = 5\\n        slow = (-1)\\n        \\n        slow.next = head.next = 2\\n        '''\\n        def removeNthFromEnd(self, head, n):\\n            assert n > 0\\n            dummy = ListNode(-1)\\n            dummy.next = head\\n            slow, fast = dummy, dummy\\n            for i in range(n):\\n                fast = fast.next\\n                assert fast\\n            while fast.next:\\n                fast = fast.next\\n                slow = slow.next\\n            slow.next = slow.next.next\\n            return dummy.next",
                "solutionTags": [],
                "code": "Try to consider the extreme case. What if n = len(list)? What if n = 0? (impossible, but you need to demonstrate that you have thought of the edge cases)\\n\\nUsing the dummy head ensures that you can always return something, as the head itself could be removed.\\n\\n    class Solution:\\n        # @return a ListNode\\n        '''\\n        n = 5\\n        (-1)->1->2->3->4->5\\n        \\n        i    =    0->1->2->3->4->5\\n        fast = (-1)->1->2->3->4->5\\n        \\n        fast = 5\\n        slow = (-1)\\n        \\n        slow.next = head.next = 2\\n        '''\\n        def removeNthFromEnd(self, head, n):\\n            assert n > 0\\n            dummy = ListNode(-1)\\n            dummy.next = head\\n            slow, fast = dummy, dummy\\n            for i in range(n):\\n                fast = fast.next\\n                assert fast\\n            while fast.next:\\n                fast = fast.next\\n                slow = slow.next\\n            slow.next = slow.next.next\\n            return dummy.next",
                "codeTag": "Java"
            },
            {
                "id": 3446797,
                "title": "keep-it-simple-baby",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1 for loop\\n1 love\\n1 live\\n\\n# Code\\n```\\npublic class Solution\\n    {\\n        public ListNode RemoveNthFromEnd(ListNode head, int n)\\n        {\\n            ListNode prev = null;\\n\\n            for (var (node, i) = (head, 0); node != null; node = node.next, i++)            \\n                if (i >= n)                \\n                    if (prev == null) prev = head;\\n                    else prev = prev.next;    \\n            \\n            if (prev == null) return head.next;\\n            if (prev.next != null) prev.next = prev.next.next;\\n            return head;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n    {\\n        public ListNode RemoveNthFromEnd(ListNode head, int n)\\n        {\\n            ListNode prev = null;\\n\\n            for (var (node, i) = (head, 0); node != null; node = node.next, i++)            \\n                if (i >= n)                \\n                    if (prev == null) prev = head;\\n                    else prev = prev.next;    \\n            \\n            if (prev == null) return head.next;\\n            if (prev.next != null) prev.next = prev.next.next;\\n            return head;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394224,
                "title": "java-linked-list-remove-elem",
                "content": "\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ArrayList<ListNode> arr = new ArrayList<>();\\n        while (head != null)\\n        {\\n            arr.add(head);\\n            head = head.next;\\n        }\\n        if (arr.size() == 0 || n > arr.size())\\n            return null;\\n        if (n == arr.size())\\n            return arr.get(0).next;\\n        arr.get(arr.size() - n - 1).next = arr.get(arr.size() - n).next;\\n        return arr.get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ArrayList<ListNode> arr = new ArrayList<>();\\n        while (head != null)\\n        {\\n            arr.add(head);\\n            head = head.next;\\n        }\\n        if (arr.size() == 0 || n > arr.size())\\n            return null;\\n        if (n == arr.size())\\n            return arr.get(0).next;\\n        arr.get(arr.size() - n - 1).next = arr.get(arr.size() - n).next;\\n        return arr.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2633008,
                "title": "simple-js",
                "content": "```\\nconst removeNthFromEnd = function(head, n) {\\n\\n    const nodeFromStart = totalNoOfNodes(head) - n;\\n    \\n    if(nodeFromStart==0) return head.next\\n    \\n    let prev = head;\\n    let next = head.next;\\n    for(let i=1; i<nodeFromStart; i++) {\\n        prev=prev.next;\\n        next=next.next;\\n    }\\n    \\n    prev.next = next.next; //CRUX\\n    \\n    return head;\\n    \\n};\\n\\nfunction totalNoOfNodes(head){\\n    let count = 0;\\n    while(head){\\n        head = head.next;\\n        count++;\\n    }\\n    \\n    return count;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst removeNthFromEnd = function(head, n) {\\n\\n    const nodeFromStart = totalNoOfNodes(head) - n;\\n    \\n    if(nodeFromStart==0) return head.next\\n    \\n    let prev = head;\\n    let next = head.next;\\n    for(let i=1; i<nodeFromStart; i++) {\\n        prev=prev.next;\\n        next=next.next;\\n    }\\n    \\n    prev.next = next.next; //CRUX\\n    \\n    return head;\\n    \\n};\\n\\nfunction totalNoOfNodes(head){\\n    let count = 0;\\n    while(head){\\n        head = head.next;\\n        count++;\\n    }\\n    \\n    return count;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2411474,
                "title": "python-3-one-pass-approach-explained",
                "content": "**Context**\\\\\\nWe\\'re given two parameters: `head` and `n`. The former stores a reference to the head of the linked list. The latter stores an integer representing the xth final node that we must remove (*i.e. if `n` is 2, then we must remove the 2nd final node*). The problem requires us to remove the nth final node from the linked list.\\n\\n**Solution**\\\\\\nThe way to solve this problem in one-pass is by utilizing two pointer variables: `slow` and `fast`. In order to find the nth final node, we\\'ll need to find the total number of nodes in the linked list. However, this (finding the total number of nodes) requires N additional time - which prevents us from solving the problem in one pass.\\n\\nRather than finding the nth final node, we can find the nth node instead (*i.e. if the total number of nodes is 5 and `n` is 2, then we\\'ll want to remove the 3rd node*). This can be achieved by executing two tasks:\\n* move `fast` `n` times beforehand\\n* move `slow` and `fast` in parallel until `fast.next` is null.\\n\\nBy the time `fast.next` is null, `slow` should be storing a reference to the nth node\\'s previous node. The way to remove the nth node is by having `slow` point to the nth node\\'s next node (`slow.next = slow.next.next`).\\n\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = fast = head\\n        \\n        for _ in range(n):\\n            fast = fast.next\\n        \\n        # if fast is null, then it implies that we must remove\\n        # the first node. Hence, we\\'ll return the next node\\n        # (after the first node) as an answer.\\n        if not fast:\\n            return head.next\\n        \\n        while fast.next:\\n            slow = slow.next\\n            fast = fast.next\\n        \\n        slow.next = slow.next.next\\n        return head\\n```\\n\\\\\\nThe time complexity is O(N) because we must iterate through the linked list at most once (moving `fast` `n` times beforehand + moving `fast` until it\\'s null).\\n\\nThe space complexity is O(1) because we\\'re only using few additional spaces to initialize few variables.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = fast = head\\n        \\n        for _ in range(n):\\n            fast = fast.next\\n        \\n        # if fast is null, then it implies that we must remove\\n        # the first node. Hence, we\\'ll return the next node\\n        # (after the first node) as an answer.\\n        if not fast:\\n            return head.next\\n        \\n        while fast.next:\\n            slow = slow.next\\n            fast = fast.next\\n        \\n        slow.next = slow.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270564,
                "title": "easy-c-sol-naive-efficient-approaches-time-o-n",
                "content": "```\\n// Naive Solution :: Time : O(N) + O(N) :: Aux_Space : O(1)\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        int count = 0;\\n        ListNode *curr = head;\\n\\n        while(curr){\\n            count++;\\n            curr = curr->next;\\n        }\\n\\n        if(count == n){\\n            head = head->next;\\n            return head;\\n        }\\n\\n\\n        int k = count-n;\\n\\n        ListNode *temp = head;\\n        count = 1;\\n\\n        while(count!=k){\\n\\n            temp = temp->next;\\n            count++;\\n        }\\n\\n        ListNode *var = temp->next;\\n        temp->next = temp->next->next;\\n        delete(var);\\n\\n        return head;\\n    }\\n};\\n\\n// Efficient Solutin :: Time : O(N) :: Aux_Space : O(1)\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* curr = new ListNode();\\n        curr->next = head;\\n        ListNode* fast = curr;\\n        ListNode* slow = curr;\\n\\n        int k = n;\\n\\n        while(k--){\\n            fast = fast->next;\\n        }\\n\\n        while(fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n\\n        slow->next = slow->next->next;\\n\\n        return curr->next;\\n\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        int count = 0;\\n        ListNode *curr = head;\\n\\n        while(curr){\\n            count++;\\n            curr = curr->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2192124,
                "title": "java-0ms-beats-100-in-time-simple-and-easy-with-explaination",
                "content": "![image](https://assets.leetcode.com/users/images/2e075c52-0509-4921-afd1-8763fa174e10_1656090668.9436104.png)\\n\\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        int len=0;\\n        ListNode temp=head;\\n        // Find the length/size of list.\\n        while(temp!=null)\\n        {\\n            len++;\\n            temp=temp.next;\\n        }\\n        System.out.println(len);\\n        if(len==1) return null;\\n        if(len-n==0) return head.next;\\n      \\n        int count=1;\\n        temp=head;\\n\\t\\t//Reach to the node before the one you want to delete.\\n        //If len is 5, 2nd element from last means 3rd element from start.\\n        while(count!=len-n)\\n        {\\n            temp=temp.next;\\n            count++;\\n        }\\n        System.out.println(temp.val);\\n        temp.next=temp.next.next;\\n    return head;\\n    }\\n}\\n```\\n***Pls upvote the solution if you find it helpful.***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        int len=0;\\n        ListNode temp=head;\\n        // Find the length/size of list.\\n        while(temp!=null)\\n        {\\n            len++;\\n            temp=temp.next;\\n        }\\n        System.out.println(len);\\n        if(len==1) return null;\\n        if(len-n==0) return head.next;\\n      \\n        int count=1;\\n        temp=head;\\n\\t\\t//Reach to the node before the one you want to delete.\\n        //If len is 5, 2nd element from last means 3rd element from start.\\n        while(count!=len-n)\\n        {\\n            temp=temp.next;\\n            count++;\\n        }\\n        System.out.println(temp.val);\\n        temp.next=temp.next.next;\\n    return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127566,
                "title": "0ms-1liner-100-fastest-solution-explained-o-n-time-complexity-o-n-space-complexity",
                "content": "(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* *** Kotlin ***\\n\\n```\\n\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n      fun removeNthFromEnd(head: ListNode?, n: Int): ListNode? {\\n    if (head == null) return null\\n    \\n    var nodeCount = 0\\n    var current = head\\n    \\n    while (current != null) {\\n      nodeCount++\\n      current = current.next\\n    }\\n    \\n    if (nodeCount == n) return head.next\\n    \\n    var prev: ListNode? = null\\n    current = head\\n    val dummy = ListNode(-1)\\n    dummy.next = current\\n    \\n    var step = nodeCount - n\\n    while (step-- > 0) {\\n      prev = current\\n      current = current?.next\\n    }\\n    \\n    prev?.next = current?.next\\n    \\n    return dummy.next\\n  }\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "JavaScript",
                    "Kotlin",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n      fun removeNthFromEnd(head: ListNode?, n: Int): ListNode? {\\n    if (head == null) return null\\n    \\n    var nodeCount = 0\\n    var current = head\\n    \\n    while (current != null) {\\n      nodeCount++\\n      current = current.next\\n    }\\n    \\n    if (nodeCount == n) return head.next\\n    \\n    var prev: ListNode? = null\\n    current = head\\n    val dummy = ListNode(-1)\\n    dummy.next = current\\n    \\n    var step = nodeCount - n\\n    while (step-- > 0) {\\n      prev = current\\n      current = current?.next\\n    }\\n    \\n    prev?.next = current?.next\\n    \\n    return dummy.next\\n  }\\n}\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087843,
                "title": "c-solution-in-two-pass-and-one-pass",
                "content": "**Code in two pass**\\n```\\nint lenList(struct ListNode* head){\\n    struct ListNode* ptr = head;\\n    int l = 0;\\n    while(ptr != NULL) {\\n        l++;\\n        ptr = ptr->next;\\n    }\\n    return l;\\n}\\n\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    if(!head || !head->next) return NULL;\\n\\n    int len = lenList(head);\\n    if(len == n) {\\n        head = head->next;\\n        return head;\\n    }\\n    struct ListNode* ptr = head;\\n    int count = len - n;\\n    while(count > 1) {\\n        ptr = ptr->next;\\n        count--;\\n    }\\n    struct ListNode* q = ptr->next;\\n    ptr->next = ptr->next->next;\\n    free(q);\\n    \\n    return head;\\n}\\n```\\n\\n**Code in one pass**\\n```\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    struct ListNode* fast = head;\\n    struct ListNode* slow = head;\\n    \\n    for(int i=0; i<n; i++) fast = fast->next;\\n    if(!fast) return head->next;\\n    \\n    while(fast->next){\\n        fast = fast->next;\\n        slow = slow->next;\\n    }\\n    \\n    struct ListNode* q = slow->next;\\n    slow->next = slow->next->next;\\n    free(q);\\n    \\n    return head;\\n}\\n```\\n\\n**Please upvote if you liked the solution**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint lenList(struct ListNode* head){\\n    struct ListNode* ptr = head;\\n    int l = 0;\\n    while(ptr != NULL) {\\n        l++;\\n        ptr = ptr->next;\\n    }\\n    return l;\\n}\\n\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    if(!head || !head->next) return NULL;\\n\\n    int len = lenList(head);\\n    if(len == n) {\\n        head = head->next;\\n        return head;\\n    }\\n    struct ListNode* ptr = head;\\n    int count = len - n;\\n    while(count > 1) {\\n        ptr = ptr->next;\\n        count--;\\n    }\\n    struct ListNode* q = ptr->next;\\n    ptr->next = ptr->next->next;\\n    free(q);\\n    \\n    return head;\\n}\\n```\n```\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    struct ListNode* fast = head;\\n    struct ListNode* slow = head;\\n    \\n    for(int i=0; i<n; i++) fast = fast->next;\\n    if(!fast) return head->next;\\n    \\n    while(fast->next){\\n        fast = fast->next;\\n        slow = slow->next;\\n    }\\n    \\n    struct ListNode* q = slow->next;\\n    slow->next = slow->next->next;\\n    free(q);\\n    \\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1989690,
                "title": "javascript-solution",
                "content": "```\\nvar removeNthFromEnd = function(head, n) {\\n    let tempList = new ListNode(0);\\n    tempList.next = head;\\n\\t\\n    // set variables for next node and current node\\n    let slow = tempList;\\n    let fast = tempList;\\n\\t\\n    // set fast to n nodes ahead of slow\\n    for (let i = 0; i <= n; i++) {\\n        fast = fast.next;\\n    }\\n\\t\\n    // While we haven\\'t reached the end of the list\\n    // set slow to n nodes behind fast\\n    while (fast) {\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n\\t\\n    // set slow.next to two nodes ahead of slow\\n    // then return the nth node of the list\\n    slow.next = slow.next.next;\\n    return tempList.next;\\n}\\n```\\n\\nTime complexity is 0(n)\\nSpace complexity 0(1)\\n\\nRuntime: 60 ms, faster than 95.08% of JavaScript online submissions for Remove Nth Node From End of List.\\nMemory Usage: 42.7 MB, less than 72.68% of JavaScript online submissions for Remove Nth Node From End of List.",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nvar removeNthFromEnd = function(head, n) {\\n    let tempList = new ListNode(0);\\n    tempList.next = head;\\n\\t\\n    // set variables for next node and current node\\n    let slow = tempList;\\n    let fast = tempList;\\n\\t\\n    // set fast to n nodes ahead of slow\\n    for (let i = 0; i <= n; i++) {\\n        fast = fast.next;\\n    }\\n\\t\\n    // While we haven\\'t reached the end of the list\\n    // set slow to n nodes behind fast\\n    while (fast) {\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n\\t\\n    // set slow.next to two nodes ahead of slow\\n    // then return the nth node of the list\\n    slow.next = slow.next.next;\\n    return tempList.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1725772,
                "title": "two-pointer-approach",
                "content": "class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode result = head;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n\\t //moving fast pointer to n+starting position\\n       while(n-- > 0){\\n           \\n           fast = fast.next;\\n       }\\n\\t   \\n\\t   \\n        if(fast == null){\\n            return result.next;\\n        }\\n       \\n        while(fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        System.out.println(\"deleting value\"+ slow.next.val);\\n       \\n        slow.next = slow.next.next;\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode result = head;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n\\t //moving fast pointer to n+starting position\\n       while(n-- > 0){\\n           \\n           fast = fast.next;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1699955,
                "title": "easy-and-clean-optimized-code-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* fast = head , *slow = head;\\n        for(int i = 0 ; i < n ; i++) fast = fast->next;\\n        if(!fast) return head->next;\\n        while(fast->next){\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* fast = head , *slow = head;\\n        for(int i = 0 ; i < n ; i++) fast = fast->next;\\n        if(!fast) return head->next;\\n        while(fast->next){\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645734,
                "title": "slow-and-fast-pointer-java-code",
                "content": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode slow = dummy;\\n        ListNode fast = dummy;\\n        \\n        // move fast pointer n time\\n        for(int i = 1; i <=n; ++i)\\n            fast = fast.next;\\n        \\n        while(fast.next != null){\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        \\n        slow.next = slow.next.next;\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode slow = dummy;\\n        ListNode fast = dummy;\\n        \\n        // move fast pointer n time\\n        for(int i = 1; i <=n; ++i)\\n            fast = fast.next;\\n        \\n        while(fast.next != null){\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        \\n        slow.next = slow.next.next;\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431330,
                "title": "java-o-n-one-pass-solution",
                "content": "This is a great problem to grasp the concept of linked lists, and uses a technique that occurs in other linked list problems.\\n\\n**Two-Pass Solution**\\nThe obvious approach to this problem is to use 2 passes through the linked list, the first pass for counting the number of nodes, and the second pass to find the node to remove and remove it. \\n```\\n//Sorry if my code is a little long, just trying to be as descriptive as possible\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode cur = head;\\n        int count = 0;\\n        while(cur != null){\\n            count++;\\n            cur = cur.next;\\n        }\\n        \\n        if(n == count){\\n            return head.next;\\n        }\\n        \\n        cur = head;\\n        ListNode pred = null;\\n        for(int i = 0; i < count - n; i++){\\n            pred = cur;\\n            cur = cur.next;\\n        }\\n       \\n        pred.next = cur.next;\\n        return head;\\n    }\\n}\\n```\\nThis code is not \"bad\" by any means, 2 passes still means ```O(n)``` time, and a constant number of new variables means ```O(1)``` space, but can we use the fact that we are looking to remove the ```n```th node from the end to create a one-pass solution?\\n\\n**One-Pass Solution**\\nA common way of doing one-pass solutions for linked list search/remove/insert problems is to use some variation of the slow-fast pointer technique. In this question, we can start by initializing a pointer ```fast``` at the head of the linked list given. Then we can move this pointer ```n``` nodes further. Then we can intialize a pointer ```slow``` to ```head```, and ```prev``` to ```null``` (this pointer being the one trailing ```slow```). We can move ```fast```, ```slow```, and ```prev``` simultaneously, and once ```fast``` becomes ```null``` (passes the end of the list), ```slow``` will be pointing to the ```n```th node from the end, which can now be removed. \\n\\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head;\\n        for(int i = 0; i < n; i++){\\n            fast = fast.next;\\n        }\\n        ListNode slow = head;\\n        ListNode prev = null;\\n        while(fast != null){\\n            fast = fast.next;\\n            prev = slow;\\n            slow = slow.next;\\n        }\\n        if(prev == null){\\n            return head.next;\\n        }\\n        prev.next = slow.next;\\n        return head;\\n    }\\n}\\n```\\nThis solution is also done in ```O(n)``` time, and ```O(1)``` space, but the difference being that it is done in one pass. \\n\\nHope this helps!!",
                "solutionTags": [],
                "code": "```\\n//Sorry if my code is a little long, just trying to be as descriptive as possible\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode cur = head;\\n        int count = 0;\\n        while(cur != null){\\n            count++;\\n            cur = cur.next;\\n        }\\n        \\n        if(n == count){\\n            return head.next;\\n        }\\n        \\n        cur = head;\\n        ListNode pred = null;\\n        for(int i = 0; i < count - n; i++){\\n            pred = cur;\\n            cur = cur.next;\\n        }\\n       \\n        pred.next = cur.next;\\n        return head;\\n    }\\n}\\n```\n```O(n)```\n```O(1)```\n```n```\n```fast```\n```n```\n```slow```\n```head```\n```prev```\n```null```\n```slow```\n```fast```\n```slow```\n```prev```\n```fast```\n```null```\n```slow```\n```n```\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head;\\n        for(int i = 0; i < n; i++){\\n            fast = fast.next;\\n        }\\n        ListNode slow = head;\\n        ListNode prev = null;\\n        while(fast != null){\\n            fast = fast.next;\\n            prev = slow;\\n            slow = slow.next;\\n        }\\n        if(prev == null){\\n            return head.next;\\n        }\\n        prev.next = slow.next;\\n        return head;\\n    }\\n}\\n```\n```O(n)```\n```O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 1416454,
                "title": "2-pointer-approach-with-comments-typescript",
                "content": "```ts\\n// N: number of nodes\\n// Time: O(N)\\n// Space: O(1)\\n\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {\\n    const dummyHead = new ListNode(0, head);\\n    let slow = dummyHead;\\n    let fast = dummyHead;\\n    \\n    // Move fast n nodes ahead of slow\\n    for (let i = 0; i < n; i++) {\\n        fast = fast.next;\\n    }\\n    \\n    // When fast reaches 1st node from the end, slow will be n+1th node from the end\\n    while (fast.next) {\\n        fast = fast.next;\\n        slow = slow.next;\\n    }\\n    \\n    // Skip over the nth node from the end\\n    slow.next = slow.next.next;\\n    \\n    return dummyHead.next;\\n}\\n```",
                "solutionTags": [],
                "code": "```ts\\n// N: number of nodes\\n// Time: O(N)\\n// Space: O(1)\\n\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {\\n    const dummyHead = new ListNode(0, head);\\n    let slow = dummyHead;\\n    let fast = dummyHead;\\n    \\n    // Move fast n nodes ahead of slow\\n    for (let i = 0; i < n; i++) {\\n        fast = fast.next;\\n    }\\n    \\n    // When fast reaches 1st node from the end, slow will be n+1th node from the end\\n    while (fast.next) {\\n        fast = fast.next;\\n        slow = slow.next;\\n    }\\n    \\n    // Skip over the nth node from the end\\n    slow.next = slow.next.next;\\n    \\n    return dummyHead.next;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366565,
                "title": "c-simple-one-pass-o-n-time-o-1-space",
                "content": "curr refers to the first node and nPlusOneNodesFromCurris n plus nodes\\nfar from the curr node so if it becomes null we need to delete the next value\\nof curr\\n\\nEDGE CASES\\n\\ndeleting the first node and second node\\nif its first node nPlusOneNodesFromCurr will be NULL when n=1\\nand if its second node n will be 0 and nPlusOneNodesFromCurr will be NULL\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *curr=head,*nPlusOneNodesFromCurr=head;\\n        n++;\\n        while(nPlusOneNodesFromCurr!=NULL&&n--){\\n            nPlusOneNodesFromCurr=nPlusOneNodesFromCurr->next;\\n        }\\n        if(nPlusOneNodesFromCurr==NULL&&n==1)\\n         return head->next;\\n     \\n        while(nPlusOneNodesFromCurr!=NULL){\\n            curr=curr->next;\\n           nPlusOneNodesFromCurr=nPlusOneNodesFromCurr->next;     \\n        }\\n        curr->next=curr->next->next;\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *curr=head,*nPlusOneNodesFromCurr=head;\\n        n++;\\n        while(nPlusOneNodesFromCurr!=NULL&&n--){\\n            nPlusOneNodesFromCurr=nPlusOneNodesFromCurr->next;\\n        }\\n        if(nPlusOneNodesFromCurr==NULL&&n==1)\\n         return head->next;\\n     \\n        while(nPlusOneNodesFromCurr!=NULL){\\n            curr=curr->next;\\n           nPlusOneNodesFromCurr=nPlusOneNodesFromCurr->next;     \\n        }\\n        curr->next=curr->next->next;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354890,
                "title": "c-brute-to-optimal-easy",
                "content": "**1. Brute Force**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        //if only one element \\n        if(!head->next){\\n            return nullptr;\\n        }\\n        //if two element\\n        if(!head->next->next){\\n            if(n==1){\\n                head->next=nullptr;\\n                return head;\\n            }\\n            else{\\n                return head->next;\\n            }\\n        }\\n        //more than two element\\n        int ctr=0, length=0;\\n        ListNode *temp=head;\\n        ListNode *ptr =head;\\n        \\n        //checking length\\n        while(ptr){\\n            ptr = ptr->next;\\n            length++;\\n        }\\n        \\n        //1st edge case if first element removed\\n        if(n==length){\\n            return head->next;\\n        }\\n        //removing length-n element\\n        while(temp){\\n            //if element found is n-1th from end\\n            if(ctr==length-n-1){\\n      \\n                if(temp->next->next!=nullptr){\\n                    temp->next=temp->next->next;\\n                }\\n                //2nd edge case if last element removed\\n                else{\\n                    temp->next = nullptr;\\n                }\\n            }\\n            temp = temp->next;\\n            ctr++;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\n**2. Two Pointer**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* start = new ListNode(0);\\n        start->next = head;\\n        ListNode* fast=start;\\n        ListNode* slow=start;\\n        \\n        for(int i=1; i<=n; ++i){\\n            fast = fast->next;\\n        }\\n            \\n            while(fast->next!=NULL){\\n                fast = fast->next;\\n                slow = slow->next;\\n            }\\n            slow->next = slow->next->next;\\n        return start->next;\\n       \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        //if only one element \\n        if(!head->next){\\n            return nullptr;\\n        }\\n        //if two element\\n        if(!head->next->next){\\n            if(n==1){\\n                head->next=nullptr;\\n                return head;\\n            }\\n            else{\\n                return head->next;\\n            }\\n        }\\n        //more than two element\\n        int ctr=0, length=0;\\n        ListNode *temp=head;\\n        ListNode *ptr =head;\\n        \\n        //checking length\\n        while(ptr){\\n            ptr = ptr->next;\\n            length++;\\n        }\\n        \\n        //1st edge case if first element removed\\n        if(n==length){\\n            return head->next;\\n        }\\n        //removing length-n element\\n        while(temp){\\n            //if element found is n-1th from end\\n            if(ctr==length-n-1){\\n      \\n                if(temp->next->next!=nullptr){\\n                    temp->next=temp->next->next;\\n                }\\n                //2nd edge case if last element removed\\n                else{\\n                    temp->next = nullptr;\\n                }\\n            }\\n            temp = temp->next;\\n            ctr++;\\n        }\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* start = new ListNode(0);\\n        start->next = head;\\n        ListNode* fast=start;\\n        ListNode* slow=start;\\n        \\n        for(int i=1; i<=n; ++i){\\n            fast = fast->next;\\n        }\\n            \\n            while(fast->next!=NULL){\\n                fast = fast->next;\\n                slow = slow->next;\\n            }\\n            slow->next = slow->next->next;\\n        return start->next;\\n       \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256656,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        \\n        ListNode* p1 = head;\\n        ListNode* p2;\\n        ListNode* prevP2 = NULL;\\n        \\n        while(n){\\n            p1 = p1->next;\\n            n--;\\n        }\\n        \\n        p2 = head;\\n        while(p1){\\n            prevP2 = p2;\\n            p2 = p2->next;\\n            p1 = p1->next;\\n        }\\n        \\n        //Trying to delete the head\\n        if(!prevP2) return p2->next;\\n        else{\\n            prevP2->next = p2->next;\\n            return head;\\n        }\\n        return head;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        \\n        ListNode* p1 = head;\\n        ListNode* p2;\\n        ListNode* prevP2 = NULL;\\n        \\n        while(n){\\n            p1 = p1->next;\\n            n--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1164484,
                "title": "c-super-simple-short-one-pass-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if (!head) \\n            return NULL;\\n        \\n        ListNode* dummy_head = new ListNode();\\n        dummy_head->next = head;\\n        ListNode *fast = dummy_head, *slow = dummy_head;\\n        \\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n        \\n        while (fast->next) {\\n            fast = fast->next;\\n            slow = slow->next;        \\n        }\\n        \\n        ListNode *to_delete = slow->next;\\n        slow->next = slow->next->next;\\n        delete to_delete;\\n        \\n        return dummy_head->next;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if (!head) \\n            return NULL;\\n        \\n        ListNode* dummy_head = new ListNode();\\n        dummy_head->next = head;\\n        ListNode *fast = dummy_head, *slow = dummy_head;\\n        \\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n        \\n        while (fast->next) {\\n            fast = fast->next;\\n            slow = slow->next;        \\n        }\\n        \\n        ListNode *to_delete = slow->next;\\n        slow->next = slow->next->next;\\n        delete to_delete;\\n        \\n        return dummy_head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961866,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast=slow=head\\n        for i in range(n):\\n            fast=fast.next\\n        if not fast:return head.next\\n        while fast.next:\\n            slow=slow.next\\n            fast=fast.next\\n        slow.next=slow.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast=slow=head\\n        for i in range(n):\\n            fast=fast.next\\n        if not fast:return head.next\\n        while fast.next:\\n            slow=slow.next\\n            fast=fast.next\\n        slow.next=slow.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503293,
                "title": "javascript-detailed-explanation",
                "content": "```\\nvar removeNthFromEnd = function(head, n) {\\n    // create a newlistnode which we will use to store our answer\\n    let dummy = new ListNode(-1);\\n    // keep a reference to head, which we will return\\n    dummy.next = head;\\n    \\n    // we\\'re starting these are our dummy value (-1)\\n    let slow = dummy;\\n    let fast = dummy;\\n    \\n    // get one ahead of N # of nodes, so given n =2, then 1->2->3->4->5 we\\'d be at 3\\n    // effectively creating a distance of size N from the fast pointer (3) and the slow (1)\\n    for(let i = 1; i <= n + 1; i++) {\\n        fast = fast.next;\\n    }\\n    \\n    // slow is at head still, fast is ahead of slow at a distance of N\\n    // we move slow and fast one at a time, when fast is at the end of the list (null)\\n    // slow will be at distance N-1 from the end of the list\\n    while(fast !== null) {\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n    \\n    // slow is now one before N, lets skip it\\n    slow.next = slow.next.next;\\n    \\n    // dummy contains our initial value (-1->1->2->3->4->5)\\n    // we don\\'t need the dummy value (-1)\\n    // so return the next value (1->2->3->4->5)\\n    return dummy.next;\\n};\\n\\n\\n// this is algo looks manually stepping through it. Given: 1->2->3->4->5, n = 2\\n// move fast to N + 1\\n// fast     i    n+1 (end point)\\n//  1       1    3\\n//  2       2    3\\n//  3       3    3\\n// fast: 3, slow : -1, distance between fast slow: 2 (which will always be n)\\n\\n// loop until fast !== null\\n// slow    fast    distance between (not difference)\\n//  1       4             2\\n//  2       5             2\\n//  3       null(eol)     2\\n\\n// so now our slow pointer is one before the node we need to skip (n)\\n// so lets skip it, slow.next is the value we need to skip (4), so\\n// slow.next -> slow.next.next(5)\\n// 1->2->3->5```",
                "solutionTags": [],
                "code": "```\\nvar removeNthFromEnd = function(head, n) {\\n    // create a newlistnode which we will use to store our answer\\n    let dummy = new ListNode(-1);\\n    // keep a reference to head, which we will return\\n    dummy.next = head;\\n    \\n    // we\\'re starting these are our dummy value (-1)\\n    let slow = dummy;\\n    let fast = dummy;\\n    \\n    // get one ahead of N # of nodes, so given n =2, then 1->2->3->4->5 we\\'d be at 3\\n    // effectively creating a distance of size N from the fast pointer (3) and the slow (1)\\n    for(let i = 1; i <= n + 1; i++) {\\n        fast = fast.next;\\n    }\\n    \\n    // slow is at head still, fast is ahead of slow at a distance of N\\n    // we move slow and fast one at a time, when fast is at the end of the list (null)\\n    // slow will be at distance N-1 from the end of the list\\n    while(fast !== null) {\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n    \\n    // slow is now one before N, lets skip it\\n    slow.next = slow.next.next;\\n    \\n    // dummy contains our initial value (-1->1->2->3->4->5)\\n    // we don\\'t need the dummy value (-1)\\n    // so return the next value (1->2->3->4->5)\\n    return dummy.next;\\n};\\n\\n\\n// this is algo looks manually stepping through it. Given: 1->2->3->4->5, n = 2\\n// move fast to N + 1\\n// fast     i    n+1 (end point)\\n//  1       1    3\\n//  2       2    3\\n//  3       3    3\\n// fast: 3, slow : -1, distance between fast slow: 2 (which will always be n)\\n\\n// loop until fast !== null\\n// slow    fast    distance between (not difference)\\n//  1       4             2\\n//  2       5             2\\n//  3       null(eol)     2\\n\\n// so now our slow pointer is one before the node we need to skip (n)\\n// so lets skip it, slow.next is the value we need to skip (4), so\\n// slow.next -> slow.next.next(5)\\n// 1->2->3->5```",
                "codeTag": "Unknown"
            },
            {
                "id": 368217,
                "title": "remove-nth-node-from-end-of-list",
                "content": "Given a linked list, remove the n-th node from the end of list and return its head.\\n\\nExample:\\n\\nGiven linked list: 1->2->3->4->5, and n = 2.\\n\\nAfter removing the second node from the end, the linked list becomes 1->2->3->5.\\n\\n```\\n\\t# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        p = head\\n        i = 0\\n        while p:\\n            p = p.next\\n            i += 1\\n        p = head\\n        step = i-n#total length - n\\n        if step == 0:\\n            head = head.next\\n        else:\\n            l = 1\\n            while l<step :\\n                p = p.next\\n                l += 1\\n            p.next = p.next.next\\n        return head\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n\\t# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        p = head\\n        i = 0\\n        while p:\\n            p = p.next\\n            i += 1\\n        p = head\\n        step = i-n#total length - n\\n        if step == 0:\\n            head = head.next\\n        else:\\n            l = 1\\n            while l<step :\\n                p = p.next\\n                l += 1\\n            p.next = p.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287711,
                "title": "solution-in-python",
                "content": "Runtime: 40 ms, faster than 93.06% of Python3 online submissions for Remove Nth Node From End of List.\\nMemory Usage: 13.2 MB, less than 5.60% of Python3 online submissions for Remove Nth Node From End of List.\\n```# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        if head.next == None:\\n            return None\\n        tmp = head\\n        size = 0\\n        \\n        # find the size of the linked list\\n        while tmp:\\n            size += 1\\n            tmp = tmp.next\\n        tmp = head\\n        \\n        #if we have to remove the first node:\\n        if n == size: \\n            return head.next\\n        \\n        for i in range(size-n-1):\\n            tmp = tmp.next\\n        tmp.next = tmp.next.next\\n        return head",
                "solutionTags": [],
                "code": "Runtime: 40 ms, faster than 93.06% of Python3 online submissions for Remove Nth Node From End of List.\\nMemory Usage: 13.2 MB, less than 5.60% of Python3 online submissions for Remove Nth Node From End of List.\\n```# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        if head.next == None:\\n            return None\\n        tmp = head\\n        size = 0\\n        \\n        # find the size of the linked list\\n        while tmp:\\n            size += 1\\n            tmp = tmp.next\\n        tmp = head\\n        \\n        #if we have to remove the first node:\\n        if n == size: \\n            return head.next\\n        \\n        for i in range(size-n-1):\\n            tmp = tmp.next\\n        tmp.next = tmp.next.next\\n        return head",
                "codeTag": "Java"
            },
            {
                "id": 209699,
                "title": "javascript-o-n-time-o-1-space-with-comments",
                "content": "```javascript\\n/**\\n * Time: O(n)\\n * Space: O(1)\\n * n - # of nodes\\n */\\n\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nfunction removeNthFromEnd(head, n) {\\n  const dummy = new ListNode(); // use dummy to handle removing head\\n  dummy.next = head;\\n  let fast = dummy;\\n  let slow = dummy;\\n\\n  // Move fast n + 1 nodes ahead of slow\\n  for (let i = 0; i < n + 1; i++) {\\n    fast = fast.next;\\n  }\\n\\n  // Move fast to end, slow will be (n + 1)th from last node, just before the node to remove\\n  while (fast) {\\n    fast = fast.next;\\n    slow = slow.next;\\n  }\\n\\n  // Remove the nth from last node\\n  slow.next = slow.next.next;\\n  return dummy.next;\\n}\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * Time: O(n)\\n * Space: O(1)\\n * n - # of nodes\\n */\\n\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nfunction removeNthFromEnd(head, n) {\\n  const dummy = new ListNode(); // use dummy to handle removing head\\n  dummy.next = head;\\n  let fast = dummy;\\n  let slow = dummy;\\n\\n  // Move fast n + 1 nodes ahead of slow\\n  for (let i = 0; i < n + 1; i++) {\\n    fast = fast.next;\\n  }\\n\\n  // Move fast to end, slow will be (n + 1)th from last node, just before the node to remove\\n  while (fast) {\\n    fast = fast.next;\\n    slow = slow.next;\\n  }\\n\\n  // Remove the nth from last node\\n  slow.next = slow.next.next;\\n  return dummy.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 167577,
                "title": "java-two-pointers-with-explanations",
                "content": "**Logical Thought**\\nThe loop invariant is that two pointers `s, e` such that `s is always n nodes distance in front of e`. In this way, `s` is always the preceding node of the node to remove.When e is the `tail` node of the List (i.e. when `e.next = null`), we simply remove s.next (`s.next = s.next.next`). For example,\\n```\\nGiven 1 - 2 - 3 - 4 - 5 - N, n = 2,\\ns is always 2 nodes distance in front of e\\nD - 1 - 2 - 3 - 4 - 5 - N\\n            s\\n                    e\\n3 is the node to remove.\\n```\\n**Code**\\n```\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n\\n        if (head == null || head.next == null) {\\n            return null;\\n        }\\n\\n        ListNode dummyHead = new ListNode(0), s = dummyHead, e = s;\\n        dummyHead.next = head;\\n\\n        for (int i = 0; i < n; i++) {\\n            e = e.next;\\n        }\\n        while (e.next != null) {\\n            e = e.next;\\n            s = s.next;\\n        }\\n        s.next = s.next.next;\\n\\n        return dummyHead.next;\\n    }\\n```\\n**Trick**\\nTo remove a node in List, we need to figure out its preceding node. Since we may remove the List\\'s head, which does not have a preceding node, we establish a `dummyHead` for simplicity (`dummyHead.next = head`).\\n\\nI appreciate your **VOTE UP** (\\u02CAo\\u0334\\u0336\\u0337\\u0324\\u2304o\\u0334\\u0336\\u0337\\u0324\\u02CB) ",
                "solutionTags": [],
                "code": "```\\nGiven 1 - 2 - 3 - 4 - 5 - N, n = 2,\\ns is always 2 nodes distance in front of e\\nD - 1 - 2 - 3 - 4 - 5 - N\\n            s\\n                    e\\n3 is the node to remove.\\n```\n```\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n\\n        if (head == null || head.next == null) {\\n            return null;\\n        }\\n\\n        ListNode dummyHead = new ListNode(0), s = dummyHead, e = s;\\n        dummyHead.next = head;\\n\\n        for (int i = 0; i < n; i++) {\\n            e = e.next;\\n        }\\n        while (e.next != null) {\\n            e = e.next;\\n            s = s.next;\\n        }\\n        s.next = s.next.next;\\n\\n        return dummyHead.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8816,
                "title": "minimal-recursive-java-solution-12ms",
                "content": "```\\n\\tpublic static ListNode removeNthFromEnd(ListNode head, int n) {\\n\\t\\tif(head==null){\\n\\t\\t\\treturn null;\\n\\t\\t}\\n        int depth=removeHelper(head,n);\\n        head=depth>n?head:head.next;\\n        return head;\\n \\n    }\\n\\t public static int removeHelper(ListNode head,int n){\\n\\t\\tif(head.next==null){\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tint cur=1+removeHelper(head.next, n);\\n\\t\\tif(cur==n+1){\\n\\t\\t\\thead.next=head.next==null?null:head.next.next;\\n\\t\\t}\\n\\t\\treturn cur;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic static ListNode removeNthFromEnd(ListNode head, int n) {\\n\\t\\tif(head==null){\\n\\t\\t\\treturn null;\\n\\t\\t}\\n        int depth=removeHelper(head,n);\\n        head=depth>n?head:head.next;\\n        return head;\\n \\n    }\\n\\t public static int removeHelper(ListNode head,int n){\\n\\t\\tif(head.next==null){\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tint cur=1+removeHelper(head.next, n);\\n\\t\\tif(cur==n+1){\\n\\t\\t\\thead.next=head.next==null?null:head.next.next;\\n\\t\\t}\\n\\t\\treturn cur;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8910,
                "title": "o-n-time-o-1-space-ruby-solution-single-pass",
                "content": "``` ruby\\ndef remove_nth_from_end(head, n)\\n    return nil unless head.next\\n    count = 0\\n    h, p = head, head\\n    while h\\n        p = p.next if count > n\\n        h = h.next\\n        count += 1\\n    end\\n    return head.next if count == n\\n    p.next = p.next.next\\n    head\\nend\\n```",
                "solutionTags": [],
                "code": "``` ruby\\ndef remove_nth_from_end(head, n)\\n    return nil unless head.next\\n    count = 0\\n    h, p = head, head\\n    while h\\n        p = p.next if count > n\\n        h = h.next\\n        count += 1\\n    end\\n    return head.next if count == n\\n    p.next = p.next.next\\n    head\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 8984,
                "title": "one-pass-javascript-solution",
                "content": "    var removeNthFromEnd = function(head, n) {\\n      var left, before, right = head;\\n      left = before = {next: head}; \\n      while (n--) right = right.next;\\n      while (right) {\\n        right = right.next;\\n        left = left.next;\\n      }\\n      left.next = left.next.next;\\n      return before.next;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var removeNthFromEnd = function(head, n) {\\n      var left, before, right = head;\\n      left = before = {next: head}; \\n      while (n--) right = right.next;\\n      while (right) {\\n        right = right.next;\\n        left = left.next;\\n      }\\n      left.next = left.next.next;\\n      return before.next;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 4086979,
                "title": "accepted-java-code-beats-100",
                "content": "# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```JAVA []\\nclass Solution {\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n    if(head == null) return head;\\n    int k = 0;\\n    ListNode curr = head;\\n    for(; curr != null; curr = curr.next) k++;\\n    k -= n; //to get position of given element from first node\\n    if(k == 0) return head.next;\\n    for(curr = head; k > 1; k--, curr = curr.next) ;\\n    curr.next = curr.next.next; // to remove that node\\n    return head;\\n    }\\n}\\n```\\n>>> ## Upvote\\uD83D\\uDC4D if you find helpful\\n",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```JAVA []\\nclass Solution {\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n    if(head == null) return head;\\n    int k = 0;\\n    ListNode curr = head;\\n    for(; curr != null; curr = curr.next) k++;\\n    k -= n; //to get position of given element from first node\\n    if(k == 0) return head.next;\\n    for(curr = head; k > 1; k--, curr = curr.next) ;\\n    curr.next = curr.next.next; // to remove that node\\n    return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799083,
                "title": "simple-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* start = new ListNode();\\n        start->next = head;\\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n        for(int i = 0; i < n; ++i) {\\n            fast = fast->next;\\n        }\\n        while(fast->next) {\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        slow->next = slow->next->next;\\n        return start->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* start = new ListNode();\\n        start->next = head;\\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n        for(int i = 0; i < n; ++i) {\\n            fast = fast->next;\\n        }\\n        while(fast->next) {\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        slow->next = slow->next->next;\\n        return start->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725716,
                "title": "easy-to-understand-c",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* temp = head;\\n<!-- Iterate till end to find length of list -->\\n        int cnt = 0;\\n        while (temp) {\\n            temp = temp->next;\\n            cnt++;\\n        }\\n<!-- If single node then return head->next i.e NULL -->\\n        cnt = cnt - n;\\n        if (cnt == 0) {\\n            return head->next;\\n        }\\n<!-- mark the length till which you have to iterate -->\\n        temp = head;\\n        while (cnt - 1) {\\n            temp = temp->next;\\n            cnt--;\\n        }\\n<!-- After iterating till just previous node of node which is to be removed, mark the next of node by skipping the node in between -->\\n        temp->next = temp->next->next;\\n        return head;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* temp = head;\\n<!-- Iterate till end to find length of list -->\\n        int cnt = 0;\\n        while (temp) {\\n            temp = temp->next;\\n            cnt++;\\n        }\\n<!-- If single node then return head->next i.e NULL -->\\n        cnt = cnt - n;\\n        if (cnt == 0) {\\n            return head->next;\\n        }\\n<!-- mark the length till which you have to iterate -->\\n        temp = head;\\n        while (cnt - 1) {\\n            temp = temp->next;\\n            cnt--;\\n        }\\n<!-- After iterating till just previous node of node which is to be removed, mark the next of node by skipping the node in between -->\\n        temp->next = temp->next->next;\\n        return head;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370715,
                "title": "typescript-2-pointers-smart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {\\n    let fastP: ListNode = head\\n    let slowP: ListNode = head\\n    for (let i = 0; i < n; i++) {\\n        fastP = fastP.next;\\n    }\\n    if (!fastP) return head.next;\\n\\n    while (fastP.next) {\\n        fastP = fastP.next\\n        slowP = slowP.next;\\n    }\\n    slowP.next = slowP.next.next;\\n\\n    return head\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {\\n    let fastP: ListNode = head\\n    let slowP: ListNode = head\\n    for (let i = 0; i < n; i++) {\\n        fastP = fastP.next;\\n    }\\n    if (!fastP) return head.next;\\n\\n    while (fastP.next) {\\n        fastP = fastP.next\\n        slowP = slowP.next;\\n    }\\n    slowP.next = slowP.next.next;\\n\\n    return head\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254467,
                "title": "c-easy-solution-using-length-of-linkedlist",
                "content": "# Intuition\\nWe can traverse the linked list and find the length of the list. Then, we can traverse the list again to reach the nth node from the end and remove it. To remove the node, we need to modify the \\'next\\' pointer of its previous node to point to its next node.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Define a helper function \\'getlength()\\' that takes the head of the linked list as input and returns its length.\\n2. Compute the length of the linked list using the \\'getlength()\\' function.\\n3. Traverse the linked list again until the node n nodes from the end is reached.\\n4. Modify the next pointer of the previous node to point to the next node of the node to be removed.\\n5. Delete the node to be removed.\\n6. Return the head of the modified linked list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N), where N is the length of the linked list. We traverse the linked list twice.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), We only use constant extra space to store the pointers.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int getlength(ListNode* head){\\n        ListNode* curr = head;\\n        int length = 0;\\n        while(curr!=NULL){\\n            length++;\\n            curr = curr->next;\\n        }\\n        return length;\\n    }\\n\\n\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        if (head == nullptr) {\\n            return nullptr;\\n        }\\n\\n       int length = getlength(head);\\n       ListNode* node = NULL;\\n       if(length<=1) return node;\\n\\n       ListNode* curr = head;\\n       ListNode* prev = NULL;\\n\\n       int position = length - n;\\n       int count = 1;\\n\\n       if(length==n){\\n            head = head->next;\\n           curr->next = NULL;\\n           delete curr;\\n           return head;\\n       }\\n\\n       while(count<=position){\\n           prev = curr;\\n           curr = curr->next;\\n           count++;\\n       }\\n\\n        if(curr==NULL){\\n           prev->next = NULL;\\n       }\\n        else{\\n        prev->next = curr->next;\\n        curr->next = NULL;\\n        delete curr;\\n        }     \\n\\n        return head;\\n               \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int getlength(ListNode* head){\\n        ListNode* curr = head;\\n        int length = 0;\\n        while(curr!=NULL){\\n            length++;\\n            curr = curr->next;\\n        }\\n        return length;\\n    }\\n\\n\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        if (head == nullptr) {\\n            return nullptr;\\n        }\\n\\n       int length = getlength(head);\\n       ListNode* node = NULL;\\n       if(length<=1) return node;\\n\\n       ListNode* curr = head;\\n       ListNode* prev = NULL;\\n\\n       int position = length - n;\\n       int count = 1;\\n\\n       if(length==n){\\n            head = head->next;\\n           curr->next = NULL;\\n           delete curr;\\n           return head;\\n       }\\n\\n       while(count<=position){\\n           prev = curr;\\n           curr = curr->next;\\n           count++;\\n       }\\n\\n        if(curr==NULL){\\n           prev->next = NULL;\\n       }\\n        else{\\n        prev->next = curr->next;\\n        curr->next = NULL;\\n        delete curr;\\n        }     \\n\\n        return head;\\n               \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245946,
                "title": "0ms-beats-100-one-pass-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n){\\n        ListNode ans=new ListNode();\\n        ans.next=head;\\n        ListNode fast=ans;\\n        ListNode slow=ans;\\n\\n        for(int i=1;i<=n;i++){\\n            fast=fast.next;\\n        }\\n\\n        while(fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next;\\n        }\\n        slow.next=slow.next.next;\\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n){\\n        ListNode ans=new ListNode();\\n        ans.next=head;\\n        ListNode fast=ans;\\n        ListNode slow=ans;\\n\\n        for(int i=1;i<=n;i++){\\n            fast=fast.next;\\n        }\\n\\n        while(fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next;\\n        }\\n        slow.next=slow.next.next;\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041441,
                "title": "0ms-100-beats-easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        int size=findSize(head);\\n        ListNode ans= new ListNode();\\n        ListNode prev=ans;\\n        ListNode cur=head;\\n        for(int i=0;i<size-n;i++){\\n            prev.next=cur;\\n            cur=cur.next;\\n            prev=prev.next;\\n        } \\n        prev.next=cur.next;\\n        return ans.next;\\n    }\\n    public int findSize(ListNode head){\\n        ListNode temp=head;\\n        int count=0;\\n        while(temp!=null){\\n            count++;\\n            temp=temp.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        int size=findSize(head);\\n        ListNode ans= new ListNode();\\n        ListNode prev=ans;\\n        ListNode cur=head;\\n        for(int i=0;i<size-n;i++){\\n            prev.next=cur;\\n            cur=cur.next;\\n            prev=prev.next;\\n        } \\n        prev.next=cur.next;\\n        return ans.next;\\n    }\\n    public int findSize(ListNode head){\\n        ListNode temp=head;\\n        int count=0;\\n        while(temp!=null){\\n            count++;\\n            temp=temp.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016097,
                "title": "single-pass-recursive-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse recursion to accumulate new list with a single pass.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI use a recursive helper function that returns a tuple containing the accumulated result ListNode along with a count of nodes that begins from the end of the list. At each recursive step, I first call the recursive helper function, then check if the current node is the nth node from the end of the list. If it is, then I do not accumulate the current node value, if it isn\\'t then I add the current node value and continue. \\n\\n[Quick Video Explanation with Diagram](https://youtu.be/p3CPh_hjcpk)\\nhttps://youtu.be/p3CPh_hjcpk\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def recursiveHelper(self, head: Optional[ListNode], n: int) -> (Optional[ListNode], int):\\n        if (head == None):\\n            return (None, 0)\\n        else:\\n            (chain, location) = self.recursiveHelper(head.next, n)\\n            location += 1\\n            if (location == n):\\n                return (chain, location)\\n            else:\\n                return (ListNode(head.val, chain), location)\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        (head, location) = self.recursiveHelper(head, n)\\n        return head\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def recursiveHelper(self, head: Optional[ListNode], n: int) -> (Optional[ListNode], int):\\n        if (head == None):\\n            return (None, 0)\\n        else:\\n            (chain, location) = self.recursiveHelper(head.next, n)\\n            location += 1\\n            if (location == n):\\n                return (chain, location)\\n            else:\\n                return (ListNode(head.val, chain), location)\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        (head, location) = self.recursiveHelper(head, n)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833601,
                "title": "concise-java-solution-faster-than-100-with-explanation",
                "content": "**Explanation**: First, I get the length of the list by looping through it. Then I calculate the node to be removed as `listLength - n`. A standard algorithm to  remove the node is then implemented. Below is the full code.\\n\\n```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fakeHead = head;\\n        int listLength = 1;\\n        while(fakeHead.next != null) {\\n            listLength++;\\n            fakeHead = fakeHead.next;\\n        }\\n        if(n == listLength) {\\n            head = head.next;\\n            return head;\\n        }\\n        int nodeToRemove = listLength - n;\\n        fakeHead = head;\\n        for(int i=0; fakeHead.next!=null && i<nodeToRemove-1; i++){\\n            fakeHead = fakeHead.next;\\n        }\\n        fakeHead.next = fakeHead.next.next;\\n        return head;\\n    }\\n```\\n\\nIf this solution helped you, an upvote would be greatly appreciated :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fakeHead = head;\\n        int listLength = 1;\\n        while(fakeHead.next != null) {\\n            listLength++;\\n            fakeHead = fakeHead.next;\\n        }\\n        if(n == listLength) {\\n            head = head.next;\\n            return head;\\n        }\\n        int nodeToRemove = listLength - n;\\n        fakeHead = head;\\n        for(int i=0; fakeHead.next!=null && i<nodeToRemove-1; i++){\\n            fakeHead = fakeHead.next;\\n        }\\n        fakeHead.next = fakeHead.next.next;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2634465,
                "title": "javascript-solution-88-36-percent-faster",
                "content": "``` \\nvar removeNthFromEnd = function(head, n) {\\n    var node = new ListNode()\\n    var rep = node\\n    var hash = []\\n    while(head!==null){\\n        hash.push(head.val)\\n        head = head.next\\n    }\\n    var count = hash.length-n\\n    let i = 0\\n    while(i<hash.length){\\n        if(count!==0){\\n            node.next = new ListNode(hash[i])\\n            count--\\n            node = node.next\\n        }else{\\n            count+=n-1 \\n        }\\n        i++\\n    }\\n    return rep.next\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` \\nvar removeNthFromEnd = function(head, n) {\\n    var node = new ListNode()\\n    var rep = node\\n    var hash = []\\n    while(head!==null){\\n        hash.push(head.val)\\n        head = head.next\\n    }\\n    var count = hash.length-n\\n    let i = 0\\n    while(i<hash.length){\\n        if(count!==0){\\n            node.next = new ListNode(hash[i])\\n            count--\\n            node = node.next\\n        }else{\\n            count+=n-1 \\n        }\\n        i++\\n    }\\n    return rep.next\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2633583,
                "title": "rust-concise-two-pass-with-iterators-with-comments",
                "content": "After solving this, I read through **all** the published Rust solutions, and despite all the posted variations, I think this brings something new to the table in terms of using standard library features of Rust to avoid reinventing the wheel. The algorithm itself is the same as every other iterative Rust solution, though - count the number of total nodes, step up to the node immediately before the node to be deleted, and link it to the node immediately after the deleted node.\\n\\nImplementation notes:\\n* `std::iter::successors` yields elements as long as the state is `Some(...)`. Could it be more ideal for counting the number of nodes in our linked list? :)\\n* `fold` gives us exactly what we need to iterate over the list and give us the node we want.\\n\\n```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        let cnt = std::iter::successors(head.as_ref(), |last| last.next.as_ref()).count();\\n        let mut dummy = Some(Box::new(ListNode{val: 0, next: head}));\\n        let mut prev = (0..cnt - n as usize).fold(dummy.as_mut(), |curr, _| curr.unwrap().next.as_mut() );\\n        prev.unwrap().next = prev.as_mut().unwrap().next.as_mut().unwrap().next.take();\\n        dummy.unwrap().next\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        let cnt = std::iter::successors(head.as_ref(), |last| last.next.as_ref()).count();\\n        let mut dummy = Some(Box::new(ListNode{val: 0, next: head}));\\n        let mut prev = (0..cnt - n as usize).fold(dummy.as_mut(), |curr, _| curr.unwrap().next.as_mut() );\\n        prev.unwrap().next = prev.as_mut().unwrap().next.as_mut().unwrap().next.take();\\n        dummy.unwrap().next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2603476,
                "title": "0-ms-faster-than-100-00-of-java",
                "content": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode temp=head;\\n        ListNode slow=head;\\n        ListNode fast=slow.next;\\n        int count=0;\\n        while(temp!=null){\\n            count++;\\n            temp=temp.next;\\n        }\\n        count=count-n;\\n        while(count!=1 && fast!=null){\\n            slow=slow.next;\\n            fast=fast.next;\\n            count--;\\n        }\\n        if(fast==null){\\n            head=head.next;\\n        }else{\\n            slow.next=fast.next;\\n        }\\n        return head;\\n    }\\n}\\nPLEASE UPVOTE \\uD83D\\uDE0A```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode temp=head;\\n        ListNode slow=head;\\n        ListNode fast=slow.next;\\n        int count=0;\\n        while(temp!=null){\\n            count++;\\n            temp=temp.next;\\n        }\\n        count=count-n;\\n        while(count!=1 && fast!=null){\\n            slow=slow.next;\\n            fast=fast.next;\\n            count--;\\n        }\\n        if(fast==null){\\n            head=head.next;\\n        }else{\\n            slow.next=fast.next;\\n        }\\n        return head;\\n    }\\n}\\nPLEASE UPVOTE \\uD83D\\uDE0A```",
                "codeTag": "Java"
            },
            {
                "id": 2384172,
                "title": "c-solution-0ms-better-than-100-comments-easy",
                "content": "![image](https://assets.leetcode.com/users/images/9bbc3ebd-149a-43b6-afb5-b312d3eed80a_1659721445.167148.png)\\n```\\n// to calculate the number of elements in linked list\\nint length(ListNode* head){\\n\\tint len=0;\\n\\twhile(head!=NULL)\\n\\t\\thead = head->next, len++;\\n\\treturn len;\\n}\\n\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tint len = length(head);\\n\\t// if n is same as length, it means we need to remove the first element\\n\\tif(n==len){\\n\\t\\thead = head->next; return head;\\n\\t}\\n\\t\\n\\tint count=1;\\n\\tListNode* temp = head;\\n\\t// running the while loop n number of times, \\n\\t// and stopping just before the last nth node, i.e., prev node before last nth node.\\n\\twhile(count!=len-n){\\n\\t\\ttemp= temp->next;\\n\\t\\tcount++;\\n\\t}\\n\\t\\n\\t// now its just simple delete node example\\n\\t// we point the next of the prev node to next of last nth node.\\n\\tif(temp!= NULL && temp->next!=NULL)\\n\\t\\ttemp->next= temp->next->next;\\n\\treturn head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// to calculate the number of elements in linked list\\nint length(ListNode* head){\\n\\tint len=0;\\n\\twhile(head!=NULL)\\n\\t\\thead = head->next, len++;\\n\\treturn len;\\n}\\n\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tint len = length(head);\\n\\t// if n is same as length, it means we need to remove the first element\\n\\tif(n==len){\\n\\t\\thead = head->next; return head;\\n\\t}\\n\\t\\n\\tint count=1;\\n\\tListNode* temp = head;\\n\\t// running the while loop n number of times, \\n\\t// and stopping just before the last nth node, i.e., prev node before last nth node.\\n\\twhile(count!=len-n){\\n\\t\\ttemp= temp->next;\\n\\t\\tcount++;\\n\\t}\\n\\t\\n\\t// now its just simple delete node example\\n\\t// we point the next of the prev node to next of last nth node.\\n\\tif(temp!= NULL && temp->next!=NULL)\\n\\t\\ttemp->next= temp->next->next;\\n\\treturn head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2317493,
                "title": "c-slow-fast-pointers",
                "content": "Straight forward solution, comment below if there\\'re any suggestions or doubts :)\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode * start = new ListNode();\\n        start -> next = head;\\n        ListNode* fast = start;\\n        ListNode* slow = start;     \\n\\n        for(int i = 1; i <= n; ++i) fast = fast->next;\\n    \\n        while(fast->next != NULL){\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        \\n        slow->next = slow->next->next;\\n        \\n        return start->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode * start = new ListNode();\\n        start -> next = head;\\n        ListNode* fast = start;\\n        ListNode* slow = start;     \\n\\n        for(int i = 1; i <= n; ++i) fast = fast->next;\\n    \\n        while(fast->next != NULL){\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        \\n        slow->next = slow->next->next;\\n        \\n        return start->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299971,
                "title": "easy-to-understand-one-pass-solution",
                "content": "***Fast and slow pointers*** [0ms 40.3MB](https://leetcode.com/submissions/detail/750313835/)\\nHey there! Just another popular problem - boy, they really into LinkedList problems. Idea is simples - we put the slow pointer in the beginning of the list, and n-1 to right of it we put another (call it slow and fast respectivly). Then traverse until last node for **fast pointer**, then simply delete.  Here goes the code! \\n```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fastPointer = head;\\n        if (fastPointer.next == null) {\\n            return null;\\n        }\\n        ListNode slowPointer = null;\\n        \\n        for (int i = 1; i < n; i++) {\\n            fastPointer = fastPointer.next;\\n        }\\n        \\n        while (fastPointer.next != null) {\\n            fastPointer = fastPointer.next;\\n            if (slowPointer == null) {\\n                slowPointer = head;\\n            } else {\\n                slowPointer = slowPointer.next;\\n            }\\n        }\\n        \\n        if (slowPointer == null) {\\n            return head.next;\\n        }\\n        slowPointer.next = slowPointer.next.next;\\n        return head;\\n    }\\n``` \\nTime complexity: O(n) - since we traverse list in one pass\\nSpace complexity: O(1) - no additional space required",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Interactive"
                ],
                "code": "```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fastPointer = head;\\n        if (fastPointer.next == null) {\\n            return null;\\n        }\\n        ListNode slowPointer = null;\\n        \\n        for (int i = 1; i < n; i++) {\\n            fastPointer = fastPointer.next;\\n        }\\n        \\n        while (fastPointer.next != null) {\\n            fastPointer = fastPointer.next;\\n            if (slowPointer == null) {\\n                slowPointer = head;\\n            } else {\\n                slowPointer = slowPointer.next;\\n            }\\n        }\\n        \\n        if (slowPointer == null) {\\n            return head.next;\\n        }\\n        slowPointer.next = slowPointer.next.next;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2246932,
                "title": "java-in-depth-explanation-two-pointers-technique",
                "content": "You need to know how to remove element from the LinkedList.\\n \\n **Intuition**\\n\\nThe optimal solution for the problem is using **Two Pointer Technique**.  Let\\'s say `n = 2` and we have a LinkedList `1 -> 2 -> 3 -> 4 -> 5 `. Then we want to make it as `1 -> 2 -> 3 -> 5`. Therefore, we want to have make `left` pointer points to `3`, and we could do `left.next = left.next.next`. But how do we achieve it?\\n  \\n**Oberservation**\\nThis is what we want eventually so we can perform the operation mentioned above. We can obeserve that the distance between `left` and `right` are `n+1`. \\n```\\n1   ->   2   ->   3   ->   4   ->   5  ->  null\\n                 left                      right\\n\\t\\t\\t\\t |----      n+1        ------|\\n```\\n\\nHow do we achieve it? We can place `left` on `dummyHead` position, and place `right` on position where is `n` distance away from `head`. Therefore, the distance between `left` and `right` will be `n+1` eventually.\\n\\n```\\ndummyHead   ->   1   ->   2   ->   3   ->   4   ->   5\\n   left                          right \\n   |----         n+1         ------|\\n```\\n\\n**Java code implementation**\\n\\n```\\nclass Solution\\n{\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        // O(L) time | O(1) space\\n        // two pointer technique\\n        ListNode dummyHead = new ListNode(-1);\\n        dummyHead.next = head;\\n        ListNode left = dummyHead;\\n        ListNode right = head;\\n        \\n        while(n > 0)\\n        {\\n            n -= 1;\\n            right = right.next;\\n        }\\n        \\n        while(right != null)\\n        {\\n            left = left.next;\\n            right = right.next;\\n        }\\n        left.next = left.next.next;\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n1   ->   2   ->   3   ->   4   ->   5  ->  null\\n                 left                      right\\n\\t\\t\\t\\t |----      n+1        ------|\\n```\n```\\ndummyHead   ->   1   ->   2   ->   3   ->   4   ->   5\\n   left                          right \\n   |----         n+1         ------|\\n```\n```\\nclass Solution\\n{\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        // O(L) time | O(1) space\\n        // two pointer technique\\n        ListNode dummyHead = new ListNode(-1);\\n        dummyHead.next = head;\\n        ListNode left = dummyHead;\\n        ListNode right = head;\\n        \\n        while(n > 0)\\n        {\\n            n -= 1;\\n            right = right.next;\\n        }\\n        \\n        while(right != null)\\n        {\\n            left = left.next;\\n            right = right.next;\\n        }\\n        left.next = left.next.next;\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136314,
                "title": "easy-and-simple-python-solution-with-explanation",
                "content": "-We take two pointers. Keep the first pointer start at the begining of the list and second traverse to position N+1 th element in the list. \\n-Here we consider the head to be initially null. \\n-This will help the 2 pointers to be seperated by exactly N nodes.\\n-The N node difference gap will be maintained as we advance both pointers at the same pace.\\n-We continue to traverse untill the second pointer reaches Null.\\n-When the second pointer reaches Null, the first pointer will exactly point one position before the target node which is to be deleted.\\n-With first.next.next we jump that node and return head for the result\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        \\n        ans=ListNode(0)\\n        ans.next=head\\n        first=ans\\n        second=ans\\n        for i in range(1,n+2):\\n            second=second.next\\n        while(second is not None):\\n            second=second.next\\n            first=first.next\\n        first.next=first.next.next\\n        return ans.next\\n```\\n\\n**Please upvote if it helped :)**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        \\n        ans=ListNode(0)\\n        ans.next=head\\n        first=ans\\n        second=ans\\n        for i in range(1,n+2):\\n            second=second.next\\n        while(second is not None):\\n            second=second.next\\n            first=first.next\\n        first.next=first.next.next\\n        return ans.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090746,
                "title": "easy-cpp-two-piointer-approach",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head == NULL)\\n        return NULL;\\n \\n    ListNode *fast = head;\\n    ListNode *slow = head;\\n \\n    for(int i=0; i<n; i++){\\n        fast = fast->next; //Firstly move the pointer by one step till it reaches nth node from starting\\n    }\\n \\n    //if remove the first node\\n    if(fast == NULL){\\n        head = head->next;\\n        return head;\\n    }\\n \\n    while(fast->next != NULL){\\n        fast = fast->next;\\n        slow = slow->next;\\n    }\\n        //slow will reach at the (n-1)th position from end of the list\\n    slow->next = slow->next->next;\\n \\n    return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head == NULL)\\n        return NULL;\\n \\n    ListNode *fast = head;\\n    ListNode *slow = head;\\n \\n    for(int i=0; i<n; i++){\\n        fast = fast->next; //Firstly move the pointer by one step till it reaches nth node from starting\\n    }\\n \\n    //if remove the first node\\n    if(fast == NULL){\\n        head = head->next;\\n        return head;\\n    }\\n \\n    while(fast->next != NULL){\\n        fast = fast->next;\\n        slow = slow->next;\\n    }\\n        //slow will reach at the (n-1)th position from end of the list\\n    slow->next = slow->next->next;\\n \\n    return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079645,
                "title": "python-using-two-pointers-and-dummy-node-in-o-n-time",
                "content": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode(0,head)\\n        first = dummy\\n        second = head\\n        while n > 0 and second:\\n            n-=1\\n            second = second.next\\n        \\n        while second:\\n            first = first.next\\n            second = second.next\\n        \\n        first.next = first.next.next\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode(0,head)\\n        first = dummy\\n        second = head\\n        while n > 0 and second:\\n            n-=1\\n            second = second.next\\n        \\n        while second:\\n            first = first.next\\n            second = second.next\\n        \\n        first.next = first.next.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077600,
                "title": "java-single-pass-two-pointer-o-n-time-and-o-1-space",
                "content": "```\\n//TC: O(n)\\n//SC: O(1)\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        //base case\\n        if(head == null){\\n            return head;\\n        }\\n        \\n        int count = 0;\\n        ListNode dummy = new ListNode(-1);\\n        //Adding a dummy node befor the head, gives us the ease to write to code\\n        //without having to handle seperately the case where we have to delete\\n        //head node or even if there is only one node in the list\\n        dummy.next = head;\\n        ListNode slow = dummy;\\n        ListNode fast = dummy;//ahead of slow, and heance the name\\n        \\n        //We move the fast pointer until the count is <= n\\n        while(count <= n){\\n            count++;\\n            fast = fast.next;\\n        }\\n        //Then we move slow and fast at 1x speed, until fast is null\\n        //This places the slow at (n-1)th position form end\\n        //As we want to remove nth node, we reset links and we remove\\n        //the nth node\\n        while(fast != null){\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        //Reset the links and remove nth node\\n        slow.next = slow.next.next;\\n        //As head is at dummy.next, we return that\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n//TC: O(n)\\n//SC: O(1)\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        //base case\\n        if(head == null){\\n            return head;\\n        }\\n        \\n        int count = 0;\\n        ListNode dummy = new ListNode(-1);\\n        //Adding a dummy node befor the head, gives us the ease to write to code\\n        //without having to handle seperately the case where we have to delete\\n        //head node or even if there is only one node in the list\\n        dummy.next = head;\\n        ListNode slow = dummy;\\n        ListNode fast = dummy;//ahead of slow, and heance the name\\n        \\n        //We move the fast pointer until the count is <= n\\n        while(count <= n){\\n            count++;\\n            fast = fast.next;\\n        }\\n        //Then we move slow and fast at 1x speed, until fast is null\\n        //This places the slow at (n-1)th position form end\\n        //As we want to remove nth node, we reset links and we remove\\n        //the nth node\\n        while(fast != null){\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        //Reset the links and remove nth node\\n        slow.next = slow.next.next;\\n        //As head is at dummy.next, we return that\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024693,
                "title": "python-solution-faster-than-95",
                "content": "Take a dummy node connect it with head (if we take a dummy node then it would be easy to delete the first node if target node is head ie. n = length of list). Take 2 pointers fast and slow. Increase the fast pointer by n steps. Then in next pass increase both slow and fast together by one step. Slow will stop before the target element then delete the link.\\n\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        fast = head\\n        slow = dummy\\n        \\n        for i in range(n):\\n            fast = fast.next\\n        \\n        while fast:\\n            fast = fast.next\\n            slow = slow.next\\n        \\n        tmp = slow.next.next\\n        slow.next.next = None\\n        slow.next = tmp\\n        \\n        return dummy.next\\n\\n# Time: O(N)    where N is the length of Linkedlist\\n# Space: O(1)\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        fast = head\\n        slow = dummy\\n        \\n        for i in range(n):\\n            fast = fast.next\\n        \\n        while fast:\\n            fast = fast.next\\n            slow = slow.next\\n        \\n        tmp = slow.next.next\\n        slow.next.next = None\\n        slow.next = tmp\\n        \\n        return dummy.next\\n\\n# Time: O(N)    where N is the length of Linkedlist\\n# Space: O(1)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575851,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1564857,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1566736,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1565826,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1576041,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1576258,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1571048,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1576900,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1567166,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1820945,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1575851,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1564857,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1566736,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1565826,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1576041,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1576258,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1571048,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1576900,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1567166,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1820945,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1567809,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1571049,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1568838,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1941941,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1575528,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1573790,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 2031745,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1699663,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1576661,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1576621,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1572845,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 1573521,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 1569186,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2074292,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2069230,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2068894,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2067748,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2064136,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2049900,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2045973,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2038012,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 2033169,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 2023084,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 2021460,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 2021264,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 2018477,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 2010908,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 2005098,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 1989947,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 1981274,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 1947920,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1941870,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1928350,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1927944,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1912962,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1903794,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1902347,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1885458,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1878243,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1856530,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1846477,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1845450,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1838225,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1832920,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1826013,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1817380,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1807847,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1807283,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1806956,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1803178,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1798329,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1794340,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1793531,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1793259,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1792058,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1789844,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1785417,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1774792,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1772792,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1768698,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1767986,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1767463,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1762738,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1761939,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1760978,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1759142,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1757564,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1757307,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1752948,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1752910,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1751930,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1743442,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1742860,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1731185,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1729271,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1729034,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1727125,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1725040,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1716796,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1716023,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1714258,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1711080,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1710159,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1709843,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1709177,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1709090,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1707734,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1706368,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1704391,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1703301,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1677246,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1673854,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1671271,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1671268,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1670269,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1668685,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1664371,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1662071,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1651400,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1632513,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            }
        ]
    }
]