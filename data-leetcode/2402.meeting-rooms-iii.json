[
    {
        "title": "Meeting Rooms III",
        "question_content": "You are given an integer n. There are n rooms numbered from 0 to n - 1.\nYou are given a 2D integer array meetings where meetings[i] = [starti, endi] means that a meeting will be held during the half-closed time interval [starti, endi). All the values of starti are unique.\nMeetings are allocated to rooms in the following manner:\n\n\tEach meeting will take place in the unused room with the lowest number.\n\tIf there are no available rooms, the meeting will be delayed until a room becomes free. The delayed meeting should have the same duration as the original meeting.\n\tWhen a room becomes unused, meetings that have an earlier original start time should be given the room.\n\nReturn the number of the room that held the most meetings. If there are multiple rooms, return the room with the lowest number.\nA half-closed interval [a, b) is the interval between a and b including a and not including b.\n&nbsp;\nExample 1:\n\nInput: n = 2, meetings = [[0,10],[1,5],[2,7],[3,4]]\nOutput: 0\nExplanation:\n- At time 0, both rooms are not being used. The first meeting starts in room 0.\n- At time 1, only room 1 is not being used. The second meeting starts in room 1.\n- At time 2, both rooms are being used. The third meeting is delayed.\n- At time 3, both rooms are being used. The fourth meeting is delayed.\n- At time 5, the meeting in room 1 finishes. The third meeting starts in room 1 for the time period [5,10).\n- At time 10, the meetings in both rooms finish. The fourth meeting starts in room 0 for the time period [10,11).\nBoth rooms 0 and 1 held 2 meetings, so we return 0. \n\nExample 2:\n\nInput: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\nOutput: 1\nExplanation:\n- At time 1, all three rooms are not being used. The first meeting starts in room 0.\n- At time 2, rooms 1 and 2 are not being used. The second meeting starts in room 1.\n- At time 3, only room 2 is not being used. The third meeting starts in room 2.\n- At time 4, all three rooms are being used. The fourth meeting is delayed.\n- At time 5, the meeting in room 2 finishes. The fourth meeting starts in room 2 for the time period [5,10).\n- At time 6, all three rooms are being used. The fifth meeting is delayed.\n- At time 10, the meetings in rooms 1 and 2 finish. The fifth meeting starts in room 1 for the time period [10,12).\nRoom 0 held 1 meeting while rooms 1 and 2 each held 2 meetings, so we return 1. \n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 100\n\t1 <= meetings.length <= 105\n\tmeetings[i].length == 2\n\t0 <= starti < endi <= 5 * 105\n\tAll the values of starti are unique.",
        "solutions": [
            {
                "id": 2527280,
                "title": "c-with-explanation-magic-of-priority-queues",
                "content": "**Overview**\\nGreedy Problem using Priority Queues.\\n\\n**How I figured it out as Priority Queues?**\\n* Ordering was required at every step. \\n* `O(n log n)` solution would work.\\n\\t\\n**Algorithm**\\n1. Sort the meetings based on `start_time `\\n2. Create a MIN priority queue for engaged rooms. Each node of PQ will store `{current_meeting_ending_time, room_number}` \\n3. Create a MIN priority queue for non-engaged rooms. Each node of PQ will store `{room_number}`\\n4. Currently all the rooms are empty, so push them in non-engaged rooms PQ.\\n5. For each of the meeting, follow these steps:\\n* Move the meeting rooms in engaged, with `ending_time <= s`, to unused\\n* If there are multiple empty rooms, choose the one with `lower room_number` (Can be directly fetched from non-engaged rooms PQ)\\n* If there are no empty rooms, wait for the engaged room with nearest ending time to empty (Topmost node of engaged PQ)\\n** If we are using an engaged room to carry out the meeting, `starting_time` for this meeting will change and since duration has to be the same, the `newEndingTime` will be `sum(end_time_of_the_prev_meeting, duration)`\\n*  Mark the `current_room` as engaged.\\n* Increment the count in frequency map for the `current_room` \\n\\n6. Find the room with maximum meetings from frequency map.\\n\\n**Code**\\n```\\nbool compare(vector<int>& v1, vector<int>& v2) {\\n    return v1[0] < v2[0];\\n}\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        /* Sort the meetings based on start_time */\\n        sort(meetings.begin(), meetings.end(), compare);\\n        \\n        /* Create a priority queue for engaged rooms. Each node of PQ will store {current_meeting_ending_time, room_number} */\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> engaged;\\n        \\n        /* Create a priority queue for non-engaged rooms. Each node of PQ will store {room_number} */\\n        priority_queue<int, vector<int>, greater<int>> unused;\\n        \\n        /* Frequency map to store the frequency of meetings in each room */\\n        unordered_map<int, int> freq;\\n        \\n        /* Currently all the rooms are mepty */\\n        for(int i = 0; i < n; i++) {\\n            unused.push(i);\\n        }\\n        \\n        for(auto x:meetings) {\\n            int s = x[0], e = x[1];\\n            \\n            /* Move the meeting rooms in engaged, with ending_time <= s, to unused */ \\n            while(engaged.size() > 0 && engaged.top().first <= s) {\\n                int room = engaged.top().second;\\n                engaged.pop();\\n                \\n                unused.push(room);\\n            }\\n            \\n            /* If there are multiple empty rooms, choose the one with lower room_number */\\n            if(unused.size() > 0) \\n            {\\n                int room = unused.top();\\n                unused.pop();\\n                \\n                freq[abs(room)] += 1;\\n                \\n                /* Mark the room as engaged */\\n                engaged.push({e, room});\\n            }\\n            /* If there are no empty rooms, wait for the engaged room with nearest ending time to empty */\\n            else \\n            {\\n                pair<long long, int> topmost = engaged.top();\\n                engaged.pop();\\n            \\n                freq[abs(topmost.second)] += 1;\\n                \\n                /* Since duration has to be the same, the newEnd will be sum(end_time_of_the_prev_meeting, duration) */ \\n                long long newEnd = topmost.first;\\n                newEnd += (e - s);\\n                \\n                /* Mark the room as engaged */\\n                engaged.push({newEnd, topmost.second});\\n            }\\n        }\\n        \\n        /* Find the lowest room_number with maximum frequency */\\n        int maxi = 0;\\n        for(int i = 1; i < n; i++) {\\n            if(freq[i] > freq[maxi])\\n                maxi = i;\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nbool compare(vector<int>& v1, vector<int>& v2) {\\n    return v1[0] < v2[0];\\n}\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        /* Sort the meetings based on start_time */\\n        sort(meetings.begin(), meetings.end(), compare);\\n        \\n        /* Create a priority queue for engaged rooms. Each node of PQ will store {current_meeting_ending_time, room_number} */\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> engaged;\\n        \\n        /* Create a priority queue for non-engaged rooms. Each node of PQ will store {room_number} */\\n        priority_queue<int, vector<int>, greater<int>> unused;\\n        \\n        /* Frequency map to store the frequency of meetings in each room */\\n        unordered_map<int, int> freq;\\n        \\n        /* Currently all the rooms are mepty */\\n        for(int i = 0; i < n; i++) {\\n            unused.push(i);\\n        }\\n        \\n        for(auto x:meetings) {\\n            int s = x[0], e = x[1];\\n            \\n            /* Move the meeting rooms in engaged, with ending_time <= s, to unused */ \\n            while(engaged.size() > 0 && engaged.top().first <= s) {\\n                int room = engaged.top().second;\\n                engaged.pop();\\n                \\n                unused.push(room);\\n            }\\n            \\n            /* If there are multiple empty rooms, choose the one with lower room_number */\\n            if(unused.size() > 0) \\n            {\\n                int room = unused.top();\\n                unused.pop();\\n                \\n                freq[abs(room)] += 1;\\n                \\n                /* Mark the room as engaged */\\n                engaged.push({e, room});\\n            }\\n            /* If there are no empty rooms, wait for the engaged room with nearest ending time to empty */\\n            else \\n            {\\n                pair<long long, int> topmost = engaged.top();\\n                engaged.pop();\\n            \\n                freq[abs(topmost.second)] += 1;\\n                \\n                /* Since duration has to be the same, the newEnd will be sum(end_time_of_the_prev_meeting, duration) */ \\n                long long newEnd = topmost.first;\\n                newEnd += (e - s);\\n                \\n                /* Mark the room as engaged */\\n                engaged.push({newEnd, topmost.second});\\n            }\\n        }\\n        \\n        /* Find the lowest room_number with maximum frequency */\\n        int maxi = 0;\\n        for(int i = 1; i < n; i++) {\\n            if(freq[i] > freq[maxi])\\n                maxi = i;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527284,
                "title": "one-heap-two-heaps",
                "content": "#### One Min Heap\\nThis solution evolved from the original solution below (which could still be a good start - check it out).\\n\\nInstead of tracking available room separatelly, we \"catch up\" all rooms with eneded meeting to the current time.\\n\\nI\\'d say that this solution is simpler, but is less efficient if meetings are sparse (as we may need re-insert `n` rooms before each meeting).\\n\\nFor this problem, however, `n` is small (`<= 100`), so the runtime for both solutions is comparable.\\n\\n**C++**\\n```cpp\\nint mostBooked(int n, vector<vector<int>>& meets) {\\n    int cnt[101] = {};\\n    sort(begin(meets), end(meets));\\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n    for (int i = 0; i < n; ++i)\\n        pq.push({meets[0][0], i});\\n    for (auto &m : meets) {\\n        while (pq.top().first < m[0]) {\\n            pq.push({m[0], pq.top().second});\\n            pq.pop();\\n        }\\n        auto [start, room] = pq.top(); pq.pop();\\n        pq.push({start + m[1] - m[0], room});\\n        ++cnt[room];\\n    }\\n    return max_element(begin(cnt), end(cnt)) - begin(cnt);\\n}\\n```\\n\\n#### Two Min Heaps\\nThe `avail` min heap holds numbers of the available rooms (so the lowest number is on top).\\n\\nThe `busy` min heap stores end times of the ongoing meeting, and used room numbers.\\n    \\nWe sort the meetings, and then for each meeting:\\n1. Remove meetings, ended before this meeting, from `busy`\\n    - Put room numbers back to `avail`.\\n2. If we do not have an available room, select the room on top of `busy`.\\n    - We move the start time of this meeting accordingly. \\n3. If we do, select the room on top of `avail`.\\n4. Push this meeting end time, and the selected room number, to `busy`.\\n5. Increment the number of meetings for the selected room.\\n    \\n**C++**\\n```cpp\\nint mostBooked(int n, vector<vector<int>>& meets) {\\n    int cnt[101] = {};\\n    sort(begin(meets), end(meets));\\n    priority_queue<int, vector<int>, greater<int>> avail;\\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> busy;\\n    for (int i = 0; i < n; ++i)\\n        avail.push(i);\\n    for (auto &m : meets) {\\n        while (!busy.empty() && busy.top().first <= m[0]) {\\n            avail.push(busy.top().second);\\n            busy.pop();\\n        }\\n        long long start = avail.empty() ? busy.top().first : m[0], duration = m[1] - m[0];\\n        int room = avail.empty() ? busy.top().second : avail.top();\\n        if (avail.empty())\\n            busy.pop();\\n        else\\n            avail.pop();\\n        ++cnt[room];\\n        busy.push({start + duration, room});\\n    }\\n    return max_element(begin(cnt), end(cnt)) - begin(cnt);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint mostBooked(int n, vector<vector<int>>& meets) {\\n    int cnt[101] = {};\\n    sort(begin(meets), end(meets));\\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n    for (int i = 0; i < n; ++i)\\n        pq.push({meets[0][0], i});\\n    for (auto &m : meets) {\\n        while (pq.top().first < m[0]) {\\n            pq.push({m[0], pq.top().second});\\n            pq.pop();\\n        }\\n        auto [start, room] = pq.top(); pq.pop();\\n        pq.push({start + m[1] - m[0], room});\\n        ++cnt[room];\\n    }\\n    return max_element(begin(cnt), end(cnt)) - begin(cnt);\\n}\\n```\n```cpp\\nint mostBooked(int n, vector<vector<int>>& meets) {\\n    int cnt[101] = {};\\n    sort(begin(meets), end(meets));\\n    priority_queue<int, vector<int>, greater<int>> avail;\\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> busy;\\n    for (int i = 0; i < n; ++i)\\n        avail.push(i);\\n    for (auto &m : meets) {\\n        while (!busy.empty() && busy.top().first <= m[0]) {\\n            avail.push(busy.top().second);\\n            busy.pop();\\n        }\\n        long long start = avail.empty() ? busy.top().first : m[0], duration = m[1] - m[0];\\n        int room = avail.empty() ? busy.top().second : avail.top();\\n        if (avail.empty())\\n            busy.pop();\\n        else\\n            avail.pop();\\n        ++cnt[room];\\n        busy.push({start + duration, room});\\n    }\\n    return max_element(begin(cnt), end(cnt)) - begin(cnt);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2527548,
                "title": "python-heap-solution",
                "content": "# **Explanation**\\n`ready` contains the ready room index for `meetings`.\\n`rooms` contains the rooms in use with `[end_time, room_index]` as element.\\n\\nFor `[start, end]` in the sorted `meetings`,\\nwe firstly release the `rooms` that is ready before `start` time.\\nIf there is room in `ready` state,\\nwe choose the room with smallest index.\\nOtherwise, we choose the room with smallest `end_time` in `rooms`.\\n<br>\\n\\n# **Complexity**\\nTime `O(nlogn)`\\nSpace `O(n)`\\n<br>\\n\\n\\n**Python**\\n```py\\n    def mostBooked(self, n, meetings):\\n        ready = [r for r in range(n)]\\n        rooms = []\\n        heapify(ready)\\n        res = [0] * n\\n        for s,e in sorted(meetings):\\n            while rooms and rooms[0][0] <= s:\\n                t,r = heappop(rooms)\\n                heappush(ready, r)\\n            if ready:\\n                r = heappop(ready)\\n                heappush(rooms, [e, r])\\n            else:\\n                t,r = heappop(rooms)\\n                heappush(rooms, [t + e - s, r])\\n            res[r] += 1\\n        return res.index(max(res))\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\n    def mostBooked(self, n, meetings):\\n        ready = [r for r in range(n)]\\n        rooms = []\\n        heapify(ready)\\n        res = [0] * n\\n        for s,e in sorted(meetings):\\n            while rooms and rooms[0][0] <= s:\\n                t,r = heappop(rooms)\\n                heappush(ready, r)\\n            if ready:\\n                r = heappop(ready)\\n                heappush(rooms, [e, r])\\n            else:\\n                t,r = heappop(rooms)\\n                heappush(rooms, [t + e - s, r])\\n            res[r] += 1\\n        return res.index(max(res))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2527317,
                "title": "python-3-explanation-with-pictures-priority-queue",
                "content": "Use two priority queues:\\n- `free` for empty rooms sorted by **room number**\\n- `taken` for busy rooms sorted by **ending time**\\n\\nThen we iterate over sorted meetings.\\n![image](https://assets.leetcode.com/users/images/dce5dff7-ff61-42a0-abed-9ceef8892f96_1662264064.1017175.png)\\n\\nFor `task 0`, assign it to `room 0`\\n\\n![image](https://assets.leetcode.com/users/images/b0dc2bea-11ca-465c-8ad1-ba29ff98763d_1662264067.7685502.png)\\n\\nFor `task 1`, assign it to `room 1` \\n![image](https://assets.leetcode.com/users/images/7f94b813-e3b4-4195-882b-a076ce760665_1662264070.9481263.png)\\n\\nFor `task 2`, notice that there is no empty room, we must wait for the first empty room, thus we delay the time to **the ending time of earilest finished meetings**, that is `end 1` in our case.\\n\\n\\n![image](https://assets.leetcode.com/users/images/12106668-8298-44de-bc80-4ef1d675eedf_1662264073.9411733.png)\\n\\n![image](https://assets.leetcode.com/users/images/e308dead-97b0-43cf-aa11-c0a4fddc5e1b_1662264078.3835742.png)\\n\\nSince `room 1` is free now,  we can assign `task 1` to `room 1` \\n\\n![image](https://assets.leetcode.com/users/images/0406d438-fe0d-47bc-a04f-14a66e4c8a0b_1662264081.2236185.png)\\n\\nSimilarly, for `task 3`, its starting time is no earlier than the starting time of `task 2`, thus we have to delay it in this case.\\n\\n![image](https://assets.leetcode.com/users/images/c1881bde-58fe-4453-8c09-018ab424f862_1662264084.0077674.png)\\n\\n![image](https://assets.leetcode.com/users/images/9c32715e-20c4-4091-801b-2f64495b06aa_1662264088.567162.png)\\n\\n\\n```\\ndef mostBooked(self, n: int, A: List[List[int]]) -> int:\\n        count, free, taken = [0] * n, list(range(n)), []\\n        heapq.heapify(free)    \\n        A.sort()\\n        prev = -1\\n        \\n        for start, end in A:\\n            # Reset start time.\\n            duration = end - start\\n            start = max(start, prev)\\n            end = start + duration\\n            \\n            # Free finished rooms \\n            while taken and taken[0][0] <= start:\\n                _, i = heapq.heappop(taken)\\n                heapq.heappush(free, i)\\n            \\n            # Delay current meeting if there is no free room.\\n            if not free:\\n                start = taken[0][0]\\n                end = start + duration\\n                # Free finished rooms\\n                while taken and taken[0][0] <= start:\\n                    _, i = heapq.heappop(taken)\\n                    heapq.heappush(free, i)\\n            \\n            # Assign a room\\n            i = heapq.heappop(free)\\n            count[i] += 1\\n            heapq.heappush(taken, [end, i])\\n            \\n            # Reset previous time\\n            prev = start\\n            \\n        return count.index(max(count))  \\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef mostBooked(self, n: int, A: List[List[int]]) -> int:\\n        count, free, taken = [0] * n, list(range(n)), []\\n        heapq.heapify(free)    \\n        A.sort()\\n        prev = -1\\n        \\n        for start, end in A:\\n            # Reset start time.\\n            duration = end - start\\n            start = max(start, prev)\\n            end = start + duration\\n            \\n            # Free finished rooms \\n            while taken and taken[0][0] <= start:\\n                _, i = heapq.heappop(taken)\\n                heapq.heappush(free, i)\\n            \\n            # Delay current meeting if there is no free room.\\n            if not free:\\n                start = taken[0][0]\\n                end = start + duration\\n                # Free finished rooms\\n                while taken and taken[0][0] <= start:\\n                    _, i = heapq.heappop(taken)\\n                    heapq.heappush(free, i)\\n            \\n            # Assign a room\\n            i = heapq.heappop(free)\\n            count[i] += 1\\n            heapq.heappush(taken, [end, i])\\n            \\n            # Reset previous time\\n            prev = start\\n            \\n        return count.index(max(count))  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2535735,
                "title": "detailed-explanation-simulation-using-min-heaps-c-clean-code",
                "content": "**Intuition :**\\n\\n* Idea here is simply to simulate the meetings according to the rules given in problem statement.\\n\\n* Let us look at each rule and try to build logic using it: \\n\\t* **Rule 1 :**  Allocate room to a meet only when it is empty and if multiple rooms are empty, then pick one with smallest number.\\n\\t\\t* So here we can use a min heap **`empty`** to keep track of all empty rooms.\\n\\t\\t* And to get the room with smallest room number.\\n\\t\\t\\n\\t* **Rule 2 :** If all rooms are occupied, then wait till some meeting ends, and then allocate current meeting to emptied room.\\n\\t\\t* Here, we can use another min heap **`occupied`** that keeps track of **finishing/ending time** of a meeting along with room number.\\n\\t\\t* Using this, we can get a room as early as possible and with smallest room number (in case multiple rooms are emptied at same time).\\n\\t* **Rule 3 :** Allocated room to meetings based on their original **start time**. \\n\\t\\t* This means allocate room to meetings on **1** basis.\\n\\t\\t* i.e if one room is empty and multiple meets are to be allocated, then give priority to the meeting that has *least* original start time.\\n\\t\\t* This can be done easily by sorting `meetings` list, and then start allocating rooms from `i=0`.\\n\\n* Now that we have all rules ready along with implementation, we can start simulation.\\n\\t* First we will sort `meetings` list and also add all rooms to `empty` min heap.\\n\\t* Then, we will start allocating rooms to each meet one by one.\\n\\t* So, first of all, if some meetings are finished till now, then move rooms from `occupied` list to `empty` list.\\n\\t* Next if we have a room empty, then allocate meet to it, add ending time and room number to `occupied` list.\\n\\t* But, if at current start time of meet, no room is empty, then get the room which is ending earliest from now.\\n\\t\\t* Then update finish/end time for current meet and room number, and add this to `occupied` list\\n\\t* Also, for each meeting, increment count of meets allocated to that room accordingly.\\n\\t* Continue this process till all meetings are allocated to some room.\\n\\t* In the end, get the smallest room with most meets allocated.\\n\\n* Dry run over a sample test case : \\n\\n\\t\\tmeetings = [[1,20],[2,10],[3,5],[4,9],[6,8]], n = 3  -> meetings is sorted here\\n\\t\\t\\n\\t\\tInitially, empty = {0, 1, 2} and occupied = { }, meetsCount = [0, 0, 0]\\n\\t\\t\\n\\t\\tmeet 0 : start = 1, end = 20, duration = 20 - 1 = 19\\n\\t\\t\\t-> No meet is finishing in occupied rooms at current start time\\n\\t\\t\\t-> roomNum = 0, meetCount[0] = 1, allocate to room 0\\n\\t\\t\\t-> empty = {1, 2} , occupied = { (20, 0) } , meetsCount = [1, 0, 0]\\n\\t\\t\\n\\t\\tmeet 1 : start = 2, end = 10, duration = 10 - 2 = 8\\n\\t\\t\\t-> No meet is finishing in occupied rooms at current start time\\n\\t\\t\\t-> roomNum = 1, meetCount[1] = 1, allocate to room 1\\n\\t\\t\\t-> empty = {2} , occupied = { (10, 1), (20, 0) } , meetsCount = [1, 1, 0]\\n\\t\\t\\t\\n\\t\\tmeet 2 : start = 3, end = 5, duration = 5 - 3 = 2\\n\\t\\t\\t-> No meet is finishing in occupied rooms at current start time\\n\\t\\t\\t-> roomNum = 2, meetCount[2] = 1, allocate to room 2\\n\\t\\t\\t-> empty = { } , occupied = { (5, 2), (10, 1), (20, 0) } , meetsCount = [1, 1, 1]\\n\\t\\t\\t\\n\\t\\tmeet 3 : start = 4, end = 9, duration = 9 - 4 = 5\\n\\t\\t\\t-> No meet is finishing in occupied rooms at current start time, also no room is empty\\n\\t\\t\\t-> Wait till time=5, when room 2 gets empty. Then we can use that room.\\n\\t\\t\\t-> occupied = { (10, 1), (20, 0) }, since we have popped top element (5, 2) from heap [Intermediate step]\\n\\t\\t\\t-> endTime = time + duration = 5 + 5 = 10\\n\\t\\t\\t-> roomNum = 2, meetCount[2] = 2, allocate to room 2\\n\\t\\t\\t-> empty = { } , occupied = { (10, 1), (10, 2), (20, 0) } , meetsCount = [1, 1, 2]\\n\\t\\t\\t\\n\\t\\tmeet 4 : start = 6, end = 8, duration = 8 - 6 = 2\\n\\t\\t\\t-> No meet is finishing in occupied rooms at current start time, also no room is empty\\n\\t\\t\\t-> Wait till time=10, when room 1 gets empty. Then we can use that room.\\n\\t\\t\\t-> occupied = { (10, 2), (20, 0) }, since we have popped top element (10, 1) from heap [Intermediate step]\\n\\t\\t\\t-> endTime = time + duration = 10 + 2 = 12\\n\\t\\t\\t-> roomNum = 1, meetCount[1] = 2, allocate to room 1\\n\\t\\t\\t-> empty = { } , occupied = { (10, 2), (12, 1), (20, 0) } , meetsCount = [1, 2, 2]\\n\\n\\t\\t- So we have allocated rooms to all meetings. \\n\\t\\t- Smallest room number which held maximum meet i.e max( meetsCount[i] ) = 1\\n\\n# Code : \\n\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        \\n\\t\\t// Sort the meetings list by [startTime_i]\\n        sort(begin(meetings), end(meetings));\\n        \\n\\t\\t// Count of meets that are held in total inside each room from 0 to n-1\\n        vector<int> meetsCount(n, 0);\\n        \\n\\t\\t// Min Heap to store ending time of meet held in some room. \\n\\t\\t// This will give room number with smallest ending time\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> occupied;\\n\\t\\t\\n\\t\\t// Min Heap to store empty/available room number\\n\\t\\t// This will give smallest room number that is empty\\n        priority_queue<int, vector<int>, greater<int>> empty;\\n        \\n\\t\\t// Initially all n rooms are empty\\n        for(int i=0; i<n; i++) empty.push(i);\\n        \\n        // Iterate over all sorted meetings, and try to allocate a room that is empty\\n\\t\\t// And if not empty then wait till it gets available\\n        for(auto& meet : meetings) {\\n\\t\\t\\n            // Clear all room in which meeting is ended\\n            // i.e ending time of meet is less than or eq to start time of current meet\\n            long long currTime = meet[0];\\n            while(occupied.size()) {\\n                if(currTime < occupied.top().first) break;\\n                auto [time, room] = occupied.top(); occupied.pop();\\n                empty.push(room);\\n            }\\n            \\n            // If room available then allocate that room to current meeting\\n            int roomNum = -1;\\n            if(empty.size()) {\\n                roomNum = empty.top(); empty.pop();\\n                occupied.push({ meet[1], roomNum });\\n            }\\n            \\n            // If no room is available, then wait till a meet ends and allocate that room\\n            else if(occupied.size()) {\\n                auto [time, room] = occupied.top(); occupied.pop();   \\n                roomNum = room;\\n                long long endTime = time + meet[1] - meet[0];\\n                occupied.push({endTime, roomNum});\\n            }\\n            \\n            // Once room is allocated for meet, increment count of meets held in that room\\n            if(roomNum != -1) meetsCount[roomNum]++;\\n        }\\n        \\n\\t\\t// Get the index i.e room number with maximum meetings held\\n        int idx = -1, maxVal = 0;\\n        for(int i=0; i<n; i++) {\\n            if(meetsCount[i] > maxVal) {\\n                idx = i;\\n                maxVal = meetsCount[i];\\n            }    \\n        }\\n        \\n        return idx;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* **Time :** `O(NlogN + M (logN + logM))`, \\n* **Space :** `O(N + M)`\\n\\t* `M` is size of `meetings` array\\n\\t* `N` is number of rooms available\\n\\n***If you find this solution helpful, do not forget to give it a like :)***",
                "solutionTags": [
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        \\n\\t\\t// Sort the meetings list by [startTime_i]\\n        sort(begin(meetings), end(meetings));\\n        \\n\\t\\t// Count of meets that are held in total inside each room from 0 to n-1\\n        vector<int> meetsCount(n, 0);\\n        \\n\\t\\t// Min Heap to store ending time of meet held in some room. \\n\\t\\t// This will give room number with smallest ending time\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> occupied;\\n\\t\\t\\n\\t\\t// Min Heap to store empty/available room number\\n\\t\\t// This will give smallest room number that is empty\\n        priority_queue<int, vector<int>, greater<int>> empty;\\n        \\n\\t\\t// Initially all n rooms are empty\\n        for(int i=0; i<n; i++) empty.push(i);\\n        \\n        // Iterate over all sorted meetings, and try to allocate a room that is empty\\n\\t\\t// And if not empty then wait till it gets available\\n        for(auto& meet : meetings) {\\n\\t\\t\\n            // Clear all room in which meeting is ended\\n            // i.e ending time of meet is less than or eq to start time of current meet\\n            long long currTime = meet[0];\\n            while(occupied.size()) {\\n                if(currTime < occupied.top().first) break;\\n                auto [time, room] = occupied.top(); occupied.pop();\\n                empty.push(room);\\n            }\\n            \\n            // If room available then allocate that room to current meeting\\n            int roomNum = -1;\\n            if(empty.size()) {\\n                roomNum = empty.top(); empty.pop();\\n                occupied.push({ meet[1], roomNum });\\n            }\\n            \\n            // If no room is available, then wait till a meet ends and allocate that room\\n            else if(occupied.size()) {\\n                auto [time, room] = occupied.top(); occupied.pop();   \\n                roomNum = room;\\n                long long endTime = time + meet[1] - meet[0];\\n                occupied.push({endTime, roomNum});\\n            }\\n            \\n            // Once room is allocated for meet, increment count of meets held in that room\\n            if(roomNum != -1) meetsCount[roomNum]++;\\n        }\\n        \\n\\t\\t// Get the index i.e room number with maximum meetings held\\n        int idx = -1, maxVal = 0;\\n        for(int i=0; i<n; i++) {\\n            if(meetsCount[i] > maxVal) {\\n                idx = i;\\n                maxVal = meetsCount[i];\\n            }    \\n        }\\n        \\n        return idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528000,
                "title": "java-clean-simple-one-heap",
                "content": "```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a, b) -> a[0] - b[0]);\\n        PriorityQueue<long[]> queue = new PriorityQueue<>(\\n                (a, b) -> a[0] == b[0] ? (int) (a[1] - b[1]) : (int) (a[0] - b[0]));\\n        // {endTime, room}\\n\\n        int[] roomCount = new int[n]; // number of meeting of the room\\n        int result = 0;\\n\\n        for (int i = 0; i < n; i++)\\n            queue.add(new long[] { 0, i });\\n\\n        for (int[] item : meetings) {\\n            int time = item[0]; // new meeting start time\\n\\n            while (queue.peek()[0] < time) // order all available room by room index\\n                queue.add(new long[] { time, queue.poll()[1] });\\n\\n            long[] current = queue.poll();\\n            int curRoom = (int) current[1];\\n            long meetingEndTime = current[0] + (item[1] - item[0]); // current room endTime + this meeting time\\n            roomCount[curRoom]++;\\n\\n            if (roomCount[curRoom] > roomCount[result]) // update result\\n                result = curRoom;\\n            else if (roomCount[curRoom] == roomCount[result])\\n                result = Math.min(result, curRoom);\\n\\n            queue.add(new long[] { meetingEndTime, curRoom });\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a, b) -> a[0] - b[0]);\\n        PriorityQueue<long[]> queue = new PriorityQueue<>(\\n                (a, b) -> a[0] == b[0] ? (int) (a[1] - b[1]) : (int) (a[0] - b[0]));\\n        // {endTime, room}\\n\\n        int[] roomCount = new int[n]; // number of meeting of the room\\n        int result = 0;\\n\\n        for (int i = 0; i < n; i++)\\n            queue.add(new long[] { 0, i });\\n\\n        for (int[] item : meetings) {\\n            int time = item[0]; // new meeting start time\\n\\n            while (queue.peek()[0] < time) // order all available room by room index\\n                queue.add(new long[] { time, queue.poll()[1] });\\n\\n            long[] current = queue.poll();\\n            int curRoom = (int) current[1];\\n            long meetingEndTime = current[0] + (item[1] - item[0]); // current room endTime + this meeting time\\n            roomCount[curRoom]++;\\n\\n            if (roomCount[curRoom] > roomCount[result]) // update result\\n                result = curRoom;\\n            else if (roomCount[curRoom] == roomCount[result])\\n                result = Math.min(result, curRoom);\\n\\n            queue.add(new long[] { meetingEndTime, curRoom });\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535834,
                "title": "two-approaches-to-solve-the-problem-and-why-one-approach-gives-79-81-test-cases",
                "content": "There are two approaches to this problem, one approach will give 78/81 correct test cases and other will give 81/81.\\nI will briefly discuss the approaches. \\n\\n- Maintain a heap to store end_time and room index of a meeting\\n- Run a loop over all meetings\\n- Whenever we are at a meeting i, we pop from heap all the meeting that ends before the start time of meeting i.\\n- Now we check whether a room is available, if a room is available then give the room to current meeting.\\n- Else we need to postpone meeting until the next upcoming deadline. This deadline will actually be top of the heap.\\n- From this point you can do 2 approach\\n- 1) Pop from heap all the elements of same deadlines. It makes sense that suppose if i postpone a task thats supposed to start at 10pm to 11pm, I will remove from heap all the tasks that should end at around 11pm. Note that this appraoch will give wrong answer at test case 79. Check @Ankit173 \\'s comment below to find out why this approach fails.\\n- 2) Pop only the top of heap. This approach gives correct answer. \\n\\n- Posting code for both approach.\\nNOTE: I didnt use two heaps, because I didnt wrote optimal code on my first try, but the code still gets accepted.\\nApproach 1\\n```\\nimport numpy as np\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        \\n        meetings.sort()\\n        rooms = [0] * n\\n        counts = [0] * n\\n        \\n        heap = []\\n        \\n        for meeting in meetings:\\n            duration = meeting[1] - meeting[0]\\n            # i have reached start time for ith meeting\\n            # pop off all meetings\\n            while heap and heap[0][0] <= meeting[0]:\\n                ele = heapq.heappop(heap)\\n                rooms[ele[1]] = 0\\n              \\n            # get next empty room\\n            try:\\n                next_room = rooms.index(0)\\n            except:\\n                next_room = -1\\n            \\n            # if no room is empty\\n            if next_room == -1:\\n                # make meeting timing to end time of the next\\n                meeting[0] = heap[0][0]\\n\\t\\t\\t\\t# APROACH 1 ---------------------------------\\n                while heap and heap[0][0] == meeting[0]:\\n                    ele = heapq.heappop(heap)\\n                    rooms[ele[1]] = 0\\n                # ----------------------------------------------\\n                next_room = rooms.index(0)\\n                \\n            \\n            \\n            rooms[next_room] = 1\\n            counts[next_room] += 1\\n            appender = [meeting[0] + duration, next_room]\\n            heapq.heappush(heap, appender)\\n            # print(heap)\\n        # print(counts)\\n        return np.argmax(counts)\\n```\\n\\nApproach 2\\n```\\nimport numpy as np\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        \\n        meetings.sort()\\n        rooms = [0] * n\\n        counts = [0] * n\\n        \\n        heap = []\\n        \\n        for idx in range(len(meetings)):\\n            meeting = meetings[idx]\\n            duration = meeting[1] - meeting[0]\\n            # i have reached start time for ith meeting\\n            # pop off all meetings\\n            while heap and heap[0][0] <= meeting[0]:\\n                ele = heapq.heappop(heap)\\n                rooms[ele[1]] = 0\\n              \\n            # get next empty room\\n            try:\\n                next_room = rooms.index(0)\\n            except:\\n                next_room = -1\\n            \\n            # if no room is empty\\n            if next_room == -1:\\n                # make meeting timing to end time of the next\\n                meeting[0] = heap[0][0]\\n\\t\\t\\t\\t# APPROACH 2 -----------------------------------\\n                ele = heapq.heappop(heap)\\n\\t\\t\\t\\t# --------------------------------------------------\\n                rooms[ele[1]] = 0\\n                    \\n                next_room = rooms.index(0)\\n                \\n            \\n            \\n            rooms[next_room] = 1\\n            counts[next_room] += 1\\n            appender = [meeting[0] + duration, next_room]\\n            heapq.heappush(heap, appender)\\n            # print(heap)\\n        # print(counts)\\n        return np.argmax(counts)\\n```\\n",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport numpy as np\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        \\n        meetings.sort()\\n        rooms = [0] * n\\n        counts = [0] * n\\n        \\n        heap = []\\n        \\n        for meeting in meetings:\\n            duration = meeting[1] - meeting[0]\\n            # i have reached start time for ith meeting\\n            # pop off all meetings\\n            while heap and heap[0][0] <= meeting[0]:\\n                ele = heapq.heappop(heap)\\n                rooms[ele[1]] = 0\\n              \\n            # get next empty room\\n            try:\\n                next_room = rooms.index(0)\\n            except:\\n                next_room = -1\\n            \\n            # if no room is empty\\n            if next_room == -1:\\n                # make meeting timing to end time of the next\\n                meeting[0] = heap[0][0]\\n\\t\\t\\t\\t# APROACH 1 ---------------------------------\\n                while heap and heap[0][0] == meeting[0]:\\n                    ele = heapq.heappop(heap)\\n                    rooms[ele[1]] = 0\\n                # ----------------------------------------------\\n                next_room = rooms.index(0)\\n                \\n            \\n            \\n            rooms[next_room] = 1\\n            counts[next_room] += 1\\n            appender = [meeting[0] + duration, next_room]\\n            heapq.heappush(heap, appender)\\n            # print(heap)\\n        # print(counts)\\n        return np.argmax(counts)\\n```\n```\\nimport numpy as np\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        \\n        meetings.sort()\\n        rooms = [0] * n\\n        counts = [0] * n\\n        \\n        heap = []\\n        \\n        for idx in range(len(meetings)):\\n            meeting = meetings[idx]\\n            duration = meeting[1] - meeting[0]\\n            # i have reached start time for ith meeting\\n            # pop off all meetings\\n            while heap and heap[0][0] <= meeting[0]:\\n                ele = heapq.heappop(heap)\\n                rooms[ele[1]] = 0\\n              \\n            # get next empty room\\n            try:\\n                next_room = rooms.index(0)\\n            except:\\n                next_room = -1\\n            \\n            # if no room is empty\\n            if next_room == -1:\\n                # make meeting timing to end time of the next\\n                meeting[0] = heap[0][0]\\n\\t\\t\\t\\t# APPROACH 2 -----------------------------------\\n                ele = heapq.heappop(heap)\\n\\t\\t\\t\\t# --------------------------------------------------\\n                rooms[ele[1]] = 0\\n                    \\n                next_room = rooms.index(0)\\n                \\n            \\n            \\n            rooms[next_room] = 1\\n            counts[next_room] += 1\\n            appender = [meeting[0] + duration, next_room]\\n            heapq.heappush(heap, appender)\\n            # print(heap)\\n        # print(counts)\\n        return np.argmax(counts)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527347,
                "title": "java-o-nlogn-heaps-and-sort-with-comments",
                "content": "```\\nclass Solution {\\n\\tpublic int mostBooked(int n, int[][] meetings) {\\n\\t\\t// sort by start\\n\\t\\tArrays.sort(meetings, (a, b) -> a[0] - b[0]);\\n\\n\\t\\t// available rooms\\n\\t\\tvar rooms = new PriorityQueue<Integer>();\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\trooms.add(i);\\n\\n\\t\\t// { meeting end, room taken } -> sort by end time and by room number\\n\\t\\tvar runningMeetings = new PriorityQueue<int[]>((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n\\n\\t\\t// room usage count\\n\\t\\tvar count = new int[n];\\n\\t\\tfor (int[] meeting : meetings) {\\n\\t\\t\\t// return room to available if meeting has ended\\n\\t\\t\\twhile (!runningMeetings.isEmpty() && runningMeetings.peek()[0] <= meeting[0])\\n\\t\\t\\t\\trooms.add(runningMeetings.poll()[1]);\\n\\n\\t\\t\\tvar delayedStart = meeting[0];\\n\\t\\t\\tif (rooms.isEmpty()) { // no available rooms, adjust the next meeting start time with delay\\n\\t\\t\\t\\tvar await = runningMeetings.poll();\\n\\t\\t\\t\\tdelayedStart = await[0];\\n\\t\\t\\t\\trooms.add(await[1]);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// schedule the next meeting\\n\\t\\t\\tvar room = rooms.poll();\\n\\t\\t\\tcount[room]++;\\n\\t\\t\\trunningMeetings.add(new int[] { delayedStart + meeting[1] - meeting[0], room});\\n\\t\\t}\\n\\n\\t\\t// find the most used room\\n\\t\\tvar maxIdx = 0;\\n\\t\\tfor (int r = 0; r < count.length; r++)\\n\\t\\t\\tif (count[maxIdx] < count[r])\\n\\t\\t\\t\\tmaxIdx = r;\\n\\n\\t\\treturn maxIdx;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int mostBooked(int n, int[][] meetings) {\\n\\t\\t// sort by start\\n\\t\\tArrays.sort(meetings, (a, b) -> a[0] - b[0]);\\n\\n\\t\\t// available rooms\\n\\t\\tvar rooms = new PriorityQueue<Integer>();\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\trooms.add(i);\\n\\n\\t\\t// { meeting end, room taken } -> sort by end time and by room number\\n\\t\\tvar runningMeetings = new PriorityQueue<int[]>((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n\\n\\t\\t// room usage count\\n\\t\\tvar count = new int[n];\\n\\t\\tfor (int[] meeting : meetings) {\\n\\t\\t\\t// return room to available if meeting has ended\\n\\t\\t\\twhile (!runningMeetings.isEmpty() && runningMeetings.peek()[0] <= meeting[0])\\n\\t\\t\\t\\trooms.add(runningMeetings.poll()[1]);\\n\\n\\t\\t\\tvar delayedStart = meeting[0];\\n\\t\\t\\tif (rooms.isEmpty()) { // no available rooms, adjust the next meeting start time with delay\\n\\t\\t\\t\\tvar await = runningMeetings.poll();\\n\\t\\t\\t\\tdelayedStart = await[0];\\n\\t\\t\\t\\trooms.add(await[1]);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// schedule the next meeting\\n\\t\\t\\tvar room = rooms.poll();\\n\\t\\t\\tcount[room]++;\\n\\t\\t\\trunningMeetings.add(new int[] { delayedStart + meeting[1] - meeting[0], room});\\n\\t\\t}\\n\\n\\t\\t// find the most used room\\n\\t\\tvar maxIdx = 0;\\n\\t\\tfor (int r = 0; r < count.length; r++)\\n\\t\\t\\tif (count[maxIdx] < count[r])\\n\\t\\t\\t\\tmaxIdx = r;\\n\\n\\t\\treturn maxIdx;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527323,
                "title": "two-min-heaps-easy-expanation-c",
                "content": "The approach is to use 2  priority queues of type pair, one for storing the meetings in ascending order of start time and another to store end time of room , room number (avaliability queue) .\\n Now we go one by one to schedule all meeting in our priority queue,\\nFor every meeting :\\n1 .  Create a vector store to keep all the rooms that can potentially hold the meeting \\n2. Push the first room in the avaliability queue into this vector.\\n\\n3. If the endtime of this room is <= the start time of meeting .\\n   -> Keep on pushing rooms until we find a room with greater end time.\\n\\n4. Now sort the array in increasing order of room number and choose the first room to hold the meeting.\\n\\n5. Put the rest of the rooms in vector back to the avaliability queue.\\n\\n\\n\\n\\t\\n```\\nvector<int> room(n,0);\\n\\tpriority_queue<pair<long long,long long>,vector<pair<long long,long long>>,greater<pair<long long,long long>>> aval;  //(endtime, room no.) for keeping track of avaliability of rooms (sorted in ascending order of end time)\\n\\tfor(int i=0;i<n;i++){\\n\\t\\taval.push({0,i});\\n\\t}\\n\\tpriority_queue<pair<long long,long long>,vector<pair<long long,long long>>,greater<pair<long long,long long>>> pq; // for the meetings to be scheduled (start,end) ( sorted in ascending order of start time)\\n\\tfor(int i = 0;i<meet.size();i++){\\n\\t\\tpq.push({meet[i][0],meet[i][1]});\\n\\t}\\n\\n\\twhile(pq.size()){\\n\\n\\t\\tlong long start = pq.top().first;\\n\\t\\tlong long end = pq.top().second;\\n\\t\\tpq.pop();\\n\\n\\t\\tvector<pair<long long,long long>> store;  // to check which meeting room has lowest room no. among all unused rooms(stores {room no.,end time})\\n\\t\\tlong long et = aval.top().first;      // end time \\n\\t\\tlong long roomno = aval.top().second;  \\n\\t\\taval.pop();                                    // if the end time of all rooms are greater than start then store will contain only 1 room \\n\\t\\tstore.push_back({roomno,et});\\n\\t\\twhile(aval.size() && aval.top().first<= start){   // push in all rooms that are unused  \\n\\t\\t et = aval.top().first;\\n\\t\\t roomno = aval.top().second;\\n\\t\\t aval.pop();\\n\\t\\t\\tstore.push_back({roomno,et});\\n\\t\\t}\\n\\n\\t\\tsort(store.begin(),store.end());     //  sort to get the unused room with lowest room number\\n\\n\\t\\tet = store[0].second;                // choose the room at 0th index and put rest of the rooms from index 1 back in pq\\n\\t\\troomno= store[0].first;\\n\\n\\t\\tfor(int i=1;i<store.size();i++){\\n\\t\\t\\taval.push({store[i].second,store[i].first});\\n\\t\\t}\\n\\t\\t   long long dur = end-start;      // calculate duration \\n            room[roomno]++;\\n            \\n            if(et<=start)\\n              aval.push({end,roomno});\\n                \\n            else\\n              aval.push({et+dur,roomno});\\n      \\n        }\\n        \\n        \\n        long long l = 0;\\n        long long num = -1;\\n        for(int i=0;i<n;i++){\\n            if(room[i]>l){\\n                l = room[i];\\n                num = i;\\n            }\\n        }\\n        \\n        return num;\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<int> room(n,0);\\n\\tpriority_queue<pair<long long,long long>,vector<pair<long long,long long>>,greater<pair<long long,long long>>> aval;  //(endtime, room no.) for keeping track of avaliability of rooms (sorted in ascending order of end time)\\n\\tfor(int i=0;i<n;i++){\\n\\t\\taval.push({0,i});\\n\\t}\\n\\tpriority_queue<pair<long long,long long>,vector<pair<long long,long long>>,greater<pair<long long,long long>>> pq; // for the meetings to be scheduled (start,end) ( sorted in ascending order of start time)\\n\\tfor(int i = 0;i<meet.size();i++){\\n\\t\\tpq.push({meet[i][0],meet[i][1]});\\n\\t}\\n\\n\\twhile(pq.size()){\\n\\n\\t\\tlong long start = pq.top().first;\\n\\t\\tlong long end = pq.top().second;\\n\\t\\tpq.pop();\\n\\n\\t\\tvector<pair<long long,long long>> store;  // to check which meeting room has lowest room no. among all unused rooms(stores {room no.,end time})\\n\\t\\tlong long et = aval.top().first;      // end time \\n\\t\\tlong long roomno = aval.top().second;  \\n\\t\\taval.pop();                                    // if the end time of all rooms are greater than start then store will contain only 1 room \\n\\t\\tstore.push_back({roomno,et});\\n\\t\\twhile(aval.size() && aval.top().first<= start){   // push in all rooms that are unused  \\n\\t\\t et = aval.top().first;\\n\\t\\t roomno = aval.top().second;\\n\\t\\t aval.pop();\\n\\t\\t\\tstore.push_back({roomno,et});\\n\\t\\t}\\n\\n\\t\\tsort(store.begin(),store.end());     //  sort to get the unused room with lowest room number\\n\\n\\t\\tet = store[0].second;                // choose the room at 0th index and put rest of the rooms from index 1 back in pq\\n\\t\\troomno= store[0].first;\\n\\n\\t\\tfor(int i=1;i<store.size();i++){\\n\\t\\t\\taval.push({store[i].second,store[i].first});\\n\\t\\t}\\n\\t\\t   long long dur = end-start;      // calculate duration \\n            room[roomno]++;\\n            \\n            if(et<=start)\\n              aval.push({end,roomno});\\n                \\n            else\\n              aval.push({et+dur,roomno});\\n      \\n        }\\n        \\n        \\n        long long l = 0;\\n        long long num = -1;\\n        for(int i=0;i<n;i++){\\n            if(room[i]>l){\\n                l = room[i];\\n                num = i;\\n            }\\n        }\\n        \\n        return num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2854705,
                "title": "java-solution-with-detailed-explanations",
                "content": "```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        // sort rooms by start time\\n        Arrays.sort(meetings, (m1, m2) -> m1[0] - m2[0]);\\n        // key: int[end time, room number]\\n        // sort by end time, if the same end time - sort by lowest room number\\n        PriorityQueue<int []> sheduler = new PriorityQueue<>((m1, m2) -> m1[0] == m2[0] ? m1[1] - m2[1] : m1[0] - m2[0]);\\n        PriorityQueue<Integer> availableRooms = new PriorityQueue<>();\\n        for (int i = 0; i < n; i++) {\\n            availableRooms.add(i); // add all rooms to availability\\n        }\\n        \\n        int[] roomUsageCount = new int[n];\\n        for (int[] meeting : meetings) {\\n            int currMeetingStartTime = meeting[0];\\n            while (!sheduler.isEmpty() && currMeetingStartTime >= sheduler.peek()[0]) { // empty past meetings\\n                availableRooms.add(sheduler.remove()[1]); // add freed room to availability\\n            }\\n            int delay = 0;\\n            if (availableRooms.size() == 0) { // all rooms are full\\n                int[] endedMeeting = sheduler.remove();\\n                delay = endedMeeting[0] - currMeetingStartTime; // add delay\\n                availableRooms.add(endedMeeting[1]); // add free room back to availability\\n            }\\n            int currMeetingEndTime = meeting[1] + delay;\\n            int availableRoom = availableRooms.remove(); // get lowest available room\\n            sheduler.add(new int[] {currMeetingEndTime, availableRoom}); // add current meeting \\n            roomUsageCount[availableRoom]++;\\n        }\\n        \\n        // find the most used room\\n        int maxUsedRoom = 0;\\n        int maxUsage = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (roomUsageCount[i] > maxUsage) {\\n                maxUsage = roomUsageCount[i];\\n                maxUsedRoom = i;\\n            }\\n        }\\n        return maxUsedRoom;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        // sort rooms by start time\\n        Arrays.sort(meetings, (m1, m2) -> m1[0] - m2[0]);\\n        // key: int[end time, room number]\\n        // sort by end time, if the same end time - sort by lowest room number\\n        PriorityQueue<int []> sheduler = new PriorityQueue<>((m1, m2) -> m1[0] == m2[0] ? m1[1] - m2[1] : m1[0] - m2[0]);\\n        PriorityQueue<Integer> availableRooms = new PriorityQueue<>();\\n        for (int i = 0; i < n; i++) {\\n            availableRooms.add(i); // add all rooms to availability\\n        }\\n        \\n        int[] roomUsageCount = new int[n];\\n        for (int[] meeting : meetings) {\\n            int currMeetingStartTime = meeting[0];\\n            while (!sheduler.isEmpty() && currMeetingStartTime >= sheduler.peek()[0]) { // empty past meetings\\n                availableRooms.add(sheduler.remove()[1]); // add freed room to availability\\n            }\\n            int delay = 0;\\n            if (availableRooms.size() == 0) { // all rooms are full\\n                int[] endedMeeting = sheduler.remove();\\n                delay = endedMeeting[0] - currMeetingStartTime; // add delay\\n                availableRooms.add(endedMeeting[1]); // add free room back to availability\\n            }\\n            int currMeetingEndTime = meeting[1] + delay;\\n            int availableRoom = availableRooms.remove(); // get lowest available room\\n            sheduler.add(new int[] {currMeetingEndTime, availableRoom}); // add current meeting \\n            roomUsageCount[availableRoom]++;\\n        }\\n        \\n        // find the most used room\\n        int maxUsedRoom = 0;\\n        int maxUsage = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (roomUsageCount[i] > maxUsage) {\\n                maxUsage = roomUsageCount[i];\\n                maxUsedRoom = i;\\n            }\\n        }\\n        return maxUsedRoom;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774209,
                "title": "elegant-solution-in-javascript-with-detailed-walkthrough-and-example",
                "content": "# Intuition\\n\\nThe intuition behind solving this problem is to keep track of the end time of each room and book the earliest available room with the lowest index in the list. We will use two arrays to store the counters of the meetings in each room and the earliest end time for each room.\\n\\n# Approach\\n\\nSince JavaScript does not have a built-in Heap data structure, we can solve this problem using just an array and two loops. We will iterate through the meetings using the `map` method, and for each meeting iteration, we will iterate through the rooms using a `for` loop. This approach allows us to check all the rooms and find the room with the earliest end time.\\n\\nRead the code and follow the walkthrough below to understand the solution better. It is recommended to create your own doodles and explain the solution to yourself for better comprehension.\\n\\n# Complexity\\n\\n- Time complexity: O(m * n) => O(n)\\n  - Here, m represents the number of meetings, and n represents the number of rooms. The overall time complexity is linear.\\n  - It\\'s important to note that the Chrome web browser uses the Timsort implementation, which is a hybrid of merge sort and insertion sort. So, the time complexity of our `sort` method is O(n*logn). However, for small arrays, its time complexity is O(n).\\n\\n- Space complexity: O(n)\\n  - The rooms counter array and available rooms array have the same length, which is n.\\n  - Additionally, we introduce two integer variables and one boolean variable, resulting in a total of three variables with constant space complexity.\\n  - Therefore, the overall space complexity is O(2 * n) + O(1 * 3).\\n\\n# Walkthrough\\n\\n1. First, we define two arrays: `rooms_meetings_counter` and `available_rooms`. The `rooms_meetings_counter` array will keep the counters of the meetings in each room, and the `available_rooms` array will store the earliest end time for each room. The indexes in these arrays represent the room number. Take your time to understand this step as it is crucial to the logic.\\n\\n2. We sort the meetings array by their start time using the `sort` method. This sorting step is essential for our solution.\\n\\n3. Next, we iterate through the meetings using the `map` method. Alternatively, we can use a `for` loop, but in my opinion, the `map` method provides a more elegant solution.\\n\\n4. For each meeting iteration, we introduce two variables: `earliestRoomIdx` and `earliestEndTime`. We start with the index 0 because we want to check all the rooms and find the room with the earliest end time. For the earliest end time, we initialize it with the maximum possible value, which can be either `Infinity` or `Number.MAX_SAFE_INTEGER`.\\n\\n5. Within each meeting iteration, we iterate through all the rooms we have.\\n\\n6. The first `if` condition checks the availability of the room by comparing the start time with the end time of all the rooms stored in the `available_rooms` array. By default, the `available_rooms` array is populated with -1 since the start time cannot be a negative value. The condition checks if the current room is available for the current meeting. If it is, we update the `available_rooms` array with the end time of the current meeting and break out of the `for` loop.\\n\\n7. The second `if` condition is responsible for tracking the earliest end time and the corresponding room index. If we do not find an available room in the previous step, we check if the end time of the current room iteration is less than the registered earliest end time. If it is, we update the earliest end time and the earliest room index with the index of the current room iteration.\\n\\n8. The last `if` condition checks if all the rooms are busy. If this condition is true, it means that no rooms are available for the current meeting. In this case, we assign the current meeting to the room with the earliest end time. To do this, we use the earliest room index and update this room with a new end time, which is equal to the previous end time plus the duration of the current meeting.\\n\\n9. Now, let\\'s discuss the purpose of the boolean flag `isAvailableRoomExist`. When we break out of the `for` loop and find a free room, we should not trigger the last `if` condition from step 8. This condition should only be triggered when there is no available room for the meeting. The boolean variable `isAvailableRoomExist` indicates that we did not find a room, but we found the earliest room index.\\n\\n10. In the last step, we find the maximum value in the `rooms_meetings_counter` array and retrieve its index using the `indexOf` function. This will return the lowest index with the maximum value.\\n\\n11. Congratulations! You have solved the problem. \\nReward yourself with a cup of coffee. \\nYou deserve it! \\uD83D\\uDE0A\\n\\n# Example\\n\\nLet\\'s use the data from the test case to see how the code works.\\nWe have the input: `[[1,20],[2,10],[3,5],[4,9],[6,8]]`.\\n\\nThe first three meetings will take all three available rooms, resulting in the following arrays:\\n```\\nrooms_meetings_counter = [1, 1, 1] \\navailable_rooms = [20, 10, 5]\\n```\\nThis means that we have reached the first `if` condition, and the rest of the code is skipped.\\n\\nThe last two meetings are different:\\n1. We skip the first `if` condition.\\n2. We iterate through the rooms to find the earliest end time and the earliest room index in the second `if` condition.\\n3. We update the counter value for the current room.\\n\\nFor the meeting [4,9], the earliest end time is at index 2, and the earliest end time is 5. So, in the last `if` condition, we pick `available_rooms[2]` and assign the value of 5 + (9-4). As a result, we have the following arrays:\\n\\n```\\nrooms_meetings_counter = [1, 1, 2] \\navailable_rooms = [20, 10, 10]\\n```\\n\\nThe last meeting is [6, 8]. We iterate from room 0 up to room 2, and it seems that the earliest end time here is 10 at index 1. If we check the last room, 10 < 10 is false, and we do not update the earliest room index further.\\n\\nAs a result, we have the following arrays:\\n\\n```\\nrooms_meetings_counter = [1, 2, 2] \\navailable_rooms = [20, 12, 10]\\n```\\n\\nNow, we can proceed to step 10 and return the index 1 as our result.\\n\\n# Implementation\\n\\n```javascript\\n/**\\n * @param {number} n\\n * @param {number[][]} meetings\\n * @return {number}\\n */\\n\\nvar mostBooked = function(n, meetings) {\\n    let rooms_meetings_counter = new Array(n).fill(0);\\n    let available_rooms = new Array(n).fill(-1);\\n    meetings.sort((a, b) => a[0] - b[0]);\\n\\n    meetings.map((meeting) => {\\n        let [start, end] = meeting;\\n        let earliestRoomIdx = 0;\\n        let earliestEndTime = Number.MAX_SAFE_INTEGER;\\n\\n        let isAvailableRoomExist = false;\\n\\n        for (let i = 0; i < n; i++) {\\n            if (available_rooms[i] <= start) {\\n                rooms_meetings_counter[i]++;\\n                available_rooms[i] = end;\\n                isAvailableRoomExist = true;\\n                break;\\n            }\\n\\n            if (available_rooms[i] < earliestEndTime) {\\n                earliestEndTime = available_rooms[i];\\n                earliestRoomIdx = i;\\n            }\\n        }\\n\\n        if (!isAvailableRoomExist) {\\n            rooms_meetings_counter[earliestRoomIdx]++;\\n            available_rooms[earliestRoomIdx] += end - start;\\n        }\\n    });\\n\\n    return rooms_meetings_counter.indexOf(Math.max(...rooms_meetings_counter));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nrooms_meetings_counter = [1, 1, 1] \\navailable_rooms = [20, 10, 5]\\n```\n```\\nrooms_meetings_counter = [1, 1, 2] \\navailable_rooms = [20, 10, 10]\\n```\n```\\nrooms_meetings_counter = [1, 2, 2] \\navailable_rooms = [20, 12, 10]\\n```\n```javascript\\n/**\\n * @param {number} n\\n * @param {number[][]} meetings\\n * @return {number}\\n */\\n\\nvar mostBooked = function(n, meetings) {\\n    let rooms_meetings_counter = new Array(n).fill(0);\\n    let available_rooms = new Array(n).fill(-1);\\n    meetings.sort((a, b) => a[0] - b[0]);\\n\\n    meetings.map((meeting) => {\\n        let [start, end] = meeting;\\n        let earliestRoomIdx = 0;\\n        let earliestEndTime = Number.MAX_SAFE_INTEGER;\\n\\n        let isAvailableRoomExist = false;\\n\\n        for (let i = 0; i < n; i++) {\\n            if (available_rooms[i] <= start) {\\n                rooms_meetings_counter[i]++;\\n                available_rooms[i] = end;\\n                isAvailableRoomExist = true;\\n                break;\\n            }\\n\\n            if (available_rooms[i] < earliestEndTime) {\\n                earliestEndTime = available_rooms[i];\\n                earliestRoomIdx = i;\\n            }\\n        }\\n\\n        if (!isAvailableRoomExist) {\\n            rooms_meetings_counter[earliestRoomIdx]++;\\n            available_rooms[earliestRoomIdx] += end - start;\\n        }\\n    });\\n\\n    return rooms_meetings_counter.indexOf(Math.max(...rooms_meetings_counter));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3682947,
                "title": "simple-and-detailed-comments-readable-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing Min heap\\n\\n# Complexity\\n- Time complexity: \\nO(nlogn)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def mostBooked(self, num_rooms, meetings):\\n        # Create a list of available rooms using indices from 0 to num_rooms-1\\n        available_rooms = [room for room in range(num_rooms)]\\n        occupied_rooms = []  # Stores rooms that are currently occupied\\n        heapify(available_rooms)  # Convert the available_rooms list into a heap\\n        booking_counts = [0] * num_rooms  # Initialize a list to keep track of booking counts per room\\n\\n        # Sort the meetings in ascending order based on the start time\\n        sorted_meetings = sorted(meetings, key=lambda x: x[0])\\n        for start_time, end_time in sorted_meetings:\\n            # Check if there are any available rooms at the start time of the meeting\\n            while occupied_rooms and occupied_rooms[0][0] <= start_time:\\n                # Room becomes available, add it back to the available_rooms heap\\n                end, room = heappop(occupied_rooms)\\n                heappush(available_rooms, room)\\n\\n            if available_rooms:\\n                # Assign an available room from the available_rooms heap to the meeting\\n                room = heappop(available_rooms)\\n                heappush(occupied_rooms, [end_time, room])  # Add the meeting to the occupied_rooms heap\\n            else:\\n                # All rooms are occupied, find the room with the earliest end time\\n                current_end, room = heappop(occupied_rooms)\\n                new_end = current_end + end_time - start_time  # Update the room\\'s end time\\n                heappush(occupied_rooms, [new_end, room])\\n\\n            booking_counts[room] += 1  # Increment the booking count for the assigned room\\n\\n        # Find the room with the maximum booking count and return its index\\n        max_booking_count = max(booking_counts)\\n        most_booked_room = booking_counts.index(max_booking_count)\\n        return most_booked_room\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, num_rooms, meetings):\\n        # Create a list of available rooms using indices from 0 to num_rooms-1\\n        available_rooms = [room for room in range(num_rooms)]\\n        occupied_rooms = []  # Stores rooms that are currently occupied\\n        heapify(available_rooms)  # Convert the available_rooms list into a heap\\n        booking_counts = [0] * num_rooms  # Initialize a list to keep track of booking counts per room\\n\\n        # Sort the meetings in ascending order based on the start time\\n        sorted_meetings = sorted(meetings, key=lambda x: x[0])\\n        for start_time, end_time in sorted_meetings:\\n            # Check if there are any available rooms at the start time of the meeting\\n            while occupied_rooms and occupied_rooms[0][0] <= start_time:\\n                # Room becomes available, add it back to the available_rooms heap\\n                end, room = heappop(occupied_rooms)\\n                heappush(available_rooms, room)\\n\\n            if available_rooms:\\n                # Assign an available room from the available_rooms heap to the meeting\\n                room = heappop(available_rooms)\\n                heappush(occupied_rooms, [end_time, room])  # Add the meeting to the occupied_rooms heap\\n            else:\\n                # All rooms are occupied, find the room with the earliest end time\\n                current_end, room = heappop(occupied_rooms)\\n                new_end = current_end + end_time - start_time  # Update the room\\'s end time\\n                heappush(occupied_rooms, [new_end, room])\\n\\n            booking_counts[room] += 1  # Increment the booking count for the assigned room\\n\\n        # Find the room with the maximum booking count and return its index\\n        max_booking_count = max(booking_counts)\\n        most_booked_room = booking_counts.index(max_booking_count)\\n        return most_booked_room\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527286,
                "title": "java-explained-in-comments-o-n-log-n-time-two-priorityqueues-solution",
                "content": "```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        // Counter for number of meetings held in room\\n        int[] rooms = new int[n];\\n        \\n        // List(start, end, room number)\\n        PriorityQueue<List<Long>> occupiedRooms = new PriorityQueue<>((x, y) \\n                                                                         -> Long.compare(x.get(1), y.get(1)));\\n        // 1. Each meeting will take place in the free room with the lowest number.\\n        PriorityQueue<Long> freeRooms = new PriorityQueue<>();\\n        for (int i = 0; i < n; i++) {\\n            freeRooms.add((long) i);\\n        }\\n        \\n        // 3. Meetings that have an earlier original start time should be given the room\\n        Arrays.sort(meetings, (x, y) -> Integer.compare(x[0], y[0]));\\n        long currentTime = 0;\\n        for (int[] meeting : meetings) {\\n            // Update time to meeting time if meeting time is later\\n            currentTime = Math.max(meeting[0], currentTime);\\n            \\n            // If no meeting rooms left, go to time where earliest room will be cleared\\n            if (freeRooms.isEmpty()) {\\n                long earliestFreeTime = occupiedRooms.peek().get(1);\\n                currentTime = Math.max(earliestFreeTime, currentTime);\\n            }            \\n            \\n            // Clear all rooms occuring at and before this time\\n            while (!occupiedRooms.isEmpty() && occupiedRooms.peek().get(1) <= currentTime) {\\n                long freedRoom = occupiedRooms.poll().get(2);\\n                freeRooms.add(freedRoom);\\n            }\\n            \\n            // Occupy a new room, \\n            // 2. Delayed meeting should have same duration\\n            long nextRoom = freeRooms.poll();\\n            rooms[(int) nextRoom] += 1;\\n            occupiedRooms.add(List.of(currentTime, currentTime + (meeting[1] - meeting[0]), nextRoom));\\n        }\\n        \\n        // Get smallest room with largest meetings held\\n        int max = 0, ansRoom = 0;\\n        for (int i = n-1; i >= 0; i--) {\\n            if (rooms[i] >= max) {\\n                max = rooms[i];\\n                ansRoom = i;\\n            }\\n        }\\n        return ansRoom;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        // Counter for number of meetings held in room\\n        int[] rooms = new int[n];\\n        \\n        // List(start, end, room number)\\n        PriorityQueue<List<Long>> occupiedRooms = new PriorityQueue<>((x, y) \\n                                                                         -> Long.compare(x.get(1), y.get(1)));\\n        // 1. Each meeting will take place in the free room with the lowest number.\\n        PriorityQueue<Long> freeRooms = new PriorityQueue<>();\\n        for (int i = 0; i < n; i++) {\\n            freeRooms.add((long) i);\\n        }\\n        \\n        // 3. Meetings that have an earlier original start time should be given the room\\n        Arrays.sort(meetings, (x, y) -> Integer.compare(x[0], y[0]));\\n        long currentTime = 0;\\n        for (int[] meeting : meetings) {\\n            // Update time to meeting time if meeting time is later\\n            currentTime = Math.max(meeting[0], currentTime);\\n            \\n            // If no meeting rooms left, go to time where earliest room will be cleared\\n            if (freeRooms.isEmpty()) {\\n                long earliestFreeTime = occupiedRooms.peek().get(1);\\n                currentTime = Math.max(earliestFreeTime, currentTime);\\n            }            \\n            \\n            // Clear all rooms occuring at and before this time\\n            while (!occupiedRooms.isEmpty() && occupiedRooms.peek().get(1) <= currentTime) {\\n                long freedRoom = occupiedRooms.poll().get(2);\\n                freeRooms.add(freedRoom);\\n            }\\n            \\n            // Occupy a new room, \\n            // 2. Delayed meeting should have same duration\\n            long nextRoom = freeRooms.poll();\\n            rooms[(int) nextRoom] += 1;\\n            occupiedRooms.add(List.of(currentTime, currentTime + (meeting[1] - meeting[0]), nextRoom));\\n        }\\n        \\n        // Get smallest room with largest meetings held\\n        int max = 0, ansRoom = 0;\\n        for (int i = n-1; i >= 0; i--) {\\n            if (rooms[i] >= max) {\\n                max = rooms[i];\\n                ansRoom = i;\\n            }\\n        }\\n        return ansRoom;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616664,
                "title": "python-two-heap-solution",
                "content": "Time Complexity: `O(nlogn)`\\nSpace Complexity: `O(N)`\\n```\\n# Learn from @lee215, add my own thought\\n# Algorithm:\\n# Two Heap:\\n#      One heap record the ready room\\n#      another heap record the room holding meeting and the end time\\n# Also, use the ans arry to record the times each used.\\n# if there is a ready room, push the room to the meeting room\\n# if there is not a ready room, pop the room with earliest end time, and push again with new end time\\nfrom heapq import heapify, heappush, heappop\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        # sort meetings:\\n        meetings.sort()\\n        # initialize the two min Heap\\n        ready_room = list(range(n))\\n        meeting_room = []\\n        heapify(ready_room)\\n        heapify(meeting_room)\\n        # initialize the ans array\\n        ans = [0] * n\\n        # start to go through the meetings\\n        for start, end in meetings:\\n            while meeting_room  and meeting_room [0][0] <= start:\\n                _, room = heappop(meeting_room)\\n                # push the ready room back to the heap\\n                heappush(ready_room, room)\\n            # if there is a ready room, \\n            if ready_room:\\n                room = heappop(ready_room)\\n                heappush(meeting_room, [end, room])\\n            # if there is not a ready room, pop and push again\\n            else:\\n                endtime, room = heappop(meeting_room)\\n                heappush(meeting_room, [endtime + end - start, room])\\n            # in this iteration, we use the room, so + 1\\n            ans[room] += 1\\n        # return the used-most room\\n        return ans.index(max(ans))\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n# Learn from @lee215, add my own thought\\n# Algorithm:\\n# Two Heap:\\n#      One heap record the ready room\\n#      another heap record the room holding meeting and the end time\\n# Also, use the ans arry to record the times each used.\\n# if there is a ready room, push the room to the meeting room\\n# if there is not a ready room, pop the room with earliest end time, and push again with new end time\\nfrom heapq import heapify, heappush, heappop\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        # sort meetings:\\n        meetings.sort()\\n        # initialize the two min Heap\\n        ready_room = list(range(n))\\n        meeting_room = []\\n        heapify(ready_room)\\n        heapify(meeting_room)\\n        # initialize the ans array\\n        ans = [0] * n\\n        # start to go through the meetings\\n        for start, end in meetings:\\n            while meeting_room  and meeting_room [0][0] <= start:\\n                _, room = heappop(meeting_room)\\n                # push the ready room back to the heap\\n                heappush(ready_room, room)\\n            # if there is a ready room, \\n            if ready_room:\\n                room = heappop(ready_room)\\n                heappush(meeting_room, [end, room])\\n            # if there is not a ready room, pop and push again\\n            else:\\n                endtime, room = heappop(meeting_room)\\n                heappush(meeting_room, [endtime + end - start, room])\\n            # in this iteration, we use the room, so + 1\\n            ans[room] += 1\\n        # return the used-most room\\n        return ans.index(max(ans))\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538259,
                "title": "python-no-heap",
                "content": "```python\\n        rooms, count = [0] * n, [0] * n\\n        for a, b in sorted(meetings):\\n            best_i, best_end = None, inf\\n            for i, end in enumerate(rooms):\\n                if a >= end:\\n                    rooms[i] = b\\n                    count[i] += 1\\n                    break\\n                if end < best_end:\\n                    best_i, best_end = i, end\\n            else:\\n                rooms[best_i] = b - a + rooms[best_i]\\n                count[best_i] += 1\\n        return count.index(max(count))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n        rooms, count = [0] * n, [0] * n\\n        for a, b in sorted(meetings):\\n            best_i, best_end = None, inf\\n            for i, end in enumerate(rooms):\\n                if a >= end:\\n                    rooms[i] = b\\n                    count[i] += 1\\n                    break\\n                if end < best_end:\\n                    best_i, best_end = i, end\\n            else:\\n                rooms[best_i] = b - a + rooms[best_i]\\n                count[best_i] += 1\\n        return count.index(max(count))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2528754,
                "title": "explanation-of-every-step-using-one-priority-queue",
                "content": "Hii Everyone this is very interesting problem\\nApproach :\\n**STEP 1** - Sort the meeting array\\n**STEP 2** - Use priority queue of room size(n) to store meetings in rooms min priority_queue<pair<time, room number>>\\n**STEP 3** - Create vistied array to check if any room is empty or not and a Answer array to store the total meetings happend in the room\\n**STEP 4** - Start pushing in priority queue if any room is vacant\\n**STEP 5** -\\n\\t\\t\\tThis part of code is because if more than one room is empty for a meeting then meeting will happen in smal indexed room.\\n```\\n while(p.size()>0 && p.top().first <= j[0]){\\n                auto m = p.top();\\n                p.pop();\\n                vis[m.second]=0;\\n                \\n            }\\n```\\n\\n\\t\\t\\t\\n\\t\\t\\tDry run for this test case:\\n\\t\\t\\tn = 2\\n\\t\\t\\tmeetings = [[0,10],[1,2],[12,14],[13,15]]\\n\\t\\t\\ti =0 , pq is empty, will go in for loop and room no.0 is vacant meeting [0,10] will happen in room no. 0. mark vis vector.\\n\\t\\t\\tpush in pq< meetings[i][1],0>\\n\\t\\t\\ti = 1 pq is not empty but pq.top().first>meetings[i][0]\\n\\t\\t\\tgo in for loop room no. 1 is vacant push in pq in room no. 1;\\n\\t\\t\\tmark vis vector\\n\\t\\t\\t\\n\\t\\t\\ti = 2, pq is not  empty and pq.top().first<meetings[i][0]{\\n\\t\\t\\tgo in while loop pop till pq.top().first>meetings[i][0]\\n\\t\\t\\tans unmark vist vector......\\n\\t\\t\\t.......\\n\\t\\t\\t`int mostBooked(int n, vector<vector<int>>& meetings) {\\n\\t\\t\\t\\tpriority_queue<pair<long long,long long >,vector<pair<long long,long long >>,greater<pair<long long,long long >>>p;\\n\\t\\t\\t\\tsort(meetings.begin(),meetings.end());\\n\\n\\t\\t\\t\\tvector<long long >vis(n,0);\\n\\t\\t\\t\\tvector<long long >count(n,0);\\n\\t\\t\\t\\tfor(auto j : meetings){\\n\\t\\t\\t\\t\\tint f = 1;\\n\\t\\t\\t\\t\\twhile(p.size()>0 && p.top().first <= j[0]){\\n\\t\\t\\t\\t\\t\\tauto m = p.top();\\n\\t\\t\\t\\t\\t\\tp.pop();\\n\\t\\t\\t\\t\\t\\tvis[m.second]=0;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\t\\tif(vis[i]==0){\\n\\t\\t\\t\\t\\t\\t\\tvis[i]=1;\\n\\n\\t\\t\\t\\t\\t\\t\\tp.push({j[1],i});\\n\\t\\t\\t\\t\\t\\t\\tcount[i]++;\\n\\t\\t\\t\\t\\t\\t\\tf = 0;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(f == 1){\\n\\n\\t\\t\\t\\t\\t\\tauto m = p.top();\\n\\t\\t\\t\\t\\t\\tp.pop();\\n\\t\\t\\t\\t\\t\\tp.push({j[1]+m.first-j[0], m.second});\\n\\t\\t\\t\\t\\t\\tcount[m.second]++;\\n\\t\\t\\t\\t\\t\\tvis[m.second]=1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlong long  mx = 0;\\n\\t\\t\\t\\tlong long  ans=0;\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t   if(mx<count[i]){\\n\\t\\t\\t\\t\\t   ans=i;\\n\\t\\t\\t\\t\\t   mx = count[i];\\n\\t\\t\\t\\t   }\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n    }`\\n\\t\\t\\tplease upvote if you liked it.\\n\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\n while(p.size()>0 && p.top().first <= j[0]){\\n                auto m = p.top();\\n                p.pop();\\n                vis[m.second]=0;\\n                \\n            }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2527811,
                "title": "java-2-heaps",
                "content": "int overflow was a troublesome\\n```java\\n\\n    public int mostBooked(int n, int[][] meetings) {\\n        PriorityQueue<Room> free = new PriorityQueue<>(Comparator.comparingInt(r -> r.roomNumber));\\n        PriorityQueue<Room> working = new PriorityQueue<>((r1, r2) -> {\\n            if (r1.nextAvailableTime == r2.nextAvailableTime)\\n                return Integer.compare(r1.roomNumber, r2.roomNumber);\\n            return Long.compare(r1.nextAvailableTime, r2.nextAvailableTime);\\n        });\\n\\n        for (int i = 0; i < n; i++) {\\n            free.add(new Room(i));\\n        }\\n\\n        Arrays.sort(meetings, Comparator.comparingInt(o -> o[0]));\\n\\n        for (int[] meeting : meetings) {\\n            while (!working.isEmpty() && working.peek().nextAvailableTime <= meeting[0]) {\\n                free.offer(working.poll());\\n            }\\n\\n            Room room = null;\\n            if (free.isEmpty()) {\\n                room = working.poll();\\n            } else {\\n                room = free.poll();\\n            }\\n            room.holdMeeting(meeting);\\n            working.offer(room);\\n        }\\n\\n        free.addAll(working);\\n\\n        return free.stream()\\n                .sorted((r1, r2) -> {\\n                    if (r1.meetingCnt == r2.meetingCnt) {\\n                        return Integer.compare(r1.roomNumber, r2.roomNumber);\\n                    }\\n                    return Integer.compare(r2.meetingCnt, r1.meetingCnt);\\n                }).findFirst().get().roomNumber;\\n    }\\n\\n    class Room {\\n        int roomNumber;\\n        int meetingCnt = 0;\\n        long nextAvailableTime = -1;\\n\\n        public Room(int roomNumber) {\\n            this.roomNumber = roomNumber;\\n        }\\n\\n        public void holdMeeting(int[] meeting) {\\n            int duration = meeting[1] - meeting[0];\\n            this.nextAvailableTime = Math.max(this.nextAvailableTime, meeting[0]) + duration;\\n            meetingCnt++;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"Room{\" +\\n                    \"roomNumber=\" + roomNumber +\\n                    \", meetingCnt=\" + meetingCnt +\\n                    \", nextAvailableTime=\" + nextAvailableTime +\\n                    \\'}\\';\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n\\n    public int mostBooked(int n, int[][] meetings) {\\n        PriorityQueue<Room> free = new PriorityQueue<>(Comparator.comparingInt(r -> r.roomNumber));\\n        PriorityQueue<Room> working = new PriorityQueue<>((r1, r2) -> {\\n            if (r1.nextAvailableTime == r2.nextAvailableTime)\\n                return Integer.compare(r1.roomNumber, r2.roomNumber);\\n            return Long.compare(r1.nextAvailableTime, r2.nextAvailableTime);\\n        });\\n\\n        for (int i = 0; i < n; i++) {\\n            free.add(new Room(i));\\n        }\\n\\n        Arrays.sort(meetings, Comparator.comparingInt(o -> o[0]));\\n\\n        for (int[] meeting : meetings) {\\n            while (!working.isEmpty() && working.peek().nextAvailableTime <= meeting[0]) {\\n                free.offer(working.poll());\\n            }\\n\\n            Room room = null;\\n            if (free.isEmpty()) {\\n                room = working.poll();\\n            } else {\\n                room = free.poll();\\n            }\\n            room.holdMeeting(meeting);\\n            working.offer(room);\\n        }\\n\\n        free.addAll(working);\\n\\n        return free.stream()\\n                .sorted((r1, r2) -> {\\n                    if (r1.meetingCnt == r2.meetingCnt) {\\n                        return Integer.compare(r1.roomNumber, r2.roomNumber);\\n                    }\\n                    return Integer.compare(r2.meetingCnt, r1.meetingCnt);\\n                }).findFirst().get().roomNumber;\\n    }\\n\\n    class Room {\\n        int roomNumber;\\n        int meetingCnt = 0;\\n        long nextAvailableTime = -1;\\n\\n        public Room(int roomNumber) {\\n            this.roomNumber = roomNumber;\\n        }\\n\\n        public void holdMeeting(int[] meeting) {\\n            int duration = meeting[1] - meeting[0];\\n            this.nextAvailableTime = Math.max(this.nextAvailableTime, meeting[0]) + duration;\\n            meetingCnt++;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"Room{\" +\\n                    \"roomNumber=\" + roomNumber +\\n                    \", meetingCnt=\" + meetingCnt +\\n                    \", nextAvailableTime=\" + nextAvailableTime +\\n                    \\'}\\';\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527383,
                "title": "double-min-heaps-fully-explained",
                "content": "Observations:\\n\\n1. We must prioritize allocating the smallest indexed room number - MIN HEAP\\n2. We must know the next room number that becomes available by the end time - MIN HEAP\\n3. We must sort the meetings array by start time because we want to process the input sequentially.\\n\\nLogic:\\n\\nGiven the observations, we have the following thing:\\n\\nWe will have a min heap that will give us the next empty room prioritizing on the index.\\nWe also must know the room that frees up next, so we will have a min heap that we will store (end_time, room_number)\\nwhich will be ordered by the end_time.\\n\\nAt every iteration on meetings we have few things happening:\\n1. All the meetings that ended before (or at) the start_time of the current meeting are now ended, so they rooms are freed. We will push them back onto the rooms heap.\\n\\n2. If there is no empty room, we still need to allocate a room to the meeting, but with a delay.\\nWe will pop the meeting that the next one to end, and we will also pop all the meetings that have the same end time, because maybe 2 or more meetings end at the same time.\\nAfter popping the meeting, we allocate their rooms back to the rooms_heap. \\n\\nNow we must add the current meeting, but we address the delay. So the current meeting will end at meeting_end + delay.\\n\\nIn the end check the room number that hosted the most meetings.\\n\\n\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        rooms_number_heap = [i for i in range(n)]\\n        end_interval_heap = []\\n        ans = [0] * n\\n        \\n        meetings.sort(key=lambda x: x[0])\\n        heapq.heapify(rooms_number_heap)\\n        \\n        for meeting_start, meeting_end in meetings:\\n            delay = 0\\n            \\n            # the rooms that are now freed\\n            while end_interval_heap and end_interval_heap[0][0] <= meeting_start:\\n                end, no = heapq.heappop(end_interval_heap)\\n                heapq.heappush(rooms_number_heap, no)\\n            \\n            \\n            # If no empty room - there is a delay\\n            if not rooms_number_heap:\\n                end_time, room_no = heapq.heappop(end_interval_heap)\\n                # push the room number back to heap\\n                heapq.heappush(rooms_number_heap, room_no)\\n                \\n                # count delay\\n                delay = max(0, end_time - meeting_start)\\n                \\n                while end_interval_heap and end_interval_heap[0] == end_time:\\n                    end, no = heapq.heappop(end_interval_heap)\\n                    heapq.heappush(rooms_number_heap, no)\\n                \\n            # allocate a room\\n            room_no = heapq.heappop(rooms_number_heap)\\n            ans[room_no] += 1\\n            heapq.heappush(end_interval_heap, (meeting_end + delay, room_no) )\\n        \\n        \\n        best_count = 0\\n        ans_i = 0\\n        for i, v in enumerate(ans):\\n            if v > best_count:\\n                best_count = v\\n                ans_i = i\\n        \\n        return ans_i\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        rooms_number_heap = [i for i in range(n)]\\n        end_interval_heap = []\\n        ans = [0] * n\\n        \\n        meetings.sort(key=lambda x: x[0])\\n        heapq.heapify(rooms_number_heap)\\n        \\n        for meeting_start, meeting_end in meetings:\\n            delay = 0\\n            \\n            # the rooms that are now freed\\n            while end_interval_heap and end_interval_heap[0][0] <= meeting_start:\\n                end, no = heapq.heappop(end_interval_heap)\\n                heapq.heappush(rooms_number_heap, no)\\n            \\n            \\n            # If no empty room - there is a delay\\n            if not rooms_number_heap:\\n                end_time, room_no = heapq.heappop(end_interval_heap)\\n                # push the room number back to heap\\n                heapq.heappush(rooms_number_heap, room_no)\\n                \\n                # count delay\\n                delay = max(0, end_time - meeting_start)\\n                \\n                while end_interval_heap and end_interval_heap[0] == end_time:\\n                    end, no = heapq.heappop(end_interval_heap)\\n                    heapq.heappush(rooms_number_heap, no)\\n                \\n            # allocate a room\\n            room_no = heapq.heappop(rooms_number_heap)\\n            ans[room_no] += 1\\n            heapq.heappush(end_interval_heap, (meeting_end + delay, room_no) )\\n        \\n        \\n        best_count = 0\\n        ans_i = 0\\n        for i, v in enumerate(ans):\\n            if v > best_count:\\n                best_count = v\\n                ans_i = i\\n        \\n        return ans_i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527295,
                "title": "c-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& m) {\\n        sort(m.begin(),m.end());\\n        set<int> free;                                           // will store free rooms\\n        for(int i=0;i<n;i++) free.insert(i);\\n        set<pair<long long,int>> used;              // {end time, used room}\\n        vector<int> ans(n,0);\\n        int k = 0;\\n        long long time = 0;\\n        while(k<m.size()){\\n            while(!used.empty() && (*used.begin()).first <= time){                    \\n                free.insert((*used.begin()).second);\\n                used.erase(used.begin());\\n            }\\n            if(free.empty()){\\n                time = (*used.begin()).first;\\n                continue;\\n            }\\n            if(time < m[k][0]){\\n                time = m[k][0];\\n                continue;\\n            }\\n            \\n            int j = *(free.begin());\\n            free.erase(free.begin());\\n            ans[j]++;\\n            long long duration = m[k][1]-m[k][0];\\n            used.insert({time + duration,j});\\n            k++;\\n        }\\n        \\n        \\n        int ind = -1;\\n        int maxi = 0;\\n        for(int i=0;i<n;i++){\\n            if(ans[i]>maxi){\\n                maxi = ans[i];\\n                ind = i;\\n            }\\n        }\\n        return ind;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& m) {\\n        sort(m.begin(),m.end());\\n        set<int> free;                                           // will store free rooms\\n        for(int i=0;i<n;i++) free.insert(i);\\n        set<pair<long long,int>> used;              // {end time, used room}",
                "codeTag": "Java"
            },
            {
                "id": 3868559,
                "title": "java-2-priority-queue-solutions-with-detailed-explanation-and-comments",
                "content": "# Intuition\\nThe question has several conditions which help us to choose the right data-structures. \\n\\n1. As soon as a room becomes available, we line that up in our available rooms to schedule the next meeting. If multiple rooms are available, we sort them in ascending order. This gives us an idea that usage of priority queue will help us line the rooms in that order.\\n2. When none of the rooms are available when processing a meeting, we will have to wait. The meeting which will be over first would be able to give its occupied room back. The delay would be to be (to_be_scheduled_meeting\\'s_start time) + (next available room\\'s time interval). So, it is important that we keep a track of meetings end times. \\nA priority queue sorted by ascending end time would take care of that. But added condition here is that if multiple meeting rooms are available (that is, same end times), we will pick the one with smaller number. So, the sorting logic of this priority queue will be- \\nAmong the options of rooms - choose room where meeting\\'s end time is smaller. If multiple rooms have same end time, choose the one with smaller room index.\\n\\nClass Room:\\nI have used a custom class- Room which has two elements - endTime and room number. As explained above, these are the two things we need to track. Several solutions use an array to keep track of these two fields. However, that choice has two drawbacks-\\na) If your interviewer gives you room numbers in non-integer format but endTime is in different data type, this would no longer be a generic solution.\\nb) The readability is poor and this kind of code would be hard to maintain especially in big production systems. With my class, I can differentiate between two different things - endTime and room number.\\n\\n# Approach\\n1. We initialize the available rooms and start assigning meetings to them.\\n2. After a while, we might have a case where next meetings needs to be scehduled but none of the running meetings are over. So, delay would be there to schedule the next meeting.\\n3. We keep checking if any of the running meetings is over and then, place their rooms into available queue.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    //custom class\\n    public class Room {\\n        int endTime;\\n        //occupied room\\n        int num;\\n\\n        public Room(int endTime, int num) {\\n            this.endTime = endTime;\\n            this.num = num;\\n        }\\n    }\\n\\n    public int mostBooked(int n, int[][] meetings) {\\n         // sort by meeting start times\\n        Arrays.sort(meetings, (a,b) -> (a[0] - b[0]));\\n\\n        //Queue to keep track of room numbers which are available\\n        PriorityQueue<Integer> availableRoom = new PriorityQueue();\\n\\n        //Queue to store Room object for each meeting, sorted by endTimes\\n        //if meeting\\'s endTime is same, sort by smaller room number\\n        PriorityQueue<Room> runningMeeting = new PriorityQueue<Room>(\\n            (a, b) -> a.endTime == b.endTime ? a.num - b.num : a.endTime - b.endTime\\n        );\\n\\n        //array to track most used rooms\\n        int[] count = new int[n];\\n\\n\\n        //final result : room number - we will keep it updating\\n        int res = 0;\\n\\n        //To begin with, all rooms will be available\\n        for (int i=0; i < n; i++) {\\n            availableRoom.offer(i);\\n        }\\n\\n        //processing: Iterate over each meeting interval\\n        for (int[] next: meetings) {\\n            /**check if any room is available before scheduling next meeting. \\nThat is, if next meeting starts after (or during: equal-to sign) current \\nrunning meeting\\'s endtime. Keep updating available room for next meeting**/\\n            while (!runningMeeting.isEmpty() && runningMeeting.peek().endTime <= next[0]) {\\n                availableRoom.offer(runningMeeting.poll().num);\\n            }\\n\\n            /**There will be two cases:\\n            a) Ideal- at least one room available for next meeting- no delay. So, start time will be next[0]\\n            b) Delay- no room is available. So you pick the top (first ending meeting) and add the delay. Initialize \\'latestPossibleStartTime\\' with next[0]. We will see if there is a delay**/\\n            int latestPossibleStartTime = next[0];\\n\\n            /** Now look if there is delay due to non-availability of rooms**/\\n            if (availableRoom.isEmpty()) {\\n                /**then, pick the first ending meeting (or one of the such meetings with smaller room number)**/\\n                Room firstEndingMeeting = runningMeeting.poll();\\n                latestPossibleStartTime = firstEndingMeeting.endTime;\\n\\n                //room number released by firstEndingMeeting\\n                availableRoom.offer(firstEndingMeeting.num);\\n            }\\n\\n            /** Now we have a room available - schedule the next meeting\\n            a) update number of meetings held by this room so far\\n            b) for a delayed meeting, update the new end time before placing it into runningMeeting queue**/\\n            int room = availableRoom.poll();\\n            count[room]++;\\n            int meetingInterval = next[1]-next[0];\\n            runningMeeting.offer(new Room(meetingInterval+latestPossibleStartTime, room));\\n\\n            //update \\'res\\' with max meetings holding room number\\n            if (count[room] > count[res]) {\\n                res = room;\\n                //if same- go for smaller number\\n            } else if (count[room] == count[res]) {\\n                res = Math.min(res, room);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //custom class\\n    public class Room {\\n        int endTime;\\n        //occupied room\\n        int num;\\n\\n        public Room(int endTime, int num) {\\n            this.endTime = endTime;\\n            this.num = num;\\n        }\\n    }\\n\\n    public int mostBooked(int n, int[][] meetings) {\\n         // sort by meeting start times\\n        Arrays.sort(meetings, (a,b) -> (a[0] - b[0]));\\n\\n        //Queue to keep track of room numbers which are available\\n        PriorityQueue<Integer> availableRoom = new PriorityQueue();\\n\\n        //Queue to store Room object for each meeting, sorted by endTimes\\n        //if meeting\\'s endTime is same, sort by smaller room number\\n        PriorityQueue<Room> runningMeeting = new PriorityQueue<Room>(\\n            (a, b) -> a.endTime == b.endTime ? a.num - b.num : a.endTime - b.endTime\\n        );\\n\\n        //array to track most used rooms\\n        int[] count = new int[n];\\n\\n\\n        //final result : room number - we will keep it updating\\n        int res = 0;\\n\\n        //To begin with, all rooms will be available\\n        for (int i=0; i < n; i++) {\\n            availableRoom.offer(i);\\n        }\\n\\n        //processing: Iterate over each meeting interval\\n        for (int[] next: meetings) {\\n            /**check if any room is available before scheduling next meeting. \\nThat is, if next meeting starts after (or during: equal-to sign) current \\nrunning meeting\\'s endtime. Keep updating available room for next meeting**/\\n            while (!runningMeeting.isEmpty() && runningMeeting.peek().endTime <= next[0]) {\\n                availableRoom.offer(runningMeeting.poll().num);\\n            }\\n\\n            /**There will be two cases:\\n            a) Ideal- at least one room available for next meeting- no delay. So, start time will be next[0]\\n            b) Delay- no room is available. So you pick the top (first ending meeting) and add the delay. Initialize \\'latestPossibleStartTime\\' with next[0]. We will see if there is a delay**/\\n            int latestPossibleStartTime = next[0];\\n\\n            /** Now look if there is delay due to non-availability of rooms**/\\n            if (availableRoom.isEmpty()) {\\n                /**then, pick the first ending meeting (or one of the such meetings with smaller room number)**/\\n                Room firstEndingMeeting = runningMeeting.poll();\\n                latestPossibleStartTime = firstEndingMeeting.endTime;\\n\\n                //room number released by firstEndingMeeting\\n                availableRoom.offer(firstEndingMeeting.num);\\n            }\\n\\n            /** Now we have a room available - schedule the next meeting\\n            a) update number of meetings held by this room so far\\n            b) for a delayed meeting, update the new end time before placing it into runningMeeting queue**/\\n            int room = availableRoom.poll();\\n            count[room]++;\\n            int meetingInterval = next[1]-next[0];\\n            runningMeeting.offer(new Room(meetingInterval+latestPossibleStartTime, room));\\n\\n            //update \\'res\\' with max meetings holding room number\\n            if (count[room] > count[res]) {\\n                res = room;\\n                //if same- go for smaller number\\n            } else if (count[room] == count[res]) {\\n                res = Math.min(res, room);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989009,
                "title": "three-flavors-of-the-same-algorithm-2-heaps-just-changing-the-object-type-to-compare-performance",
                "content": "# Intuition\\nWork with 2 heaps:\\n- Heap of the busy rooms, ordered by the ones that will end first*\\n- Heap of the available rooms, sorted by the smaller idex rooms first.\\n\\n1. At every interation if there are no available rooms jump in time and end busy room that ends first*\\n2. At every interation check all the rooms that will have their meetings concluded (as rooms with smaller index may appear)\\n3. Add the meeting with the older start time available to the room with smaller index. Set the end time considering the time when the meeting really started**.\\n \\nImportant:\\n-  *remember that more than one room can free at the same time, so dequeue the room with smaller index!\\n- **remember that the new end may be overflow integer values (use long).\\n\\nIn this code the Pair object had a better performance in many tests (but not all!).\\n\\n# Approach\\n2 heaps\\n\\n# Complexity\\n## Time complexity:\\n- Heap: $$O(meetings.length*log(n)+meetings.length*log(meetings.length))$$\\n- Array Scan: $$O(meetings.length*n+meetings.length*log(meetings.length))$$\\n\\n## Space complexity:\\n$$O(n+meetings.length)$$\\n\\n# Code Using Index Reference on the Heap\\n![image.png](https://assets.leetcode.com/users/images/1fe220ca-f1b6-4aa0-b168-610b7ad178c9_1672697919.5588703.png)\\n![image.png](https://assets.leetcode.com/users/images/56d6d2f9-59f9-4bcc-8910-f6e9a4c268c5_1672698319.2827795.png)\\n\\n```java\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings,(a,b)->a[0]-b[0]);\\n        // some ending times may exceed int limits\\n        long[][] room= new long[n][3]; // 0: meeting held, 1: when it ends, 2: counter\\n        // a and b in this contexts are the room index\\n        PriorityQueue<Integer> roomsBusy = new PriorityQueue<>((a,b)->room[a][1]==room[b][1]?a-b:(int)(room[a][1]-room[b][1]));\\n        PriorityQueue<Integer> roomsAvailable = new PriorityQueue<>((a,b)->a-b);\\n        for(int i=0;i<n&&i<meetings.length;i++) roomsAvailable.add(i);\\n        for(int i=0;i<meetings.length;i++) {\\n            int meetingStart=meetings[i][0];\\n            int meetingEnd=meetings[i][1];\\n            // Empty rooms that end before (or at the moment) the next meeting starts\\n            // room[roomsBusy.peek()][1] is the next room to be free\\n            // meetings[i] is the next meeting to start\\n            // if roomsAvailable is empty and we have 2 rooms ending at the same time,\\n            // dequeue the smaller first\\n            while(!roomsBusy.isEmpty()&&(roomsAvailable.isEmpty()||room[roomsBusy.peek()][1]<=meetingStart)) {\\n                roomsAvailable.add(roomsBusy.remove());\\n            }\\n            int nextRoomIndex=roomsAvailable.remove();\\n            long[] nextRoom=room[nextRoomIndex];\\n            nextRoom[0]=i;\\n            nextRoom[1]=Math.max(meetingEnd,meetingEnd-meetingStart+nextRoom[1]);\\n            nextRoom[2]++;\\n            // Occupy the meeting room\\n            roomsBusy.add(nextRoomIndex);\\n        }\\n        int max=0;\\n        for(int i=1;i<room.length;i++) if(room[i][2]>room[max][2]) max=i;\\n        return max;\\n    }\\n}\\n```\\n\\n## Code With Array\\n![image.png](https://assets.leetcode.com/users/images/2f916d1d-957b-4d5b-93a9-db7b82579c97_1672698168.456079.png)\\n![image.png](https://assets.leetcode.com/users/images/fbed6bef-58cb-40ab-b6bf-77887cc7f3df_1672698261.537175.png)\\n\\n```java\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings,(a,b)->a[0]-b[0]);\\n        int[]  count=new int[n];\\n        PriorityQueue<long[]> roomsBusy = new PriorityQueue<long[]>((a,b)->{\\n            long t1=a[1], t2=b[1];\\n            return t1==t2?(int)(a[0]-b[0]):(int)(t1-t2);\\n        });\\n        PriorityQueue<long[]> roomsAvailable = new PriorityQueue<>((a,b)->(int)(a[0]-b[0]));\\n        for(int i=0;i<n&&i<meetings.length;i++) roomsAvailable.add(new long[] {i,0});\\n        for(int i=0;i<meetings.length;i++) {\\n            int meetingStart=meetings[i][0];\\n            int meetingEnd=meetings[i][1];\\n            while(!roomsBusy.isEmpty()&&(roomsAvailable.isEmpty()||roomsBusy.peek()[1]<=meetingStart)) {\\n                roomsAvailable.add(roomsBusy.remove());\\n            }\\n            long[] nextRoom = roomsAvailable.remove();\\n            count[(int)nextRoom[0]]++;\\n            nextRoom[1]=Math.max(meetingEnd,meetingEnd-meetingStart+nextRoom[1]);\\n            roomsBusy.add(nextRoom);\\n        }\\n        int max=0;\\n        for(int i=1;i<count.length;i++) if(count[i]>count[max]) max=i;\\n        return max;\\n    }\\n}\\n```\\n\\n## Code With Pair Object\\n![image.png](https://assets.leetcode.com/users/images/37812984-59f3-422f-a982-ebc66d887988_1672698444.3056402.png)\\n![image.png](https://assets.leetcode.com/users/images/af4ad341-e929-48a1-a9f0-26eb5740ec81_1672698468.1841896.png)\\n\\n\\n```java\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings,(a,b)->a[0]-b[0]);\\n        int[]  count=new int[n];\\n        PriorityQueue<Pair> roomsBusy = new PriorityQueue<>((a,b)->a.end==b.end?a.index-b.index:(int)(a.end-b.end));\\n        PriorityQueue<Pair> roomsAvailable = new PriorityQueue<>((a,b)->a.index-b.index);\\n        for(int i=0;i<n&&i<meetings.length;i++) roomsAvailable.add(new Pair(i,0));\\n        for(int i=0;i<meetings.length;i++) {\\n            int meetingStart=meetings[i][0];\\n            int meetingEnd=meetings[i][1];\\n            while(!roomsBusy.isEmpty()&&(roomsAvailable.isEmpty()||roomsBusy.peek().end<=meetingStart)) {\\n                roomsAvailable.add(roomsBusy.remove());\\n            }\\n            Pair nextRoom = roomsAvailable.remove();\\n            count[nextRoom.index]++;\\n            nextRoom.end=Math.max(meetingEnd,meetingEnd-meetingStart+nextRoom.end);\\n            roomsBusy.add(nextRoom);\\n        }\\n        int max=0;\\n        for(int i=1;i<count.length;i++) if(count[i]>count[max]) max=i;\\n        return max;\\n    }\\n    class Pair {\\n        int index;\\n        long end;\\n        public Pair(int index, long end) {\\n            this.index=index;\\n            this.end=end;\\n        }\\n    }\\n}\\n```\\n\\n## Code Without Heap\\n![image.png](https://assets.leetcode.com/users/images/971384c6-95c2-4763-997b-8755d30f4942_1672705071.063569.png)\\n\\n```java\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings,(a,b)->a[0]-b[0]);\\n        int[]  count=new int[n];\\n        long[] room=new long[n];\\n        for(int i=0;i<meetings.length;i++) {\\n            int meetingStart=meetings[i][0];\\n            int meetingEnd=meetings[i][1];\\n            int nextRoom=-1;\\n            long sooner=Long.MAX_VALUE;\\n            for(int j=0;j<room.length;j++) {\\n                if(room[j]<=meetingStart) {\\n                    nextRoom=j;\\n                    break;\\n                }\\n                if(room[j]<sooner) {\\n                    nextRoom=j;\\n                    sooner=room[j];\\n                }\\n            }\\n            count[nextRoom]++;\\n            room[nextRoom]=Math.max(meetingEnd,meetingEnd-meetingStart+room[nextRoom]);\\n        }\\n        int max=0;\\n        for(int i=1;i<count.length;i++) if(count[i]>count[max]) max=i;\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings,(a,b)->a[0]-b[0]);\\n        // some ending times may exceed int limits\\n        long[][] room= new long[n][3]; // 0: meeting held, 1: when it ends, 2: counter\\n        // a and b in this contexts are the room index\\n        PriorityQueue<Integer> roomsBusy = new PriorityQueue<>((a,b)->room[a][1]==room[b][1]?a-b:(int)(room[a][1]-room[b][1]));\\n        PriorityQueue<Integer> roomsAvailable = new PriorityQueue<>((a,b)->a-b);\\n        for(int i=0;i<n&&i<meetings.length;i++) roomsAvailable.add(i);\\n        for(int i=0;i<meetings.length;i++) {\\n            int meetingStart=meetings[i][0];\\n            int meetingEnd=meetings[i][1];\\n            // Empty rooms that end before (or at the moment) the next meeting starts\\n            // room[roomsBusy.peek()][1] is the next room to be free\\n            // meetings[i] is the next meeting to start\\n            // if roomsAvailable is empty and we have 2 rooms ending at the same time,\\n            // dequeue the smaller first\\n            while(!roomsBusy.isEmpty()&&(roomsAvailable.isEmpty()||room[roomsBusy.peek()][1]<=meetingStart)) {\\n                roomsAvailable.add(roomsBusy.remove());\\n            }\\n            int nextRoomIndex=roomsAvailable.remove();\\n            long[] nextRoom=room[nextRoomIndex];\\n            nextRoom[0]=i;\\n            nextRoom[1]=Math.max(meetingEnd,meetingEnd-meetingStart+nextRoom[1]);\\n            nextRoom[2]++;\\n            // Occupy the meeting room\\n            roomsBusy.add(nextRoomIndex);\\n        }\\n        int max=0;\\n        for(int i=1;i<room.length;i++) if(room[i][2]>room[max][2]) max=i;\\n        return max;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings,(a,b)->a[0]-b[0]);\\n        int[]  count=new int[n];\\n        PriorityQueue<long[]> roomsBusy = new PriorityQueue<long[]>((a,b)->{\\n            long t1=a[1], t2=b[1];\\n            return t1==t2?(int)(a[0]-b[0]):(int)(t1-t2);\\n        });\\n        PriorityQueue<long[]> roomsAvailable = new PriorityQueue<>((a,b)->(int)(a[0]-b[0]));\\n        for(int i=0;i<n&&i<meetings.length;i++) roomsAvailable.add(new long[] {i,0});\\n        for(int i=0;i<meetings.length;i++) {\\n            int meetingStart=meetings[i][0];\\n            int meetingEnd=meetings[i][1];\\n            while(!roomsBusy.isEmpty()&&(roomsAvailable.isEmpty()||roomsBusy.peek()[1]<=meetingStart)) {\\n                roomsAvailable.add(roomsBusy.remove());\\n            }\\n            long[] nextRoom = roomsAvailable.remove();\\n            count[(int)nextRoom[0]]++;\\n            nextRoom[1]=Math.max(meetingEnd,meetingEnd-meetingStart+nextRoom[1]);\\n            roomsBusy.add(nextRoom);\\n        }\\n        int max=0;\\n        for(int i=1;i<count.length;i++) if(count[i]>count[max]) max=i;\\n        return max;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings,(a,b)->a[0]-b[0]);\\n        int[]  count=new int[n];\\n        PriorityQueue<Pair> roomsBusy = new PriorityQueue<>((a,b)->a.end==b.end?a.index-b.index:(int)(a.end-b.end));\\n        PriorityQueue<Pair> roomsAvailable = new PriorityQueue<>((a,b)->a.index-b.index);\\n        for(int i=0;i<n&&i<meetings.length;i++) roomsAvailable.add(new Pair(i,0));\\n        for(int i=0;i<meetings.length;i++) {\\n            int meetingStart=meetings[i][0];\\n            int meetingEnd=meetings[i][1];\\n            while(!roomsBusy.isEmpty()&&(roomsAvailable.isEmpty()||roomsBusy.peek().end<=meetingStart)) {\\n                roomsAvailable.add(roomsBusy.remove());\\n            }\\n            Pair nextRoom = roomsAvailable.remove();\\n            count[nextRoom.index]++;\\n            nextRoom.end=Math.max(meetingEnd,meetingEnd-meetingStart+nextRoom.end);\\n            roomsBusy.add(nextRoom);\\n        }\\n        int max=0;\\n        for(int i=1;i<count.length;i++) if(count[i]>count[max]) max=i;\\n        return max;\\n    }\\n    class Pair {\\n        int index;\\n        long end;\\n        public Pair(int index, long end) {\\n            this.index=index;\\n            this.end=end;\\n        }\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings,(a,b)->a[0]-b[0]);\\n        int[]  count=new int[n];\\n        long[] room=new long[n];\\n        for(int i=0;i<meetings.length;i++) {\\n            int meetingStart=meetings[i][0];\\n            int meetingEnd=meetings[i][1];\\n            int nextRoom=-1;\\n            long sooner=Long.MAX_VALUE;\\n            for(int j=0;j<room.length;j++) {\\n                if(room[j]<=meetingStart) {\\n                    nextRoom=j;\\n                    break;\\n                }\\n                if(room[j]<sooner) {\\n                    nextRoom=j;\\n                    sooner=room[j];\\n                }\\n            }\\n            count[nextRoom]++;\\n            room[nextRoom]=Math.max(meetingEnd,meetingEnd-meetingStart+room[nextRoom]);\\n        }\\n        int max=0;\\n        for(int i=1;i<count.length;i++) if(count[i]>count[max]) max=i;\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529118,
                "title": "javascript-two-heaps",
                "content": "**Solution: Two Heaps**\\n\\nUse two heaps - `available` and `occupied`, to keep track of rooms (as `[room index, next available time]`) that are available. \\n  `available`: Rooms that are available, sorted by room index.\\n  `occupied`: Rooms that are occupied, sorted by next available time.\\n\\nSort meetings by start time.\\nFor each meeting, \\n  1. Move rooms that have freed up from occupied to available.\\n  2. Assign a room to the meeting. Count the number of times each room is used.\\n  * If there are no available rooms, take out the earliest room from occupied and delay the start time of the meeting.\\n      * If there are multiple occupied rooms with the same available time, move them all.\\n  * If there is an available room, use an available room with the smallest room index.\\n  * When adding a room back to the heap, we need to account for the delayed time if there was originally no available room.\\n\\n`n = number of rooms`, `m = number of meetings`\\nTime Complexity: `O(m log(m) + m log(n))` 505ms\\nSpace Complexity: `O(n)` 75.8MB\\n```\\nvar mostBooked = function(n, meetings) {\\n  let available = new PriorityQueue((a, b) => a[0] - b[0]); // [room index, next available time]\\n  let occupied = new PriorityQueue((a, b) => a[1] - b[1]);\\n  for (let i = 0; i < n; i++) {\\n    available.add([i, 0]);\\n  }\\n\\n  meetings.sort((a, b) => a[0] - b[0]);\\n  let count = Array(n).fill(0);\\n  for (let [start, end] of meetings) {\\n    let duration = end - start;\\n    while (!occupied.isEmpty() && occupied.top()[1] <= start) {\\n      available.add(occupied.remove());\\n    }\\n    \\n    if (available.isEmpty()) {\\n      let [roomIndex, availableTime] = occupied.remove();\\n      available.add([roomIndex, availableTime]);\\n      while (!occupied.isEmpty() && occupied.top()[1] === availableTime) {\\n        available.add(occupied.remove());\\n      }\\n    } \\n    let [roomIndex, availableTime] = available.remove();\\n    count[roomIndex]++;\\n    occupied.add([roomIndex, Math.max(start, availableTime) + duration]);\\n  }\\n  \\n  let ans = 0;\\n  for (let i = 1; i < n; i++) {\\n    if (count[i] > count[ans]) ans = i;\\n  }\\n  return ans;\\n};\\n\\nclass PriorityQueue {\\n  constructor(comparator = ((a, b) => a - b)) {\\n    this.values = [];\\n    this.comparator = comparator;\\n    this.size = 0;\\n  }\\n  add(val) {\\n    this.size++;\\n    this.values.push(val);\\n    let idx = this.size - 1, parentIdx = Math.floor((idx - 1) / 2);\\n    while (parentIdx >= 0 && this.comparator(this.values[parentIdx], this.values[idx]) > 0) {\\n      [this.values[parentIdx], this.values[idx]] = [this.values[idx], this.values[parentIdx]];\\n      idx = parentIdx;\\n      parentIdx = Math.floor((idx - 1) / 2);\\n    }\\n  }\\n  remove() {\\n    if (this.size === 0) return -1;\\n    this.size--;\\n    if (this.size === 0) return this.values.pop();\\n    let removedVal = this.values[0];\\n    this.values[0] = this.values.pop();\\n    let idx = 0;\\n    while (idx < this.size && idx < Math.floor(this.size / 2)) {\\n      let leftIdx = idx * 2 + 1, rightIdx = idx * 2 + 2;\\n      if (rightIdx === this.size) {\\n        if (this.comparator(this.values[leftIdx], this.values[idx]) > 0) break;\\n        [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n        idx = leftIdx;\\n      } else if (this.comparator(this.values[leftIdx], this.values[idx]) < 0 || this.comparator(this.values[rightIdx], this.values[idx]) < 0) {\\n        if (this.comparator(this.values[leftIdx], this.values[rightIdx]) <= 0) {\\n          [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n          idx = leftIdx;\\n        } else {\\n          [this.values[rightIdx], this.values[idx]] = [this.values[idx], this.values[rightIdx]];\\n          idx = rightIdx;\\n        }\\n      } else {\\n        break;\\n      }\\n    }\\n    return removedVal;\\n  }\\n  top() {\\n    return this.values[0];\\n  }\\n  isEmpty() {\\n    return this.size === 0;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mostBooked = function(n, meetings) {\\n  let available = new PriorityQueue((a, b) => a[0] - b[0]); // [room index, next available time]\\n  let occupied = new PriorityQueue((a, b) => a[1] - b[1]);\\n  for (let i = 0; i < n; i++) {\\n    available.add([i, 0]);\\n  }\\n\\n  meetings.sort((a, b) => a[0] - b[0]);\\n  let count = Array(n).fill(0);\\n  for (let [start, end] of meetings) {\\n    let duration = end - start;\\n    while (!occupied.isEmpty() && occupied.top()[1] <= start) {\\n      available.add(occupied.remove());\\n    }\\n    \\n    if (available.isEmpty()) {\\n      let [roomIndex, availableTime] = occupied.remove();\\n      available.add([roomIndex, availableTime]);\\n      while (!occupied.isEmpty() && occupied.top()[1] === availableTime) {\\n        available.add(occupied.remove());\\n      }\\n    } \\n    let [roomIndex, availableTime] = available.remove();\\n    count[roomIndex]++;\\n    occupied.add([roomIndex, Math.max(start, availableTime) + duration]);\\n  }\\n  \\n  let ans = 0;\\n  for (let i = 1; i < n; i++) {\\n    if (count[i] > count[ans]) ans = i;\\n  }\\n  return ans;\\n};\\n\\nclass PriorityQueue {\\n  constructor(comparator = ((a, b) => a - b)) {\\n    this.values = [];\\n    this.comparator = comparator;\\n    this.size = 0;\\n  }\\n  add(val) {\\n    this.size++;\\n    this.values.push(val);\\n    let idx = this.size - 1, parentIdx = Math.floor((idx - 1) / 2);\\n    while (parentIdx >= 0 && this.comparator(this.values[parentIdx], this.values[idx]) > 0) {\\n      [this.values[parentIdx], this.values[idx]] = [this.values[idx], this.values[parentIdx]];\\n      idx = parentIdx;\\n      parentIdx = Math.floor((idx - 1) / 2);\\n    }\\n  }\\n  remove() {\\n    if (this.size === 0) return -1;\\n    this.size--;\\n    if (this.size === 0) return this.values.pop();\\n    let removedVal = this.values[0];\\n    this.values[0] = this.values.pop();\\n    let idx = 0;\\n    while (idx < this.size && idx < Math.floor(this.size / 2)) {\\n      let leftIdx = idx * 2 + 1, rightIdx = idx * 2 + 2;\\n      if (rightIdx === this.size) {\\n        if (this.comparator(this.values[leftIdx], this.values[idx]) > 0) break;\\n        [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n        idx = leftIdx;\\n      } else if (this.comparator(this.values[leftIdx], this.values[idx]) < 0 || this.comparator(this.values[rightIdx], this.values[idx]) < 0) {\\n        if (this.comparator(this.values[leftIdx], this.values[rightIdx]) <= 0) {\\n          [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n          idx = leftIdx;\\n        } else {\\n          [this.values[rightIdx], this.values[idx]] = [this.values[idx], this.values[rightIdx]];\\n          idx = rightIdx;\\n        }\\n      } else {\\n        break;\\n      }\\n    }\\n    return removedVal;\\n  }\\n  top() {\\n    return this.values[0];\\n  }\\n  isEmpty() {\\n    return this.size === 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527885,
                "title": "c-without-priority-queues-easy-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& m) {\\n        sort(m.begin(),m.end());\\n        vector<long long> v(n,0);                              // to store the no. of meeting in a particular room\\n        long long last=0;\\n        vector<long long> meet(n,0);                      // to store the end time of any room\\n        for(auto x:m){\\n            long long int a=x[0];\\n            long long int b=x[1];\\n\\n            long long int y=100000000000000000;\\n            long long int j=n;\\n            long long int k;\\n            for(int i=0;i<n;i++){\\n               \\n                if(meet[i]<=a && j>i){                                // check if start time of meet is greater than ending time of that room\\n                    j=i;\\n                    break;\\n                }\\n                if(meet[i]<y){                                     //if no room had end time less than start time of meet check the room which will be free first\\n                    y=meet[i];\\n                    k=i;\\n                }\\n            }\\n         \\n            if(j==n){\\n                j=k;\\n            }\\n            v[j]++;                                                                 //update the meet count for that room\\n            if(meet[j]<a){                                                        \\n                meet[j]=b;                                                           //update end time\\n            }\\n            else\\n            meet[j]+=b-a;\\n            \\n            \\n        }\\n        long long int j;\\n        long long int y=INT_MIN;\\n        for(int i=0;i<n;i++){                                         //check which room has max meets\\n            if(v[i]>y){\\n                y=v[i];\\n                j=i;                       \\n            }\\n        }\\n        return j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& m) {\\n        sort(m.begin(),m.end());\\n        vector<long long> v(n,0);                              // to store the no. of meeting in a particular room\\n        long long last=0;\\n        vector<long long> meet(n,0);                      // to store the end time of any room\\n        for(auto x:m){\\n            long long int a=x[0];\\n            long long int b=x[1];\\n\\n            long long int y=100000000000000000;\\n            long long int j=n;\\n            long long int k;\\n            for(int i=0;i<n;i++){\\n               \\n                if(meet[i]<=a && j>i){                                // check if start time of meet is greater than ending time of that room\\n                    j=i;\\n                    break;\\n                }\\n                if(meet[i]<y){                                     //if no room had end time less than start time of meet check the room which will be free first\\n                    y=meet[i];\\n                    k=i;\\n                }\\n            }\\n         \\n            if(j==n){\\n                j=k;\\n            }\\n            v[j]++;                                                                 //update the meet count for that room\\n            if(meet[j]<a){                                                        \\n                meet[j]=b;                                                           //update end time\\n            }\\n            else\\n            meet[j]+=b-a;\\n            \\n            \\n        }\\n        long long int j;\\n        long long int y=INT_MIN;\\n        for(int i=0;i<n;i++){                                         //check which room has max meets\\n            if(v[i]>y){\\n                y=v[i];\\n                j=i;                       \\n            }\\n        }\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527506,
                "title": "python-2-priority-queue-solution-with-detailed-explanation-and-in-line-comments",
                "content": "## General idea\\nUse two priority queues to record available rooms and meetings so we are able to track the whole process efficiently with `O(Nlog(N))` time complexity.\\n\\n## Detailed Explanation\\n**room_pq**:  Priority Queue to record available meeting rooms, needs to be initialized with all the `range(n)` rooms\\n**meeting_pq**: Priority Queue to track on-going meetings\\n**room_usage_count**: List to record number of time we use each room\\n\\nSort **meetings** list.\\nFor every **meeting**:\\n1. Remove all completed meetings in **meeting_pq**  before the start of next meeting. \\n2. Check if there is any available meeting room in **room_pq**\\na.  If so, heappop the room from **room_pq**\\nb. Otherwise, heappop the next completing meeting from **meeting_pq**, use the room for the poped meeting and postpone the next meeting\\'s start time to the end time of poped meeting.\\n3. Use the room and start-time for the next meeting, push `(start, room)` to **meeting_pq**.\\n\\n## Code\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n\\n        # Modify (start, end) tuple into (start, duration) for simplicity during calculation\\n        meetings = [[meet[0], meet[1]-meet[0]] for meet in meetings]\\n\\n\\n        # Create and initialize priority queues and the list to count room usage\\n        room_pq, meeting_pq = [], []\\n        room_usage_count = [0] * n\\n        for i in range(n):\\n            heappush(room_pq, i)\\n        \\n        # loop through all meetings\\n        for start, duration in meetings:\\n            \\n            # Make sure we are not calling heappop if meeting_pq is empty\\n            while meeting_pq:\\n\\n                # Retrieve the earliest completing on-going meeting\\n                end_time, room = heappop(meeting_pq)\\n\\n                # If the meeting will not be completed before the start of next meeting, \\n                # exit the loop and push the on-going meeting back.\\n                if end_time > start:\\n                    heappush(meeting_pq, (end_time, room))\\n                    break\\n\\n                # Otherwise, the on-going meeting will be completed before the start of next meeting,\\n                # push back the room to all available rooms\\n                heappush(room_pq, room)\\n            \\n            # Check if there is any available room\\n            if room_pq:\\n                room = heappop(room_pq)\\n            else:\\n                # If not, use the next available room and postpone the next meeting\\'s start time\\n                start, room = heappop(meeting_pq)\\n\\n            # Start the meeting\\n            heappush(meeting_pq, (start + duration, room))\\n            room_usage_count[room] += 1\\n        \\n        return room_usage_count.index(max(room_usage_count))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n\\n        # Modify (start, end) tuple into (start, duration) for simplicity during calculation\\n        meetings = [[meet[0], meet[1]-meet[0]] for meet in meetings]\\n\\n\\n        # Create and initialize priority queues and the list to count room usage\\n        room_pq, meeting_pq = [], []\\n        room_usage_count = [0] * n\\n        for i in range(n):\\n            heappush(room_pq, i)\\n        \\n        # loop through all meetings\\n        for start, duration in meetings:\\n            \\n            # Make sure we are not calling heappop if meeting_pq is empty\\n            while meeting_pq:\\n\\n                # Retrieve the earliest completing on-going meeting\\n                end_time, room = heappop(meeting_pq)\\n\\n                # If the meeting will not be completed before the start of next meeting, \\n                # exit the loop and push the on-going meeting back.\\n                if end_time > start:\\n                    heappush(meeting_pq, (end_time, room))\\n                    break\\n\\n                # Otherwise, the on-going meeting will be completed before the start of next meeting,\\n                # push back the room to all available rooms\\n                heappush(room_pq, room)\\n            \\n            # Check if there is any available room\\n            if room_pq:\\n                room = heappop(room_pq)\\n            else:\\n                # If not, use the next available room and postpone the next meeting\\'s start time\\n                start, room = heappop(meeting_pq)\\n\\n            # Start the meeting\\n            heappush(meeting_pq, (start + duration, room))\\n            room_usage_count[room] += 1\\n        \\n        return room_usage_count.index(max(room_usage_count))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939714,
                "title": "python-3-2-heaps-o-m-log-max-m-n-n-o-m-n",
                "content": "# Intuition\\nMaintain rooms sorted by their time of being available again.\\nMaintain available rooms sorted by their nubmer to pick the smallest one.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(m\\\\log (\\\\max(m, n)) + n)$\\n\\n- Space complexity: $O(m + n)$\\n\\n# Code\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        available_rooms = list(range(n))\\n        heapq.heapify(available_rooms)\\n        occupied_rooms = []\\n        cnt = defaultdict(int)\\n        for start, end in meetings:\\n            while len(occupied_rooms) > 0 and occupied_rooms[0][0] <= start:\\n                heapq.heappush(available_rooms, heapq.heappop(occupied_rooms)[1])\\n            if len(available_rooms) == 0:\\n                available_time, room = heapq.heappop(occupied_rooms)\\n            else:\\n                room = heapq.heappop(available_rooms)\\n                available_time = start\\n            cnt[room] += 1\\n            heapq.heappush(occupied_rooms, (max(start, available_time) + (end-start), room))\\n        max_meetings = max(cnt.values())\\n        return min(filter(lambda room: cnt[room] == max_meetings, range(n)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        available_rooms = list(range(n))\\n        heapq.heapify(available_rooms)\\n        occupied_rooms = []\\n        cnt = defaultdict(int)\\n        for start, end in meetings:\\n            while len(occupied_rooms) > 0 and occupied_rooms[0][0] <= start:\\n                heapq.heappush(available_rooms, heapq.heappop(occupied_rooms)[1])\\n            if len(available_rooms) == 0:\\n                available_time, room = heapq.heappop(occupied_rooms)\\n            else:\\n                room = heapq.heappop(available_rooms)\\n                available_time = start\\n            cnt[room] += 1\\n            heapq.heappush(occupied_rooms, (max(start, available_time) + (end-start), room))\\n        max_meetings = max(cnt.values())\\n        return min(filter(lambda room: cnt[room] == max_meetings, range(n)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525137,
                "title": "simple-c-solution-using-2-priority-queues-free-and-occupied",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        priority_queue<pair<long, long>, vector<pair<long, long>>, greater<pair<long, long>>> occupied;\\n        priority_queue<long, vector<long>, greater<long>> free;\\n        for(int i = 0 ; i < n; i++) {\\n            free.push(i);\\n        }\\n        vector<int> counter(n);\\n        sort(meetings.begin(), meetings.end());\\n        for(auto meet : meetings) {\\n            int index = 0;\\n            while(!occupied.empty() && occupied.top().first <= meet[0]) {\\n                free.push(occupied.top().second);\\n                occupied.pop();\\n            }\\n            if(!free.empty()) {\\n                index = free.top();\\n                occupied.push({meet[1], free.top()});\\n                free.pop();\\n            } else {\\n                auto curr = occupied.top();\\n                index = curr.second;\\n                curr.first = curr.first + (meet[1]- meet[0]);\\n                occupied.pop();\\n                occupied.push(curr);\\n            }\\n            counter[index]++;\\n        }\\n        int ans = 0, maxValue = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(maxValue < counter[i]) {\\n                maxValue = counter[i];\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        priority_queue<pair<long, long>, vector<pair<long, long>>, greater<pair<long, long>>> occupied;\\n        priority_queue<long, vector<long>, greater<long>> free;\\n        for(int i = 0 ; i < n; i++) {\\n            free.push(i);\\n        }\\n        vector<int> counter(n);\\n        sort(meetings.begin(), meetings.end());\\n        for(auto meet : meetings) {\\n            int index = 0;\\n            while(!occupied.empty() && occupied.top().first <= meet[0]) {\\n                free.push(occupied.top().second);\\n                occupied.pop();\\n            }\\n            if(!free.empty()) {\\n                index = free.top();\\n                occupied.push({meet[1], free.top()});\\n                free.pop();\\n            } else {\\n                auto curr = occupied.top();\\n                index = curr.second;\\n                curr.first = curr.first + (meet[1]- meet[0]);\\n                occupied.pop();\\n                occupied.push(curr);\\n            }\\n            counter[index]++;\\n        }\\n        int ans = 0, maxValue = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(maxValue < counter[i]) {\\n                maxValue = counter[i];\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317649,
                "title": "c-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    \\n  public int MostBooked(int n, int[][] meetings) {\\n      // Counter for number of meetings held in room\\n        int[] rooms = new int[n];\\n        \\n        // List(start, end, room number)\\n        PriorityQueue<List<long>, long> occupiedRooms = new PriorityQueue<List<long>, long>(Comparer<long>.Create((x, y) => x.CompareTo(y)));\\n        \\n        // 1. Each meeting will take place in the free room with the lowest number.\\n        PriorityQueue<long, long> freeRooms = new PriorityQueue<long, long>();\\n        for (int i = 0; i < n; i++) {\\n            freeRooms.Enqueue(i, i);\\n        }\\n        \\n        // 3. Meetings that have an earlier original start time should be given the room\\n        Array.Sort(meetings, (x, y) => x[0].CompareTo(y[0]));\\n        long currentTime = 0;\\n        for (int i = 0; i < meetings.Length; i++) {\\n            int[] meeting = meetings[i];\\n            // Update time to meeting time if meeting time is later\\n            currentTime = Math.Max(meeting[0], currentTime);\\n            \\n            // If no meeting rooms left, go to time where earliest room will be cleared\\n            if (freeRooms.Count == 0) {\\n                long earliestFreeTime = occupiedRooms.Peek()[1];\\n                currentTime = Math.Max(earliestFreeTime, currentTime);\\n            }            \\n            \\n            // Clear all rooms occuring at and before this time\\n            while (occupiedRooms.Count > 0 && occupiedRooms.Peek()[1] <= currentTime) {\\n                long freedRoom = occupiedRooms.Dequeue()[2];\\n                freeRooms.Enqueue(freedRoom, freedRoom);\\n            }\\n            \\n            // Occupy a new room, \\n            // 2. Delayed meeting should have same duration\\n            long nextRoom = freeRooms.Dequeue();\\n            rooms[nextRoom] += 1;\\n            occupiedRooms.Enqueue(new List<long>{ currentTime, currentTime + (meeting[1] - meeting[0]), nextRoom }, currentTime + (meeting[1] - meeting[0]));\\n        }\\n        \\n        // Get smallest room with largest meetings held\\n        int max = 0, ansRoom = 0;\\n        for (int i = n-1; i >= 0; i--) {\\n            if (rooms[i] >= max) {\\n                max = rooms[i];\\n                ansRoom = i;\\n            }\\n        }\\n        return ansRoom;   \\n}\\n\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    \\n  public int MostBooked(int n, int[][] meetings) {\\n      // Counter for number of meetings held in room\\n        int[] rooms = new int[n];\\n        \\n        // List(start, end, room number)\\n        PriorityQueue<List<long>, long> occupiedRooms = new PriorityQueue<List<long>, long>(Comparer<long>.Create((x, y) => x.CompareTo(y)));\\n        \\n        // 1. Each meeting will take place in the free room with the lowest number.\\n        PriorityQueue<long, long> freeRooms = new PriorityQueue<long, long>();\\n        for (int i = 0; i < n; i++) {\\n            freeRooms.Enqueue(i, i);\\n        }\\n        \\n        // 3. Meetings that have an earlier original start time should be given the room\\n        Array.Sort(meetings, (x, y) => x[0].CompareTo(y[0]));\\n        long currentTime = 0;\\n        for (int i = 0; i < meetings.Length; i++) {\\n            int[] meeting = meetings[i];\\n            // Update time to meeting time if meeting time is later\\n            currentTime = Math.Max(meeting[0], currentTime);\\n            \\n            // If no meeting rooms left, go to time where earliest room will be cleared\\n            if (freeRooms.Count == 0) {\\n                long earliestFreeTime = occupiedRooms.Peek()[1];\\n                currentTime = Math.Max(earliestFreeTime, currentTime);\\n            }            \\n            \\n            // Clear all rooms occuring at and before this time\\n            while (occupiedRooms.Count > 0 && occupiedRooms.Peek()[1] <= currentTime) {\\n                long freedRoom = occupiedRooms.Dequeue()[2];\\n                freeRooms.Enqueue(freedRoom, freedRoom);\\n            }\\n            \\n            // Occupy a new room, \\n            // 2. Delayed meeting should have same duration\\n            long nextRoom = freeRooms.Dequeue();\\n            rooms[nextRoom] += 1;\\n            occupiedRooms.Enqueue(new List<long>{ currentTime, currentTime + (meeting[1] - meeting[0]), nextRoom }, currentTime + (meeting[1] - meeting[0]));\\n        }\\n        \\n        // Get smallest room with largest meetings held\\n        int max = 0, ansRoom = 0;\\n        for (int i = n-1; i >= 0; i--) {\\n            if (rooms[i] >= max) {\\n                max = rooms[i];\\n                ansRoom = i;\\n            }\\n        }\\n        return ansRoom;   \\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954369,
                "title": "python-two-minheaps-o-m-log-n-beats-97",
                "content": "# Intuition\\nHere we will use two minHeaps.  One `free_rooms_heap` to store indices of free rooms available and the second `meeting_ends_heap` to store meeting ending time and its `room_id`. While iterating over meetings we free out all room with meeting ending time smaller then current meeting start time. Further we pop available room from `free_rooms_heap` with smallest `room_id`. If no free room available we delay our observation time and free out the room with smallest meeting ending time (pop from `meeting_ends_heap`). While ocupating some room we increase its usage count in dedicated array `meeting_counts`\\n\\n# Complexity\\n- Time complexity: $$O(m*(log(m) + log(n))))$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n\\n        meeting_counts = [0] * n\\n        meeting_ends_heap = []  # [end, room_id]\\n        free_rooms_heap = list(range(n))\\n        heapq.heapify(free_rooms_heap)\\n\\n        meetings.sort()\\n\\n        for start, end in meetings:\\n            while meeting_ends_heap and start >= meeting_ends_heap[0][0]:\\n                _, room_id = heapq.heappop(meeting_ends_heap)\\n                heapq.heappush(free_rooms_heap, room_id)\\n            \\n            delay = 0\\n            if free_rooms_heap:\\n                room_id = heapq.heappop(free_rooms_heap)\\n            else:\\n                delay = meeting_ends_heap[0][0] - start\\n                _, room_id = heapq.heappop(meeting_ends_heap)\\n\\n            heapq.heappush(meeting_ends_heap, [end + delay, room_id])\\n            meeting_counts[room_id] += 1\\n        \\n        return meeting_counts.index(max(meeting_counts))\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n\\n        meeting_counts = [0] * n\\n        meeting_ends_heap = []  # [end, room_id]\\n        free_rooms_heap = list(range(n))\\n        heapq.heapify(free_rooms_heap)\\n\\n        meetings.sort()\\n\\n        for start, end in meetings:\\n            while meeting_ends_heap and start >= meeting_ends_heap[0][0]:\\n                _, room_id = heapq.heappop(meeting_ends_heap)\\n                heapq.heappush(free_rooms_heap, room_id)\\n            \\n            delay = 0\\n            if free_rooms_heap:\\n                room_id = heapq.heappop(free_rooms_heap)\\n            else:\\n                delay = meeting_ends_heap[0][0] - start\\n                _, room_id = heapq.heappop(meeting_ends_heap)\\n\\n            heapq.heappush(meeting_ends_heap, [end + delay, room_id])\\n            meeting_counts[room_id] += 1\\n        \\n        return meeting_counts.index(max(meeting_counts))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803600,
                "title": "c-easy-solution-with-user-define-comparator-function-for-pq",
                "content": "```\\nclass cmp\\n{\\n    public:\\n    bool operator()(pair<long long,int> &a,pair<long long,int> &b)\\n    {\\n        return (a.first==b.first?a.second>b.second:a.first>b.first);\\n    }\\n};\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meet) {\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>> ,cmp> p;\\n        int freq[101]={};\\n        sort(begin(meet),end(meet));\\n        for(int i=0;i<n;i++)p.push({0,i});\\n        for(auto &x: meet)\\n        {\\n            while(p.top().first<x[0])\\n            {\\n                p.push({x[0],p.top().second});\\n                p.pop();\\n            }\\n            pair<long long,int> temp=p.top();\\n            p.pop();\\n            freq[temp.second]++;\\n            temp.first+=(x[1]-x[0]);\\n            p.push(temp);\\n        }\\n        int ans=0;\\n        for(int i=0;i<101;i++)if(freq[ans]<freq[i])ans=i;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass cmp\\n{\\n    public:\\n    bool operator()(pair<long long,int> &a,pair<long long,int> &b)\\n    {\\n        return (a.first==b.first?a.second>b.second:a.first>b.first);\\n    }\\n};\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meet) {\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>> ,cmp> p;\\n        int freq[101]={};\\n        sort(begin(meet),end(meet));\\n        for(int i=0;i<n;i++)p.push({0,i});\\n        for(auto &x: meet)\\n        {\\n            while(p.top().first<x[0])\\n            {\\n                p.push({x[0],p.top().second});\\n                p.pop();\\n            }\\n            pair<long long,int> temp=p.top();\\n            p.pop();\\n            freq[temp.second]++;\\n            temp.first+=(x[1]-x[0]);\\n            p.push(temp);\\n        }\\n        int ans=0;\\n        for(int i=0;i<101;i++)if(freq[ans]<freq[i])ans=i;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637216,
                "title": "no-heaps-queues-or-sorting-line-sweep-solution",
                "content": "Find the range of start times for the meetings and place end times for every meeting on the point on a timeline corresponding to its start.  Then sweep the timeline, maintaining an array of times until which every room is occupied.  The time complexity here is O(R+m\\\\*n), where R is the time range of the meetings start times, m is the number of meetings and n is the number of rooms.  With n being a small constant and the time range being of the same order as the number of meetings, this in practice actually works slightly faster than the sorting-based solutions with the current constraints.\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& v) {\\n        int last=0, first=500001;    // last and first meeting start times\\n        for (auto &vv: v) {\\n            last=max(last,vv[0]);\\n            first=min(first,vv[0]);\\n        }\\n        last++;        \\n                \\n        vector<int> end(last,-1);   // push end times onto the timeline corresponding to the start times\\n        for (auto &vv: v) {\\n            end[vv[0]]=vv[1];\\n        }\\n\\n        vector<long> busy(n,0);  // room i is busy until busy[i]\\n        vector<int> cnt(n,0);    // room i had cnt[i] meetings\\n        \\n        //Line sweep\\n        for (int i=first; i<last; ++i) {\\n            if (end[i]>-1) {                    \\n                bool found=false;\\n                for(int r=0; r<n; r++) {\\n                    if (busy[r]<=i) {\\n                        busy[r]=end[i];\\n                        found=true;\\n                        cnt[r]++;\\n                        break;\\n                    }                        \\n                }\\n                if (!found) {\\n                    int nextroom=min_element(busy.begin(), busy.end())-busy.begin();\\n                    busy[nextroom]+=end[i]-i;\\n                    cnt[nextroom]++;\\n                }\\n            }\\n        }\\n        return max_element(cnt.begin(),cnt.end())-cnt.begin();\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& v) {\\n        int last=0, first=500001;    // last and first meeting start times\\n        for (auto &vv: v) {\\n            last=max(last,vv[0]);\\n            first=min(first,vv[0]);\\n        }\\n        last++;        \\n                \\n        vector<int> end(last,-1);   // push end times onto the timeline corresponding to the start times\\n        for (auto &vv: v) {\\n            end[vv[0]]=vv[1];\\n        }\\n\\n        vector<long> busy(n,0);  // room i is busy until busy[i]\\n        vector<int> cnt(n,0);    // room i had cnt[i] meetings\\n        \\n        //Line sweep\\n        for (int i=first; i<last; ++i) {\\n            if (end[i]>-1) {                    \\n                bool found=false;\\n                for(int r=0; r<n; r++) {\\n                    if (busy[r]<=i) {\\n                        busy[r]=end[i];\\n                        found=true;\\n                        cnt[r]++;\\n                        break;\\n                    }                        \\n                }\\n                if (!found) {\\n                    int nextroom=min_element(busy.begin(), busy.end())-busy.begin();\\n                    busy[nextroom]+=end[i]-i;\\n                    cnt[nextroom]++;\\n                }\\n            }\\n        }\\n        return max_element(cnt.begin(),cnt.end())-cnt.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597443,
                "title": "python-sweep-line-solution-using-two-heaps-similar-problems-listed",
                "content": "Please see and vote for my solutions for similar problems.\\n[253. Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/discuss/322622/Simple-Python-solutions)\\n[2406. Divide Intervals Into Minimum Number of Groups](https://leetcode.com/problems/divide-intervals-into-minimum-number-of-groups/discuss/2594874/Solutions-similar-to-253.-Meeting-Rooms-II-(similar-problems-listed))\\n[2402. Meeting Rooms III](https://leetcode.com/problems/meeting-rooms-iii/discuss/2597443/Python-Heap-Solution-similar-problems-listed)\\n[731. My Calendar II](https://leetcode.com/problems/my-calendar-ii/discuss/323479/Simple-C%2B%2B-Solution-using-built-in-map-(Same-as-253.-Meeting-Rooms-II))\\n[732. My Calendar III](https://leetcode.com/problems/my-calendar-iii/discuss/302492/Simple-C%2B%2B-Solution-using-built-in-map-(Same-as-253.-Meeting-Rooms-II))\\n[1094. Car Pooling](https://leetcode.com/problems/car-pooling/discuss/319088/Simple-Python-solution)\\n[1109. Corporate Flight Bookings](https://leetcode.com/problems/corporate-flight-bookings/discuss/328949/Simple-Python-solution)\\n[218. The Skyline Problem](https://leetcode.com/problems/the-skyline-problem/discuss/325070/SImple-Python-solutions)\\n\\n\\nSimilar to [253. Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/discuss/322622/Simple-Python-solutions)\\n```\\n    def minMeetingRooms(self, intervals):\\n        intervals.sort(key = lambda x: x[0])    # sort the intervals\\n        res = 0\\n        heap, heap_size = [], 0         # heap of meeting ending times\\n        for interval in intervals:      # move the vertical line from left to right\\n\\t\\t    # pop all ended meetings from the heap\\n            while heap and heap[0] <= interval[0]:\\n                heapq.heappop(heap)\\n                heap_size -= 1\\n            heapq.heappush(heap, interval[1])\\n            heap_size += 1\\n            res = max(res, heap_size)\\n        return res\\n```\\n\\nWe can modify the algorithm a little bit\\n\\n```\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort(key = lambda x: x[0])     # sort time intervals, \\n        freq = n * [0]\\n        used_rooms = [] \\n        free_rooms = list(range(n)) \\n        heapq.heapify(free_rooms)          # a heap of available rooms\\n        for start, end in meetings:        # move a vertical line from left to right, \\n\\t\\t    # pop all ended meetings and rooms from used_rooms\\n            while used_rooms and used_rooms[0][0] <= start:\\n                time, i = heapq.heappop(used_rooms)\\n                heapq.heappush(free_rooms, i)\\n\\t\\t\\t# according to the rules, assign a new room to this meeting \\n            if free_rooms:\\n                i = heapq.heappop(free_rooms)\\n                heapq.heappush(used_rooms, (end, i))\\n            else:\\n                time, i = heapq.heappop(used_rooms)\\n                heapq.heappush(used_rooms, (end - start + time, i))\\n            freq[i] += 1\\n        max_usages = max(freq)\\n        for i in range(n):\\n            if freq[i] == max_usages:\\n                return i\\n```",
                "solutionTags": [],
                "code": "```\\n    def minMeetingRooms(self, intervals):\\n        intervals.sort(key = lambda x: x[0])    # sort the intervals\\n        res = 0\\n        heap, heap_size = [], 0         # heap of meeting ending times\\n        for interval in intervals:      # move the vertical line from left to right\\n\\t\\t    # pop all ended meetings from the heap\\n            while heap and heap[0] <= interval[0]:\\n                heapq.heappop(heap)\\n                heap_size -= 1\\n            heapq.heappush(heap, interval[1])\\n            heap_size += 1\\n            res = max(res, heap_size)\\n        return res\\n```\n```\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort(key = lambda x: x[0])     # sort time intervals, \\n        freq = n * [0]\\n        used_rooms = [] \\n        free_rooms = list(range(n)) \\n        heapq.heapify(free_rooms)          # a heap of available rooms\\n        for start, end in meetings:        # move a vertical line from left to right, \\n\\t\\t    # pop all ended meetings and rooms from used_rooms\\n            while used_rooms and used_rooms[0][0] <= start:\\n                time, i = heapq.heappop(used_rooms)\\n                heapq.heappush(free_rooms, i)\\n\\t\\t\\t# according to the rules, assign a new room to this meeting \\n            if free_rooms:\\n                i = heapq.heappop(free_rooms)\\n                heapq.heappush(used_rooms, (end, i))\\n            else:\\n                time, i = heapq.heappop(used_rooms)\\n                heapq.heappush(used_rooms, (end - start + time, i))\\n            freq[i] += 1\\n        max_usages = max(freq)\\n        for i in range(n):\\n            if freq[i] == max_usages:\\n                return i\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2555322,
                "title": "got-this-right-in-first-attempt-feels-like-i-am-a-god",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        priority_queue <pair<ll,int>, vector<pair<ll,int>>, greater<pair<ll,int>>> pq;\\n        priority_queue <int, vector<int>, greater<int>> pq1;\\n        sort(meetings.begin(),meetings.end());\\n        vector<int> v(n,0);\\n        pq.push({meetings[0][1],0});\\n        v[0]++;\\n        for(int i=1;i<n;i++) pq1.push(i);\\n        for(int i=1;i<meetings.size();i++){\\n            if(pq.size()!=0 && meetings[i][0]>=pq.top().first){\\n                while(pq.size()!=0 && meetings[i][0]>=pq.top().first){\\n                    pq1.push(pq.top().second);\\n                    pq.pop();\\n                }\\n                pq.push({meetings[i][1],pq1.top()});\\n                v[pq1.top()]++;\\n                pq1.pop();\\n            }\\n            else{\\n                if(pq1.size()!=0){\\n                    pq.push({meetings[i][1],pq1.top()});\\n                    v[pq1.top()]++;\\n                    pq1.pop();\\n                }\\n                else{\\n                    ll end=pq.top().first;\\n                    int room=pq.top().second;\\n                    pq.pop();\\n                    pq.push({end+(meetings[i][1]-meetings[i][0]),room});\\n                    v[room]++;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        int mx=0;\\n        for(int i=0;i<n;i++){\\n            cout<<i<<\" \"<<v[i]<<endl;\\n            if(v[i]>mx){\\n                mx=v[i];\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        priority_queue <pair<ll,int>, vector<pair<ll,int>>, greater<pair<ll,int>>> pq;\\n        priority_queue <int, vector<int>, greater<int>> pq1;\\n        sort(meetings.begin(),meetings.end());\\n        vector<int> v(n,0);\\n        pq.push({meetings[0][1],0});\\n        v[0]++;\\n        for(int i=1;i<n;i++) pq1.push(i);\\n        for(int i=1;i<meetings.size();i++){\\n            if(pq.size()!=0 && meetings[i][0]>=pq.top().first){\\n                while(pq.size()!=0 && meetings[i][0]>=pq.top().first){\\n                    pq1.push(pq.top().second);\\n                    pq.pop();\\n                }\\n                pq.push({meetings[i][1],pq1.top()});\\n                v[pq1.top()]++;\\n                pq1.pop();\\n            }\\n            else{\\n                if(pq1.size()!=0){\\n                    pq.push({meetings[i][1],pq1.top()});\\n                    v[pq1.top()]++;\\n                    pq1.pop();\\n                }\\n                else{\\n                    ll end=pq.top().first;\\n                    int room=pq.top().second;\\n                    pq.pop();\\n                    pq.push({end+(meetings[i][1]-meetings[i][0]),room});\\n                    v[room]++;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        int mx=0;\\n        for(int i=0;i<n;i++){\\n            cout<<i<<\" \"<<v[i]<<endl;\\n            if(v[i]>mx){\\n                mx=v[i];\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2533294,
                "title": "java",
                "content": "```\\nclass Solution {\\n    Map<Integer, Long> count = new HashMap<>();\\n    \\n    public int mostBooked(int n, int[][] meetings) {\\n        \\n        // Sorts occupied Rooms in the increasing order of getting free.  \\n        PriorityQueue<Node> pq = new PriorityQueue<>((node1, node2)-> {\\n            if (node1.endTime != node2.endTime)\\n                return node1.endTime - node2.endTime;\\n            return node1.roomId - node2.roomId;\\n        });\\n        \\n        TreeSet<Integer> availableRooms = new TreeSet<>();\\n        Arrays.sort(meetings, (a, b)-> a[0] - b[0]);\\n        for (int i = 0; i < n; ++i) {\\n            availableRooms.add(i);\\n        }\\n        \\n        for (int i = 0; i < meetings.length; ++i) {\\n            var meeting = meetings[i];\\n            \\n            // Free Up Rooms\\n            while (pq.size() > 0 && meeting[0] >= pq.peek().endTime) {\\n                var node = pq.poll();\\n                availableRooms.add(node.roomId);\\n            }\\n            \\n            if (availableRooms.size() == 0) {\\n                \\n                meeting[0] = meeting[0];\\n                \\n                meeting[1] = meeting[1] + pq.peek().endTime - meeting[0];\\n                \\n                var node = pq.poll();\\n                \\n                count.put(node.roomId, 1 + count.getOrDefault(node.roomId, 0L));\\n                pq.offer(new Node(node.roomId, meeting[1]));\\n            } else {\\n                int roomId = availableRooms.pollFirst();\\n                count.put(roomId, 1 + count.getOrDefault(roomId, 0L));\\n                \\n                pq.offer(new Node(roomId, meeting[1]));\\n            }\\n        }\\n        \\n        return getRoomWithMax();\\n    }\\n    \\n    int getRoomWithMax() {\\n        // System.out.println(count);\\n        \\n        int roomId = -1;\\n        long maxCount = Integer.MIN_VALUE;\\n        \\n        for (var entry : count.entrySet()) {\\n            if (maxCount < entry.getValue()) {\\n                maxCount = entry.getValue();\\n                roomId = entry.getKey();\\n            } else if (maxCount == entry.getValue()) {\\n                if (roomId > entry.getKey()) {\\n                    roomId = entry.getKey();\\n                }\\n            }\\n        }\\n        \\n        \\n        return roomId;\\n    }\\n    \\n    class Node {\\n        int roomId;\\n        int endTime;\\n        \\n        Node(int roomId, int endTime) {\\n            this.roomId = roomId;\\n            this.endTime = endTime;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Long> count = new HashMap<>();\\n    \\n    public int mostBooked(int n, int[][] meetings) {\\n        \\n        // Sorts occupied Rooms in the increasing order of getting free.  \\n        PriorityQueue<Node> pq = new PriorityQueue<>((node1, node2)-> {\\n            if (node1.endTime != node2.endTime)\\n                return node1.endTime - node2.endTime;\\n            return node1.roomId - node2.roomId;\\n        });\\n        \\n        TreeSet<Integer> availableRooms = new TreeSet<>();\\n        Arrays.sort(meetings, (a, b)-> a[0] - b[0]);\\n        for (int i = 0; i < n; ++i) {\\n            availableRooms.add(i);\\n        }\\n        \\n        for (int i = 0; i < meetings.length; ++i) {\\n            var meeting = meetings[i];\\n            \\n            // Free Up Rooms\\n            while (pq.size() > 0 && meeting[0] >= pq.peek().endTime) {\\n                var node = pq.poll();\\n                availableRooms.add(node.roomId);\\n            }\\n            \\n            if (availableRooms.size() == 0) {\\n                \\n                meeting[0] = meeting[0];\\n                \\n                meeting[1] = meeting[1] + pq.peek().endTime - meeting[0];\\n                \\n                var node = pq.poll();\\n                \\n                count.put(node.roomId, 1 + count.getOrDefault(node.roomId, 0L));\\n                pq.offer(new Node(node.roomId, meeting[1]));\\n            } else {\\n                int roomId = availableRooms.pollFirst();\\n                count.put(roomId, 1 + count.getOrDefault(roomId, 0L));\\n                \\n                pq.offer(new Node(roomId, meeting[1]));\\n            }\\n        }\\n        \\n        return getRoomWithMax();\\n    }\\n    \\n    int getRoomWithMax() {\\n        // System.out.println(count);\\n        \\n        int roomId = -1;\\n        long maxCount = Integer.MIN_VALUE;\\n        \\n        for (var entry : count.entrySet()) {\\n            if (maxCount < entry.getValue()) {\\n                maxCount = entry.getValue();\\n                roomId = entry.getKey();\\n            } else if (maxCount == entry.getValue()) {\\n                if (roomId > entry.getKey()) {\\n                    roomId = entry.getKey();\\n                }\\n            }\\n        }\\n        \\n        \\n        return roomId;\\n    }\\n    \\n    class Node {\\n        int roomId;\\n        int endTime;\\n        \\n        Node(int roomId, int endTime) {\\n            this.roomId = roomId;\\n            this.endTime = endTime;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531109,
                "title": "hindi-video-explanation-min-heap-c",
                "content": "Code with comments below:\\nIn case you want to understand the intuition and logic used for solving , please refer hindi video:\\nhttps://youtu.be/HfmZIAF82l0\\n\\n```\\nclass Solution {\\npublic:\\n    /*\\n    We have to assign one meeting room for each meeting.\\n    Basic : Lets say we store the occupancy and time(if occupied) after which the\\n    room will be available. Then for a particular meeting we can check whether\\n    we have an empty room or not. If no empty room then we can find closest time\\n    when some room will be available. time = O(N*meetings_length)\\n    \\n    Optimal:\\n    We can use 2 heaps to store available rooms, occupied rooms.\\n    available rooms => store index of room\\n    occupied rooms => store current meeting end time, index of room.\\n    */\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n\\n      sort(meetings.begin(), meetings.end());\\n      \\n      int m = meetings.size();\\n      vector<int> room_meeting_count(n, 0);\\n      \\n      // store available rooms in min heap(lowest index room first)\\n      priority_queue<int, vector<int>, greater<int>> available;\\n      // busy rooms in min heap(earliest meeting complete time first)\\n      priority_queue<pair<long long, int>, vector<pair<long long, int>>,\\n        greater<pair<long long, int>>> busy;\\n      \\n      for (int i = 0; i < n; ++i) {\\n        available.push(i);\\n      }\\n      \\n      for (const auto& meeting: meetings) {\\n        // move rooms whose ongoing meetings are over before start time\\n        // of current meeting.\\n        int start = meeting[0] , end = meeting[1];\\n        while (busy.size() > 0 && busy.top().first <= start) {\\n          available.push(busy.top().second);\\n          busy.pop();\\n        }\\n        \\n        if (available.size() > 0) {\\n          int top = available.top();\\n          room_meeting_count[top]++;\\n          available.pop();\\n          busy.push({end, top});\\n          continue;\\n        }\\n        // no available rooms, will have to wait for occupied room to get empty.\\n        // earliest room that will be available.\\n        auto top = busy.top();\\n        int available_time = top.first, index = top.second;\\n        busy.pop();\\n        room_meeting_count[index]++;\\n        // the end time of current meeting will be \\n        // (end time of meeting that finishes earliest)+ duration of current meeting\\n        busy.push({top.first + end - start, index});\\n      }\\n      \\n      return max_element(room_meeting_count.begin(),\\n                         room_meeting_count.end()) - room_meeting_count.begin();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    We have to assign one meeting room for each meeting.\\n    Basic : Lets say we store the occupancy and time(if occupied) after which the\\n    room will be available. Then for a particular meeting we can check whether\\n    we have an empty room or not. If no empty room then we can find closest time\\n    when some room will be available. time = O(N*meetings_length)\\n    \\n    Optimal:\\n    We can use 2 heaps to store available rooms, occupied rooms.\\n    available rooms => store index of room\\n    occupied rooms => store current meeting end time, index of room.\\n    */\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n\\n      sort(meetings.begin(), meetings.end());\\n      \\n      int m = meetings.size();\\n      vector<int> room_meeting_count(n, 0);\\n      \\n      // store available rooms in min heap(lowest index room first)\\n      priority_queue<int, vector<int>, greater<int>> available;\\n      // busy rooms in min heap(earliest meeting complete time first)\\n      priority_queue<pair<long long, int>, vector<pair<long long, int>>,\\n        greater<pair<long long, int>>> busy;\\n      \\n      for (int i = 0; i < n; ++i) {\\n        available.push(i);\\n      }\\n      \\n      for (const auto& meeting: meetings) {\\n        // move rooms whose ongoing meetings are over before start time\\n        // of current meeting.\\n        int start = meeting[0] , end = meeting[1];\\n        while (busy.size() > 0 && busy.top().first <= start) {\\n          available.push(busy.top().second);\\n          busy.pop();\\n        }\\n        \\n        if (available.size() > 0) {\\n          int top = available.top();\\n          room_meeting_count[top]++;\\n          available.pop();\\n          busy.push({end, top});\\n          continue;\\n        }\\n        // no available rooms, will have to wait for occupied room to get empty.\\n        // earliest room that will be available.\\n        auto top = busy.top();\\n        int available_time = top.first, index = top.second;\\n        busy.pop();\\n        room_meeting_count[index]++;\\n        // the end time of current meeting will be \\n        // (end time of meeting that finishes earliest)+ duration of current meeting\\n        busy.push({top.first + end - start, index});\\n      }\\n      \\n      return max_element(room_meeting_count.begin(),\\n                         room_meeting_count.end()) - room_meeting_count.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530106,
                "title": "python-priority-queue",
                "content": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        # sort the meetings by start time\\n        meetings.sort()\\n        \\n        # priority queue \\n        queue = []\\n        count = collections.defaultdict(int)\\n        \\n        # avaliable meeting room, sort by idx\\n        ava = []\\n        for idx in range(n):\\n            heapq.heappush(ava, idx)\\n        \\n        for idx in range(len(meetings)):\\n            start, end = meetings[idx]\\n            dur = end - start\\n            \\n            # release the meeting room if the start time is greater than the\\n            # end time\\n            while queue and queue[0][0] <= start:\\n                _, room_idx = heapq.heappop(queue)\\n                heapq.heappush(ava, room_idx)\\n            \\n            # if there is an empty meeting room, find the smaller index room\\n            if len(ava) > 0:\\n                room_idx = heapq.heappop(ava)\\n                heapq.heappush(queue, (end, room_idx))\\n                count[room_idx] += 1\\n            else:\\n                end_time, next_end_room = heapq.heappop(queue)\\n                \\n                # At this moment, the meeting should be delayed\\n                new_end_time = end_time + dur\\n                \\n                heapq.heappush(queue, (new_end_time, next_end_room))\\n                count[next_end_room] += 1\\n                \\n        # Find the max count\\n        ans = count[0]\\n        ans_idx = 0\\n        for idx in range(1, n):\\n            # If there are multiple rooms\\n            # return the room with the lowest number.\\n            # so we use `>`\\n            if count[idx] > ans:\\n                ans_idx = idx\\n                ans = count[idx]\\n        \\n        return ans_idx\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        # sort the meetings by start time\\n        meetings.sort()\\n        \\n        # priority queue \\n        queue = []\\n        count = collections.defaultdict(int)\\n        \\n        # avaliable meeting room, sort by idx\\n        ava = []\\n        for idx in range(n):\\n            heapq.heappush(ava, idx)\\n        \\n        for idx in range(len(meetings)):\\n            start, end = meetings[idx]\\n            dur = end - start\\n            \\n            # release the meeting room if the start time is greater than the\\n            # end time\\n            while queue and queue[0][0] <= start:\\n                _, room_idx = heapq.heappop(queue)\\n                heapq.heappush(ava, room_idx)\\n            \\n            # if there is an empty meeting room, find the smaller index room\\n            if len(ava) > 0:\\n                room_idx = heapq.heappop(ava)\\n                heapq.heappush(queue, (end, room_idx))\\n                count[room_idx] += 1\\n            else:\\n                end_time, next_end_room = heapq.heappop(queue)\\n                \\n                # At this moment, the meeting should be delayed\\n                new_end_time = end_time + dur\\n                \\n                heapq.heappush(queue, (new_end_time, next_end_room))\\n                count[next_end_room] += 1\\n                \\n        # Find the max count\\n        ans = count[0]\\n        ans_idx = 0\\n        for idx in range(1, n):\\n            # If there are multiple rooms\\n            # return the room with the lowest number.\\n            # so we use `>`\\n            if count[idx] > ans:\\n                ans_idx = idx\\n                ans = count[idx]\\n        \\n        return ans_idx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529432,
                "title": "87-tc-easy-python-solution",
                "content": "```\\ndef mostBooked(self, n: int, meet: List[List[int]]) -> int:\\n\\tcount = [0] * n\\n\\tmeet.sort()\\n\\tavlbl = SortedList([i for i in range(n)])\\n\\thold = []\\n\\tfor i, j in meet:\\n\\t\\twhile(hold and hold[0][0] <= i):\\n\\t\\t\\t_, room = heappop(hold)\\n\\t\\t\\tavlbl.add(room)\\n\\t\\tif(avlbl):\\n\\t\\t\\troom = avlbl.pop(0)\\n\\t\\t\\tstart = i\\n\\t\\telse:\\n\\t\\t\\tstart, room = heappop(hold)\\n\\t\\theappush(hold, (start + (j-i), room))\\n\\t\\tcount[room] += 1\\n\\tm, ans = -1, -1\\n\\tfor i in range(n):\\n\\t\\tif(m < count[i]):\\n\\t\\t\\tm = count[i]\\n\\t\\t\\tans = i\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef mostBooked(self, n: int, meet: List[List[int]]) -> int:\\n\\tcount = [0] * n\\n\\tmeet.sort()\\n\\tavlbl = SortedList([i for i in range(n)])\\n\\thold = []\\n\\tfor i, j in meet:\\n\\t\\twhile(hold and hold[0][0] <= i):\\n\\t\\t\\t_, room = heappop(hold)\\n\\t\\t\\tavlbl.add(room)\\n\\t\\tif(avlbl):\\n\\t\\t\\troom = avlbl.pop(0)\\n\\t\\t\\tstart = i\\n\\t\\telse:\\n\\t\\t\\tstart, room = heappop(hold)\\n\\t\\theappush(hold, (start + (j-i), room))\\n\\t\\tcount[room] += 1\\n\\tm, ans = -1, -1\\n\\tfor i in range(n):\\n\\t\\tif(m < count[i]):\\n\\t\\t\\tm = count[i]\\n\\t\\t\\tans = i\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2529232,
                "title": "javascript-simple-easy-heavily-commented-code",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} meetings\\n * @return {number}\\n */\\nvar mostBooked = function(n, meetings) {\\n\\n    let roomsMeetingCount=[], roomsSchedule=[];\\n    //Intially all the rooms are available and meeting count for eacy room is set to 0\\n    for(let i=0;i<n;i++){\\n        roomsSchedule[i]=-1;\\n        roomsMeetingCount[i]=0;\\n    }\\n    //Sort meeting by their start time\\n    meetings.sort(function(a,b){return a[0]-b[0]});\\n    \\n    for(let i=0;i<meetings.length;i++){\\n        let start =  meetings[i][0];\\n        let end = meetings[i][1];\\n        let earliestRoom=-1,earliestTime=Number.MAX_SAFE_INTEGER,freeRoomFound=false;\\n        for(let i=0;i<n;i++){\\n            if(roomsSchedule[i]<=start){//This is the room with the smallest index which is free on or before start time of the current meeting\\n                roomsMeetingCount[i]++;\\n                roomsSchedule[i]=end;//This room will be avialable at \\'end\\' time of the current meeting.\\n                freeRoomFound=true;\\n                break;\\n            }\\n            if(roomsSchedule[i]<earliestTime){//Let\\'s keep track of the \"room with smallest index and being available at the earliest\"\\n                earliestTime = roomsSchedule[i];\\n                earliestRoom = i;\\n            }\\n        }\\n        if(freeRoomFound===false){//If we couldn\\'t find any meeting room then we will wait for the \"room with smallest index and being available at the earliest\" \\n            roomsMeetingCount[earliestRoom]++;\\n            roomsSchedule[earliestRoom]+=(end-start);//Time to vacant for the room will be increased by the duration of current meeting.\\n        }\\n    }\\n    //Now we have count of meetings for each meeting. Can just need to find the room index with the maximum number of meetings.\\n    let max=0,maxi=-1;\\n    for(let i=0;i<n;i++){\\n        if(roomsMeetingCount[i]>max){\\n            max = roomsMeetingCount[i];\\n            maxi=i;\\n        }\\n    }\\n    return maxi;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} meetings\\n * @return {number}\\n */\\nvar mostBooked = function(n, meetings) {\\n\\n    let roomsMeetingCount=[], roomsSchedule=[];\\n    //Intially all the rooms are available and meeting count for eacy room is set to 0\\n    for(let i=0;i<n;i++){\\n        roomsSchedule[i]=-1;\\n        roomsMeetingCount[i]=0;\\n    }\\n    //Sort meeting by their start time\\n    meetings.sort(function(a,b){return a[0]-b[0]});\\n    \\n    for(let i=0;i<meetings.length;i++){\\n        let start =  meetings[i][0];\\n        let end = meetings[i][1];\\n        let earliestRoom=-1,earliestTime=Number.MAX_SAFE_INTEGER,freeRoomFound=false;\\n        for(let i=0;i<n;i++){\\n            if(roomsSchedule[i]<=start){//This is the room with the smallest index which is free on or before start time of the current meeting\\n                roomsMeetingCount[i]++;\\n                roomsSchedule[i]=end;//This room will be avialable at \\'end\\' time of the current meeting.\\n                freeRoomFound=true;\\n                break;\\n            }\\n            if(roomsSchedule[i]<earliestTime){//Let\\'s keep track of the \"room with smallest index and being available at the earliest\"\\n                earliestTime = roomsSchedule[i];\\n                earliestRoom = i;\\n            }\\n        }\\n        if(freeRoomFound===false){//If we couldn\\'t find any meeting room then we will wait for the \"room with smallest index and being available at the earliest\" \\n            roomsMeetingCount[earliestRoom]++;\\n            roomsSchedule[earliestRoom]+=(end-start);//Time to vacant for the room will be increased by the duration of current meeting.\\n        }\\n    }\\n    //Now we have count of meetings for each meeting. Can just need to find the room index with the maximum number of meetings.\\n    let max=0,maxi=-1;\\n    for(let i=0;i<n;i++){\\n        if(roomsMeetingCount[i]>max){\\n            max = roomsMeetingCount[i];\\n            maxi=i;\\n        }\\n    }\\n    return maxi;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2528124,
                "title": "python-easy-1-priority-queue-solution",
                "content": "```\\n    def mostBooked(self, n, meetings):\\n        \"\"\"\\n        :type n: int\\n        :type meetings: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        arr = []\\n        for i in range(n):\\n            heapq.heappush(arr, (0, i)) # (endTime, roomID)\\n        \\n        cnt = collections.Counter()\\n        meetings.sort() # sort based on start time\\n        \\n        for i in range(len(meetings)):\\n            s, e = meetings[i]\\n            \\n            # free finished rooms such that low-index room can be selected first\\n            while arr[0][0] < s:\\n                curTime, idx = heapq.heappop(arr)\\n                heapq.heappush(arr, (s, idx))\\n            \\n            curTime, idx = heapq.heappop(arr)\\n            heapq.heappush(arr, (max(curTime, s) + e - s, idx))\\n            cnt[idx] += 1\\n        \\n        maxV = 0\\n        for i in range(n):\\n            if cnt[i] > maxV:\\n                res = i\\n                maxV = cnt[i]\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    def mostBooked(self, n, meetings):\\n        \"\"\"\\n        :type n: int\\n        :type meetings: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        arr = []\\n        for i in range(n):\\n            heapq.heappush(arr, (0, i)) # (endTime, roomID)\\n        \\n        cnt = collections.Counter()\\n        meetings.sort() # sort based on start time\\n        \\n        for i in range(len(meetings)):\\n            s, e = meetings[i]\\n            \\n            # free finished rooms such that low-index room can be selected first\\n            while arr[0][0] < s:\\n                curTime, idx = heapq.heappop(arr)\\n                heapq.heappush(arr, (s, idx))\\n            \\n            curTime, idx = heapq.heappop(arr)\\n            heapq.heappush(arr, (max(curTime, s) + e - s, idx))\\n            cnt[idx] += 1\\n        \\n        maxV = 0\\n        for i in range(n):\\n            if cnt[i] > maxV:\\n                res = i\\n                maxV = cnt[i]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2527872,
                "title": "rust-brutal-force-greedy",
                "content": "Solution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/lvl4/lc2402)\\n\\n<b>Problem List</b>\\n#Greedy - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_algorithm/greedy)\\n\\n```\\n/// @author: Leon\\n/// https://leetcode.com/problems/meeting-rooms-iii/\\n/// Time Complexity:    O(`n` * `_len_mts`) + O(`_len_mts` * lg(`_len_mts`))\\n/// Space Complexity:   O(`n`)\\n/// Note:\\n/// this approach takes the advantage of `n` being small\\nimpl Solution {\\n    pub fn most_booked(n: i32, meetings: Vec<Vec<i32>>) -> i32 {\\n        const RANGE: i64 = 1e10 as i64 * 5 + 7;\\n        let _len_mts: usize = meetings.len();\\n        let n: usize = n as usize;\\n        let meetings: Vec<Vec<i32>> = {\\n            let mut mts = meetings;\\n            mts.sort_by_key(|v| v[0]);\\n            mts\\n        };\\n        let mut end_times: Vec<i64> = vec![0; n];\\n        let mut freqs: Vec<i32> = vec![0; n];\\n        for mt in meetings {\\n            let start = mt[0] as i64;\\n            let end = mt[1] as i64;\\n            let duration = end - start;\\n            let mut arranged: bool = false;\\n            let mut end_min: i64 = RANGE;\\n            let mut idx_min: usize = n + 1;\\n            // to greedily pick the availablity\\n            for idx in 0..n {\\n                // if any availability can be found,\\n                // to pick the one with the lowest index\\n                if end_times[idx] <= start {\\n                    end_times[idx] = end;\\n                    freqs[idx] += 1;\\n                    arranged = true;\\n                    break;\\n                }\\n                // to keep track of the min value/index along the way\\n                if end_times[idx] < end_min {\\n                    end_min = end_times[idx];\\n                    idx_min = idx;\\n                }\\n            }\\n            // if not any availability can be found,\\n            // to pick the earliest ending spot\\n            if !arranged {\\n                freqs[idx_min] += 1;\\n                end_times[idx_min] += duration;\\n            }\\n        }\\n        let mut most: i32 = 0;\\n        let mut ans: usize = 0;\\n        for (idx, freq) in freqs.into_iter().enumerate() {\\n            if freq > most {\\n                most = freq;\\n                ans = idx;\\n            }\\n        }\\n        return ans as i32;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Greedy"
                ],
                "code": "```\\n/// @author: Leon\\n/// https://leetcode.com/problems/meeting-rooms-iii/\\n/// Time Complexity:    O(`n` * `_len_mts`) + O(`_len_mts` * lg(`_len_mts`))\\n/// Space Complexity:   O(`n`)\\n/// Note:\\n/// this approach takes the advantage of `n` being small\\nimpl Solution {\\n    pub fn most_booked(n: i32, meetings: Vec<Vec<i32>>) -> i32 {\\n        const RANGE: i64 = 1e10 as i64 * 5 + 7;\\n        let _len_mts: usize = meetings.len();\\n        let n: usize = n as usize;\\n        let meetings: Vec<Vec<i32>> = {\\n            let mut mts = meetings;\\n            mts.sort_by_key(|v| v[0]);\\n            mts\\n        };\\n        let mut end_times: Vec<i64> = vec![0; n];\\n        let mut freqs: Vec<i32> = vec![0; n];\\n        for mt in meetings {\\n            let start = mt[0] as i64;\\n            let end = mt[1] as i64;\\n            let duration = end - start;\\n            let mut arranged: bool = false;\\n            let mut end_min: i64 = RANGE;\\n            let mut idx_min: usize = n + 1;\\n            // to greedily pick the availablity\\n            for idx in 0..n {\\n                // if any availability can be found,\\n                // to pick the one with the lowest index\\n                if end_times[idx] <= start {\\n                    end_times[idx] = end;\\n                    freqs[idx] += 1;\\n                    arranged = true;\\n                    break;\\n                }\\n                // to keep track of the min value/index along the way\\n                if end_times[idx] < end_min {\\n                    end_min = end_times[idx];\\n                    idx_min = idx;\\n                }\\n            }\\n            // if not any availability can be found,\\n            // to pick the earliest ending spot\\n            if !arranged {\\n                freqs[idx_min] += 1;\\n                end_times[idx_min] += duration;\\n            }\\n        }\\n        let mut most: i32 = 0;\\n        let mut ans: usize = 0;\\n        for (idx, freq) in freqs.into_iter().enumerate() {\\n            if freq > most {\\n                most = freq;\\n                ans = idx;\\n            }\\n        }\\n        return ans as i32;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2527771,
                "title": "easy-min-heap-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        priority_queue<pair<long long,long long >,vector<pair<long long,long long >>,greater<pair<long long,long long >>>p;\\n        sort(meetings.begin(),meetings.end());\\n        vector<long long >vis(n,0);\\n        vector<long long >countt(n,0);\\n        for(auto k:meetings){\\n            int flg=1;\\n            while(p.size()>0&&p.top().first<=k[0]){\\n                auto m = p.top();\\n                p.pop();\\n                vis[m.second]=0;\\n                \\n            }\\n            for(int i=0;i<n;i++){\\n                if(vis[i]==0){\\n                    vis[i]=1;\\n                   \\n                    p.push({k[1],i});\\n                    countt[i]++;\\n                    flg=0;\\n                    break;\\n                }\\n            }\\n            if(flg==0)\\n                continue;\\n         \\n                auto m = p.top();\\n                p.pop();\\n                p.push({k[1]+m.first-k[0],m.second});\\n                countt[m.second]++;\\n                vis[m.second]=1;\\n            \\n        }\\n        long long  maxi = 0;\\n        long long  ans=0;\\n        for(int i=0;i<n;i++){\\n           if(maxi<countt[i]){\\n               ans=i;\\n               maxi = countt[i];\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        priority_queue<pair<long long,long long >,vector<pair<long long,long long >>,greater<pair<long long,long long >>>p;\\n        sort(meetings.begin(),meetings.end());\\n        vector<long long >vis(n,0);\\n        vector<long long >countt(n,0);\\n        for(auto k:meetings){\\n            int flg=1;\\n            while(p.size()>0&&p.top().first<=k[0]){\\n                auto m = p.top();\\n                p.pop();\\n                vis[m.second]=0;\\n                \\n            }\\n            for(int i=0;i<n;i++){\\n                if(vis[i]==0){\\n                    vis[i]=1;\\n                   \\n                    p.push({k[1],i});\\n                    countt[i]++;\\n                    flg=0;\\n                    break;\\n                }\\n            }\\n            if(flg==0)\\n                continue;\\n         \\n                auto m = p.top();\\n                p.pop();\\n                p.push({k[1]+m.first-k[0],m.second});\\n                countt[m.second]++;\\n                vis[m.second]=1;\\n            \\n        }\\n        long long  maxi = 0;\\n        long long  ans=0;\\n        for(int i=0;i<n;i++){\\n           if(maxi<countt[i]){\\n               ans=i;\\n               maxi = countt[i];\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527637,
                "title": "javascript-two-priority-queues",
                "content": "```\\nvar mostBooked = function(n, meetings) {\\n    meetings.sort((a,b)=> a[0]-b[0]);\\n    const q1 = new MinPriorityQueue({ priority: (el) => el[0]}); // available: sort by index\\n    const q2 = new MinPriorityQueue({ priority: (el) => el[1]*500000 + el[0]}); // in use: sort by endTime\\n    for(let i =0; i<n; i++) {\\n        q1.enqueue([i, 0]);\\n    }\\n    const res = new Array(n).fill(0);\\n    for(let m of meetings) {\\n        // 1. check any possible available room again before m[0] start time\\n        while(!q2.isEmpty() && m[0] >= q2.front().element[1]) {\\n            q1.enqueue([...q2.dequeue().element]);\\n        }\\n        // 2. check if any empty room can be used\\n        if(!q1.isEmpty()) {\\n            const cur = q1.dequeue().element;\\n            cur[1] = cur[1] <= m[0] ? m[1] : (cur[1] + m[1] - m[0]);\\n            res[cur[0]]++;\\n            q2.enqueue([...cur]);\\n        }\\n        // 3. if no empty room, always use the 1st one that finish in future\\n        else {\\n            const first = q2.dequeue().element;\\n            first[1] += m[1] - m[0];\\n            res[first[0]]++;\\n            q2.enqueue([...first]);\\n        }\\n    }\\n    // 4. return the max room index\\n    let j;\\n    let max = 0;\\n    for(let i =0; i<n; i++){\\n        if(res[i] > max) {\\n            j = i;\\n            max = res[i];\\n        }\\n    }\\n    return j;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvar mostBooked = function(n, meetings) {\\n    meetings.sort((a,b)=> a[0]-b[0]);\\n    const q1 = new MinPriorityQueue({ priority: (el) => el[0]}); // available: sort by index\\n    const q2 = new MinPriorityQueue({ priority: (el) => el[1]*500000 + el[0]}); // in use: sort by endTime\\n    for(let i =0; i<n; i++) {\\n        q1.enqueue([i, 0]);\\n    }\\n    const res = new Array(n).fill(0);\\n    for(let m of meetings) {\\n        // 1. check any possible available room again before m[0] start time\\n        while(!q2.isEmpty() && m[0] >= q2.front().element[1]) {\\n            q1.enqueue([...q2.dequeue().element]);\\n        }\\n        // 2. check if any empty room can be used\\n        if(!q1.isEmpty()) {\\n            const cur = q1.dequeue().element;\\n            cur[1] = cur[1] <= m[0] ? m[1] : (cur[1] + m[1] - m[0]);\\n            res[cur[0]]++;\\n            q2.enqueue([...cur]);\\n        }\\n        // 3. if no empty room, always use the 1st one that finish in future\\n        else {\\n            const first = q2.dequeue().element;\\n            first[1] += m[1] - m[0];\\n            res[first[0]]++;\\n            q2.enqueue([...first]);\\n        }\\n    }\\n    // 4. return the max room index\\n    let j;\\n    let max = 0;\\n    for(let i =0; i<n; i++){\\n        if(res[i] > max) {\\n            j = i;\\n            max = res[i];\\n        }\\n    }\\n    return j;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2527343,
                "title": "python-more-heap-extravaganza",
                "content": "We will keep a heap of available rooms and a keep of occupied rooms.\r\n\r\n* At the beginning the heap of available rooms includes all rooms. It will include only the room numbers\r\n* The heap of occupied rooms will include tuples `(endTime, roomNumber)`\r\n* For each meeting, we\r\n\t* Check if by the time it starts any meetings would have ended by that time, and free the corresponding rooms (making them available again).\r\n\t* Check if there is an available room\r\n\t\t* If not, we look at the next room that would get free and use that one, we recalculate the ending time of that meeting keeping the same duration\r\n\t\t* If yes, we assign the room. We make sure to increas the meeting count of the room.\r\n\r\nNote problem makes no mention about the start times being sorted, so we need to make sure to sorte them at first for this solution to work.\r\n\r\n&#8718;\r\n\r\n```python\r\nclass Solution:\r\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\r\n        meetings.sort() # make sure start times are sorted!!\r\n        \r\n        meetingCount = [0 for _ in range(n)]\r\n        availableRooms = list(range(n)); heapify(availableRooms)\r\n        occupiedRooms = []\r\n        \r\n        \r\n        for start, end in meetings:\r\n            while occupiedRooms and start >= occupiedRooms[0][0]:\r\n                heappush(availableRooms, heappop(occupiedRooms)[1]) # frees room and makes it available\r\n            \r\n            if availableRooms:\r\n                roomNumber = heappop(availableRooms)  # assigns next available room\r\n            else:\r\n                freedEnd, roomNumber = heappop(occupiedRooms)  # waits until the next room that would be available gets free\r\n                end += freedEnd - start\r\n            heappush(occupiedRooms, (end,roomNumber))  # make note that the ruom is occupied and when the assigned meeting ends\r\n            meetingCount[roomNumber] += 1  # update meeting counter\r\n            \r\n        return sorted([(count, i) for i, count in enumerate(meetingCount)], key = lambda x: (-x[0], x[1]))[0][1]  # find room with most meetings\r\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\r\nclass Solution:\r\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\r\n        meetings.sort() # make sure start times are sorted!!\r\n        \r\n        meetingCount = [0 for _ in range(n)]\r\n        availableRooms = list(range(n)); heapify(availableRooms)\r\n        occupiedRooms = []\r\n        \r\n        \r\n        for start, end in meetings:\r\n            while occupiedRooms and start >= occupiedRooms[0][0]:\r\n                heappush(availableRooms, heappop(occupiedRooms)[1]) # frees room and makes it available\r\n            \r\n            if availableRooms:\r\n                roomNumber = heappop(availableRooms)  # assigns next available room\r\n            else:\r\n                freedEnd, roomNumber = heappop(occupiedRooms)  # waits until the next room that would be available gets free\r\n                end += freedEnd - start\r\n            heappush(occupiedRooms, (end,roomNumber))  # make note that the ruom is occupied and when the assigned meeting ends\r\n            meetingCount[roomNumber] += 1  # update meeting counter\r\n            \r\n        return sorted([(count, i) for i, count in enumerate(meetingCount)], key = lambda x: (-x[0], x[1]))[0][1]  # find room with most meetings\r\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955536,
                "title": "easy-c-two-min-heaps-explained-in-comments",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        vector<int> rooms(n);\\n        int m = meetings.size();\\n        sort(meetings.begin(),meetings.end());\\n\\n        priority_queue<int,vector<int>,greater<int>>avail;\\n        // rooms available\\n\\n        for(int i =0;i<n;i++){\\n            avail.push(i);\\n        }\\n\\n        priority_queue<pair<long long ,int>,vector<pair<long long,int>>,greater<pair<long long ,int>>> inUse;\\n        // duration , room\\n\\n        for(auto m : meetings){\\n            while(!inUse.empty() && inUse.top().first <= m[0]){\\n                avail.push(inUse.top().second);\\n                inUse.pop();\\n            }\\n\\n            long long duration= m[1]-m[0];\\n            long long start ;\\n            if(avail.empty()){\\n                start = inUse.top().first;\\n            }else{\\n                start = m[0];\\n            }\\n\\n            int room = avail.empty() ? inUse.top().second : avail.top();\\n\\n            if(avail.empty()){\\n                inUse.pop();\\n            }else{\\n                avail.pop();\\n            }\\n            rooms[room]++;\\n\\n            inUse.push({start + duration , room});\\n        }\\n\\n        int maxi =0,ans=0;\\n        for(int i =0;i<n;i++){\\n            if(rooms[i]>maxi){\\n                maxi = rooms[i];\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        vector<int> rooms(n);\\n        int m = meetings.size();\\n        sort(meetings.begin(),meetings.end());\\n\\n        priority_queue<int,vector<int>,greater<int>>avail;\\n        // rooms available\\n\\n        for(int i =0;i<n;i++){\\n            avail.push(i);\\n        }\\n\\n        priority_queue<pair<long long ,int>,vector<pair<long long,int>>,greater<pair<long long ,int>>> inUse;\\n        // duration , room\\n\\n        for(auto m : meetings){\\n            while(!inUse.empty() && inUse.top().first <= m[0]){\\n                avail.push(inUse.top().second);\\n                inUse.pop();\\n            }\\n\\n            long long duration= m[1]-m[0];\\n            long long start ;\\n            if(avail.empty()){\\n                start = inUse.top().first;\\n            }else{\\n                start = m[0];\\n            }\\n\\n            int room = avail.empty() ? inUse.top().second : avail.top();\\n\\n            if(avail.empty()){\\n                inUse.pop();\\n            }else{\\n                avail.pop();\\n            }\\n            rooms[room]++;\\n\\n            inUse.push({start + duration , room});\\n        }\\n\\n        int maxi =0,ans=0;\\n        for(int i =0;i<n;i++){\\n            if(rooms[i]>maxi){\\n                maxi = rooms[i];\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854263,
                "title": "c-ordered-set-detailed-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs the questions asks about allocating rooms with minimum`room number`, we can think of using`Set`data structure which will store the end time of that meeting and the room number in which the meeting is being held.\\n`Set`will store the meetings which are currently being held.\\nAlso,`Map`data structure will store the count of meetings conducted in a specific room.\\nUse`LONG LONG` to avoid`signed integer overflow`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First, sort the given input so that we will get meetings in increasing order of their expected start time.\\n- Then, iterate on the`meetings`input.\\n- If current meeting\\'s start time is greater than the 1st element of`set`then, erase that element from`set` because it means that the meeting was  over and so, that room will become free to use now.\\n- If`set`has`0`elements then, the meeting will be conducted in room 0.\\n- If`set`has`n`elements which means that all rooms are currently occupied. Then, erase the first element from the`set`as this meeting will finish first and so new meeting will be held there.\\n- Else, find the minimum room number which is free so that the meeting can be conducted there.\\n- At each iteration,`map` will store whether room`i`is free or in use.\\nAlso, anothe`map`will store the count of meetings held in that specific room.\\n- Finally,`map`will give the room with maximum meetings held.\\n\\n\\n# Complexity\\n- Time complexity: O(m * log(m)) + O(m * log(n)) + O(n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(3 * n).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        sort(meetings.begin(), meetings.end());\\n        int m = meetings.size();\\n        map<long long, long long> mp, mpInd;\\n        set<pair<long long, long long>> st;\\n        for(int i = 0; i < m; ++i) {\\n            for(auto it: st) {\\n                long long time = it.first;\\n                long long room = it.second;\\n                if(time > meetings[i][0]) {\\n                    break;\\n                }\\n                // Make room free if end time is passed.\\n                mpInd.erase(room);\\n                st.erase(it);\\n            }\\n\\n            // All rooms are available to use. So use room 0.\\n            if(st.size() == 0) {\\n                st.insert({meetings[i][1], 0});\\n                mp[0]++;\\n                mpInd[0] = 1;\\n                continue;\\n            }\\n\\n            // All rooms are in use. So meeting will be held in room with smallest ending time.\\n            if(st.size() == n) {\\n                auto it = *(st.begin());\\n                long long time = it.first;\\n                long long room = it.second;\\n                st.erase(it);\\n                mp[room]++;\\n                st.insert({time + (meetings[i][1] - meetings[i][0]), room}); \\n            }\\n\\n            // Meeting will be held in room which is free having smallest room number.\\n            else {\\n                long long minInd = 0;\\n                for(auto it: mpInd) {\\n                    if(it.first != minInd) {\\n                        break;\\n                    }\\n                    minInd++;\\n                }\\n                mp[minInd]++;\\n                mpInd[minInd] = 1;\\n                st.insert({meetings[i][1], minInd});\\n            }\\n        }\\n\\n        // Answer will be room with maximum number of meetings.set\\n        long long ans = -1;\\n        int ind = -1;\\n        for(auto it: mp) {\\n            if(it.second > ans) {\\n                ans = it.second;\\n                ind = it.first;\\n            }\\n        }\\n\\n        return ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        sort(meetings.begin(), meetings.end());\\n        int m = meetings.size();\\n        map<long long, long long> mp, mpInd;\\n        set<pair<long long, long long>> st;\\n        for(int i = 0; i < m; ++i) {\\n            for(auto it: st) {\\n                long long time = it.first;\\n                long long room = it.second;\\n                if(time > meetings[i][0]) {\\n                    break;\\n                }\\n                // Make room free if end time is passed.\\n                mpInd.erase(room);\\n                st.erase(it);\\n            }\\n\\n            // All rooms are available to use. So use room 0.\\n            if(st.size() == 0) {\\n                st.insert({meetings[i][1], 0});\\n                mp[0]++;\\n                mpInd[0] = 1;\\n                continue;\\n            }\\n\\n            // All rooms are in use. So meeting will be held in room with smallest ending time.\\n            if(st.size() == n) {\\n                auto it = *(st.begin());\\n                long long time = it.first;\\n                long long room = it.second;\\n                st.erase(it);\\n                mp[room]++;\\n                st.insert({time + (meetings[i][1] - meetings[i][0]), room}); \\n            }\\n\\n            // Meeting will be held in room which is free having smallest room number.\\n            else {\\n                long long minInd = 0;\\n                for(auto it: mpInd) {\\n                    if(it.first != minInd) {\\n                        break;\\n                    }\\n                    minInd++;\\n                }\\n                mp[minInd]++;\\n                mpInd[minInd] = 1;\\n                st.insert({meetings[i][1], minInd});\\n            }\\n        }\\n\\n        // Answer will be room with maximum number of meetings.set\\n        long long ans = -1;\\n        int ind = -1;\\n        for(auto it: mp) {\\n            if(it.second > ans) {\\n                ans = it.second;\\n                ind = it.first;\\n            }\\n        }\\n\\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597258,
                "title": "c-simple-simulation-using-heap-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/meeting-rooms-iii/\\n    \\n    TC: O(nlogn (sorting) + nlogn (heap push/pop))\\n    SC: O(n)\\n    \\n    This is a simulation problem, where if there is a free room avail for use, then\\n    use it while trying to get the room with the lowest index. Otherwise, take the room\\n    where the ongoing meeting will end the earliest and if multiple rooms will be avail at the same\\n    time, pick the one with the lowest room index.\\n    While checking if a room is avail is free or not is trivial, it might not be trivial to simulate\\n    waiting for a room to get a avail room. For this we just pick the meeting room where the meeting will end the\\n    earliest as we would have waited for that long. Then since the current meeting would take place there and has already gotten\\n    delayed, update its end time accordingly.\\n    \\n    1. Sort the meetings by start time.\\n    2. We use min heap to keep track of busy {end_time, room_idx} and free rooms {room_idx}.\\n    3. Intially all the rooms are available for use.\\n    4. for each meeting:\\n        - Mark any meeting room free whose end time has passed the start of current meeting\\n        - If a room is avail, take it.\\n        - If a room is not avail, get the room with the earliest meeting end time, we will\\n            use this room.\\n            \\n    5. Find the most used room\\n*/\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // sort the meetings by the start time\\n        sort(meetings.begin(), meetings.end());\\n        \\n        // custom comparator: when the end time is same, pick the room with a \\n        // lower index\\n        auto comp = [&](const array<long long, 2>& a, const array<long long, 2>& b) {\\n            if(a[0] == b[0])\\n                return a[1] > b[1];\\n            return a[0] > b[0];\\n        };\\n        // Min heap of <meeting_end_time, room_id>\\n        priority_queue<array<long long, 2>, vector<array<long long, 2>>, decltype(comp)> busy_rooms(comp);\\n        \\n        // Min heap of <room_id>\\n        priority_queue<int, vector<int>, greater<int>> free_rooms;\\n        \\n        // <room_id, no_of_times_used>\\n        unordered_map<int, int> room_used;\\n        // tracks the most used room\\n        long long most_used = 0, most_used_room = 0;\\n        \\n        // Initially all the rooms are empty\\n        for(int room = 0; room < n; room++)\\n            free_rooms.push(room);\\n        \\n        for(auto meeting: meetings) {\\n            int start = meeting[0], end = meeting[1];\\n            \\n            // Check the update for all the busy rooms where the meeting have\\n            // finished and mark them available for use\\n            while(!busy_rooms.empty() && busy_rooms.top()[0] <= start) {\\n                int room = busy_rooms.top()[1];\\n                busy_rooms.pop();\\n                // mark the room as free again\\n                free_rooms.push(room);\\n            }\\n            \\n            // check if there is any vacant room for the meeting\\n            if(!free_rooms.empty()) {\\n                int room = free_rooms.top();\\n                free_rooms.pop();\\n                \\n                // mark the room as busy\\n                busy_rooms.push({end, room});\\n                ++room_used[room];\\n            } \\n            // all the rooms are busy. Pick the room where the meeting will end the earliest\\n            else {\\n                auto [meeting_end, room] = busy_rooms.top();\\n                busy_rooms.pop();\\n                \\n                // When the current ongoing meeting will end in the room, \\n                // this new meeting will start there after waiting for it to end\\n                // and hence its end time will also get delayed\\n                ++room_used[room];\\n                int duration = end - start;\\n                busy_rooms.push({meeting_end + duration, room});\\n            }\\n        }\\n        \\n        // find the most used room with lowest room index\\n        // if two rooms have the same freq count, pick the lower index one\\n        for(auto [room, used]: room_used) {\\n            if(used > most_used ||\\n              (used == most_used && room < most_used_room)) {\\n                most_used = room_used[room];\\n                most_used_room = room;\\n            }\\n        }\\n        return most_used_room;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/meeting-rooms-iii/\\n    \\n    TC: O(nlogn (sorting) + nlogn (heap push/pop))\\n    SC: O(n)\\n    \\n    This is a simulation problem, where if there is a free room avail for use, then\\n    use it while trying to get the room with the lowest index. Otherwise, take the room\\n    where the ongoing meeting will end the earliest and if multiple rooms will be avail at the same\\n    time, pick the one with the lowest room index.\\n    While checking if a room is avail is free or not is trivial, it might not be trivial to simulate\\n    waiting for a room to get a avail room. For this we just pick the meeting room where the meeting will end the\\n    earliest as we would have waited for that long. Then since the current meeting would take place there and has already gotten\\n    delayed, update its end time accordingly.\\n    \\n    1. Sort the meetings by start time.\\n    2. We use min heap to keep track of busy {end_time, room_idx} and free rooms {room_idx}.\\n    3. Intially all the rooms are available for use.\\n    4. for each meeting:\\n        - Mark any meeting room free whose end time has passed the start of current meeting\\n        - If a room is avail, take it.\\n        - If a room is not avail, get the room with the earliest meeting end time, we will\\n            use this room.\\n            \\n    5. Find the most used room\\n*/\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // sort the meetings by the start time\\n        sort(meetings.begin(), meetings.end());\\n        \\n        // custom comparator: when the end time is same, pick the room with a \\n        // lower index\\n        auto comp = [&](const array<long long, 2>& a, const array<long long, 2>& b) {\\n            if(a[0] == b[0])\\n                return a[1] > b[1];\\n            return a[0] > b[0];\\n        };\\n        // Min heap of <meeting_end_time, room_id>\\n        priority_queue<array<long long, 2>, vector<array<long long, 2>>, decltype(comp)> busy_rooms(comp);\\n        \\n        // Min heap of <room_id>\\n        priority_queue<int, vector<int>, greater<int>> free_rooms;\\n        \\n        // <room_id, no_of_times_used>\\n        unordered_map<int, int> room_used;\\n        // tracks the most used room\\n        long long most_used = 0, most_used_room = 0;\\n        \\n        // Initially all the rooms are empty\\n        for(int room = 0; room < n; room++)\\n            free_rooms.push(room);\\n        \\n        for(auto meeting: meetings) {\\n            int start = meeting[0], end = meeting[1];\\n            \\n            // Check the update for all the busy rooms where the meeting have\\n            // finished and mark them available for use\\n            while(!busy_rooms.empty() && busy_rooms.top()[0] <= start) {\\n                int room = busy_rooms.top()[1];\\n                busy_rooms.pop();\\n                // mark the room as free again\\n                free_rooms.push(room);\\n            }\\n            \\n            // check if there is any vacant room for the meeting\\n            if(!free_rooms.empty()) {\\n                int room = free_rooms.top();\\n                free_rooms.pop();\\n                \\n                // mark the room as busy\\n                busy_rooms.push({end, room});\\n                ++room_used[room];\\n            } \\n            // all the rooms are busy. Pick the room where the meeting will end the earliest\\n            else {\\n                auto [meeting_end, room] = busy_rooms.top();\\n                busy_rooms.pop();\\n                \\n                // When the current ongoing meeting will end in the room, \\n                // this new meeting will start there after waiting for it to end\\n                // and hence its end time will also get delayed\\n                ++room_used[room];\\n                int duration = end - start;\\n                busy_rooms.push({meeting_end + duration, room});\\n            }\\n        }\\n        \\n        // find the most used room with lowest room index\\n        // if two rooms have the same freq count, pick the lower index one\\n        for(auto [room, used]: room_used) {\\n            if(used > most_used ||\\n              (used == most_used && room < most_used_room)) {\\n                most_used = room_used[room];\\n                most_used_room = room;\\n            }\\n        }\\n        return most_used_room;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175593,
                "title": "easy-js-es6-dp-solution-with-detailed-comments-beats-92-5",
                "content": "# Complexity\\n- Time complexity:\\n**O(m * n)**\\n*Where is **m** for meetings and **n** for meeting rooms*\\n\\n- Space complexity:\\n**O(n)**\\n*Technically it\\'s O(n + n) for 2 arrays, but you know the rules :)*\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} meetings\\n * @return {number}\\n */\\nvar mostBooked = function(n, meetings) {\\n    // We will track the number of meetings for each room and room schedule to know\\n    // when each room will be free. All the rooms are available at time 0\\n    // and number of meetings for each room is 0\\n    let roomsMeetingsCount = Array(n).fill(0);\\n    let roomsSchedule = Array(n).fill(0);\\n\\n    // First of all, let\\'s sort meetings according to their start time\\n    meetings.sort((a,b) => a[0] - b[0]);\\n    \\n    // Looping over scheduled meetings we need to track start & end times,\\n    // number of the room that will be the earliest available (if there will not be\\n    // a free one), the time when the earliest room become available,\\n    // and the fact is whether we found the free room or not\\n    for (let i = 0; i < meetings.length; i += 1){\\n        let [start, end] = meetings[i];\\n        let earliestRoom = 0;\\n        let earliestTime = Infinity;\\n        let isFreeRoomFound = false;\\n\\n        // For each meeting, we will loop over all rooms to find a free one\\n        for (let j = 0; j < n; j += 1) {\\n            // If we find a free room, we will increase the counter of  meetings in\\n            // this room, note the time when the room will be free (meeting end time),\\n            // mark isFreeRoomFound flag as true to not to trigger the delay condition\\n            // in line 51, and also break the inner cycle (where we just found a room\\n            // for our meeting, so going to find the room for the next meeting)\\n            if (roomsSchedule[j] <= start) {\\n                roomsMeetingsCount[j] += 1;\\n                roomsSchedule[j] = end;\\n                isFreeRoomFound = true;\\n                break;\\n            }\\n\\n            // If we can\\'t find a free room let\\'s at the same time look at which one\\n            // will be free at the earliest and save its number\\n            if (roomsSchedule[j] < earliestTime) {\\n                earliestTime = roomsSchedule[j];\\n                earliestRoom = j;\\n            }\\n        }\\n\\n        // If we didn\\'t find the room, we will wait for the room that will be free\\n        // earlier, and also we need to move the time of our meeting, adding the\\n        // total duration to the schedule of the earliest free room\\n        if (isFreeRoomFound === false) {\\n            roomsMeetingsCount[earliestRoom] += 1;\\n            roomsSchedule[earliestRoom] += end - start;\\n        }\\n    }\\n\\n    // In the last step, we need to find the maximum number of meetings and remember\\n    // the number of the corresponding room with the most meetings to return it\\n    let maxMeetings = 0\\n    let numberOfRoomWithMostMeetings = 0;\\n\\n    for (let i = 0; i < n; i += 1) {\\n        if (roomsMeetingsCount[i] > maxMeetings) {\\n            maxMeetings = roomsMeetingsCount[i];\\n            numberOfRoomWithMostMeetings = i;\\n        }\\n    }\\n\\n    return numberOfRoomWithMostMeetings;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} meetings\\n * @return {number}\\n */\\nvar mostBooked = function(n, meetings) {\\n    // We will track the number of meetings for each room and room schedule to know\\n    // when each room will be free. All the rooms are available at time 0\\n    // and number of meetings for each room is 0\\n    let roomsMeetingsCount = Array(n).fill(0);\\n    let roomsSchedule = Array(n).fill(0);\\n\\n    // First of all, let\\'s sort meetings according to their start time\\n    meetings.sort((a,b) => a[0] - b[0]);\\n    \\n    // Looping over scheduled meetings we need to track start & end times,\\n    // number of the room that will be the earliest available (if there will not be\\n    // a free one), the time when the earliest room become available,\\n    // and the fact is whether we found the free room or not\\n    for (let i = 0; i < meetings.length; i += 1){\\n        let [start, end] = meetings[i];\\n        let earliestRoom = 0;\\n        let earliestTime = Infinity;\\n        let isFreeRoomFound = false;\\n\\n        // For each meeting, we will loop over all rooms to find a free one\\n        for (let j = 0; j < n; j += 1) {\\n            // If we find a free room, we will increase the counter of  meetings in\\n            // this room, note the time when the room will be free (meeting end time),\\n            // mark isFreeRoomFound flag as true to not to trigger the delay condition\\n            // in line 51, and also break the inner cycle (where we just found a room\\n            // for our meeting, so going to find the room for the next meeting)\\n            if (roomsSchedule[j] <= start) {\\n                roomsMeetingsCount[j] += 1;\\n                roomsSchedule[j] = end;\\n                isFreeRoomFound = true;\\n                break;\\n            }\\n\\n            // If we can\\'t find a free room let\\'s at the same time look at which one\\n            // will be free at the earliest and save its number\\n            if (roomsSchedule[j] < earliestTime) {\\n                earliestTime = roomsSchedule[j];\\n                earliestRoom = j;\\n            }\\n        }\\n\\n        // If we didn\\'t find the room, we will wait for the room that will be free\\n        // earlier, and also we need to move the time of our meeting, adding the\\n        // total duration to the schedule of the earliest free room\\n        if (isFreeRoomFound === false) {\\n            roomsMeetingsCount[earliestRoom] += 1;\\n            roomsSchedule[earliestRoom] += end - start;\\n        }\\n    }\\n\\n    // In the last step, we need to find the maximum number of meetings and remember\\n    // the number of the corresponding room with the most meetings to return it\\n    let maxMeetings = 0\\n    let numberOfRoomWithMostMeetings = 0;\\n\\n    for (let i = 0; i < n; i += 1) {\\n        if (roomsMeetingsCount[i] > maxMeetings) {\\n            maxMeetings = roomsMeetingsCount[i];\\n            numberOfRoomWithMostMeetings = i;\\n        }\\n    }\\n\\n    return numberOfRoomWithMostMeetings;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2776389,
                "title": "straightforward-javascript-solution",
                "content": "# Approach\\nUse two heaps, one for tracking available rooms and the other tracks for rooms that\\'s in use. Iterate through the list of meetings, for each one check if there\\'s existing room that can be used, if no, try to wait for the next available room. Meanwhile keeping track of the # of time each room is being used.\\n\\n# Complexity\\n- Time complexity: O(NLogN)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nvar mostBooked = function (n, meetings) {\\n    // sort meeting by start day then by end date\\n    meetings.sort((a, b) => a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]);\\n    // create a PQ sort by end time, and then by room\\n    const pq = new MinPriorityQueue({ compare: (a, b) => a[1] === b[1] ? a[2] > b[2] : a[1] > b[1] });\\n    let roomRecords = new Array(n).fill(0);\\n    let rooms = new MinPriorityQueue();\\n    for (let i = 0; i < n; i++) {\\n        rooms.enqueue(i);\\n    }\\n\\n    for (let [start, end] of meetings) {\\n        const duration = end - start;\\n        // ring ring allo room service\\n        while (pq.front()?.[1] <= start) {\\n            rooms.enqueue(pq.dequeue()[2]);\\n        }\\n\\n        // there\\'s room avaiable\\n        if (rooms.size() !== 0) {\\n            // find the lowest possible room\\n            const room = rooms.dequeue().element;\\n            pq.enqueue([start, end, room]);\\n            roomRecords[room]++;\\n            continue;\\n        }\\n\\n        // no room, look for next avaiable room\\n        let firstMeetingToEnd = pq.dequeue();\\n        const room = firstMeetingToEnd[2];\\n        pq.enqueue([firstMeetingToEnd[1], firstMeetingToEnd[1] + duration, room]);\\n        roomRecords[room]++;\\n    }\\n\\n    // find the room that hosted most meetings\\n    let res = -1;\\n    let max = -Infinity;\\n    for (let i = 0; i < roomRecords.length; i++) {\\n        if (max < roomRecords[i]) {\\n            res = i;\\n            max = roomRecords[i];\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mostBooked = function (n, meetings) {\\n    // sort meeting by start day then by end date\\n    meetings.sort((a, b) => a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]);\\n    // create a PQ sort by end time, and then by room\\n    const pq = new MinPriorityQueue({ compare: (a, b) => a[1] === b[1] ? a[2] > b[2] : a[1] > b[1] });\\n    let roomRecords = new Array(n).fill(0);\\n    let rooms = new MinPriorityQueue();\\n    for (let i = 0; i < n; i++) {\\n        rooms.enqueue(i);\\n    }\\n\\n    for (let [start, end] of meetings) {\\n        const duration = end - start;\\n        // ring ring allo room service\\n        while (pq.front()?.[1] <= start) {\\n            rooms.enqueue(pq.dequeue()[2]);\\n        }\\n\\n        // there\\'s room avaiable\\n        if (rooms.size() !== 0) {\\n            // find the lowest possible room\\n            const room = rooms.dequeue().element;\\n            pq.enqueue([start, end, room]);\\n            roomRecords[room]++;\\n            continue;\\n        }\\n\\n        // no room, look for next avaiable room\\n        let firstMeetingToEnd = pq.dequeue();\\n        const room = firstMeetingToEnd[2];\\n        pq.enqueue([firstMeetingToEnd[1], firstMeetingToEnd[1] + duration, room]);\\n        roomRecords[room]++;\\n    }\\n\\n    // find the room that hosted most meetings\\n    let res = -1;\\n    let max = -Infinity;\\n    for (let i = 0; i < roomRecords.length; i++) {\\n        if (max < roomRecords[i]) {\\n            res = i;\\n            max = roomRecords[i];\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2647449,
                "title": "simple-heap-sortledlist-solution-explained-python",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        #each meeting takes place in the unused room with lowest number\\n        #if this contraint wasnt present, 0 would always be the answer\\n        \\n        #all start values are unique\\n        meetings.sort() #sort by start time\\n        \\n        occupied = []\\n        available = SortedList(range(n)) #tbh you could have used another min heap for this\\n        counter = [0]*n #keep track of how many times a room is used\\n        \\n        for s,e in meetings:\\n            #if prev meetings have ended, make those rooms available again\\n            while occupied and occupied[0][0] <= s:\\n                _, room = heappop(occupied)\\n                available.add(room)\\n            \\n            if available:\\n                room = available.pop(0) #choose the unused room with lowest number\\n                heappush(occupied, (e, room))\\n                counter[room] += 1\\n            else:\\n                #find the meeting that ends the earliest\\n                earliestEnding, room = heappop(occupied)\\n                #meeting starts & ends, after a delay of earliestEnding - s\\n                heappush(occupied, (e+earliestEnding-s, room))\\n                counter[room] += 1\\n\\n        return max([(x, i) for i,x in enumerate(counter)], key=lambda x: (x[0], -x[1]))[1]\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        #each meeting takes place in the unused room with lowest number\\n        #if this contraint wasnt present, 0 would always be the answer\\n        \\n        #all start values are unique\\n        meetings.sort() #sort by start time\\n        \\n        occupied = []\\n        available = SortedList(range(n)) #tbh you could have used another min heap for this\\n        counter = [0]*n #keep track of how many times a room is used\\n        \\n        for s,e in meetings:\\n            #if prev meetings have ended, make those rooms available again\\n            while occupied and occupied[0][0] <= s:\\n                _, room = heappop(occupied)\\n                available.add(room)\\n            \\n            if available:\\n                room = available.pop(0) #choose the unused room with lowest number\\n                heappush(occupied, (e, room))\\n                counter[room] += 1\\n            else:\\n                #find the meeting that ends the earliest\\n                earliestEnding, room = heappop(occupied)\\n                #meeting starts & ends, after a delay of earliestEnding - s\\n                heappush(occupied, (e+earliestEnding-s, room))\\n                counter[room] += 1\\n\\n        return max([(x, i) for i,x in enumerate(counter)], key=lambda x: (x[0], -x[1]))[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587077,
                "title": "c-priority-queue-95-faster-than-all",
                "content": "```\\nclass Solution {\\npublic:\\n    using pi_t = std::pair<long, int>;\\n    \\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        \\n        if (n == 1)\\n            return 0;\\n        \\n        std::sort(meetings.begin(), meetings.end());\\n        \\n        std::priority_queue<pi_t, std::vector<pi_t>, std::greater<pi_t>> time_pq;\\n        std::priority_queue<int, std::vector<int>, std::greater<int>> room_pq;\\n        \\n        std::unordered_map<int, int> room_map;\\n        \\n        for (int i = 0; i < n; ++i)\\n        {\\n            room_pq.push(i);\\n            room_map[i] = 0;\\n        }\\n        \\n        for (auto &mt : meetings)\\n        {\\n            while (!time_pq.empty())\\n            {\\n                auto [t, idx] = time_pq.top();\\n                if (t <= mt[0])\\n                {\\n                    room_pq.push(idx);\\n                    time_pq.pop();\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            \\n            if (!room_pq.empty())\\n            {\\n                int idx = room_pq.top();\\n                room_pq.pop();\\n                \\n                time_pq.push({mt[1], idx});\\n                ++room_map[idx];\\n            }\\n            else\\n            {\\n                auto [t, idx] = time_pq.top();\\n                time_pq.pop();\\n                \\n                long t2 = t + mt[1] - mt[0];\\n                time_pq.push({t2, idx});\\n                \\n                ++room_map[idx];\\n            }\\n        }\\n        \\n        int room_num = 0;\\n        for (int i = 1; i < n; ++i)\\n        {\\n            if (room_map[i] > room_map[room_num])\\n            {\\n                room_num = i;\\n            }\\n        }\\n        return room_num;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    using pi_t = std::pair<long, int>;\\n    \\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        \\n        if (n == 1)\\n            return 0;\\n        \\n        std::sort(meetings.begin(), meetings.end());\\n        \\n        std::priority_queue<pi_t, std::vector<pi_t>, std::greater<pi_t>> time_pq;\\n        std::priority_queue<int, std::vector<int>, std::greater<int>> room_pq;\\n        \\n        std::unordered_map<int, int> room_map;\\n        \\n        for (int i = 0; i < n; ++i)\\n        {\\n            room_pq.push(i);\\n            room_map[i] = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2557080,
                "title": "python-the-roommanager-you-need-beats-99",
                "content": "`rooms` holds indices of free rooms\\n`booked` holds  `(end_time, room_index)` currently booked rooms and their ending times\\n`count` holds how many times each room has been booked\\n\\nWe do these steps:\\n1. Sort by starting times. \\n2. For each starting time `s`  we clear out all booked rooms which has finished before time `s`. \\n3.  If there is a free room we book the one with smallest index. (increment counter of booked room)\\n4.  Else we book the room which would end first. (increment counter of booked room)\\n5.  Return room which is visited the most.\\n\\n```\\nclass RoomManager:\\n    def __init__(self,n):\\n        self.rooms = [i for i in range(n)]\\n        heapify(self.rooms)\\n        self.booked = []\\n        self.count = [0]*n\\n\\n    def free_room(self):\\n        return self.rooms != []\\n        \\n    def book_room(self, end_time):\\n        if self.free_room():\\n            room = heappop(self.rooms)\\n            heappush(self.booked,(end_time,room))\\n            self.count[room] += 1\\n    \\n    def book_nearest(self,time):\\n        end_time,room = heappop(self.booked)\\n        heappush(self.booked,(end_time+time,room))\\n        self.count[room] += 1\\n\\n    def clear_booked(self,s):\\n        while self.booked and self.booked[0][0] <= s:\\n            e,r = heappop(self.booked)\\n            heappush(self.rooms,r)\\n        \\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort() # Step 1\\n        rm = RoomManager(n)\\n        for s,e in meetings:\\n            rm.clear_booked(s) # Step 2\\n            if rm.free_room(): \\n                rm.book_room(e) # Step 3\\n            else:\\n                rm.book_nearest(e-s) # Step 4\\n        return rm.count.index(max(rm.count)) # Step 5\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass RoomManager:\\n    def __init__(self,n):\\n        self.rooms = [i for i in range(n)]\\n        heapify(self.rooms)\\n        self.booked = []\\n        self.count = [0]*n\\n\\n    def free_room(self):\\n        return self.rooms != []\\n        \\n    def book_room(self, end_time):\\n        if self.free_room():\\n            room = heappop(self.rooms)\\n            heappush(self.booked,(end_time,room))\\n            self.count[room] += 1\\n    \\n    def book_nearest(self,time):\\n        end_time,room = heappop(self.booked)\\n        heappush(self.booked,(end_time+time,room))\\n        self.count[room] += 1\\n\\n    def clear_booked(self,s):\\n        while self.booked and self.booked[0][0] <= s:\\n            e,r = heappop(self.booked)\\n            heappush(self.rooms,r)\\n        \\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort() # Step 1\\n        rm = RoomManager(n)\\n        for s,e in meetings:\\n            rm.clear_booked(s) # Step 2\\n            if rm.free_room(): \\n                rm.book_room(e) # Step 3\\n            else:\\n                rm.book_nearest(e-s) # Step 4\\n        return rm.count.index(max(rm.count)) # Step 5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543888,
                "title": "python-2-solution-heap-and-linear-scan",
                "content": "1.\\n```\\nfrom heapq import heappush, heappop, heapify\\n\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        free, ocp = list(range(n)), []\\n        heapify(free)\\n        cnt = [0] * n\\n        for start, end in meetings:\\n            while ocp and ocp[0][0] <= start: heappush(free, heappop(ocp)[1])\\n            if free:\\n                idx = heappop(free)\\n                cnt[idx] += 1\\n                heappush(ocp, (end, idx))\\n            else:\\n                t, idx = heappop(ocp)\\n                cnt[idx] += 1\\n                heappush(ocp, (t + end - start, idx))\\n        ans = 0\\n        for i in range(n):\\n            if cnt[i] > cnt[ans]: ans = i\\n        return ans\\n```\\n2.\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        rooms, cnt = [0] * n, [0] * n\\n        for start, end in meetings:\\n            idx = -1\\n            for i in range(n):\\n                if rooms[i] <= start:\\n                    idx = i\\n                    break\\n                elif idx == -1 or rooms[i] < rooms[idx]: idx = i\\n            cnt[idx] += 1\\n            rooms[idx] = max(rooms[idx], start) + (end - start)\\n        ans = 0\\n        for i in range(n):\\n            if cnt[i] > cnt[ans]: ans = i\\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappush, heappop, heapify\\n\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        free, ocp = list(range(n)), []\\n        heapify(free)\\n        cnt = [0] * n\\n        for start, end in meetings:\\n            while ocp and ocp[0][0] <= start: heappush(free, heappop(ocp)[1])\\n            if free:\\n                idx = heappop(free)\\n                cnt[idx] += 1\\n                heappush(ocp, (end, idx))\\n            else:\\n                t, idx = heappop(ocp)\\n                cnt[idx] += 1\\n                heappush(ocp, (t + end - start, idx))\\n        ans = 0\\n        for i in range(n):\\n            if cnt[i] > cnt[ans]: ans = i\\n        return ans\\n```\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        rooms, cnt = [0] * n, [0] * n\\n        for start, end in meetings:\\n            idx = -1\\n            for i in range(n):\\n                if rooms[i] <= start:\\n                    idx = i\\n                    break\\n                elif idx == -1 or rooms[i] < rooms[idx]: idx = i\\n            cnt[idx] += 1\\n            rooms[idx] = max(rooms[idx], start) + (end - start)\\n        ans = 0\\n        for i in range(n):\\n            if cnt[i] > cnt[ans]: ans = i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538561,
                "title": "java-treeset-priority-queue-commented",
                "content": "Runtime: 135 ms, faster than 62.86% of Java online submissions for Meeting Rooms III.\\nMemory Usage: 149.7 MB, less than 16.90% of Java online submissions for Meeting Rooms III.\\n```\\nclass Solution {\\n  public int mostBooked(int n, int[][] meetings) {\\n    int ans[] = new int[n];                                                     //for numbers of usages \\n    PriorityQueue<int[]> ends = new PriorityQueue<>\\n      (n, (int[] o1, int[] o2) -> o2[0]!=o1[0] ? o1[0]-o2[0] : o1[1]-o2[1]);    //end , room   \\n    TreeSet<Integer> rooms = new TreeSet<>();                                   //for empty rooms\\n    for(int i = 0; i != n; i++) rooms.add(i);                                   //check all rooms as empty \\n    Arrays.sort(meetings, (int[] o1, int[] o2) -> o1[0] - o2[0]);               //sorting for minimal starts\\n  \\n    for(int[] m: meetings){\\n      while(!ends.isEmpty() && ends.peek()[0] <= m[0]) rooms.add(ends.poll()[1]);       //empty all rooms for current time\\n      \\n      if(!rooms.isEmpty()){                                          //if we have empty rooms\\n        int room = rooms.pollFirst();                                //fetch room with minimal number\\n        ans[room]++;                                                 //check it as used\\n        ends.add(new int[]{m[1], room});                             //and put it into queue\\n      }else{                                                     //if we not have any empty room \\n        int[] e = ends.poll();                                   //fetch from queue first room that will be empty \\n        ans[e[1]]++;                                             //and again use it (check it as used)\\n        ends.add(new int[]{e[0] + m[1] - m[0], e[1]});           //and reuse it with correct time\\n      } \\n    }\\n    \\n    int maxi = 0, id = -1;                          //fetch minimal index from array with numbers of usages\\n    for(int i = 0; i != n; i++)\\n      if(ans[i] > maxi) {maxi = ans[i]; id = i;}\\n    \\n    return id;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int mostBooked(int n, int[][] meetings) {\\n    int ans[] = new int[n];                                                     //for numbers of usages \\n    PriorityQueue<int[]> ends = new PriorityQueue<>\\n      (n, (int[] o1, int[] o2) -> o2[0]!=o1[0] ? o1[0]-o2[0] : o1[1]-o2[1]);    //end , room   \\n    TreeSet<Integer> rooms = new TreeSet<>();                                   //for empty rooms\\n    for(int i = 0; i != n; i++) rooms.add(i);                                   //check all rooms as empty \\n    Arrays.sort(meetings, (int[] o1, int[] o2) -> o1[0] - o2[0]);               //sorting for minimal starts\\n  \\n    for(int[] m: meetings){\\n      while(!ends.isEmpty() && ends.peek()[0] <= m[0]) rooms.add(ends.poll()[1]);       //empty all rooms for current time\\n      \\n      if(!rooms.isEmpty()){                                          //if we have empty rooms\\n        int room = rooms.pollFirst();                                //fetch room with minimal number\\n        ans[room]++;                                                 //check it as used\\n        ends.add(new int[]{m[1], room});                             //and put it into queue\\n      }else{                                                     //if we not have any empty room \\n        int[] e = ends.poll();                                   //fetch from queue first room that will be empty \\n        ans[e[1]]++;                                             //and again use it (check it as used)\\n        ends.add(new int[]{e[0] + m[1] - m[0], e[1]});           //and reuse it with correct time\\n      } \\n    }\\n    \\n    int maxi = 0, id = -1;                          //fetch minimal index from array with numbers of usages\\n    for(int i = 0; i != n; i++)\\n      if(ans[i] > maxi) {maxi = ans[i]; id = i;}\\n    \\n    return id;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2537260,
                "title": "the-art-of-using-heaps-priority-queue-made-the-problem-easy",
                "content": "Tiny detail to pay attention to: TLE if you do not add & (Ampersand) to parameters in the lambda in the sort. Because without ampersand, you are making tons of copies of vectors.\\n\\n```\\ntypedef long long LL;\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        sort(meetings.begin(), meetings.end(), [](vector<int> &v0, vector<int> &v1) { return v0[0] < v1[0]; });\\n        priority_queue<pair<LL, int>, vector<pair<LL, int>>, greater<pair<LL, int>>> used;\\n        priority_queue<int, vector<int>, greater<int>> unused;\\n        unordered_map<int, int> freq;\\n        for (int i = 0; i < n; ++ i) unused.emplace(i);\\n        for (auto &x : meetings) {\\n            int s = x[0], e = x[1];\\n            while (used.size() && used.top().first <= s) {\\n                int room = used.top().second;\\n                used.pop();\\n                unused.emplace(room);\\n            }\\n            if (unused.size()) {\\n                int room = unused.top(); unused.pop();\\n                used.emplace(e, room);\\n                ++ freq[room];\\n            } else {\\n                auto &meet = used.top();\\n                int room = meet.second;\\n                LL end = meet.first; used.pop();\\n                used.emplace(end + (e - s), room);\\n                ++ freq[room];\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 1; i < n; ++ i)\\n            if (freq[i] > freq[ans]) ans = i;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef long long LL;\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        sort(meetings.begin(), meetings.end(), [](vector<int> &v0, vector<int> &v1) { return v0[0] < v1[0]; });\\n        priority_queue<pair<LL, int>, vector<pair<LL, int>>, greater<pair<LL, int>>> used;\\n        priority_queue<int, vector<int>, greater<int>> unused;\\n        unordered_map<int, int> freq;\\n        for (int i = 0; i < n; ++ i) unused.emplace(i);\\n        for (auto &x : meetings) {\\n            int s = x[0], e = x[1];\\n            while (used.size() && used.top().first <= s) {\\n                int room = used.top().second;\\n                used.pop();\\n                unused.emplace(room);\\n            }\\n            if (unused.size()) {\\n                int room = unused.top(); unused.pop();\\n                used.emplace(e, room);\\n                ++ freq[room];\\n            } else {\\n                auto &meet = used.top();\\n                int room = meet.second;\\n                LL end = meet.first; used.pop();\\n                used.emplace(end + (e - s), room);\\n                ++ freq[room];\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 1; i < n; ++ i)\\n            if (freq[i] > freq[ans]) ans = i;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536297,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>&nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        set<int>s;\\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(i);\\n        }\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n       int mp[1001];\\n        memset(mp,0,sizeof(mp));\\n        for(auto &val:nums)\\n        {\\n            int start=val[0];\\n            int end=val[1];\\n            while(pq.size()&&pq.top().first<=start)\\n            {\\n                s.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            if(s.size())\\n            {\\n                int empty_room=*s.begin();\\n                s.erase(s.begin());\\n                mp[empty_room]++;\\n                pq.push({end,empty_room});\\n            }\\n            else\\n            {\\n                auto temp=pq.top();\\n                pq.pop();\\n                int empty_room=temp.second;\\n                mp[empty_room]++;\\n                pq.push({1ll*temp.first+(end-start),empty_room});\\n            }\\n        }\\n        int max_index=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[i]>mp[max_index])\\n            {\\n                max_index=i;\\n            }\\n        }\\n        return max_index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>&nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        set<int>s;\\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(i);\\n        }\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n       int mp[1001];\\n        memset(mp,0,sizeof(mp));\\n        for(auto &val:nums)\\n        {\\n            int start=val[0];\\n            int end=val[1];\\n            while(pq.size()&&pq.top().first<=start)\\n            {\\n                s.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            if(s.size())\\n            {\\n                int empty_room=*s.begin();\\n                s.erase(s.begin());\\n                mp[empty_room]++;\\n                pq.push({end,empty_room});\\n            }\\n            else\\n            {\\n                auto temp=pq.top();\\n                pq.pop();\\n                int empty_room=temp.second;\\n                mp[empty_room]++;\\n                pq.push({1ll*temp.first+(end-start),empty_room});\\n            }\\n        }\\n        int max_index=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[i]>mp[max_index])\\n            {\\n                max_index=i;\\n            }\\n        }\\n        return max_index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534040,
                "title": "c-solution-min-heap",
                "content": "```\\n#define ll                long long\\n#define fr                first\\n#define sc                second\\n#define pii               pair<ll,ll>\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) { \\n        int m = meetings.size();\\n        int maxc = INT_MIN, ans;\\n        vector<ll> cnt(n, 0);\\n        priority_queue<ll, vector<ll>, greater<ll>> room;\\n        priority_queue<pii, vector<pii>, greater<pii>> end;\\n        for(int i = 0; i < n; i++) room.push(i);\\n        sort(meetings.begin(), meetings.end());\\n        ll start = 0;\\n        for(auto v : meetings) {\\n            start = max(start, (ll)v[0]);\\n            while(!end.empty() && end.top().fr <= start) {\\n                pii p = end.top();\\n                end.pop();\\n                room.push(p.sc);\\n            }\\n            if(room.empty()) {\\n                pii p = end.top();\\n                end.pop();\\n                start = p.fr;\\n                room.push(p.sc);\\n            }\\n            int r = room.top();\\n            cnt[r]++;\\n            room.pop();\\n            end.push({v[1]+start-v[0], r});\\n            if(cnt[r] > maxc || (cnt[r] == maxc && r < ans)) {\\n                maxc = cnt[r];\\n                ans = r;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define ll                long long\\n#define fr                first\\n#define sc                second\\n#define pii               pair<ll,ll>\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) { \\n        int m = meetings.size();\\n        int maxc = INT_MIN, ans;\\n        vector<ll> cnt(n, 0);\\n        priority_queue<ll, vector<ll>, greater<ll>> room;\\n        priority_queue<pii, vector<pii>, greater<pii>> end;\\n        for(int i = 0; i < n; i++) room.push(i);\\n        sort(meetings.begin(), meetings.end());\\n        ll start = 0;\\n        for(auto v : meetings) {\\n            start = max(start, (ll)v[0]);\\n            while(!end.empty() && end.top().fr <= start) {\\n                pii p = end.top();\\n                end.pop();\\n                room.push(p.sc);\\n            }\\n            if(room.empty()) {\\n                pii p = end.top();\\n                end.pop();\\n                start = p.fr;\\n                room.push(p.sc);\\n            }\\n            int r = room.top();\\n            cnt[r]++;\\n            room.pop();\\n            end.push({v[1]+start-v[0], r});\\n            if(cnt[r] > maxc || (cnt[r] == maxc && r < ans)) {\\n                maxc = cnt[r];\\n                ans = r;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533346,
                "title": "ez-python-google-interview-question-2022-priority-queue-explained",
                "content": "```\\n\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        \"\"\"\\n            1. when rooms are available, take the room with lowest number and allote to person (use heap1)\\n            2. otherwise, pop lowest time ending room from ongoing meeting room, allote here  (use heap2)\\n        \"\"\"\\n        \\n        \\n        meetings.sort()\\n        ans = defaultdict(int)\\n\\n        \\n        ongoing_meetings = []\\n        free_rooms = list(range(n))\\n        \\n        for meeting_start, meeting_end in meetings:\\n            \\n            while ongoing_meetings and meeting_start >= ongoing_meetings[0][0]:\\n                # free the rooms\\n                _, freed_room = heappop(ongoing_meetings)\\n                heappush(free_rooms, freed_room)\\n            \\n            if free_rooms:\\n                # there is free room available\\n                meeting_room = heappop(free_rooms)\\n                heappush(ongoing_meetings, (meeting_end, meeting_room))\\n                ans[meeting_room] += 1\\n                \\n            else:\\n                # no free room.. keep popping all rooms which are less than curr time\\n                \\n                prev_meeting_end_time, meeting_room = heappop(ongoing_meetings)\\n                actual_end_time = (meeting_end - meeting_start) + prev_meeting_end_time\\n                heappush(ongoing_meetings, (actual_end_time, meeting_room))\\n                ans[meeting_room] += 1\\n        \\n            \\n        # now ans has info about {roomNumber: timesUsed}\\n        max_time = max(ans.values())\\n        for i in range(n+1):\\n            if ans[i] == max_time:\\n                return i\\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        \"\"\"\\n            1. when rooms are available, take the room with lowest number and allote to person (use heap1)\\n            2. otherwise, pop lowest time ending room from ongoing meeting room, allote here  (use heap2)\\n        \"\"\"\\n        \\n        \\n        meetings.sort()\\n        ans = defaultdict(int)\\n\\n        \\n        ongoing_meetings = []\\n        free_rooms = list(range(n))\\n        \\n        for meeting_start, meeting_end in meetings:\\n            \\n            while ongoing_meetings and meeting_start >= ongoing_meetings[0][0]:\\n                # free the rooms\\n                _, freed_room = heappop(ongoing_meetings)\\n                heappush(free_rooms, freed_room)\\n            \\n            if free_rooms:\\n                # there is free room available\\n                meeting_room = heappop(free_rooms)\\n                heappush(ongoing_meetings, (meeting_end, meeting_room))\\n                ans[meeting_room] += 1\\n                \\n            else:\\n                # no free room.. keep popping all rooms which are less than curr time\\n                \\n                prev_meeting_end_time, meeting_room = heappop(ongoing_meetings)\\n                actual_end_time = (meeting_end - meeting_start) + prev_meeting_end_time\\n                heappush(ongoing_meetings, (actual_end_time, meeting_room))\\n                ans[meeting_room] += 1\\n        \\n            \\n        # now ans has info about {roomNumber: timesUsed}\\n        max_time = max(ans.values())\\n        for i in range(n+1):\\n            if ans[i] == max_time:\\n                return i\\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532364,
                "title": "c-priority-queue-sortedset",
                "content": "```\\n    public int MostBooked(int n, int[][] meetings)\\n    {\\n        Array.Sort(meetings, (a, b) => a[0].CompareTo(b[0]));\\n        int[] roomsUsedCount = new int[n];\\n\\n        SortedSet<int> emptyRooms = new SortedSet<int>();\\n        for (int i = 0; i < n; i++)\\n            emptyRooms.Add(i);\\n\\n        //Room number - EndTime\\n        PriorityQueue<long[], long[]> pqUsedRooms = new PriorityQueue<long[], long[]>(Comparer<long[]>.Create((a, b) => a[1] == b[1] ? a[0].CompareTo(b[0]) : a[1].CompareTo(b[1])));\\n\\n        foreach (int[] meeting in meetings)\\n        {\\n            while (pqUsedRooms.Count > 0 && pqUsedRooms.Peek()[1] <= meeting[0])\\n            {\\n                long room = pqUsedRooms.Dequeue()[0];\\n                emptyRooms.Add((int)room);\\n            }\\n            if (emptyRooms.Count > 0)\\n            {\\n                int room = emptyRooms.Min();\\n                emptyRooms.Remove(room);\\n                roomsUsedCount[room]++;\\n                pqUsedRooms.Enqueue(new long[] { room, meeting[1] }, new long[] { room, meeting[1] });\\n            }\\n            else\\n            {\\n                long[] cur = pqUsedRooms.Dequeue();\\n                long room = cur[0];\\n                roomsUsedCount[room]++;\\n                long newEndtime = cur[1] + meeting[1] - meeting[0];\\n                pqUsedRooms.Enqueue(new long[] { room, newEndtime }, new long[] { room, newEndtime });\\n            }\\n        }\\n\\n        return Array.IndexOf(roomsUsedCount, roomsUsedCount.Max());\\n    }\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    public int MostBooked(int n, int[][] meetings)\\n    {\\n        Array.Sort(meetings, (a, b) => a[0].CompareTo(b[0]));\\n        int[] roomsUsedCount = new int[n];\\n\\n        SortedSet<int> emptyRooms = new SortedSet<int>();\\n        for (int i = 0; i < n; i++)\\n            emptyRooms.Add(i);\\n\\n        //Room number - EndTime\\n        PriorityQueue<long[], long[]> pqUsedRooms = new PriorityQueue<long[], long[]>(Comparer<long[]>.Create((a, b) => a[1] == b[1] ? a[0].CompareTo(b[0]) : a[1].CompareTo(b[1])));\\n\\n        foreach (int[] meeting in meetings)\\n        {\\n            while (pqUsedRooms.Count > 0 && pqUsedRooms.Peek()[1] <= meeting[0])\\n            {\\n                long room = pqUsedRooms.Dequeue()[0];\\n                emptyRooms.Add((int)room);\\n            }\\n            if (emptyRooms.Count > 0)\\n            {\\n                int room = emptyRooms.Min();\\n                emptyRooms.Remove(room);\\n                roomsUsedCount[room]++;\\n                pqUsedRooms.Enqueue(new long[] { room, meeting[1] }, new long[] { room, meeting[1] });\\n            }\\n            else\\n            {\\n                long[] cur = pqUsedRooms.Dequeue();\\n                long room = cur[0];\\n                roomsUsedCount[room]++;\\n                long newEndtime = cur[1] + meeting[1] - meeting[0];\\n                pqUsedRooms.Enqueue(new long[] { room, newEndtime }, new long[] { room, newEndtime });\\n            }\\n        }\\n\\n        return Array.IndexOf(roomsUsedCount, roomsUsedCount.Max());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2531303,
                "title": "c-two-heaps-solution",
                "content": "FYI: use **long EndTime** because of one disgusting test case that leads to integer overflow.\\n```\\npublic class Solution {\\n    public int MostBooked(int n, int[][] meetings) {\\n        var busy = new PriorityQueue<Room, Room>(new RoomComparer());\\n        var empty = new PriorityQueue<int, int>();\\n        \\n        for(int i = 0; i < n; i++)\\n            empty.Enqueue(i,i);\\n        \\n        Array.Sort(meetings, (a,b) => { return a[0] - b[0]; });\\n        \\n        int[] arr = new int[n];        \\n        for(int i = 0; i < meetings.Length; i++){\\n            int start = meetings[i][0];\\n            int end = meetings[i][1];\\n            \\n            while(busy.Count > 0 && busy.Peek().EndTime <= start){\\n                empty.Enqueue(busy.Peek().RoomNumber, busy.Dequeue().RoomNumber);\\n            }\\n            \\n            if(empty.Count > 0){\\n                arr[empty.Peek()]++;\\n                var r = new Room() { RoomNumber = empty.Dequeue(), EndTime = end };\\n                busy.Enqueue(r, r);\\n                \\n            } else{\\n                arr[busy.Peek().RoomNumber]++;\\n                var room = new Room() { RoomNumber = busy.Peek().RoomNumber, EndTime = end + busy.Dequeue().EndTime - start };\\n                busy.Enqueue(room, room);                \\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < arr.Length; i++){\\n            if(arr[i] > arr[res])\\n                res = i;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    class Room{\\n        public int RoomNumber { get; set; }\\n        public long EndTime { get; set; }\\n    }\\n    \\n    class RoomComparer : IComparer<Room>{\\n        public int Compare(Room a, Room b){\\n            if(a.EndTime == b.EndTime) {\\n                return a.RoomNumber.CompareTo(b.RoomNumber);\\n            }\\n            else\\n                return a.EndTime.CompareTo(b.EndTime);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MostBooked(int n, int[][] meetings) {\\n        var busy = new PriorityQueue<Room, Room>(new RoomComparer());\\n        var empty = new PriorityQueue<int, int>();\\n        \\n        for(int i = 0; i < n; i++)\\n            empty.Enqueue(i,i);\\n        \\n        Array.Sort(meetings, (a,b) => { return a[0] - b[0]; });\\n        \\n        int[] arr = new int[n];        \\n        for(int i = 0; i < meetings.Length; i++){\\n            int start = meetings[i][0];\\n            int end = meetings[i][1];\\n            \\n            while(busy.Count > 0 && busy.Peek().EndTime <= start){\\n                empty.Enqueue(busy.Peek().RoomNumber, busy.Dequeue().RoomNumber);\\n            }\\n            \\n            if(empty.Count > 0){\\n                arr[empty.Peek()]++;\\n                var r = new Room() { RoomNumber = empty.Dequeue(), EndTime = end };\\n                busy.Enqueue(r, r);\\n                \\n            } else{\\n                arr[busy.Peek().RoomNumber]++;\\n                var room = new Room() { RoomNumber = busy.Peek().RoomNumber, EndTime = end + busy.Dequeue().EndTime - start };\\n                busy.Enqueue(room, room);                \\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < arr.Length; i++){\\n            if(arr[i] > arr[res])\\n                res = i;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    class Room{\\n        public int RoomNumber { get; set; }\\n        public long EndTime { get; set; }\\n    }\\n    \\n    class RoomComparer : IComparer<Room>{\\n        public int Compare(Room a, Room b){\\n            if(a.EndTime == b.EndTime) {\\n                return a.RoomNumber.CompareTo(b.RoomNumber);\\n            }\\n            else\\n                return a.EndTime.CompareTo(b.EndTime);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529673,
                "title": "easy-well-commented-clean-code-c-priority-queue",
                "content": "```\\n#define pii pair<long long,long long>\\nclass Solution {\\npublic:\\n    int mostBooked(int n , vector<vector<int>>& nums) {\\n        sort(nums.begin() , nums.end());\\n        set<int> s; // to store available rooms\\n        priority_queue<pii , vector<pii> , greater<pii>> pq; // to store {end , room no.} of running meetings\\n        map<int,int> mp; // to store how many times a particular room is used\\n            \\n        for(int i = 0 ; i < n ; i++) // all the rooms will be available in the begining \\n            s.insert(i);\\n        \\n        for(auto x : nums){\\n            long long st = x[0];\\n            long long en = x[1];\\n            while(!pq.empty() and pq.top().first <= st){\\n                auto it = pq.top();\\n                pq.pop();\\n                s.insert(it.second); // insert the rooms which become free at this moment\\n            }\\n            \\n            if(s.empty()){ // if there are no rooms avaliable we will assign the closest room which will become free in future\\n                auto it = pq.top();\\n                pq.pop();\\n                long long diff = en - st; // time for which the meet will continue\\n                en = diff + it.first; // end time for the meeting after we will assign it to the future meet\\n                s.insert(it.second); // assuming it will become free insert it into the set\\n            }\\n            \\n            auto it = s.begin(); // first room that is free \\n            int free = (*it);\\n            \\n            mp[free]++;\\n            s.erase(it); // remove it from the set as it becomes occupied\\n            pq.push({en , free});\\n        }\\n        int ans , mx = INT_MIN;\\n        // now we will calculate the ans that is the most occupied room during the whole process\\n        for(auto x : mp){\\n            if(mx < x.second){\\n                mx = x.second;\\n                ans = x.first;\\n            }else if(mx == x.second){\\n                ans = min(ans , x.first);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\n#define pii pair<long long,long long>\\nclass Solution {\\npublic:\\n    int mostBooked(int n , vector<vector<int>>& nums) {\\n        sort(nums.begin() , nums.end());\\n        set<int> s; // to store available rooms\\n        priority_queue<pii , vector<pii> , greater<pii>> pq; // to store {end , room no.} of running meetings\\n        map<int,int> mp; // to store how many times a particular room is used\\n            \\n        for(int i = 0 ; i < n ; i++) // all the rooms will be available in the begining \\n            s.insert(i);\\n        \\n        for(auto x : nums){\\n            long long st = x[0];\\n            long long en = x[1];\\n            while(!pq.empty() and pq.top().first <= st){\\n                auto it = pq.top();\\n                pq.pop();\\n                s.insert(it.second); // insert the rooms which become free at this moment\\n            }\\n            \\n            if(s.empty()){ // if there are no rooms avaliable we will assign the closest room which will become free in future\\n                auto it = pq.top();\\n                pq.pop();\\n                long long diff = en - st; // time for which the meet will continue\\n                en = diff + it.first; // end time for the meeting after we will assign it to the future meet\\n                s.insert(it.second); // assuming it will become free insert it into the set\\n            }\\n            \\n            auto it = s.begin(); // first room that is free \\n            int free = (*it);\\n            \\n            mp[free]++;\\n            s.erase(it); // remove it from the set as it becomes occupied\\n            pq.push({en , free});\\n        }\\n        int ans , mx = INT_MIN;\\n        // now we will calculate the ans that is the most occupied room during the whole process\\n        for(auto x : mp){\\n            if(mx < x.second){\\n                mx = x.second;\\n                ans = x.first;\\n            }else if(mx == x.second){\\n                ans = min(ans , x.first);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529456,
                "title": "100-time-complexity-set-priorityqueue-c-comments",
                "content": "![image](https://assets.leetcode.com/users/images/553cff7c-e9a9-466f-97a4-036572ff83a1_1662288268.4134252.png)\\n\\n```\\n#define ll long long\\n#define pi pair<ll,ll>\\n\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& A) {\\n        vector<int> roomcnt(n,0);\\n        set<int> s;\\n        priority_queue<pi,vector<pi>,greater<pi>> q;\\n        sort(A.begin(),A.end());\\n        int m=A.size();\\n        // store available rooms\\n        for(int i=0;i<n;i++){\\n            s.insert(i);\\n        }\\n        for(int i=0;i<m;i++){\\n            ll start=A[i][0];\\n            ll end=A[i][1];\\n            // storing available room in set \\n            while(q.size()>0 && q.top().first<=start){\\n                int room=q.top().second;\\n                q.pop();\\n                s.insert(room);\\n            }\\n            // delaying the current meeting\\n            if(s.size()==0){\\n                pair<ll,ll> p=q.top();\\n                q.pop();\\n                ll dif=end-start;\\n                start=p.first;\\n                end=start+dif;\\n                s.insert(p.second);\\n            }\\n            // lowest number of unsed room available\\n            auto it=s.begin(); \\n            roomcnt[*it]++;\\n            // assign meeting to lowest avaible room\\n            q.push({end,*it});\\n            s.erase(*it);\\n        }\\n        int ans=0;\\n        int maxi=0;\\n        // find room with maximum meetings\\n        for(int i=0;i<n;i++){\\n            if(maxi<roomcnt[i]){\\n                maxi=roomcnt[i];\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\n#define ll long long\\n#define pi pair<ll,ll>\\n\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& A) {\\n        vector<int> roomcnt(n,0);\\n        set<int> s;\\n        priority_queue<pi,vector<pi>,greater<pi>> q;\\n        sort(A.begin(),A.end());\\n        int m=A.size();\\n        // store available rooms\\n        for(int i=0;i<n;i++){\\n            s.insert(i);\\n        }\\n        for(int i=0;i<m;i++){\\n            ll start=A[i][0];\\n            ll end=A[i][1];\\n            // storing available room in set \\n            while(q.size()>0 && q.top().first<=start){\\n                int room=q.top().second;\\n                q.pop();\\n                s.insert(room);\\n            }\\n            // delaying the current meeting\\n            if(s.size()==0){\\n                pair<ll,ll> p=q.top();\\n                q.pop();\\n                ll dif=end-start;\\n                start=p.first;\\n                end=start+dif;\\n                s.insert(p.second);\\n            }\\n            // lowest number of unsed room available\\n            auto it=s.begin(); \\n            roomcnt[*it]++;\\n            // assign meeting to lowest avaible room\\n            q.push({end,*it});\\n            s.erase(*it);\\n        }\\n        int ans=0;\\n        int maxi=0;\\n        // find room with maximum meetings\\n        for(int i=0;i<n;i++){\\n            if(maxi<roomcnt[i]){\\n                maxi=roomcnt[i];\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528064,
                "title": "meeting-rooms-iii",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define  pi  pair<ll,ll>\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n  set<ll>st;\\n     priority_queue <pi, vector<pi>, greater<pi>>pq;\\n         vector<ll>cnt(n,0);\\n         for(ll i=0;i<n;i++)\\n         {\\n              st.insert(i);\\n         }\\n    sort(meetings.begin(), meetings.end(),\\n     \\n        [](vector<int>&v1,vector<int>&v2) {\\n         return v1[0]<=v2[0];\\n         \\n        } \\n    );\\n     for(int i=0;i<meetings.size();i++)\\n     {\\n         ll start=meetings[i][0];\\n          ll end=meetings[i][1];\\n          ll duration=end-start;\\n         while(!pq.empty()&&pq.top().first<=meetings[i][0])\\n             {\\n              pi top=pq.top();\\n              pq.pop();\\n              st.insert(top.second);  \\n             }\\n        \\n         if(st.size()==0)\\n         {\\n    \\n              pi top=pq.top();\\n              pq.pop();   \\n              cnt[top.second]+=1;\\n              pq.push({top.first+duration,top.second});\\n              continue;\\n         }\\n      auto it=st.begin();\\n          ll f=*it;\\n          st.erase(f);\\n          cnt[f]+=1;\\n         pq.push({meetings[i][1],f});\\n         \\n     }\\n         return max_element(cnt.begin(),cnt.end())-cnt.begin();\\n    } \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define  pi  pair<ll,ll>\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n  set<ll>st;\\n     priority_queue <pi, vector<pi>, greater<pi>>pq;\\n         vector<ll>cnt(n,0);\\n         for(ll i=0;i<n;i++)\\n         {\\n              st.insert(i);\\n         }\\n    sort(meetings.begin(), meetings.end(),\\n     \\n        [](vector<int>&v1,vector<int>&v2) {\\n         return v1[0]<=v2[0];\\n         \\n        } \\n    );\\n     for(int i=0;i<meetings.size();i++)\\n     {\\n         ll start=meetings[i][0];\\n          ll end=meetings[i][1];\\n          ll duration=end-start;\\n         while(!pq.empty()&&pq.top().first<=meetings[i][0])\\n             {\\n              pi top=pq.top();\\n              pq.pop();\\n              st.insert(top.second);  \\n             }\\n        \\n         if(st.size()==0)\\n         {\\n    \\n              pi top=pq.top();\\n              pq.pop();   \\n              cnt[top.second]+=1;\\n              pq.push({top.first+duration,top.second});\\n              continue;\\n         }\\n      auto it=st.begin();\\n          ll f=*it;\\n          st.erase(f);\\n          cnt[f]+=1;\\n         pq.push({meetings[i][1],f});\\n         \\n     }\\n         return max_element(cnt.begin(),cnt.end())-cnt.begin();\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528058,
                "title": "two-priority-queues-and-mind-the-delay",
                "content": "```cpp\\nvector<int> room(n);\\npriority_queue<\\n\\tpair<long long, int>,\\n\\tvector<pair<long long, int>>, \\n\\tgreater<> > occupied;\\npriority_queue<int, vector<int>, greater<> > available;\\n\\n// there are n rooms available initially\\nfor (int i = 0; i < n; ++i)\\n\\tavailable.push(i);\\n\\n// sort the meetings\\nsort(begin(meetings), end(meetings));\\nlong long delay = 0;\\n\\n// for each meeting\\nfor (auto& x : meetings)\\n{\\n\\t// release all the finished rooms and put them into available queue\\n\\twhile (occupied.size() && occupied.top().first <= x[0])\\n\\t{\\n\\t\\tavailable.push(occupied.top().second);\\n\\t\\toccupied.pop();\\n\\t}\\n\\t\\n\\t// if there are no available room, this meeting will delay\\n\\tif (available.empty())\\n\\t{\\n\\t\\tdelay = occupied.top().first - x[0];\\n\\t\\tavailable.push(occupied.top().second);\\n\\t\\toccupied.pop();\\n\\t}\\n\\t// if there are some available rooms, this meeting is on schedule\\n\\telse\\n\\t{\\n\\t\\tdelay = 0;\\n\\t}\\n\\t\\n\\t// count the used room number\\n\\t++ room[available.top()];\\n\\toccupied.push({delay + x[1], available.top()});\\n\\tavailable.pop();\\n}\\n\\nreturn max_element(begin(room), end(room)) - begin(room);\\n```\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\nvector<int> room(n);\\npriority_queue<\\n\\tpair<long long, int>,\\n\\tvector<pair<long long, int>>, \\n\\tgreater<> > occupied;\\npriority_queue<int, vector<int>, greater<> > available;\\n\\n// there are n rooms available initially\\nfor (int i = 0; i < n; ++i)\\n\\tavailable.push(i);\\n\\n// sort the meetings\\nsort(begin(meetings), end(meetings));\\nlong long delay = 0;\\n\\n// for each meeting\\nfor (auto& x : meetings)\\n{\\n\\t// release all the finished rooms and put them into available queue\\n\\twhile (occupied.size() && occupied.top().first <= x[0])\\n\\t{\\n\\t\\tavailable.push(occupied.top().second);\\n\\t\\toccupied.pop();\\n\\t}\\n\\t\\n\\t// if there are no available room, this meeting will delay\\n\\tif (available.empty())\\n\\t{\\n\\t\\tdelay = occupied.top().first - x[0];\\n\\t\\tavailable.push(occupied.top().second);\\n\\t\\toccupied.pop();\\n\\t}\\n\\t// if there are some available rooms, this meeting is on schedule\\n\\telse\\n\\t{\\n\\t\\tdelay = 0;\\n\\t}\\n\\t\\n\\t// count the used room number\\n\\t++ room[available.top()];\\n\\toccupied.push({delay + x[1], available.top()});\\n\\tavailable.pop();\\n}\\n\\nreturn max_element(begin(room), end(room)) - begin(room);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2528001,
                "title": "rust-two-heap-solution",
                "content": "```\\nuse std::collections::BinaryHeap;\\nuse std::cmp::Reverse;\\nimpl Solution {\\n    pub fn most_booked(n: i32, mut meetings: Vec<Vec<i32>>) -> i32 {\\n        meetings.sort_unstable();\\n        let mut mts: BinaryHeap<Reverse<(i64, i32)>> = BinaryHeap::new();\\n        let mut rms = (0..n).map(|v| Reverse(v)).collect::<BinaryHeap<_>>();\\n        let mut cnt = vec![0; n as usize];\\n        \\n        for meeting in &meetings {\\n            let mut off = 0i64;\\n            while !mts.is_empty() && mts.peek().unwrap().0.0 <= meeting[0] as i64 {\\n                rms.push(Reverse(mts.pop().unwrap().0.1));\\n            }\\n            let mut r = if let Some(r) = rms.pop() {\\n                r.0\\n            } else {\\n                let p = mts.pop().unwrap().0;\\n                off = p.0 - meeting[0] as i64;\\n                p.1\\n            };\\n            cnt[r as usize] += 1;\\n            mts.push(Reverse((off + meeting[1] as i64, r)));\\n        }\\n\\t\\t// the max function by deafult returns the last max element if there is a tie.\\n        cnt.iter().enumerate().max_by_key(|(idx, &c)| (c, n as usize - idx)).unwrap().0 as i32 \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::BinaryHeap;\\nuse std::cmp::Reverse;\\nimpl Solution {\\n    pub fn most_booked(n: i32, mut meetings: Vec<Vec<i32>>) -> i32 {\\n        meetings.sort_unstable();\\n        let mut mts: BinaryHeap<Reverse<(i64, i32)>> = BinaryHeap::new();\\n        let mut rms = (0..n).map(|v| Reverse(v)).collect::<BinaryHeap<_>>();\\n        let mut cnt = vec![0; n as usize];\\n        \\n        for meeting in &meetings {\\n            let mut off = 0i64;\\n            while !mts.is_empty() && mts.peek().unwrap().0.0 <= meeting[0] as i64 {\\n                rms.push(Reverse(mts.pop().unwrap().0.1));\\n            }\\n            let mut r = if let Some(r) = rms.pop() {\\n                r.0\\n            } else {\\n                let p = mts.pop().unwrap().0;\\n                off = p.0 - meeting[0] as i64;\\n                p.1\\n            };\\n            cnt[r as usize] += 1;\\n            mts.push(Reverse((off + meeting[1] as i64, r)));\\n        }\\n\\t\\t// the max function by deafult returns the last max element if there is a tie.\\n        cnt.iter().enumerate().max_by_key(|(idx, &c)| (c, n as usize - idx)).unwrap().0 as i32 \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2527977,
                "title": "two-heap-python-solution",
                "content": "```\\nfrom heapq import heappop, heappush\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        free = []\\n        booked= []\\n        for i in range(n):\\n            free.append(i)\\n        heapify(free)\\n        meeting = [0]*n \\n        for start,end in meetings:\\n            #first remove the rooms that became free\\n            # print(free,booked)\\n            while booked and booked[0][0]<=start:\\n                endTime,room = heappop(booked)\\n                heappush(free,room)\\n            if free:\\n                room = heappop(free)\\n                meeting[room]+=1 \\n                heappush(booked,(end , room))\\n            else:\\n                endTime, room = heappop(booked)\\n                meeting[room]+=1\\n                heappush(booked,(endTime+end-start , room))\\n            # print(meeting)\\n        return meeting.index(max(meeting))\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappop, heappush\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        free = []\\n        booked= []\\n        for i in range(n):\\n            free.append(i)\\n        heapify(free)\\n        meeting = [0]*n \\n        for start,end in meetings:\\n            #first remove the rooms that became free\\n            # print(free,booked)\\n            while booked and booked[0][0]<=start:\\n                endTime,room = heappop(booked)\\n                heappush(free,room)\\n            if free:\\n                room = heappop(free)\\n                meeting[room]+=1 \\n                heappush(booked,(end , room))\\n            else:\\n                endTime, room = heappop(booked)\\n                meeting[room]+=1\\n                heappush(booked,(endTime+end-start , room))\\n            # print(meeting)\\n        return meeting.index(max(meeting))\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527817,
                "title": "java-142ms-super-simple-brute-force-solution-no-heap",
                "content": "There are 100 rooms at most, so no need to use heap at all. Another thing we need to notice is that the meetings have to happen in the start time order. Below is the code, very intuitive.\\n\\n```\\n    /*\\n    Runtime: 142 ms, faster than 50.00% of Java online submissions for Meeting Rooms III.\\n    Memory Usage: 139.6 MB, less than 12.50% of Java online submissions for Meeting Rooms III.\\n     */\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, Comparator.comparingInt(i -> i[0]));\\n\\n        int[] bookedCount = new int[n];\\n        long[] availableTimes = new long[n];\\n\\n        for (int[] meeting : meetings) {\\n            int room = findRoom(availableTimes, meeting[0]);\\n            long startTime = Math.max(meeting[0], availableTimes[room]);\\n            availableTimes[room] = startTime + meeting[1] - meeting[0];\\n            bookedCount[room]++;\\n        }\\n\\n        int mostBookedRoom = 0;\\n        for (int i = 1; i < bookedCount.length; i++) {\\n            if (bookedCount[i] > bookedCount[mostBookedRoom]) {\\n                mostBookedRoom = i;\\n            }\\n        }\\n\\n        return mostBookedRoom;\\n    }\\n\\n    private int findRoom(long[] availableTimes, int time) {\\n        int minAvailableRoom = 0;\\n        for (int i = 0; i < availableTimes.length; i++) {\\n            if (availableTimes[i] <= time) {\\n                return i;\\n            }\\n            if (availableTimes[i] < availableTimes[minAvailableRoom]) {\\n                minAvailableRoom = i;\\n            }\\n        }\\n\\n        return minAvailableRoom;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    /*\\n    Runtime: 142 ms, faster than 50.00% of Java online submissions for Meeting Rooms III.\\n    Memory Usage: 139.6 MB, less than 12.50% of Java online submissions for Meeting Rooms III.\\n     */\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, Comparator.comparingInt(i -> i[0]));\\n\\n        int[] bookedCount = new int[n];\\n        long[] availableTimes = new long[n];\\n\\n        for (int[] meeting : meetings) {\\n            int room = findRoom(availableTimes, meeting[0]);\\n            long startTime = Math.max(meeting[0], availableTimes[room]);\\n            availableTimes[room] = startTime + meeting[1] - meeting[0];\\n            bookedCount[room]++;\\n        }\\n\\n        int mostBookedRoom = 0;\\n        for (int i = 1; i < bookedCount.length; i++) {\\n            if (bookedCount[i] > bookedCount[mostBookedRoom]) {\\n                mostBookedRoom = i;\\n            }\\n        }\\n\\n        return mostBookedRoom;\\n    }\\n\\n    private int findRoom(long[] availableTimes, int time) {\\n        int minAvailableRoom = 0;\\n        for (int i = 0; i < availableTimes.length; i++) {\\n            if (availableTimes[i] <= time) {\\n                return i;\\n            }\\n            if (availableTimes[i] < availableTimes[minAvailableRoom]) {\\n                minAvailableRoom = i;\\n            }\\n        }\\n\\n        return minAvailableRoom;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2527686,
                "title": "o-nlogn-using-simulation-hashmap-binary-search-example-with-illustration",
                "content": "**Main Idea**:\\n+ **Sorting meeting**s with start time ascendant.\\n+ **Initializing** queue **rooms** comprising room information **(end_time, room) with (-1, room) sorting by end_time** ascendant.\\n+ **Initlializing** the number of used times in all rooms **used_room** with **0 value**. \\n+ Processing **meeting i from [0, n-1]**:\\n  + Poping choose_room in queue rooms with end_time<=start[i] and lowest number\\n  + **Increasing number of using choose_room by 1** in  **used_room**.\\n  + **Adding new agenda for choose_room** with **(end_time = start_time + duration[i], choose_room)** to queue **rooms** where  **start_time = min(start[i], end_time)**.\\n + **Returning the result with lowest room number getting higest using times** in **used_room array**.\\n\\n**Examples**:\\n```\\nExample 1: 4 [[2, 13], [3, 12], [7, 10], [17, 19], [18, 19]]\\n+ (i, meeting): (0, [2, 13]) rooms: [(-1, 0), (-1, 1), (-1, 2), (-1, 3)]\\n--> choose: (si,ei): 0 (2, 13) rooms: [(-1, 1), (-1, 2), (-1, 3), (13, 0)] used: [1, 0, 0, 0]\\n+ (i, meeting): (1, [3, 12]) rooms: [(-1, 1), (-1, 2), (-1, 3), (13, 0)]\\n--> choose: (si,ei): 1 (3, 12) rooms: [(-1, 2), (-1, 3), (12, 1), (13, 0)] used: [1, 1, 0, 0]\\n+ (i, meeting): (2, [7, 10]) rooms: [(-1, 2), (-1, 3), (12, 1), (13, 0)]\\n--> choose: (si,ei): 2 (7, 10) rooms: [(-1, 3), (10, 2), (12, 1), (13, 0)] used: [1, 1, 1, 0]\\n+ (i, meeting): (3, [17, 19]) rooms: [(-1, 3), (10, 2), (12, 1), (13, 0)]\\n--> choose: (si,ei): 0 (17, 19) rooms: [(-1, 3), (10, 2), (12, 1), (19, 0)] used: [2, 1, 1, 0]\\n+ (i, meeting): (4, [18, 19]) rooms: [(-1, 3), (10, 2), (12, 1), (19, 0)]\\n--> choose: (si,ei): 1 (18, 19) rooms: [(-1, 3), (10, 2), (19, 0), (19, 1)] used: [2, 2, 1, 0]\\nused: [2, 2, 1, 0] ans: 0\\n====================\\n\\nExample 2: 2 [[0, 10], [1, 5], [2, 7], [3, 4]]\\n+ (i, meeting): (0, [0, 10]) rooms: [(-1, 0), (-1, 1)]\\n--> choose: (si,ei): 0 (0, 10) rooms: [(-1, 1), (10, 0)] used: [1, 0]\\n+ (i, meeting): (1, [1, 5]) rooms: [(-1, 1), (10, 0)]\\n--> choose: (si,ei): 1 (1, 5) rooms: [(5, 1), (10, 0)] used: [1, 1]\\n+ (i, meeting): (2, [2, 7]) rooms: [(5, 1), (10, 0)]\\n--> choose: (si,ei): 1 (5, 10) rooms: [(10, 0), (10, 1)] used: [1, 2]\\n+ (i, meeting): (3, [3, 4]) rooms: [(10, 0), (10, 1)]\\n--> choose: (si,ei): 0 (10, 11) rooms: [(10, 1), (11, 0)] used: [2, 2]\\nused: [2, 2] ans: 0\\n====================\\n\\nExample 3: 3 [[1, 20], [2, 10], [3, 5], [4, 9], [6, 8]]\\n+ (i, meeting): (0, [1, 20]) rooms: [(-1, 0), (-1, 1), (-1, 2)]\\n--> choose: (si,ei): 0 (1, 20) rooms: [(-1, 1), (-1, 2), (20, 0)] used: [1, 0, 0]\\n+ (i, meeting): (1, [2, 10]) rooms: [(-1, 1), (-1, 2), (20, 0)]\\n--> choose: (si,ei): 1 (2, 10) rooms: [(-1, 2), (10, 1), (20, 0)] used: [1, 1, 0]\\n+ (i, meeting): (2, [3, 5]) rooms: [(-1, 2), (10, 1), (20, 0)]\\n--> choose: (si,ei): 2 (3, 5) rooms: [(5, 2), (10, 1), (20, 0)] used: [1, 1, 1]\\n+ (i, meeting): (3, [4, 9]) rooms: [(5, 2), (10, 1), (20, 0)]\\n--> choose: (si,ei): 2 (5, 10) rooms: [(10, 1), (10, 2), (20, 0)] used: [1, 1, 2]\\n+ (i, meeting): (4, [6, 8]) rooms: [(10, 1), (10, 2), (20, 0)]\\n--> choose: (si,ei): 1 (10, 12) rooms: [(10, 2), (12, 1), (20, 0)] used: [1, 2, 2]\\nused: [1, 2, 2] ans: 1\\n====================\\n```\\n\\n**Code**:\\n```\\nfrom sortedcontainers import SortedSet\\n\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        m = len(meetings)\\n        \\n        room_used = [0] * n\\n        rooms = SortedSet([(-1, i) for i in range(n)])\\n        \\n        meetings = sorted(meetings)\\n        \\n        for i in range(m):\\n            # print((i, meetings[i]), rooms, room_used)\\n            \\n            pi = rooms.bisect_right((meetings[i][0],n+1))\\n            pi = max(0, pi - 1)\\n            pmin = 0\\n            for ii in range(1, pi + 1):\\n                if rooms[pmin][1]>rooms[ii][1]:\\n                    pmin = ii\\n            \\n            end_time, choose_room = rooms[pmin]\\n            rooms.pop(pmin)\\n            room_used[choose_room] += 1\\n            \\n            si = max(end_time, meetings[i][0])\\n            ei = si + (meetings[i][1] - meetings[i][0])\\n            rooms.add((ei, choose_room))\\n            # print(\"-->\", pmin, choose_room, (i, si, ei), rooms)\\n        \\n        ans = 0\\n        for i in range(1, n):\\n            if room_used[ans]<room_used[i]:\\n                ans = i\\n        # print(room_used, ans)\\n        # print(\"=\" * 20)\\n        return ans\\n    \\n    \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Simulation"
                ],
                "code": "```\\nExample 1: 4 [[2, 13], [3, 12], [7, 10], [17, 19], [18, 19]]\\n+ (i, meeting): (0, [2, 13]) rooms: [(-1, 0), (-1, 1), (-1, 2), (-1, 3)]\\n--> choose: (si,ei): 0 (2, 13) rooms: [(-1, 1), (-1, 2), (-1, 3), (13, 0)] used: [1, 0, 0, 0]\\n+ (i, meeting): (1, [3, 12]) rooms: [(-1, 1), (-1, 2), (-1, 3), (13, 0)]\\n--> choose: (si,ei): 1 (3, 12) rooms: [(-1, 2), (-1, 3), (12, 1), (13, 0)] used: [1, 1, 0, 0]\\n+ (i, meeting): (2, [7, 10]) rooms: [(-1, 2), (-1, 3), (12, 1), (13, 0)]\\n--> choose: (si,ei): 2 (7, 10) rooms: [(-1, 3), (10, 2), (12, 1), (13, 0)] used: [1, 1, 1, 0]\\n+ (i, meeting): (3, [17, 19]) rooms: [(-1, 3), (10, 2), (12, 1), (13, 0)]\\n--> choose: (si,ei): 0 (17, 19) rooms: [(-1, 3), (10, 2), (12, 1), (19, 0)] used: [2, 1, 1, 0]\\n+ (i, meeting): (4, [18, 19]) rooms: [(-1, 3), (10, 2), (12, 1), (19, 0)]\\n--> choose: (si,ei): 1 (18, 19) rooms: [(-1, 3), (10, 2), (19, 0), (19, 1)] used: [2, 2, 1, 0]\\nused: [2, 2, 1, 0] ans: 0\\n====================\\n\\nExample 2: 2 [[0, 10], [1, 5], [2, 7], [3, 4]]\\n+ (i, meeting): (0, [0, 10]) rooms: [(-1, 0), (-1, 1)]\\n--> choose: (si,ei): 0 (0, 10) rooms: [(-1, 1), (10, 0)] used: [1, 0]\\n+ (i, meeting): (1, [1, 5]) rooms: [(-1, 1), (10, 0)]\\n--> choose: (si,ei): 1 (1, 5) rooms: [(5, 1), (10, 0)] used: [1, 1]\\n+ (i, meeting): (2, [2, 7]) rooms: [(5, 1), (10, 0)]\\n--> choose: (si,ei): 1 (5, 10) rooms: [(10, 0), (10, 1)] used: [1, 2]\\n+ (i, meeting): (3, [3, 4]) rooms: [(10, 0), (10, 1)]\\n--> choose: (si,ei): 0 (10, 11) rooms: [(10, 1), (11, 0)] used: [2, 2]\\nused: [2, 2] ans: 0\\n====================\\n\\nExample 3: 3 [[1, 20], [2, 10], [3, 5], [4, 9], [6, 8]]\\n+ (i, meeting): (0, [1, 20]) rooms: [(-1, 0), (-1, 1), (-1, 2)]\\n--> choose: (si,ei): 0 (1, 20) rooms: [(-1, 1), (-1, 2), (20, 0)] used: [1, 0, 0]\\n+ (i, meeting): (1, [2, 10]) rooms: [(-1, 1), (-1, 2), (20, 0)]\\n--> choose: (si,ei): 1 (2, 10) rooms: [(-1, 2), (10, 1), (20, 0)] used: [1, 1, 0]\\n+ (i, meeting): (2, [3, 5]) rooms: [(-1, 2), (10, 1), (20, 0)]\\n--> choose: (si,ei): 2 (3, 5) rooms: [(5, 2), (10, 1), (20, 0)] used: [1, 1, 1]\\n+ (i, meeting): (3, [4, 9]) rooms: [(5, 2), (10, 1), (20, 0)]\\n--> choose: (si,ei): 2 (5, 10) rooms: [(10, 1), (10, 2), (20, 0)] used: [1, 1, 2]\\n+ (i, meeting): (4, [6, 8]) rooms: [(10, 1), (10, 2), (20, 0)]\\n--> choose: (si,ei): 1 (10, 12) rooms: [(10, 2), (12, 1), (20, 0)] used: [1, 2, 2]\\nused: [1, 2, 2] ans: 1\\n====================\\n```\n```\\nfrom sortedcontainers import SortedSet\\n\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        m = len(meetings)\\n        \\n        room_used = [0] * n\\n        rooms = SortedSet([(-1, i) for i in range(n)])\\n        \\n        meetings = sorted(meetings)\\n        \\n        for i in range(m):\\n            # print((i, meetings[i]), rooms, room_used)\\n            \\n            pi = rooms.bisect_right((meetings[i][0],n+1))\\n            pi = max(0, pi - 1)\\n            pmin = 0\\n            for ii in range(1, pi + 1):\\n                if rooms[pmin][1]>rooms[ii][1]:\\n                    pmin = ii\\n            \\n            end_time, choose_room = rooms[pmin]\\n            rooms.pop(pmin)\\n            room_used[choose_room] += 1\\n            \\n            si = max(end_time, meetings[i][0])\\n            ei = si + (meetings[i][1] - meetings[i][0])\\n            rooms.add((ei, choose_room))\\n            # print(\"-->\", pmin, choose_room, (i, si, ei), rooms)\\n        \\n        ans = 0\\n        for i in range(1, n):\\n            if room_used[ans]<room_used[i]:\\n                ans = i\\n        # print(room_used, ans)\\n        # print(\"=\" * 20)\\n        return ans\\n    \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527557,
                "title": "where-does-this-logic-fail-passes-78-81-tc",
                "content": "I have used a set roomAvailable to get which smallest room is empty at the moment, waiting queue to pick the first meeting inserted into it and priority_queue pq to track the ending time of the ongoing meeting along with the room occupied to make it free later.\\nCan anyone please help me in figuring out where it goes wrong. Thank You.\\n\\n\\n```\\nint mostBooked(int n, vector<vector<int>>& meetings) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int len = meetings.size();\\n        set<int> roomAvailable;\\n        for(int i=0;i<n;i++)    roomAvailable.insert(i);\\n        queue<int> waiting;\\n        map<int,int> roomUsed;\\n        sort(meetings.begin(),meetings.end());\\n        int idx = 0;\\n        for(int time=0;time<=500001;time++) {\\n            //early exit\\n            if(idx == len && roomAvailable.size() == n && waiting.size() == 0) break;  \\n            //remove done task\\n            while(!pq.empty() && pq.top().first == time) {\\n                pair<int,int> cur = pq.top();\\n                int room = cur.second;\\n                roomAvailable.insert(room);\\n                pq.pop();\\n            }\\n            //assign to waiting\\n            while(idx<len && meetings[idx][0] == time) {\\n                waiting.push(meetings[idx][1] - meetings[idx][0]);\\n                idx++;\\n            }\\n            \\n            //pick from waiting\\n            //which room available\\n            while(roomAvailable.size() > 0 && waiting.size() > 0) {\\n                int meetTime = waiting.front();\\n                waiting.pop();\\n                int ra = *roomAvailable.begin();\\n                roomAvailable.erase(roomAvailable.begin());\\n                roomUsed[ra]++;\\n                pq.push({time+meetTime,ra});\\n            }\\n        }\\n       \\n        int maxi = 0;\\n        for(auto it:roomUsed) {\\n            maxi = max(maxi,it.second);\\n        }        \\n        int ans;\\n        for(auto it:roomUsed) {\\n            if(it.second == maxi)   return it.first;\\n        }",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "I have used a set roomAvailable to get which smallest room is empty at the moment, waiting queue to pick the first meeting inserted into it and priority_queue pq to track the ending time of the ongoing meeting along with the room occupied to make it free later.\\nCan anyone please help me in figuring out where it goes wrong. Thank You.\\n\\n\\n```\\nint mostBooked(int n, vector<vector<int>>& meetings) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int len = meetings.size();\\n        set<int> roomAvailable;\\n        for(int i=0;i<n;i++)    roomAvailable.insert(i);\\n        queue<int> waiting;\\n        map<int,int> roomUsed;\\n        sort(meetings.begin(),meetings.end());\\n        int idx = 0;\\n        for(int time=0;time<=500001;time++) {\\n            //early exit\\n            if(idx == len && roomAvailable.size() == n && waiting.size() == 0) break;  \\n            //remove done task\\n            while(!pq.empty() && pq.top().first == time) {\\n                pair<int,int> cur = pq.top();\\n                int room = cur.second;\\n                roomAvailable.insert(room);\\n                pq.pop();\\n            }\\n            //assign to waiting\\n            while(idx<len && meetings[idx][0] == time) {\\n                waiting.push(meetings[idx][1] - meetings[idx][0]);\\n                idx++;\\n            }\\n            \\n            //pick from waiting\\n            //which room available\\n            while(roomAvailable.size() > 0 && waiting.size() > 0) {\\n                int meetTime = waiting.front();\\n                waiting.pop();\\n                int ra = *roomAvailable.begin();\\n                roomAvailable.erase(roomAvailable.begin());\\n                roomUsed[ra]++;\\n                pq.push({time+meetTime,ra});\\n            }\\n        }\\n       \\n        int maxi = 0;\\n        for(auto it:roomUsed) {\\n            maxi = max(maxi,it.second);\\n        }        \\n        int ans;\\n        for(auto it:roomUsed) {\\n            if(it.second == maxi)   return it.first;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2527473,
                "title": "easy-solution-java",
                "content": "\\tclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings,(a,b)->a[0]-b[0]);\\n        LinkedList<long[]> list=new LinkedList<>();\\n        PriorityQueue<long[]> pq=new PriorityQueue<>((a,b)-> a[1]==b[1]? Long.compare(a[0],b[0]): Long.compare(a[1],b[1]));\\n        HashMap<Long,Integer> hm=new HashMap<>();\\n        for(int i=0;i<n;i++)\\n            pq.add(new long[]{i,0});\\n        for(int i=0;i<meetings.length;i++)\\n        {\\n            int curr[]=meetings[i];\\n            long end[]=pq.remove();\\n            long del=end[1]-curr[0];\\n            if(del>0)\\n            pq.add(new long[]{end[0],curr[1]+del});\\n            else\\n            {\\n                while(pq.size()>0 && pq.peek()[1]<=curr[0])\\n                {\\n                    long aa[]=pq.remove();\\n                    if(aa[0]<end[0])\\n                    {\\n                        list.add(new long[]{end[0],end[1]});\\n                        end[0]=aa[0];\\n                    }\\n                    else\\n                    {\\n                        list.add(new long[]{aa[0],aa[1]});\\n                    }\\n                }\\n                for(long m[]: list)\\n                    pq.add(m);\\n                list=new LinkedList<>();\\n                pq.add(new long[]{end[0],curr[1]});\\n            }\\n\\n            hm.put(end[0],hm.getOrDefault(end[0],0)+1);\\n            \\n        }\\n        long max=0,ans=0;\\n        for(long k:hm.keySet())\\n        {\\n            long s=hm.get(k);\\n            if(s>max)\\n            {\\n                max=hm.get(k);\\n                ans=k;\\n            }\\n            else if(s==max)\\n            {\\n                ans=Math.min(k,ans);\\n            }\\n            \\n        }\\n        return (int)ans;\\n    }\\n\\t}\\nPlease **Upvote** if you liked the solution.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings,(a,b)->a[0]-b[0]);\\n        LinkedList<long[]> list=new LinkedList<>();\\n        PriorityQueue<long[]> pq=new PriorityQueue<>((a,b)-> a[1]==b[1]? Long.compare(a[0],b[0]): Long.compare(a[1],b[1]));\\n        HashMap<Long,Integer> hm=new HashMap<>();\\n        for(int i=0;i<n;i++)\\n            pq.add(new long[]{i,0}",
                "codeTag": "Java"
            },
            {
                "id": 2527289,
                "title": "c-priorityqueue",
                "content": "```\\n        public int MostBooked(int n, int[][] meetings)\\n        {\\n            int res = 0;\\n            int[] arr = new int[n];\\n            meetings = meetings.OrderBy(x => x[0]).ToArray();//sort by start time\\n            //pq of room, store {index, endTime}, return min startTime with min index\\n            PriorityQueue<int[], int[]> pq = new PriorityQueue<int[], int[]>(\\n                Comparer<int[]>.Create((a, b) =>\\n                {\\n                    if (a[1] != b[1])\\n                        return a[1] - b[1];\\n                    else\\n                        return a[0] - b[0];\\n                }));\\n\\n            for(int i = 0; i < n; i++)\\n            {\\n                int[] curr = new int[] { i, 0 };//init pq, all element from 0\\n                pq.Enqueue(curr, curr);\\n            }\\n\\n            foreach(var m in meetings)\\n            {\\n                //if any element\\'s entTime < curr meeting\\'s startTime, update it\\n                while (pq.Peek()[1]< m[0])\\n                {\\n                    var curr = pq.Dequeue();\\n                    curr[1] = m[0];\\n                    pq.Enqueue(curr, curr);\\n                }\\n\\n                var top = pq.Dequeue();\\n                arr[top[0]]++;\\n                top[1] += m[1] - m[0];\\n                pq.Enqueue(top, top);\\n            }\\n\\n            int max = -1;\\n            for(int i = 0; i < n; i++)\\n            {\\n                if (arr[i] > max)\\n                {\\n                    max = arr[i];\\n                    res = i;\\n                }\\n            }\\n            return res;\\n        }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n        public int MostBooked(int n, int[][] meetings)\\n        {\\n            int res = 0;\\n            int[] arr = new int[n];\\n            meetings = meetings.OrderBy(x => x[0]).ToArray();//sort by start time\\n            //pq of room, store {index, endTime}, return min startTime with min index\\n            PriorityQueue<int[], int[]> pq = new PriorityQueue<int[], int[]>(\\n                Comparer<int[]>.Create((a, b) =>\\n                {\\n                    if (a[1] != b[1])\\n                        return a[1] - b[1];\\n                    else\\n                        return a[0] - b[0];\\n                }));\\n\\n            for(int i = 0; i < n; i++)\\n            {\\n                int[] curr = new int[] { i, 0 };//init pq, all element from 0\\n                pq.Enqueue(curr, curr);\\n            }\\n\\n            foreach(var m in meetings)\\n            {\\n                //if any element\\'s entTime < curr meeting\\'s startTime, update it\\n                while (pq.Peek()[1]< m[0])\\n                {\\n                    var curr = pq.Dequeue();\\n                    curr[1] = m[0];\\n                    pq.Enqueue(curr, curr);\\n                }\\n\\n                var top = pq.Dequeue();\\n                arr[top[0]]++;\\n                top[1] += m[1] - m[0];\\n                pq.Enqueue(top, top);\\n            }\\n\\n            int max = -1;\\n            for(int i = 0; i < n; i++)\\n            {\\n                if (arr[i] > max)\\n                {\\n                    max = arr[i];\\n                    res = i;\\n                }\\n            }\\n            return res;\\n        }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2527273,
                "title": "clean-python-one-heapq-set-solution-with-explanation",
                "content": "Compared to meeting room 1 and 2, the tricky part here is \"Each meeting will take place in the unused room with the lowest number.\" We can\\'t start with assigning each room with a meeting, but have to go in order. The `available` set is used for this purpose. Before scheduling each meeting, we update the available set by checking finished meetings.\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort(key=lambda x:x[0]) # sort by start time to meet requirement 3\\n        usage = [0] * n\\n        min_heap = [] # compare by end time\\n        available = set(range(n)) # keep track of unused rooms to meet requirement 1\\n        \\n        for start, end in meetings:\\n            while min_heap and min_heap[0][0] <= start:\\n                _, room = heapq.heappop(min_heap)\\n                available.add(room)\\n            delay = 0\\n            if available:\\n                room = min(available)\\n                available.remove(room)\\n            else:\\n                prev_end,room = heapq.heappop(min_heap)\\n                delay = prev_end-start # apply delay offset to meet requirement 2\\n            heapq.heappush(min_heap, (delay+end, room))\\n            usage[room] += 1\\n            \\n        most_used = max(usage)\\n        return usage.index(most_used)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort(key=lambda x:x[0]) # sort by start time to meet requirement 3\\n        usage = [0] * n\\n        min_heap = [] # compare by end time\\n        available = set(range(n)) # keep track of unused rooms to meet requirement 1\\n        \\n        for start, end in meetings:\\n            while min_heap and min_heap[0][0] <= start:\\n                _, room = heapq.heappop(min_heap)\\n                available.add(room)\\n            delay = 0\\n            if available:\\n                room = min(available)\\n                available.remove(room)\\n            else:\\n                prev_end,room = heapq.heappop(min_heap)\\n                delay = prev_end-start # apply delay offset to meet requirement 2\\n            heapq.heappush(min_heap, (delay+end, room))\\n            usage[room] += 1\\n            \\n        most_used = max(usage)\\n        return usage.index(most_used)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095597,
                "title": "easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a, b) -> a[0] - b[0]);\\n\\n\\t\\tlong[] rooms = new long[n];\\n        int[] cnt = new int[n];\\n        for(int[] meet: meetings){\\n            int start = meet[0]; int end = meet[1];\\n            int pos = 0;\\n\\n            for(int i=0; i<n; i++){\\n                //find position\\n                if(rooms[i] <= start){\\n                    pos = i;\\n                    break;\\n                }\\n                if(rooms[i] < rooms[pos]){\\n                    pos = i;\\n                }\\n            }\\n                //place rooms\\n                if(rooms[pos] <= start){\\n                    rooms[pos] = end;\\n                }\\n                else{\\n                    rooms[pos] += ((long)end-start);\\n                }\\n                cnt[pos]++ ;\\n        }\\n        int mx = 0;\\n        for(int i=0; i<n; i++){\\n            if(cnt[i] > cnt[mx])\\n            mx = i;\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a, b) -> a[0] - b[0]);\\n\\n\\t\\tlong[] rooms = new long[n];\\n        int[] cnt = new int[n];\\n        for(int[] meet: meetings){\\n            int start = meet[0]; int end = meet[1];\\n            int pos = 0;\\n\\n            for(int i=0; i<n; i++){\\n                //find position\\n                if(rooms[i] <= start){\\n                    pos = i;\\n                    break;\\n                }\\n                if(rooms[i] < rooms[pos]){\\n                    pos = i;\\n                }\\n            }\\n                //place rooms\\n                if(rooms[pos] <= start){\\n                    rooms[pos] = end;\\n                }\\n                else{\\n                    rooms[pos] += ((long)end-start);\\n                }\\n                cnt[pos]++ ;\\n        }\\n        int mx = 0;\\n        for(int i=0; i<n; i++){\\n            if(cnt[i] > cnt[mx])\\n            mx = i;\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070935,
                "title": "python3-2-heap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n2 heap problem\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nNPlogP\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNPlogP\\n# Code\\n```\\n# 2 heaps, a heap for busy and a heap for free. All rooms will be in free heap first\\n# busy heap will store (end_time, room_ind); free heap only need to know the room_ind\\n# for each meeting, pop out all rooms that have end_time <= current meeting start time,\\n# if free heap, then use the meeting on free heap, pop out and put into busy heap\\n# if free heap is empty, pick the busy heap with smallest end_time, pop and update the end_time again and throw into busy heap\\n# during this process, count the number of meetings when a room is arranged\\nimport heapq\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        free_heap, busy_heap = list(range(n)), []\\n        heapq.heapify(free_heap)\\n        room_meeting_counts = [0] * n\\n        for meeting in meetings:\\n            while busy_heap and busy_heap[0][0] <= meeting[0]:\\n                _, room_ind = heapq.heappop(busy_heap)\\n                heapq.heappush(free_heap, room_ind)\\n\\n            if free_heap:\\n                free_room_ind = heapq.heappop(free_heap)\\n                heapq.heappush(busy_heap, (meeting[1], free_room_ind))\\n                room_meeting_counts[free_room_ind] += 1\\n            else:\\n                earlist_free_time, room_ind = heapq.heappop(busy_heap)\\n                heapq.heappush(busy_heap, (earlist_free_time + meeting[1] - meeting[0], room_ind))\\n                room_meeting_counts[room_ind] += 1\\n        return room_meeting_counts.index(max(room_meeting_counts))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# 2 heaps, a heap for busy and a heap for free. All rooms will be in free heap first\\n# busy heap will store (end_time, room_ind); free heap only need to know the room_ind\\n# for each meeting, pop out all rooms that have end_time <= current meeting start time,\\n# if free heap, then use the meeting on free heap, pop out and put into busy heap\\n# if free heap is empty, pick the busy heap with smallest end_time, pop and update the end_time again and throw into busy heap\\n# during this process, count the number of meetings when a room is arranged\\nimport heapq\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        free_heap, busy_heap = list(range(n)), []\\n        heapq.heapify(free_heap)\\n        room_meeting_counts = [0] * n\\n        for meeting in meetings:\\n            while busy_heap and busy_heap[0][0] <= meeting[0]:\\n                _, room_ind = heapq.heappop(busy_heap)\\n                heapq.heappush(free_heap, room_ind)\\n\\n            if free_heap:\\n                free_room_ind = heapq.heappop(free_heap)\\n                heapq.heappush(busy_heap, (meeting[1], free_room_ind))\\n                room_meeting_counts[free_room_ind] += 1\\n            else:\\n                earlist_free_time, room_ind = heapq.heappop(busy_heap)\\n                heapq.heappush(busy_heap, (earlist_free_time + meeting[1] - meeting[0], room_ind))\\n                room_meeting_counts[room_ind] += 1\\n        return room_meeting_counts.index(max(room_meeting_counts))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045844,
                "title": "let-min-heap-do-all-the-work-for-you-just-pop-next-available-room",
                "content": "I was surpised to solve this problem without looking in the forum. It is somewhat straightforward when you rely on the min heap that just spits out the next available room. \\nTo solve this problem, we will use min heap that contains next available room id with the smalest availability start time. Rooms with the same availability time are sorted further by room id.\\nEach time we pop next room, we increment the counter that tracks how many times we used it, and put the room back into the heap but with a new availablility time. There are only two edge cases to look up:\\n1. Room is available earlier than meeting. In this case, some other room with the smaller number might become available later. As the result, when we see this happens, we adjust this room availability time and put it back on the heap (make it idle)\\n2. If room is late, we need to adjust next availability time for that room based on the meeting duration.\\n\\n```\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetingsCountPerRoom = Counter()\\n        \\n        # Time when room becomes available and room number\\n        availableRooms = [(0, i) for i in range(n)]\\n        heapq.heapify(availableRooms)\\n\\n        # sort meetings by start time\\n        meetings.sort(key=lambda meeting: meeting[0]) \\n        \\n        # go through each meeting and assign room\\n        for meetingStart, meetingEnd in meetings:\\n            # grab next room that becomes available\\n            roomStart, roomNumber = 0, 0\\n            while True:\\n                # check if room becomes available but meeting has not started yet\\n                # if so, make room idle in the queue. It is possible that when\\n                # meeting starts, the room with the lower number becomes available too\\n                roomStart, roomNumber = heapq.heappop(availableRooms)\\n                if roomStart >= meetingStart: break\\n                heapq.heappush(availableRooms, (meetingStart, roomNumber))\\n\\n            # we got the room. Increment how many times it was used and put it back into availabilty heap\\n            meetingsCountPerRoom[roomNumber] += 1\\n            # if room is late, make sure that meetingEnd reflects that\\n            if roomStart > meetingStart: meetingEnd += roomStart - meetingStart\\n            heapq.heappush(availableRooms, (meetingEnd, roomNumber))\\n\\n        return meetingsCountPerRoom.most_common(1)[-1][0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetingsCountPerRoom = Counter()\\n        \\n        # Time when room becomes available and room number\\n        availableRooms = [(0, i) for i in range(n)]\\n        heapq.heapify(availableRooms)\\n\\n        # sort meetings by start time\\n        meetings.sort(key=lambda meeting: meeting[0]) \\n        \\n        # go through each meeting and assign room\\n        for meetingStart, meetingEnd in meetings:\\n            # grab next room that becomes available\\n            roomStart, roomNumber = 0, 0\\n            while True:\\n                # check if room becomes available but meeting has not started yet\\n                # if so, make room idle in the queue. It is possible that when\\n                # meeting starts, the room with the lower number becomes available too\\n                roomStart, roomNumber = heapq.heappop(availableRooms)\\n                if roomStart >= meetingStart: break\\n                heapq.heappush(availableRooms, (meetingStart, roomNumber))\\n\\n            # we got the room. Increment how many times it was used and put it back into availabilty heap\\n            meetingsCountPerRoom[roomNumber] += 1\\n            # if room is late, make sure that meetingEnd reflects that\\n            if roomStart > meetingStart: meetingEnd += roomStart - meetingStart\\n            heapq.heappush(availableRooms, (meetingEnd, roomNumber))\\n\\n        return meetingsCountPerRoom.most_common(1)[-1][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4036635,
                "title": "c-2-min-heap",
                "content": "# Intuition\\nMin-Heap\\n\\n# Approach\\nUsing 2 Priority Queues\\n\\n# Complexity\\n- Time complexity:\\nAddition of \"N\" rooms - O(NlogN)\\nFor each meetings - Addition and deletion takes O(logM) + O(logN)\\nFor \"M\" meetings: M(O(logM) + O(logN))\\nFinal TC: O(NlogN) + M(O(logM) + O(logN))\\n\\n- Space complexity: O(M + N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        priority_queue<int, vector<int>, greater<int>> available;\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> busy;\\n        vector<int> room_count(n, 0);\\n        int room_no;\\n        sort(meetings.begin(), meetings.end());\\n\\n        for(int i=0;i<n; i++) available.push(i);\\n\\n        for(auto m:meetings) {\\n            long long int start = m[0];\\n            long long int end = m[1];\\n\\n            while(!busy.empty() && start >= busy.top().first) {\\n                available.push(busy.top().second);\\n                busy.pop();\\n            }\\n\\n            if(available.size() > 0) {\\n                room_no = available.top();\\n                available.pop();\\n                busy.push({end, room_no});\\n                room_count[room_no]++;\\n                continue;\\n            }\\n\\n            long long int next_end = busy.top().first;\\n            int next_room = busy.top().second;\\n            busy.pop();\\n            busy.push({next_end + (end-start), next_room});\\n            room_count[next_room]++;\\n        }\\n        return max_element(room_count.begin(), room_count.end()) - room_count.begin();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        priority_queue<int, vector<int>, greater<int>> available;\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> busy;\\n        vector<int> room_count(n, 0);\\n        int room_no;\\n        sort(meetings.begin(), meetings.end());\\n\\n        for(int i=0;i<n; i++) available.push(i);\\n\\n        for(auto m:meetings) {\\n            long long int start = m[0];\\n            long long int end = m[1];\\n\\n            while(!busy.empty() && start >= busy.top().first) {\\n                available.push(busy.top().second);\\n                busy.pop();\\n            }\\n\\n            if(available.size() > 0) {\\n                room_no = available.top();\\n                available.pop();\\n                busy.push({end, room_no});\\n                room_count[room_no]++;\\n                continue;\\n            }\\n\\n            long long int next_end = busy.top().first;\\n            int next_room = busy.top().second;\\n            busy.pop();\\n            busy.push({next_end + (end-start), next_room});\\n            room_count[next_room]++;\\n        }\\n        return max_element(room_count.begin(), room_count.end()) - room_count.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019588,
                "title": "a-clear-explanation-using-priority-queue",
                "content": "# Intuition\\nWhen seeing scheduler problems, I immediately think of using priority queue.\\n\\n# Approach\\nFor this problem, I need 3 priority queues: \\n1) meetings sorted by the meeting start time\\n2) available rooms sorted by the room number \\n3) occupided (pending) rooms sorted by a) the meeting end time and b) the room number.\\n\\nThere is also a process involving room releasing from pending rooms and adding to the available rooms. \\n\\n\\n# Complexity\\n- Time complexity: O(m(logn+logm)), m is the meetings size, n is the room size.\\n\\n- Space complexity: O(m+n)\\n\\n# Code\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        counts = [0]*n\\n        rooms = [i for i in range(n)]\\n        pending = []\\n        heapq.heapify(rooms)\\n        heapq.heapify(meetings)\\n        heapq.heapify(pending)\\n        \\n        while meetings:\\n            start, end = heapq.heappop(meetings)\\n            while pending and pending[0][0] <= start:\\n                old_end, room = heapq.heappop(pending)\\n                heapq.heappush(rooms, room)\\n            \\n            if rooms:\\n                room = heapq.heappop(rooms)\\n                heapq.heappush(pending, (end, room))\\n            else:\\n                old_end, room = heapq.heappop(pending)\\n                delta = old_end - start\\n                heapq.heappush(pending, (end+delta, room))\\n            \\n            counts[room] += 1\\n        \\n        max_count = max(counts)\\n        return counts.index(max_count)\\n    \\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        counts = [0]*n\\n        rooms = [i for i in range(n)]\\n        pending = []\\n        heapq.heapify(rooms)\\n        heapq.heapify(meetings)\\n        heapq.heapify(pending)\\n        \\n        while meetings:\\n            start, end = heapq.heappop(meetings)\\n            while pending and pending[0][0] <= start:\\n                old_end, room = heapq.heappop(pending)\\n                heapq.heappush(rooms, room)\\n            \\n            if rooms:\\n                room = heapq.heappop(rooms)\\n                heapq.heappush(pending, (end, room))\\n            else:\\n                old_end, room = heapq.heappop(pending)\\n                delta = old_end - start\\n                heapq.heappush(pending, (end+delta, room))\\n            \\n            counts[room] += 1\\n        \\n        max_count = max(counts)\\n        return counts.index(max_count)\\n    \\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000040,
                "title": "java-easy-to-understand-w-explanation",
                "content": "# Intuition\\nWe need to keep track of the lowest room number that is available. We have two possible ways this can happen:\\n1. Some previous meeting(s) has ended freeing up rooms \\n2. We have available rooms \\n3. if none of 1 & 2 is true, we will have to wait until the meeting with the earliest end time to end before filling up the room. \\n \\n# Approach\\nUsing two heaps:\\n- Available: to keep track of rooms that have freed up\\n- Occupied: to keep track of ongoing meetings\\nFor each meeting, we just need to check the three conditions mentioned above in order. \\n\\nUsing the array res to keep track of frequency\\n\\n# Complexity\\nm: meetings, n= rooms\\n- Time complexity:\\nO(m log m)\\n\\n- Space complexity:\\nO(n+m)\\n\\n# Code\\n```\\nclass Room {\\n    int num, endTime;\\n    public Room(int num){\\n        this.num = num;\\n    }\\n}\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        int[] res = new int[n];\\n        Arrays.sort(meetings, new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b){\\n                if(a[0]==b[0]) return a[1]-b[1];\\n                return a[0]-b[0];\\n            }\\n        });\\n        Comparator<Room> availComp = new Comparator<>(){\\n            public int compare(Room a, Room b){\\n                return a.num-b.num;\\n            }\\n        };\\n        Comparator<Room> occuComp = new Comparator<>(){\\n            public int compare(Room a, Room b){\\n                if(a.endTime == b.endTime)\\n                    return a.num-b.num;\\n                return a.endTime-b.endTime;\\n            }\\n        };\\n        PriorityQueue<Room> available = new PriorityQueue<>(availComp);\\n        PriorityQueue<Room> occupied = new PriorityQueue<>(occuComp);\\n        for(int i=0; i<n; i++) available.add(new Room(i));\\n        for(int[] meeting : meetings){\\n            Room toAdd = null;\\n            while(!occupied.isEmpty() && occupied.peek().endTime<=meeting[0]){\\n                Room removed = occupied.poll();\\n                removed.endTime = 0;\\n                available.add(removed);\\n            }\\n            if(!available.isEmpty()) {\\n                toAdd = available.poll();\\n                toAdd.endTime = meeting[1];\\n            }\\n            else {\\n                Room toRemove = occupied.poll();\\n                toAdd = new Room(toRemove.num);\\n                toAdd.endTime = toRemove.endTime+(meeting[1]-meeting[0]);\\n            }\\n            occupied.add(toAdd);\\n            res[toAdd.num]++;\\n        }\\n        int result = 0;\\n        for(int i=0; i<res.length; i++){\\n            if(res[i]>res[result]) result = i;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Room {\\n    int num, endTime;\\n    public Room(int num){\\n        this.num = num;\\n    }\\n}\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        int[] res = new int[n];\\n        Arrays.sort(meetings, new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b){\\n                if(a[0]==b[0]) return a[1]-b[1];\\n                return a[0]-b[0];\\n            }\\n        });\\n        Comparator<Room> availComp = new Comparator<>(){\\n            public int compare(Room a, Room b){\\n                return a.num-b.num;\\n            }\\n        };\\n        Comparator<Room> occuComp = new Comparator<>(){\\n            public int compare(Room a, Room b){\\n                if(a.endTime == b.endTime)\\n                    return a.num-b.num;\\n                return a.endTime-b.endTime;\\n            }\\n        };\\n        PriorityQueue<Room> available = new PriorityQueue<>(availComp);\\n        PriorityQueue<Room> occupied = new PriorityQueue<>(occuComp);\\n        for(int i=0; i<n; i++) available.add(new Room(i));\\n        for(int[] meeting : meetings){\\n            Room toAdd = null;\\n            while(!occupied.isEmpty() && occupied.peek().endTime<=meeting[0]){\\n                Room removed = occupied.poll();\\n                removed.endTime = 0;\\n                available.add(removed);\\n            }\\n            if(!available.isEmpty()) {\\n                toAdd = available.poll();\\n                toAdd.endTime = meeting[1];\\n            }\\n            else {\\n                Room toRemove = occupied.poll();\\n                toAdd = new Room(toRemove.num);\\n                toAdd.endTime = toRemove.endTime+(meeting[1]-meeting[0]);\\n            }\\n            occupied.add(toAdd);\\n            res[toAdd.num]++;\\n        }\\n        int result = 0;\\n        for(int i=0; i<res.length; i++){\\n            if(res[i]>res[result]) result = i;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994140,
                "title": "python3-simple-2-heap-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n2 Heaps to keep track of busy and available rooms\\n# Complexity\\n- Time complexity: $$O(n\\\\log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom heapq import heapify, heappop ,heappush\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        # 2 heap approachs\\n        # (end_time , room_num)\\n        busy = []\\n        # room_num\\n        available = [i for i in range(n)]\\n        output = [0] * n\\n        heapify(available)\\n        for start, end in meetings:\\n            while busy and busy[0][0] <= start:\\n                heappush(available,heappop(busy)[1])\\n            # have some room for this meeting now\\n            if len(available) > 0:\\n                room_num = heappop(available)\\n                output[room_num] += 1\\n                heappush(busy,(end,room_num))\\n            else: # no room to use\\n                room = heappop(busy)\\n                output[room[1]] += 1\\n                heappush(busy,(room[0]+(end-start),room[1]))\\n        return output.index(max(output))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heapify, heappop ,heappush\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        # 2 heap approachs\\n        # (end_time , room_num)\\n        busy = []\\n        # room_num\\n        available = [i for i in range(n)]\\n        output = [0] * n\\n        heapify(available)\\n        for start, end in meetings:\\n            while busy and busy[0][0] <= start:\\n                heappush(available,heappop(busy)[1])\\n            # have some room for this meeting now\\n            if len(available) > 0:\\n                room_num = heappop(available)\\n                output[room_num] += 1\\n                heappush(busy,(end,room_num))\\n            else: # no room to use\\n                room = heappop(busy)\\n                output[room[1]] += 1\\n                heappush(busy,(room[0]+(end-start),room[1]))\\n        return output.index(max(output))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978431,
                "title": "java-heap-solution-67ms-runtime-beats-89-32-memory-beats-97-59",
                "content": "# Intuition\\nMy first thought is to use a greedy approach to allocate rooms. Specifically, for each incoming meeting request, I\\'ll try to place it in the earliest available room. This would require me to keep track of the end times of meetings currently being hosted in all rooms.\\n\\nPriority queues come to mind for maintaining this information, as they allow efficient retrieval of the minimum endtime, i.e. the rooms that will get free the earliest. Sorting the meetings by their start time is also crucial, as we are looking at a chronological order of events.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. **Sort Meetings:**\\nSort all the meetings by their start times. This helps to simulate the real-world scenario where meetings are scheduled in chronological order.\\n2. **Initialize Data Structures:**\\n- `int[] room_usage`: An array to keep track of how many meetings are booked in each room.\\n- `boolean[] occupying`: An array to keep track of which rooms are currently being used.\\n- `PriorityQueue<Event> pq`: To maintain the end times of ongoing meetings and thus to easily find the next available room.\\n- `Queue<Integer> waiting`: A queue to hold meetings that could not be scheduled immediately due to all rooms being occupied.\\n3. **Iterate through Meetings:**\\n- For each meeting, check if any ongoing meeting has ended, and accordingly update the PriorityQueue and occupying arrays.\\n- Try to allocate a room for the current meeting. If no rooms are available, place the meeting in the waiting queue.\\n4. **Handle Waiting Queue:**\\nAfter going through all the meetings, if there are any meetings left in the waiting queue, allocate rooms for them based on room availability.\\n5. **Find Most Booked Room:**\\nFinally, loop through the room_usage array to find the room with the maximum bookings.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(mn + mlogm)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m + n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        // Sort the meetings by starting time\\n        Arrays.sort(meetings, new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] row1, int[] row2){\\n                return row1[0] - row2[0];\\n            }\\n        });\\n\\n        int[] room_usage = new int[n]; // track room usage\\n        boolean[] occupying = new boolean[n]; // track which rooms are used now\\n        int occupying_count = 0; // track whether rooms are full\\n        PriorityQueue<Event> pq = new PriorityQueue<>(); // track the on-going meetings, sort based on end time\\n        Queue<Integer> waiting = new LinkedList<>(); // track the delayed meetings \\n        for(int[] meeting : meetings){\\n            while(!pq.isEmpty()){\\n                // constantly polling earlier end time (comparing with the current start time)\\n                if(pq.peek().end <= meeting[0]){\\n                    Event e = pq.poll();\\n                    // if some meeting is waiting\\n                    if(!waiting.isEmpty()){\\n                        pq.add(new Event(e.end + waiting.poll(), e.room));\\n                        room_usage[e.room]++;\\n                    }\\n                    // if no meeting waiting\\n                    else{\\n                        occupying[e.room] = false;\\n                        occupying_count--;\\n                    }\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n\\n            // if exist empty meeting room\\n            if(occupying_count < n){\\n                for(int i = 0; i < n; i++){\\n                    // find it\\n                    if(!occupying[i]){\\n                        occupying[i] = true;\\n                        occupying_count++;\\n                        pq.add(new Event(meeting[1], i));\\n                        room_usage[i]++;\\n                        break;\\n                    }\\n                }\\n            } \\n            // if full, add the meeting to the waitlist, we only need to know the duration\\n            else{\\n                waiting.add(meeting[1]-meeting[0]);\\n            }\\n        }\\n\\n        // after dealing with all events in the first for-loop, deal with the ones in waitlist\\n        while(!pq.isEmpty()){\\n            Event e = pq.poll();\\n            if(!waiting.isEmpty()){\\n                pq.add(new Event(e.end + waiting.poll(), e.room));\\n                room_usage[e.room]++;\\n            }\\n            // this else statement doesn\\'t affect the correctness\\n            else{\\n                occupying[e.room] = false;\\n                occupying_count--;\\n            }\\n        }\\n        \\n        // loop to check the max room usage\\n        int res = -1;\\n        int max_usage = -1;\\n        for(int i = 0; i < room_usage.length; i++){\\n            if(room_usage[i] > max_usage){\\n                res = i;\\n                max_usage = room_usage[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\nclass Event implements Comparable<Event>{\\n    int end;\\n    int room;\\n    public Event(int e, int r){\\n        end = e;\\n        room = r;\\n    }\\n\\n    @Override\\n    public int compareTo(Event other){\\n        // added this room comparason to deal with test case 81, 82\\n        if(this.end == other.end){\\n            return (int)(this.room-other.room);\\n        }\\n        else{\\n            return (int)(this.end - other.end);\\n        } \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        // Sort the meetings by starting time\\n        Arrays.sort(meetings, new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] row1, int[] row2){\\n                return row1[0] - row2[0];\\n            }\\n        });\\n\\n        int[] room_usage = new int[n]; // track room usage\\n        boolean[] occupying = new boolean[n]; // track which rooms are used now\\n        int occupying_count = 0; // track whether rooms are full\\n        PriorityQueue<Event> pq = new PriorityQueue<>(); // track the on-going meetings, sort based on end time\\n        Queue<Integer> waiting = new LinkedList<>(); // track the delayed meetings \\n        for(int[] meeting : meetings){\\n            while(!pq.isEmpty()){\\n                // constantly polling earlier end time (comparing with the current start time)\\n                if(pq.peek().end <= meeting[0]){\\n                    Event e = pq.poll();\\n                    // if some meeting is waiting\\n                    if(!waiting.isEmpty()){\\n                        pq.add(new Event(e.end + waiting.poll(), e.room));\\n                        room_usage[e.room]++;\\n                    }\\n                    // if no meeting waiting\\n                    else{\\n                        occupying[e.room] = false;\\n                        occupying_count--;\\n                    }\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n\\n            // if exist empty meeting room\\n            if(occupying_count < n){\\n                for(int i = 0; i < n; i++){\\n                    // find it\\n                    if(!occupying[i]){\\n                        occupying[i] = true;\\n                        occupying_count++;\\n                        pq.add(new Event(meeting[1], i));\\n                        room_usage[i]++;\\n                        break;\\n                    }\\n                }\\n            } \\n            // if full, add the meeting to the waitlist, we only need to know the duration\\n            else{\\n                waiting.add(meeting[1]-meeting[0]);\\n            }\\n        }\\n\\n        // after dealing with all events in the first for-loop, deal with the ones in waitlist\\n        while(!pq.isEmpty()){\\n            Event e = pq.poll();\\n            if(!waiting.isEmpty()){\\n                pq.add(new Event(e.end + waiting.poll(), e.room));\\n                room_usage[e.room]++;\\n            }\\n            // this else statement doesn\\'t affect the correctness\\n            else{\\n                occupying[e.room] = false;\\n                occupying_count--;\\n            }\\n        }\\n        \\n        // loop to check the max room usage\\n        int res = -1;\\n        int max_usage = -1;\\n        for(int i = 0; i < room_usage.length; i++){\\n            if(room_usage[i] > max_usage){\\n                res = i;\\n                max_usage = room_usage[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\nclass Event implements Comparable<Event>{\\n    int end;\\n    int room;\\n    public Event(int e, int r){\\n        end = e;\\n        room = r;\\n    }\\n\\n    @Override\\n    public int compareTo(Event other){\\n        // added this room comparason to deal with test case 81, 82\\n        if(this.end == other.end){\\n            return (int)(this.room-other.room);\\n        }\\n        else{\\n            return (int)(this.end - other.end);\\n        } \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978107,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\ntypedef pair<long long,long long>pii;\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) \\n    {\\n        vector<long long>vis(n,0);\\n        priority_queue<long long,vector<long long>,greater<long long>>free;\\n        priority_queue<pii,vector<pii>,greater<pii>>pq;\\n        sort(meetings.begin(),meetings.end());\\n        for (long long i=0;i<n;i++) free.push(i);\\n        for (auto it: meetings)\\n        {\\n          while(!pq.empty() && pq.top().first<=it[0]) \\n          {\\n              long long room=pq.top().second;\\n              pq.pop();\\n              free.push(room);\\n          }\\n          if (free.size())\\n          {\\n              long long freeRoom=free.top();\\n              free.pop();\\n              pq.push({it[1],freeRoom});\\n              vis[freeRoom]++;\\n          }\\n          else{\\n              long long freeRoom=pq.top().second;\\n              long long endTime=pq.top().first+(it[1]-it[0]);\\n              pq.pop();\\n              pq.push({endTime,freeRoom});\\n             vis[freeRoom]++;\\n          }\\n        }\\n        long long maxi=vis[0];\\n        long long ans=0;\\n        for (long long i=1;i<n;i++)\\n        {\\n            if (vis[i]>maxi)\\n            {\\n                maxi=vis[i];\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef pair<long long,long long>pii;\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) \\n    {\\n        vector<long long>vis(n,0);\\n        priority_queue<long long,vector<long long>,greater<long long>>free;\\n        priority_queue<pii,vector<pii>,greater<pii>>pq;\\n        sort(meetings.begin(),meetings.end());\\n        for (long long i=0;i<n;i++) free.push(i);\\n        for (auto it: meetings)\\n        {\\n          while(!pq.empty() && pq.top().first<=it[0]) \\n          {\\n              long long room=pq.top().second;\\n              pq.pop();\\n              free.push(room);\\n          }\\n          if (free.size())\\n          {\\n              long long freeRoom=free.top();\\n              free.pop();\\n              pq.push({it[1],freeRoom});\\n              vis[freeRoom]++;\\n          }\\n          else{\\n              long long freeRoom=pq.top().second;\\n              long long endTime=pq.top().first+(it[1]-it[0]);\\n              pq.pop();\\n              pq.push({endTime,freeRoom});\\n             vis[freeRoom]++;\\n          }\\n        }\\n        long long maxi=vis[0];\\n        long long ans=0;\\n        for (long long i=1;i<n;i++)\\n        {\\n            if (vis[i]>maxi)\\n            {\\n                maxi=vis[i];\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977169,
                "title": "easy-to-understand-efficient-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse two min-heaps - one for keeping track of free rooms (h1), and the other (h2) to keep track of meetings with earliest ending times along with rooms (endtime, room)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each meeting\\n1. Evict all meetings in h2 if they have ended by the time new meeting begins. These meetings are put back in h1\\n2. If no such meeting is available - evict the meeting that ends earliest, and add a wait-time to the ending of the latest meeting\\n3. Keep track of every room\\'s record in a dictionary\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n\\n        meetings = sorted(meetings)\\n        \\n        import heapq\\n\\n        # Free rooms\\n        h1 = [i for i in range(n)]\\n        heapq.heapify(h1)\\n\\n        # Rooms with end times in order\\n        h2 = []\\n        rooms_record = {i: 0 for i in range(n)}\\n\\n        for meeting in meetings:\\n            start, end = meeting\\n\\n            wait = 0\\n            while h2:\\n                room_end, room = heapq.heappop(h2)\\n    \\n                if room_end <= start:\\n                    # evict rooms where meetings have ended\\n                    heapq.heappush(h1, room)\\n\\n                elif room_end > start:\\n                    # if the earliest meeting ends after this begings\\n                    if not h1:\\n                        # only use this if no other rooms are free\\n                        # add a wait_time to that meeting\\n                        wait = room_end - start                        \\n                        heapq.heappush(h1, room)\\n                    else:\\n                        heapq.heappush(h2, (room_end, room))\\n                    break\\n\\n            room = heapq.heappop(h1)\\n            rooms_record[room] += 1     \\n            heapq.heappush(h2, (end+wait, room))\\n        \\n        return max(rooms_record, key=rooms_record.get)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n\\n        meetings = sorted(meetings)\\n        \\n        import heapq\\n\\n        # Free rooms\\n        h1 = [i for i in range(n)]\\n        heapq.heapify(h1)\\n\\n        # Rooms with end times in order\\n        h2 = []\\n        rooms_record = {i: 0 for i in range(n)}\\n\\n        for meeting in meetings:\\n            start, end = meeting\\n\\n            wait = 0\\n            while h2:\\n                room_end, room = heapq.heappop(h2)\\n    \\n                if room_end <= start:\\n                    # evict rooms where meetings have ended\\n                    heapq.heappush(h1, room)\\n\\n                elif room_end > start:\\n                    # if the earliest meeting ends after this begings\\n                    if not h1:\\n                        # only use this if no other rooms are free\\n                        # add a wait_time to that meeting\\n                        wait = room_end - start                        \\n                        heapq.heappush(h1, room)\\n                    else:\\n                        heapq.heappush(h2, (room_end, room))\\n                    break\\n\\n            room = heapq.heappop(h1)\\n            rooms_record[room] += 1     \\n            heapq.heappush(h2, (end+wait, room))\\n        \\n        return max(rooms_record, key=rooms_record.get)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975358,
                "title": "java-solution-priorityqueue-map-simulation",
                "content": "# Code\\n```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        // PriorityQueue + Map + Simulation\\n        int[] roomCnt = new int[n];\\n        PriorityQueue<Integer> availables = new PriorityQueue<>(); // available rooms\\n        for (int i=0; i<n; i++) availables.offer(i);\\n        PriorityQueue<int[]> wait = new PriorityQueue<>((a, b) -> a[0] - b[0]); // <[start, end]>\\n        PriorityQueue<long[]> ongoing = new PriorityQueue<>((a, b) -> Long.compare(a[0], b[0])); // <[end, room_num]> \\u4F7F\\u7528 long \\u9632\\u6B62\\u6EA2\\u51FA\\n        for (int[] meeting : meetings) wait.offer(meeting);\\n\\n        int res = 0;\\n        while (!wait.isEmpty()) {\\n            long curTime = availables.isEmpty() ? ongoing.peek()[0] : wait.peek()[0];\\n            if (!ongoing.isEmpty() && ongoing.peek()[0] < curTime) curTime = ongoing.peek()[0];\\n\\n            while (!ongoing.isEmpty() && ongoing.peek()[0] <= curTime) {\\n                availables.offer((int) ongoing.poll()[1]);\\n            }\\n            while (!wait.isEmpty() && wait.peek()[0] <= curTime && !availables.isEmpty()) {\\n                long matchRoom = availables.poll();\\n                int[] matchMeet = wait.poll();\\n                roomCnt[(int) matchRoom]++;\\n                if (roomCnt[(int) matchRoom] == roomCnt[res] && matchRoom < res || roomCnt[(int) matchRoom] > roomCnt[res]) res = (int) matchRoom;\\n                ongoing.offer(new long[]{matchMeet[1] - matchMeet[0] + curTime, matchRoom});\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        // PriorityQueue + Map + Simulation\\n        int[] roomCnt = new int[n];\\n        PriorityQueue<Integer> availables = new PriorityQueue<>(); // available rooms\\n        for (int i=0; i<n; i++) availables.offer(i);\\n        PriorityQueue<int[]> wait = new PriorityQueue<>((a, b) -> a[0] - b[0]); // <[start, end]>\\n        PriorityQueue<long[]> ongoing = new PriorityQueue<>((a, b) -> Long.compare(a[0], b[0])); // <[end, room_num]> \\u4F7F\\u7528 long \\u9632\\u6B62\\u6EA2\\u51FA\\n        for (int[] meeting : meetings) wait.offer(meeting);\\n\\n        int res = 0;\\n        while (!wait.isEmpty()) {\\n            long curTime = availables.isEmpty() ? ongoing.peek()[0] : wait.peek()[0];\\n            if (!ongoing.isEmpty() && ongoing.peek()[0] < curTime) curTime = ongoing.peek()[0];\\n\\n            while (!ongoing.isEmpty() && ongoing.peek()[0] <= curTime) {\\n                availables.offer((int) ongoing.poll()[1]);\\n            }\\n            while (!wait.isEmpty() && wait.peek()[0] <= curTime && !availables.isEmpty()) {\\n                long matchRoom = availables.poll();\\n                int[] matchMeet = wait.poll();\\n                roomCnt[(int) matchRoom]++;\\n                if (roomCnt[(int) matchRoom] == roomCnt[res] && matchRoom < res || roomCnt[(int) matchRoom] > roomCnt[res]) res = (int) matchRoom;\\n                ongoing.offer(new long[]{matchMeet[1] - matchMeet[0] + curTime, matchRoom});\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962204,
                "title": "c-2-priority-queue-with-comment-solve-81th-testcase-fail-by-fix-compare-function",
                "content": "# Code\\n```\\n/*\\n    Algo.\\n    sort meeting by start time.\\n    \\n    iterate meeting:\\n        find room\\n        \\n        I use 2 variable to represent a room.(hold meeting # , next free time)\\n        Init state give (0,0)\\n            \\n        if no room can use. choose min next free time room.\\n        if hae rooms can use(cur meeting start >= next free time),choose min index one.\\n\\n\\n        iterate meeting.\\n\\n            update 2 priority queue.\\n            pop free room from \"not free\" to \"free\".\\n\\n            if no free room.\\n                pop room from \"not free\".update it and put it back.\\n            if has free\\n                pop from \"free\" update it and put it to \"not free\"\\n\\n            [BECAREFUL]\\n            need consider delay meeting start time and no delay meeting start time.\\n            if delay => start at pre meeting\\'s end.\\n            if no delay => start at meeting\\'s start time.\\n\\n*/\\n\\nclass Solution {\\n\\n    struct Room{\\n        int cnt{};\\n        long long next_freetime{};//overflow\\n    };\\n\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        \\n        sort(meetings.begin(),meetings.end());\\n\\n        vector<Room> rooms(n);\\n\\n        priority_queue<int,vector<int>,function<bool(const int&,const int&)>> free_rooms(\\n            [&](auto &a,auto &b){\\n                return a > b;\\n            }\\n        );\\n\\n        priority_queue<int,vector<int>,function<bool(const int&,const int&)>> NOT_free_rooms(\\n            [&](auto &a,auto &b){\\n                \\n                //fail at 81 / 82 testcases passed\\n                // return rooms[a].next_freetime>rooms[b].next_freetime;\\n                \\n                if(rooms[a].next_freetime == rooms[b].next_freetime)\\n                    return a > b;\\n                else\\n                    return rooms[a].next_freetime > rooms[b].next_freetime;\\n            }\\n        );\\n\\n        int meeting_n = meetings.size();\\n\\n        //put all meeting to free rooms queue\\n        for(int i{};i<n;i++) free_rooms.emplace(i);\\n\\n        int max_cnt{},ans=INT_MAX;\\n        for(int i{};i<meeting_n;i++){\\n\\n            //updae 2 queue\\n            while(!NOT_free_rooms.empty() && rooms[NOT_free_rooms.top()].next_freetime <= meetings[i][0])\\n                free_rooms.push(NOT_free_rooms.top()),NOT_free_rooms.pop();    \\n            \\n            int choose;\\n            if(free_rooms.empty()){\\n                //this meeting will be delay.start at pre meeting end.\\n                choose = NOT_free_rooms.top(),NOT_free_rooms.pop();\\n                rooms[choose].next_freetime += meetings[i][1]-meetings[i][0];\\n            }\\n            else{\\n                // [BECAREFUL] \\n                //this meeting will not be dalay.start from where it should be\\n                //end when it should end.\\n                choose = free_rooms.top(),free_rooms.pop();\\n                rooms[choose].next_freetime = meetings[i][1];\\n            }\\n            rooms[choose].cnt++;\\n            \\n            if(rooms[choose].cnt > max_cnt){\\n                max_cnt = rooms[choose].cnt, ans = choose;\\n            }else if(rooms[choose].cnt == max_cnt) ans = min(ans,choose);\\n            \\n            NOT_free_rooms.push(choose);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n    Algo.\\n    sort meeting by start time.\\n    \\n    iterate meeting:\\n        find room\\n        \\n        I use 2 variable to represent a room.(hold meeting # , next free time)\\n        Init state give (0,0)\\n            \\n        if no room can use. choose min next free time room.\\n        if hae rooms can use(cur meeting start >= next free time),choose min index one.\\n\\n\\n        iterate meeting.\\n\\n            update 2 priority queue.\\n            pop free room from \"not free\" to \"free\".\\n\\n            if no free room.\\n                pop room from \"not free\".update it and put it back.\\n            if has free\\n                pop from \"free\" update it and put it to \"not free\"\\n\\n            [BECAREFUL]\\n            need consider delay meeting start time and no delay meeting start time.\\n            if delay => start at pre meeting\\'s end.\\n            if no delay => start at meeting\\'s start time.\\n\\n*/\\n\\nclass Solution {\\n\\n    struct Room{\\n        int cnt{};\\n        long long next_freetime{};//overflow\\n    };\\n\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        \\n        sort(meetings.begin(),meetings.end());\\n\\n        vector<Room> rooms(n);\\n\\n        priority_queue<int,vector<int>,function<bool(const int&,const int&)>> free_rooms(\\n            [&](auto &a,auto &b){\\n                return a > b;\\n            }\\n        );\\n\\n        priority_queue<int,vector<int>,function<bool(const int&,const int&)>> NOT_free_rooms(\\n            [&](auto &a,auto &b){\\n                \\n                //fail at 81 / 82 testcases passed\\n                // return rooms[a].next_freetime>rooms[b].next_freetime;\\n                \\n                if(rooms[a].next_freetime == rooms[b].next_freetime)\\n                    return a > b;\\n                else\\n                    return rooms[a].next_freetime > rooms[b].next_freetime;\\n            }\\n        );\\n\\n        int meeting_n = meetings.size();\\n\\n        //put all meeting to free rooms queue\\n        for(int i{};i<n;i++) free_rooms.emplace(i);\\n\\n        int max_cnt{},ans=INT_MAX;\\n        for(int i{};i<meeting_n;i++){\\n\\n            //updae 2 queue\\n            while(!NOT_free_rooms.empty() && rooms[NOT_free_rooms.top()].next_freetime <= meetings[i][0])\\n                free_rooms.push(NOT_free_rooms.top()),NOT_free_rooms.pop();    \\n            \\n            int choose;\\n            if(free_rooms.empty()){\\n                //this meeting will be delay.start at pre meeting end.\\n                choose = NOT_free_rooms.top(),NOT_free_rooms.pop();\\n                rooms[choose].next_freetime += meetings[i][1]-meetings[i][0];\\n            }\\n            else{\\n                // [BECAREFUL] \\n                //this meeting will not be dalay.start from where it should be\\n                //end when it should end.\\n                choose = free_rooms.top(),free_rooms.pop();\\n                rooms[choose].next_freetime = meetings[i][1];\\n            }\\n            rooms[choose].cnt++;\\n            \\n            if(rooms[choose].cnt > max_cnt){\\n                max_cnt = rooms[choose].cnt, ans = choose;\\n            }else if(rooms[choose].cnt == max_cnt) ans = min(ans,choose);\\n            \\n            NOT_free_rooms.push(choose);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952262,
                "title": "simple-solution-no-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\ncomplexity:  n= rooms, m = meetings\\n        \\n    I didn\\'t say O(m*logm) from the sorting becuase of worse case scenario\\n n= 100, m = 10^5\\n 100 * 10**5 > 100 * log(100)\\n        \\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        \"\"\"\\n        input: int,list[list[int]]\\n        output: int (# room with most meetings)\\n        \\n        approach:\\n        track end time each room and # meetings in two lists\\n        traverse meetings\\n        find next room(first one that is open before start or next available)\\n        add meeting to next room and update end time to either meeting end time or room end time + meeting duration\\n\\n        \\n        cases:\\n            multiple overlapping meeings\\n            meeting out of order\\n            meeting of different length out of order (shorter meetings after long meeting)\\n            gaps between meetings\\n            multiple available rooms that can accomodate\\n        \"\"\"\\n\\n        self.rooms = [0]*n\\n        self.mtngs = [0]*n\\n        meetings.sort()\\n        #print(meetings)\\n        \\n        def find_next_room(start_time): #O(n)\\n            earliest_end = min(self.rooms)\\n            if earliest_end > start:\\n                return self.rooms.index(earliest_end)\\n            else:\\n                for i,room_end in enumerate(self.rooms):\\n                    if room_end <= start_time:\\n                        return i\\n        \\n        for start,end in meetings: #O(m)\\n            #print(\"mtng\",(start,end))\\n            next_room = find_next_room(start)\\n            room_end = self.rooms[next_room]\\n            duration = end-start\\n            #print(\"duration\", duration)\\n            #print(end,room_end + duration)\\n            end_time = max(end,room_end + duration)\\n            self.rooms[next_room] = end_time\\n            self.mtngs[next_room] += 1\\n            #print(\"self.rooms\",self.rooms)\\n            #print(\"self.mtngs\",self.mtngs)\\n        \\n        return self.mtngs.index(max(self.mtngs))\\n        \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        \"\"\"\\n        input: int,list[list[int]]\\n        output: int (# room with most meetings)\\n        \\n        approach:\\n        track end time each room and # meetings in two lists\\n        traverse meetings\\n        find next room(first one that is open before start or next available)\\n        add meeting to next room and update end time to either meeting end time or room end time + meeting duration\\n\\n        \\n        cases:\\n            multiple overlapping meeings\\n            meeting out of order\\n            meeting of different length out of order (shorter meetings after long meeting)\\n            gaps between meetings\\n            multiple available rooms that can accomodate\\n        \"\"\"\\n\\n        self.rooms = [0]*n\\n        self.mtngs = [0]*n\\n        meetings.sort()\\n        #print(meetings)\\n        \\n        def find_next_room(start_time): #O(n)\\n            earliest_end = min(self.rooms)\\n            if earliest_end > start:\\n                return self.rooms.index(earliest_end)\\n            else:\\n                for i,room_end in enumerate(self.rooms):\\n                    if room_end <= start_time:\\n                        return i\\n        \\n        for start,end in meetings: #O(m)\\n            #print(\"mtng\",(start,end))\\n            next_room = find_next_room(start)\\n            room_end = self.rooms[next_room]\\n            duration = end-start\\n            #print(\"duration\", duration)\\n            #print(end,room_end + duration)\\n            end_time = max(end,room_end + duration)\\n            self.rooms[next_room] = end_time\\n            self.mtngs[next_room] += 1\\n            #print(\"self.rooms\",self.rooms)\\n            #print(\"self.mtngs\",self.mtngs)\\n        \\n        return self.mtngs.index(max(self.mtngs))\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948156,
                "title": "c-o-m-logn-solution-with-min-heaps-beats-99-05",
                "content": "# Intuition\\nUse one min heap for available rooms with room number, and another min heap for occupied rooms with end time and room number.\\n\\n# Approach\\nLine sweep. For each meeting, first check the meeting start time to release occupied rooms that finish being used before it; then, if there are available rooms, schedule the meeting to the room with the smallest room number (the top of the first min heam); otherwise, pop the top of the min heap for the occupied rooms to release a future room, and schedule the meeting to that room\\'s end time.\\n\\n# Complexity\\n- Time complexity:\\n$$O(mlogn)$$, where $$m=meetings.size()$$, and $$logn$$ for heap insertions.\\n\\n- Space complexity:\\n$$O(n)$$ for the heaps.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        priority_queue<int, vector<int>, greater<int>> rooms;\\n        priority_queue<pair<long, int>, vector<pair<long, int>>, greater<pair<long, int>>> ends;\\n        vector<int> count(n, 0);\\n        int max = 0, maxroom = 0;\\n\\n        for (int i = 0; i < n; i++) rooms.push(i);\\n        sort(meetings.begin(), meetings.end());\\n\\n        for (const auto& meeting : meetings) {\\n            while (ends.size() > 0 && ends.top().first <= meeting[0]) {\\n                rooms.push(ends.top().second);\\n                ends.pop();\\n            }\\n\\n            int room;\\n            if (rooms.size() > 0) {\\n                room = rooms.top();\\n                rooms.pop();\\n                ends.push(make_pair(meeting[1], room));\\n            } else {\\n                long time = ends.top().first;\\n                room = ends.top().second;\\n                ends.pop();\\n                ends.push(make_pair(time - meeting[0] + meeting[1], room));\\n            }\\n\\n            count[room]++;\\n            if (count[room] > max || (count[room] == max && room < maxroom)) {\\n                max = count[room];\\n                maxroom = room;\\n            }\\n        }\\n        return maxroom;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        priority_queue<int, vector<int>, greater<int>> rooms;\\n        priority_queue<pair<long, int>, vector<pair<long, int>>, greater<pair<long, int>>> ends;\\n        vector<int> count(n, 0);\\n        int max = 0, maxroom = 0;\\n\\n        for (int i = 0; i < n; i++) rooms.push(i);\\n        sort(meetings.begin(), meetings.end());\\n\\n        for (const auto& meeting : meetings) {\\n            while (ends.size() > 0 && ends.top().first <= meeting[0]) {\\n                rooms.push(ends.top().second);\\n                ends.pop();\\n            }\\n\\n            int room;\\n            if (rooms.size() > 0) {\\n                room = rooms.top();\\n                rooms.pop();\\n                ends.push(make_pair(meeting[1], room));\\n            } else {\\n                long time = ends.top().first;\\n                room = ends.top().second;\\n                ends.pop();\\n                ends.push(make_pair(time - meeting[0] + meeting[1], room));\\n            }\\n\\n            count[room]++;\\n            if (count[room] > max || (count[room] == max && room < maxroom)) {\\n                max = count[room];\\n                maxroom = room;\\n            }\\n        }\\n        return maxroom;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933463,
                "title": "python3-solution-with-minheap-and-lists",
                "content": "# Code\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        freeRoom = [True for i in range(n)]\\n        roomCnt = [0 for i in range(n)]\\n        endTimeHeap = []\\n        heapq.heapify(endTimeHeap)\\n        \\n        def checkRoomFree(newMeet):\\n            while endTimeHeap and newMeet[0] >= endTimeHeap[0][0]:\\n                val = heapq.heappop(endTimeHeap)            \\n                freeRoom[val[1]] = True\\n            for j in range(len(freeRoom)):\\n                if freeRoom[j] == True:\\n                    freeRoom[j] = False\\n                    roomCnt[j] += 1\\n                    return True, j\\n                    \\n            return False, 0\\n                \\n        for i in range(len(meetings)):\\n            isFree, roomNo = checkRoomFree(meetings[i])\\n            if isFree:\\n                heapq.heappush(endTimeHeap, [meetings[i][1], roomNo])\\n            else:\\n                diff = meetings[i][1] - meetings[i][0]\\n                if endTimeHeap:\\n                    endTime, roomNo = heapq.heappop(endTimeHeap)\\n                    newEndTime = endTime + diff\\n                    roomCnt[roomNo] += 1\\n                    heapq.heappush(endTimeHeap, [newEndTime, roomNo])\\n\\n        maxCnt = max(roomCnt)              \\n        return roomCnt.index(maxCnt)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        freeRoom = [True for i in range(n)]\\n        roomCnt = [0 for i in range(n)]\\n        endTimeHeap = []\\n        heapq.heapify(endTimeHeap)\\n        \\n        def checkRoomFree(newMeet):\\n            while endTimeHeap and newMeet[0] >= endTimeHeap[0][0]:\\n                val = heapq.heappop(endTimeHeap)            \\n                freeRoom[val[1]] = True\\n            for j in range(len(freeRoom)):\\n                if freeRoom[j] == True:\\n                    freeRoom[j] = False\\n                    roomCnt[j] += 1\\n                    return True, j\\n                    \\n            return False, 0\\n                \\n        for i in range(len(meetings)):\\n            isFree, roomNo = checkRoomFree(meetings[i])\\n            if isFree:\\n                heapq.heappush(endTimeHeap, [meetings[i][1], roomNo])\\n            else:\\n                diff = meetings[i][1] - meetings[i][0]\\n                if endTimeHeap:\\n                    endTime, roomNo = heapq.heappop(endTimeHeap)\\n                    newEndTime = endTime + diff\\n                    roomCnt[roomNo] += 1\\n                    heapq.heappush(endTimeHeap, [newEndTime, roomNo])\\n\\n        maxCnt = max(roomCnt)              \\n        return roomCnt.index(maxCnt)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925443,
                "title": "meeting-rooms-ii-and-hashmap-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        if(n <= 0 or meetings.size() == 0) return -1;\\n        sort(meetings.begin(), meetings.end());\\n        auto cmp = [](vector<long long> &a, vector<long long> &b){ \\n            if(b[1] == a[1])\\n                return a[2] > b[2];\\n            return a[1] > b[1];\\n        };\\n        priority_queue<vector<long long>, vector<vector<long long>>, decltype(cmp)> pq(cmp);\\n        unordered_map<int, int> hashmap;\\n        unordered_set<int> rooms;\\n        pq.push({meetings[0][0], meetings[0][1], 0});\\n        rooms.insert(0);\\n        for(int i = 1; i < meetings.size(); i++) {\\n            while(!pq.empty() and pq.top()[1] <= meetings[i][0]) {\\n                auto curr = pq.top();\\n                rooms.erase(curr[2]);\\n                hashmap[curr[2]]++;\\n                pq.pop();\\n            }\\n            if(pq.size() < n) {\\n                for(int j = 0 ; j < n; j++) {\\n                    if(!rooms.count(j)) {\\n                        rooms.insert(j);\\n                        pq.push({meetings[i][0], meetings[i][1],j});\\n                        break;\\n                    }\\n                }\\n                continue;\\n            }\\n            auto curr = pq.top();\\n            hashmap[curr[2]]++;\\n            pq.pop();\\n            rooms.erase(curr[2]);\\n            auto diff = curr[1] - meetings[i][0];\\n            pq.push({curr[0],meetings[i][1]+diff,curr[2]});\\n        }\\n        while(!pq.empty()) {\\n            auto curr = pq.top();\\n            pq.pop();\\n            hashmap[curr[2]]++;\\n        }\\n        int res = 0;\\n        int maxv = 1;\\n\\n        for(auto i: hashmap) {\\n            if(i.second >= maxv) {\\n                if(maxv == i.second) {\\n                    if(res > i.first)\\n                        res = i.first;\\n                    continue;\\n                }\\n                maxv = i.second;\\n                res = i.first;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        if(n <= 0 or meetings.size() == 0) return -1;\\n        sort(meetings.begin(), meetings.end());\\n        auto cmp = [](vector<long long> &a, vector<long long> &b){ \\n            if(b[1] == a[1])\\n                return a[2] > b[2];\\n            return a[1] > b[1];\\n        };\\n        priority_queue<vector<long long>, vector<vector<long long>>, decltype(cmp)> pq(cmp);\\n        unordered_map<int, int> hashmap;\\n        unordered_set<int> rooms;\\n        pq.push({meetings[0][0], meetings[0][1], 0});\\n        rooms.insert(0);\\n        for(int i = 1; i < meetings.size(); i++) {\\n            while(!pq.empty() and pq.top()[1] <= meetings[i][0]) {\\n                auto curr = pq.top();\\n                rooms.erase(curr[2]);\\n                hashmap[curr[2]]++;\\n                pq.pop();\\n            }\\n            if(pq.size() < n) {\\n                for(int j = 0 ; j < n; j++) {\\n                    if(!rooms.count(j)) {\\n                        rooms.insert(j);\\n                        pq.push({meetings[i][0], meetings[i][1],j});\\n                        break;\\n                    }\\n                }\\n                continue;\\n            }\\n            auto curr = pq.top();\\n            hashmap[curr[2]]++;\\n            pq.pop();\\n            rooms.erase(curr[2]);\\n            auto diff = curr[1] - meetings[i][0];\\n            pq.push({curr[0],meetings[i][1]+diff,curr[2]});\\n        }\\n        while(!pq.empty()) {\\n            auto curr = pq.top();\\n            pq.pop();\\n            hashmap[curr[2]]++;\\n        }\\n        int res = 0;\\n        int maxv = 1;\\n\\n        for(auto i: hashmap) {\\n            if(i.second >= maxv) {\\n                if(maxv == i.second) {\\n                    if(res > i.first)\\n                        res = i.first;\\n                    continue;\\n                }\\n                maxv = i.second;\\n                res = i.first;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920505,
                "title": "c-solution-using-2-priority-queues",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDetailed explanation is present along with the code as comments.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        \\n        // Sorting based on starting time. \\n        sort(meetings.begin(), meetings.end());\\n\\n        // PQ to store the emprt rooms. The room with minimum \\n        // index must be alloted first, hence minHeap is used\\n        priority_queue<int, vector<int>, greater<int>> emptyRooms;\\n\\n        // Vector to store usage frequency of rooms \\n        vector<int> freq(n, 0);\\n\\n        int i = 0;\\n        while (i < n) {\\n            emptyRooms.push(i++);\\n        }\\n\\n        // Priority Queue to store the currently occupied rooms\\n        // PQ => {end Time of the meeting, room occupied}\\n        priority_queue<\\n            pair<long long, int>, \\n            vector<pair<long long, int>>, \\n            greater<pair<long long, int>>> pq;\\n\\n        for (const auto& meeting: meetings) {\\n            \\n            // if there exists rooms whose end timings are less than\\n            // the current meeting time, then they should be freed.\\n            while (!pq.empty() && pq.top().first <= meeting[0]) {\\n                emptyRooms.push(pq.top().second);\\n                pq.pop();\\n            }\\n             \\n            // Check if any room is empty and allot that room if true\\n            if (!emptyRooms.empty()) {\\n                int room = emptyRooms.top();\\n                emptyRooms.pop();\\n\\n                pq.push({meeting[1], room});\\n                freq[room]++;\\n            } else {\\n                // else take the top element from the occupied rooms\\n                // priority queue and allot it to new meeting\\n                auto top = pq.top();\\n                pq.pop();\\n\\n                long long delay = top.first - meeting[0];\\n                int room = top.second;\\n                \\n                // The end time of the top occupied room will be\\n                // greater than the current meeting\\'s starting time,\\n                // to account the delay caused, endTime of the current\\n                // meeting should be added with the delay.\\n                long long int endTime = delay + meeting[1];\\n\\n                pq.push({endTime, room});\\n                freq[room]++;\\n            }\\n        }\\n\\n        // Find the index with max Frequency\\n        int index = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (freq[i] > freq[index]) {\\n                index = i;\\n            }\\n        }\\n\\n        return index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        \\n        // Sorting based on starting time. \\n        sort(meetings.begin(), meetings.end());\\n\\n        // PQ to store the emprt rooms. The room with minimum \\n        // index must be alloted first, hence minHeap is used\\n        priority_queue<int, vector<int>, greater<int>> emptyRooms;\\n\\n        // Vector to store usage frequency of rooms \\n        vector<int> freq(n, 0);\\n\\n        int i = 0;\\n        while (i < n) {\\n            emptyRooms.push(i++);\\n        }\\n\\n        // Priority Queue to store the currently occupied rooms\\n        // PQ => {end Time of the meeting, room occupied}\\n        priority_queue<\\n            pair<long long, int>, \\n            vector<pair<long long, int>>, \\n            greater<pair<long long, int>>> pq;\\n\\n        for (const auto& meeting: meetings) {\\n            \\n            // if there exists rooms whose end timings are less than\\n            // the current meeting time, then they should be freed.\\n            while (!pq.empty() && pq.top().first <= meeting[0]) {\\n                emptyRooms.push(pq.top().second);\\n                pq.pop();\\n            }\\n             \\n            // Check if any room is empty and allot that room if true\\n            if (!emptyRooms.empty()) {\\n                int room = emptyRooms.top();\\n                emptyRooms.pop();\\n\\n                pq.push({meeting[1], room});\\n                freq[room]++;\\n            } else {\\n                // else take the top element from the occupied rooms\\n                // priority queue and allot it to new meeting\\n                auto top = pq.top();\\n                pq.pop();\\n\\n                long long delay = top.first - meeting[0];\\n                int room = top.second;\\n                \\n                // The end time of the top occupied room will be\\n                // greater than the current meeting\\'s starting time,\\n                // to account the delay caused, endTime of the current\\n                // meeting should be added with the delay.\\n                long long int endTime = delay + meeting[1];\\n\\n                pq.push({endTime, room});\\n                freq[room]++;\\n            }\\n        }\\n\\n        // Find the index with max Frequency\\n        int index = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (freq[i] > freq[index]) {\\n                index = i;\\n            }\\n        }\\n\\n        return index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919076,
                "title": "beats-95-time-and-80-space-c-lightning-fast-priority-queue-approach",
                "content": "# Intuition\\nThe only thing that led me into using min heaps was the fact that we always had to reorder to find the smallest numbered room and we also needed a way to check which meeting ended first.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        int m = meetings.size();\\n        vector<int> cnt(n, 0);\\n        priority_queue<int, vector<int>, greater<int>> free_rooms;\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> occ_rooms;\\n        sort(meetings.begin(), meetings.end());\\n        for(int i=0; i<n; i++) free_rooms.push(i);\\n\\n        long long timer = 0;\\n        int ind = 0;\\n        // cout << \"hello\" << endl;\\n        while(ind < m){\\n            // cout << \"hello1\" << endl;\\n            while(!occ_rooms.empty()){\\n                // cout << \"hello2\" << endl;\\n                if(occ_rooms.top().first <= meetings[ind][0]){\\n                    timer = occ_rooms.top().first;\\n                    int freedroom = occ_rooms.top().second;\\n                    occ_rooms.pop();\\n                    free_rooms.push(freedroom);\\n                }else{\\n                    break;\\n                }\\n            }\\n            // int freeroom;\\n            if(free_rooms.empty()){\\n                // cout << \"hello3\" << endl;\\n                timer = occ_rooms.top().first;\\n                while(!occ_rooms.empty()){\\n                    if(occ_rooms.top().first == timer){\\n                        int newroom = occ_rooms.top().second;\\n                        free_rooms.push(newroom);\\n                        occ_rooms.pop();\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            int room = free_rooms.top();\\n            free_rooms.pop();\\n\\n            if(timer >= meetings[ind][0]){\\n                // cout << \"hello4\" << endl;\\n                cnt[room]++;\\n                occ_rooms.push({timer + meetings[ind][1]-meetings[ind][0], room});\\n                ind++;\\n            }else{\\n                // cout << \"hello5\" << endl;\\n                timer = meetings[ind][0];\\n                cnt[room]++;\\n                occ_rooms.push({timer + meetings[ind][1]-meetings[ind][0], room});\\n                ind++;\\n            }\\n\\n        }\\n        for(auto el: cnt) cout << el << \" \";\\n        return max_element(cnt.begin(), cnt.end()) - cnt.begin();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        int m = meetings.size();\\n        vector<int> cnt(n, 0);\\n        priority_queue<int, vector<int>, greater<int>> free_rooms;\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> occ_rooms;\\n        sort(meetings.begin(), meetings.end());\\n        for(int i=0; i<n; i++) free_rooms.push(i);\\n\\n        long long timer = 0;\\n        int ind = 0;\\n        // cout << \"hello\" << endl;\\n        while(ind < m){\\n            // cout << \"hello1\" << endl;\\n            while(!occ_rooms.empty()){\\n                // cout << \"hello2\" << endl;\\n                if(occ_rooms.top().first <= meetings[ind][0]){\\n                    timer = occ_rooms.top().first;\\n                    int freedroom = occ_rooms.top().second;\\n                    occ_rooms.pop();\\n                    free_rooms.push(freedroom);\\n                }else{\\n                    break;\\n                }\\n            }\\n            // int freeroom;\\n            if(free_rooms.empty()){\\n                // cout << \"hello3\" << endl;\\n                timer = occ_rooms.top().first;\\n                while(!occ_rooms.empty()){\\n                    if(occ_rooms.top().first == timer){\\n                        int newroom = occ_rooms.top().second;\\n                        free_rooms.push(newroom);\\n                        occ_rooms.pop();\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n            int room = free_rooms.top();\\n            free_rooms.pop();\\n\\n            if(timer >= meetings[ind][0]){\\n                // cout << \"hello4\" << endl;\\n                cnt[room]++;\\n                occ_rooms.push({timer + meetings[ind][1]-meetings[ind][0], room});\\n                ind++;\\n            }else{\\n                // cout << \"hello5\" << endl;\\n                timer = meetings[ind][0];\\n                cnt[room]++;\\n                occ_rooms.push({timer + meetings[ind][1]-meetings[ind][0], room});\\n                ind++;\\n            }\\n\\n        }\\n        for(auto el: cnt) cout << el << \" \";\\n        return max_element(cnt.begin(), cnt.end()) - cnt.begin();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3911249,
                "title": "python-code-with-detailed-explanation-two-priority-queues",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse two priority queues, one for storing the available rooms ordered by the room number, the other for storing the unavailable rooms ordered by ending time\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each traversed meeting\\n1. Construct available rooms based on ending time\\n2. If there are available rooms, take the one with the smallest number\\n3. If not, take the busy rooms with minimum ending time\\n4. Update the result and room status\\n\\n# Complexity\\nTake meeting room number as n, meeting number is m\\n- Time complexity: O((m*n) logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) since we store every meeting room in array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        # Sort the meetings by the start time\\n        meetings.sort(key=lambda x: x[0])\\n\\n        # Keep track of the maximum meetings for each room\\n        res_arr = defaultdict(int)\\n        res = -1\\n        max_res = float(\\'-inf\\')\\n\\n        # Two priority queues\\n        # one for storing the room statuses, order by ending time of current meeting\\n        h = []\\n        # one for storing the rooms that are available, order by room number\\n        h1 = []\\n\\n        # Init, every room has zero ending time, since its available\\n        for num in range(n):\\n            heapq.heappush(h,(0,num))\\n\\n        for m in meetings:\\n            # Construct the h1 for current meeting to find available rooms\\n            while h:\\n                max_time, room_num = heapq.heappop(h)\\n                if max_time <= m[0]:\\n                    heapq.heappush(h1, (room_num, max_time))\\n                else:\\n                    heapq.heappush(h, (max_time, room_num))\\n                    break\\n\\n            # If h1 is not empty, we take from lowest room number in h1\\n            # Else, we take from earliest available meeting room in h\\n            if h1:\\n                room_num, max_time = heapq.heappop(h1)\\n            else:\\n                max_time, room_num = heapq.heappop(h)\\n\\n            # Record and update the current maximum\\n            res_arr[room_num] += 1\\n            if res_arr[room_num] > max_res:\\n                max_res = res_arr[room_num]\\n                res = room_num\\n            elif res_arr[room_num] == max_res:\\n                if res > room_num:\\n                    res = room_num\\n\\n            # Push back the updated taken room to queue\\n            heapq.heappush(h,( (m[1]-m[0])+max(max_time,m[0]),room_num))\\n            # Push back the available rooms to queue\\n            while h1:\\n                room_num, max_time = heapq.heappop(h1)\\n                heapq.heappush(h, (max_time, room_num))\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        # Sort the meetings by the start time\\n        meetings.sort(key=lambda x: x[0])\\n\\n        # Keep track of the maximum meetings for each room\\n        res_arr = defaultdict(int)\\n        res = -1\\n        max_res = float(\\'-inf\\')\\n\\n        # Two priority queues\\n        # one for storing the room statuses, order by ending time of current meeting\\n        h = []\\n        # one for storing the rooms that are available, order by room number\\n        h1 = []\\n\\n        # Init, every room has zero ending time, since its available\\n        for num in range(n):\\n            heapq.heappush(h,(0,num))\\n\\n        for m in meetings:\\n            # Construct the h1 for current meeting to find available rooms\\n            while h:\\n                max_time, room_num = heapq.heappop(h)\\n                if max_time <= m[0]:\\n                    heapq.heappush(h1, (room_num, max_time))\\n                else:\\n                    heapq.heappush(h, (max_time, room_num))\\n                    break\\n\\n            # If h1 is not empty, we take from lowest room number in h1\\n            # Else, we take from earliest available meeting room in h\\n            if h1:\\n                room_num, max_time = heapq.heappop(h1)\\n            else:\\n                max_time, room_num = heapq.heappop(h)\\n\\n            # Record and update the current maximum\\n            res_arr[room_num] += 1\\n            if res_arr[room_num] > max_res:\\n                max_res = res_arr[room_num]\\n                res = room_num\\n            elif res_arr[room_num] == max_res:\\n                if res > room_num:\\n                    res = room_num\\n\\n            # Push back the updated taken room to queue\\n            heapq.heappush(h,( (m[1]-m[0])+max(max_time,m[0]),room_num))\\n            # Push back the available rooms to queue\\n            while h1:\\n                room_num, max_time = heapq.heappop(h1)\\n                heapq.heappush(h, (max_time, room_num))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910176,
                "title": "typescript-2-heaps",
                "content": "# Intuition\\nKeep track of free and occupied rooms using 2 heaps: \\n`freeRooms`: returns free room with minimal number\\n`occupiedRooms`: returns room with lowest \"getting free\" time, for rooms with the same time it returns room with lowest number\\n\\n# Approach\\n1. Init rooms meetings counter with `0`\\n2. Sort meetings so we are able to correctly track occupied rooms when new meeting \"arrives\"\\n2. Initiailize `freeRooms` heap with all available rooms\\n3. Process all meeting one by one (they are sorted by start time). \\n- check if any rooms got free till the meeting start time, effectively moving rooms from `occupiedRooms` to `freeRooms` heap\\n- schedule the meeting in the free room if available\\n- if no schedule meeting in next avalable occupied room, calculate end meeting time as `\"room getting freetime\" + \"meeting duration\"`\\n- count scheduled meeting\\n4. Find room with maximum booked meetings in rooms meetings counter \\n\\n# Complexity\\n- Time complexity:\\nn - room number, m - meetings number\\n1. sorting: $$O(m * log(m))$$\\n2. heap initialization: $$O(n * log(n))$$ - but it should be just $$O(n)$$ with proper heap\\n3. `while` loop insdie `for` loop: we occupy room only by meeting, it means that in worst case scenario it\\'s $$O(m * log(n))$$\\n4. rest operations with `occupiedRooms` considering `for` loop: $$O(m * log(n))$$, as `n` is max number of elements in heap\\n5. operations with `freeRoooms` considering `for` loop: $$O(m * log(n))$$\\nfind max booked room in counter: $$O(n)$$\\n\\nSumming up: $$O(m * log(m) + n * log(n) + m * log(n) + m * log(n) + n)$$\\nAnd simplifying (taking heap initialization as $$O(n)$$): $$O(m * (log(m) + log(n)) + n)$$\\n\\n\\n- Space complexity:\\nHeaps and counter take: $$O(n)$$ (we don\\'t consider sorting)\\n\\n# Code\\n```\\nclass HeapNode<T = never> {\\n    val: number;\\n    data?: T;\\n\\n    constructor(val: number, data?: T) {\\n        this.val = val;\\n        this.data = data;\\n    }\\n}\\n\\nclass MinHeap<T> {\\n    arr: HeapNode<T>[] = [];\\n    size = 0;\\n\\n    compare: (nodeA: T, nodeB: T) => boolean | undefined;\\n\\n    shouldBeAbove(nodeA: HeapNode<T>, nodeB: HeapNode<T>) {\\n        return this.compare ? this.compare(nodeA.data, nodeB.data) : nodeA.val < nodeB.val;\\n    }\\n\\n    constructor(compare: (nodeA: T, nodeB: T) => boolean = undefined) {\\n        this.compare = compare;\\n    }\\n\\n    pop(): HeapNode<T> | undefined {\\n        if (this.size === 0) {\\n            return undefined;\\n        }\\n\\n        let head = this.arr[0];\\n\\n        this.arr[0] = this.arr[this.size - 1];\\n        this.arr.length = this.size = this.size - 1;\\n        this.heapifyDown(0);\\n\\n        return head;\\n    }\\n\\n    getParentInd(ind: number): number | undefined {\\n        if (ind === 0) {\\n            return undefined;\\n        }\\n        return Math.floor((ind - 1) / 2);\\n    }\\n\\n    getChildIndexes(ind: number): number[] {\\n        return [ind * 2 + 1, ind * 2 + 2].filter(\\n            (ind) => ind < this.size\\n        );\\n    }\\n\\n    swap(indA: number, indB: number) {\\n        let temp = this.arr[indA];\\n        this.arr[indA] = this.arr[indB];\\n        this.arr[indB] = temp;\\n    }\\n\\n    heapifyDown(cur: number) {\\n        let childrenIndexes = this.getChildIndexes(cur);\\n        if (childrenIndexes.length > 0) {\\n            let maxChildInd =\\n                childrenIndexes.length > 1 &&\\n                    this.shouldBeAbove(this.arr[childrenIndexes[1]], this.arr[childrenIndexes[0]])\\n                    ? childrenIndexes[1]\\n                    : childrenIndexes[0];\\n\\n            if (this.shouldBeAbove(this.arr[maxChildInd], this.arr[cur])) {\\n                this.swap(cur, maxChildInd);\\n                this.heapifyDown(maxChildInd);\\n            }\\n        }\\n    }\\n\\n    heapifyUp(cur: number) {\\n        let parent = this.getParentInd(cur);\\n        if (parent !== undefined && this.shouldBeAbove(this.arr[cur], this.arr[parent])) {\\n            this.swap(cur, parent);\\n            this.heapifyUp(parent);\\n        }\\n    }\\n\\n    push(val: number, data: T = undefined) {\\n        this.arr[this.size] = new HeapNode<T>(val, data);\\n        this.heapifyUp(this.size);\\n        this.size++;\\n    }\\n\\n    isEmpty() {\\n        return this.size === 0\\n    }\\n\\n    peek() {\\n        return this.isEmpty() ? undefined : this.arr[0]\\n    }\\n}\\n\\ntype RoomHeap = {\\n    roomNumber: number,\\n    time: number\\n}\\nfunction mostBooked(n: number, meetings: number[][]): number {\\n    meetings.sort((a, b) => a[0] - b[0])\\n\\n    let counter = Array(n).fill(0)\\n\\n    let freeRooms = new MinHeap()\\n    let occupiedRooms = new MinHeap<RoomHeap>(\\n        // with the same \"\"getting free\" time we need to take room with lowest number\\n        (a, b) => a.time !== b.time ? a.time < b.time : a.roomNumber < b.roomNumber\\n    )\\n\\n    for (let i = 0; i < n; i++) {\\n        freeRooms.push(i)\\n    }\\n\\n    for (let [start, end] of meetings) {\\n        // total while loop cycles can not exceed number of meetings, so it\\'s O(rooms * log(rooms))\\n        while (!occupiedRooms.isEmpty() && occupiedRooms.peek().val <= start) {\\n            let { roomNumber } = occupiedRooms.pop().data\\n            freeRooms.push(roomNumber)\\n        }\\n\\n        let roomNumber: number\\n        let realEndTime = end\\n\\n        if (freeRooms.isEmpty()) {\\n            // schedule meeting in currently occupied room\\n            let occupiedRoom = occupiedRooms.pop().data\\n            realEndTime = occupiedRoom.time + (end - start)\\n            roomNumber = occupiedRoom.roomNumber\\n        } else {\\n            // there is free room\\n            roomNumber = freeRooms.pop().val\\n        }\\n\\n        occupiedRooms.push(realEndTime, {\\n            roomNumber,\\n            time: realEndTime\\n        })\\n\\n        counter[roomNumber]++\\n    }\\n\\n    let maxMeetings = 0\\n    let roomWithMaxMeetings = -1\\n\\n    for (let i = 0; i < n; i++) {\\n        if (counter[i] > maxMeetings) {\\n            maxMeetings = counter[i]\\n            roomWithMaxMeetings = i\\n        }\\n    }\\n\\n    return roomWithMaxMeetings\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass HeapNode<T = never> {\\n    val: number;\\n    data?: T;\\n\\n    constructor(val: number, data?: T) {\\n        this.val = val;\\n        this.data = data;\\n    }\\n}\\n\\nclass MinHeap<T> {\\n    arr: HeapNode<T>[] = [];\\n    size = 0;\\n\\n    compare: (nodeA: T, nodeB: T) => boolean | undefined;\\n\\n    shouldBeAbove(nodeA: HeapNode<T>, nodeB: HeapNode<T>) {\\n        return this.compare ? this.compare(nodeA.data, nodeB.data) : nodeA.val < nodeB.val;\\n    }\\n\\n    constructor(compare: (nodeA: T, nodeB: T) => boolean = undefined) {\\n        this.compare = compare;\\n    }\\n\\n    pop(): HeapNode<T> | undefined {\\n        if (this.size === 0) {\\n            return undefined;\\n        }\\n\\n        let head = this.arr[0];\\n\\n        this.arr[0] = this.arr[this.size - 1];\\n        this.arr.length = this.size = this.size - 1;\\n        this.heapifyDown(0);\\n\\n        return head;\\n    }\\n\\n    getParentInd(ind: number): number | undefined {\\n        if (ind === 0) {\\n            return undefined;\\n        }\\n        return Math.floor((ind - 1) / 2);\\n    }\\n\\n    getChildIndexes(ind: number): number[] {\\n        return [ind * 2 + 1, ind * 2 + 2].filter(\\n            (ind) => ind < this.size\\n        );\\n    }\\n\\n    swap(indA: number, indB: number) {\\n        let temp = this.arr[indA];\\n        this.arr[indA] = this.arr[indB];\\n        this.arr[indB] = temp;\\n    }\\n\\n    heapifyDown(cur: number) {\\n        let childrenIndexes = this.getChildIndexes(cur);\\n        if (childrenIndexes.length > 0) {\\n            let maxChildInd =\\n                childrenIndexes.length > 1 &&\\n                    this.shouldBeAbove(this.arr[childrenIndexes[1]], this.arr[childrenIndexes[0]])\\n                    ? childrenIndexes[1]\\n                    : childrenIndexes[0];\\n\\n            if (this.shouldBeAbove(this.arr[maxChildInd], this.arr[cur])) {\\n                this.swap(cur, maxChildInd);\\n                this.heapifyDown(maxChildInd);\\n            }\\n        }\\n    }\\n\\n    heapifyUp(cur: number) {\\n        let parent = this.getParentInd(cur);\\n        if (parent !== undefined && this.shouldBeAbove(this.arr[cur], this.arr[parent])) {\\n            this.swap(cur, parent);\\n            this.heapifyUp(parent);\\n        }\\n    }\\n\\n    push(val: number, data: T = undefined) {\\n        this.arr[this.size] = new HeapNode<T>(val, data);\\n        this.heapifyUp(this.size);\\n        this.size++;\\n    }\\n\\n    isEmpty() {\\n        return this.size === 0\\n    }\\n\\n    peek() {\\n        return this.isEmpty() ? undefined : this.arr[0]\\n    }\\n}\\n\\ntype RoomHeap = {\\n    roomNumber: number,\\n    time: number\\n}\\nfunction mostBooked(n: number, meetings: number[][]): number {\\n    meetings.sort((a, b) => a[0] - b[0])\\n\\n    let counter = Array(n).fill(0)\\n\\n    let freeRooms = new MinHeap()\\n    let occupiedRooms = new MinHeap<RoomHeap>(\\n        // with the same \"\"getting free\" time we need to take room with lowest number\\n        (a, b) => a.time !== b.time ? a.time < b.time : a.roomNumber < b.roomNumber\\n    )\\n\\n    for (let i = 0; i < n; i++) {\\n        freeRooms.push(i)\\n    }\\n\\n    for (let [start, end] of meetings) {\\n        // total while loop cycles can not exceed number of meetings, so it\\'s O(rooms * log(rooms))\\n        while (!occupiedRooms.isEmpty() && occupiedRooms.peek().val <= start) {\\n            let { roomNumber } = occupiedRooms.pop().data\\n            freeRooms.push(roomNumber)\\n        }\\n\\n        let roomNumber: number\\n        let realEndTime = end\\n\\n        if (freeRooms.isEmpty()) {\\n            // schedule meeting in currently occupied room\\n            let occupiedRoom = occupiedRooms.pop().data\\n            realEndTime = occupiedRoom.time + (end - start)\\n            roomNumber = occupiedRoom.roomNumber\\n        } else {\\n            // there is free room\\n            roomNumber = freeRooms.pop().val\\n        }\\n\\n        occupiedRooms.push(realEndTime, {\\n            roomNumber,\\n            time: realEndTime\\n        })\\n\\n        counter[roomNumber]++\\n    }\\n\\n    let maxMeetings = 0\\n    let roomWithMaxMeetings = -1\\n\\n    for (let i = 0; i < n; i++) {\\n        if (counter[i] > maxMeetings) {\\n            maxMeetings = counter[i]\\n            roomWithMaxMeetings = i\\n        }\\n    }\\n\\n    return roomWithMaxMeetings\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908421,
                "title": "two-min-heaps-method-in-c",
                "content": "# Complexity\\n- Time complexity: klog(k) + nlog(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: k + n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) \\n    {\\n        int m = meetings.size();\\n        // min heap: ending time & room number\\n        priority_queue<pair<long,int>, vector<pair<long,int>>, greater<pair<long,int>>> inUseEndTimes;\\n        // min heap: room number\\n        priority_queue<int, vector<int>, greater<int>> emptyRooms;\\n\\n        sort(meetings.begin(), meetings.end());\\n\\n        vector<int> cnt(n);\\n        for (int i = 0; i < n; ++i)\\n        {\\n            // room number\\n            emptyRooms.push(i);\\n        }\\n\\n        int ind = 0;\\n\\n        long clock = 0;\\n        while (ind < m)\\n        {\\n            // There is no empty room\\n            if (emptyRooms.empty())\\n            {\\n                // if we need to wait for one of the meetings to end, let\\'s move the clock forward\\n                // until the earliest end time.\\n                auto [endTime, roomNumber] = inUseEndTimes.top();\\n                \\n                inUseEndTimes.pop();\\n                clock = endTime;\\n                while (!inUseEndTimes.empty() && inUseEndTimes.top().first <= clock)\\n                {\\n                    auto [endTime, roomNumber] = inUseEndTimes.top();\\n                    inUseEndTimes.pop();\\n                    emptyRooms.push(roomNumber);\\n                }\\n                emptyRooms.push(roomNumber);\\n            }\\n            else\\n            {\\n                // there is empty room, so let\\'s assign the next meeting\\n                int startTime = meetings[ind][0];\\n                int duration = meetings[ind][1] - meetings[ind][0];\\n\\n                if (clock < startTime)\\n                {\\n                    // However, if current clock is earlier than the start of this meeting, we need to wait\\n                    // Let\\'s fastforward to earliest time we can\\n                    clock = startTime;\\n                    if (!inUseEndTimes.empty())\\n                    {\\n                        // release all the rooms that are finished due to this forwarding time\\n                        while (!inUseEndTimes.empty() && inUseEndTimes.top().first <= clock)\\n                        {\\n                            auto [endTime, roomNumber] = inUseEndTimes.top();\\n                            inUseEndTimes.pop();\\n                            emptyRooms.push(roomNumber);\\n                        }\\n                    }\\n                }\\n\\n                // now we\\'ve updated the emptyRooms, and we can pick the room with lowest number\\n                int room = emptyRooms.top();\\n                emptyRooms.pop();\\n\\n                inUseEndTimes.push(pair(clock + duration, room));\\n                cnt[room]++;\\n                ind++;\\n            }\\n        }\\n\\n        int maxCnt = 0;\\n        int maxRoom = 0;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            if (cnt[i] > maxCnt)\\n            {\\n                maxRoom = i;\\n                maxCnt = cnt[i];\\n            }\\n        }\\n\\n        return maxRoom;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) \\n    {\\n        int m = meetings.size();\\n        // min heap: ending time & room number\\n        priority_queue<pair<long,int>, vector<pair<long,int>>, greater<pair<long,int>>> inUseEndTimes;\\n        // min heap: room number\\n        priority_queue<int, vector<int>, greater<int>> emptyRooms;\\n\\n        sort(meetings.begin(), meetings.end());\\n\\n        vector<int> cnt(n);\\n        for (int i = 0; i < n; ++i)\\n        {\\n            // room number\\n            emptyRooms.push(i);\\n        }\\n\\n        int ind = 0;\\n\\n        long clock = 0;\\n        while (ind < m)\\n        {\\n            // There is no empty room\\n            if (emptyRooms.empty())\\n            {\\n                // if we need to wait for one of the meetings to end, let\\'s move the clock forward\\n                // until the earliest end time.\\n                auto [endTime, roomNumber] = inUseEndTimes.top();\\n                \\n                inUseEndTimes.pop();\\n                clock = endTime;\\n                while (!inUseEndTimes.empty() && inUseEndTimes.top().first <= clock)\\n                {\\n                    auto [endTime, roomNumber] = inUseEndTimes.top();\\n                    inUseEndTimes.pop();\\n                    emptyRooms.push(roomNumber);\\n                }\\n                emptyRooms.push(roomNumber);\\n            }\\n            else\\n            {\\n                // there is empty room, so let\\'s assign the next meeting\\n                int startTime = meetings[ind][0];\\n                int duration = meetings[ind][1] - meetings[ind][0];\\n\\n                if (clock < startTime)\\n                {\\n                    // However, if current clock is earlier than the start of this meeting, we need to wait\\n                    // Let\\'s fastforward to earliest time we can\\n                    clock = startTime;\\n                    if (!inUseEndTimes.empty())\\n                    {\\n                        // release all the rooms that are finished due to this forwarding time\\n                        while (!inUseEndTimes.empty() && inUseEndTimes.top().first <= clock)\\n                        {\\n                            auto [endTime, roomNumber] = inUseEndTimes.top();\\n                            inUseEndTimes.pop();\\n                            emptyRooms.push(roomNumber);\\n                        }\\n                    }\\n                }\\n\\n                // now we\\'ve updated the emptyRooms, and we can pick the room with lowest number\\n                int room = emptyRooms.top();\\n                emptyRooms.pop();\\n\\n                inUseEndTimes.push(pair(clock + duration, room));\\n                cnt[room]++;\\n                ind++;\\n            }\\n        }\\n\\n        int maxCnt = 0;\\n        int maxRoom = 0;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            if (cnt[i] > maxCnt)\\n            {\\n                maxRoom = i;\\n                maxCnt = cnt[i];\\n            }\\n        }\\n\\n        return maxRoom;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905717,
                "title": "c-ordered-set-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) \\n    {\\n        sort(meetings.begin(), meetings.end());\\n        int m = meetings.size();\\n        map<long long, long long> mp, mpInd;\\n        set<pair<long long, long long>> st;\\n        for(int i = 0; i < m; ++i) {\\n            for(auto it: st) {\\n                long long time = it.first;\\n                long long room = it.second;\\n                if(time > meetings[i][0]) {\\n                    break;\\n                }\\n                mpInd.erase(room);\\n                st.erase(it);\\n            }\\n\\n            if(st.size() == 0) {\\n                st.insert({meetings[i][1], 0});\\n                mp[0]++;\\n                mpInd[0] = 1;\\n                continue;\\n            }\\n\\n            if(st.size() == n) {\\n                auto it = *(st.begin());\\n                long long time = it.first;\\n                long long room = it.second;\\n                st.erase(it);\\n                mp[room]++;\\n                st.insert({time + (meetings[i][1] - meetings[i][0]), room}); \\n            }\\n\\n            else {\\n                long long minInd = 0;\\n                for(auto it: mpInd) {\\n                    if(it.first != minInd) {\\n                        break;\\n                    }\\n                    minInd++;\\n                }\\n                mp[minInd]++;\\n                mpInd[minInd] = 1;\\n                st.insert({meetings[i][1], minInd});\\n            }\\n        }\\n        long long ans = -1;\\n        int ind = -1;\\n        for(auto it: mp) {\\n            if(it.second > ans) {\\n                ans = it.second;\\n                ind = it.first;\\n            }\\n        }\\n\\n        return ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) \\n    {\\n        sort(meetings.begin(), meetings.end());\\n        int m = meetings.size();\\n        map<long long, long long> mp, mpInd;\\n        set<pair<long long, long long>> st;\\n        for(int i = 0; i < m; ++i) {\\n            for(auto it: st) {\\n                long long time = it.first;\\n                long long room = it.second;\\n                if(time > meetings[i][0]) {\\n                    break;\\n                }\\n                mpInd.erase(room);\\n                st.erase(it);\\n            }\\n\\n            if(st.size() == 0) {\\n                st.insert({meetings[i][1], 0});\\n                mp[0]++;\\n                mpInd[0] = 1;\\n                continue;\\n            }\\n\\n            if(st.size() == n) {\\n                auto it = *(st.begin());\\n                long long time = it.first;\\n                long long room = it.second;\\n                st.erase(it);\\n                mp[room]++;\\n                st.insert({time + (meetings[i][1] - meetings[i][0]), room}); \\n            }\\n\\n            else {\\n                long long minInd = 0;\\n                for(auto it: mpInd) {\\n                    if(it.first != minInd) {\\n                        break;\\n                    }\\n                    minInd++;\\n                }\\n                mp[minInd]++;\\n                mpInd[minInd] = 1;\\n                st.insert({meetings[i][1], minInd});\\n            }\\n        }\\n        long long ans = -1;\\n        int ind = -1;\\n        for(auto it: mp) {\\n            if(it.second > ans) {\\n                ans = it.second;\\n                ind = it.first;\\n            }\\n        }\\n\\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883822,
                "title": "not-sure-why-this-code-is-not-working-can-some-one-please-explain",
                "content": "I am not sure why this code is not working. It is failing at 70/82 test cases with **wrong output**\\n\\nThe failing test case:\\n```\\n2\\n[[43,44],[34,36],[11,47],[1,8],[30,33],[45,48],[23,41],[29,30]]\\n\\nExpected: 1\\nMy output: 0\\n```\\n\\nThe code is as follows:\\n\\n```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        int[] room = new int[n];\\n        boolean[] filled = new boolean[n];\\n        int len = meetings.length;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new CustomComparator());\\n        Arrays.sort(meetings, (t1, t2) -> (Integer.compare(t1[0], t2[0])));\\n        int idx = 0;\\n        int time = 0;\\n        \\n        while(!pq.isEmpty() || idx < len) {\\n            emptyRoomsIfPossible(pq, time, filled);\\n            int roomAvail = whichRoomAvailable(filled);\\n            if (roomAvail == -1) {\\n                // if room is not available, \\n                time++;\\n            } else {\\n                if (idx < len) {\\n                    if (time >= meetings[idx][0]) {\\n                        int endTime = (meetings[idx][1] - meetings[idx][0]) + time;\\n                        int[] toInsert = new int[]{time, endTime, roomAvail};\\n                        pq.offer(toInsert);\\n                        filled[roomAvail] = true;\\n                        room[roomAvail]++;\\n                        idx++;\\n                        time++;\\n                    } else {\\n                        time++;\\n                    }\\n                } else {\\n                    time++;\\n                }\\n            }\\n        }\\n        \\n        int count = 0;\\n        int res = 0;\\n        \\n        for(int i=0; i<room.length; i++) {\\n            if (room[i] > count) {\\n                count = room[i];\\n                res = i;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void emptyRoomsIfPossible(PriorityQueue<int[]> pq, int time, boolean[] filled) {\\n        while(!pq.isEmpty() && pq.peek()[1] <= time) {\\n            int[] arr = pq.poll();\\n            filled[arr[2]] = false;\\n        }\\n    }\\n    \\n    int whichRoomAvailable(boolean filled[]) {\\n        for(int i=0; i<filled.length; i++) {\\n            if (!filled[i]) {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n  \\n    \\n    class CustomComparator implements Comparator<int[]> {\\n        public int compare(int[] a, int[] b) {\\n            return Integer.compare(a[1], b[1]);\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n2\\n[[43,44],[34,36],[11,47],[1,8],[30,33],[45,48],[23,41],[29,30]]\\n\\nExpected: 1\\nMy output: 0\\n```\n```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        int[] room = new int[n];\\n        boolean[] filled = new boolean[n];\\n        int len = meetings.length;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new CustomComparator());\\n        Arrays.sort(meetings, (t1, t2) -> (Integer.compare(t1[0], t2[0])));\\n        int idx = 0;\\n        int time = 0;\\n        \\n        while(!pq.isEmpty() || idx < len) {\\n            emptyRoomsIfPossible(pq, time, filled);\\n            int roomAvail = whichRoomAvailable(filled);\\n            if (roomAvail == -1) {\\n                // if room is not available, \\n                time++;\\n            } else {\\n                if (idx < len) {\\n                    if (time >= meetings[idx][0]) {\\n                        int endTime = (meetings[idx][1] - meetings[idx][0]) + time;\\n                        int[] toInsert = new int[]{time, endTime, roomAvail};\\n                        pq.offer(toInsert);\\n                        filled[roomAvail] = true;\\n                        room[roomAvail]++;\\n                        idx++;\\n                        time++;\\n                    } else {\\n                        time++;\\n                    }\\n                } else {\\n                    time++;\\n                }\\n            }\\n        }\\n        \\n        int count = 0;\\n        int res = 0;\\n        \\n        for(int i=0; i<room.length; i++) {\\n            if (room[i] > count) {\\n                count = room[i];\\n                res = i;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void emptyRoomsIfPossible(PriorityQueue<int[]> pq, int time, boolean[] filled) {\\n        while(!pq.isEmpty() && pq.peek()[1] <= time) {\\n            int[] arr = pq.poll();\\n            filled[arr[2]] = false;\\n        }\\n    }\\n    \\n    int whichRoomAvailable(boolean filled[]) {\\n        for(int i=0; i<filled.length; i++) {\\n            if (!filled[i]) {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n  \\n    \\n    class CustomComparator implements Comparator<int[]> {\\n        public int compare(int[] a, int[] b) {\\n            return Integer.compare(a[1], b[1]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871167,
                "title": "meeting-rooms-iii-easy-heap-sorting-well-explained",
                "content": "# Code\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        import heapq as hq\\n        meetings.sort(key=lambda x:x[0])\\n        # print(meetings)\\n        avail=[]\\n        for i in range(n):\\n            avail.append(i)\\n        hq.heapify(avail)\\n        proc=[]\\n        t=0\\n        hq.heapify(proc)\\n        count=[0]*n\\n        j=0\\n        for i in range(len(meetings)):\\n            t=meetings[i][0]\\n            while len(proc) and proc[0][0]<=t:\\n                x1=hq.heappop(proc)\\n                hq.heappush(avail,x1[1])\\n            f=True\\n            if len(avail):\\n                f=False\\n                x=hq.heappop(avail)\\n                count[x]+=1\\n                hq.heappush(proc,[meetings[i][1],x])\\n            if f:\\n                if len(proc):\\n                    x1=hq.heappop(proc)\\n                    count[x1[1]]+=1\\n                    diff=abs(x1[0]-meetings[i][0])\\n                    hq.heappush(proc,[meetings[i][1]+diff,x1[1]])\\n        # print(count)\\n        mx=float(\"-inf\")\\n        ind=-1\\n        for i in range(len(count)):\\n            if count[i]>mx:\\n                mx=count[i]\\n                ind=i\\n        return(ind)\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        import heapq as hq\\n        meetings.sort(key=lambda x:x[0])\\n        # print(meetings)\\n        avail=[]\\n        for i in range(n):\\n            avail.append(i)\\n        hq.heapify(avail)\\n        proc=[]\\n        t=0\\n        hq.heapify(proc)\\n        count=[0]*n\\n        j=0\\n        for i in range(len(meetings)):\\n            t=meetings[i][0]\\n            while len(proc) and proc[0][0]<=t:\\n                x1=hq.heappop(proc)\\n                hq.heappush(avail,x1[1])\\n            f=True\\n            if len(avail):\\n                f=False\\n                x=hq.heappop(avail)\\n                count[x]+=1\\n                hq.heappush(proc,[meetings[i][1],x])\\n            if f:\\n                if len(proc):\\n                    x1=hq.heappop(proc)\\n                    count[x1[1]]+=1\\n                    diff=abs(x1[0]-meetings[i][0])\\n                    hq.heappush(proc,[meetings[i][1]+diff,x1[1]])\\n        # print(count)\\n        mx=float(\"-inf\")\\n        ind=-1\\n        for i in range(len(count)):\\n            if count[i]>mx:\\n                mx=count[i]\\n                ind=i\\n        return(ind)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864929,
                "title": "100-java-solution-no-heap-no-sorting-o-m-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNormal traversing over the data, iterating over each meeting, and putting it in the first available room if exists, or the closest to be free.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute force, but it\\'s better than using heap and re-adjust it for each iteration, which is a Brute force itself plus sorting the heap.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\nm: number of meetings.\\nn: number of rooms.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        // init\\n        int[] meetingsCount = new int[n];\\n        long[] rooms = new long[n];\\n        Arrays.sort(meetings, (meeting_a, meeting_b) -> meeting_a[0] - meeting_b[0]);\\n\\n        // logic\\n        int closestRoomIndex = 0;\\n        long closestRoom = rooms[0];\\n        boolean freeRoom = false;\\n        for(int[] meeting : meetings) {\\n            closestRoomIndex = 0;\\n            closestRoom = rooms[0];\\n            freeRoom = false;\\n            for (int j = 0; j < n; j++) {\\n                if (meeting[0] >= rooms[j]) {\\n                    rooms[j] = meeting[1];\\n                    meetingsCount[j]++;\\n                    freeRoom = true;\\n                    break;\\n                }\\n                if (rooms[j] < closestRoom) {\\n                    closestRoomIndex = j;\\n                    closestRoom = rooms[j];\\n                }\\n            }\\n            if (!freeRoom) {\\n                rooms[closestRoomIndex] = rooms[closestRoomIndex] + meeting[1] - meeting[0];\\n                meetingsCount[closestRoomIndex]++;\\n            }\\n        }\\n\\n        // output\\n        int max = 0, maxIndex = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (meetingsCount[i] > max) {\\n                max = meetingsCount[i];\\n                maxIndex = i;\\n            }\\n        }\\n        \\n        return maxIndex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        // init\\n        int[] meetingsCount = new int[n];\\n        long[] rooms = new long[n];\\n        Arrays.sort(meetings, (meeting_a, meeting_b) -> meeting_a[0] - meeting_b[0]);\\n\\n        // logic\\n        int closestRoomIndex = 0;\\n        long closestRoom = rooms[0];\\n        boolean freeRoom = false;\\n        for(int[] meeting : meetings) {\\n            closestRoomIndex = 0;\\n            closestRoom = rooms[0];\\n            freeRoom = false;\\n            for (int j = 0; j < n; j++) {\\n                if (meeting[0] >= rooms[j]) {\\n                    rooms[j] = meeting[1];\\n                    meetingsCount[j]++;\\n                    freeRoom = true;\\n                    break;\\n                }\\n                if (rooms[j] < closestRoom) {\\n                    closestRoomIndex = j;\\n                    closestRoom = rooms[j];\\n                }\\n            }\\n            if (!freeRoom) {\\n                rooms[closestRoomIndex] = rooms[closestRoomIndex] + meeting[1] - meeting[0];\\n                meetingsCount[closestRoomIndex]++;\\n            }\\n        }\\n\\n        // output\\n        int max = 0, maxIndex = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (meetingsCount[i] > max) {\\n                max = meetingsCount[i];\\n                maxIndex = i;\\n            }\\n        }\\n        \\n        return maxIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863955,
                "title": "easy-c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n     int m=meetings.size();\\n     vector<int>ans(n,0);\\n     vector<long long >times(n,0);\\n     sort(meetings.begin(),meetings.end());\\n     for(int i=0;i<m;i++){\\n           int start=meetings[i][0];\\n           int end=meetings[i][1];\\n           bool flag=false;\\n           int idx=-1;\\n           long long val=1e18;\\n           for(int j=0;j<n;j++){\\n               if(times[j]<val){\\n                   val=times[j];\\n                   idx=j;\\n               }\\n               if(times[j]<=start){\\n              flag=true;\\n              ans[j]++;\\n              times[j]=end;\\n              break;\\n               }\\n           }\\n           if(!flag){\\n               ans[idx]++;\\n               times[idx]+=(1ll*(end-start));\\n           }\\n     }\\n     int maxi=-1,f_idx=-1;\\n     for(int i=0;i<n;i++){\\n         if(ans[i]>maxi){\\n           maxi=ans[i];\\n           f_idx=i;\\n         }\\n     }\\n     return f_idx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n     int m=meetings.size();\\n     vector<int>ans(n,0);\\n     vector<long long >times(n,0);\\n     sort(meetings.begin(),meetings.end());\\n     for(int i=0;i<m;i++){\\n           int start=meetings[i][0];\\n           int end=meetings[i][1];\\n           bool flag=false;\\n           int idx=-1;\\n           long long val=1e18;\\n           for(int j=0;j<n;j++){\\n               if(times[j]<val){\\n                   val=times[j];\\n                   idx=j;\\n               }\\n               if(times[j]<=start){\\n              flag=true;\\n              ans[j]++;\\n              times[j]=end;\\n              break;\\n               }\\n           }\\n           if(!flag){\\n               ans[idx]++;\\n               times[idx]+=(1ll*(end-start));\\n           }\\n     }\\n     int maxi=-1,f_idx=-1;\\n     for(int i=0;i<n;i++){\\n         if(ans[i]>maxi){\\n           maxi=ans[i];\\n           f_idx=i;\\n         }\\n     }\\n     return f_idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860678,
                "title": "a-simple-heap-solution-beating-97-in-execution-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is quite similar to 1606. Find servers that handled most numbers of requests\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- A heap to manage meetings with latest ending times\\n- A heap to get the smallest available room number\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings = sorted(meetings)\\n        rooms = [0] * n\\n        queue = []\\n        unused = list(range(n))\\n        for s, e in meetings:\\n            while queue and queue[0][0] <= s:\\n                _, r = heapq.heappop(queue)\\n                heapq.heappush(unused, r)\\n\\n            if unused: \\n                # use the first room\\n                used_room = heapq.heappop(unused)\\n                rooms[used_room] += 1\\n                heapq.heappush(queue, (e, used_room))\\n            else: # all rooms are in used\\n                end_time, reused_room = heapq.heappop(queue)\\n                end_time = e - s + end_time\\n                rooms[reused_room] += 1\\n                heapq.heappush(queue, (end_time, reused_room))\\n            \\n        imax, mx = -1, 0\\n        for i, r in enumerate(rooms):\\n            if r <= mx: continue\\n            mx = r\\n            imax = i\\n        return imax\\n\\n\\n                \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings = sorted(meetings)\\n        rooms = [0] * n\\n        queue = []\\n        unused = list(range(n))\\n        for s, e in meetings:\\n            while queue and queue[0][0] <= s:\\n                _, r = heapq.heappop(queue)\\n                heapq.heappush(unused, r)\\n\\n            if unused: \\n                # use the first room\\n                used_room = heapq.heappop(unused)\\n                rooms[used_room] += 1\\n                heapq.heappush(queue, (e, used_room))\\n            else: # all rooms are in used\\n                end_time, reused_room = heapq.heappop(queue)\\n                end_time = e - s + end_time\\n                rooms[reused_room] += 1\\n                heapq.heappush(queue, (end_time, reused_room))\\n            \\n        imax, mx = -1, 0\\n        for i, r in enumerate(rooms):\\n            if r <= mx: continue\\n            mx = r\\n            imax = i\\n        return imax\\n\\n\\n                \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855954,
                "title": "java-two-priorityqueues",
                "content": "# Code\\n```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        int[] count = new int[n];\\n        PriorityQueue<long[]> pq = new PriorityQueue<>( (long[] v1, long[] v2) -> (v1[0] == v2[0]) ? Long.compare(v1[1], v2[1]) : Long.compare(v1[0], v2[0]) );\\n\\n        Arrays.sort(meetings, (int[] m1, int[] m2) -> Integer.compare(m1[0], m2[0]));\\n\\n        PriorityQueue<Integer> pqAvailable = new PriorityQueue<>();\\n        for (int i = 0; i < n; i++) {\\n            pqAvailable.add(i);\\n        }\\n\\n        long[] room;\\n\\n        for (int[] meeting : meetings) {\\n\\n            while ( ! pq.isEmpty() && pq.peek()[0] <= meeting[0]) {\\n                pqAvailable.add((int)pq.poll()[1]);\\n            }\\n\\n            if ( ! pqAvailable.isEmpty()) {\\n               room = new long[]{meeting[1], pqAvailable.poll()}; \\n            } else {\\n                room = pq.poll();\\n                room[0] += (meeting[1]-meeting[0]);\\n            }\\n            \\n            count[(int)room[1]]++;\\n            //System.out.println(\"room:\"+room[1]+\" end:\"+room[0]);\\n            pq.add(room);\\n        }\\n\\n        int maxI = n-1;\\n        for (int i = n-2; i>=0; i--) {\\n            if (count[i] >= count[maxI]) {\\n                maxI = i;\\n            }\\n        }\\n        return maxI;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        int[] count = new int[n];\\n        PriorityQueue<long[]> pq = new PriorityQueue<>( (long[] v1, long[] v2) -> (v1[0] == v2[0]) ? Long.compare(v1[1], v2[1]) : Long.compare(v1[0], v2[0]) );\\n\\n        Arrays.sort(meetings, (int[] m1, int[] m2) -> Integer.compare(m1[0], m2[0]));\\n\\n        PriorityQueue<Integer> pqAvailable = new PriorityQueue<>();\\n        for (int i = 0; i < n; i++) {\\n            pqAvailable.add(i);\\n        }\\n\\n        long[] room;\\n\\n        for (int[] meeting : meetings) {\\n\\n            while ( ! pq.isEmpty() && pq.peek()[0] <= meeting[0]) {\\n                pqAvailable.add((int)pq.poll()[1]);\\n            }\\n\\n            if ( ! pqAvailable.isEmpty()) {\\n               room = new long[]{meeting[1], pqAvailable.poll()}; \\n            } else {\\n                room = pq.poll();\\n                room[0] += (meeting[1]-meeting[0]);\\n            }\\n            \\n            count[(int)room[1]]++;\\n            //System.out.println(\"room:\"+room[1]+\" end:\"+room[0]);\\n            pq.add(room);\\n        }\\n\\n        int maxI = n-1;\\n        for (int i = n-2; i>=0; i--) {\\n            if (count[i] >= count[maxI]) {\\n                maxI = i;\\n            }\\n        }\\n        return maxI;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849259,
                "title": "python-1-heap-23-lines-beats-97-89-in-speed-and-59-31-in-memory",
                "content": "# Code\\n```\\nimport heapq\\n\\n\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        bookings = [0] * n\\n        avails = [(0, i) for i in range(n)]  # (available time, room index)\\n        heapq.heapify(avails)\\n\\n        meetings = sorted(meetings, key=lambda x: x[0])\\n        for meeting in meetings:\\n            start_time, end_time = meeting\\n\\n            # Find the earliest available room\\n            earliest_avail_time, room_idx = heapq.heappop(avails)\\n            while earliest_avail_time < start_time:\\n                heapq.heappush(avails, (start_time, room_idx))\\n                earliest_avail_time, room_idx = heapq.heappop(avails)\\n\\n            # Update the available time for the room and add the booking\\n            avail_time = max(earliest_avail_time, start_time) + (end_time - start_time)\\n            heapq.heappush(avails, (avail_time, room_idx))\\n            bookings[room_idx] += 1\\n        return bookings.index(max(bookings))\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\n\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        bookings = [0] * n\\n        avails = [(0, i) for i in range(n)]  # (available time, room index)\\n        heapq.heapify(avails)\\n\\n        meetings = sorted(meetings, key=lambda x: x[0])\\n        for meeting in meetings:\\n            start_time, end_time = meeting\\n\\n            # Find the earliest available room\\n            earliest_avail_time, room_idx = heapq.heappop(avails)\\n            while earliest_avail_time < start_time:\\n                heapq.heappush(avails, (start_time, room_idx))\\n                earliest_avail_time, room_idx = heapq.heappop(avails)\\n\\n            # Update the available time for the room and add the booking\\n            avail_time = max(earliest_avail_time, start_time) + (end_time - start_time)\\n            heapq.heappush(avails, (avail_time, room_idx))\\n            bookings[room_idx] += 1\\n        return bookings.index(max(bookings))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849062,
                "title": "sol-using-2-heaps-to-maintain-busy-and-available-rooms",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        busy = []\\n        available = [i for i in range(n)]\\n        rooms = [0] * n\\n\\n        meetings.sort()\\n\\n        print(meetings)\\n\\n        for start,end in meetings:\\n            while busy and busy[0][0] <= start:\\n                _, room = heapq.heappop(busy)\\n                heapq.heappush(available, room)\\n\\n            if available:\\n                room = heapq.heappop(available)\\n                heapq.heappush(busy, (end, room))\\n            else:\\n                time, room = heapq.heappop(busy)\\n                heapq.heappush(busy, (time + end-start, room))\\n            \\n            rooms[room] += 1\\n        \\n        return rooms.index(max(rooms))\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        busy = []\\n        available = [i for i in range(n)]\\n        rooms = [0] * n\\n\\n        meetings.sort()\\n\\n        print(meetings)\\n\\n        for start,end in meetings:\\n            while busy and busy[0][0] <= start:\\n                _, room = heapq.heappop(busy)\\n                heapq.heappush(available, room)\\n\\n            if available:\\n                room = heapq.heappop(available)\\n                heapq.heappush(busy, (end, room))\\n            else:\\n                time, room = heapq.heappop(busy)\\n                heapq.heappush(busy, (time + end-start, room))\\n            \\n            rooms[room] += 1\\n        \\n        return rooms.index(max(rooms))\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844193,
                "title": "c-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    private Dictionary<int, int> _rooms = new Dictionary<int, int>();\\n    private PriorityQueue<int, int> _freeRoom = new PriorityQueue<int, int>();\\n    private PriorityQueue<Room, Room> _occupiedRoom = new PriorityQueue<Room, Room>();\\n\\n    class Room : IComparable<Room>\\n    {\\n        public int Index { get; set; }\\n\\n        public long AvailableAt { get; set; }\\n\\n        public Room(int index, long availableAt)\\n        {\\n            Index = index;\\n            AvailableAt = availableAt;\\n        }\\n\\n        public int CompareTo(Room? other)\\n        {\\n            if (AvailableAt == other.AvailableAt)\\n            {\\n                return Index.CompareTo(other.Index);\\n            }\\n\\n            return AvailableAt.CompareTo(other.AvailableAt);\\n        }\\n    }\\n    \\n    public int MostBooked(int n, int[][] meetings)\\n    {\\n        InitializeMeeting(n, meetings);\\n        long time = 0;\\n        \\n        Array.Sort(meetings, (x,y) => x[0] - y[0]);\\n        \\n        foreach (var meeting in meetings)\\n        {\\n            time = Math.Max(time, meeting[0]);\\n            \\n            if (_freeRoom.Count == 0) {\\n                long earliestFreeTime = _occupiedRoom.Peek().AvailableAt;\\n                time = Math.Max(earliestFreeTime, time);\\n            }\\n            \\n            while (_occupiedRoom.Count > 0 && _occupiedRoom.Peek().AvailableAt <= time)\\n            {\\n                var room = _occupiedRoom.Dequeue();\\n                _freeRoom.Enqueue(room.Index, room.Index);\\n            }\\n\\n            var freeRoomNumber = _freeRoom.Dequeue();\\n\\n            var occupiedRoom = new Room(freeRoomNumber, time + meeting[1] - meeting[0]);\\n            _occupiedRoom.Enqueue(occupiedRoom, occupiedRoom);\\n\\n            _rooms[freeRoomNumber]++;\\n        }\\n\\n        var maxCount = 0;\\n        var index = 0;\\n        \\n        foreach (var pair in _rooms)\\n        {\\n            if (maxCount < pair.Value)\\n            {\\n                maxCount = pair.Value;\\n                index = pair.Key;\\n            }\\n        }\\n        \\n        return index;\\n    }\\n\\n    void InitializeMeeting(int n, int[][] meetings)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            _rooms[i] = 0;\\n            _freeRoom.Enqueue(i, i);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    private Dictionary<int, int> _rooms = new Dictionary<int, int>();\\n    private PriorityQueue<int, int> _freeRoom = new PriorityQueue<int, int>();\\n    private PriorityQueue<Room, Room> _occupiedRoom = new PriorityQueue<Room, Room>();\\n\\n    class Room : IComparable<Room>\\n    {\\n        public int Index { get; set; }\\n\\n        public long AvailableAt { get; set; }\\n\\n        public Room(int index, long availableAt)\\n        {\\n            Index = index;\\n            AvailableAt = availableAt;\\n        }\\n\\n        public int CompareTo(Room? other)\\n        {\\n            if (AvailableAt == other.AvailableAt)\\n            {\\n                return Index.CompareTo(other.Index);\\n            }\\n\\n            return AvailableAt.CompareTo(other.AvailableAt);\\n        }\\n    }\\n    \\n    public int MostBooked(int n, int[][] meetings)\\n    {\\n        InitializeMeeting(n, meetings);\\n        long time = 0;\\n        \\n        Array.Sort(meetings, (x,y) => x[0] - y[0]);\\n        \\n        foreach (var meeting in meetings)\\n        {\\n            time = Math.Max(time, meeting[0]);\\n            \\n            if (_freeRoom.Count == 0) {\\n                long earliestFreeTime = _occupiedRoom.Peek().AvailableAt;\\n                time = Math.Max(earliestFreeTime, time);\\n            }\\n            \\n            while (_occupiedRoom.Count > 0 && _occupiedRoom.Peek().AvailableAt <= time)\\n            {\\n                var room = _occupiedRoom.Dequeue();\\n                _freeRoom.Enqueue(room.Index, room.Index);\\n            }\\n\\n            var freeRoomNumber = _freeRoom.Dequeue();\\n\\n            var occupiedRoom = new Room(freeRoomNumber, time + meeting[1] - meeting[0]);\\n            _occupiedRoom.Enqueue(occupiedRoom, occupiedRoom);\\n\\n            _rooms[freeRoomNumber]++;\\n        }\\n\\n        var maxCount = 0;\\n        var index = 0;\\n        \\n        foreach (var pair in _rooms)\\n        {\\n            if (maxCount < pair.Value)\\n            {\\n                maxCount = pair.Value;\\n                index = pair.Key;\\n            }\\n        }\\n        \\n        return index;\\n    }\\n\\n    void InitializeMeeting(int n, int[][] meetings)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            _rooms[i] = 0;\\n            _freeRoom.Enqueue(i, i);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824658,
                "title": "c-easy-solution-beats-100-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically to solve this we need to use priority queue concept. In more algorithmic terms we will be using \"heaps\".\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n))     \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        sort(meetings.begin(),meetings.end());\\n        priority_queue<pair<long long int,long long int>,vector<pair<long long int,long long int>>,greater<pair<long long int,long long int>>>ongoingMeetings;\\n        vector<long long int> numberOfMeetingsPerRoom(n,0);\\n        priority_queue<long long int,vector<long long int>,greater<long long int>> listOfRoomsAvailable;\\n        long long int currentTime = 0;\\n        for(long long int room=0;room<n;room++){\\n            listOfRoomsAvailable.push(room);\\n        }\\n        for(long long int meetingCount=0;meetingCount<meetings.size();meetingCount++){\\n            long long int startTime = meetings[meetingCount][0];\\n            long long int endTime = meetings[meetingCount][1];\\n            \\n            //Check the starting condition\\n            if(startTime>=currentTime){\\n                currentTime = startTime;\\n            }\\n\\n            //Check and vacant the meeting rooms\\n            while(ongoingMeetings.size()>0&&currentTime>=ongoingMeetings.top().first){\\n                long long int roomVacant = ongoingMeetings.top().second;\\n                listOfRoomsAvailable.push(roomVacant);\\n                ongoingMeetings.pop();\\n            }\\n\\n            //If no rooms available\\n            if(listOfRoomsAvailable.size()==0){\\n                currentTime = ongoingMeetings.top().first;\\n                while(ongoingMeetings.size()>0&&currentTime>=ongoingMeetings.top().first){\\n                    long long int roomVacant = ongoingMeetings.top().second;\\n                    listOfRoomsAvailable.push(roomVacant);\\n                    ongoingMeetings.pop();\\n                }\\n            }\\n\\n            endTime += (currentTime-startTime); \\n\\n            //Push the current meeting\\n            long long int roomAvailable = listOfRoomsAvailable.top();\\n            listOfRoomsAvailable.pop();\\n            ongoingMeetings.push({endTime,roomAvailable});\\n\\n            //Increase the count of meeting in that room\\n            numberOfMeetingsPerRoom[roomAvailable]++;\\n        }\\n\\n        long long int roomHavingMaxMeeting = 0;\\n        long long int maxCountOfMeeting = numberOfMeetingsPerRoom[0];\\n        for(long long int room=0;room<n;room++){\\n            if(maxCountOfMeeting<numberOfMeetingsPerRoom[room]){\\n                roomHavingMaxMeeting = room;\\n                maxCountOfMeeting = numberOfMeetingsPerRoom[room];\\n            }\\n        }\\n        return roomHavingMaxMeeting;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        sort(meetings.begin(),meetings.end());\\n        priority_queue<pair<long long int,long long int>,vector<pair<long long int,long long int>>,greater<pair<long long int,long long int>>>ongoingMeetings;\\n        vector<long long int> numberOfMeetingsPerRoom(n,0);\\n        priority_queue<long long int,vector<long long int>,greater<long long int>> listOfRoomsAvailable;\\n        long long int currentTime = 0;\\n        for(long long int room=0;room<n;room++){\\n            listOfRoomsAvailable.push(room);\\n        }\\n        for(long long int meetingCount=0;meetingCount<meetings.size();meetingCount++){\\n            long long int startTime = meetings[meetingCount][0];\\n            long long int endTime = meetings[meetingCount][1];\\n            \\n            //Check the starting condition\\n            if(startTime>=currentTime){\\n                currentTime = startTime;\\n            }\\n\\n            //Check and vacant the meeting rooms\\n            while(ongoingMeetings.size()>0&&currentTime>=ongoingMeetings.top().first){\\n                long long int roomVacant = ongoingMeetings.top().second;\\n                listOfRoomsAvailable.push(roomVacant);\\n                ongoingMeetings.pop();\\n            }\\n\\n            //If no rooms available\\n            if(listOfRoomsAvailable.size()==0){\\n                currentTime = ongoingMeetings.top().first;\\n                while(ongoingMeetings.size()>0&&currentTime>=ongoingMeetings.top().first){\\n                    long long int roomVacant = ongoingMeetings.top().second;\\n                    listOfRoomsAvailable.push(roomVacant);\\n                    ongoingMeetings.pop();\\n                }\\n            }\\n\\n            endTime += (currentTime-startTime); \\n\\n            //Push the current meeting\\n            long long int roomAvailable = listOfRoomsAvailable.top();\\n            listOfRoomsAvailable.pop();\\n            ongoingMeetings.push({endTime,roomAvailable});\\n\\n            //Increase the count of meeting in that room\\n            numberOfMeetingsPerRoom[roomAvailable]++;\\n        }\\n\\n        long long int roomHavingMaxMeeting = 0;\\n        long long int maxCountOfMeeting = numberOfMeetingsPerRoom[0];\\n        for(long long int room=0;room<n;room++){\\n            if(maxCountOfMeeting<numberOfMeetingsPerRoom[room]){\\n                roomHavingMaxMeeting = room;\\n                maxCountOfMeeting = numberOfMeetingsPerRoom[room];\\n            }\\n        }\\n        return roomHavingMaxMeeting;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824656,
                "title": "c-easy-solution-beats-100-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically to solve this we need to use priority queue concept. In more algorithmic terms we will be using \"heaps\".\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n))     \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        sort(meetings.begin(),meetings.end());\\n        priority_queue<pair<long long int,long long int>,vector<pair<long long int,long long int>>,greater<pair<long long int,long long int>>>ongoingMeetings;\\n        vector<long long int> numberOfMeetingsPerRoom(n,0);\\n        priority_queue<long long int,vector<long long int>,greater<long long int>> listOfRoomsAvailable;\\n        long long int currentTime = 0;\\n        for(long long int room=0;room<n;room++){\\n            listOfRoomsAvailable.push(room);\\n        }\\n        for(long long int meetingCount=0;meetingCount<meetings.size();meetingCount++){\\n            long long int startTime = meetings[meetingCount][0];\\n            long long int endTime = meetings[meetingCount][1];\\n            \\n            //Check the starting condition\\n            if(startTime>=currentTime){\\n                currentTime = startTime;\\n            }\\n\\n            //Check and vacant the meeting rooms\\n            while(ongoingMeetings.size()>0&&currentTime>=ongoingMeetings.top().first){\\n                long long int roomVacant = ongoingMeetings.top().second;\\n                listOfRoomsAvailable.push(roomVacant);\\n                ongoingMeetings.pop();\\n            }\\n\\n            //If no rooms available\\n            if(listOfRoomsAvailable.size()==0){\\n                currentTime = ongoingMeetings.top().first;\\n                while(ongoingMeetings.size()>0&&currentTime>=ongoingMeetings.top().first){\\n                    long long int roomVacant = ongoingMeetings.top().second;\\n                    listOfRoomsAvailable.push(roomVacant);\\n                    ongoingMeetings.pop();\\n                }\\n            }\\n\\n            endTime += (currentTime-startTime); \\n\\n            //Push the current meeting\\n            long long int roomAvailable = listOfRoomsAvailable.top();\\n            listOfRoomsAvailable.pop();\\n            ongoingMeetings.push({endTime,roomAvailable});\\n\\n            //Increase the count of meeting in that room\\n            numberOfMeetingsPerRoom[roomAvailable]++;\\n        }\\n\\n        long long int roomHavingMaxMeeting = 0;\\n        long long int maxCountOfMeeting = numberOfMeetingsPerRoom[0];\\n        for(long long int room=0;room<n;room++){\\n            if(maxCountOfMeeting<numberOfMeetingsPerRoom[room]){\\n                roomHavingMaxMeeting = room;\\n                maxCountOfMeeting = numberOfMeetingsPerRoom[room];\\n            }\\n        }\\n        return roomHavingMaxMeeting;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        sort(meetings.begin(),meetings.end());\\n        priority_queue<pair<long long int,long long int>,vector<pair<long long int,long long int>>,greater<pair<long long int,long long int>>>ongoingMeetings;\\n        vector<long long int> numberOfMeetingsPerRoom(n,0);\\n        priority_queue<long long int,vector<long long int>,greater<long long int>> listOfRoomsAvailable;\\n        long long int currentTime = 0;\\n        for(long long int room=0;room<n;room++){\\n            listOfRoomsAvailable.push(room);\\n        }\\n        for(long long int meetingCount=0;meetingCount<meetings.size();meetingCount++){\\n            long long int startTime = meetings[meetingCount][0];\\n            long long int endTime = meetings[meetingCount][1];\\n            \\n            //Check the starting condition\\n            if(startTime>=currentTime){\\n                currentTime = startTime;\\n            }\\n\\n            //Check and vacant the meeting rooms\\n            while(ongoingMeetings.size()>0&&currentTime>=ongoingMeetings.top().first){\\n                long long int roomVacant = ongoingMeetings.top().second;\\n                listOfRoomsAvailable.push(roomVacant);\\n                ongoingMeetings.pop();\\n            }\\n\\n            //If no rooms available\\n            if(listOfRoomsAvailable.size()==0){\\n                currentTime = ongoingMeetings.top().first;\\n                while(ongoingMeetings.size()>0&&currentTime>=ongoingMeetings.top().first){\\n                    long long int roomVacant = ongoingMeetings.top().second;\\n                    listOfRoomsAvailable.push(roomVacant);\\n                    ongoingMeetings.pop();\\n                }\\n            }\\n\\n            endTime += (currentTime-startTime); \\n\\n            //Push the current meeting\\n            long long int roomAvailable = listOfRoomsAvailable.top();\\n            listOfRoomsAvailable.pop();\\n            ongoingMeetings.push({endTime,roomAvailable});\\n\\n            //Increase the count of meeting in that room\\n            numberOfMeetingsPerRoom[roomAvailable]++;\\n        }\\n\\n        long long int roomHavingMaxMeeting = 0;\\n        long long int maxCountOfMeeting = numberOfMeetingsPerRoom[0];\\n        for(long long int room=0;room<n;room++){\\n            if(maxCountOfMeeting<numberOfMeetingsPerRoom[room]){\\n                roomHavingMaxMeeting = room;\\n                maxCountOfMeeting = numberOfMeetingsPerRoom[room];\\n            }\\n        }\\n        return roomHavingMaxMeeting;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820613,
                "title": "c-solution-using-priority-queue",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n*logn)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        set<int>vacantRooms;\\n        for(int i=0;i<n;i++){\\n            vacantRooms.insert(i);\\n        }\\n\\n        vector<int>count(n, 0);\\n\\n        sort(meetings.begin(), meetings.end());\\n\\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>>minh;\\n        for(int i=0;i<meetings.size();i++){\\n            int start = meetings[i][0];\\n            int end = meetings[i][1];\\n\\n            if(minh.size() == 0){\\n                minh.push({(ll)end, 0});\\n                count[0]++;\\n                vacantRooms.erase(0);\\n            }\\n            else{\\n                while(!minh.empty()){\\n                    if(minh.top().first > start)\\n                        break;\\n                    int index = minh.top().second;\\n                    minh.pop();\\n                    vacantRooms.insert(index);\\n                }\\n\\n                if(vacantRooms.size()){\\n                    int index = *vacantRooms.begin();\\n                    count[index]++;\\n                    minh.push({(ll)end, index});\\n                    vacantRooms.erase(index);\\n                }\\n                else{\\n                    ll prevEnd = minh.top().first;\\n                    int index = minh.top().second;\\n                    minh.pop();\\n\\n                    ll diff = abs(prevEnd-start);\\n                    count[index]++;\\n                    minh.push({(ll)end+(ll)diff, index});\\n                }\\n            }\\n        }\\n\\n        int maxi = 0, res = 0;\\n        for(int i=0;i<n;i++){\\n            if(maxi < count[i]){\\n                maxi = count[i];\\n                res = i;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        set<int>vacantRooms;\\n        for(int i=0;i<n;i++){\\n            vacantRooms.insert(i);\\n        }\\n\\n        vector<int>count(n, 0);\\n\\n        sort(meetings.begin(), meetings.end());\\n\\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>>minh;\\n        for(int i=0;i<meetings.size();i++){\\n            int start = meetings[i][0];\\n            int end = meetings[i][1];\\n\\n            if(minh.size() == 0){\\n                minh.push({(ll)end, 0});\\n                count[0]++;\\n                vacantRooms.erase(0);\\n            }\\n            else{\\n                while(!minh.empty()){\\n                    if(minh.top().first > start)\\n                        break;\\n                    int index = minh.top().second;\\n                    minh.pop();\\n                    vacantRooms.insert(index);\\n                }\\n\\n                if(vacantRooms.size()){\\n                    int index = *vacantRooms.begin();\\n                    count[index]++;\\n                    minh.push({(ll)end, index});\\n                    vacantRooms.erase(index);\\n                }\\n                else{\\n                    ll prevEnd = minh.top().first;\\n                    int index = minh.top().second;\\n                    minh.pop();\\n\\n                    ll diff = abs(prevEnd-start);\\n                    count[index]++;\\n                    minh.push({(ll)end+(ll)diff, index});\\n                }\\n            }\\n        }\\n\\n        int maxi = 0, res = 0;\\n        for(int i=0;i<n;i++){\\n            if(maxi < count[i]){\\n                maxi = count[i];\\n                res = i;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819664,
                "title": "java-solution-o-nlogn-solution-with-detailed-explanation-2-priorityqueue-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Room will needed to be allotted to a meeting when it starts, that means the meeting that start first will need to have a room early than the meeting that is starting late ==> We will need to ```Sort``` the Meetings Array according to their ```start times```.\\n- For any meeting, we will need to get all the unused meeting rooms so far and select the lowest room amongst them. So we will need a ```Min Heap``` or ```PriorityQueue``` based on ```Smaller End Times, and then Smaller Room ID```.\\n- If there are no meething rooms available, the current meeting will start when after the earliest ending meeting in the current rooms ==> ```delay = lowest ending time - this meeting\\'s start time```.\\n- Add the delay to the current meeting\\'s end time and allot the freed room.\\n- Maintain a room frequency array and update it when a new meeting is assigned to that room.\\n- Get the minimum room index with maximum room frequency.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort array according to start times: ```Arrays.sort(meetings, (a,b) -> a[0] - b[0]);```\\n- Make 2 PriorityQueues: \\n    1. Scheduler (pq in code): Holds end Times and Room ID. Sorted First by End Times and then by Room ID\\n    2. AvailableRooms: Holds the rooms available at any time.\\n- For any new meeting, remove the meetings already over from Scheduler and add those rooms to AvailableRooms.\\n- If no meeting has ended and rooms are full, free the earliest ending meeting, add delay to current meeting, and add this meeting into scheduler.\\n- Update the RoomFreq for this room.\\n- Check the Room with highest Freq and return it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    Assuming:\\n    1. Size of Array = m\\n    2. and m >= n\\n\\n    Sorting: O(mlogm)\\n    PriorityQueue: O(nlogn)\\n    For Loops: O(m)\\n\\n    Total Time Complexity = O(Max(nlogn,mlogm)) or O(mlogm)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    PriorityQueue: O(n)\\n    RoomFreq Array: O(n)\\n\\n    Total Space Complexity = O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a,b) -> a[0] - b[0]);\\n\\n        //EndTime, RoomID\\n        //Sort By EndTime, then By RoomID\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(\\n            (a,b) ->\\n            a[0] == b[0]?a[1]-b[1]:a[0]-b[0]\\n        );\\n\\n        //Available Rooms\\n        PriorityQueue<Integer> availableRooms = new PriorityQueue<>();\\n\\n        //Room Freq\\n        int[] roomFreq = new int[n];\\n\\n        for(int i=0;i<n;i++)\\n            availableRooms.add(i);\\n        \\n        for(int[] meeting:meetings){\\n            int x = meeting[0];\\n            int y = meeting[1];\\n\\n            //Add All Emptied Rooms back to Available Rooms\\n            while(!pq.isEmpty() && x >= pq.peek()[0]){\\n                availableRooms.add(pq.poll()[1]);\\n            }\\n\\n            int delayMeeting = 0;\\n            \\n            //If No Available Rooms\\n            if(availableRooms.isEmpty()){\\n                int[] endMeeting = pq.poll();\\n                availableRooms.add(endMeeting[1]);\\n                delayMeeting = endMeeting[0] - x;\\n            }\\n\\n            y += delayMeeting;\\n            int roomUsed = availableRooms.poll();\\n            pq.add(new int[]{y,roomUsed});\\n            roomFreq[roomUsed]++;\\n        }\\n\\n        int maxUsedRoom = 0;\\n        int maxUsage = 0;\\n        for(int i=0;i<n;i++){\\n            if(maxUsage < roomFreq[i]){\\n                maxUsage = roomFreq[i];\\n                maxUsedRoom = i;\\n            }\\n        }\\n\\n\\n        return maxUsedRoom;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```Sort```\n```start times```\n```Min Heap```\n```PriorityQueue```\n```Smaller End Times, and then Smaller Room ID```\n```delay = lowest ending time - this meeting\\'s start time```\n```Arrays.sort(meetings, (a,b) -> a[0] - b[0]);```\n```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a,b) -> a[0] - b[0]);\\n\\n        //EndTime, RoomID\\n        //Sort By EndTime, then By RoomID\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(\\n            (a,b) ->\\n            a[0] == b[0]?a[1]-b[1]:a[0]-b[0]\\n        );\\n\\n        //Available Rooms\\n        PriorityQueue<Integer> availableRooms = new PriorityQueue<>();\\n\\n        //Room Freq\\n        int[] roomFreq = new int[n];\\n\\n        for(int i=0;i<n;i++)\\n            availableRooms.add(i);\\n        \\n        for(int[] meeting:meetings){\\n            int x = meeting[0];\\n            int y = meeting[1];\\n\\n            //Add All Emptied Rooms back to Available Rooms\\n            while(!pq.isEmpty() && x >= pq.peek()[0]){\\n                availableRooms.add(pq.poll()[1]);\\n            }\\n\\n            int delayMeeting = 0;\\n            \\n            //If No Available Rooms\\n            if(availableRooms.isEmpty()){\\n                int[] endMeeting = pq.poll();\\n                availableRooms.add(endMeeting[1]);\\n                delayMeeting = endMeeting[0] - x;\\n            }\\n\\n            y += delayMeeting;\\n            int roomUsed = availableRooms.poll();\\n            pq.add(new int[]{y,roomUsed});\\n            roomFreq[roomUsed]++;\\n        }\\n\\n        int maxUsedRoom = 0;\\n        int maxUsage = 0;\\n        for(int i=0;i<n;i++){\\n            if(maxUsage < roomFreq[i]){\\n                maxUsage = roomFreq[i];\\n                maxUsedRoom = i;\\n            }\\n        }\\n\\n\\n        return maxUsedRoom;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811691,
                "title": "java-two-priorityqueue",
                "content": "# Code\\n```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a,b) -> Integer.compare(a[0], b[0]));\\n\\n        int[] count = new int[n];\\n        int[] currMeetings = new int[n];\\n        PriorityQueue<Integer> busy = new PriorityQueue<>(\\n            (i, j) -> currMeetings[i] == currMeetings[j] ? i - j : currMeetings[i] - currMeetings[j]\\n        );\\n        for (int room = 0; room < n; room++) busy.add(room);\\n\\n        PriorityQueue<Integer> free = new PriorityQueue<>();\\n\\n        for (int i=0; i<meetings.length; i++) {\\n            int[] meeting = meetings[i];\\n            while (!busy.isEmpty() && currMeetings[busy.peek()] <= meeting[0]) {\\n                free.add(busy.poll());\\n            }\\n\\n            int room = !free.isEmpty() ? free.poll() : busy.poll();\\n\\n            if (currMeetings[room] <= meeting[0]) {\\n                currMeetings[room] = meeting[1];\\n            } else {\\n                int duration = meeting[1] - meeting[0];\\n                currMeetings[room] += duration;\\n            }\\n\\n            count[room]++;\\n            busy.add(room);\\n        }\\n\\n        return maxI(count);\\n    }\\n\\n    private int maxI(int[] nums) {\\n        int maxI = 0;\\n        int max = nums[0];\\n\\n        for (int i=0; i<nums.length; i++) {\\n            if (nums[i] > max) {\\n                maxI = i;\\n                max = nums[i];\\n            }\\n        }\\n\\n        return maxI;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a,b) -> Integer.compare(a[0], b[0]));\\n\\n        int[] count = new int[n];\\n        int[] currMeetings = new int[n];\\n        PriorityQueue<Integer> busy = new PriorityQueue<>(\\n            (i, j) -> currMeetings[i] == currMeetings[j] ? i - j : currMeetings[i] - currMeetings[j]\\n        );\\n        for (int room = 0; room < n; room++) busy.add(room);\\n\\n        PriorityQueue<Integer> free = new PriorityQueue<>();\\n\\n        for (int i=0; i<meetings.length; i++) {\\n            int[] meeting = meetings[i];\\n            while (!busy.isEmpty() && currMeetings[busy.peek()] <= meeting[0]) {\\n                free.add(busy.poll());\\n            }\\n\\n            int room = !free.isEmpty() ? free.poll() : busy.poll();\\n\\n            if (currMeetings[room] <= meeting[0]) {\\n                currMeetings[room] = meeting[1];\\n            } else {\\n                int duration = meeting[1] - meeting[0];\\n                currMeetings[room] += duration;\\n            }\\n\\n            count[room]++;\\n            busy.add(room);\\n        }\\n\\n        return maxI(count);\\n    }\\n\\n    private int maxI(int[] nums) {\\n        int maxI = 0;\\n        int max = nums[0];\\n\\n        for (int i=0; i<nums.length; i++) {\\n            if (nums[i] > max) {\\n                maxI = i;\\n                max = nums[i];\\n            }\\n        }\\n\\n        return maxI;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809960,
                "title": "approach-using-priorityq-greedy",
                "content": "# Intuition\\nHere similar to meetingRooms2 problem, our logic is that we first sort the meetings array acoording to the start time so that it is easier to work with, then we use a min heap(priority q) to store the meetings endtime and the roomNo. We also use a exra priorityq to store the roomNo we do so because we always want to choose the least \\nvalued roomNo.\\n# Approach\\n- First store all roomNo in freerooms prorityQ since initiallya ll rooms are free\\n- Next we iterate through meeting array and store start and end time\\n    - First we check if any room is engaged or Not in a while loop here in loop we also check if the current start time is >= least end time in the ```engagedRoom``` priority Q. Here if it is we then pop the value and add roomNo to ```freeRooms ```. this is done so because we always want to get all freeRooms before we conduct a meeting\\\\\\n    - Next we check if any FreeRooms are there. Here we then add    current endtime and roomNo to ```engagedRooms``` . ```engagedRooms.push({end,room});```. After pushing to a room we increase the roomFrequency, and pop out the room from ```freeRooms```\\n    - Next if no freeRoom availabel. Then we popout the engagedroom with least end time from the priorityQ and push the current meeting by updating the endtime by ```newEnd=endTop +(end-start);```. We then push newend time and roomNo to ```engagedRooms``` and then update frequency of room again\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        sort(meetings.begin(),meetings.end(),[](const vector<int>&a,const vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>> engagedRooms;\\n        priority_queue<int,vector<int>,greater<int>> freeRooms;\\n        unordered_map<int,int>roomFreq;\\n        for(int i=0;i<n;i++){\\n            freeRooms.push(i);\\n        }\\n        for(auto& time:meetings ){\\n            int start=time[0];\\n            int end=time[1];\\n            while(engagedRooms.size()>0 and engagedRooms.top().first<=start ){\\n                int room=engagedRooms.top().second;\\n                engagedRooms.pop();\\n                freeRooms.push(room);\\n            }\\n            if(freeRooms.size()>0){\\n                int room=freeRooms.top();\\n                engagedRooms.push({end,room});\\n                roomFreq[room]++;\\n                freeRooms.pop();\\n            }\\n            else{\\n                long long endTop=engagedRooms.top().first;\\n                int room=engagedRooms.top().second;\\n                engagedRooms.pop();\\n                roomFreq[room]++;\\n                long long newEnd=endTop +(end-start);\\n                engagedRooms.push({newEnd,room});\\n            }\\n\\n        }\\n        int maxRoom=0;\\n        for(int i=1;i<n;i++){\\n           if(roomFreq[i]>roomFreq[maxRoom]){\\n               maxRoom=i;\\n           }\\n        }\\n        return maxRoom;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```engagedRoom```\n```freeRooms ```\n```engagedRooms```\n```engagedRooms.push({end,room});```\n```freeRooms```\n```newEnd=endTop +(end-start);```\n```engagedRooms```\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        sort(meetings.begin(),meetings.end(),[](const vector<int>&a,const vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>> engagedRooms;\\n        priority_queue<int,vector<int>,greater<int>> freeRooms;\\n        unordered_map<int,int>roomFreq;\\n        for(int i=0;i<n;i++){\\n            freeRooms.push(i);\\n        }\\n        for(auto& time:meetings ){\\n            int start=time[0];\\n            int end=time[1];\\n            while(engagedRooms.size()>0 and engagedRooms.top().first<=start ){\\n                int room=engagedRooms.top().second;\\n                engagedRooms.pop();\\n                freeRooms.push(room);\\n            }\\n            if(freeRooms.size()>0){\\n                int room=freeRooms.top();\\n                engagedRooms.push({end,room});\\n                roomFreq[room]++;\\n                freeRooms.pop();\\n            }\\n            else{\\n                long long endTop=engagedRooms.top().first;\\n                int room=engagedRooms.top().second;\\n                engagedRooms.pop();\\n                roomFreq[room]++;\\n                long long newEnd=endTop +(end-start);\\n                engagedRooms.push({newEnd,room});\\n            }\\n\\n        }\\n        int maxRoom=0;\\n        for(int i=1;i<n;i++){\\n           if(roomFreq[i]>roomFreq[maxRoom]){\\n               maxRoom=i;\\n           }\\n        }\\n        return maxRoom;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789201,
                "title": "python-with-heap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse heap (priority queue) to figure out which room is available.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- meeting start time bigger than the first meeting available time, loop meeting rooms until find finish time bigger than start time.\\n- meeting start time smaller or equal to meeting available time. Take first one out off the meeting room queue.\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(rooms)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        rooms = [[0, i, 0] for i in range(n)] + [[float(\\'inf\\'), 0, 0]]\\n        max_count, max_room_n = 0, float(\\'-inf\\')\\n        for start, end in meetings:\\n            while start > rooms[0][0]:\\n                finish, room_n, count = heapq.heappop(rooms)\\n                heapq.heappush(rooms, [start, room_n, count])\\n            finish, room_n, count = heapq.heappop(rooms)\\n            start, end = max(finish, start), max(end, end - start + finish)\\n            heapq.heappush(rooms, [end, room_n, count + 1])\\n            max_count, max_room_n = max([max_count, max_room_n], [count+1, -room_n])\\n        return -max_room_n\\n\\n          \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        rooms = [[0, i, 0] for i in range(n)] + [[float(\\'inf\\'), 0, 0]]\\n        max_count, max_room_n = 0, float(\\'-inf\\')\\n        for start, end in meetings:\\n            while start > rooms[0][0]:\\n                finish, room_n, count = heapq.heappop(rooms)\\n                heapq.heappush(rooms, [start, room_n, count])\\n            finish, room_n, count = heapq.heappop(rooms)\\n            start, end = max(finish, start), max(end, end - start + finish)\\n            heapq.heappush(rooms, [end, room_n, count + 1])\\n            max_count, max_room_n = max([max_count, max_room_n], [count+1, -room_n])\\n        return -max_room_n\\n\\n          \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783947,
                "title": "python-solution-using-2-min-heaps-commented-code-for-better-step-by-step-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    First thought was to use minHeap because it required continous ordering at every iteration and minHeap does that the most efficiently.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Neatly mentioned in the code, along with comments. Please check.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->  \\n    O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        busyRooms = [] \\n        #busyRooms is a MinHeap which will store elements in (endTime, roomNo) format, sorted on the endTime\\n\\n        availableRooms = [i for i in range(n)] \\n        #availableRooms is a minHeap which will store the indices of the available rooms\\n\\n        count = [0] * n\\n        #an array for storing the number of times each room is used\\n\\n        meetings.sort(key = lambda x : x[0])\\n        #sorts the meetings array based on the first index or the start time\\n\\n        for start, end in meetings:\\n            #if the ending time of the next to-be-freed meeting room is less than the \\n            #start time of the next room, we can use that meeting room for the next meeting\\n            while busyRooms and busyRooms[0][0] <= start: \\n                endTime, room = heappop(busyRooms)\\n                heappush(availableRooms, room)\\n\\n            #if a room(with lowest index) is available, then use that for the next \\n            #meeting and add it to busy minHeap\\n            if availableRooms:\\n                room = heappop(availableRooms)\\n                heappush(busyRooms, (end, room))\\n            \\n            #if the availableRooms are empty, then you have to wait until the latest meeting finishes\\n            #and then you have to use the room that became empty as your room for the next meeting\\n            else:\\n                endTime, room = heappop(busyRooms)\\n                heappush(busyRooms, ((endTime + end - start), room)) \\n                #endTime + end - start is because we store the end time of the meeting in busy minHeap\\n                #and to calculate the end time now, we need to add the duration of the new meeting to the \\n                #endTime, which will give us the new end time\\n\\n            count[room] += 1\\n\\n        return count.index(max(count)) \\n                #max(count) returns the maximum element of the count array and \\n                #index gives the leftmost index of the max element\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        busyRooms = [] \\n        #busyRooms is a MinHeap which will store elements in (endTime, roomNo) format, sorted on the endTime\\n\\n        availableRooms = [i for i in range(n)] \\n        #availableRooms is a minHeap which will store the indices of the available rooms\\n\\n        count = [0] * n\\n        #an array for storing the number of times each room is used\\n\\n        meetings.sort(key = lambda x : x[0])\\n        #sorts the meetings array based on the first index or the start time\\n\\n        for start, end in meetings:\\n            #if the ending time of the next to-be-freed meeting room is less than the \\n            #start time of the next room, we can use that meeting room for the next meeting\\n            while busyRooms and busyRooms[0][0] <= start: \\n                endTime, room = heappop(busyRooms)\\n                heappush(availableRooms, room)\\n\\n            #if a room(with lowest index) is available, then use that for the next \\n            #meeting and add it to busy minHeap\\n            if availableRooms:\\n                room = heappop(availableRooms)\\n                heappush(busyRooms, (end, room))\\n            \\n            #if the availableRooms are empty, then you have to wait until the latest meeting finishes\\n            #and then you have to use the room that became empty as your room for the next meeting\\n            else:\\n                endTime, room = heappop(busyRooms)\\n                heappush(busyRooms, ((endTime + end - start), room)) \\n                #endTime + end - start is because we store the end time of the meeting in busy minHeap\\n                #and to calculate the end time now, we need to add the duration of the new meeting to the \\n                #endTime, which will give us the new end time\\n\\n            count[room] += 1\\n\\n        return count.index(max(count)) \\n                #max(count) returns the maximum element of the count array and \\n                #index gives the leftmost index of the max element\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777871,
                "title": "easy-c-fully-explained-commented-code-priority-queue-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAssiging vacant room to the meetings according to their start time if there is a available room otherwise wait for the other meeting to end!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the meeting time with respect to start time\\nThen iterate over all meeting,\\n\\n(1) Check all the currently running meeting whether it is running at this time or not i.e. start time of new meeting,\\nVacant all rooms whose meeting ended as of the start of the current meeting\\n \\n(2) if there is a vacant room, just assign the current meeting to the room number with lowest id;\\n\\n(3) if no room vacant, delay the current meeting till any of the ongoing meeting ends;\\nEnd the latest meeting which will end soonest, and assign the current meeting to that room, with delayed endtime since it starts late\\n\\n\\nChange frequency of meeting room in a different priority_queue roomfreq;\\nreturn the maximum element index of roomfreq\\n\\nDo upvote please!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        sort(meetings.begin(), meetings.end());\\n        priority_queue<pair<long long,int>> endtime; //storing endtime of all running meeting\\n        priority_queue<int> unusedroom;              //storing unusedroom till curr time\\n        vector<int> roomfreq(n,0);\\n\\n        for(int i=0;i<n; i++)   unusedroom.push(-i);\\n\\n        for(auto itr:meetings) {\\n            int str = itr[0];  //till this time, vacant all room where meeting ended\\n            while(endtime.size()) {\\n                pair<int,int> pr = endtime.top();\\n                if(-pr.first<= str)  {\\n                    endtime.pop();\\n                    unusedroom.push(pr.second);\\n                }\\n                else    break;\\n            }\\n\\n            if(unusedroom.size()) { //assign first room to this meeting if there is vacant room\\n                endtime.push({-itr[1],unusedroom.top()});\\n                roomfreq[-unusedroom.top()]++;\\n                unusedroom.pop();\\n            }\\n            else {  //wait till the latest ending meeting\\n                // vacating the room which meeting ends\\n                pair<long long,int> pr = endtime.top(); //sorted in ascending order(see negative sign)\\n                endtime.pop();                  \\n                \\n                // assigning curr meeting to this vacant room\\n                endtime.push({pr.first-itr[1]+itr[0],pr.second});\\n                roomfreq[-pr.second]++;     //increasing its frequency\\n            }\\n        } \\n        \\n        int maxElementIndex = max_element(roomfreq.begin(),roomfreq.end()) - roomfreq.begin();\\n        return maxElementIndex; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        sort(meetings.begin(), meetings.end());\\n        priority_queue<pair<long long,int>> endtime; //storing endtime of all running meeting\\n        priority_queue<int> unusedroom;              //storing unusedroom till curr time\\n        vector<int> roomfreq(n,0);\\n\\n        for(int i=0;i<n; i++)   unusedroom.push(-i);\\n\\n        for(auto itr:meetings) {\\n            int str = itr[0];  //till this time, vacant all room where meeting ended\\n            while(endtime.size()) {\\n                pair<int,int> pr = endtime.top();\\n                if(-pr.first<= str)  {\\n                    endtime.pop();\\n                    unusedroom.push(pr.second);\\n                }\\n                else    break;\\n            }\\n\\n            if(unusedroom.size()) { //assign first room to this meeting if there is vacant room\\n                endtime.push({-itr[1],unusedroom.top()});\\n                roomfreq[-unusedroom.top()]++;\\n                unusedroom.pop();\\n            }\\n            else {  //wait till the latest ending meeting\\n                // vacating the room which meeting ends\\n                pair<long long,int> pr = endtime.top(); //sorted in ascending order(see negative sign)\\n                endtime.pop();                  \\n                \\n                // assigning curr meeting to this vacant room\\n                endtime.push({pr.first-itr[1]+itr[0],pr.second});\\n                roomfreq[-pr.second]++;     //increasing its frequency\\n            }\\n        } \\n        \\n        int maxElementIndex = max_element(roomfreq.begin(),roomfreq.end()) - roomfreq.begin();\\n        return maxElementIndex; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777869,
                "title": "easy-c-fully-explained-commented-code-priority-queue-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAssiging vacant room to the meetings according to their start time if there is a available room otherwise wait for the other meeting to end!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the meeting time with respect to start time\\nThen iterate over all meeting,\\n\\n(1) Check all the currently running meeting whether it is running at this time or not i.e. start time of new meeting,\\nVacant all rooms whose meeting ended as of the start of the current meeting\\n \\n(2) if there is a vacant room, just assign the current meeting to the room number with lowest id;\\n\\n(3) if no room vacant, delay the current meeting till any of the ongoing meeting ends;\\nEnd the latest meeting which will end soonest, and assign the current meeting to that room, with delayed endtime since it starts late\\n\\n\\nChange frequency of meeting room in a different priority_queue roomfreq;\\nreturn the maximum element index of roomfreq\\n\\nDo upvote please!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        sort(meetings.begin(), meetings.end());\\n        priority_queue<pair<long long,int>> endtime; //storing endtime of all running meeting\\n        priority_queue<int> unusedroom;              //storing unusedroom till curr time\\n        vector<int> roomfreq(n,0);\\n\\n        for(int i=0;i<n; i++)   unusedroom.push(-i);\\n\\n        for(auto itr:meetings) {\\n            int str = itr[0];  //till this time, vacant all room where meeting ended\\n            while(endtime.size()) {\\n                pair<int,int> pr = endtime.top();\\n                if(-pr.first<= str)  {\\n                    endtime.pop();\\n                    unusedroom.push(pr.second);\\n                }\\n                else    break;\\n            }\\n\\n            if(unusedroom.size()) { //assign first room to this meeting if there is vacant room\\n                endtime.push({-itr[1],unusedroom.top()});\\n                roomfreq[-unusedroom.top()]++;\\n                unusedroom.pop();\\n            }\\n            else {  //wait till the latest ending meeting\\n                // vacating the room which meeting ends\\n                pair<long long,int> pr = endtime.top(); //sorted in ascending order(see negative sign)\\n                endtime.pop();                  \\n                \\n                // assigning curr meeting to this vacant room\\n                endtime.push({pr.first-itr[1]+itr[0],pr.second});\\n                roomfreq[-pr.second]++;     //increasing its frequency\\n            }\\n        } \\n        \\n        int maxElementIndex = max_element(roomfreq.begin(),roomfreq.end()) - roomfreq.begin();\\n        return maxElementIndex; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        sort(meetings.begin(), meetings.end());\\n        priority_queue<pair<long long,int>> endtime; //storing endtime of all running meeting\\n        priority_queue<int> unusedroom;              //storing unusedroom till curr time\\n        vector<int> roomfreq(n,0);\\n\\n        for(int i=0;i<n; i++)   unusedroom.push(-i);\\n\\n        for(auto itr:meetings) {\\n            int str = itr[0];  //till this time, vacant all room where meeting ended\\n            while(endtime.size()) {\\n                pair<int,int> pr = endtime.top();\\n                if(-pr.first<= str)  {\\n                    endtime.pop();\\n                    unusedroom.push(pr.second);\\n                }\\n                else    break;\\n            }\\n\\n            if(unusedroom.size()) { //assign first room to this meeting if there is vacant room\\n                endtime.push({-itr[1],unusedroom.top()});\\n                roomfreq[-unusedroom.top()]++;\\n                unusedroom.pop();\\n            }\\n            else {  //wait till the latest ending meeting\\n                // vacating the room which meeting ends\\n                pair<long long,int> pr = endtime.top(); //sorted in ascending order(see negative sign)\\n                endtime.pop();                  \\n                \\n                // assigning curr meeting to this vacant room\\n                endtime.push({pr.first-itr[1]+itr[0],pr.second});\\n                roomfreq[-pr.second]++;     //increasing its frequency\\n            }\\n        } \\n        \\n        int maxElementIndex = max_element(roomfreq.begin(),roomfreq.end()) - roomfreq.begin();\\n        return maxElementIndex; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762888,
                "title": "two-min-heaps-fully-explained-commented-code-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        //sort acc to start time\\n        sort(meetings.begin(), meetings.end());\\n\\n        //min heap {end_time, room_used}\\n        //helps to sort acc to end time and vacate rooms\\n        //take long long instead of int as it will cause integer overflow\\n        priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> p;\\n\\n        //min heap to maintain the record of unused rooms\\n        //helps to allocate the lowest number unused room to a meeting\\n        priority_queue<int, vector<int>, greater<int>> unused_rooms;\\n\\n        //all rooms are vacant intially\\n        for(int i = 0; i < n; i++) {\\n            unused_rooms.push(i);\\n        }\\n\\n        //helps maintain the count of usage of a particular room\\n        //maintains records for all n rooms(0 to n)\\n        vector<int> room_used_cnt(n, 0);\\n\\n        for(int i = 0; i < meetings.size(); i++) {\\n            while(!p.empty() && meetings[i][0] >= p.top().first) {\\n               \\n                //vacate those rooms whose meetings have ended before or at the start time of curr metings[i]\\n                //VACANT ROOMS\\n                //push them in min heap of unused_rooms as they have become empty now\\n                int room_used = p.top().second;\\n                unused_rooms.push(room_used);\\n                p.pop();\\n            }\\n           \\n            //allocate room to the current meeting\\n\\n            //delay in allocating the room to a particular meeting which affect it\\'s end time as start time woould be different from intially specified in meetings start time for this meeting\\n\\n            //take it long long instead of int to prevent integer overflow\\n            long long delay = 0;\\n            \\n            if(unused_rooms.empty()) {\\n                //no vacant rooms available -> metings going in all rooms\\n                //delay calculation\\n                if(!p.empty()) {\\n                    // Room which will empty first whose end time is the earliest(lowest)\\n                    int room_used = p.top().second;\\n//push it in the unused room min heap as now room is empty\\n                    unused_rooms.push(room_used);\\n\\n                    //if meeting [1,5) is popped, at time stamp = 5\\n                    //but our meeting is [2, 7)  then start time would be [5, 10(duration of meeting + starttime)]\\n                    //duration of meeting is 7 - 2 = 5\\n                    //new end time  would be = new start time  + duration\\n                    //delay = new start time(prev\\'s meeting end time) - intial start time\\n                    //assuming that when this meeting ([1,5]) will get over at 5 then new meeting ([2,7)) can start which wil be now -> ([5, 10))\\n                    delay = p.top().first - meetings[i][0];\\n                    \\n                    p.pop();\\n                }\\n            }\\n            //this is the lowest number room to be allocated to the present meeting // which is nothing but the top of unused rooms min heap (unused room which has the lowest number)\\n            int room_to_be_taken = unused_rooms.top();\\n            unused_rooms.pop();\\n\\n            //inc the count usage for the room taken\\n            room_used_cnt[room_to_be_taken]++;\\n            //calc the new end time, it would remain same if no delay is caused as delay is intiallized to 0\\n            long long new_end_time = meetings[i][1] + delay;\\n            p.push({new_end_time, room_to_be_taken});\\n            \\n        }\\n\\n        //calc for the room which in which most meetings occured\\n        int max_room_cnt = 0;\\n        int ans = -1;\\n        for(int i = 0; i < n; i++) {\\n            if(max_room_cnt < room_used_cnt[i]) {\\n                max_room_cnt = room_used_cnt[i];\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        //sort acc to start time\\n        sort(meetings.begin(), meetings.end());\\n\\n        //min heap {end_time, room_used}\\n        //helps to sort acc to end time and vacate rooms\\n        //take long long instead of int as it will cause integer overflow\\n        priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> p;\\n\\n        //min heap to maintain the record of unused rooms\\n        //helps to allocate the lowest number unused room to a meeting\\n        priority_queue<int, vector<int>, greater<int>> unused_rooms;\\n\\n        //all rooms are vacant intially\\n        for(int i = 0; i < n; i++) {\\n            unused_rooms.push(i);\\n        }\\n\\n        //helps maintain the count of usage of a particular room\\n        //maintains records for all n rooms(0 to n)\\n        vector<int> room_used_cnt(n, 0);\\n\\n        for(int i = 0; i < meetings.size(); i++) {\\n            while(!p.empty() && meetings[i][0] >= p.top().first) {\\n               \\n                //vacate those rooms whose meetings have ended before or at the start time of curr metings[i]\\n                //VACANT ROOMS\\n                //push them in min heap of unused_rooms as they have become empty now\\n                int room_used = p.top().second;\\n                unused_rooms.push(room_used);\\n                p.pop();\\n            }\\n           \\n            //allocate room to the current meeting\\n\\n            //delay in allocating the room to a particular meeting which affect it\\'s end time as start time woould be different from intially specified in meetings start time for this meeting\\n\\n            //take it long long instead of int to prevent integer overflow\\n            long long delay = 0;\\n            \\n            if(unused_rooms.empty()) {\\n                //no vacant rooms available -> metings going in all rooms\\n                //delay calculation\\n                if(!p.empty()) {\\n                    // Room which will empty first whose end time is the earliest(lowest)\\n                    int room_used = p.top().second;\\n//push it in the unused room min heap as now room is empty\\n                    unused_rooms.push(room_used);\\n\\n                    //if meeting [1,5) is popped, at time stamp = 5\\n                    //but our meeting is [2, 7)  then start time would be [5, 10(duration of meeting + starttime)]\\n                    //duration of meeting is 7 - 2 = 5\\n                    //new end time  would be = new start time  + duration\\n                    //delay = new start time(prev\\'s meeting end time) - intial start time\\n                    //assuming that when this meeting ([1,5]) will get over at 5 then new meeting ([2,7)) can start which wil be now -> ([5, 10))\\n                    delay = p.top().first - meetings[i][0];\\n                    \\n                    p.pop();\\n                }\\n            }\\n            //this is the lowest number room to be allocated to the present meeting // which is nothing but the top of unused rooms min heap (unused room which has the lowest number)\\n            int room_to_be_taken = unused_rooms.top();\\n            unused_rooms.pop();\\n\\n            //inc the count usage for the room taken\\n            room_used_cnt[room_to_be_taken]++;\\n            //calc the new end time, it would remain same if no delay is caused as delay is intiallized to 0\\n            long long new_end_time = meetings[i][1] + delay;\\n            p.push({new_end_time, room_to_be_taken});\\n            \\n        }\\n\\n        //calc for the room which in which most meetings occured\\n        int max_room_cnt = 0;\\n        int ans = -1;\\n        for(int i = 0; i < n; i++) {\\n            if(max_room_cnt < room_used_cnt[i]) {\\n                max_room_cnt = room_used_cnt[i];\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762675,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition is here is pretty simple. Make note of the following -->\\n1. each start time is unique\\n2. if a room is not available, the meeting is delayed and is run for the same amount of time i.e. end_time - start_time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe aproach here is pretty simple\\n1. sort the meetings with the start_time\\n2. initialize a map which keeps track of #meetings conducted in each meeting room\\n3. Initialize a min priority queue with 1 element per meeting room with element type = pair(time when the meeting room becomes free, meeting room number)\\n4. Now for each meeting, loop through the priority queue and update the end times in the priority queue with max(end time, new start_time)\\n5. By doing so, we make sure that the rooms which were free before the new meeting are sorted acordingly in the priority queue.\\n6. Next step is pretty simple. Draw one meeting room from the priority queue and conduct the meeting i.e. incrememnt the map value for that meeting room.\\n\\n# Complexity\\n- Time complexity: O(mnlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nThis is because for each meeting (m), we refill the priority queue which take nlogn. so it is m*nlogn => mnlogn\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\nWe need space for the priority queue and the meeting rooms.\\n\\n# Code\\n```\\nbool interval_compare(const vector<int> &a, const vector<int> &b) {\\n    if ( a[0] < b[0] ) {\\n        return true;\\n    }\\n    if ( b[0] < a[0] ) {\\n        return false;\\n    }\\n    if ( a[1] < b[1] ) {\\n        return true;\\n    }\\n    return false;\\n}\\n\\nclass Solution {\\nprivate:\\n    map<int, int> num_of_meeting;\\n\\n    int max_meeting_room = 0;\\n\\n    int max_meetings = 1;\\n\\n    priority_queue<pair<long, int>, vector<pair<long, int>>, greater<pair<long, int>>> meeting_room_free_time;// (free_time, meeting_room)\\n\\n    void update_time(long start_time) {\\n        vector<pair<long, int>> temp_times;\\n        while ( !meeting_room_free_time.empty() && meeting_room_free_time.top().first < start_time ) {\\n            int old_end_time = meeting_room_free_time.top().first;\\n            int meeting_room = meeting_room_free_time.top().second;\\n            temp_times.push_back(pair(start_time, meeting_room));\\n            meeting_room_free_time.pop();\\n        }\\n\\n        for ( int i = 0; i < temp_times.size(); i++ ) {\\n            meeting_room_free_time.push(temp_times[i]);\\n        }\\n    }\\n\\n    int find_most_booked_meeting_room(int n, vector<vector<int>>& meetings) {\\n        for ( int i = 0; i < n; i++ ) {\\n            num_of_meeting[i] = 0;\\n            meeting_room_free_time.push(pair(0, i));\\n        }\\n        sort(meetings.begin(), meetings.end(), interval_compare);\\n\\n        for ( int i = 0; i < meetings.size(); i++ ) {\\n            update_time(meetings[i][0]);\\n            long free_meeting_room_start_time = meeting_room_free_time.top().first;\\n            int free_meeting_room = meeting_room_free_time.top().second;\\n            meeting_room_free_time.pop();\\n            num_of_meeting[free_meeting_room] += 1;\\n            meeting_room_free_time.push(pair(free_meeting_room_start_time + (long)(meetings[i][1] - meetings[i][0]), free_meeting_room));\\n        }\\n\\n        for ( int i = 0; i < n; i++ ) {\\n            if ( num_of_meeting[i] > max_meetings) {\\n                max_meetings = num_of_meeting[i];\\n                max_meeting_room = i;\\n            }\\n        }\\n\\n        return max_meeting_room;\\n    }\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        return find_most_booked_meeting_room(n, meetings);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nbool interval_compare(const vector<int> &a, const vector<int> &b) {\\n    if ( a[0] < b[0] ) {\\n        return true;\\n    }\\n    if ( b[0] < a[0] ) {\\n        return false;\\n    }\\n    if ( a[1] < b[1] ) {\\n        return true;\\n    }\\n    return false;\\n}\\n\\nclass Solution {\\nprivate:\\n    map<int, int> num_of_meeting;\\n\\n    int max_meeting_room = 0;\\n\\n    int max_meetings = 1;\\n\\n    priority_queue<pair<long, int>, vector<pair<long, int>>, greater<pair<long, int>>> meeting_room_free_time;// (free_time, meeting_room)\\n\\n    void update_time(long start_time) {\\n        vector<pair<long, int>> temp_times;\\n        while ( !meeting_room_free_time.empty() && meeting_room_free_time.top().first < start_time ) {\\n            int old_end_time = meeting_room_free_time.top().first;\\n            int meeting_room = meeting_room_free_time.top().second;\\n            temp_times.push_back(pair(start_time, meeting_room));\\n            meeting_room_free_time.pop();\\n        }\\n\\n        for ( int i = 0; i < temp_times.size(); i++ ) {\\n            meeting_room_free_time.push(temp_times[i]);\\n        }\\n    }\\n\\n    int find_most_booked_meeting_room(int n, vector<vector<int>>& meetings) {\\n        for ( int i = 0; i < n; i++ ) {\\n            num_of_meeting[i] = 0;\\n            meeting_room_free_time.push(pair(0, i));\\n        }\\n        sort(meetings.begin(), meetings.end(), interval_compare);\\n\\n        for ( int i = 0; i < meetings.size(); i++ ) {\\n            update_time(meetings[i][0]);\\n            long free_meeting_room_start_time = meeting_room_free_time.top().first;\\n            int free_meeting_room = meeting_room_free_time.top().second;\\n            meeting_room_free_time.pop();\\n            num_of_meeting[free_meeting_room] += 1;\\n            meeting_room_free_time.push(pair(free_meeting_room_start_time + (long)(meetings[i][1] - meetings[i][0]), free_meeting_room));\\n        }\\n\\n        for ( int i = 0; i < n; i++ ) {\\n            if ( num_of_meeting[i] > max_meetings) {\\n                max_meetings = num_of_meeting[i];\\n                max_meeting_room = i;\\n            }\\n        }\\n\\n        return max_meeting_room;\\n    }\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        return find_most_booked_meeting_room(n, meetings);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722977,
                "title": "java-solution-with-detailed-explanation-intuition-and-complexity-analysis-2-heaps-o-n-log-n",
                "content": "# Intuition\\nn = 100 suggests an O(n log n) solution would work and the nature of the problem is greedy and has some ordering in terms of intervals of meeting therefore the intuition was to use priority queue minheap\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing 2 minheaps one for keeping the track of busy meetings using tuple {endTime, roomNumber} and one avaialable minheap to help get the minimum index room available in constant time\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    -    O(n log n) for sorting and n * [log(n) for adding and polling to pq]\\n        = 2* (n log n) ~ n(logn) asymptotically \\n        where n is the n umber of meetings\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    -    O(n) for busy pq to store tuple {endTime, roomNumber} to track busy rooms\\n         O(m) for available room in pq to get the room with smallest index\\n       O(m) for array to store the frequency of meetings in each room\\n     = 2 * O(n) + O(m)\\n        = O(n) + O(m) asymptotically\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a,b)-> a[0]-b[0]);\\n        Queue<Meeting> busy = new PriorityQueue<>(); // to track busy rooms and storing tuple {endTime, roomNumber}\\n        Queue<Integer> available = new PriorityQueue<>(); //to get the smallest index room available\\n\\n        for(int i=0;i<n;i++){\\n            available.add(i);\\n        }\\n\\n        int[] count = new int[n]; // to track the freq of meeting in each room\\n        int result = 0;\\n\\n        for(int[] meet : meetings){\\n            long currentStartTime = meet[0];\\n            long currentEndTime = meet[1];\\n            int currRoom = 0;\\n            while(!busy.isEmpty() && busy.peek().endTime <= currentStartTime){\\n                Meeting m = busy.poll();\\n                available.add(m.roomNumber);\\n            }\\n            if(!available.isEmpty()){// case when there are available rooms, we assign the meeting to the top room from available pq\\n                currRoom = available.poll();\\n\\n                busy.add(new Meeting(currentEndTime, currRoom));\\n                count[currRoom]++; // increment freq for currRoom \\n            }\\n            else{ // case when no room is available and we need to wait for the earliest meeting to end\\n                Meeting m = busy.poll();\\n                currRoom = m.roomNumber;\\n                busy.add(new Meeting(m.endTime + meet[1]-meet[0],\\n                 m.roomNumber)); // to ensure the duration of the delayed meeting remains the same\\n\\n                 count[currRoom]++; // increment freq for currRoom \\n            }\\n\\n            if(count[currRoom] > count[result]){\\n                result = currRoom;\\n            }\\n            else if(count[currRoom]==count[result]){\\n                result = Math.min(result, currRoom);\\n            }\\n\\n        }\\n        return result;\\n\\n    }\\n}\\nclass Meeting implements Comparable<Meeting>{\\n    long endTime;\\n    int roomNumber;\\n    Meeting(long endTime, int roomNumber){\\n        this.endTime = endTime;\\n        this.roomNumber = roomNumber;\\n    }\\n\\n    @Override\\n    public int compareTo(Meeting another){\\n        if (this.endTime < another.endTime) return -1;\\n        if (this.endTime > another.endTime) return 1;\\n        return this.roomNumber - another.roomNumber;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a,b)-> a[0]-b[0]);\\n        Queue<Meeting> busy = new PriorityQueue<>(); // to track busy rooms and storing tuple {endTime, roomNumber}\\n        Queue<Integer> available = new PriorityQueue<>(); //to get the smallest index room available\\n\\n        for(int i=0;i<n;i++){\\n            available.add(i);\\n        }\\n\\n        int[] count = new int[n]; // to track the freq of meeting in each room\\n        int result = 0;\\n\\n        for(int[] meet : meetings){\\n            long currentStartTime = meet[0];\\n            long currentEndTime = meet[1];\\n            int currRoom = 0;\\n            while(!busy.isEmpty() && busy.peek().endTime <= currentStartTime){\\n                Meeting m = busy.poll();\\n                available.add(m.roomNumber);\\n            }\\n            if(!available.isEmpty()){// case when there are available rooms, we assign the meeting to the top room from available pq\\n                currRoom = available.poll();\\n\\n                busy.add(new Meeting(currentEndTime, currRoom));\\n                count[currRoom]++; // increment freq for currRoom \\n            }\\n            else{ // case when no room is available and we need to wait for the earliest meeting to end\\n                Meeting m = busy.poll();\\n                currRoom = m.roomNumber;\\n                busy.add(new Meeting(m.endTime + meet[1]-meet[0],\\n                 m.roomNumber)); // to ensure the duration of the delayed meeting remains the same\\n\\n                 count[currRoom]++; // increment freq for currRoom \\n            }\\n\\n            if(count[currRoom] > count[result]){\\n                result = currRoom;\\n            }\\n            else if(count[currRoom]==count[result]){\\n                result = Math.min(result, currRoom);\\n            }\\n\\n        }\\n        return result;\\n\\n    }\\n}\\nclass Meeting implements Comparable<Meeting>{\\n    long endTime;\\n    int roomNumber;\\n    Meeting(long endTime, int roomNumber){\\n        this.endTime = endTime;\\n        this.roomNumber = roomNumber;\\n    }\\n\\n    @Override\\n    public int compareTo(Meeting another){\\n        if (this.endTime < another.endTime) return -1;\\n        if (this.endTime > another.endTime) return 1;\\n        return this.roomNumber - another.roomNumber;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719472,
                "title": "java-priority-queue-minheap-easy-to-understand-with-comments",
                "content": "# Intuition\\n1. Sort the input meeting array by asc order of start times.\\n2. Since we need to use available room with lowest value, we need a minHeap (Priority Queue).\\n3. We need to store the running meeting in the ascending order of meeting end times, but when the end times are same then we need to use the meeting which is using lowest value of room number. Hence we need a minHeap (Priority Queue with custom comparator)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n logn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    // Using PriorityQueue (minHeaps)\\n    public int mostBooked(int n, int[][] meetings) {\\n        // sort meeting by asc of start times\\n        Arrays.sort(meetings, (o1, o2) -> o1[0] - o2[0]);\\n\\n        // store available rooms sorted by asc order, since the ask is to use lowest number room when there are available rooms\\n        PriorityQueue<Integer> availableRooms = new PriorityQueue<>();\\n        for(int i = 0; i < n; i++) {\\n            availableRooms.add(i);\\n        }\\n\\n        // sort by end time ,if same end time , sort by lowest room number\\n        PriorityQueue<MeetingItem> runningMeetings = new PriorityQueue<>(new Comparator<MeetingItem>() {\\n            @Override\\n            public int compare(MeetingItem o1, MeetingItem o2) {\\n                if(o1.endTime == o2.endTime) {\\n                    return o1.roomNum - o2.roomNum;\\n                }\\n                return o1.endTime - o2.endTime;\\n            }\\n        });\\n\\n        int[] roomsUsageCount = new int[n];\\n        for(int[] meeting: meetings) {\\n            int curMeetingStartTime = meeting[0];\\n            int curMeetingEndTime = meeting[1];\\n\\n            // check for completed meetings, and put the room numbers in the availableRooms minHeap\\n            while(!runningMeetings.isEmpty() && curMeetingStartTime >= runningMeetings.peek().endTime) {\\n                availableRooms.add(runningMeetings.poll().roomNum);\\n            }\\n\\n            int delay = 0;\\n            // if there are no available rooms, that means all rooms are busy, and the runningMeetings queue is not empty\\n            // and now we must assign a room to the current meeting\\n            // since all the remaining running meeting have the end times which is greater than curMeetingEndTime\\n            // we need to add delay\\n            if(availableRooms.isEmpty()) {\\n                MeetingItem earliestEndedMeetingItem = runningMeetings.poll();\\n                delay = earliestEndedMeetingItem.endTime - curMeetingStartTime;\\n                availableRooms.add(earliestEndedMeetingItem.roomNum);\\n            }\\n            // if there are rooms available, then no need to check the runningMeeting queue,\\n            // since we have already removed all completed meeting in the while loop check above\\n            curMeetingEndTime += delay; // add delay to current meeting end time\\n            int roomToUse = availableRooms.poll();\\n            runningMeetings.add(new MeetingItem(curMeetingEndTime, roomToUse));\\n            roomsUsageCount[roomToUse]++;\\n        }\\n\\n        int maxUsageRoom = -1;\\n        int maxUsageRoomCount = 0;\\n        for(int i = 0; i< n; i++) {\\n            if(roomsUsageCount[i] > maxUsageRoomCount) {\\n                maxUsageRoom = i;\\n                maxUsageRoomCount= roomsUsageCount[i];\\n            }\\n        }\\n        return maxUsageRoom;\\n    }\\n\\n    static class MeetingItem {\\n        public int endTime;\\n        public int roomNum;\\n\\n        public MeetingItem(int endTime, int roomNum) {\\n            this.endTime = endTime;\\n            this.roomNum = roomNum;\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // Using PriorityQueue (minHeaps)\\n    public int mostBooked(int n, int[][] meetings) {\\n        // sort meeting by asc of start times\\n        Arrays.sort(meetings, (o1, o2) -> o1[0] - o2[0]);\\n\\n        // store available rooms sorted by asc order, since the ask is to use lowest number room when there are available rooms\\n        PriorityQueue<Integer> availableRooms = new PriorityQueue<>();\\n        for(int i = 0; i < n; i++) {\\n            availableRooms.add(i);\\n        }\\n\\n        // sort by end time ,if same end time , sort by lowest room number\\n        PriorityQueue<MeetingItem> runningMeetings = new PriorityQueue<>(new Comparator<MeetingItem>() {\\n            @Override\\n            public int compare(MeetingItem o1, MeetingItem o2) {\\n                if(o1.endTime == o2.endTime) {\\n                    return o1.roomNum - o2.roomNum;\\n                }\\n                return o1.endTime - o2.endTime;\\n            }\\n        });\\n\\n        int[] roomsUsageCount = new int[n];\\n        for(int[] meeting: meetings) {\\n            int curMeetingStartTime = meeting[0];\\n            int curMeetingEndTime = meeting[1];\\n\\n            // check for completed meetings, and put the room numbers in the availableRooms minHeap\\n            while(!runningMeetings.isEmpty() && curMeetingStartTime >= runningMeetings.peek().endTime) {\\n                availableRooms.add(runningMeetings.poll().roomNum);\\n            }\\n\\n            int delay = 0;\\n            // if there are no available rooms, that means all rooms are busy, and the runningMeetings queue is not empty\\n            // and now we must assign a room to the current meeting\\n            // since all the remaining running meeting have the end times which is greater than curMeetingEndTime\\n            // we need to add delay\\n            if(availableRooms.isEmpty()) {\\n                MeetingItem earliestEndedMeetingItem = runningMeetings.poll();\\n                delay = earliestEndedMeetingItem.endTime - curMeetingStartTime;\\n                availableRooms.add(earliestEndedMeetingItem.roomNum);\\n            }\\n            // if there are rooms available, then no need to check the runningMeeting queue,\\n            // since we have already removed all completed meeting in the while loop check above\\n            curMeetingEndTime += delay; // add delay to current meeting end time\\n            int roomToUse = availableRooms.poll();\\n            runningMeetings.add(new MeetingItem(curMeetingEndTime, roomToUse));\\n            roomsUsageCount[roomToUse]++;\\n        }\\n\\n        int maxUsageRoom = -1;\\n        int maxUsageRoomCount = 0;\\n        for(int i = 0; i< n; i++) {\\n            if(roomsUsageCount[i] > maxUsageRoomCount) {\\n                maxUsageRoom = i;\\n                maxUsageRoomCount= roomsUsageCount[i];\\n            }\\n        }\\n        return maxUsageRoom;\\n    }\\n\\n    static class MeetingItem {\\n        public int endTime;\\n        public int roomNum;\\n\\n        public MeetingItem(int endTime, int roomNum) {\\n            this.endTime = endTime;\\n            this.roomNum = roomNum;\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719204,
                "title": "no-heap-but-little-bit-lazy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        maximus=0\\n        dic={i:0 for i in range(n)}\\n        rooms=[0]*n\\n        for i in meetings:\\n            min_room=min(rooms)\\n            if min_room>i[0]:\\n                ind=rooms.index(min_room)\\n                rooms[ind]=max(rooms[ind],i[0])+(i[1]-i[0])\\n                dic[ind]+=1\\n                maximus=max(maximus,dic[ind])\\n            else:\\n                for j in range(len(rooms)):\\n                    if rooms[j]<=i[0]:\\n                        rooms[j]=max(rooms[j],i[0])+(i[1]-i[0])\\n                        dic[j]+=1\\n                        maximus=max(maximus,dic[j])\\n                        break\\n\\n        for i,j in dic.items():\\n            if j==maximus:return i\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        maximus=0\\n        dic={i:0 for i in range(n)}\\n        rooms=[0]*n\\n        for i in meetings:\\n            min_room=min(rooms)\\n            if min_room>i[0]:\\n                ind=rooms.index(min_room)\\n                rooms[ind]=max(rooms[ind],i[0])+(i[1]-i[0])\\n                dic[ind]+=1\\n                maximus=max(maximus,dic[ind])\\n            else:\\n                for j in range(len(rooms)):\\n                    if rooms[j]<=i[0]:\\n                        rooms[j]=max(rooms[j],i[0])+(i[1]-i[0])\\n                        dic[j]+=1\\n                        maximus=max(maximus,dic[j])\\n                        break\\n\\n        for i,j in dic.items():\\n            if j==maximus:return i\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694452,
                "title": "python-2-heap-solution-with-intuition",
                "content": "# Intuition\\nInitially tried solving this problem with just one heap. But realised that the rooms need to be assigned in an order and not just which room got freed first. For eg, if room 1 got freed before room 0, we want to assign room 0 to the next meeting. We need to keep track of the first room available out of n rooms, thus needing another heap.\\n\\nThe flow is quite straightforward, we first try to free any meeting rooms based on their end times. If current meetings start time is greater than equals the end time of prior meetings, we simply remove them and add the rooms to our rooms_heap (rooms available). We are basically assuming that the meeting start time is the current time and all the meetings with end times less than the current time has already finished.\\n\\nNow, we want to add a meeting. If there is a room available we just remove the room from rooms_heap and add the meeting to that room (in our meetings_heap). However if there isn\\'t a room available it means that the current meeting is delayed. In this case we want to get the room that will be freed first. Our meetings heap contains (meeting_end_time, room) so it stores the earliest ending meeting. Note that python heap automatically sorts based upon room in case 2 meetings have same meeting_end_time\\'s.\\n\\nOnce we have the room and the end time of previous meeting, we need to account for the delay when adding the new meeting. So, the end time for this meeting will become the end time of previous meeting + the duratiion for current meeting.\\n\\n# Complexity\\n- Time complexity:\\nO(MlogM + Mlogn) or just O(MlogM), where M is length of meetings. \\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort(key = lambda x: x[0])\\n        meetings_heap = []\\n        room_heap = [i for i in range(n)]\\n        meeting_counts = [0] * n\\n        for index in range(0, len(meetings)):\\n            current_meeting = meetings[index]\\n            while meetings_heap and meetings_heap[0][0] <= current_meeting[0]:\\n                heappush(room_heap, heappop(meetings_heap)[1])\\n            if room_heap:\\n                room = heappop(room_heap)\\n                new_end_time = current_meeting[1]\\n            else:\\n                prev_end_time, room = heappop(meetings_heap)\\n                new_end_time = prev_end_time + current_meeting[1] - current_meeting[0]\\n            meeting_counts[room] += 1\\n            heappush(meetings_heap, (new_end_time, room))\\n        return meeting_counts.index(max(meeting_counts))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort(key = lambda x: x[0])\\n        meetings_heap = []\\n        room_heap = [i for i in range(n)]\\n        meeting_counts = [0] * n\\n        for index in range(0, len(meetings)):\\n            current_meeting = meetings[index]\\n            while meetings_heap and meetings_heap[0][0] <= current_meeting[0]:\\n                heappush(room_heap, heappop(meetings_heap)[1])\\n            if room_heap:\\n                room = heappop(room_heap)\\n                new_end_time = current_meeting[1]\\n            else:\\n                prev_end_time, room = heappop(meetings_heap)\\n                new_end_time = prev_end_time + current_meeting[1] - current_meeting[0]\\n            meeting_counts[room] += 1\\n            heappush(meetings_heap, (new_end_time, room))\\n        return meeting_counts.index(max(meeting_counts))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686547,
                "title": "simple-set-based-solution-c-simulation",
                "content": "\\n\\n# Approach\\nI used one set to keep track of free rooms, and one set of pair {EndTime, RoomIndex} to simulate the meetings. Rest code is self explanatory.\\n\\n# Complexity\\n- Time complexity:\\no(nlogn)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n         set <int> free;\\n         for (int i=0;i<n;i++) {\\n             free.insert(i);\\n         } \\n          int cnt[101];\\n          memset(cnt,0,sizeof(cnt));\\n          sort(meetings.begin(),meetings.end());\\n           set  < pair <long long int ,long long int  > > heap;\\n\\n           for (auto &i:meetings) {\\n               // Remove all the meeting which ended before this meeting begins\\n               if (heap.size()) {\\n                     pair <int,int> front=*heap.begin();\\n                      \\n                        while ( i[0]>front.first ) {\\n                            \\n                          \\n                           free.insert(front.second);\\n                            heap.erase(heap.begin());\\n                            if (heap.size() == 0) {break;}\\n                            front=*heap.begin();\\n\\n                        }\\n               }\\n               if (free.size()) {\\n                   // room is free allot it \\n                   int bg=*free.begin();\\n                   free.erase(bg);\\n                   heap.insert({i[1]-1,bg});\\n                   cnt[bg]++;\\n\\n               }\\n               else {\\n             // Get the first room to be emptied and allot meeting to it\\n                    pair <int,int> front=*heap.begin();\\n                    \\n                   long long  int newStart=front.first+1,newEnd=newStart+(i[1]-i[0])-1;\\n                    heap.erase(heap.begin());\\n                    heap.insert({newEnd,front.second});\\n                    cnt[front.second]++;\\n                           \\n\\n               }\\n           }\\n   int mx=0;\\n           for (int i=0;i<101;i++) {\\n mx=max(mx,cnt[i]);\\n\\n           }\\n             for (int i=0;i<101;i++) {\\n           if (cnt[i]==mx) {return i;}\\n           }\\n           return 0;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n         set <int> free;\\n         for (int i=0;i<n;i++) {\\n             free.insert(i);\\n         } \\n          int cnt[101];\\n          memset(cnt,0,sizeof(cnt));\\n          sort(meetings.begin(),meetings.end());\\n           set  < pair <long long int ,long long int  > > heap;\\n\\n           for (auto &i:meetings) {\\n               // Remove all the meeting which ended before this meeting begins\\n               if (heap.size()) {\\n                     pair <int,int> front=*heap.begin();\\n                      \\n                        while ( i[0]>front.first ) {\\n                            \\n                          \\n                           free.insert(front.second);\\n                            heap.erase(heap.begin());\\n                            if (heap.size() == 0) {break;}\\n                            front=*heap.begin();\\n\\n                        }\\n               }\\n               if (free.size()) {\\n                   // room is free allot it \\n                   int bg=*free.begin();\\n                   free.erase(bg);\\n                   heap.insert({i[1]-1,bg});\\n                   cnt[bg]++;\\n\\n               }\\n               else {\\n             // Get the first room to be emptied and allot meeting to it\\n                    pair <int,int> front=*heap.begin();\\n                    \\n                   long long  int newStart=front.first+1,newEnd=newStart+(i[1]-i[0])-1;\\n                    heap.erase(heap.begin());\\n                    heap.insert({newEnd,front.second});\\n                    cnt[front.second]++;\\n                           \\n\\n               }\\n           }\\n   int mx=0;\\n           for (int i=0;i<101;i++) {\\n mx=max(mx,cnt[i]);\\n\\n           }\\n             for (int i=0;i<101;i++) {\\n           if (cnt[i]==mx) {return i;}\\n           }\\n           return 0;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670948,
                "title": "heap-with-treeset-in-java",
                "content": "# Intuition\\nWe do the same thing as in Meeting II:\\nWe sort the meeting by its start time and then end time.\\nWe use a heap to clear meetings that ended before the current meeting.\\nBut we need to keep track of the room number and the delayed time when there is no available room.\\n# Approach\\nUse a TreeSet to record the indexes of the free room and give out the free room with the smallest index.\\nUpdate the end time of the meeting if it has to be delayed. The delayed time is the difference between the start time of the current meeting and the end time of previous meeting\\n\\n# Complexity\\n- Time complexity: O(n * log(n))\\n- Space complexity: O(n)\\n# Code\\n```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        TreeSet<Integer> freeRooms = new TreeSet<>();\\n        for (int i = 0; i < n; i++) {\\n            freeRooms.add(i);\\n        }\\n        int[] counts = new int[n];\\n\\n        Arrays.sort(meetings, (a, b) -> \\n            a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n        \\n        Queue<int[]> heap = new PriorityQueue<>((a, b) ->\\n            a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n\\n        for (int[] meeting: meetings) {\\n            int start = meeting[0];\\n            int end = meeting[1];\\n\\n            while (!heap.isEmpty() && heap.peek()[0] <= start) {\\n                int[] ended = heap.poll();\\n                freeRooms.add(ended[1]);\\n            }\\n\\n            if (freeRooms.isEmpty()) {\\n                int[] ended = heap.poll();\\n                end += ended[0] - start;\\n                freeRooms.add(ended[1]);\\n            }\\n\\n            int room = freeRooms.pollFirst();\\n            heap.offer(new int[]{end, room});\\n            counts[room]++;\\n        }\\n\\n        int maxCount = counts[0];\\n        int maxRoom = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (counts[i] > maxCount) {\\n                maxCount = counts[i];\\n                maxRoom = i;\\n            }\\n        }\\n        return maxRoom;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        TreeSet<Integer> freeRooms = new TreeSet<>();\\n        for (int i = 0; i < n; i++) {\\n            freeRooms.add(i);\\n        }\\n        int[] counts = new int[n];\\n\\n        Arrays.sort(meetings, (a, b) -> \\n            a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n        \\n        Queue<int[]> heap = new PriorityQueue<>((a, b) ->\\n            a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n\\n        for (int[] meeting: meetings) {\\n            int start = meeting[0];\\n            int end = meeting[1];\\n\\n            while (!heap.isEmpty() && heap.peek()[0] <= start) {\\n                int[] ended = heap.poll();\\n                freeRooms.add(ended[1]);\\n            }\\n\\n            if (freeRooms.isEmpty()) {\\n                int[] ended = heap.poll();\\n                end += ended[0] - start;\\n                freeRooms.add(ended[1]);\\n            }\\n\\n            int room = freeRooms.pollFirst();\\n            heap.offer(new int[]{end, room});\\n            counts[room]++;\\n        }\\n\\n        int maxCount = counts[0];\\n        int maxRoom = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (counts[i] > maxCount) {\\n                maxCount = counts[i];\\n                maxRoom = i;\\n            }\\n        }\\n        return maxRoom;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652740,
                "title": "c-priority-queue",
                "content": "# Approach\\npriority queue\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    typedef long long ll;\\n    typedef pair<ll, ll> pii;\\n    typedef tuple<ll, ll, ll> tiii;\\n\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        int m = meetings.size();\\n        // {new_start_time, original_start_time, period}\\n        priority_queue<tiii, vector<tiii>, greater<tiii>> waiting_que;  \\n        // {end_time, room_id}\\n        priority_queue<pii, vector<pii>, greater<pii>> using_que; \\n        // {room_id}\\n        priority_queue<int, vector<int>, greater<int>> unused_que;  \\n        vector<int> using_count(n, 0);\\n\\n        for (int i = 0; i < m; i++) \\n            waiting_que.push({meetings[i][0], meetings[i][0], meetings[i][1]-meetings[i][0]});\\n        \\n        for (int i = 0; i < n; i++) \\n            unused_que.push(i);\\n\\n        while (waiting_que.size()) {\\n            auto [s, os, period] = waiting_que.top(); \\n            waiting_que.pop();\\n\\n            // update unused meetingroom \\n            while (using_que.size() && using_que.top().first <= s) {\\n                auto [ee, room_id] = using_que.top(); using_que.pop();\\n                unused_que.push(room_id);\\n            }\\n\\n            if (unused_que.size()) { // have unused meetingroom \\n                int room_id = unused_que.top(); unused_que.pop();\\n                using_que.push({s + period, room_id});\\n                using_count[room_id] += 1;\\n            } else {                // no unused meetingroom \\n                auto [ee, room_id] = using_que.top(); using_que.pop();\\n                using_que.push({ee + period, room_id});\\n                using_count[room_id] += 1;\\n            }\\n        }\\n\\n        auto itr = max_element(using_count.begin(), using_count.end());\\n        return (itr - using_count.begin());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    typedef long long ll;\\n    typedef pair<ll, ll> pii;\\n    typedef tuple<ll, ll, ll> tiii;\\n\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        int m = meetings.size();\\n        // {new_start_time, original_start_time, period}\\n        priority_queue<tiii, vector<tiii>, greater<tiii>> waiting_que;  \\n        // {end_time, room_id}\\n        priority_queue<pii, vector<pii>, greater<pii>> using_que; \\n        // {room_id}\\n        priority_queue<int, vector<int>, greater<int>> unused_que;  \\n        vector<int> using_count(n, 0);\\n\\n        for (int i = 0; i < m; i++) \\n            waiting_que.push({meetings[i][0], meetings[i][0], meetings[i][1]-meetings[i][0]});\\n        \\n        for (int i = 0; i < n; i++) \\n            unused_que.push(i);\\n\\n        while (waiting_que.size()) {\\n            auto [s, os, period] = waiting_que.top(); \\n            waiting_que.pop();\\n\\n            // update unused meetingroom \\n            while (using_que.size() && using_que.top().first <= s) {\\n                auto [ee, room_id] = using_que.top(); using_que.pop();\\n                unused_que.push(room_id);\\n            }\\n\\n            if (unused_que.size()) { // have unused meetingroom \\n                int room_id = unused_que.top(); unused_que.pop();\\n                using_que.push({s + period, room_id});\\n                using_count[room_id] += 1;\\n            } else {                // no unused meetingroom \\n                auto [ee, room_id] = using_que.top(); using_que.pop();\\n                using_que.push({ee + period, room_id});\\n                using_count[room_id] += 1;\\n            }\\n        }\\n\\n        auto itr = max_element(using_count.begin(), using_count.end());\\n        return (itr - using_count.begin());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636423,
                "title": "java-priorityqueue-map",
                "content": "```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        PriorityQueue<long[]> heap = new PriorityQueue<>((long[] a, long[] b) -> Long.compare(a[0], b[0]) == 0 ? Long.compare(a[1], b[1]) : Long.compare(a[0], b[0]));\\n        Map<Integer, Integer> rooms = new HashMap<>();\\n        Arrays.sort(meetings, (int[] a, int[] b) -> a[0] - b[0]);\\n\\n        for (int i = 0; i < n; i++)\\n            heap.add(new long[] {0, i});\\n\\n        int result = 0;\\n\\n        for (int[] meeting : meetings) {\\n            int start = meeting[0];\\n\\n            while (heap.peek()[0] < start)\\n                heap.add(new long[] {start, heap.poll()[1]});\\n\\n            long[] current = heap.poll();\\n            long end = current[0] + (meeting[1] - meeting[0]);\\n            int room = (int) current[1];\\n\\n            rooms.put(room, rooms.getOrDefault(room, 0) + 1);\\n\\n            if (rooms.get(room) > rooms.get(result))\\n                result = room;\\n            else if (rooms.get(room) == rooms.get(result))\\n                result = Math.min(room, result);\\n            \\n            heap.add(new long[] {end, room});\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        PriorityQueue<long[]> heap = new PriorityQueue<>((long[] a, long[] b) -> Long.compare(a[0], b[0]) == 0 ? Long.compare(a[1], b[1]) : Long.compare(a[0], b[0]));\\n        Map<Integer, Integer> rooms = new HashMap<>();\\n        Arrays.sort(meetings, (int[] a, int[] b) -> a[0] - b[0]);\\n\\n        for (int i = 0; i < n; i++)\\n            heap.add(new long[] {0, i});\\n\\n        int result = 0;\\n\\n        for (int[] meeting : meetings) {\\n            int start = meeting[0];\\n\\n            while (heap.peek()[0] < start)\\n                heap.add(new long[] {start, heap.poll()[1]});\\n\\n            long[] current = heap.poll();\\n            long end = current[0] + (meeting[1] - meeting[0]);\\n            int room = (int) current[1];\\n\\n            rooms.put(room, rooms.getOrDefault(room, 0) + 1);\\n\\n            if (rooms.get(room) > rooms.get(result))\\n                result = room;\\n            else if (rooms.get(room) == rooms.get(result))\\n                result = Math.min(room, result);\\n            \\n            heap.add(new long[] {end, room});\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613727,
                "title": "golang-2-min-heap-solution",
                "content": "# Intuition\\nWe need a data structure that can return the next available meeting room and or if all meeting rooms are booked, then it can tell us the meeting room that will be available earliest.\\nSince we keep modifying the booked and available set on encountering every meeting room, the values need to be determined dynamically due to which heap is an appropriate data structure to choose as it can give us the minimum value in logn time.\\n\\n# Approach\\nKeep 2 min heaps\\na. Available room indexes sorted based on the index\\nb. Booked rooms with index and end time sorted based on which meeting ends first and if 2 meetings end at the same time then which one has a lower index\\n\\nWe then sort our meetings based on the start time and which meetings is ending first if start times are same.\\n\\nUsing these min heaps, we then loop over our sorted meeting room set and perform operations in following order\\n1. Remove all booked rooms and make them available, if the end time is before start time.\\n2. Try to see if there is an available meeting room and if there is, then book the room, keeping track of max booked room count\\n3. If no available rooms are present, then it means we have to find the meeting that ends first among the booked rooms, and then rebook it with new end time as duration of meeting + previous end time (i.e. new start time). Since we\\'re doing a booking here, keep track of max booked room count.\\n\\nNote: We have to make sure while tracking the max booked rooms that if new booked room count is same as max booked room, but new booked room index is smaller then we choose that as our max booked room.\\n\\n# Complexity\\n- Time complexity:\\nSince we sort the meetings rooms it would O(nlogn) time\\nWe then loop over all meetings and try to get min value from 2 heaps which would be 2*O(nlogn)\\nSo overall complexity is O(nlogn)\\n\\n- Space complexity:\\nWe are storing a copy of end time, index and available rooms that can all be O(n) size\\n\\n# Code\\n```\\ntype bookedRoom struct {\\n    end int\\n    index int\\n}\\ntype mhBookedRooms []*bookedRoom\\nfunc (mh mhBookedRooms) Len() int { return len(mh) }\\nfunc (mh mhBookedRooms) Swap(i, j int) { mh[i], mh[j] = mh[j], mh[i] }\\nfunc (mh mhBookedRooms) Less(i, j int) bool {\\n    return mh[i].end < mh[j].end || (mh[i].end == mh[j].end && mh[i].index < mh[j].index)\\n}\\nfunc (mh *mhBookedRooms) Push(a interface{}) {\\n    *mh = append(*mh, a.(*bookedRoom))\\n}\\nfunc (mh *mhBookedRooms) Pop() interface{} {\\n    hLen := len(*mh) - 1\\n    el := (*mh)[hLen]\\n    *mh = (*mh)[:hLen]\\n    return el\\n}\\ntype mhAvailableRooms []int\\nfunc (mh mhAvailableRooms) Len() int { return len(mh) }\\nfunc (mh mhAvailableRooms) Swap(i, j int) { mh[i], mh[j] = mh[j], mh[i] }\\nfunc (mh mhAvailableRooms) Less(i, j int) bool {\\n    return mh[i] < mh[j]\\n}\\nfunc (mh *mhAvailableRooms) Push(a interface{}) {\\n    *mh = append(*mh, a.(int))\\n}\\nfunc (mh *mhAvailableRooms) Pop() interface{} {\\n    hLen := len(*mh) - 1\\n    el := (*mh)[hLen]\\n    *mh = (*mh)[:hLen]\\n    return el\\n}\\n\\nfunc mostBooked(n int, meetings [][]int) int {\\n    bookedRooms := &mhBookedRooms{}\\n    availableRooms := &mhAvailableRooms{}\\n    var maxBookedRoomIdx, maxBookedRoomCount int\\n    var bookingCount = make([]int, n)\\n    sort.Slice(meetings, func(i, j int) bool {\\n        return meetings[i][0] < meetings[j][0] || (meetings[i][0] == meetings[j][0] && meetings[i][1] < meetings[j][1])\\n    })\\n    for i:=0; i<n; i++ {\\n        heap.Push(availableRooms, i)\\n    }\\n    for _, meeting := range meetings {\\n        // cleanup\\n        for bookedRooms.Len() > 0 {\\n            booked := heap.Pop(bookedRooms).(*bookedRoom)\\n            if booked.end > meeting[0] {\\n                heap.Push(bookedRooms, booked) // push booked room back\\n                break\\n            } else {\\n                heap.Push(availableRooms, booked.index)\\n            }\\n        }\\n        if availableRooms.Len() > 0 {\\n            room := heap.Pop(availableRooms).(int)\\n            heap.Push(bookedRooms, &bookedRoom{end: meeting[1], index: room})\\n            bookingCount[room]++\\n            // update index if booking count is greater or a lower room index has same count\\n            if bookingCount[room] > maxBookedRoomCount || (bookingCount[room] == maxBookedRoomCount && room < maxBookedRoomIdx) {\\n                maxBookedRoomIdx = room\\n                maxBookedRoomCount = bookingCount[room]\\n            }\\n            continue\\n        }\\n        // no available rooms, use the room which is ending first\\n        booked := heap.Pop(bookedRooms).(*bookedRoom)\\n        bookingCount[booked.index]++\\n        // update index if booking count is greater or a lower room index has same count\\n        if bookingCount[booked.index] > maxBookedRoomCount || (bookingCount[booked.index] == maxBookedRoomCount && booked.index < maxBookedRoomIdx) {\\n            maxBookedRoomIdx = booked.index\\n            maxBookedRoomCount = bookingCount[booked.index]\\n        }\\n        // push to booked\\n        newEnd := booked.end + (meeting[1] - meeting[0])\\n        heap.Push(bookedRooms, &bookedRoom{end: newEnd, index: booked.index})\\n    }\\n    return maxBookedRoomIdx\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntype bookedRoom struct {\\n    end int\\n    index int\\n}\\ntype mhBookedRooms []*bookedRoom\\nfunc (mh mhBookedRooms) Len() int { return len(mh) }\\nfunc (mh mhBookedRooms) Swap(i, j int) { mh[i], mh[j] = mh[j], mh[i] }\\nfunc (mh mhBookedRooms) Less(i, j int) bool {\\n    return mh[i].end < mh[j].end || (mh[i].end == mh[j].end && mh[i].index < mh[j].index)\\n}\\nfunc (mh *mhBookedRooms) Push(a interface{}) {\\n    *mh = append(*mh, a.(*bookedRoom))\\n}\\nfunc (mh *mhBookedRooms) Pop() interface{} {\\n    hLen := len(*mh) - 1\\n    el := (*mh)[hLen]\\n    *mh = (*mh)[:hLen]\\n    return el\\n}\\ntype mhAvailableRooms []int\\nfunc (mh mhAvailableRooms) Len() int { return len(mh) }\\nfunc (mh mhAvailableRooms) Swap(i, j int) { mh[i], mh[j] = mh[j], mh[i] }\\nfunc (mh mhAvailableRooms) Less(i, j int) bool {\\n    return mh[i] < mh[j]\\n}\\nfunc (mh *mhAvailableRooms) Push(a interface{}) {\\n    *mh = append(*mh, a.(int))\\n}\\nfunc (mh *mhAvailableRooms) Pop() interface{} {\\n    hLen := len(*mh) - 1\\n    el := (*mh)[hLen]\\n    *mh = (*mh)[:hLen]\\n    return el\\n}\\n\\nfunc mostBooked(n int, meetings [][]int) int {\\n    bookedRooms := &mhBookedRooms{}\\n    availableRooms := &mhAvailableRooms{}\\n    var maxBookedRoomIdx, maxBookedRoomCount int\\n    var bookingCount = make([]int, n)\\n    sort.Slice(meetings, func(i, j int) bool {\\n        return meetings[i][0] < meetings[j][0] || (meetings[i][0] == meetings[j][0] && meetings[i][1] < meetings[j][1])\\n    })\\n    for i:=0; i<n; i++ {\\n        heap.Push(availableRooms, i)\\n    }\\n    for _, meeting := range meetings {\\n        // cleanup\\n        for bookedRooms.Len() > 0 {\\n            booked := heap.Pop(bookedRooms).(*bookedRoom)\\n            if booked.end > meeting[0] {\\n                heap.Push(bookedRooms, booked) // push booked room back\\n                break\\n            } else {\\n                heap.Push(availableRooms, booked.index)\\n            }\\n        }\\n        if availableRooms.Len() > 0 {\\n            room := heap.Pop(availableRooms).(int)\\n            heap.Push(bookedRooms, &bookedRoom{end: meeting[1], index: room})\\n            bookingCount[room]++\\n            // update index if booking count is greater or a lower room index has same count\\n            if bookingCount[room] > maxBookedRoomCount || (bookingCount[room] == maxBookedRoomCount && room < maxBookedRoomIdx) {\\n                maxBookedRoomIdx = room\\n                maxBookedRoomCount = bookingCount[room]\\n            }\\n            continue\\n        }\\n        // no available rooms, use the room which is ending first\\n        booked := heap.Pop(bookedRooms).(*bookedRoom)\\n        bookingCount[booked.index]++\\n        // update index if booking count is greater or a lower room index has same count\\n        if bookingCount[booked.index] > maxBookedRoomCount || (bookingCount[booked.index] == maxBookedRoomCount && booked.index < maxBookedRoomIdx) {\\n            maxBookedRoomIdx = booked.index\\n            maxBookedRoomCount = bookingCount[booked.index]\\n        }\\n        // push to booked\\n        newEnd := booked.end + (meeting[1] - meeting[0])\\n        heap.Push(bookedRooms, &bookedRoom{end: newEnd, index: booked.index})\\n    }\\n    return maxBookedRoomIdx\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3609475,
                "title": "two-maps-only-o-n-m-logn-t-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        \\n        int m = meetings.size();\\n        sort(meetings.begin() , meetings.end());\\n\\n\\n        map<long long,long long>rooms;\\n        map<long long,long long>use;\\n\\n        for(int j = 0; j < n; j++)rooms[j] = 0;\\n\\n        for(int i = 0; i < m; i++){\\n\\n            int start_time = meetings[i][0];\\n            int end_time = meetings[i][1];\\n            int duration = end_time - start_time;\\n\\n            bool done = false;\\n\\n            for(int j = 0; j < n; j++){\\n                if(start_time >= rooms[j]){\\n                    rooms[j] = end_time;\\n                    use[j]++;\\n                    done = true;\\n                    break;\\n                }\\n            }\\n\\n            if(!done){\\n                \\n                long long early = LONG_MAX;\\n                for(int j = 0; j < n; j++){\\n                    early = min(early , rooms[j]);\\n                }\\n\\n\\n                for(int j = 0 ; j < n; j++){\\n                    if(rooms[j] == early){\\n                        rooms[j] += duration;\\n                        use[j]++;\\n                        break;\\n                    }\\n                }\\n\\n            }\\n\\n        }\\n\\n        long long maxi = 0;\\n\\n        for(int j = 0; j < n; j++){\\n            maxi = max(maxi , use[j]);\\n        }\\n\\n        long long ans;\\n\\n        for(int j = 0; j < n; j++){\\n            if(use[j] == maxi){\\n                ans = j;\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        \\n        int m = meetings.size();\\n        sort(meetings.begin() , meetings.end());\\n\\n\\n        map<long long,long long>rooms;\\n        map<long long,long long>use;\\n\\n        for(int j = 0; j < n; j++)rooms[j] = 0;\\n\\n        for(int i = 0; i < m; i++){\\n\\n            int start_time = meetings[i][0];\\n            int end_time = meetings[i][1];\\n            int duration = end_time - start_time;\\n\\n            bool done = false;\\n\\n            for(int j = 0; j < n; j++){\\n                if(start_time >= rooms[j]){\\n                    rooms[j] = end_time;\\n                    use[j]++;\\n                    done = true;\\n                    break;\\n                }\\n            }\\n\\n            if(!done){\\n                \\n                long long early = LONG_MAX;\\n                for(int j = 0; j < n; j++){\\n                    early = min(early , rooms[j]);\\n                }\\n\\n\\n                for(int j = 0 ; j < n; j++){\\n                    if(rooms[j] == early){\\n                        rooms[j] += duration;\\n                        use[j]++;\\n                        break;\\n                    }\\n                }\\n\\n            }\\n\\n        }\\n\\n        long long maxi = 0;\\n\\n        for(int j = 0; j < n; j++){\\n            maxi = max(maxi , use[j]);\\n        }\\n\\n        long long ans;\\n\\n        for(int j = 0; j < n; j++){\\n            if(use[j] == maxi){\\n                ans = j;\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604695,
                "title": "c-solution-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> &a,vector<int> &b)\\n    {\\n        return a[0]<b[0];\\n    }\\n\\n    int mostBooked(int n, vector<vector<int>>& meetings)\\n    {\\n        vector<int> usedFrequency(n,0);\\n        sort(meetings.begin(),meetings.end(),comp);\\n\\n        priority_queue<long long,vector<long long>,greater<>> availableRooms;\\n        priority_queue<pair<long long,long long>,vector<pair<long long,long long>>,greater<>> ongoingMeeting;    \\n\\n        for(int i=0;i<n;i++)\\n        {\\n            availableRooms.push(i);\\n        }\\n\\n        for(int i=0;i<meetings.size();i++)\\n        {\\n            long long start = meetings[i][0], end = meetings[i][1];\\n            if(ongoingMeeting.empty())\\n            {\\n                long long room = availableRooms.top();\\n                usedFrequency[room]++;\\n                availableRooms.pop();\\n                ongoingMeeting.push({end,room});\\n            }\\n            else if(ongoingMeeting.top().first<=start)\\n            {\\n                while(ongoingMeeting.size() && ongoingMeeting.top().first<=start)\\n                {\\n                    long long room =  ongoingMeeting.top().second;\\n                    availableRooms.push(room);\\n                    ongoingMeeting.pop();\\n                }\\n\\n                long long room = availableRooms.top();\\n                usedFrequency[room]++;\\n                availableRooms.pop();\\n                ongoingMeeting.push({end,room});\\n            }\\n            else if(ongoingMeeting.top().first>start && availableRooms.size())\\n            {\\n                long long room = availableRooms.top();\\n                usedFrequency[room]++;\\n                availableRooms.pop();\\n                ongoingMeeting.push({end,room});\\n            }\\n            else\\n            {\\n                long long endTime = ongoingMeeting.top().first;\\n                long long room =  ongoingMeeting.top().second;\\n                ongoingMeeting.pop();\\n                usedFrequency[room]++;\\n\\n                ongoingMeeting.push({endTime + end - start,room});    \\n            }\\n        }\\n\\n        long long mostBookedRoom = -1,freq=-1;\\n\\n        for(int i=0;i<usedFrequency.size();i++)\\n        {\\n            if((freq<usedFrequency[i]))\\n            {\\n                mostBookedRoom = i;\\n                freq = usedFrequency[i];\\n            }\\n        }\\n\\n        return mostBookedRoom;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> &a,vector<int> &b)\\n    {\\n        return a[0]<b[0];\\n    }\\n\\n    int mostBooked(int n, vector<vector<int>>& meetings)\\n    {\\n        vector<int> usedFrequency(n,0);\\n        sort(meetings.begin(),meetings.end(),comp);\\n\\n        priority_queue<long long,vector<long long>,greater<>> availableRooms;\\n        priority_queue<pair<long long,long long>,vector<pair<long long,long long>>,greater<>> ongoingMeeting;    \\n\\n        for(int i=0;i<n;i++)\\n        {\\n            availableRooms.push(i);\\n        }\\n\\n        for(int i=0;i<meetings.size();i++)\\n        {\\n            long long start = meetings[i][0], end = meetings[i][1];\\n            if(ongoingMeeting.empty())\\n            {\\n                long long room = availableRooms.top();\\n                usedFrequency[room]++;\\n                availableRooms.pop();\\n                ongoingMeeting.push({end,room});\\n            }\\n            else if(ongoingMeeting.top().first<=start)\\n            {\\n                while(ongoingMeeting.size() && ongoingMeeting.top().first<=start)\\n                {\\n                    long long room =  ongoingMeeting.top().second;\\n                    availableRooms.push(room);\\n                    ongoingMeeting.pop();\\n                }\\n\\n                long long room = availableRooms.top();\\n                usedFrequency[room]++;\\n                availableRooms.pop();\\n                ongoingMeeting.push({end,room});\\n            }\\n            else if(ongoingMeeting.top().first>start && availableRooms.size())\\n            {\\n                long long room = availableRooms.top();\\n                usedFrequency[room]++;\\n                availableRooms.pop();\\n                ongoingMeeting.push({end,room});\\n            }\\n            else\\n            {\\n                long long endTime = ongoingMeeting.top().first;\\n                long long room =  ongoingMeeting.top().second;\\n                ongoingMeeting.pop();\\n                usedFrequency[room]++;\\n\\n                ongoingMeeting.push({endTime + end - start,room});    \\n            }\\n        }\\n\\n        long long mostBookedRoom = -1,freq=-1;\\n\\n        for(int i=0;i<usedFrequency.size();i++)\\n        {\\n            if((freq<usedFrequency[i]))\\n            {\\n                mostBookedRoom = i;\\n                freq = usedFrequency[i];\\n            }\\n        }\\n\\n        return mostBookedRoom;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594417,
                "title": "python-one-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        def get_room(meeting):\\n            \\'\\'\\'\\n            get the earliest/smallest ID room\\n            assign if available, else, wait_for_room and reschedule\\n            returns the (rescheduled) end time\\n            \\'\\'\\'\\n\\n            end_time, room = heapq.heappop(pq)\\n            cur_end = meeting[1]\\n            if end_time > meeting[0]: # have to wait and reschedule\\n                cur_end = end_time +  meeting[1] -  meeting[0] # rescheduled end time\\n                heapq.heappush(pq, (cur_end, room))\\n                return room\\n            else: # there mgiht be multiple rooms available?? should pick the lowest ID, how?\\n             # pop all the available ones, select the smallest ID, and put everything else back\\n                candidate_rooms, selected_id = [(end_time, room)], room\\n                while pq and pq[0][0] <= meeting[0]:\\n                    room_info = heapq.heappop(pq)\\n                    candidate_rooms.append(room_info)\\n                    selected_id = min(selected_id, room_info[1])\\n                for candidate_room in candidate_rooms:\\n                    if candidate_room[1] != selected_id:\\n                        heapq.heappush(pq, candidate_room)\\n                heapq.heappush(pq, (cur_end, selected_id))\\n            return selected_id\\n\\n        meetings.sort()\\n\\n        rooms = {}\\n        pq = []\\n\\n        for i in range(n):\\n            rooms[i] = 0\\n            heapq.heappush(pq, (0, i)) # end_time, room_id\\n            \\n    \\n        for meeting in meetings:\\n            room = get_room(meeting)\\n            rooms[room] = rooms[room] + 1\\n\\n        sorted_r = sorted(rooms.items(), key=lambda x: (-x[1], x[0])) # sort by max meetings, then small ID\\n        return sorted_r[0][0]\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        def get_room(meeting):\\n            \\'\\'\\'\\n            get the earliest/smallest ID room\\n            assign if available, else, wait_for_room and reschedule\\n            returns the (rescheduled) end time\\n            \\'\\'\\'\\n\\n            end_time, room = heapq.heappop(pq)\\n            cur_end = meeting[1]\\n            if end_time > meeting[0]: # have to wait and reschedule\\n                cur_end = end_time +  meeting[1] -  meeting[0] # rescheduled end time\\n                heapq.heappush(pq, (cur_end, room))\\n                return room\\n            else: # there mgiht be multiple rooms available?? should pick the lowest ID, how?\\n             # pop all the available ones, select the smallest ID, and put everything else back\\n                candidate_rooms, selected_id = [(end_time, room)], room\\n                while pq and pq[0][0] <= meeting[0]:\\n                    room_info = heapq.heappop(pq)\\n                    candidate_rooms.append(room_info)\\n                    selected_id = min(selected_id, room_info[1])\\n                for candidate_room in candidate_rooms:\\n                    if candidate_room[1] != selected_id:\\n                        heapq.heappush(pq, candidate_room)\\n                heapq.heappush(pq, (cur_end, selected_id))\\n            return selected_id\\n\\n        meetings.sort()\\n\\n        rooms = {}\\n        pq = []\\n\\n        for i in range(n):\\n            rooms[i] = 0\\n            heapq.heappush(pq, (0, i)) # end_time, room_id\\n            \\n    \\n        for meeting in meetings:\\n            room = get_room(meeting)\\n            rooms[room] = rooms[room] + 1\\n\\n        sorted_r = sorted(rooms.items(), key=lambda x: (-x[1], x[0])) # sort by max meetings, then small ID\\n        return sorted_r[0][0]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570914,
                "title": "c-min-heap",
                "content": "```\\nUse two MinHeaps, one for free rooms and one for occupied rooms. FreeRoom heap should be sorted by room id, while the occupied room heap should be sorted by end time of meeting, then room id.\\ntypedef long long int ll;\\ntypedef priority_queue<pair<ll, pair<ll, ll>>, vector<pair<ll, pair<ll, ll>>>, greater<pair<ll, pair<ll, ll>>>> MinHeap;\\n\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        sort(meetings.begin(), meetings.end(), [](const vector<int>& a1, const vector<int>& a2) -> bool{\\n            return ((a1[0] == a2[0]) ? (a1[1] < a2[1]) : (a1[0] < a2[0]));\\n        });\\n\\n        MinHeap freeRooms;\\n        MinHeap occupiedRooms;\\n        for(int i = 0 ; i < n ; i++)\\n            freeRooms.push({i, {0, 0}});\\n        \\n        unordered_map<int, int> mp;\\n        int maxRoom = 0, maxCnt = 0;\\n        for(auto &meeting : meetings){\\n            ll st = meeting[0], ed = meeting[1];\\n            ll duration = ed-st;\\n            \\n            while(occupiedRooms.empty() == false && occupiedRooms.top().first <= st){\\n                freeRooms.push({occupiedRooms.top().second.first, {occupiedRooms.top().second.second, occupiedRooms.top().first}});\\n                occupiedRooms.pop();\\n            }\\n            \\n            if(freeRooms.empty() == true){\\n                auto roomPr = occupiedRooms.top();\\n                occupiedRooms.pop();\\n                ll roomId = roomPr.second.first;\\n                ll currCnt = ++mp[roomId];\\n                ll newSt = roomPr.first;\\n                ll newEd = newSt+duration;\\n                occupiedRooms.push({newEd, {roomId, newSt}});\\n                if(currCnt > maxCnt){\\n                    maxCnt = currCnt;\\n                    maxRoom = roomId;\\n                }else if(currCnt == maxCnt && maxRoom > roomId){\\n                    maxRoom = roomId;\\n                }\\n                \\n            }else{\\n                auto roomPr = freeRooms.top();\\n                freeRooms.pop();\\n                int currCnt = ++mp[roomPr.first];\\n                if(currCnt > maxCnt){\\n                    maxCnt = currCnt;\\n                    maxRoom = roomPr.first;\\n                }else if(currCnt == maxCnt && maxRoom > roomPr.first){\\n                    maxRoom = roomPr.first;\\n                }\\n                ll newSt = max(roomPr.second.second, st);\\n                ll newEd = newSt+duration;\\n                occupiedRooms.push({newEd, {roomPr.first, newSt}});\\n            }\\n        }\\n        return maxRoom;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nUse two MinHeaps, one for free rooms and one for occupied rooms. FreeRoom heap should be sorted by room id, while the occupied room heap should be sorted by end time of meeting, then room id.\\ntypedef long long int ll;\\ntypedef priority_queue<pair<ll, pair<ll, ll>>, vector<pair<ll, pair<ll, ll>>>, greater<pair<ll, pair<ll, ll>>>> MinHeap;\\n\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        sort(meetings.begin(), meetings.end(), [](const vector<int>& a1, const vector<int>& a2) -> bool{\\n            return ((a1[0] == a2[0]) ? (a1[1] < a2[1]) : (a1[0] < a2[0]));\\n        });\\n\\n        MinHeap freeRooms;\\n        MinHeap occupiedRooms;\\n        for(int i = 0 ; i < n ; i++)\\n            freeRooms.push({i, {0, 0}});\\n        \\n        unordered_map<int, int> mp;\\n        int maxRoom = 0, maxCnt = 0;\\n        for(auto &meeting : meetings){\\n            ll st = meeting[0], ed = meeting[1];\\n            ll duration = ed-st;\\n            \\n            while(occupiedRooms.empty() == false && occupiedRooms.top().first <= st){\\n                freeRooms.push({occupiedRooms.top().second.first, {occupiedRooms.top().second.second, occupiedRooms.top().first}});\\n                occupiedRooms.pop();\\n            }\\n            \\n            if(freeRooms.empty() == true){\\n                auto roomPr = occupiedRooms.top();\\n                occupiedRooms.pop();\\n                ll roomId = roomPr.second.first;\\n                ll currCnt = ++mp[roomId];\\n                ll newSt = roomPr.first;\\n                ll newEd = newSt+duration;\\n                occupiedRooms.push({newEd, {roomId, newSt}});\\n                if(currCnt > maxCnt){\\n                    maxCnt = currCnt;\\n                    maxRoom = roomId;\\n                }else if(currCnt == maxCnt && maxRoom > roomId){\\n                    maxRoom = roomId;\\n                }\\n                \\n            }else{\\n                auto roomPr = freeRooms.top();\\n                freeRooms.pop();\\n                int currCnt = ++mp[roomPr.first];\\n                if(currCnt > maxCnt){\\n                    maxCnt = currCnt;\\n                    maxRoom = roomPr.first;\\n                }else if(currCnt == maxCnt && maxRoom > roomPr.first){\\n                    maxRoom = roomPr.first;\\n                }\\n                ll newSt = max(roomPr.second.second, st);\\n                ll newEd = newSt+duration;\\n                occupiedRooms.push({newEd, {roomPr.first, newSt}});\\n            }\\n        }\\n        return maxRoom;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566100,
                "title": "c-priority-queue",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // [end time, room number]\\n        priority_queue<pair<long, int>, \\n                       vector<pair<long, int>>, \\n                       greater<pair<long, int>>> occupied;\\n        // [room number]\\n        priority_queue<int, vector<int>, greater<int>> free;\\n        // [room number, frequency]\\n        unordered_map<int, int> frequency;\\n        \\n        sort(meetings.begin(), meetings.end());\\n        // all meeting rooms are free\\n        for(int i = 0; i < n; i++){\\n            free.push(i);\\n        }\\n        \\n        for(const auto& meet : meetings){\\n            \\n            int cur_start = meet[0];\\n            int cur_end = meet[1];\\n            \\n            // occupied -> free\\n            while(occupied.size() && occupied.top().first <= cur_start){\\n                int room = occupied.top().second;\\n                occupied.pop();  // move occupied to free\\n                free.push(room);\\n            }\\n            \\n            // free -> occupied\\n            if(!free.empty()){\\n                int free_room = free.top();\\n                free.pop();  // move free to occupied\\n                occupied.push({cur_end, free_room});\\n                frequency[free_room]++;\\n            }\\n            \\n            // occupied -> occupied\\n            else{\\n                pair<long, int> first_available = occupied.top();\\n                occupied.pop(); // move occupied to another occupied\\n                long new_end = first_available.first;\\n                new_end += (cur_end - cur_start);\\n                occupied.push({new_end, first_available.second});\\n                frequency[first_available.second]++;\\n            }\\n        }\\n        int max_freq_room = 0;\\n        for(int i = 1; i < frequency.size(); i++){\\n            if(frequency[max_freq_room] < frequency[i]){\\n                max_freq_room = i;\\n            }\\n        }\\n        \\n        return max_freq_room;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // [end time, room number]\\n        priority_queue<pair<long, int>, \\n                       vector<pair<long, int>>, \\n                       greater<pair<long, int>>> occupied;\\n        // [room number]\\n        priority_queue<int, vector<int>, greater<int>> free;\\n        // [room number, frequency]\\n        unordered_map<int, int> frequency;\\n        \\n        sort(meetings.begin(), meetings.end());\\n        // all meeting rooms are free\\n        for(int i = 0; i < n; i++){\\n            free.push(i);\\n        }\\n        \\n        for(const auto& meet : meetings){\\n            \\n            int cur_start = meet[0];\\n            int cur_end = meet[1];\\n            \\n            // occupied -> free\\n            while(occupied.size() && occupied.top().first <= cur_start){\\n                int room = occupied.top().second;\\n                occupied.pop();  // move occupied to free\\n                free.push(room);\\n            }\\n            \\n            // free -> occupied\\n            if(!free.empty()){\\n                int free_room = free.top();\\n                free.pop();  // move free to occupied\\n                occupied.push({cur_end, free_room});\\n                frequency[free_room]++;\\n            }\\n            \\n            // occupied -> occupied\\n            else{\\n                pair<long, int> first_available = occupied.top();\\n                occupied.pop(); // move occupied to another occupied\\n                long new_end = first_available.first;\\n                new_end += (cur_end - cur_start);\\n                occupied.push({new_end, first_available.second});\\n                frequency[first_available.second]++;\\n            }\\n        }\\n        int max_freq_room = 0;\\n        for(int i = 1; i < frequency.size(); i++){\\n            if(frequency[max_freq_room] < frequency[i]){\\n                max_freq_room = i;\\n            }\\n        }\\n        \\n        return max_freq_room;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553867,
                "title": "solution-using-heap-priorityqueue-with-detailed-explanation",
                "content": "\\n# Approach\\nThis code represents a solution for finding the most booked room in a set of meetings. Let\\'s go through the code step by step:\\n\\n1. The code starts by defining a class named `Solution` with a public method `MostBooked` that takes two parameters: an integer `n` representing the number of rooms and a two-dimensional integer array `meetings` representing the start and end times of the meetings.\\n\\n2. The code then sorts the `meetings` array using `Array.Sort`, passing a lambda function `(x, y) => x[0] - y[0]` as the comparison function. This sorts the meetings based on their start times in ascending order.\\n\\n3. A `PriorityQueue` is initialized with a custom comparer. This priority queue will store tuples `(int roomNumber, long whenAvailable, int count)`. The comparer function compares the tuples based on the `whenAvailable` field. If the `whenAvailable` values are equal, it compares the `roomNumber` field. This ensures that the priority queue retrieves the room with the earliest availability first.\\n\\n4. A loop is started to enqueue initial room states into the priority queue. Each room is initialized with `(i, 0, 0)`, where `i` represents the room number, `0` represents the initial availability time, and `0` represents the initial booking count.\\n\\n5. Another loop is started to process each meeting in the sorted `meetings` array.\\n\\n6. Inside the loop, it checks the availability of the rooms in the priority queue. If the earliest available room is still not available for the current meeting start time (`meetings[i][0]`), it dequeues the room, updates its availability time to match the current meeting start time, and enqueues it back into the priority queue.\\n\\n7. After ensuring that a suitable room is available, it dequeues the room from the priority queue.\\n\\n8. It then checks if the current room\\'s availability time (`whenAvailable`) is greater than the current meeting\\'s start time (`meetings[i][0]`). If it is, it means the room is already booked for a later time, so the availability time is updated by adding the difference between the meeting\\'s end time (`meetings[i][1]`) and start time (`meetings[i][0]`) to it. Otherwise, the room\\'s availability time is set to the meeting\\'s end time.\\n\\n9. The booking count for the room is incremented.\\n\\n10. The updated room is enqueued back into the priority queue.\\n\\n11. After processing all the meetings, the first room tuple is dequeued from the priority queue. This represents the room with the highest booking count and earliest availability.\\n\\n12. A loop is started to find the room with the highest booking count. The current room tuple is dequeued from the priority queue, and if its booking count is equal to the best count found so far and its room number is lower, it becomes the new best room. If its booking count is higher than the best count, it becomes the new best room.\\n\\n13. Finally, the room number of the best room is returned as the result.\\n\\nIn summary, this code sorts the meetings based on their start times and then assigns rooms to the meetings, making sure the rooms have the earliest availability and keeping track of the booking count. It finds the room with the highest booking count and earliest availability and returns its room number.\\n# Code\\n```\\npublic class Solution {\\n    public int MostBooked(int n, int[][] meetings) {\\n        Array.Sort(meetings, (x, y) => x[0] - y[0]);\\n        var rooms = new PriorityQueue<(int roomNumber, long whenAvailable, int count), (int roomNumber, long whenAvailable, int count)>(\\n            Comparer<(int roomNumber, long whenAvailable, int count)>.Create(\\n                (x, y) => x.whenAvailable == y.whenAvailable ? x.roomNumber - y.roomNumber : (int)(x.whenAvailable - y.whenAvailable)));\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            rooms.Enqueue((i, 0, 0), (i, 0, 0));\\n        }\\n\\n        for(int i = 0; i < meetings.Length; i++)\\n        {\\n            while(rooms.Peek().whenAvailable < meetings[i][0])\\n            {\\n                var temp = rooms.Dequeue();\\n                temp.whenAvailable = meetings[i][0];\\n                rooms.Enqueue(temp, temp);\\n            }\\n\\n            var cur = rooms.Dequeue();\\n            if(cur.whenAvailable > meetings[i][0])\\n                cur.whenAvailable += (meetings[i][1] - meetings[i][0]);\\n            else\\n                cur.whenAvailable = meetings[i][1];\\n            cur.count++;\\n            rooms.Enqueue(cur, cur);\\n        }\\n\\n        (int roomNumber, long whenAvailable, int count) best = rooms.Dequeue(); \\n        while(rooms.Count > 0)\\n        {\\n            var cur = rooms.Dequeue();\\n            if(cur.count == best.count && cur.roomNumber < best.roomNumber)\\n                best = cur;\\n            else if(cur.count > best.count)\\n                best = cur;\\n        }\\n        return best.roomNumber;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MostBooked(int n, int[][] meetings) {\\n        Array.Sort(meetings, (x, y) => x[0] - y[0]);\\n        var rooms = new PriorityQueue<(int roomNumber, long whenAvailable, int count), (int roomNumber, long whenAvailable, int count)>(\\n            Comparer<(int roomNumber, long whenAvailable, int count)>.Create(\\n                (x, y) => x.whenAvailable == y.whenAvailable ? x.roomNumber - y.roomNumber : (int)(x.whenAvailable - y.whenAvailable)));\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            rooms.Enqueue((i, 0, 0), (i, 0, 0));\\n        }\\n\\n        for(int i = 0; i < meetings.Length; i++)\\n        {\\n            while(rooms.Peek().whenAvailable < meetings[i][0])\\n            {\\n                var temp = rooms.Dequeue();\\n                temp.whenAvailable = meetings[i][0];\\n                rooms.Enqueue(temp, temp);\\n            }\\n\\n            var cur = rooms.Dequeue();\\n            if(cur.whenAvailable > meetings[i][0])\\n                cur.whenAvailable += (meetings[i][1] - meetings[i][0]);\\n            else\\n                cur.whenAvailable = meetings[i][1];\\n            cur.count++;\\n            rooms.Enqueue(cur, cur);\\n        }\\n\\n        (int roomNumber, long whenAvailable, int count) best = rooms.Dequeue(); \\n        while(rooms.Count > 0)\\n        {\\n            var cur = rooms.Dequeue();\\n            if(cur.count == best.count && cur.roomNumber < best.roomNumber)\\n                best = cur;\\n            else if(cur.count > best.count)\\n                best = cur;\\n        }\\n        return best.roomNumber;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553394,
                "title": "java-straighforward-solution-using-priorityqueue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (o1, o2) -> o1[0] - o2[0]);//sort meeting by start time.\\n        PriorityQueue<Room> pq = new PriorityQueue<>();\\n        int[] count = new int[n];\\n        for (int i = 0; i < n; i++){\\n            pq.add(new Room(i, 0));\\n        }    \\n\\n        for (int[] m : meetings){\\n            int start = m[0], end = m[1];\\n            while (pq.peek().avaiTime < start){//This is to handle the case there are multiple avai Room when a meeting starts.\\n                Room top = pq.remove();\\n                pq.add(new Room(top.id, start));\\n            }\\n            Room top = pq.remove();\\n            int id = top.id;\\n            long preEnd = top.avaiTime;\\n            count[id]++;\\n            pq.add(new Room(id, preEnd + end - start));\\n        }\\n\\n        int max = 0;\\n        int result = 0;\\n        for (int i = 0; i < n; i++){\\n            if (max < count[i]){\\n                max = count[i];\\n                result = i;\\n            }\\n        }\\n        return result;\\n    }\\n}\\nclass Room implements Comparable<Room>{\\n    int id;\\n    long avaiTime;\\n\\n    public Room(int id, long avaiTime){\\n        this.id = id;\\n        this.avaiTime = avaiTime;\\n    }\\n    @Override\\n    public int compareTo(Room another){\\n        if (this.avaiTime < another.avaiTime) return -1;\\n        if (this.avaiTime > another.avaiTime) return 1;\\n        return this.id - another.id;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (o1, o2) -> o1[0] - o2[0]);//sort meeting by start time.\\n        PriorityQueue<Room> pq = new PriorityQueue<>();\\n        int[] count = new int[n];\\n        for (int i = 0; i < n; i++){\\n            pq.add(new Room(i, 0));\\n        }    \\n\\n        for (int[] m : meetings){\\n            int start = m[0], end = m[1];\\n            while (pq.peek().avaiTime < start){//This is to handle the case there are multiple avai Room when a meeting starts.\\n                Room top = pq.remove();\\n                pq.add(new Room(top.id, start));\\n            }\\n            Room top = pq.remove();\\n            int id = top.id;\\n            long preEnd = top.avaiTime;\\n            count[id]++;\\n            pq.add(new Room(id, preEnd + end - start));\\n        }\\n\\n        int max = 0;\\n        int result = 0;\\n        for (int i = 0; i < n; i++){\\n            if (max < count[i]){\\n                max = count[i];\\n                result = i;\\n            }\\n        }\\n        return result;\\n    }\\n}\\nclass Room implements Comparable<Room>{\\n    int id;\\n    long avaiTime;\\n\\n    public Room(int id, long avaiTime){\\n        this.id = id;\\n        this.avaiTime = avaiTime;\\n    }\\n    @Override\\n    public int compareTo(Room another){\\n        if (this.avaiTime < another.avaiTime) return -1;\\n        if (this.avaiTime > another.avaiTime) return 1;\\n        return this.id - another.id;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546603,
                "title": "python-heap-sort-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar to meeting rooms 2, we want to sort the meetings by start time so we can process them. Since we always want to use the lowest room # first, we will use a min heap to track the available rooms. We will also use a min heap to track end times so we know when each room will be free.\\n\\nThe complexity of the problem comes from the fact that a meeting can be delayed if there are no rooms. As such, the end time of a meeting may not be the real end time and the problem becomes similar to a scheduling problem with multiple threads and tasks. Take for example a meeting [10, 15]. If the meeting is delayed and instead starts 5 time units later, the real end time would be 20. Therefore we will track the time and we will also use the length of the meeting instead of the time itself.\\n\\nGoing back to the [10, 15] example, we would replace it with [10, 5], which means \"the meeting starts at time=10, and lasts 5 time units\". This way if the meeting is delayed and it starts at a later time, we can calculate the end time as time_started+length (5 in this case)/\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize 2 heaps for the available and in-use rooms. Initialize an array to track how often each room is used. \\n\\n1. Sort meetings by start time\\n2. Loop through the meetings and replace the end time with the length which is equal to (start_time - end_time)\\n3. Push all the rooms into the available heap\\n4. Set time = 0. We will update the time on 2 occasions:\\n    a. The next meeting is starting and there is a room available. Then time is set to the start time of that meeting\\n    b. There is no room available for the incoming meeting. We set the time to when a room will open up. This will be the minimum value in the in_use_rooms heap\\n\\n    Note that we take the max of these 2 values since time cannot go backwards. So if the start time of a meeting is delayed, we keep the time at the end time of the meeting in the room that was made avaialble.\\n\\n5. Loop through the meetings and run through the following steps:\\n    **a**. Update the time. This will either be the next start time or the time in which the most recent a meeting finished/room was reopened.\\n    **b**. Based on the time, open up rooms where meetings have ended.\\n    **c**. If there are no rooms available, move the time to the next time a meeting ends/room opens up. Pop that room from the busy heap and move it to the avaialble heap.\\n    **d**. Allocate the room to the meeting. Set the ending time of the meeting as the length of the meeting + the current time. Note that we are guaranteed that a room is open due to step 4.\\n6. After all meetings have been processed, loop through the array of frequencies to determine which room is used the most.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$ for the sort. We run a for loop through the meetings with heappush and heappop operations (which are $$O(logk)$$ where k is the number of element in the heap). This has a worst case runtime of $$O(nlogn)$$.\\n\\nOverall Time Complexity: $$O(nlogn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe heaps and the frequency array are $$O(n)$$. Note that depending on the language and implementation, the sorting algorithm at the beginning may take space.\\n\\nOverall Space Complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution(object):\\n    def mostBooked(self, n, meetings):\\n        \"\"\"\\n        :type n: int\\n        :type meetings: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        # sort meetings by start time\\n        # use a pq to track lowest meeting value n that is AVAILABLE\\n        # use a pq to track [end time, room #] \\n        # array [freq that each room was used]\\n        available_rooms = []\\n        in_use_rooms = []\\n        freq = [0]*n\\n\\n        meetings = sorted(meetings, key=lambda x: x[0])\\n        for i in range(0, len(meetings)):\\n            meeting = meetings[i]\\n            meetings[i][1] = meeting[1] - meeting[0]\\n        for i in range(0, n):\\n            heapq.heappush(available_rooms, i)\\n\\n        time = 0\\n        for meeting in meetings:\\n            time = max(time, meeting[0])\\n            # pop any rooms that are now free_room\\n            while len(in_use_rooms) > 0 and in_use_rooms[0][0] <= time:\\n                free_room = heapq.heappop(in_use_rooms)[1]\\n                heapq.heappush(available_rooms, free_room)\\n\\n\\n            if len(available_rooms) == 0:\\n                # move the end_pointer to the next ending to end a meeting\\n                time = in_use_rooms[0][0]\\n                while len(in_use_rooms) > 0 and in_use_rooms[0][0] == time:\\n                    free_room = heapq.heappop(in_use_rooms)[1]\\n                    heapq.heappush(available_rooms, free_room)\\n\\n            # allocate the lowest number room for this meeting\\n            alloc_room = heapq.heappop(available_rooms)\\n            heapq.heappush(in_use_rooms, [meeting[1]+time, alloc_room])\\n            freq[alloc_room] += 1\\n\\n        max_count = 0\\n        ans = 0\\n        for i in range(0, n):\\n            if freq[i] > max_count:\\n                ans = i\\n                max_count = freq[i]\\n\\n        return ans\\n\\n\\n\\n                \\n\\n            \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution(object):\\n    def mostBooked(self, n, meetings):\\n        \"\"\"\\n        :type n: int\\n        :type meetings: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        # sort meetings by start time\\n        # use a pq to track lowest meeting value n that is AVAILABLE\\n        # use a pq to track [end time, room #] \\n        # array [freq that each room was used]\\n        available_rooms = []\\n        in_use_rooms = []\\n        freq = [0]*n\\n\\n        meetings = sorted(meetings, key=lambda x: x[0])\\n        for i in range(0, len(meetings)):\\n            meeting = meetings[i]\\n            meetings[i][1] = meeting[1] - meeting[0]\\n        for i in range(0, n):\\n            heapq.heappush(available_rooms, i)\\n\\n        time = 0\\n        for meeting in meetings:\\n            time = max(time, meeting[0])\\n            # pop any rooms that are now free_room\\n            while len(in_use_rooms) > 0 and in_use_rooms[0][0] <= time:\\n                free_room = heapq.heappop(in_use_rooms)[1]\\n                heapq.heappush(available_rooms, free_room)\\n\\n\\n            if len(available_rooms) == 0:\\n                # move the end_pointer to the next ending to end a meeting\\n                time = in_use_rooms[0][0]\\n                while len(in_use_rooms) > 0 and in_use_rooms[0][0] == time:\\n                    free_room = heapq.heappop(in_use_rooms)[1]\\n                    heapq.heappush(available_rooms, free_room)\\n\\n            # allocate the lowest number room for this meeting\\n            alloc_room = heapq.heappop(available_rooms)\\n            heapq.heappush(in_use_rooms, [meeting[1]+time, alloc_room])\\n            freq[alloc_room] += 1\\n\\n        max_count = 0\\n        ans = 0\\n        for i in range(0, n):\\n            if freq[i] > max_count:\\n                ans = i\\n                max_count = freq[i]\\n\\n        return ans\\n\\n\\n\\n                \\n\\n            \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542823,
                "title": "python-heapq-short-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        pq = []\\n        for i in range(n):\\n            heapq.heappush(pq, (0, i, 0)) # endtime, room#, count\\n        \\n        for m in meetings:\\n            while pq[0][0] < m[0]:\\n                next_room = heapq.heappop(pq)\\n                heapq.heappush(pq, (m[0], next_room[1], next_room[2]))\\n            next_room = heapq.heappop(pq)\\n            next_end = m[1] if m[0] >= next_room[0] else m[1] - m[0] + next_room[0]\\n            heapq.heappush(pq, (next_end, next_room[1], next_room[2]+1))\\n        \\n        pq.sort(key=lambda x: (-x[2], x[1]))\\n        return pq[0][1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        pq = []\\n        for i in range(n):\\n            heapq.heappush(pq, (0, i, 0)) # endtime, room#, count\\n        \\n        for m in meetings:\\n            while pq[0][0] < m[0]:\\n                next_room = heapq.heappop(pq)\\n                heapq.heappush(pq, (m[0], next_room[1], next_room[2]))\\n            next_room = heapq.heappop(pq)\\n            next_end = m[1] if m[0] >= next_room[0] else m[1] - m[0] + next_room[0]\\n            heapq.heappush(pq, (next_end, next_room[1], next_room[2]+1))\\n        \\n        pq.sort(key=lambda x: (-x[2], x[1]))\\n        return pq[0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532355,
                "title": "heap-set-solution",
                "content": "This was hard... I was able to actually explain this approach within 10 minutes of reading the question which is the first time I have ever done it for a hard problem!\\n... It took 2 more hours to figure it out on code tho. \\nI knew I almost had it so did not want to give up and see a solution that I may or may not have liked. I was working test case by test case ever so creeping close to the 80th case which eventually I did.\\n# Approach\\nSort the meeting intervals. Question states we need to prioritize earlier meeting dates (makes sense).\\nPQ1: \\'pq\\' - keeps the end time and the room associated with the meeting.\\nPQ2: \\'vacant\\' - has all the vacant meeting rooms. Using a heap because we need to pick out the smallest room before using higher numbers.\\nSet: \\'rooms\\' - just the set of rooms to increment counter to return the best room at the end.\\n\\nFirst initialize all the rooms and push them to the vacant heap.\\n\\nFor each meeting interval,\\n- Firstly, check if there are any meetings that are \"done\". If they are then that means we need to add them to our vacant heap.\\n- If there is a vacancy, then we push our current interval to that room (now this room is occupied!)\\n- If there are no vacancies at all, then this means we need to speed up time. Lets go to the earliest meeting that is about to get finished. This meeting overlaps/bleeds through our current interval, so we need to add this extra time to the end time (end - interval[0]interval[1]).\\n\\nLastly, find the best room and return it (highest frequency).\\n\\n# Complexity\\n- Time complexity:\\nO(M * Log(R))\\nM = meeting intervals\\nR = rooms\\nFor each interval, we are both pushing/popping from heap.\\n\\n\\n- Space complexity:\\nO(N) - 1D structures used\\n\\n# Code\\n```\\nimport heapq\\n\\nclass Solution(object):\\n    def mostBooked(self, n, meetings):\\n        \"\"\"\\n        :type n: int\\n        :type meetings: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        meetings.sort(key=lambda x:x[0])\\n        pq = [] # (the end time, room no) -> heap structure\\n        rooms = {} #{room no : num times used}\\n        vacant = [] # [rooms]\\n\\n        for i in range(0, n):\\n            rooms[i] = 0\\n            heapq.heappush(vacant, i)\\n\\n        for j in range(len(meetings)):\\n            interval = meetings[j]\\n\\n            while len(pq) > 0 and pq[0][0] <= interval[0]:\\n                end, room = heapq.heappop(pq)\\n                heapq.heappush(vacant, room)\\n            \\n            if vacant: #there are vacant rooms\\n                room = heapq.heappop(vacant)\\n                heapq.heappush(pq, (interval[1], room))\\n            else: #no rooms avail\\n                end, room = heapq.heappop(pq)\\n                newend = (end - interval[0]) + interval[1]\\n                heapq.heappush(pq, (newend, room))\\n\\n            rooms[room] += 1\\n                    \\n        maxroom = -10000000\\n        bestroom = 0\\n        for i in range(0, n):\\n            if rooms[i] > maxroom:\\n                bestroom = i\\n                maxroom = rooms[i]\\n\\n        return bestroom\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution(object):\\n    def mostBooked(self, n, meetings):\\n        \"\"\"\\n        :type n: int\\n        :type meetings: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        meetings.sort(key=lambda x:x[0])\\n        pq = [] # (the end time, room no) -> heap structure\\n        rooms = {} #{room no : num times used}\\n        vacant = [] # [rooms]\\n\\n        for i in range(0, n):\\n            rooms[i] = 0\\n            heapq.heappush(vacant, i)\\n\\n        for j in range(len(meetings)):\\n            interval = meetings[j]\\n\\n            while len(pq) > 0 and pq[0][0] <= interval[0]:\\n                end, room = heapq.heappop(pq)\\n                heapq.heappush(vacant, room)\\n            \\n            if vacant: #there are vacant rooms\\n                room = heapq.heappop(vacant)\\n                heapq.heappush(pq, (interval[1], room))\\n            else: #no rooms avail\\n                end, room = heapq.heappop(pq)\\n                newend = (end - interval[0]) + interval[1]\\n                heapq.heappush(pq, (newend, room))\\n\\n            rooms[room] += 1\\n                    \\n        maxroom = -10000000\\n        bestroom = 0\\n        for i in range(0, n):\\n            if rooms[i] > maxroom:\\n                bestroom = i\\n                maxroom = rooms[i]\\n\\n        return bestroom\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530194,
                "title": "3-priority-queues-with-clear-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo basically we brute-forcely simulated the process.\\n\\n1st Priority Queue: There are a list of rooms that are empty. Each time when we need to host a meeting, we take the smallest-indexed-room.\\n2nd Priority Queue: We host meetings one by one according to their start time. In other words, meetings with smaller time are hosted first.\\n3rd Priority Queue: This is a list of rooms currently occupied by a meeting. It is sorted by their end time. In other words, the room with earliest end time will be empty first.\\n\\nSo during simulation, we first check if there are rooms about to finish. If so, we add these rooms back to the 1st pq (these rooms are available again). Secondly, we check if there are empty rooms. If there are empty rooms, we just host the next meeting. If NOT, we need to wait until the next occupied room is empty.\\n\\nThere are several edge cases worth noticing. (1) before poping from each queue, we need to check if the queue is empty. (2) before hosting next meeting, we need to check if there are meetings that ends. (3) There might be MULTIPLE meetings end at the same time, we want to add ALL of them to the pq. (4) Delayed time calculation. Notice that when a meeting is delayed, meetings after this might also be delayed. So adjust the start time and end time accordingly.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        empty_room = []\\n        room_meetings = []\\n        for i in range(n):\\n            heapq.heappush(empty_room, i)\\n            room_meetings.append(0)\\n        remaining_meeting = []\\n        for i in range(len(meetings)):\\n            heapq.heappush(remaining_meeting, (meetings[i][0], meetings[i][1]))\\n        room_in_used = []\\n\\n        current_time = 0\\n        while len(remaining_meeting) > 0:\\n            next_meeting_start, next_meeting_end = heapq.heappop(remaining_meeting)\\n            current_time = max(current_time, next_meeting_start)\\n            # firstly, check if there is any room that finishes up before current meeting begins\\n            while len(room_in_used) > 0:\\n                end, start, room = heapq.heappop(room_in_used)\\n                if current_time >= end:\\n                    #  meeting is finished, this room is currently finished\\n                    room_meetings[room] += 1\\n                    heapq.heappush(empty_room, room)\\n                else:\\n                    # meeting haven\\'t finished, put it back to the queue\\n                    heapq.heappush(room_in_used, (end, start, room))\\n                    break\\n            # secondly, arrange next meeting to the smallest index meeting room\\n            delayed_time = current_time\\n            if len(empty_room) == 0:\\n                # if all rooms are occupied, we need to delay\\n                # wait until next room is available\\n                next_empty_room, _, room = heapq.heappop(room_in_used)\\n                delayed_time = next_empty_room\\n                all_rooms = [room]\\n                room_meetings[room] += 1\\n                while len(room_in_used) > 0:\\n                    e, s, r = heapq.heappop(room_in_used)\\n                    if e == next_empty_room:\\n                        all_rooms.append(r)\\n                        room_meetings[r] += 1\\n                    else:\\n                        heapq.heappush(room_in_used, (e, s, r))\\n                        break\\n                for r in all_rooms:\\n                    heapq.heappush(empty_room, r)\\n            # after this, there are available rooms. we set up the meeting\\n            current_time = max(current_time, delayed_time)\\n            room = heapq.heappop(empty_room)\\n            duration = next_meeting_end - next_meeting_start\\n            heapq.heappush(room_in_used, (current_time+duration, delayed_time, room))\\n\\n        # finishes up all meetings in-flights\\n        while len(room_in_used) > 0:\\n            e, s, r = heapq.heappop(room_in_used)\\n            room_meetings[r] += 1\\n        \\n        # ans, the most used rooms\\n        return room_meetings.index(max(room_meetings))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        empty_room = []\\n        room_meetings = []\\n        for i in range(n):\\n            heapq.heappush(empty_room, i)\\n            room_meetings.append(0)\\n        remaining_meeting = []\\n        for i in range(len(meetings)):\\n            heapq.heappush(remaining_meeting, (meetings[i][0], meetings[i][1]))\\n        room_in_used = []\\n\\n        current_time = 0\\n        while len(remaining_meeting) > 0:\\n            next_meeting_start, next_meeting_end = heapq.heappop(remaining_meeting)\\n            current_time = max(current_time, next_meeting_start)\\n            # firstly, check if there is any room that finishes up before current meeting begins\\n            while len(room_in_used) > 0:\\n                end, start, room = heapq.heappop(room_in_used)\\n                if current_time >= end:\\n                    #  meeting is finished, this room is currently finished\\n                    room_meetings[room] += 1\\n                    heapq.heappush(empty_room, room)\\n                else:\\n                    # meeting haven\\'t finished, put it back to the queue\\n                    heapq.heappush(room_in_used, (end, start, room))\\n                    break\\n            # secondly, arrange next meeting to the smallest index meeting room\\n            delayed_time = current_time\\n            if len(empty_room) == 0:\\n                # if all rooms are occupied, we need to delay\\n                # wait until next room is available\\n                next_empty_room, _, room = heapq.heappop(room_in_used)\\n                delayed_time = next_empty_room\\n                all_rooms = [room]\\n                room_meetings[room] += 1\\n                while len(room_in_used) > 0:\\n                    e, s, r = heapq.heappop(room_in_used)\\n                    if e == next_empty_room:\\n                        all_rooms.append(r)\\n                        room_meetings[r] += 1\\n                    else:\\n                        heapq.heappush(room_in_used, (e, s, r))\\n                        break\\n                for r in all_rooms:\\n                    heapq.heappush(empty_room, r)\\n            # after this, there are available rooms. we set up the meeting\\n            current_time = max(current_time, delayed_time)\\n            room = heapq.heappop(empty_room)\\n            duration = next_meeting_end - next_meeting_start\\n            heapq.heappush(room_in_used, (current_time+duration, delayed_time, room))\\n\\n        # finishes up all meetings in-flights\\n        while len(room_in_used) > 0:\\n            e, s, r = heapq.heappop(room_in_used)\\n            room_meetings[r] += 1\\n        \\n        # ans, the most used rooms\\n        return room_meetings.index(max(room_meetings))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519889,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meets) {\\n    int cnt[101] = {};\\n    sort(begin(meets), end(meets));\\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n    for (int i = 0; i < n; ++i)\\n        pq.push({meets[0][0], i});\\n    for (auto &m : meets) {\\n        while (pq.top().first < m[0]) {\\n            pq.push({m[0], pq.top().second});\\n            pq.pop();\\n        }\\n        auto [start, room] = pq.top(); pq.pop();\\n        pq.push({start + m[1] - m[0], room});\\n        ++cnt[room];\\n    }\\n    return max_element(begin(cnt), end(cnt)) - begin(cnt);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meets) {\\n    int cnt[101] = {};\\n    sort(begin(meets), end(meets));\\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n    for (int i = 0; i < n; ++i)\\n        pq.push({meets[0][0], i});\\n    for (auto &m : meets) {\\n        while (pq.top().first < m[0]) {\\n            pq.push({m[0], pq.top().second});\\n            pq.pop();\\n        }\\n        auto [start, room] = pq.top(); pq.pop();\\n        pq.push({start + m[1] - m[0], room});\\n        ++cnt[room];\\n    }\\n    return max_element(begin(cnt), end(cnt)) - begin(cnt);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517523,
                "title": "python-heap-solution-for-m-meetings-n-rooms-o-m-space-for-m-meetings-o-mlogm-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        import heapq\\n        from collections import defaultdict\\n\\n        meetingheap = [(start, end) for start, end in meetings]\\n        heapq.heapify(meetingheap) # will let us pop the meeting with the lowest start time\\n        roomfreq = defaultdict(lambda: 0)\\n   \\n        usedroomsheap = []\\n        maxroom, maxroomfreq = 0, 1 #base case, there will be at least one meeting and it will be in room 0\\n        \\n        leftoverrooms = [i for i in range(n)]\\n        heapq.heapify(leftoverrooms)\\n\\n        while meetingheap:\\n            start, end = heapq.heappop(meetingheap)\\n            lastend = 0\\n            while usedroomsheap and usedroomsheap[0][0] <= start:\\n                    lastend, nextroom = heapq.heappop(usedroomsheap)\\n                    heapq.heappush(leftoverrooms, nextroom)\\n            \\n            roomnum = heapq.heappop(leftoverrooms) if leftoverrooms else n\\n            \\n            if len(usedroomsheap) < n:\\n                heapq.heappush(usedroomsheap, (end, roomnum))\\n            else:\\n                lastend, roomnum = heapq.heappop(usedroomsheap)\\n                if start < lastend:\\n                    end += lastend-start\\n\\n                heapq.heappush(usedroomsheap, (end, roomnum))\\n\\n            roomfreq[roomnum] += 1\\n               \\n            if roomfreq[roomnum] > maxroomfreq:\\n                maxroom = roomnum\\n                maxroomfreq = roomfreq[roomnum]\\n            elif roomfreq[roomnum] == maxroomfreq:\\n                maxroom = min(maxroom, roomnum)\\n        return maxroom\\n\\n                \\n                \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        import heapq\\n        from collections import defaultdict\\n\\n        meetingheap = [(start, end) for start, end in meetings]\\n        heapq.heapify(meetingheap) # will let us pop the meeting with the lowest start time\\n        roomfreq = defaultdict(lambda: 0)\\n   \\n        usedroomsheap = []\\n        maxroom, maxroomfreq = 0, 1 #base case, there will be at least one meeting and it will be in room 0\\n        \\n        leftoverrooms = [i for i in range(n)]\\n        heapq.heapify(leftoverrooms)\\n\\n        while meetingheap:\\n            start, end = heapq.heappop(meetingheap)\\n            lastend = 0\\n            while usedroomsheap and usedroomsheap[0][0] <= start:\\n                    lastend, nextroom = heapq.heappop(usedroomsheap)\\n                    heapq.heappush(leftoverrooms, nextroom)\\n            \\n            roomnum = heapq.heappop(leftoverrooms) if leftoverrooms else n\\n            \\n            if len(usedroomsheap) < n:\\n                heapq.heappush(usedroomsheap, (end, roomnum))\\n            else:\\n                lastend, roomnum = heapq.heappop(usedroomsheap)\\n                if start < lastend:\\n                    end += lastend-start\\n\\n                heapq.heappush(usedroomsheap, (end, roomnum))\\n\\n            roomfreq[roomnum] += 1\\n               \\n            if roomfreq[roomnum] > maxroomfreq:\\n                maxroom = roomnum\\n                maxroomfreq = roomfreq[roomnum]\\n            elif roomfreq[roomnum] == maxroomfreq:\\n                maxroom = min(maxroom, roomnum)\\n        return maxroom\\n\\n                \\n                \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515339,
                "title": "priority-queue-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    class Meeting implements Comparable<Meeting> {\\n        int endTime;\\n        int roomNumber;\\n\\n        public Meeting(int endTime, int roomNumber) {\\n            this.endTime = endTime;\\n            this.roomNumber = roomNumber;\\n        }\\n\\n        @Override\\n        public int compareTo(Meeting other) {\\n            if (this.endTime == other.endTime) {\\n                return this.roomNumber - other.roomNumber;\\n            } else {\\n                return this.endTime - other.endTime;\\n            }\\n        }\\n    }\\n\\n\\n\\n    public int mostBooked(int n, int[][] meetings) {\\n\\n        // sort rooms by start time\\n        Arrays.sort(meetings,\\n                (m1, m2) -> m1[0] - m2[0]\\n        );\\n\\n        // key: [endTime, roomNumber]\\n        // Sort by end time if same end time - sort by lowest room number\\n        PriorityQueue<Meeting> scheduler = new PriorityQueue<>();\\n        PriorityQueue<Integer> availableRooms = IntStream.range(0, n)\\n                .boxed()\\n                .collect(Collectors.toCollection(PriorityQueue::new));\\n\\n        int[] roomUsageCount = new int[n];\\n        for (int[] meeting : meetings) {\\n            int currentMeetingStart = meeting[0];\\n\\n            // remove ended meetings\\n            while (!scheduler.isEmpty() && currentMeetingStart >= scheduler.peek().endTime) {\\n                // add freed room to availability\\n                availableRooms.add(scheduler.poll().roomNumber);\\n            }\\n\\n            int delay = 0;\\n            if (availableRooms.isEmpty()) { // if all rooms are full\\n                Meeting endedMeeting = scheduler.poll();\\n                // add delay\\n                delay = endedMeeting.endTime - currentMeetingStart;\\n                // add free rooms back to availableRooms\\n                availableRooms.add(endedMeeting.roomNumber);\\n            }\\n\\n            int currentMeetingEndTime = meeting[1] + delay;\\n            int availableRoom = availableRooms.poll();\\n            // find out the room with the lowest priority\\n            scheduler.add(new Meeting(currentMeetingEndTime, availableRoom));\\n            roomUsageCount[availableRoom]++;\\n        }\\n\\n        // Let\\'s find out the most used room\\n        int maxUsedRoom = 0;\\n        int maxUseCount = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (roomUsageCount[i] > maxUseCount) {\\n                maxUseCount = roomUsageCount[i];\\n                maxUsedRoom = i;\\n            }\\n        }\\n        return maxUsedRoom;\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    class Meeting implements Comparable<Meeting> {\\n        int endTime;\\n        int roomNumber;\\n\\n        public Meeting(int endTime, int roomNumber) {\\n            this.endTime = endTime;\\n            this.roomNumber = roomNumber;\\n        }\\n\\n        @Override\\n        public int compareTo(Meeting other) {\\n            if (this.endTime == other.endTime) {\\n                return this.roomNumber - other.roomNumber;\\n            } else {\\n                return this.endTime - other.endTime;\\n            }\\n        }\\n    }\\n\\n\\n\\n    public int mostBooked(int n, int[][] meetings) {\\n\\n        // sort rooms by start time\\n        Arrays.sort(meetings,\\n                (m1, m2) -> m1[0] - m2[0]\\n        );\\n\\n        // key: [endTime, roomNumber]\\n        // Sort by end time if same end time - sort by lowest room number\\n        PriorityQueue<Meeting> scheduler = new PriorityQueue<>();\\n        PriorityQueue<Integer> availableRooms = IntStream.range(0, n)\\n                .boxed()\\n                .collect(Collectors.toCollection(PriorityQueue::new));\\n\\n        int[] roomUsageCount = new int[n];\\n        for (int[] meeting : meetings) {\\n            int currentMeetingStart = meeting[0];\\n\\n            // remove ended meetings\\n            while (!scheduler.isEmpty() && currentMeetingStart >= scheduler.peek().endTime) {\\n                // add freed room to availability\\n                availableRooms.add(scheduler.poll().roomNumber);\\n            }\\n\\n            int delay = 0;\\n            if (availableRooms.isEmpty()) { // if all rooms are full\\n                Meeting endedMeeting = scheduler.poll();\\n                // add delay\\n                delay = endedMeeting.endTime - currentMeetingStart;\\n                // add free rooms back to availableRooms\\n                availableRooms.add(endedMeeting.roomNumber);\\n            }\\n\\n            int currentMeetingEndTime = meeting[1] + delay;\\n            int availableRoom = availableRooms.poll();\\n            // find out the room with the lowest priority\\n            scheduler.add(new Meeting(currentMeetingEndTime, availableRoom));\\n            roomUsageCount[availableRoom]++;\\n        }\\n\\n        // Let\\'s find out the most used room\\n        int maxUsedRoom = 0;\\n        int maxUseCount = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (roomUsageCount[i] > maxUseCount) {\\n                maxUseCount = roomUsageCount[i];\\n                maxUsedRoom = i;\\n            }\\n        }\\n        return maxUsedRoom;\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493922,
                "title": "c-code-with-comments-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        \\n        // stores the number of meetings hosted at each room\\n        vector<int>meetingcount(n);\\n        \\n        // count of the meetings\\n        int m = meetings.size();\\n\\n        // Structure to store the time when the room will get free\\n        // {EndTime,roomNo}\\n        set<pair<ll,ll>>st;\\n\\n        // Structure to store all the available rooms\\n        set<int>available;\\n\\n        // In the start all the rooms are available so adding them to available set\\n        for(int i=0;i<n;i++){\\n            available.insert(i);\\n        }\\n        \\n        // Sort the meetings by start Time \\n        sort(meetings.begin(),meetings.end(),[&](vector<int>&v1,vector<int>&v2){\\n            return v1[0]<v2[0];\\n        });\\n\\n        for(int i=0;i<m;i++){\\n            // startTime of the meeting\\n            ll start_time = meetings[i][0];\\n\\n            // Free occupied rooms before the startTime time\\n            while(st.size()>0 && (*(st.begin())).first < start_time ){\\n                available.insert((*(st.begin())).second); \\n                st.erase(st.begin());           \\n            }\\n\\n            // If any rooms are available, allocate the room with smallest room No\\n            if(available.size()>0){\\n                ll endTime = start_time + (meetings[i][1]-meetings[i][0]-1)*1LL;\\n                int roomNo = *(available.begin());\\n                st.insert({endTime,roomNo});\\n                meetingcount[roomNo]++;\\n                available.erase(available.begin());\\n            }\\n            else\\n            {\\n                // Get the room which will free early and allocate that room \\n                ll endTime = (*(st.begin())).first + (meetings[i][1]-meetings[i][0])*1LL;\\n                int roomNo = (*(st.begin())).second;\\n                st.erase(st.begin());\\n                meetingcount[roomNo]++;\\n                st.insert({endTime,roomNo});\\n            }\\n        }\\n        int max_meeting = -1, room = -1;\\n        // Calculate which room hosted maximum number of meetings\\n        for(int i=0;i<n;i++){\\n            if(meetingcount[i]>max_meeting){\\n                max_meeting = meetingcount[i];\\n                room = i;\\n            }\\n        }\\n        return room;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        \\n        // stores the number of meetings hosted at each room\\n        vector<int>meetingcount(n);\\n        \\n        // count of the meetings\\n        int m = meetings.size();\\n\\n        // Structure to store the time when the room will get free\\n        // {EndTime,roomNo}\\n        set<pair<ll,ll>>st;\\n\\n        // Structure to store all the available rooms\\n        set<int>available;\\n\\n        // In the start all the rooms are available so adding them to available set\\n        for(int i=0;i<n;i++){\\n            available.insert(i);\\n        }\\n        \\n        // Sort the meetings by start Time \\n        sort(meetings.begin(),meetings.end(),[&](vector<int>&v1,vector<int>&v2){\\n            return v1[0]<v2[0];\\n        });\\n\\n        for(int i=0;i<m;i++){\\n            // startTime of the meeting\\n            ll start_time = meetings[i][0];\\n\\n            // Free occupied rooms before the startTime time\\n            while(st.size()>0 && (*(st.begin())).first < start_time ){\\n                available.insert((*(st.begin())).second); \\n                st.erase(st.begin());           \\n            }\\n\\n            // If any rooms are available, allocate the room with smallest room No\\n            if(available.size()>0){\\n                ll endTime = start_time + (meetings[i][1]-meetings[i][0]-1)*1LL;\\n                int roomNo = *(available.begin());\\n                st.insert({endTime,roomNo});\\n                meetingcount[roomNo]++;\\n                available.erase(available.begin());\\n            }\\n            else\\n            {\\n                // Get the room which will free early and allocate that room \\n                ll endTime = (*(st.begin())).first + (meetings[i][1]-meetings[i][0])*1LL;\\n                int roomNo = (*(st.begin())).second;\\n                st.erase(st.begin());\\n                meetingcount[roomNo]++;\\n                st.insert({endTime,roomNo});\\n            }\\n        }\\n        int max_meeting = -1, room = -1;\\n        // Calculate which room hosted maximum number of meetings\\n        for(int i=0;i<n;i++){\\n            if(meetingcount[i]>max_meeting){\\n                max_meeting = meetingcount[i];\\n                room = i;\\n            }\\n        }\\n        return room;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480333,
                "title": "optimal-and-simple-python-solution-with-complexity-o-m-log-max-m-n",
                "content": "# Intuition\\nUse two minheaps: \\n1. One to keey track of the available rooms (`free_rooms`)\\n2. Another to keep track of the end_time of the meetings in progress along with the room ids (`meeting_ends`)\\n\\nWhen evaluating every meeting first ensure that the meetings that ended before the start of the new meeting are removed from the `meeting_ends` heap. \\nIf any rooms are available, remove the room from `free_room` and add the (meeting end time, room id) to the `meeting_ends` heap. \\nIf no rooms are available, then pop the `meeting_ends` heap to get the room_id that is becoming available first, update the end time of the delayed meeting before adding it to the `meeting_ends`.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- m: number of meetings\\n- n: number of rooms\\n- Time complexity: \\n    - Sort: O(m*log(m))\\n    - Heap operations: (m*log(n))\\n    - Total time complexity: O(m*log(max(m,n)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    - O(n)   \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:        \\n        meeting_ends = []\\n        heapq.heapify(meeting_ends)\\n\\n        free_rooms = list(range(n))\\n        heapq.heapify(free_rooms)\\n        \\n        room_meeting_counts = [0 for _ in range(n)]\\n\\n        meetings.sort()\\n\\n        for ind in range(len(meetings)):\\n            meeting = meetings[ind]\\n            start_time = meeting[0]\\n            end_time = meeting[1]\\n\\n            while meeting_ends and meeting_ends[0][0] <= start_time:\\n                _, room_ind = heapq.heappop(meeting_ends)\\n                heapq.heappush(free_rooms, room_ind)\\n                room_meeting_counts[room_ind] += 1\\n\\n            if len(free_rooms) > 0:\\n                room_ind = heapq.heappop(free_rooms)\\n                heapq.heappush(meeting_ends, (end_time, room_ind))\\n            else:\\n                new_start_time, room_ind = heapq.heappop(meeting_ends)\\n                room_meeting_counts[room_ind]+= 1\\n                new_end_time = new_start_time + end_time - start_time\\n                heapq.heappush(meeting_ends, (new_end_time, room_ind))\\n\\n\\n        while meeting_ends:\\n            _, room_ind = heapq.heappop(meeting_ends)\\n            heapq.heappush(free_rooms, room_ind)\\n            room_meeting_counts[room_ind] += 1\\n            \\n        return room_meeting_counts.index(max(room_meeting_counts))\\n\\n\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:        \\n        meeting_ends = []\\n        heapq.heapify(meeting_ends)\\n\\n        free_rooms = list(range(n))\\n        heapq.heapify(free_rooms)\\n        \\n        room_meeting_counts = [0 for _ in range(n)]\\n\\n        meetings.sort()\\n\\n        for ind in range(len(meetings)):\\n            meeting = meetings[ind]\\n            start_time = meeting[0]\\n            end_time = meeting[1]\\n\\n            while meeting_ends and meeting_ends[0][0] <= start_time:\\n                _, room_ind = heapq.heappop(meeting_ends)\\n                heapq.heappush(free_rooms, room_ind)\\n                room_meeting_counts[room_ind] += 1\\n\\n            if len(free_rooms) > 0:\\n                room_ind = heapq.heappop(free_rooms)\\n                heapq.heappush(meeting_ends, (end_time, room_ind))\\n            else:\\n                new_start_time, room_ind = heapq.heappop(meeting_ends)\\n                room_meeting_counts[room_ind]+= 1\\n                new_end_time = new_start_time + end_time - start_time\\n                heapq.heappush(meeting_ends, (new_end_time, room_ind))\\n\\n\\n        while meeting_ends:\\n            _, room_ind = heapq.heappop(meeting_ends)\\n            heapq.heappush(free_rooms, room_ind)\\n            room_meeting_counts[room_ind] += 1\\n            \\n        return room_meeting_counts.index(max(room_meeting_counts))\\n\\n\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477294,
                "title": "bruet-force-solution-without-heap-or-priority-queue",
                "content": "# Complexity\\n- Time complexity:(N*200)\\n\\n- Space complexity:O(N)\\n\\n# Code\\n```\\n\\nclass comp {\\n    public:\\n    bool operator()(const pair<long long, long long>& p1,\\n                    const pair<long long, long long>& p2)\\n    {  \\n        if (p1.first < p2.first)return 0;\\n        else if(p1.first > p2.first)return 1;\\n        else{\\n            return p1.second > p2.second;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        sort(meetings.begin(),meetings.end());\\n        vector<long long>vis(n,0);\\n        vector<int>cnt(n,0);\\n        long long maxv=0;\\n        int maxi=0;\\n        for(int i=0;i<meetings.size();i++){\\n            long long miniv=vis[0];\\n            int minij=0;\\n            int flag=1;\\n            for(int j=0;j<n;j++){\\n                if(vis[j]<=meetings[i][0]){\\n                    cnt[j]++;\\n                    vis[j]=meetings[i][1];\\n                    if(cnt[j]==maxv){\\n                        maxi=min(maxi,j);\\n                    }\\n                    else if(cnt[j]>maxv){\\n                        maxv=cnt[j];\\n                        maxi=j;\\n                    }\\n                    flag=0;\\n                    break;\\n                }\\n                else{\\n                    if(vis[j]<miniv){minij=j;miniv=vis[j];}\\n                }\\n            }\\n            if(flag){\\n                cnt[minij]++;\\n                vis[minij]+=(meetings[i][1]-meetings[i][0]);\\n                if(cnt[minij]==maxv){\\n                    maxi=min(maxi,minij);\\n                }\\n                else if(cnt[minij]>maxv){\\n                    maxv=cnt[minij];\\n                    maxi=minij;\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\n\\nclass comp {\\n    public:\\n    bool operator()(const pair<long long, long long>& p1,\\n                    const pair<long long, long long>& p2)\\n    {  \\n        if (p1.first < p2.first)return 0;\\n        else if(p1.first > p2.first)return 1;\\n        else{\\n            return p1.second > p2.second;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        sort(meetings.begin(),meetings.end());\\n        vector<long long>vis(n,0);\\n        vector<int>cnt(n,0);\\n        long long maxv=0;\\n        int maxi=0;\\n        for(int i=0;i<meetings.size();i++){\\n            long long miniv=vis[0];\\n            int minij=0;\\n            int flag=1;\\n            for(int j=0;j<n;j++){\\n                if(vis[j]<=meetings[i][0]){\\n                    cnt[j]++;\\n                    vis[j]=meetings[i][1];\\n                    if(cnt[j]==maxv){\\n                        maxi=min(maxi,j);\\n                    }\\n                    else if(cnt[j]>maxv){\\n                        maxv=cnt[j];\\n                        maxi=j;\\n                    }\\n                    flag=0;\\n                    break;\\n                }\\n                else{\\n                    if(vis[j]<miniv){minij=j;miniv=vis[j];}\\n                }\\n            }\\n            if(flag){\\n                cnt[minij]++;\\n                vis[minij]+=(meetings[i][1]-meetings[i][0]);\\n                if(cnt[minij]==maxv){\\n                    maxi=min(maxi,minij);\\n                }\\n                else if(cnt[minij]>maxv){\\n                    maxv=cnt[minij];\\n                    maxi=minij;\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474458,
                "title": "python-heap-solution",
                "content": "# Intuition\\nThis is the problem I encountered, it is not difficult but I did not write it out.\\n\\n# Complexity\\nk would be the number of the meetings\\n- Time complexity:O(klog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        c = Counter()\\n        maxFreq = 0\\n        ans = n\\n        rooms = [i for i in range(n)]\\n        heapq.heapify(rooms)\\n        using = [] # heapq([[end_time, room_i], ....])\\n\\n        for start, end in meetings:\\n            while using and using[0][0] <= start:\\n                _, i = heapq.heappop(using)\\n                heapq.heappush(rooms, i)\\n\\n            if rooms:\\n                i = heapq.heappop(rooms)\\n                heapq.heappush(using, [end, i])\\n            else:\\n                e, i = heapq.heappop(using)\\n                heapq.heappush(using, [end + e - start, i])\\n            c[i] += 1\\n            if c[i] > maxFreq:\\n                maxFreq = c[i]\\n                ans = i\\n            elif c[i] == maxFreq:\\n                ans = min(ans, i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        c = Counter()\\n        maxFreq = 0\\n        ans = n\\n        rooms = [i for i in range(n)]\\n        heapq.heapify(rooms)\\n        using = [] # heapq([[end_time, room_i], ....])\\n\\n        for start, end in meetings:\\n            while using and using[0][0] <= start:\\n                _, i = heapq.heappop(using)\\n                heapq.heappush(rooms, i)\\n\\n            if rooms:\\n                i = heapq.heappop(rooms)\\n                heapq.heappush(using, [end, i])\\n            else:\\n                e, i = heapq.heappop(using)\\n                heapq.heappush(using, [end + e - start, i])\\n            c[i] += 1\\n            if c[i] > maxFreq:\\n                maxFreq = c[i]\\n                ans = i\\n            elif c[i] == maxFreq:\\n                ans = min(ans, i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471417,
                "title": "java-detailed-explanation-two-heaps-easy-to-understand-solution-o-nlogn",
                "content": "# Intuition\\nFor every meeting, if there\\'re unused rooms, use the one with the smallest room number. If there\\'s no free room, choose the one with the earliest ending time.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse one min-heap for keeping track of the free rooms, since we need to choose the free room with the smallest number. Use another min-heap for the used rooms, store the end time and the room number in an array. Sort this heap based on the end time, if the end time of the rooms is the same, sort based on the room number. For simplicity, we can use **lambda comparator** here. Also use an array to track the number of times each room is used.\\n\\nSort the meetings array based on start time, then iterate through the sorted array. Check first if there\\'re any used rooms now become free in the moment of the current meeting begins. Then if there\\'s any free rooms, we can allocate the one with the smallest number. Otherwise, choose the used room with the earliest end time and also check if the meeting will be delayed.\\n\\nFinally iterate the room count array, return the room with the most used times.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please upvote if you find it useful! Thanks!\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        int[] roomCounts = new int[n];\\n        PriorityQueue<Integer> freeRooms = new PriorityQueue<>();\\n        PriorityQueue<int[]> usedRooms = new PriorityQueue<>((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]); // end time + room number\\n\\n        for (int i = 0; i < n; i++) {\\n            freeRooms.offer(i);\\n        }\\n\\n        Arrays.sort(meetings, (a, b) -> a[0] - b[0]);\\n\\n        for (int[] meeting: meetings) {\\n            // !! check if there\\'re newly freed rooms\\n            while (!usedRooms.isEmpty() && usedRooms.peek()[0] <= meeting[0]) {\\n                freeRooms.offer(usedRooms.poll()[1]);\\n            }\\n            if (!freeRooms.isEmpty()) {\\n                int room = freeRooms.poll();\\n                usedRooms.offer(new int[]{meeting[1], room});\\n                roomCounts[room]++;\\n            } else {\\n                int[] pair = usedRooms.poll();\\n                int ending = pair[0], room = pair[1];\\n                if (ending <= meeting[0]) {\\n                    usedRooms.offer(new int[]{meeting[1], room});\\n                } else {\\n                    int newEnding = ending - meeting[0] + meeting[1];\\n                    usedRooms.offer(new int[]{newEnding, room});\\n                }\\n                roomCounts[room]++;\\n            }\\n        }\\n\\n        int maxCount = 0, res = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (roomCounts[i] > maxCount) {\\n                maxCount = roomCounts[i];\\n                res = i;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        int[] roomCounts = new int[n];\\n        PriorityQueue<Integer> freeRooms = new PriorityQueue<>();\\n        PriorityQueue<int[]> usedRooms = new PriorityQueue<>((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]); // end time + room number\\n\\n        for (int i = 0; i < n; i++) {\\n            freeRooms.offer(i);\\n        }\\n\\n        Arrays.sort(meetings, (a, b) -> a[0] - b[0]);\\n\\n        for (int[] meeting: meetings) {\\n            // !! check if there\\'re newly freed rooms\\n            while (!usedRooms.isEmpty() && usedRooms.peek()[0] <= meeting[0]) {\\n                freeRooms.offer(usedRooms.poll()[1]);\\n            }\\n            if (!freeRooms.isEmpty()) {\\n                int room = freeRooms.poll();\\n                usedRooms.offer(new int[]{meeting[1], room});\\n                roomCounts[room]++;\\n            } else {\\n                int[] pair = usedRooms.poll();\\n                int ending = pair[0], room = pair[1];\\n                if (ending <= meeting[0]) {\\n                    usedRooms.offer(new int[]{meeting[1], room});\\n                } else {\\n                    int newEnding = ending - meeting[0] + meeting[1];\\n                    usedRooms.offer(new int[]{newEnding, room});\\n                }\\n                roomCounts[room]++;\\n            }\\n        }\\n\\n        int maxCount = 0, res = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (roomCounts[i] > maxCount) {\\n                maxCount = roomCounts[i];\\n                res = i;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462567,
                "title": "golang-k-n-klogk",
                "content": "## *Solution : without heap, since N is small enough*\\n\\n\\n```\\npackage main\\n\\nimport (\\n\\t\"math\"\\n\\t\"sort\"\\n)\\n\\nfunc mostBooked(n int, meetings [][]int) int {\\n\\tsort.Slice(meetings, func(i, j int) bool {\\n\\t\\treturn meetings[i][0] < meetings[j][0]\\n\\t})\\n\\n\\t// rooms[0] - endTime\\n\\t// rooms[1] - meetingCounts\\n\\trooms := make([][2]int, n+1)\\n\\trooms[n][0] = math.MaxInt\\n\\tresult := 0\\n\\n\\tfor _, meeting := range meetings {\\n\\t\\tstart := meeting[0]\\n\\t\\tend := meeting[1]\\n\\n\\t\\tminIndex := n\\n\\t\\tflag := true\\n\\n\\t\\tfor i := 0; i < n; i++ {\\n\\t\\t\\tif rooms[i][0] <= start {\\n                // Assigning meeting to the first vacant room\\n\\t\\t\\t\\trooms[i][0] = end\\n\\t\\t\\t\\trooms[i][1]++\\n\\t\\t\\t\\tflag = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tif rooms[i][0] < rooms[minIndex][0] {\\n\\t\\t\\t\\tminIndex = i\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif flag {\\n            // Time travel to the occupied room with least end time.\\n\\t\\t\\trooms[minIndex][0] = end + (rooms[minIndex][0] - start)\\n\\t\\t\\trooms[minIndex][1]++\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif rooms[i][1] > rooms[result][1] {\\n\\t\\t\\tresult = i\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nimport (\\n\\t\"math\"\\n\\t\"sort\"\\n)\\n\\nfunc mostBooked(n int, meetings [][]int) int {\\n\\tsort.Slice(meetings, func(i, j int) bool {\\n\\t\\treturn meetings[i][0] < meetings[j][0]\\n\\t})\\n\\n\\t// rooms[0] - endTime\\n\\t// rooms[1] - meetingCounts\\n\\trooms := make([][2]int, n+1)\\n\\trooms[n][0] = math.MaxInt\\n\\tresult := 0\\n\\n\\tfor _, meeting := range meetings {\\n\\t\\tstart := meeting[0]\\n\\t\\tend := meeting[1]\\n\\n\\t\\tminIndex := n\\n\\t\\tflag := true\\n\\n\\t\\tfor i := 0; i < n; i++ {\\n\\t\\t\\tif rooms[i][0] <= start {\\n                // Assigning meeting to the first vacant room\\n\\t\\t\\t\\trooms[i][0] = end\\n\\t\\t\\t\\trooms[i][1]++\\n\\t\\t\\t\\tflag = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tif rooms[i][0] < rooms[minIndex][0] {\\n\\t\\t\\t\\tminIndex = i\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif flag {\\n            // Time travel to the occupied room with least end time.\\n\\t\\t\\trooms[minIndex][0] = end + (rooms[minIndex][0] - start)\\n\\t\\t\\trooms[minIndex][1]++\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif rooms[i][1] > rooms[result][1] {\\n\\t\\t\\tresult = i\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3452852,
                "title": "javascript-two-heap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} meetings\\n * @return {number}\\n */\\n const Heap = function(n, empty, compare) {\\n    this.data = Array(n).fill(empty);\\n    this.end = 0;\\n    this.empty = empty;\\n    this.compare = compare;\\n}\\n\\nHeap.prototype.insert = function(val) {\\n    const end = this.end;\\n    const compare = this.compare;\\n    this.data[end] = val;\\n    if (end != 0) {\\n        let i = end;\\n        while(i > 0 && !compare(this.data[Math.floor((i-1)/2)], this.data[i])) {\\n            let j = Math.floor((i-1)/2);\\n            [this.data[j], this.data[i]] = [this.data[i], this.data[j]];\\n            i = j;\\n        }\\n    }\\n    this.end++;\\n}\\nHeap.prototype.poll = function() {\\n    const compare = this.compare;\\n    let end = this.end;\\n    if(end == 0) {\\n        return null;\\n    } else {\\n        end--;\\n        var output = this.data[0];\\n        if (end >= 0) {\\n            this.data[0] = this.data[end];\\n            let i = 0;\\n            let j = 2*i + 1;\\n            let k = 2*i + 2;\\n            while(!compare(this.data[i], this.data[j]) || !compare(this.data[i], this.data[k])) {\\n                let l = compare(this.data[j], this.data[k])? j : k;\\n                [this.data[i], this.data[l], i, j, k] = [this.data[l], this.data[i], l, 2*l + 1, 2*l + 2];\\n            }            \\n        }\\n    }\\n    this.end--;\\n    this.data[end] = this.empty;    \\n    return output;\\n}\\nvar mostBooked = function(n, meetings) {\\n    const compare = function(rm1, rm2) {\\n        return rm1[1] != rm2[1]? rm1[1] < rm2[1] : rm1[0] < rm2[0];\\n    }    \\n    const inUseQueue = new Heap(2*n+1, [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], compare);\\n    const vacantQueue = new Heap(2*n + 1, Number.POSITIVE_INFINITY, function(a,b) {\\n        return a < b;\\n    })\\n    let next = false;\\n    let rm\\n    const use = function(end) {\\n        rm = vacantQueue.poll();\\n        inUseQueue.insert([rm, end]);\\n        next = true;        \\n    }\\n    for(let rm = 0; rm < n; rm++) {\\n        vacantQueue.insert(rm);\\n    }\\n    let output;\\n    let max = 0;\\n    let delay = 0;\\n    const count = Array(n).fill(0);\\n    meetings.sort((a,b) =>  a[0] - b[0]);\\n    for(let i = 0; i < meetings.length; i++) {\\n        let [start, end] = meetings[i];\\n        if(start < delay) {\\n            [start, end] = [delay, end + delay - start];\\n        }\\n        next = false;\\n        while (!next) {\\n            if (inUseQueue.end == 0) {                \\n                use(end);\\n            } else {\\n                while(inUseQueue.end > 0 && inUseQueue.data[0][1] <= start) {\\n                    const room = inUseQueue.poll()[0];\\n                    vacantQueue.insert(room);\\n                }\\n                if (vacantQueue.end > 0) {                    \\n                    use(end);\\n                } else {\\n                    [start, end] = [inUseQueue.data[0][1], end + inUseQueue.data[0][1] - start];\\n                    delay = inUseQueue.data[0][1];\\n                }\\n            }\\n        }\\n        count[rm]++;\\n        if (count[rm] >= max) {\\n            if (count[rm] > max) {\\n                output = rm;\\n            } else if (output > rm) {\\n                output = rm;\\n            }\\n            max = count[rm]; \\n        }\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} meetings\\n * @return {number}\\n */\\n const Heap = function(n, empty, compare) {\\n    this.data = Array(n).fill(empty);\\n    this.end = 0;\\n    this.empty = empty;\\n    this.compare = compare;\\n}\\n\\nHeap.prototype.insert = function(val) {\\n    const end = this.end;\\n    const compare = this.compare;\\n    this.data[end] = val;\\n    if (end != 0) {\\n        let i = end;\\n        while(i > 0 && !compare(this.data[Math.floor((i-1)/2)], this.data[i])) {\\n            let j = Math.floor((i-1)/2);\\n            [this.data[j], this.data[i]] = [this.data[i], this.data[j]];\\n            i = j;\\n        }\\n    }\\n    this.end++;\\n}\\nHeap.prototype.poll = function() {\\n    const compare = this.compare;\\n    let end = this.end;\\n    if(end == 0) {\\n        return null;\\n    } else {\\n        end--;\\n        var output = this.data[0];\\n        if (end >= 0) {\\n            this.data[0] = this.data[end];\\n            let i = 0;\\n            let j = 2*i + 1;\\n            let k = 2*i + 2;\\n            while(!compare(this.data[i], this.data[j]) || !compare(this.data[i], this.data[k])) {\\n                let l = compare(this.data[j], this.data[k])? j : k;\\n                [this.data[i], this.data[l], i, j, k] = [this.data[l], this.data[i], l, 2*l + 1, 2*l + 2];\\n            }            \\n        }\\n    }\\n    this.end--;\\n    this.data[end] = this.empty;    \\n    return output;\\n}\\nvar mostBooked = function(n, meetings) {\\n    const compare = function(rm1, rm2) {\\n        return rm1[1] != rm2[1]? rm1[1] < rm2[1] : rm1[0] < rm2[0];\\n    }    \\n    const inUseQueue = new Heap(2*n+1, [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], compare);\\n    const vacantQueue = new Heap(2*n + 1, Number.POSITIVE_INFINITY, function(a,b) {\\n        return a < b;\\n    })\\n    let next = false;\\n    let rm\\n    const use = function(end) {\\n        rm = vacantQueue.poll();\\n        inUseQueue.insert([rm, end]);\\n        next = true;        \\n    }\\n    for(let rm = 0; rm < n; rm++) {\\n        vacantQueue.insert(rm);\\n    }\\n    let output;\\n    let max = 0;\\n    let delay = 0;\\n    const count = Array(n).fill(0);\\n    meetings.sort((a,b) =>  a[0] - b[0]);\\n    for(let i = 0; i < meetings.length; i++) {\\n        let [start, end] = meetings[i];\\n        if(start < delay) {\\n            [start, end] = [delay, end + delay - start];\\n        }\\n        next = false;\\n        while (!next) {\\n            if (inUseQueue.end == 0) {                \\n                use(end);\\n            } else {\\n                while(inUseQueue.end > 0 && inUseQueue.data[0][1] <= start) {\\n                    const room = inUseQueue.poll()[0];\\n                    vacantQueue.insert(room);\\n                }\\n                if (vacantQueue.end > 0) {                    \\n                    use(end);\\n                } else {\\n                    [start, end] = [inUseQueue.data[0][1], end + inUseQueue.data[0][1] - start];\\n                    delay = inUseQueue.data[0][1];\\n                }\\n            }\\n        }\\n        count[rm]++;\\n        if (count[rm] >= max) {\\n            if (count[rm] > max) {\\n                output = rm;\\n            } else if (output > rm) {\\n                output = rm;\\n            }\\n            max = count[rm]; \\n        }\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3447385,
                "title": "an-object-oriented-approach",
                "content": "# Intuition\\nMeetingRoomsManager is responsible for dealing with the rooms, while client handles the application logic stated in the problem.\\n\\n\\n# Code\\n```\\nstruct EngagedRoom {\\n  int roomId;\\n  long long meetingEndTime;\\n};\\nstruct EngagedRoomComp {\\n  bool operator()(EngagedRoom & er1, EngagedRoom & er2) {\\n    return er1.meetingEndTime > er2.meetingEndTime;\\n  }\\n};\\nclass MeetingRoomsManager {\\n  private: int n;\\n  long long cur_time = 0;\\n  priority_queue < int,\\n  vector < int > ,\\n  greater < int >> unusedRooms;\\n  priority_queue < EngagedRoom,\\n  vector < EngagedRoom > ,\\n  EngagedRoomComp > engagedRooms;\\n  vector < int > freq;\\n  public: MeetingRoomsManager(int n) {\\n    this -> n = n;\\n    for (int i = 0; i < n; i++) unusedRooms.push(i);\\n    freq = vector < int > (n, 0);\\n  }\\n  int getUnusedRoom() {\\n    if (unusedRooms.size() > 0) return unusedRooms.top();\\n    else return -1;\\n  }\\n  int minWaitTime() {\\n    if (unusedRooms.size() > 0) return 0;\\n    else return engagedRooms.top().meetingEndTime - cur_time;\\n  }\\n  void incremennt_time(int inc) {\\n    cur_time += inc;\\n    while (engagedRooms.size() > 0 && engagedRooms.top().meetingEndTime <= cur_time) {\\n      unusedRooms.push(engagedRooms.top().roomId);\\n      engagedRooms.pop();\\n    }\\n  }\\n  void startMeeting(int duration) {\\n    int room = getUnusedRoom();\\n    if (room == -1) throw \"All meeting rooms are full\";\\n    unusedRooms.pop();\\n    engagedRooms.push({\\n      room,\\n      cur_time + duration\\n    });\\n    freq[room]++;\\n  }\\n  long long get_cur_time() {\\n    return cur_time;\\n  }\\n  int get_most_booked_room() {\\n    int room = 0;\\n    for (int i = 1; i < n; i++) {\\n      if (freq[i] > freq[room]) room = i;\\n    }\\n    return room;\\n  }\\n};\\n\\nclass Solution {\\n  public: int mostBooked(int n, vector < vector < int >> & meetings) {\\n    sort(meetings.begin(), meetings.end());\\n    MeetingRoomsManager manager(n);\\n    for (vector < int > & meeting: meetings) {\\n      int start = meeting[0], end = meeting[1];\\n      long long cur_time = manager.get_cur_time();\\n      if (cur_time < start) {\\n        manager.incremennt_time(start - cur_time);\\n      }\\n      int room = manager.getUnusedRoom();\\n      if (room == -1) {\\n        int waitTime = manager.minWaitTime();\\n        manager.incremennt_time(waitTime);\\n      }\\n      manager.startMeeting(end - start);\\n    }\\n    return manager.get_most_booked_room();\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct EngagedRoom {\\n  int roomId;\\n  long long meetingEndTime;\\n};\\nstruct EngagedRoomComp {\\n  bool operator()(EngagedRoom & er1, EngagedRoom & er2) {\\n    return er1.meetingEndTime > er2.meetingEndTime;\\n  }\\n};\\nclass MeetingRoomsManager {\\n  private: int n;\\n  long long cur_time = 0;\\n  priority_queue < int,\\n  vector < int > ,\\n  greater < int >> unusedRooms;\\n  priority_queue < EngagedRoom,\\n  vector < EngagedRoom > ,\\n  EngagedRoomComp > engagedRooms;\\n  vector < int > freq;\\n  public: MeetingRoomsManager(int n) {\\n    this -> n = n;\\n    for (int i = 0; i < n; i++) unusedRooms.push(i);\\n    freq = vector < int > (n, 0);\\n  }\\n  int getUnusedRoom() {\\n    if (unusedRooms.size() > 0) return unusedRooms.top();\\n    else return -1;\\n  }\\n  int minWaitTime() {\\n    if (unusedRooms.size() > 0) return 0;\\n    else return engagedRooms.top().meetingEndTime - cur_time;\\n  }\\n  void incremennt_time(int inc) {\\n    cur_time += inc;\\n    while (engagedRooms.size() > 0 && engagedRooms.top().meetingEndTime <= cur_time) {\\n      unusedRooms.push(engagedRooms.top().roomId);\\n      engagedRooms.pop();\\n    }\\n  }\\n  void startMeeting(int duration) {\\n    int room = getUnusedRoom();\\n    if (room == -1) throw \"All meeting rooms are full\";\\n    unusedRooms.pop();\\n    engagedRooms.push({\\n      room,\\n      cur_time + duration\\n    });\\n    freq[room]++;\\n  }\\n  long long get_cur_time() {\\n    return cur_time;\\n  }\\n  int get_most_booked_room() {\\n    int room = 0;\\n    for (int i = 1; i < n; i++) {\\n      if (freq[i] > freq[room]) room = i;\\n    }\\n    return room;\\n  }\\n};\\n\\nclass Solution {\\n  public: int mostBooked(int n, vector < vector < int >> & meetings) {\\n    sort(meetings.begin(), meetings.end());\\n    MeetingRoomsManager manager(n);\\n    for (vector < int > & meeting: meetings) {\\n      int start = meeting[0], end = meeting[1];\\n      long long cur_time = manager.get_cur_time();\\n      if (cur_time < start) {\\n        manager.incremennt_time(start - cur_time);\\n      }\\n      int room = manager.getUnusedRoom();\\n      if (room == -1) {\\n        int waitTime = manager.minWaitTime();\\n        manager.incremennt_time(waitTime);\\n      }\\n      manager.startMeeting(end - start);\\n    }\\n    return manager.get_most_booked_room();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427102,
                "title": "rust-2-heaps-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn most_booked(n: i32, mut meetings: Vec<Vec<i32>>) -> i32 {\\n        use std::cmp::Reverse;\\n        use std::collections::BinaryHeap;\\n        meetings.sort();\\n        let mut ready = BinaryHeap::from((0..n).map(|x| Reverse(x)).collect::<Vec<_>>());\\n        let mut rooms: BinaryHeap<Reverse<(i64, i32)>> = BinaryHeap::new();\\n        let mut ans = vec![0; n as usize];\\n\\n        for m in meetings {\\n            let start = m[0] as i64;\\n            let end = m[1] as i64;\\n\\n            while !rooms.is_empty() && rooms.peek().unwrap().0 .0 <= start {\\n                ready.push(Reverse((rooms.pop().unwrap().0).1));\\n            }\\n\\n            if !ready.is_empty() {\\n                let r = ready.pop().unwrap().0;\\n                rooms.push(Reverse((end, r)));\\n                ans[r as usize] += 1;\\n            } else {\\n                let Reverse((t, r)) = rooms.pop().unwrap();\\n                rooms.push(Reverse((t + end - start, r)));\\n                ans[r as usize] += 1;\\n            }\\n        }\\n\\n        ans.into_iter()\\n            .enumerate()\\n            .map(|(i, v)| (v, Reverse(i)))\\n            .max()\\n            .unwrap()\\n            .1\\n            .0 as i32       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn most_booked(n: i32, mut meetings: Vec<Vec<i32>>) -> i32 {\\n        use std::cmp::Reverse;\\n        use std::collections::BinaryHeap;\\n        meetings.sort();\\n        let mut ready = BinaryHeap::from((0..n).map(|x| Reverse(x)).collect::<Vec<_>>());\\n        let mut rooms: BinaryHeap<Reverse<(i64, i32)>> = BinaryHeap::new();\\n        let mut ans = vec![0; n as usize];\\n\\n        for m in meetings {\\n            let start = m[0] as i64;\\n            let end = m[1] as i64;\\n\\n            while !rooms.is_empty() && rooms.peek().unwrap().0 .0 <= start {\\n                ready.push(Reverse((rooms.pop().unwrap().0).1));\\n            }\\n\\n            if !ready.is_empty() {\\n                let r = ready.pop().unwrap().0;\\n                rooms.push(Reverse((end, r)));\\n                ans[r as usize] += 1;\\n            } else {\\n                let Reverse((t, r)) = rooms.pop().unwrap();\\n                rooms.push(Reverse((t + end - start, r)));\\n                ans[r as usize] += 1;\\n            }\\n        }\\n\\n        ans.into_iter()\\n            .enumerate()\\n            .map(|(i, v)| (v, Reverse(i)))\\n            .max()\\n            .unwrap()\\n            .1\\n            .0 as i32       \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3400525,
                "title": "2-array-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& m) {\\n        vector<int> c(n,0);\\n        vector<long long> em(n,0);\\n        sort(m.begin(),m.end());\\n        for(int i=0;i<m.size();i++){\\n            int f=0;\\n            long long  mi=1e18;\\n            int ind=-1;\\n            for(int j=0;j<n;j++){\\n                if(m[i][0]>=em[j]){\\n                    em[j]=m[i][1];\\n                    c[j]++;\\n                    f=1;\\n                    break;\\n                }\\n                if(mi>em[j]){\\n                        mi=em[j];\\n                        ind=j;\\n                    }\\n            }\\n            if(f==0){\\n                em[ind]+=(long long)m[i][1]-m[i][0];\\n                c[ind]++;\\n            }\\n        }\\n        int ma=-1;\\n        int in=-1;\\n        for(int i=0;i<n;i++){\\n            if(ma<c[i]){\\n                ma=c[i];\\n                in=i;\\n            }\\n        }\\n        return in;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& m) {\\n        vector<int> c(n,0);\\n        vector<long long> em(n,0);\\n        sort(m.begin(),m.end());\\n        for(int i=0;i<m.size();i++){\\n            int f=0;\\n            long long  mi=1e18;\\n            int ind=-1;\\n            for(int j=0;j<n;j++){\\n                if(m[i][0]>=em[j]){\\n                    em[j]=m[i][1];\\n                    c[j]++;\\n                    f=1;\\n                    break;\\n                }\\n                if(mi>em[j]){\\n                        mi=em[j];\\n                        ind=j;\\n                    }\\n            }\\n            if(f==0){\\n                em[ind]+=(long long)m[i][1]-m[i][0];\\n                c[ind]++;\\n            }\\n        }\\n        int ma=-1;\\n        int in=-1;\\n        for(int i=0;i<n;i++){\\n            if(ma<c[i]){\\n                ma=c[i];\\n                in=i;\\n            }\\n        }\\n        return in;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395235,
                "title": "java-brute-force-solution-without-any-heap",
                "content": "# Intuition\\nIf a meeting start at 10, room is free from 5, room can start the meeting from 10.\\nIf a meeting start at 10, room is free from 15, room can start the meeting from 15.\\n\\nBy above we can calculate time when each room can start holding a given meeting.\\nFor every meeting, we take the first room that can start it at earliest.\\n\\n# Approach\\nTraversing meetings as per their start time, we keep on finding the first room that can hold the given meeting at earliest.\\n\\n# Complexity\\n- Time complexity:\\nO(num_meetings * num_rooms)\\n\\n- Space complexity:\\nO(num_rooms)\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        long[] roomFreeTime = new long[n]; // Per room earliest free time, intially all rooms are free starting time 0\\n        int[] roomMeetCount = new int[n]; // Per room meeting count\\n        \\n        Arrays.sort(meetings, (a,b) -> a[0]-b[0]); // Sort meetings by start time\\n\\n        for(int []meet:meetings){\\n            int roomIndex = searchFirstAvailableRoom(roomFreeTime, meet[0]);\\n            roomMeetCount[roomIndex]++;\\n            roomFreeTime[roomIndex] = (Math.max(roomFreeTime[roomIndex], meet[0]) + (meet[1]-meet[0]));\\n        }\\n\\n        // Find first room that holds max meetings\\n        int maxIndex = 0;\\n        int maxCount = roomMeetCount[0];\\n        for(int i=0;i<roomMeetCount.length;i++){\\n            if(maxCount < roomMeetCount[i]){\\n                maxCount = roomMeetCount[i];\\n                maxIndex = i;\\n            }\\n        }\\n        return maxIndex;\\n    }\\n\\n    // Get first room that can hold this meeting at the earliest\\n    private int searchFirstAvailableRoom(long[] roomFreeTime, int meetStart){\\n        int ansIndex = 0;\\n        long minHostTime = Math.max(roomFreeTime[0], meetStart); // Earliest time that room 0 can start this meeting\\n        for(int i=0;i<roomFreeTime.length;i++){\\n            long currHostTime = Math.max(roomFreeTime[i], meetStart);  // Earliest time that room i can start this meeting\\n            if(minHostTime > currHostTime){\\n                ansIndex = i;\\n                minHostTime = currHostTime;\\n            }\\n        }\\n        return ansIndex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostBooked(int n, int[][] meetings) {\\n        long[] roomFreeTime = new long[n]; // Per room earliest free time, intially all rooms are free starting time 0\\n        int[] roomMeetCount = new int[n]; // Per room meeting count\\n        \\n        Arrays.sort(meetings, (a,b) -> a[0]-b[0]); // Sort meetings by start time\\n\\n        for(int []meet:meetings){\\n            int roomIndex = searchFirstAvailableRoom(roomFreeTime, meet[0]);\\n            roomMeetCount[roomIndex]++;\\n            roomFreeTime[roomIndex] = (Math.max(roomFreeTime[roomIndex], meet[0]) + (meet[1]-meet[0]));\\n        }\\n\\n        // Find first room that holds max meetings\\n        int maxIndex = 0;\\n        int maxCount = roomMeetCount[0];\\n        for(int i=0;i<roomMeetCount.length;i++){\\n            if(maxCount < roomMeetCount[i]){\\n                maxCount = roomMeetCount[i];\\n                maxIndex = i;\\n            }\\n        }\\n        return maxIndex;\\n    }\\n\\n    // Get first room that can hold this meeting at the earliest\\n    private int searchFirstAvailableRoom(long[] roomFreeTime, int meetStart){\\n        int ansIndex = 0;\\n        long minHostTime = Math.max(roomFreeTime[0], meetStart); // Earliest time that room 0 can start this meeting\\n        for(int i=0;i<roomFreeTime.length;i++){\\n            long currHostTime = Math.max(roomFreeTime[i], meetStart);  // Earliest time that room i can start this meeting\\n            if(minHostTime > currHostTime){\\n                ansIndex = i;\\n                minHostTime = currHostTime;\\n            }\\n        }\\n        return ansIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388134,
                "title": "c",
                "content": "```\\nusing LL = long long ;\\nusing PII = pair<LL, LL> ;  // {endtime, index}\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        priority_queue<int, vector<int>, greater<>>canUseRoom ;\\n        priority_queue<PII, vector<PII>, greater<PII>>used ;\\n        vector<int>count(n) ;\\n        sort(meetings.begin(), meetings.end()) ;    \\n        for(int i = 0; i < n; i++)\\n            canUseRoom.push(i) ;\\n        \\n        for(auto& meeting : meetings){\\n            int start = meeting[0] ;\\n            int end = meeting[1] ;\\n            while(!used.empty() && used.top().first <= start ){\\n                int idx = used.top().second ;\\n                used.pop() ;\\n                canUseRoom.push(idx) ;\\n            }\\n            if(!canUseRoom.empty()){\\n                int idx = canUseRoom.top() ;\\n                canUseRoom.pop() ;\\n                used.push({end, idx}) ;\\n                count[idx]++ ;\\n            }\\n            else{\\n                auto [time, idx] = used.top() ;\\n                used.pop() ;\\n                count[idx]++ ;\\n                used.push({time + end - start, idx}) ;\\n            }\\n        }\\n        return max_element(count.begin(), count.end()) - count.begin() ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nusing LL = long long ;\\nusing PII = pair<LL, LL> ;  // {endtime, index}\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        priority_queue<int, vector<int>, greater<>>canUseRoom ;\\n        priority_queue<PII, vector<PII>, greater<PII>>used ;\\n        vector<int>count(n) ;\\n        sort(meetings.begin(), meetings.end()) ;    \\n        for(int i = 0; i < n; i++)\\n            canUseRoom.push(i) ;\\n        \\n        for(auto& meeting : meetings){\\n            int start = meeting[0] ;\\n            int end = meeting[1] ;\\n            while(!used.empty() && used.top().first <= start ){\\n                int idx = used.top().second ;\\n                used.pop() ;\\n                canUseRoom.push(idx) ;\\n            }\\n            if(!canUseRoom.empty()){\\n                int idx = canUseRoom.top() ;\\n                canUseRoom.pop() ;\\n                used.push({end, idx}) ;\\n                count[idx]++ ;\\n            }\\n            else{\\n                auto [time, idx] = used.top() ;\\n                used.pop() ;\\n                count[idx]++ ;\\n                used.push({time + end - start, idx}) ;\\n            }\\n        }\\n        return max_element(count.begin(), count.end()) - count.begin() ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387761,
                "title": "java-m-logn-logm-2-heap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst sort all the meetings based upon start time\\nCreate two PriorityQueue , availableRooms , BusyRooms. sort based upon end time , then room index;\\ninitially all the rooms are available & added into \"availableRooms\" priority Queue.\\nfor each meeting:\\n - free all the rooms from busyRooms queue, whose end time is less than current meeting start time & add that room to available rooms queue. \\n - check if any available meeting room, then pick & assign meeting to that room\\n - if no meeting room available, get the next possible meeting room from busyRooms. this will add the delay time. \\n- keep maintaining the counter of each room how many times its used & which room is used maximum time. \\n\\n# Complexity\\n- Time complexity:\\nm = meeting rooms length;\\nn = no of meeting rooms available \\nO(m (logn + logm)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a,b) -> { return a[0] - b[0]; });\\n        PriorityQueue<Room> availableRooms = new PriorityQueue<>( (a, b) -> {\\n            return a.end != b.end ? a.end - b.end : a.index - b.index;\\n        });\\n        PriorityQueue<Room> busyRooms = new PriorityQueue<>( (a, b) -> {\\n            return a.end != b.end ? a.end - b.end : a.index - b.index;\\n        });\\n        \\n        for(int i = 0; i< n; i++) {\\n            availableRooms.add(new Room(i, 0));\\n        }\\n\\n        int maxTimeBooked = 0;\\n        int mostBookedRoom = 0;\\n        for(int i = 0; i < meetings.length; i++){\\n            int start = meetings[i][0];\\n            int end = meetings[i][1];\\n\\n            while(!busyRooms.isEmpty() && (busyRooms.peek().end <= start)){\\n                Room busyRoom = busyRooms.poll();\\n                // since the meeting room is already free.\\n                busyRoom.setMeetingTime(0);\\n                availableRooms.add(busyRoom);\\n            }\\n\\n            Room currentRoom;\\n            if(!availableRooms.isEmpty()) {\\n                currentRoom = availableRooms.poll();\\n            } else {\\n                currentRoom = busyRooms.poll();\\n            }\\n            \\n            int timeDelay = 0;\\n            if(currentRoom.end > start) {\\n                timeDelay = currentRoom.end - start;\\n            }\\n\\n            currentRoom.setMeetingTime(end + timeDelay);\\n            currentRoom.count++;\\n\\n            if(maxTimeBooked < currentRoom.count) {\\n                maxTimeBooked = currentRoom.count;\\n                mostBookedRoom = currentRoom.index;\\n            }else if(maxTimeBooked == currentRoom.count) {\\n                mostBookedRoom = Math.min(mostBookedRoom, currentRoom.index);\\n            }\\n            busyRooms.add(currentRoom);\\n        }\\n\\n        return mostBookedRoom;\\n    }\\n\\n    class Room {\\n        int index;\\n        int count;\\n        int end;\\n        public Room(int index, int count){\\n            this.index = index;\\n            this.count = count;\\n            this.end = 0;\\n        }\\n        public void setMeetingTime(int end){\\n            this.end = end;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a,b) -> { return a[0] - b[0]; });\\n        PriorityQueue<Room> availableRooms = new PriorityQueue<>( (a, b) -> {\\n            return a.end != b.end ? a.end - b.end : a.index - b.index;\\n        });\\n        PriorityQueue<Room> busyRooms = new PriorityQueue<>( (a, b) -> {\\n            return a.end != b.end ? a.end - b.end : a.index - b.index;\\n        });\\n        \\n        for(int i = 0; i< n; i++) {\\n            availableRooms.add(new Room(i, 0));\\n        }\\n\\n        int maxTimeBooked = 0;\\n        int mostBookedRoom = 0;\\n        for(int i = 0; i < meetings.length; i++){\\n            int start = meetings[i][0];\\n            int end = meetings[i][1];\\n\\n            while(!busyRooms.isEmpty() && (busyRooms.peek().end <= start)){\\n                Room busyRoom = busyRooms.poll();\\n                // since the meeting room is already free.\\n                busyRoom.setMeetingTime(0);\\n                availableRooms.add(busyRoom);\\n            }\\n\\n            Room currentRoom;\\n            if(!availableRooms.isEmpty()) {\\n                currentRoom = availableRooms.poll();\\n            } else {\\n                currentRoom = busyRooms.poll();\\n            }\\n            \\n            int timeDelay = 0;\\n            if(currentRoom.end > start) {\\n                timeDelay = currentRoom.end - start;\\n            }\\n\\n            currentRoom.setMeetingTime(end + timeDelay);\\n            currentRoom.count++;\\n\\n            if(maxTimeBooked < currentRoom.count) {\\n                maxTimeBooked = currentRoom.count;\\n                mostBookedRoom = currentRoom.index;\\n            }else if(maxTimeBooked == currentRoom.count) {\\n                mostBookedRoom = Math.min(mostBookedRoom, currentRoom.index);\\n            }\\n            busyRooms.add(currentRoom);\\n        }\\n\\n        return mostBookedRoom;\\n    }\\n\\n    class Room {\\n        int index;\\n        int count;\\n        int end;\\n        public Room(int index, int count){\\n            this.index = index;\\n            this.count = count;\\n            this.end = 0;\\n        }\\n        public void setMeetingTime(int end){\\n            this.end = end;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381624,
                "title": "approach-using-two-priority-queues",
                "content": "\\n```\\nfrom heapq import heappush,heappop\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        hq1 = [] #room availbility sorted by time\\n        hq2 = [] #for already available rooms, time order become no longer relevant, and availble rooms have to be sorted by index\\n        useFreq = [0]*n\\n        for i in range(n):\\n            heappush(hq1,(0,i))\\n        for s,e in meetings:\\n            while hq1 and hq1[0][0]<=s:\\n                heappush(hq2,heappop(hq1)[1])\\n            if hq2:\\n                room = heappop(hq2)\\n                heappush(hq1,(e,room))\\n            else:\\n                t, room = heappop(hq1)\\n                heappush(hq1,(t+e-s,room))\\n            useFreq[room] += 1\\n        x = max(useFreq)\\n        return useFreq.index(x)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heappush,heappop\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        meetings.sort()\\n        hq1 = [] #room availbility sorted by time\\n        hq2 = [] #for already available rooms, time order become no longer relevant, and availble rooms have to be sorted by index\\n        useFreq = [0]*n\\n        for i in range(n):\\n            heappush(hq1,(0,i))\\n        for s,e in meetings:\\n            while hq1 and hq1[0][0]<=s:\\n                heappush(hq2,heappop(hq1)[1])\\n            if hq2:\\n                room = heappop(hq2)\\n                heappush(hq1,(e,room))\\n            else:\\n                t, room = heappop(hq1)\\n                heappush(hq1,(t+e-s,room))\\n            useFreq[room] += 1\\n        x = max(useFreq)\\n        return useFreq.index(x)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1837807,
                "content": [
                    {
                        "username": "quanyincode",
                        "content": "If you are wondering why your solution past 80/82 test cases, it it due to the two test cases with long inputs, which will cause integer overflow on the meeting end time. Use Long instead of Integer to track a room\\'s end time should solve the problem."
                    },
                    {
                        "username": "jerome1210",
                        "content": "May someone explain why this meetings [[0,10],[1,9],[2,8],[3,7],[4,6]] will return 1?\nI thought it should be \n1. room: 0, time 10 (0+10)\n2. room: 1, time 10 (1+9)\n3. room: 2, time 10 (2+8)\n4. room: 0, time 17 (10+7)\n5. room: 1, time 16 (10 + 6)\n\nSo, the room 0, 1 will held 2 meetings, then it should return 0 ?\n"
                    },
                    {
                        "username": "user0081T",
                        "content": "The second meeting will end at time: 9 not 10, same thing for the third meeting, it will end at time 8, not 10.  Because the the second argument for each meeting is the end time of the meeting and not the duration of it. "
                    },
                    {
                        "username": "shru15",
                        "content": "After meeting 3, the earliest free room will be room 2\\nso [3,7] -> [3+8, 7+8] at room 2\\nand 4,6 -> [4+9, 6+9] at room 1\\nsince room 0 gets freed at last, only one meeting will take place there."
                    },
                    {
                        "username": "anshil1611",
                        "content": "For the people who are confused with WA at 80/82:\\n\\nI am seeing lot of comments where people are saying its because of integer overflow. Seemingly true, however if you are using a PriorityQueue of type Pair<Integer, Integer>, that is where all the problem is occurring. Just change the type of the priority queue from Pair<Integer, Integer> to int[] (yes, no Long required) and your solution would pass the remaining test cases.\\n\\nIt seems like Pair<Integer, Integer> is not able to handle large values, and the same code which fails with Pair<Integer, Integer>, passes all test cases with int[]."
                    },
                    {
                        "username": "spark6015",
                        "content": "are we even allow to use heapq.heapify() function in the interview?"
                    },
                    {
                        "username": "strangeranda",
                        "content": "Yes, you could ask the interviewer if you could use built-in functions, and 10/10 they\\u2019d say yes. I could be wrong in 10/10, but I never faced any instance where I couldn\\u2019t use. "
                    },
                    {
                        "username": "Tanayk",
                        "content": "Can someone please help me identify the error in this code? 80/82 test cases are passing. \\nThank you\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        rooms = collections.defaultdict(int)\\n        meetings.sort()\\n        booked, free = [], []\\n        max_meets = 0\\n        for i in range(n):\\n            heapq.heappush(booked, (0, i))\\n\\n        i, curr_time = 0, meetings[0][0]\\n        while i < len(meetings):\\n            while booked and booked[0][0] <= curr_time:\\n                free_time, index = heapq.heappop(booked)\\n                heapq.heappush(free, (index, free_time))\\n\\n            if not free:\\n                curr_time = booked[0][0]\\n                continue\\n\\n            room_id, _ = heapq.heappop(free)\\n            rooms[room_id] += 1\\n            max_meets = max(max_meets, rooms[room_id])\\n            heapq.heappush(booked, (curr_time + (meetings[i][1] - meetings[i][0]), room_id))\\n            curr_time = meetings[i+1][0] if i + 1 < len(meetings) else curr_time\\n            i += 1\\n\\n        for i in range(n):\\n            if rooms[i] == max_meets:\\n                return i\\n```"
                    },
                    {
                        "username": "frog445",
                        "content": "[@quanyincode](/quanyincode) It\\'s python lol why will it have integer overflow"
                    },
                    {
                        "username": "quanyincode",
                        "content": "See my comment about the two test cases that cause integer overflow."
                    },
                    {
                        "username": "jffiorillo",
                        "content": "Regarding this test: `[[1,27],[29,49],[47,49],[41,43],[15,36],[11,15]]` in theory the output is `1` but I did it manually and the output is `0`. Can you please explain me why the output is `1`?\\n\\nThe following is the explanation why I think the answer is `0`\\n\\n```\\n// Meetings ordered by start time : [Meeting(start=1, finish=27), Meeting(start=11, finish=15), Meeting(start=15, finish=36), Meeting(start=29, finish=49), Meeting(start=41, finish=43), Meeting(start=47, finish=49)]\\n\\nfirst meeting = Meeting(start=1, finish=27)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=0, numberOfMeetings=0), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nsecond meeting = Meeting(start=11, finish=15)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=15, numberOfMeetings=1), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nthird meeting = Meeting(start=15, finish=36)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nforth meeting  = Meeting(start=29, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nfifth meeting = Meeting(start=41, finish=43)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=43, numberOfMeetings=1)]\\n\\nlast meeting = Meeting(start=47, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=92, numberOfMeetings=2)]\\n\\nAll room has been booking twice, so the answer is 0.\\n```"
                    },
                    {
                        "username": "vandanakumari13998",
                        "content": "Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\\nI didn\\'t get this example. How is the output 0. Because at time 8, [4,9] meeting will end. Hence 2 meeting room will be empty and [6,8] one would be scheduled at that time. And how is the output given as 1."
                    },
                    {
                        "username": "superZero",
                        "content": "Is the solution flawed?  I see that the solution is to delay 1 meeting till 1 room becomes available.\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                current_end, room = heappop(running_meetings)\\n                new_end = current_end + meetings[i][1] - meetings[i][0]  # Update the room\\'s end time\\n                heappush(running_meetings, (new_end, room))\\n\\n            meetings_per_room[room] +=1\\n            i +=1\\n\\nBut reality should be that all the remaining meetings whose start time is < end_time of the 1st available room should be delayed.\\n\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                for j in range (i, size):\\n                    if meetings[j][0] < running_meetings[0][0]:\\n                        meetings[j][0] += delta \\n                        meetings[j][1] +=delta\\n                    else:\\n                        break\\n\\n"
                    },
                    {
                        "username": "jj3100",
                        "content": "I used Integer types and finally managed to pass all tests. The main issue that caused me to fail on the 80/82 and 81/82 test cases is that when the end times are equal, the PriorityQueue should also compare the room numbers."
                    },
                    {
                        "username": "magomez4",
                        "content": "Passing 82 test cases but TLE? My code is the same idea as others I\\'m seeing in the submissions, and it passes all test cases, but I get a TLE and it says \"82/82\" test cases passed. It also says that the last executed input is \"n=\" yes.. a blank \\'n\\'. Can anyone tell me if this is a leetcode problem or what am I doing wrong? Any help is greatly appreciated!! \\n\\nHere is my approach:\\n ```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // keep an array for the number of bookings of\\n        // each room.\\n        // also keep a mostBooked variable that gets\\n        // updated every time a room is used.\\n        // To assign a meeting to a room, check if\\n        // the meeting starts before the earliest-finishing\\n        // scheduled meeting. If so, assign a new room. If\\n        // there are no more rooms, wait until the earliest\\n        // finishing room, and use that one. If the meeting\\n        // starts after the earliest-finishing room becomes \\n        // free, then continue to \"free-up\" rooms until\\n        // there are no rooms booked or the earliest finishing\\n        // is later than the current start time. After this,\\n        // use the same logic as above to assign the next\\n        // available room.\\n\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        // ensure meetings are sorted by start time\\n        sort(meetings.begin(),meetings.end(), comparator);\\n\\n        int bookingCount[n];\\n        fill_n(bookingCount, n, 0);\\n        int mostBooked = -1;\\n        // We declare a min-heap that holds <endTime, roomNumber> \\n        // to keep the min end time at the front.\\n        priority_queue<vector<long>, vector<vector<long>>, greater<vector<long>>> freeAt; \\n        priority_queue<int,vector<int>,greater<int>> emptyRooms;\\n        for(int i = 0; i < n; i++)\\n        {\\n            emptyRooms.push(i);\\n        }\\n\\n        for(int i = 0; i < meetings.size(); i++)\\n        {\\n            if(mostBooked == -1)\\n            {\\n                mostBooked = 0;\\n                bookingCount[mostBooked]++;\\n                vector<long> newFreeAt = {meetings[i][1], mostBooked}; \\n                freeAt.push(newFreeAt);\\n                emptyRooms.pop();\\n            }\\n            else\\n            {\\n                // if(meetings[i][0] < freeAt.top().first )\\n                if(meetings[i][0] < freeAt.top()[0] )\\n                {\\n                    // current meeting start time is earlier\\n                    // than the earliest-finishing scheduled meeting\\n                    if(freeAt.size() < n)\\n                    {\\n                        // there are available rooms, so book the next available\\n                        vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                    else\\n                    {\\n                        // there are no more available rooms, so this will haven\\n                        // to wait for the earliest finishing scheduled meeting\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        int meetingDuration = meetings[i][1] - meetings[i][0];//end time - start time\\n                        long newEndTime = freeAt.top()[0] + meetingDuration;\\n                        freeAt.pop();\\n                        vector<long> newFreeAt = {newEndTime, emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                }\\n                else\\n                {\\n                    // current meeting start time is later than the earliest\\n                    // finishing scheduled meeting. \\n                    while(!freeAt.empty() \\n                    && meetings[i][0] >= freeAt.top()[0])\\n                    {\\n                        // let the meetings finish to make sure \\n                        // we get the room with the smallest number\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        freeAt.pop();\\n                    }\\n                    vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                    freeAt.push(newFreeAt);\\n                    bookingCount[emptyRooms.top()]++;\\n                    mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                    emptyRooms.pop();\\n                }\\n            }\\n        }\\n        return mostBooked;\\n    }\\n    static bool comparator(vector<int> a, vector<int> b)\\n    {\\n        if(a[0] <= b[0])\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int updateMostBooked(int mostBooked, int newlyBooked, int bookingCount[])\\n    {\\n        int newMostBooked;\\n        if(bookingCount[newlyBooked] > bookingCount[mostBooked])\\n        {\\n            newMostBooked = newlyBooked;\\n        }\\n        else if (bookingCount[newlyBooked] == bookingCount[mostBooked])\\n        {\\n            // if two rooms have the same amount of meetings,\\n            // we consider the room with the smallest ID as \\n            // the most booked\\n            newMostBooked = min(newlyBooked, mostBooked);\\n        }\\n        else\\n        {\\n            newMostBooked = mostBooked;\\n        }\\n        return newMostBooked;\\n    }\\n};\\n```\\n"
                    }
                ]
            },
            {
                "id": 1940407,
                "content": [
                    {
                        "username": "quanyincode",
                        "content": "If you are wondering why your solution past 80/82 test cases, it it due to the two test cases with long inputs, which will cause integer overflow on the meeting end time. Use Long instead of Integer to track a room\\'s end time should solve the problem."
                    },
                    {
                        "username": "jerome1210",
                        "content": "May someone explain why this meetings [[0,10],[1,9],[2,8],[3,7],[4,6]] will return 1?\nI thought it should be \n1. room: 0, time 10 (0+10)\n2. room: 1, time 10 (1+9)\n3. room: 2, time 10 (2+8)\n4. room: 0, time 17 (10+7)\n5. room: 1, time 16 (10 + 6)\n\nSo, the room 0, 1 will held 2 meetings, then it should return 0 ?\n"
                    },
                    {
                        "username": "user0081T",
                        "content": "The second meeting will end at time: 9 not 10, same thing for the third meeting, it will end at time 8, not 10.  Because the the second argument for each meeting is the end time of the meeting and not the duration of it. "
                    },
                    {
                        "username": "shru15",
                        "content": "After meeting 3, the earliest free room will be room 2\\nso [3,7] -> [3+8, 7+8] at room 2\\nand 4,6 -> [4+9, 6+9] at room 1\\nsince room 0 gets freed at last, only one meeting will take place there."
                    },
                    {
                        "username": "anshil1611",
                        "content": "For the people who are confused with WA at 80/82:\\n\\nI am seeing lot of comments where people are saying its because of integer overflow. Seemingly true, however if you are using a PriorityQueue of type Pair<Integer, Integer>, that is where all the problem is occurring. Just change the type of the priority queue from Pair<Integer, Integer> to int[] (yes, no Long required) and your solution would pass the remaining test cases.\\n\\nIt seems like Pair<Integer, Integer> is not able to handle large values, and the same code which fails with Pair<Integer, Integer>, passes all test cases with int[]."
                    },
                    {
                        "username": "spark6015",
                        "content": "are we even allow to use heapq.heapify() function in the interview?"
                    },
                    {
                        "username": "strangeranda",
                        "content": "Yes, you could ask the interviewer if you could use built-in functions, and 10/10 they\\u2019d say yes. I could be wrong in 10/10, but I never faced any instance where I couldn\\u2019t use. "
                    },
                    {
                        "username": "Tanayk",
                        "content": "Can someone please help me identify the error in this code? 80/82 test cases are passing. \\nThank you\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        rooms = collections.defaultdict(int)\\n        meetings.sort()\\n        booked, free = [], []\\n        max_meets = 0\\n        for i in range(n):\\n            heapq.heappush(booked, (0, i))\\n\\n        i, curr_time = 0, meetings[0][0]\\n        while i < len(meetings):\\n            while booked and booked[0][0] <= curr_time:\\n                free_time, index = heapq.heappop(booked)\\n                heapq.heappush(free, (index, free_time))\\n\\n            if not free:\\n                curr_time = booked[0][0]\\n                continue\\n\\n            room_id, _ = heapq.heappop(free)\\n            rooms[room_id] += 1\\n            max_meets = max(max_meets, rooms[room_id])\\n            heapq.heappush(booked, (curr_time + (meetings[i][1] - meetings[i][0]), room_id))\\n            curr_time = meetings[i+1][0] if i + 1 < len(meetings) else curr_time\\n            i += 1\\n\\n        for i in range(n):\\n            if rooms[i] == max_meets:\\n                return i\\n```"
                    },
                    {
                        "username": "frog445",
                        "content": "[@quanyincode](/quanyincode) It\\'s python lol why will it have integer overflow"
                    },
                    {
                        "username": "quanyincode",
                        "content": "See my comment about the two test cases that cause integer overflow."
                    },
                    {
                        "username": "jffiorillo",
                        "content": "Regarding this test: `[[1,27],[29,49],[47,49],[41,43],[15,36],[11,15]]` in theory the output is `1` but I did it manually and the output is `0`. Can you please explain me why the output is `1`?\\n\\nThe following is the explanation why I think the answer is `0`\\n\\n```\\n// Meetings ordered by start time : [Meeting(start=1, finish=27), Meeting(start=11, finish=15), Meeting(start=15, finish=36), Meeting(start=29, finish=49), Meeting(start=41, finish=43), Meeting(start=47, finish=49)]\\n\\nfirst meeting = Meeting(start=1, finish=27)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=0, numberOfMeetings=0), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nsecond meeting = Meeting(start=11, finish=15)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=15, numberOfMeetings=1), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nthird meeting = Meeting(start=15, finish=36)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nforth meeting  = Meeting(start=29, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nfifth meeting = Meeting(start=41, finish=43)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=43, numberOfMeetings=1)]\\n\\nlast meeting = Meeting(start=47, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=92, numberOfMeetings=2)]\\n\\nAll room has been booking twice, so the answer is 0.\\n```"
                    },
                    {
                        "username": "vandanakumari13998",
                        "content": "Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\\nI didn\\'t get this example. How is the output 0. Because at time 8, [4,9] meeting will end. Hence 2 meeting room will be empty and [6,8] one would be scheduled at that time. And how is the output given as 1."
                    },
                    {
                        "username": "superZero",
                        "content": "Is the solution flawed?  I see that the solution is to delay 1 meeting till 1 room becomes available.\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                current_end, room = heappop(running_meetings)\\n                new_end = current_end + meetings[i][1] - meetings[i][0]  # Update the room\\'s end time\\n                heappush(running_meetings, (new_end, room))\\n\\n            meetings_per_room[room] +=1\\n            i +=1\\n\\nBut reality should be that all the remaining meetings whose start time is < end_time of the 1st available room should be delayed.\\n\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                for j in range (i, size):\\n                    if meetings[j][0] < running_meetings[0][0]:\\n                        meetings[j][0] += delta \\n                        meetings[j][1] +=delta\\n                    else:\\n                        break\\n\\n"
                    },
                    {
                        "username": "jj3100",
                        "content": "I used Integer types and finally managed to pass all tests. The main issue that caused me to fail on the 80/82 and 81/82 test cases is that when the end times are equal, the PriorityQueue should also compare the room numbers."
                    },
                    {
                        "username": "magomez4",
                        "content": "Passing 82 test cases but TLE? My code is the same idea as others I\\'m seeing in the submissions, and it passes all test cases, but I get a TLE and it says \"82/82\" test cases passed. It also says that the last executed input is \"n=\" yes.. a blank \\'n\\'. Can anyone tell me if this is a leetcode problem or what am I doing wrong? Any help is greatly appreciated!! \\n\\nHere is my approach:\\n ```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // keep an array for the number of bookings of\\n        // each room.\\n        // also keep a mostBooked variable that gets\\n        // updated every time a room is used.\\n        // To assign a meeting to a room, check if\\n        // the meeting starts before the earliest-finishing\\n        // scheduled meeting. If so, assign a new room. If\\n        // there are no more rooms, wait until the earliest\\n        // finishing room, and use that one. If the meeting\\n        // starts after the earliest-finishing room becomes \\n        // free, then continue to \"free-up\" rooms until\\n        // there are no rooms booked or the earliest finishing\\n        // is later than the current start time. After this,\\n        // use the same logic as above to assign the next\\n        // available room.\\n\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        // ensure meetings are sorted by start time\\n        sort(meetings.begin(),meetings.end(), comparator);\\n\\n        int bookingCount[n];\\n        fill_n(bookingCount, n, 0);\\n        int mostBooked = -1;\\n        // We declare a min-heap that holds <endTime, roomNumber> \\n        // to keep the min end time at the front.\\n        priority_queue<vector<long>, vector<vector<long>>, greater<vector<long>>> freeAt; \\n        priority_queue<int,vector<int>,greater<int>> emptyRooms;\\n        for(int i = 0; i < n; i++)\\n        {\\n            emptyRooms.push(i);\\n        }\\n\\n        for(int i = 0; i < meetings.size(); i++)\\n        {\\n            if(mostBooked == -1)\\n            {\\n                mostBooked = 0;\\n                bookingCount[mostBooked]++;\\n                vector<long> newFreeAt = {meetings[i][1], mostBooked}; \\n                freeAt.push(newFreeAt);\\n                emptyRooms.pop();\\n            }\\n            else\\n            {\\n                // if(meetings[i][0] < freeAt.top().first )\\n                if(meetings[i][0] < freeAt.top()[0] )\\n                {\\n                    // current meeting start time is earlier\\n                    // than the earliest-finishing scheduled meeting\\n                    if(freeAt.size() < n)\\n                    {\\n                        // there are available rooms, so book the next available\\n                        vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                    else\\n                    {\\n                        // there are no more available rooms, so this will haven\\n                        // to wait for the earliest finishing scheduled meeting\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        int meetingDuration = meetings[i][1] - meetings[i][0];//end time - start time\\n                        long newEndTime = freeAt.top()[0] + meetingDuration;\\n                        freeAt.pop();\\n                        vector<long> newFreeAt = {newEndTime, emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                }\\n                else\\n                {\\n                    // current meeting start time is later than the earliest\\n                    // finishing scheduled meeting. \\n                    while(!freeAt.empty() \\n                    && meetings[i][0] >= freeAt.top()[0])\\n                    {\\n                        // let the meetings finish to make sure \\n                        // we get the room with the smallest number\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        freeAt.pop();\\n                    }\\n                    vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                    freeAt.push(newFreeAt);\\n                    bookingCount[emptyRooms.top()]++;\\n                    mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                    emptyRooms.pop();\\n                }\\n            }\\n        }\\n        return mostBooked;\\n    }\\n    static bool comparator(vector<int> a, vector<int> b)\\n    {\\n        if(a[0] <= b[0])\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int updateMostBooked(int mostBooked, int newlyBooked, int bookingCount[])\\n    {\\n        int newMostBooked;\\n        if(bookingCount[newlyBooked] > bookingCount[mostBooked])\\n        {\\n            newMostBooked = newlyBooked;\\n        }\\n        else if (bookingCount[newlyBooked] == bookingCount[mostBooked])\\n        {\\n            // if two rooms have the same amount of meetings,\\n            // we consider the room with the smallest ID as \\n            // the most booked\\n            newMostBooked = min(newlyBooked, mostBooked);\\n        }\\n        else\\n        {\\n            newMostBooked = mostBooked;\\n        }\\n        return newMostBooked;\\n    }\\n};\\n```\\n"
                    }
                ]
            },
            {
                "id": 1941456,
                "content": [
                    {
                        "username": "quanyincode",
                        "content": "If you are wondering why your solution past 80/82 test cases, it it due to the two test cases with long inputs, which will cause integer overflow on the meeting end time. Use Long instead of Integer to track a room\\'s end time should solve the problem."
                    },
                    {
                        "username": "jerome1210",
                        "content": "May someone explain why this meetings [[0,10],[1,9],[2,8],[3,7],[4,6]] will return 1?\nI thought it should be \n1. room: 0, time 10 (0+10)\n2. room: 1, time 10 (1+9)\n3. room: 2, time 10 (2+8)\n4. room: 0, time 17 (10+7)\n5. room: 1, time 16 (10 + 6)\n\nSo, the room 0, 1 will held 2 meetings, then it should return 0 ?\n"
                    },
                    {
                        "username": "user0081T",
                        "content": "The second meeting will end at time: 9 not 10, same thing for the third meeting, it will end at time 8, not 10.  Because the the second argument for each meeting is the end time of the meeting and not the duration of it. "
                    },
                    {
                        "username": "shru15",
                        "content": "After meeting 3, the earliest free room will be room 2\\nso [3,7] -> [3+8, 7+8] at room 2\\nand 4,6 -> [4+9, 6+9] at room 1\\nsince room 0 gets freed at last, only one meeting will take place there."
                    },
                    {
                        "username": "anshil1611",
                        "content": "For the people who are confused with WA at 80/82:\\n\\nI am seeing lot of comments where people are saying its because of integer overflow. Seemingly true, however if you are using a PriorityQueue of type Pair<Integer, Integer>, that is where all the problem is occurring. Just change the type of the priority queue from Pair<Integer, Integer> to int[] (yes, no Long required) and your solution would pass the remaining test cases.\\n\\nIt seems like Pair<Integer, Integer> is not able to handle large values, and the same code which fails with Pair<Integer, Integer>, passes all test cases with int[]."
                    },
                    {
                        "username": "spark6015",
                        "content": "are we even allow to use heapq.heapify() function in the interview?"
                    },
                    {
                        "username": "strangeranda",
                        "content": "Yes, you could ask the interviewer if you could use built-in functions, and 10/10 they\\u2019d say yes. I could be wrong in 10/10, but I never faced any instance where I couldn\\u2019t use. "
                    },
                    {
                        "username": "Tanayk",
                        "content": "Can someone please help me identify the error in this code? 80/82 test cases are passing. \\nThank you\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        rooms = collections.defaultdict(int)\\n        meetings.sort()\\n        booked, free = [], []\\n        max_meets = 0\\n        for i in range(n):\\n            heapq.heappush(booked, (0, i))\\n\\n        i, curr_time = 0, meetings[0][0]\\n        while i < len(meetings):\\n            while booked and booked[0][0] <= curr_time:\\n                free_time, index = heapq.heappop(booked)\\n                heapq.heappush(free, (index, free_time))\\n\\n            if not free:\\n                curr_time = booked[0][0]\\n                continue\\n\\n            room_id, _ = heapq.heappop(free)\\n            rooms[room_id] += 1\\n            max_meets = max(max_meets, rooms[room_id])\\n            heapq.heappush(booked, (curr_time + (meetings[i][1] - meetings[i][0]), room_id))\\n            curr_time = meetings[i+1][0] if i + 1 < len(meetings) else curr_time\\n            i += 1\\n\\n        for i in range(n):\\n            if rooms[i] == max_meets:\\n                return i\\n```"
                    },
                    {
                        "username": "frog445",
                        "content": "[@quanyincode](/quanyincode) It\\'s python lol why will it have integer overflow"
                    },
                    {
                        "username": "quanyincode",
                        "content": "See my comment about the two test cases that cause integer overflow."
                    },
                    {
                        "username": "jffiorillo",
                        "content": "Regarding this test: `[[1,27],[29,49],[47,49],[41,43],[15,36],[11,15]]` in theory the output is `1` but I did it manually and the output is `0`. Can you please explain me why the output is `1`?\\n\\nThe following is the explanation why I think the answer is `0`\\n\\n```\\n// Meetings ordered by start time : [Meeting(start=1, finish=27), Meeting(start=11, finish=15), Meeting(start=15, finish=36), Meeting(start=29, finish=49), Meeting(start=41, finish=43), Meeting(start=47, finish=49)]\\n\\nfirst meeting = Meeting(start=1, finish=27)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=0, numberOfMeetings=0), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nsecond meeting = Meeting(start=11, finish=15)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=15, numberOfMeetings=1), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nthird meeting = Meeting(start=15, finish=36)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nforth meeting  = Meeting(start=29, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nfifth meeting = Meeting(start=41, finish=43)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=43, numberOfMeetings=1)]\\n\\nlast meeting = Meeting(start=47, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=92, numberOfMeetings=2)]\\n\\nAll room has been booking twice, so the answer is 0.\\n```"
                    },
                    {
                        "username": "vandanakumari13998",
                        "content": "Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\\nI didn\\'t get this example. How is the output 0. Because at time 8, [4,9] meeting will end. Hence 2 meeting room will be empty and [6,8] one would be scheduled at that time. And how is the output given as 1."
                    },
                    {
                        "username": "superZero",
                        "content": "Is the solution flawed?  I see that the solution is to delay 1 meeting till 1 room becomes available.\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                current_end, room = heappop(running_meetings)\\n                new_end = current_end + meetings[i][1] - meetings[i][0]  # Update the room\\'s end time\\n                heappush(running_meetings, (new_end, room))\\n\\n            meetings_per_room[room] +=1\\n            i +=1\\n\\nBut reality should be that all the remaining meetings whose start time is < end_time of the 1st available room should be delayed.\\n\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                for j in range (i, size):\\n                    if meetings[j][0] < running_meetings[0][0]:\\n                        meetings[j][0] += delta \\n                        meetings[j][1] +=delta\\n                    else:\\n                        break\\n\\n"
                    },
                    {
                        "username": "jj3100",
                        "content": "I used Integer types and finally managed to pass all tests. The main issue that caused me to fail on the 80/82 and 81/82 test cases is that when the end times are equal, the PriorityQueue should also compare the room numbers."
                    },
                    {
                        "username": "magomez4",
                        "content": "Passing 82 test cases but TLE? My code is the same idea as others I\\'m seeing in the submissions, and it passes all test cases, but I get a TLE and it says \"82/82\" test cases passed. It also says that the last executed input is \"n=\" yes.. a blank \\'n\\'. Can anyone tell me if this is a leetcode problem or what am I doing wrong? Any help is greatly appreciated!! \\n\\nHere is my approach:\\n ```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // keep an array for the number of bookings of\\n        // each room.\\n        // also keep a mostBooked variable that gets\\n        // updated every time a room is used.\\n        // To assign a meeting to a room, check if\\n        // the meeting starts before the earliest-finishing\\n        // scheduled meeting. If so, assign a new room. If\\n        // there are no more rooms, wait until the earliest\\n        // finishing room, and use that one. If the meeting\\n        // starts after the earliest-finishing room becomes \\n        // free, then continue to \"free-up\" rooms until\\n        // there are no rooms booked or the earliest finishing\\n        // is later than the current start time. After this,\\n        // use the same logic as above to assign the next\\n        // available room.\\n\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        // ensure meetings are sorted by start time\\n        sort(meetings.begin(),meetings.end(), comparator);\\n\\n        int bookingCount[n];\\n        fill_n(bookingCount, n, 0);\\n        int mostBooked = -1;\\n        // We declare a min-heap that holds <endTime, roomNumber> \\n        // to keep the min end time at the front.\\n        priority_queue<vector<long>, vector<vector<long>>, greater<vector<long>>> freeAt; \\n        priority_queue<int,vector<int>,greater<int>> emptyRooms;\\n        for(int i = 0; i < n; i++)\\n        {\\n            emptyRooms.push(i);\\n        }\\n\\n        for(int i = 0; i < meetings.size(); i++)\\n        {\\n            if(mostBooked == -1)\\n            {\\n                mostBooked = 0;\\n                bookingCount[mostBooked]++;\\n                vector<long> newFreeAt = {meetings[i][1], mostBooked}; \\n                freeAt.push(newFreeAt);\\n                emptyRooms.pop();\\n            }\\n            else\\n            {\\n                // if(meetings[i][0] < freeAt.top().first )\\n                if(meetings[i][0] < freeAt.top()[0] )\\n                {\\n                    // current meeting start time is earlier\\n                    // than the earliest-finishing scheduled meeting\\n                    if(freeAt.size() < n)\\n                    {\\n                        // there are available rooms, so book the next available\\n                        vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                    else\\n                    {\\n                        // there are no more available rooms, so this will haven\\n                        // to wait for the earliest finishing scheduled meeting\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        int meetingDuration = meetings[i][1] - meetings[i][0];//end time - start time\\n                        long newEndTime = freeAt.top()[0] + meetingDuration;\\n                        freeAt.pop();\\n                        vector<long> newFreeAt = {newEndTime, emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                }\\n                else\\n                {\\n                    // current meeting start time is later than the earliest\\n                    // finishing scheduled meeting. \\n                    while(!freeAt.empty() \\n                    && meetings[i][0] >= freeAt.top()[0])\\n                    {\\n                        // let the meetings finish to make sure \\n                        // we get the room with the smallest number\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        freeAt.pop();\\n                    }\\n                    vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                    freeAt.push(newFreeAt);\\n                    bookingCount[emptyRooms.top()]++;\\n                    mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                    emptyRooms.pop();\\n                }\\n            }\\n        }\\n        return mostBooked;\\n    }\\n    static bool comparator(vector<int> a, vector<int> b)\\n    {\\n        if(a[0] <= b[0])\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int updateMostBooked(int mostBooked, int newlyBooked, int bookingCount[])\\n    {\\n        int newMostBooked;\\n        if(bookingCount[newlyBooked] > bookingCount[mostBooked])\\n        {\\n            newMostBooked = newlyBooked;\\n        }\\n        else if (bookingCount[newlyBooked] == bookingCount[mostBooked])\\n        {\\n            // if two rooms have the same amount of meetings,\\n            // we consider the room with the smallest ID as \\n            // the most booked\\n            newMostBooked = min(newlyBooked, mostBooked);\\n        }\\n        else\\n        {\\n            newMostBooked = mostBooked;\\n        }\\n        return newMostBooked;\\n    }\\n};\\n```\\n"
                    }
                ]
            },
            {
                "id": 2070608,
                "content": [
                    {
                        "username": "quanyincode",
                        "content": "If you are wondering why your solution past 80/82 test cases, it it due to the two test cases with long inputs, which will cause integer overflow on the meeting end time. Use Long instead of Integer to track a room\\'s end time should solve the problem."
                    },
                    {
                        "username": "jerome1210",
                        "content": "May someone explain why this meetings [[0,10],[1,9],[2,8],[3,7],[4,6]] will return 1?\nI thought it should be \n1. room: 0, time 10 (0+10)\n2. room: 1, time 10 (1+9)\n3. room: 2, time 10 (2+8)\n4. room: 0, time 17 (10+7)\n5. room: 1, time 16 (10 + 6)\n\nSo, the room 0, 1 will held 2 meetings, then it should return 0 ?\n"
                    },
                    {
                        "username": "user0081T",
                        "content": "The second meeting will end at time: 9 not 10, same thing for the third meeting, it will end at time 8, not 10.  Because the the second argument for each meeting is the end time of the meeting and not the duration of it. "
                    },
                    {
                        "username": "shru15",
                        "content": "After meeting 3, the earliest free room will be room 2\\nso [3,7] -> [3+8, 7+8] at room 2\\nand 4,6 -> [4+9, 6+9] at room 1\\nsince room 0 gets freed at last, only one meeting will take place there."
                    },
                    {
                        "username": "anshil1611",
                        "content": "For the people who are confused with WA at 80/82:\\n\\nI am seeing lot of comments where people are saying its because of integer overflow. Seemingly true, however if you are using a PriorityQueue of type Pair<Integer, Integer>, that is where all the problem is occurring. Just change the type of the priority queue from Pair<Integer, Integer> to int[] (yes, no Long required) and your solution would pass the remaining test cases.\\n\\nIt seems like Pair<Integer, Integer> is not able to handle large values, and the same code which fails with Pair<Integer, Integer>, passes all test cases with int[]."
                    },
                    {
                        "username": "spark6015",
                        "content": "are we even allow to use heapq.heapify() function in the interview?"
                    },
                    {
                        "username": "strangeranda",
                        "content": "Yes, you could ask the interviewer if you could use built-in functions, and 10/10 they\\u2019d say yes. I could be wrong in 10/10, but I never faced any instance where I couldn\\u2019t use. "
                    },
                    {
                        "username": "Tanayk",
                        "content": "Can someone please help me identify the error in this code? 80/82 test cases are passing. \\nThank you\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        rooms = collections.defaultdict(int)\\n        meetings.sort()\\n        booked, free = [], []\\n        max_meets = 0\\n        for i in range(n):\\n            heapq.heappush(booked, (0, i))\\n\\n        i, curr_time = 0, meetings[0][0]\\n        while i < len(meetings):\\n            while booked and booked[0][0] <= curr_time:\\n                free_time, index = heapq.heappop(booked)\\n                heapq.heappush(free, (index, free_time))\\n\\n            if not free:\\n                curr_time = booked[0][0]\\n                continue\\n\\n            room_id, _ = heapq.heappop(free)\\n            rooms[room_id] += 1\\n            max_meets = max(max_meets, rooms[room_id])\\n            heapq.heappush(booked, (curr_time + (meetings[i][1] - meetings[i][0]), room_id))\\n            curr_time = meetings[i+1][0] if i + 1 < len(meetings) else curr_time\\n            i += 1\\n\\n        for i in range(n):\\n            if rooms[i] == max_meets:\\n                return i\\n```"
                    },
                    {
                        "username": "frog445",
                        "content": "[@quanyincode](/quanyincode) It\\'s python lol why will it have integer overflow"
                    },
                    {
                        "username": "quanyincode",
                        "content": "See my comment about the two test cases that cause integer overflow."
                    },
                    {
                        "username": "jffiorillo",
                        "content": "Regarding this test: `[[1,27],[29,49],[47,49],[41,43],[15,36],[11,15]]` in theory the output is `1` but I did it manually and the output is `0`. Can you please explain me why the output is `1`?\\n\\nThe following is the explanation why I think the answer is `0`\\n\\n```\\n// Meetings ordered by start time : [Meeting(start=1, finish=27), Meeting(start=11, finish=15), Meeting(start=15, finish=36), Meeting(start=29, finish=49), Meeting(start=41, finish=43), Meeting(start=47, finish=49)]\\n\\nfirst meeting = Meeting(start=1, finish=27)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=0, numberOfMeetings=0), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nsecond meeting = Meeting(start=11, finish=15)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=15, numberOfMeetings=1), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nthird meeting = Meeting(start=15, finish=36)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nforth meeting  = Meeting(start=29, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nfifth meeting = Meeting(start=41, finish=43)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=43, numberOfMeetings=1)]\\n\\nlast meeting = Meeting(start=47, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=92, numberOfMeetings=2)]\\n\\nAll room has been booking twice, so the answer is 0.\\n```"
                    },
                    {
                        "username": "vandanakumari13998",
                        "content": "Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\\nI didn\\'t get this example. How is the output 0. Because at time 8, [4,9] meeting will end. Hence 2 meeting room will be empty and [6,8] one would be scheduled at that time. And how is the output given as 1."
                    },
                    {
                        "username": "superZero",
                        "content": "Is the solution flawed?  I see that the solution is to delay 1 meeting till 1 room becomes available.\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                current_end, room = heappop(running_meetings)\\n                new_end = current_end + meetings[i][1] - meetings[i][0]  # Update the room\\'s end time\\n                heappush(running_meetings, (new_end, room))\\n\\n            meetings_per_room[room] +=1\\n            i +=1\\n\\nBut reality should be that all the remaining meetings whose start time is < end_time of the 1st available room should be delayed.\\n\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                for j in range (i, size):\\n                    if meetings[j][0] < running_meetings[0][0]:\\n                        meetings[j][0] += delta \\n                        meetings[j][1] +=delta\\n                    else:\\n                        break\\n\\n"
                    },
                    {
                        "username": "jj3100",
                        "content": "I used Integer types and finally managed to pass all tests. The main issue that caused me to fail on the 80/82 and 81/82 test cases is that when the end times are equal, the PriorityQueue should also compare the room numbers."
                    },
                    {
                        "username": "magomez4",
                        "content": "Passing 82 test cases but TLE? My code is the same idea as others I\\'m seeing in the submissions, and it passes all test cases, but I get a TLE and it says \"82/82\" test cases passed. It also says that the last executed input is \"n=\" yes.. a blank \\'n\\'. Can anyone tell me if this is a leetcode problem or what am I doing wrong? Any help is greatly appreciated!! \\n\\nHere is my approach:\\n ```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // keep an array for the number of bookings of\\n        // each room.\\n        // also keep a mostBooked variable that gets\\n        // updated every time a room is used.\\n        // To assign a meeting to a room, check if\\n        // the meeting starts before the earliest-finishing\\n        // scheduled meeting. If so, assign a new room. If\\n        // there are no more rooms, wait until the earliest\\n        // finishing room, and use that one. If the meeting\\n        // starts after the earliest-finishing room becomes \\n        // free, then continue to \"free-up\" rooms until\\n        // there are no rooms booked or the earliest finishing\\n        // is later than the current start time. After this,\\n        // use the same logic as above to assign the next\\n        // available room.\\n\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        // ensure meetings are sorted by start time\\n        sort(meetings.begin(),meetings.end(), comparator);\\n\\n        int bookingCount[n];\\n        fill_n(bookingCount, n, 0);\\n        int mostBooked = -1;\\n        // We declare a min-heap that holds <endTime, roomNumber> \\n        // to keep the min end time at the front.\\n        priority_queue<vector<long>, vector<vector<long>>, greater<vector<long>>> freeAt; \\n        priority_queue<int,vector<int>,greater<int>> emptyRooms;\\n        for(int i = 0; i < n; i++)\\n        {\\n            emptyRooms.push(i);\\n        }\\n\\n        for(int i = 0; i < meetings.size(); i++)\\n        {\\n            if(mostBooked == -1)\\n            {\\n                mostBooked = 0;\\n                bookingCount[mostBooked]++;\\n                vector<long> newFreeAt = {meetings[i][1], mostBooked}; \\n                freeAt.push(newFreeAt);\\n                emptyRooms.pop();\\n            }\\n            else\\n            {\\n                // if(meetings[i][0] < freeAt.top().first )\\n                if(meetings[i][0] < freeAt.top()[0] )\\n                {\\n                    // current meeting start time is earlier\\n                    // than the earliest-finishing scheduled meeting\\n                    if(freeAt.size() < n)\\n                    {\\n                        // there are available rooms, so book the next available\\n                        vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                    else\\n                    {\\n                        // there are no more available rooms, so this will haven\\n                        // to wait for the earliest finishing scheduled meeting\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        int meetingDuration = meetings[i][1] - meetings[i][0];//end time - start time\\n                        long newEndTime = freeAt.top()[0] + meetingDuration;\\n                        freeAt.pop();\\n                        vector<long> newFreeAt = {newEndTime, emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                }\\n                else\\n                {\\n                    // current meeting start time is later than the earliest\\n                    // finishing scheduled meeting. \\n                    while(!freeAt.empty() \\n                    && meetings[i][0] >= freeAt.top()[0])\\n                    {\\n                        // let the meetings finish to make sure \\n                        // we get the room with the smallest number\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        freeAt.pop();\\n                    }\\n                    vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                    freeAt.push(newFreeAt);\\n                    bookingCount[emptyRooms.top()]++;\\n                    mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                    emptyRooms.pop();\\n                }\\n            }\\n        }\\n        return mostBooked;\\n    }\\n    static bool comparator(vector<int> a, vector<int> b)\\n    {\\n        if(a[0] <= b[0])\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int updateMostBooked(int mostBooked, int newlyBooked, int bookingCount[])\\n    {\\n        int newMostBooked;\\n        if(bookingCount[newlyBooked] > bookingCount[mostBooked])\\n        {\\n            newMostBooked = newlyBooked;\\n        }\\n        else if (bookingCount[newlyBooked] == bookingCount[mostBooked])\\n        {\\n            // if two rooms have the same amount of meetings,\\n            // we consider the room with the smallest ID as \\n            // the most booked\\n            newMostBooked = min(newlyBooked, mostBooked);\\n        }\\n        else\\n        {\\n            newMostBooked = mostBooked;\\n        }\\n        return newMostBooked;\\n    }\\n};\\n```\\n"
                    }
                ]
            },
            {
                "id": 1777141,
                "content": [
                    {
                        "username": "quanyincode",
                        "content": "If you are wondering why your solution past 80/82 test cases, it it due to the two test cases with long inputs, which will cause integer overflow on the meeting end time. Use Long instead of Integer to track a room\\'s end time should solve the problem."
                    },
                    {
                        "username": "jerome1210",
                        "content": "May someone explain why this meetings [[0,10],[1,9],[2,8],[3,7],[4,6]] will return 1?\nI thought it should be \n1. room: 0, time 10 (0+10)\n2. room: 1, time 10 (1+9)\n3. room: 2, time 10 (2+8)\n4. room: 0, time 17 (10+7)\n5. room: 1, time 16 (10 + 6)\n\nSo, the room 0, 1 will held 2 meetings, then it should return 0 ?\n"
                    },
                    {
                        "username": "user0081T",
                        "content": "The second meeting will end at time: 9 not 10, same thing for the third meeting, it will end at time 8, not 10.  Because the the second argument for each meeting is the end time of the meeting and not the duration of it. "
                    },
                    {
                        "username": "shru15",
                        "content": "After meeting 3, the earliest free room will be room 2\\nso [3,7] -> [3+8, 7+8] at room 2\\nand 4,6 -> [4+9, 6+9] at room 1\\nsince room 0 gets freed at last, only one meeting will take place there."
                    },
                    {
                        "username": "anshil1611",
                        "content": "For the people who are confused with WA at 80/82:\\n\\nI am seeing lot of comments where people are saying its because of integer overflow. Seemingly true, however if you are using a PriorityQueue of type Pair<Integer, Integer>, that is where all the problem is occurring. Just change the type of the priority queue from Pair<Integer, Integer> to int[] (yes, no Long required) and your solution would pass the remaining test cases.\\n\\nIt seems like Pair<Integer, Integer> is not able to handle large values, and the same code which fails with Pair<Integer, Integer>, passes all test cases with int[]."
                    },
                    {
                        "username": "spark6015",
                        "content": "are we even allow to use heapq.heapify() function in the interview?"
                    },
                    {
                        "username": "strangeranda",
                        "content": "Yes, you could ask the interviewer if you could use built-in functions, and 10/10 they\\u2019d say yes. I could be wrong in 10/10, but I never faced any instance where I couldn\\u2019t use. "
                    },
                    {
                        "username": "Tanayk",
                        "content": "Can someone please help me identify the error in this code? 80/82 test cases are passing. \\nThank you\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        rooms = collections.defaultdict(int)\\n        meetings.sort()\\n        booked, free = [], []\\n        max_meets = 0\\n        for i in range(n):\\n            heapq.heappush(booked, (0, i))\\n\\n        i, curr_time = 0, meetings[0][0]\\n        while i < len(meetings):\\n            while booked and booked[0][0] <= curr_time:\\n                free_time, index = heapq.heappop(booked)\\n                heapq.heappush(free, (index, free_time))\\n\\n            if not free:\\n                curr_time = booked[0][0]\\n                continue\\n\\n            room_id, _ = heapq.heappop(free)\\n            rooms[room_id] += 1\\n            max_meets = max(max_meets, rooms[room_id])\\n            heapq.heappush(booked, (curr_time + (meetings[i][1] - meetings[i][0]), room_id))\\n            curr_time = meetings[i+1][0] if i + 1 < len(meetings) else curr_time\\n            i += 1\\n\\n        for i in range(n):\\n            if rooms[i] == max_meets:\\n                return i\\n```"
                    },
                    {
                        "username": "frog445",
                        "content": "[@quanyincode](/quanyincode) It\\'s python lol why will it have integer overflow"
                    },
                    {
                        "username": "quanyincode",
                        "content": "See my comment about the two test cases that cause integer overflow."
                    },
                    {
                        "username": "jffiorillo",
                        "content": "Regarding this test: `[[1,27],[29,49],[47,49],[41,43],[15,36],[11,15]]` in theory the output is `1` but I did it manually and the output is `0`. Can you please explain me why the output is `1`?\\n\\nThe following is the explanation why I think the answer is `0`\\n\\n```\\n// Meetings ordered by start time : [Meeting(start=1, finish=27), Meeting(start=11, finish=15), Meeting(start=15, finish=36), Meeting(start=29, finish=49), Meeting(start=41, finish=43), Meeting(start=47, finish=49)]\\n\\nfirst meeting = Meeting(start=1, finish=27)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=0, numberOfMeetings=0), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nsecond meeting = Meeting(start=11, finish=15)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=15, numberOfMeetings=1), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nthird meeting = Meeting(start=15, finish=36)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nforth meeting  = Meeting(start=29, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nfifth meeting = Meeting(start=41, finish=43)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=43, numberOfMeetings=1)]\\n\\nlast meeting = Meeting(start=47, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=92, numberOfMeetings=2)]\\n\\nAll room has been booking twice, so the answer is 0.\\n```"
                    },
                    {
                        "username": "vandanakumari13998",
                        "content": "Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\\nI didn\\'t get this example. How is the output 0. Because at time 8, [4,9] meeting will end. Hence 2 meeting room will be empty and [6,8] one would be scheduled at that time. And how is the output given as 1."
                    },
                    {
                        "username": "superZero",
                        "content": "Is the solution flawed?  I see that the solution is to delay 1 meeting till 1 room becomes available.\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                current_end, room = heappop(running_meetings)\\n                new_end = current_end + meetings[i][1] - meetings[i][0]  # Update the room\\'s end time\\n                heappush(running_meetings, (new_end, room))\\n\\n            meetings_per_room[room] +=1\\n            i +=1\\n\\nBut reality should be that all the remaining meetings whose start time is < end_time of the 1st available room should be delayed.\\n\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                for j in range (i, size):\\n                    if meetings[j][0] < running_meetings[0][0]:\\n                        meetings[j][0] += delta \\n                        meetings[j][1] +=delta\\n                    else:\\n                        break\\n\\n"
                    },
                    {
                        "username": "jj3100",
                        "content": "I used Integer types and finally managed to pass all tests. The main issue that caused me to fail on the 80/82 and 81/82 test cases is that when the end times are equal, the PriorityQueue should also compare the room numbers."
                    },
                    {
                        "username": "magomez4",
                        "content": "Passing 82 test cases but TLE? My code is the same idea as others I\\'m seeing in the submissions, and it passes all test cases, but I get a TLE and it says \"82/82\" test cases passed. It also says that the last executed input is \"n=\" yes.. a blank \\'n\\'. Can anyone tell me if this is a leetcode problem or what am I doing wrong? Any help is greatly appreciated!! \\n\\nHere is my approach:\\n ```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // keep an array for the number of bookings of\\n        // each room.\\n        // also keep a mostBooked variable that gets\\n        // updated every time a room is used.\\n        // To assign a meeting to a room, check if\\n        // the meeting starts before the earliest-finishing\\n        // scheduled meeting. If so, assign a new room. If\\n        // there are no more rooms, wait until the earliest\\n        // finishing room, and use that one. If the meeting\\n        // starts after the earliest-finishing room becomes \\n        // free, then continue to \"free-up\" rooms until\\n        // there are no rooms booked or the earliest finishing\\n        // is later than the current start time. After this,\\n        // use the same logic as above to assign the next\\n        // available room.\\n\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        // ensure meetings are sorted by start time\\n        sort(meetings.begin(),meetings.end(), comparator);\\n\\n        int bookingCount[n];\\n        fill_n(bookingCount, n, 0);\\n        int mostBooked = -1;\\n        // We declare a min-heap that holds <endTime, roomNumber> \\n        // to keep the min end time at the front.\\n        priority_queue<vector<long>, vector<vector<long>>, greater<vector<long>>> freeAt; \\n        priority_queue<int,vector<int>,greater<int>> emptyRooms;\\n        for(int i = 0; i < n; i++)\\n        {\\n            emptyRooms.push(i);\\n        }\\n\\n        for(int i = 0; i < meetings.size(); i++)\\n        {\\n            if(mostBooked == -1)\\n            {\\n                mostBooked = 0;\\n                bookingCount[mostBooked]++;\\n                vector<long> newFreeAt = {meetings[i][1], mostBooked}; \\n                freeAt.push(newFreeAt);\\n                emptyRooms.pop();\\n            }\\n            else\\n            {\\n                // if(meetings[i][0] < freeAt.top().first )\\n                if(meetings[i][0] < freeAt.top()[0] )\\n                {\\n                    // current meeting start time is earlier\\n                    // than the earliest-finishing scheduled meeting\\n                    if(freeAt.size() < n)\\n                    {\\n                        // there are available rooms, so book the next available\\n                        vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                    else\\n                    {\\n                        // there are no more available rooms, so this will haven\\n                        // to wait for the earliest finishing scheduled meeting\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        int meetingDuration = meetings[i][1] - meetings[i][0];//end time - start time\\n                        long newEndTime = freeAt.top()[0] + meetingDuration;\\n                        freeAt.pop();\\n                        vector<long> newFreeAt = {newEndTime, emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                }\\n                else\\n                {\\n                    // current meeting start time is later than the earliest\\n                    // finishing scheduled meeting. \\n                    while(!freeAt.empty() \\n                    && meetings[i][0] >= freeAt.top()[0])\\n                    {\\n                        // let the meetings finish to make sure \\n                        // we get the room with the smallest number\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        freeAt.pop();\\n                    }\\n                    vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                    freeAt.push(newFreeAt);\\n                    bookingCount[emptyRooms.top()]++;\\n                    mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                    emptyRooms.pop();\\n                }\\n            }\\n        }\\n        return mostBooked;\\n    }\\n    static bool comparator(vector<int> a, vector<int> b)\\n    {\\n        if(a[0] <= b[0])\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int updateMostBooked(int mostBooked, int newlyBooked, int bookingCount[])\\n    {\\n        int newMostBooked;\\n        if(bookingCount[newlyBooked] > bookingCount[mostBooked])\\n        {\\n            newMostBooked = newlyBooked;\\n        }\\n        else if (bookingCount[newlyBooked] == bookingCount[mostBooked])\\n        {\\n            // if two rooms have the same amount of meetings,\\n            // we consider the room with the smallest ID as \\n            // the most booked\\n            newMostBooked = min(newlyBooked, mostBooked);\\n        }\\n        else\\n        {\\n            newMostBooked = mostBooked;\\n        }\\n        return newMostBooked;\\n    }\\n};\\n```\\n"
                    }
                ]
            },
            {
                "id": 1705712,
                "content": [
                    {
                        "username": "quanyincode",
                        "content": "If you are wondering why your solution past 80/82 test cases, it it due to the two test cases with long inputs, which will cause integer overflow on the meeting end time. Use Long instead of Integer to track a room\\'s end time should solve the problem."
                    },
                    {
                        "username": "jerome1210",
                        "content": "May someone explain why this meetings [[0,10],[1,9],[2,8],[3,7],[4,6]] will return 1?\nI thought it should be \n1. room: 0, time 10 (0+10)\n2. room: 1, time 10 (1+9)\n3. room: 2, time 10 (2+8)\n4. room: 0, time 17 (10+7)\n5. room: 1, time 16 (10 + 6)\n\nSo, the room 0, 1 will held 2 meetings, then it should return 0 ?\n"
                    },
                    {
                        "username": "user0081T",
                        "content": "The second meeting will end at time: 9 not 10, same thing for the third meeting, it will end at time 8, not 10.  Because the the second argument for each meeting is the end time of the meeting and not the duration of it. "
                    },
                    {
                        "username": "shru15",
                        "content": "After meeting 3, the earliest free room will be room 2\\nso [3,7] -> [3+8, 7+8] at room 2\\nand 4,6 -> [4+9, 6+9] at room 1\\nsince room 0 gets freed at last, only one meeting will take place there."
                    },
                    {
                        "username": "anshil1611",
                        "content": "For the people who are confused with WA at 80/82:\\n\\nI am seeing lot of comments where people are saying its because of integer overflow. Seemingly true, however if you are using a PriorityQueue of type Pair<Integer, Integer>, that is where all the problem is occurring. Just change the type of the priority queue from Pair<Integer, Integer> to int[] (yes, no Long required) and your solution would pass the remaining test cases.\\n\\nIt seems like Pair<Integer, Integer> is not able to handle large values, and the same code which fails with Pair<Integer, Integer>, passes all test cases with int[]."
                    },
                    {
                        "username": "spark6015",
                        "content": "are we even allow to use heapq.heapify() function in the interview?"
                    },
                    {
                        "username": "strangeranda",
                        "content": "Yes, you could ask the interviewer if you could use built-in functions, and 10/10 they\\u2019d say yes. I could be wrong in 10/10, but I never faced any instance where I couldn\\u2019t use. "
                    },
                    {
                        "username": "Tanayk",
                        "content": "Can someone please help me identify the error in this code? 80/82 test cases are passing. \\nThank you\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        rooms = collections.defaultdict(int)\\n        meetings.sort()\\n        booked, free = [], []\\n        max_meets = 0\\n        for i in range(n):\\n            heapq.heappush(booked, (0, i))\\n\\n        i, curr_time = 0, meetings[0][0]\\n        while i < len(meetings):\\n            while booked and booked[0][0] <= curr_time:\\n                free_time, index = heapq.heappop(booked)\\n                heapq.heappush(free, (index, free_time))\\n\\n            if not free:\\n                curr_time = booked[0][0]\\n                continue\\n\\n            room_id, _ = heapq.heappop(free)\\n            rooms[room_id] += 1\\n            max_meets = max(max_meets, rooms[room_id])\\n            heapq.heappush(booked, (curr_time + (meetings[i][1] - meetings[i][0]), room_id))\\n            curr_time = meetings[i+1][0] if i + 1 < len(meetings) else curr_time\\n            i += 1\\n\\n        for i in range(n):\\n            if rooms[i] == max_meets:\\n                return i\\n```"
                    },
                    {
                        "username": "frog445",
                        "content": "[@quanyincode](/quanyincode) It\\'s python lol why will it have integer overflow"
                    },
                    {
                        "username": "quanyincode",
                        "content": "See my comment about the two test cases that cause integer overflow."
                    },
                    {
                        "username": "jffiorillo",
                        "content": "Regarding this test: `[[1,27],[29,49],[47,49],[41,43],[15,36],[11,15]]` in theory the output is `1` but I did it manually and the output is `0`. Can you please explain me why the output is `1`?\\n\\nThe following is the explanation why I think the answer is `0`\\n\\n```\\n// Meetings ordered by start time : [Meeting(start=1, finish=27), Meeting(start=11, finish=15), Meeting(start=15, finish=36), Meeting(start=29, finish=49), Meeting(start=41, finish=43), Meeting(start=47, finish=49)]\\n\\nfirst meeting = Meeting(start=1, finish=27)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=0, numberOfMeetings=0), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nsecond meeting = Meeting(start=11, finish=15)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=15, numberOfMeetings=1), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nthird meeting = Meeting(start=15, finish=36)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nforth meeting  = Meeting(start=29, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nfifth meeting = Meeting(start=41, finish=43)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=43, numberOfMeetings=1)]\\n\\nlast meeting = Meeting(start=47, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=92, numberOfMeetings=2)]\\n\\nAll room has been booking twice, so the answer is 0.\\n```"
                    },
                    {
                        "username": "vandanakumari13998",
                        "content": "Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\\nI didn\\'t get this example. How is the output 0. Because at time 8, [4,9] meeting will end. Hence 2 meeting room will be empty and [6,8] one would be scheduled at that time. And how is the output given as 1."
                    },
                    {
                        "username": "superZero",
                        "content": "Is the solution flawed?  I see that the solution is to delay 1 meeting till 1 room becomes available.\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                current_end, room = heappop(running_meetings)\\n                new_end = current_end + meetings[i][1] - meetings[i][0]  # Update the room\\'s end time\\n                heappush(running_meetings, (new_end, room))\\n\\n            meetings_per_room[room] +=1\\n            i +=1\\n\\nBut reality should be that all the remaining meetings whose start time is < end_time of the 1st available room should be delayed.\\n\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                for j in range (i, size):\\n                    if meetings[j][0] < running_meetings[0][0]:\\n                        meetings[j][0] += delta \\n                        meetings[j][1] +=delta\\n                    else:\\n                        break\\n\\n"
                    },
                    {
                        "username": "jj3100",
                        "content": "I used Integer types and finally managed to pass all tests. The main issue that caused me to fail on the 80/82 and 81/82 test cases is that when the end times are equal, the PriorityQueue should also compare the room numbers."
                    },
                    {
                        "username": "magomez4",
                        "content": "Passing 82 test cases but TLE? My code is the same idea as others I\\'m seeing in the submissions, and it passes all test cases, but I get a TLE and it says \"82/82\" test cases passed. It also says that the last executed input is \"n=\" yes.. a blank \\'n\\'. Can anyone tell me if this is a leetcode problem or what am I doing wrong? Any help is greatly appreciated!! \\n\\nHere is my approach:\\n ```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // keep an array for the number of bookings of\\n        // each room.\\n        // also keep a mostBooked variable that gets\\n        // updated every time a room is used.\\n        // To assign a meeting to a room, check if\\n        // the meeting starts before the earliest-finishing\\n        // scheduled meeting. If so, assign a new room. If\\n        // there are no more rooms, wait until the earliest\\n        // finishing room, and use that one. If the meeting\\n        // starts after the earliest-finishing room becomes \\n        // free, then continue to \"free-up\" rooms until\\n        // there are no rooms booked or the earliest finishing\\n        // is later than the current start time. After this,\\n        // use the same logic as above to assign the next\\n        // available room.\\n\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        // ensure meetings are sorted by start time\\n        sort(meetings.begin(),meetings.end(), comparator);\\n\\n        int bookingCount[n];\\n        fill_n(bookingCount, n, 0);\\n        int mostBooked = -1;\\n        // We declare a min-heap that holds <endTime, roomNumber> \\n        // to keep the min end time at the front.\\n        priority_queue<vector<long>, vector<vector<long>>, greater<vector<long>>> freeAt; \\n        priority_queue<int,vector<int>,greater<int>> emptyRooms;\\n        for(int i = 0; i < n; i++)\\n        {\\n            emptyRooms.push(i);\\n        }\\n\\n        for(int i = 0; i < meetings.size(); i++)\\n        {\\n            if(mostBooked == -1)\\n            {\\n                mostBooked = 0;\\n                bookingCount[mostBooked]++;\\n                vector<long> newFreeAt = {meetings[i][1], mostBooked}; \\n                freeAt.push(newFreeAt);\\n                emptyRooms.pop();\\n            }\\n            else\\n            {\\n                // if(meetings[i][0] < freeAt.top().first )\\n                if(meetings[i][0] < freeAt.top()[0] )\\n                {\\n                    // current meeting start time is earlier\\n                    // than the earliest-finishing scheduled meeting\\n                    if(freeAt.size() < n)\\n                    {\\n                        // there are available rooms, so book the next available\\n                        vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                    else\\n                    {\\n                        // there are no more available rooms, so this will haven\\n                        // to wait for the earliest finishing scheduled meeting\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        int meetingDuration = meetings[i][1] - meetings[i][0];//end time - start time\\n                        long newEndTime = freeAt.top()[0] + meetingDuration;\\n                        freeAt.pop();\\n                        vector<long> newFreeAt = {newEndTime, emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                }\\n                else\\n                {\\n                    // current meeting start time is later than the earliest\\n                    // finishing scheduled meeting. \\n                    while(!freeAt.empty() \\n                    && meetings[i][0] >= freeAt.top()[0])\\n                    {\\n                        // let the meetings finish to make sure \\n                        // we get the room with the smallest number\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        freeAt.pop();\\n                    }\\n                    vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                    freeAt.push(newFreeAt);\\n                    bookingCount[emptyRooms.top()]++;\\n                    mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                    emptyRooms.pop();\\n                }\\n            }\\n        }\\n        return mostBooked;\\n    }\\n    static bool comparator(vector<int> a, vector<int> b)\\n    {\\n        if(a[0] <= b[0])\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int updateMostBooked(int mostBooked, int newlyBooked, int bookingCount[])\\n    {\\n        int newMostBooked;\\n        if(bookingCount[newlyBooked] > bookingCount[mostBooked])\\n        {\\n            newMostBooked = newlyBooked;\\n        }\\n        else if (bookingCount[newlyBooked] == bookingCount[mostBooked])\\n        {\\n            // if two rooms have the same amount of meetings,\\n            // we consider the room with the smallest ID as \\n            // the most booked\\n            newMostBooked = min(newlyBooked, mostBooked);\\n        }\\n        else\\n        {\\n            newMostBooked = mostBooked;\\n        }\\n        return newMostBooked;\\n    }\\n};\\n```\\n"
                    }
                ]
            },
            {
                "id": 2066259,
                "content": [
                    {
                        "username": "quanyincode",
                        "content": "If you are wondering why your solution past 80/82 test cases, it it due to the two test cases with long inputs, which will cause integer overflow on the meeting end time. Use Long instead of Integer to track a room\\'s end time should solve the problem."
                    },
                    {
                        "username": "jerome1210",
                        "content": "May someone explain why this meetings [[0,10],[1,9],[2,8],[3,7],[4,6]] will return 1?\nI thought it should be \n1. room: 0, time 10 (0+10)\n2. room: 1, time 10 (1+9)\n3. room: 2, time 10 (2+8)\n4. room: 0, time 17 (10+7)\n5. room: 1, time 16 (10 + 6)\n\nSo, the room 0, 1 will held 2 meetings, then it should return 0 ?\n"
                    },
                    {
                        "username": "user0081T",
                        "content": "The second meeting will end at time: 9 not 10, same thing for the third meeting, it will end at time 8, not 10.  Because the the second argument for each meeting is the end time of the meeting and not the duration of it. "
                    },
                    {
                        "username": "shru15",
                        "content": "After meeting 3, the earliest free room will be room 2\\nso [3,7] -> [3+8, 7+8] at room 2\\nand 4,6 -> [4+9, 6+9] at room 1\\nsince room 0 gets freed at last, only one meeting will take place there."
                    },
                    {
                        "username": "anshil1611",
                        "content": "For the people who are confused with WA at 80/82:\\n\\nI am seeing lot of comments where people are saying its because of integer overflow. Seemingly true, however if you are using a PriorityQueue of type Pair<Integer, Integer>, that is where all the problem is occurring. Just change the type of the priority queue from Pair<Integer, Integer> to int[] (yes, no Long required) and your solution would pass the remaining test cases.\\n\\nIt seems like Pair<Integer, Integer> is not able to handle large values, and the same code which fails with Pair<Integer, Integer>, passes all test cases with int[]."
                    },
                    {
                        "username": "spark6015",
                        "content": "are we even allow to use heapq.heapify() function in the interview?"
                    },
                    {
                        "username": "strangeranda",
                        "content": "Yes, you could ask the interviewer if you could use built-in functions, and 10/10 they\\u2019d say yes. I could be wrong in 10/10, but I never faced any instance where I couldn\\u2019t use. "
                    },
                    {
                        "username": "Tanayk",
                        "content": "Can someone please help me identify the error in this code? 80/82 test cases are passing. \\nThank you\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        rooms = collections.defaultdict(int)\\n        meetings.sort()\\n        booked, free = [], []\\n        max_meets = 0\\n        for i in range(n):\\n            heapq.heappush(booked, (0, i))\\n\\n        i, curr_time = 0, meetings[0][0]\\n        while i < len(meetings):\\n            while booked and booked[0][0] <= curr_time:\\n                free_time, index = heapq.heappop(booked)\\n                heapq.heappush(free, (index, free_time))\\n\\n            if not free:\\n                curr_time = booked[0][0]\\n                continue\\n\\n            room_id, _ = heapq.heappop(free)\\n            rooms[room_id] += 1\\n            max_meets = max(max_meets, rooms[room_id])\\n            heapq.heappush(booked, (curr_time + (meetings[i][1] - meetings[i][0]), room_id))\\n            curr_time = meetings[i+1][0] if i + 1 < len(meetings) else curr_time\\n            i += 1\\n\\n        for i in range(n):\\n            if rooms[i] == max_meets:\\n                return i\\n```"
                    },
                    {
                        "username": "frog445",
                        "content": "[@quanyincode](/quanyincode) It\\'s python lol why will it have integer overflow"
                    },
                    {
                        "username": "quanyincode",
                        "content": "See my comment about the two test cases that cause integer overflow."
                    },
                    {
                        "username": "jffiorillo",
                        "content": "Regarding this test: `[[1,27],[29,49],[47,49],[41,43],[15,36],[11,15]]` in theory the output is `1` but I did it manually and the output is `0`. Can you please explain me why the output is `1`?\\n\\nThe following is the explanation why I think the answer is `0`\\n\\n```\\n// Meetings ordered by start time : [Meeting(start=1, finish=27), Meeting(start=11, finish=15), Meeting(start=15, finish=36), Meeting(start=29, finish=49), Meeting(start=41, finish=43), Meeting(start=47, finish=49)]\\n\\nfirst meeting = Meeting(start=1, finish=27)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=0, numberOfMeetings=0), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nsecond meeting = Meeting(start=11, finish=15)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=15, numberOfMeetings=1), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nthird meeting = Meeting(start=15, finish=36)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nforth meeting  = Meeting(start=29, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nfifth meeting = Meeting(start=41, finish=43)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=43, numberOfMeetings=1)]\\n\\nlast meeting = Meeting(start=47, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=92, numberOfMeetings=2)]\\n\\nAll room has been booking twice, so the answer is 0.\\n```"
                    },
                    {
                        "username": "vandanakumari13998",
                        "content": "Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\\nI didn\\'t get this example. How is the output 0. Because at time 8, [4,9] meeting will end. Hence 2 meeting room will be empty and [6,8] one would be scheduled at that time. And how is the output given as 1."
                    },
                    {
                        "username": "superZero",
                        "content": "Is the solution flawed?  I see that the solution is to delay 1 meeting till 1 room becomes available.\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                current_end, room = heappop(running_meetings)\\n                new_end = current_end + meetings[i][1] - meetings[i][0]  # Update the room\\'s end time\\n                heappush(running_meetings, (new_end, room))\\n\\n            meetings_per_room[room] +=1\\n            i +=1\\n\\nBut reality should be that all the remaining meetings whose start time is < end_time of the 1st available room should be delayed.\\n\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                for j in range (i, size):\\n                    if meetings[j][0] < running_meetings[0][0]:\\n                        meetings[j][0] += delta \\n                        meetings[j][1] +=delta\\n                    else:\\n                        break\\n\\n"
                    },
                    {
                        "username": "jj3100",
                        "content": "I used Integer types and finally managed to pass all tests. The main issue that caused me to fail on the 80/82 and 81/82 test cases is that when the end times are equal, the PriorityQueue should also compare the room numbers."
                    },
                    {
                        "username": "magomez4",
                        "content": "Passing 82 test cases but TLE? My code is the same idea as others I\\'m seeing in the submissions, and it passes all test cases, but I get a TLE and it says \"82/82\" test cases passed. It also says that the last executed input is \"n=\" yes.. a blank \\'n\\'. Can anyone tell me if this is a leetcode problem or what am I doing wrong? Any help is greatly appreciated!! \\n\\nHere is my approach:\\n ```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // keep an array for the number of bookings of\\n        // each room.\\n        // also keep a mostBooked variable that gets\\n        // updated every time a room is used.\\n        // To assign a meeting to a room, check if\\n        // the meeting starts before the earliest-finishing\\n        // scheduled meeting. If so, assign a new room. If\\n        // there are no more rooms, wait until the earliest\\n        // finishing room, and use that one. If the meeting\\n        // starts after the earliest-finishing room becomes \\n        // free, then continue to \"free-up\" rooms until\\n        // there are no rooms booked or the earliest finishing\\n        // is later than the current start time. After this,\\n        // use the same logic as above to assign the next\\n        // available room.\\n\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        // ensure meetings are sorted by start time\\n        sort(meetings.begin(),meetings.end(), comparator);\\n\\n        int bookingCount[n];\\n        fill_n(bookingCount, n, 0);\\n        int mostBooked = -1;\\n        // We declare a min-heap that holds <endTime, roomNumber> \\n        // to keep the min end time at the front.\\n        priority_queue<vector<long>, vector<vector<long>>, greater<vector<long>>> freeAt; \\n        priority_queue<int,vector<int>,greater<int>> emptyRooms;\\n        for(int i = 0; i < n; i++)\\n        {\\n            emptyRooms.push(i);\\n        }\\n\\n        for(int i = 0; i < meetings.size(); i++)\\n        {\\n            if(mostBooked == -1)\\n            {\\n                mostBooked = 0;\\n                bookingCount[mostBooked]++;\\n                vector<long> newFreeAt = {meetings[i][1], mostBooked}; \\n                freeAt.push(newFreeAt);\\n                emptyRooms.pop();\\n            }\\n            else\\n            {\\n                // if(meetings[i][0] < freeAt.top().first )\\n                if(meetings[i][0] < freeAt.top()[0] )\\n                {\\n                    // current meeting start time is earlier\\n                    // than the earliest-finishing scheduled meeting\\n                    if(freeAt.size() < n)\\n                    {\\n                        // there are available rooms, so book the next available\\n                        vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                    else\\n                    {\\n                        // there are no more available rooms, so this will haven\\n                        // to wait for the earliest finishing scheduled meeting\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        int meetingDuration = meetings[i][1] - meetings[i][0];//end time - start time\\n                        long newEndTime = freeAt.top()[0] + meetingDuration;\\n                        freeAt.pop();\\n                        vector<long> newFreeAt = {newEndTime, emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                }\\n                else\\n                {\\n                    // current meeting start time is later than the earliest\\n                    // finishing scheduled meeting. \\n                    while(!freeAt.empty() \\n                    && meetings[i][0] >= freeAt.top()[0])\\n                    {\\n                        // let the meetings finish to make sure \\n                        // we get the room with the smallest number\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        freeAt.pop();\\n                    }\\n                    vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                    freeAt.push(newFreeAt);\\n                    bookingCount[emptyRooms.top()]++;\\n                    mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                    emptyRooms.pop();\\n                }\\n            }\\n        }\\n        return mostBooked;\\n    }\\n    static bool comparator(vector<int> a, vector<int> b)\\n    {\\n        if(a[0] <= b[0])\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int updateMostBooked(int mostBooked, int newlyBooked, int bookingCount[])\\n    {\\n        int newMostBooked;\\n        if(bookingCount[newlyBooked] > bookingCount[mostBooked])\\n        {\\n            newMostBooked = newlyBooked;\\n        }\\n        else if (bookingCount[newlyBooked] == bookingCount[mostBooked])\\n        {\\n            // if two rooms have the same amount of meetings,\\n            // we consider the room with the smallest ID as \\n            // the most booked\\n            newMostBooked = min(newlyBooked, mostBooked);\\n        }\\n        else\\n        {\\n            newMostBooked = mostBooked;\\n        }\\n        return newMostBooked;\\n    }\\n};\\n```\\n"
                    }
                ]
            },
            {
                "id": 2045529,
                "content": [
                    {
                        "username": "quanyincode",
                        "content": "If you are wondering why your solution past 80/82 test cases, it it due to the two test cases with long inputs, which will cause integer overflow on the meeting end time. Use Long instead of Integer to track a room\\'s end time should solve the problem."
                    },
                    {
                        "username": "jerome1210",
                        "content": "May someone explain why this meetings [[0,10],[1,9],[2,8],[3,7],[4,6]] will return 1?\nI thought it should be \n1. room: 0, time 10 (0+10)\n2. room: 1, time 10 (1+9)\n3. room: 2, time 10 (2+8)\n4. room: 0, time 17 (10+7)\n5. room: 1, time 16 (10 + 6)\n\nSo, the room 0, 1 will held 2 meetings, then it should return 0 ?\n"
                    },
                    {
                        "username": "user0081T",
                        "content": "The second meeting will end at time: 9 not 10, same thing for the third meeting, it will end at time 8, not 10.  Because the the second argument for each meeting is the end time of the meeting and not the duration of it. "
                    },
                    {
                        "username": "shru15",
                        "content": "After meeting 3, the earliest free room will be room 2\\nso [3,7] -> [3+8, 7+8] at room 2\\nand 4,6 -> [4+9, 6+9] at room 1\\nsince room 0 gets freed at last, only one meeting will take place there."
                    },
                    {
                        "username": "anshil1611",
                        "content": "For the people who are confused with WA at 80/82:\\n\\nI am seeing lot of comments where people are saying its because of integer overflow. Seemingly true, however if you are using a PriorityQueue of type Pair<Integer, Integer>, that is where all the problem is occurring. Just change the type of the priority queue from Pair<Integer, Integer> to int[] (yes, no Long required) and your solution would pass the remaining test cases.\\n\\nIt seems like Pair<Integer, Integer> is not able to handle large values, and the same code which fails with Pair<Integer, Integer>, passes all test cases with int[]."
                    },
                    {
                        "username": "spark6015",
                        "content": "are we even allow to use heapq.heapify() function in the interview?"
                    },
                    {
                        "username": "strangeranda",
                        "content": "Yes, you could ask the interviewer if you could use built-in functions, and 10/10 they\\u2019d say yes. I could be wrong in 10/10, but I never faced any instance where I couldn\\u2019t use. "
                    },
                    {
                        "username": "Tanayk",
                        "content": "Can someone please help me identify the error in this code? 80/82 test cases are passing. \\nThank you\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        rooms = collections.defaultdict(int)\\n        meetings.sort()\\n        booked, free = [], []\\n        max_meets = 0\\n        for i in range(n):\\n            heapq.heappush(booked, (0, i))\\n\\n        i, curr_time = 0, meetings[0][0]\\n        while i < len(meetings):\\n            while booked and booked[0][0] <= curr_time:\\n                free_time, index = heapq.heappop(booked)\\n                heapq.heappush(free, (index, free_time))\\n\\n            if not free:\\n                curr_time = booked[0][0]\\n                continue\\n\\n            room_id, _ = heapq.heappop(free)\\n            rooms[room_id] += 1\\n            max_meets = max(max_meets, rooms[room_id])\\n            heapq.heappush(booked, (curr_time + (meetings[i][1] - meetings[i][0]), room_id))\\n            curr_time = meetings[i+1][0] if i + 1 < len(meetings) else curr_time\\n            i += 1\\n\\n        for i in range(n):\\n            if rooms[i] == max_meets:\\n                return i\\n```"
                    },
                    {
                        "username": "frog445",
                        "content": "[@quanyincode](/quanyincode) It\\'s python lol why will it have integer overflow"
                    },
                    {
                        "username": "quanyincode",
                        "content": "See my comment about the two test cases that cause integer overflow."
                    },
                    {
                        "username": "jffiorillo",
                        "content": "Regarding this test: `[[1,27],[29,49],[47,49],[41,43],[15,36],[11,15]]` in theory the output is `1` but I did it manually and the output is `0`. Can you please explain me why the output is `1`?\\n\\nThe following is the explanation why I think the answer is `0`\\n\\n```\\n// Meetings ordered by start time : [Meeting(start=1, finish=27), Meeting(start=11, finish=15), Meeting(start=15, finish=36), Meeting(start=29, finish=49), Meeting(start=41, finish=43), Meeting(start=47, finish=49)]\\n\\nfirst meeting = Meeting(start=1, finish=27)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=0, numberOfMeetings=0), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nsecond meeting = Meeting(start=11, finish=15)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=15, numberOfMeetings=1), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nthird meeting = Meeting(start=15, finish=36)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nforth meeting  = Meeting(start=29, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nfifth meeting = Meeting(start=41, finish=43)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=43, numberOfMeetings=1)]\\n\\nlast meeting = Meeting(start=47, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=92, numberOfMeetings=2)]\\n\\nAll room has been booking twice, so the answer is 0.\\n```"
                    },
                    {
                        "username": "vandanakumari13998",
                        "content": "Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\\nI didn\\'t get this example. How is the output 0. Because at time 8, [4,9] meeting will end. Hence 2 meeting room will be empty and [6,8] one would be scheduled at that time. And how is the output given as 1."
                    },
                    {
                        "username": "superZero",
                        "content": "Is the solution flawed?  I see that the solution is to delay 1 meeting till 1 room becomes available.\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                current_end, room = heappop(running_meetings)\\n                new_end = current_end + meetings[i][1] - meetings[i][0]  # Update the room\\'s end time\\n                heappush(running_meetings, (new_end, room))\\n\\n            meetings_per_room[room] +=1\\n            i +=1\\n\\nBut reality should be that all the remaining meetings whose start time is < end_time of the 1st available room should be delayed.\\n\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                for j in range (i, size):\\n                    if meetings[j][0] < running_meetings[0][0]:\\n                        meetings[j][0] += delta \\n                        meetings[j][1] +=delta\\n                    else:\\n                        break\\n\\n"
                    },
                    {
                        "username": "jj3100",
                        "content": "I used Integer types and finally managed to pass all tests. The main issue that caused me to fail on the 80/82 and 81/82 test cases is that when the end times are equal, the PriorityQueue should also compare the room numbers."
                    },
                    {
                        "username": "magomez4",
                        "content": "Passing 82 test cases but TLE? My code is the same idea as others I\\'m seeing in the submissions, and it passes all test cases, but I get a TLE and it says \"82/82\" test cases passed. It also says that the last executed input is \"n=\" yes.. a blank \\'n\\'. Can anyone tell me if this is a leetcode problem or what am I doing wrong? Any help is greatly appreciated!! \\n\\nHere is my approach:\\n ```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // keep an array for the number of bookings of\\n        // each room.\\n        // also keep a mostBooked variable that gets\\n        // updated every time a room is used.\\n        // To assign a meeting to a room, check if\\n        // the meeting starts before the earliest-finishing\\n        // scheduled meeting. If so, assign a new room. If\\n        // there are no more rooms, wait until the earliest\\n        // finishing room, and use that one. If the meeting\\n        // starts after the earliest-finishing room becomes \\n        // free, then continue to \"free-up\" rooms until\\n        // there are no rooms booked or the earliest finishing\\n        // is later than the current start time. After this,\\n        // use the same logic as above to assign the next\\n        // available room.\\n\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        // ensure meetings are sorted by start time\\n        sort(meetings.begin(),meetings.end(), comparator);\\n\\n        int bookingCount[n];\\n        fill_n(bookingCount, n, 0);\\n        int mostBooked = -1;\\n        // We declare a min-heap that holds <endTime, roomNumber> \\n        // to keep the min end time at the front.\\n        priority_queue<vector<long>, vector<vector<long>>, greater<vector<long>>> freeAt; \\n        priority_queue<int,vector<int>,greater<int>> emptyRooms;\\n        for(int i = 0; i < n; i++)\\n        {\\n            emptyRooms.push(i);\\n        }\\n\\n        for(int i = 0; i < meetings.size(); i++)\\n        {\\n            if(mostBooked == -1)\\n            {\\n                mostBooked = 0;\\n                bookingCount[mostBooked]++;\\n                vector<long> newFreeAt = {meetings[i][1], mostBooked}; \\n                freeAt.push(newFreeAt);\\n                emptyRooms.pop();\\n            }\\n            else\\n            {\\n                // if(meetings[i][0] < freeAt.top().first )\\n                if(meetings[i][0] < freeAt.top()[0] )\\n                {\\n                    // current meeting start time is earlier\\n                    // than the earliest-finishing scheduled meeting\\n                    if(freeAt.size() < n)\\n                    {\\n                        // there are available rooms, so book the next available\\n                        vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                    else\\n                    {\\n                        // there are no more available rooms, so this will haven\\n                        // to wait for the earliest finishing scheduled meeting\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        int meetingDuration = meetings[i][1] - meetings[i][0];//end time - start time\\n                        long newEndTime = freeAt.top()[0] + meetingDuration;\\n                        freeAt.pop();\\n                        vector<long> newFreeAt = {newEndTime, emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                }\\n                else\\n                {\\n                    // current meeting start time is later than the earliest\\n                    // finishing scheduled meeting. \\n                    while(!freeAt.empty() \\n                    && meetings[i][0] >= freeAt.top()[0])\\n                    {\\n                        // let the meetings finish to make sure \\n                        // we get the room with the smallest number\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        freeAt.pop();\\n                    }\\n                    vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                    freeAt.push(newFreeAt);\\n                    bookingCount[emptyRooms.top()]++;\\n                    mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                    emptyRooms.pop();\\n                }\\n            }\\n        }\\n        return mostBooked;\\n    }\\n    static bool comparator(vector<int> a, vector<int> b)\\n    {\\n        if(a[0] <= b[0])\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int updateMostBooked(int mostBooked, int newlyBooked, int bookingCount[])\\n    {\\n        int newMostBooked;\\n        if(bookingCount[newlyBooked] > bookingCount[mostBooked])\\n        {\\n            newMostBooked = newlyBooked;\\n        }\\n        else if (bookingCount[newlyBooked] == bookingCount[mostBooked])\\n        {\\n            // if two rooms have the same amount of meetings,\\n            // we consider the room with the smallest ID as \\n            // the most booked\\n            newMostBooked = min(newlyBooked, mostBooked);\\n        }\\n        else\\n        {\\n            newMostBooked = mostBooked;\\n        }\\n        return newMostBooked;\\n    }\\n};\\n```\\n"
                    }
                ]
            },
            {
                "id": 2036225,
                "content": [
                    {
                        "username": "quanyincode",
                        "content": "If you are wondering why your solution past 80/82 test cases, it it due to the two test cases with long inputs, which will cause integer overflow on the meeting end time. Use Long instead of Integer to track a room\\'s end time should solve the problem."
                    },
                    {
                        "username": "jerome1210",
                        "content": "May someone explain why this meetings [[0,10],[1,9],[2,8],[3,7],[4,6]] will return 1?\nI thought it should be \n1. room: 0, time 10 (0+10)\n2. room: 1, time 10 (1+9)\n3. room: 2, time 10 (2+8)\n4. room: 0, time 17 (10+7)\n5. room: 1, time 16 (10 + 6)\n\nSo, the room 0, 1 will held 2 meetings, then it should return 0 ?\n"
                    },
                    {
                        "username": "user0081T",
                        "content": "The second meeting will end at time: 9 not 10, same thing for the third meeting, it will end at time 8, not 10.  Because the the second argument for each meeting is the end time of the meeting and not the duration of it. "
                    },
                    {
                        "username": "shru15",
                        "content": "After meeting 3, the earliest free room will be room 2\\nso [3,7] -> [3+8, 7+8] at room 2\\nand 4,6 -> [4+9, 6+9] at room 1\\nsince room 0 gets freed at last, only one meeting will take place there."
                    },
                    {
                        "username": "anshil1611",
                        "content": "For the people who are confused with WA at 80/82:\\n\\nI am seeing lot of comments where people are saying its because of integer overflow. Seemingly true, however if you are using a PriorityQueue of type Pair<Integer, Integer>, that is where all the problem is occurring. Just change the type of the priority queue from Pair<Integer, Integer> to int[] (yes, no Long required) and your solution would pass the remaining test cases.\\n\\nIt seems like Pair<Integer, Integer> is not able to handle large values, and the same code which fails with Pair<Integer, Integer>, passes all test cases with int[]."
                    },
                    {
                        "username": "spark6015",
                        "content": "are we even allow to use heapq.heapify() function in the interview?"
                    },
                    {
                        "username": "strangeranda",
                        "content": "Yes, you could ask the interviewer if you could use built-in functions, and 10/10 they\\u2019d say yes. I could be wrong in 10/10, but I never faced any instance where I couldn\\u2019t use. "
                    },
                    {
                        "username": "Tanayk",
                        "content": "Can someone please help me identify the error in this code? 80/82 test cases are passing. \\nThank you\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        rooms = collections.defaultdict(int)\\n        meetings.sort()\\n        booked, free = [], []\\n        max_meets = 0\\n        for i in range(n):\\n            heapq.heappush(booked, (0, i))\\n\\n        i, curr_time = 0, meetings[0][0]\\n        while i < len(meetings):\\n            while booked and booked[0][0] <= curr_time:\\n                free_time, index = heapq.heappop(booked)\\n                heapq.heappush(free, (index, free_time))\\n\\n            if not free:\\n                curr_time = booked[0][0]\\n                continue\\n\\n            room_id, _ = heapq.heappop(free)\\n            rooms[room_id] += 1\\n            max_meets = max(max_meets, rooms[room_id])\\n            heapq.heappush(booked, (curr_time + (meetings[i][1] - meetings[i][0]), room_id))\\n            curr_time = meetings[i+1][0] if i + 1 < len(meetings) else curr_time\\n            i += 1\\n\\n        for i in range(n):\\n            if rooms[i] == max_meets:\\n                return i\\n```"
                    },
                    {
                        "username": "frog445",
                        "content": "[@quanyincode](/quanyincode) It\\'s python lol why will it have integer overflow"
                    },
                    {
                        "username": "quanyincode",
                        "content": "See my comment about the two test cases that cause integer overflow."
                    },
                    {
                        "username": "jffiorillo",
                        "content": "Regarding this test: `[[1,27],[29,49],[47,49],[41,43],[15,36],[11,15]]` in theory the output is `1` but I did it manually and the output is `0`. Can you please explain me why the output is `1`?\\n\\nThe following is the explanation why I think the answer is `0`\\n\\n```\\n// Meetings ordered by start time : [Meeting(start=1, finish=27), Meeting(start=11, finish=15), Meeting(start=15, finish=36), Meeting(start=29, finish=49), Meeting(start=41, finish=43), Meeting(start=47, finish=49)]\\n\\nfirst meeting = Meeting(start=1, finish=27)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=0, numberOfMeetings=0), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nsecond meeting = Meeting(start=11, finish=15)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=15, numberOfMeetings=1), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nthird meeting = Meeting(start=15, finish=36)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nforth meeting  = Meeting(start=29, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nfifth meeting = Meeting(start=41, finish=43)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=43, numberOfMeetings=1)]\\n\\nlast meeting = Meeting(start=47, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=92, numberOfMeetings=2)]\\n\\nAll room has been booking twice, so the answer is 0.\\n```"
                    },
                    {
                        "username": "vandanakumari13998",
                        "content": "Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\\nI didn\\'t get this example. How is the output 0. Because at time 8, [4,9] meeting will end. Hence 2 meeting room will be empty and [6,8] one would be scheduled at that time. And how is the output given as 1."
                    },
                    {
                        "username": "superZero",
                        "content": "Is the solution flawed?  I see that the solution is to delay 1 meeting till 1 room becomes available.\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                current_end, room = heappop(running_meetings)\\n                new_end = current_end + meetings[i][1] - meetings[i][0]  # Update the room\\'s end time\\n                heappush(running_meetings, (new_end, room))\\n\\n            meetings_per_room[room] +=1\\n            i +=1\\n\\nBut reality should be that all the remaining meetings whose start time is < end_time of the 1st available room should be delayed.\\n\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                for j in range (i, size):\\n                    if meetings[j][0] < running_meetings[0][0]:\\n                        meetings[j][0] += delta \\n                        meetings[j][1] +=delta\\n                    else:\\n                        break\\n\\n"
                    },
                    {
                        "username": "jj3100",
                        "content": "I used Integer types and finally managed to pass all tests. The main issue that caused me to fail on the 80/82 and 81/82 test cases is that when the end times are equal, the PriorityQueue should also compare the room numbers."
                    },
                    {
                        "username": "magomez4",
                        "content": "Passing 82 test cases but TLE? My code is the same idea as others I\\'m seeing in the submissions, and it passes all test cases, but I get a TLE and it says \"82/82\" test cases passed. It also says that the last executed input is \"n=\" yes.. a blank \\'n\\'. Can anyone tell me if this is a leetcode problem or what am I doing wrong? Any help is greatly appreciated!! \\n\\nHere is my approach:\\n ```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // keep an array for the number of bookings of\\n        // each room.\\n        // also keep a mostBooked variable that gets\\n        // updated every time a room is used.\\n        // To assign a meeting to a room, check if\\n        // the meeting starts before the earliest-finishing\\n        // scheduled meeting. If so, assign a new room. If\\n        // there are no more rooms, wait until the earliest\\n        // finishing room, and use that one. If the meeting\\n        // starts after the earliest-finishing room becomes \\n        // free, then continue to \"free-up\" rooms until\\n        // there are no rooms booked or the earliest finishing\\n        // is later than the current start time. After this,\\n        // use the same logic as above to assign the next\\n        // available room.\\n\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        // ensure meetings are sorted by start time\\n        sort(meetings.begin(),meetings.end(), comparator);\\n\\n        int bookingCount[n];\\n        fill_n(bookingCount, n, 0);\\n        int mostBooked = -1;\\n        // We declare a min-heap that holds <endTime, roomNumber> \\n        // to keep the min end time at the front.\\n        priority_queue<vector<long>, vector<vector<long>>, greater<vector<long>>> freeAt; \\n        priority_queue<int,vector<int>,greater<int>> emptyRooms;\\n        for(int i = 0; i < n; i++)\\n        {\\n            emptyRooms.push(i);\\n        }\\n\\n        for(int i = 0; i < meetings.size(); i++)\\n        {\\n            if(mostBooked == -1)\\n            {\\n                mostBooked = 0;\\n                bookingCount[mostBooked]++;\\n                vector<long> newFreeAt = {meetings[i][1], mostBooked}; \\n                freeAt.push(newFreeAt);\\n                emptyRooms.pop();\\n            }\\n            else\\n            {\\n                // if(meetings[i][0] < freeAt.top().first )\\n                if(meetings[i][0] < freeAt.top()[0] )\\n                {\\n                    // current meeting start time is earlier\\n                    // than the earliest-finishing scheduled meeting\\n                    if(freeAt.size() < n)\\n                    {\\n                        // there are available rooms, so book the next available\\n                        vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                    else\\n                    {\\n                        // there are no more available rooms, so this will haven\\n                        // to wait for the earliest finishing scheduled meeting\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        int meetingDuration = meetings[i][1] - meetings[i][0];//end time - start time\\n                        long newEndTime = freeAt.top()[0] + meetingDuration;\\n                        freeAt.pop();\\n                        vector<long> newFreeAt = {newEndTime, emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                }\\n                else\\n                {\\n                    // current meeting start time is later than the earliest\\n                    // finishing scheduled meeting. \\n                    while(!freeAt.empty() \\n                    && meetings[i][0] >= freeAt.top()[0])\\n                    {\\n                        // let the meetings finish to make sure \\n                        // we get the room with the smallest number\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        freeAt.pop();\\n                    }\\n                    vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                    freeAt.push(newFreeAt);\\n                    bookingCount[emptyRooms.top()]++;\\n                    mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                    emptyRooms.pop();\\n                }\\n            }\\n        }\\n        return mostBooked;\\n    }\\n    static bool comparator(vector<int> a, vector<int> b)\\n    {\\n        if(a[0] <= b[0])\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int updateMostBooked(int mostBooked, int newlyBooked, int bookingCount[])\\n    {\\n        int newMostBooked;\\n        if(bookingCount[newlyBooked] > bookingCount[mostBooked])\\n        {\\n            newMostBooked = newlyBooked;\\n        }\\n        else if (bookingCount[newlyBooked] == bookingCount[mostBooked])\\n        {\\n            // if two rooms have the same amount of meetings,\\n            // we consider the room with the smallest ID as \\n            // the most booked\\n            newMostBooked = min(newlyBooked, mostBooked);\\n        }\\n        else\\n        {\\n            newMostBooked = mostBooked;\\n        }\\n        return newMostBooked;\\n    }\\n};\\n```\\n"
                    }
                ]
            },
            {
                "id": 2027700,
                "content": [
                    {
                        "username": "quanyincode",
                        "content": "If you are wondering why your solution past 80/82 test cases, it it due to the two test cases with long inputs, which will cause integer overflow on the meeting end time. Use Long instead of Integer to track a room\\'s end time should solve the problem."
                    },
                    {
                        "username": "jerome1210",
                        "content": "May someone explain why this meetings [[0,10],[1,9],[2,8],[3,7],[4,6]] will return 1?\nI thought it should be \n1. room: 0, time 10 (0+10)\n2. room: 1, time 10 (1+9)\n3. room: 2, time 10 (2+8)\n4. room: 0, time 17 (10+7)\n5. room: 1, time 16 (10 + 6)\n\nSo, the room 0, 1 will held 2 meetings, then it should return 0 ?\n"
                    },
                    {
                        "username": "user0081T",
                        "content": "The second meeting will end at time: 9 not 10, same thing for the third meeting, it will end at time 8, not 10.  Because the the second argument for each meeting is the end time of the meeting and not the duration of it. "
                    },
                    {
                        "username": "shru15",
                        "content": "After meeting 3, the earliest free room will be room 2\\nso [3,7] -> [3+8, 7+8] at room 2\\nand 4,6 -> [4+9, 6+9] at room 1\\nsince room 0 gets freed at last, only one meeting will take place there."
                    },
                    {
                        "username": "anshil1611",
                        "content": "For the people who are confused with WA at 80/82:\\n\\nI am seeing lot of comments where people are saying its because of integer overflow. Seemingly true, however if you are using a PriorityQueue of type Pair<Integer, Integer>, that is where all the problem is occurring. Just change the type of the priority queue from Pair<Integer, Integer> to int[] (yes, no Long required) and your solution would pass the remaining test cases.\\n\\nIt seems like Pair<Integer, Integer> is not able to handle large values, and the same code which fails with Pair<Integer, Integer>, passes all test cases with int[]."
                    },
                    {
                        "username": "spark6015",
                        "content": "are we even allow to use heapq.heapify() function in the interview?"
                    },
                    {
                        "username": "strangeranda",
                        "content": "Yes, you could ask the interviewer if you could use built-in functions, and 10/10 they\\u2019d say yes. I could be wrong in 10/10, but I never faced any instance where I couldn\\u2019t use. "
                    },
                    {
                        "username": "Tanayk",
                        "content": "Can someone please help me identify the error in this code? 80/82 test cases are passing. \\nThank you\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        rooms = collections.defaultdict(int)\\n        meetings.sort()\\n        booked, free = [], []\\n        max_meets = 0\\n        for i in range(n):\\n            heapq.heappush(booked, (0, i))\\n\\n        i, curr_time = 0, meetings[0][0]\\n        while i < len(meetings):\\n            while booked and booked[0][0] <= curr_time:\\n                free_time, index = heapq.heappop(booked)\\n                heapq.heappush(free, (index, free_time))\\n\\n            if not free:\\n                curr_time = booked[0][0]\\n                continue\\n\\n            room_id, _ = heapq.heappop(free)\\n            rooms[room_id] += 1\\n            max_meets = max(max_meets, rooms[room_id])\\n            heapq.heappush(booked, (curr_time + (meetings[i][1] - meetings[i][0]), room_id))\\n            curr_time = meetings[i+1][0] if i + 1 < len(meetings) else curr_time\\n            i += 1\\n\\n        for i in range(n):\\n            if rooms[i] == max_meets:\\n                return i\\n```"
                    },
                    {
                        "username": "frog445",
                        "content": "[@quanyincode](/quanyincode) It\\'s python lol why will it have integer overflow"
                    },
                    {
                        "username": "quanyincode",
                        "content": "See my comment about the two test cases that cause integer overflow."
                    },
                    {
                        "username": "jffiorillo",
                        "content": "Regarding this test: `[[1,27],[29,49],[47,49],[41,43],[15,36],[11,15]]` in theory the output is `1` but I did it manually and the output is `0`. Can you please explain me why the output is `1`?\\n\\nThe following is the explanation why I think the answer is `0`\\n\\n```\\n// Meetings ordered by start time : [Meeting(start=1, finish=27), Meeting(start=11, finish=15), Meeting(start=15, finish=36), Meeting(start=29, finish=49), Meeting(start=41, finish=43), Meeting(start=47, finish=49)]\\n\\nfirst meeting = Meeting(start=1, finish=27)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=0, numberOfMeetings=0), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nsecond meeting = Meeting(start=11, finish=15)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=15, numberOfMeetings=1), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nthird meeting = Meeting(start=15, finish=36)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nforth meeting  = Meeting(start=29, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nfifth meeting = Meeting(start=41, finish=43)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=43, numberOfMeetings=1)]\\n\\nlast meeting = Meeting(start=47, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=92, numberOfMeetings=2)]\\n\\nAll room has been booking twice, so the answer is 0.\\n```"
                    },
                    {
                        "username": "vandanakumari13998",
                        "content": "Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\\nI didn\\'t get this example. How is the output 0. Because at time 8, [4,9] meeting will end. Hence 2 meeting room will be empty and [6,8] one would be scheduled at that time. And how is the output given as 1."
                    },
                    {
                        "username": "superZero",
                        "content": "Is the solution flawed?  I see that the solution is to delay 1 meeting till 1 room becomes available.\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                current_end, room = heappop(running_meetings)\\n                new_end = current_end + meetings[i][1] - meetings[i][0]  # Update the room\\'s end time\\n                heappush(running_meetings, (new_end, room))\\n\\n            meetings_per_room[room] +=1\\n            i +=1\\n\\nBut reality should be that all the remaining meetings whose start time is < end_time of the 1st available room should be delayed.\\n\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                for j in range (i, size):\\n                    if meetings[j][0] < running_meetings[0][0]:\\n                        meetings[j][0] += delta \\n                        meetings[j][1] +=delta\\n                    else:\\n                        break\\n\\n"
                    },
                    {
                        "username": "jj3100",
                        "content": "I used Integer types and finally managed to pass all tests. The main issue that caused me to fail on the 80/82 and 81/82 test cases is that when the end times are equal, the PriorityQueue should also compare the room numbers."
                    },
                    {
                        "username": "magomez4",
                        "content": "Passing 82 test cases but TLE? My code is the same idea as others I\\'m seeing in the submissions, and it passes all test cases, but I get a TLE and it says \"82/82\" test cases passed. It also says that the last executed input is \"n=\" yes.. a blank \\'n\\'. Can anyone tell me if this is a leetcode problem or what am I doing wrong? Any help is greatly appreciated!! \\n\\nHere is my approach:\\n ```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // keep an array for the number of bookings of\\n        // each room.\\n        // also keep a mostBooked variable that gets\\n        // updated every time a room is used.\\n        // To assign a meeting to a room, check if\\n        // the meeting starts before the earliest-finishing\\n        // scheduled meeting. If so, assign a new room. If\\n        // there are no more rooms, wait until the earliest\\n        // finishing room, and use that one. If the meeting\\n        // starts after the earliest-finishing room becomes \\n        // free, then continue to \"free-up\" rooms until\\n        // there are no rooms booked or the earliest finishing\\n        // is later than the current start time. After this,\\n        // use the same logic as above to assign the next\\n        // available room.\\n\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        // ensure meetings are sorted by start time\\n        sort(meetings.begin(),meetings.end(), comparator);\\n\\n        int bookingCount[n];\\n        fill_n(bookingCount, n, 0);\\n        int mostBooked = -1;\\n        // We declare a min-heap that holds <endTime, roomNumber> \\n        // to keep the min end time at the front.\\n        priority_queue<vector<long>, vector<vector<long>>, greater<vector<long>>> freeAt; \\n        priority_queue<int,vector<int>,greater<int>> emptyRooms;\\n        for(int i = 0; i < n; i++)\\n        {\\n            emptyRooms.push(i);\\n        }\\n\\n        for(int i = 0; i < meetings.size(); i++)\\n        {\\n            if(mostBooked == -1)\\n            {\\n                mostBooked = 0;\\n                bookingCount[mostBooked]++;\\n                vector<long> newFreeAt = {meetings[i][1], mostBooked}; \\n                freeAt.push(newFreeAt);\\n                emptyRooms.pop();\\n            }\\n            else\\n            {\\n                // if(meetings[i][0] < freeAt.top().first )\\n                if(meetings[i][0] < freeAt.top()[0] )\\n                {\\n                    // current meeting start time is earlier\\n                    // than the earliest-finishing scheduled meeting\\n                    if(freeAt.size() < n)\\n                    {\\n                        // there are available rooms, so book the next available\\n                        vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                    else\\n                    {\\n                        // there are no more available rooms, so this will haven\\n                        // to wait for the earliest finishing scheduled meeting\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        int meetingDuration = meetings[i][1] - meetings[i][0];//end time - start time\\n                        long newEndTime = freeAt.top()[0] + meetingDuration;\\n                        freeAt.pop();\\n                        vector<long> newFreeAt = {newEndTime, emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                }\\n                else\\n                {\\n                    // current meeting start time is later than the earliest\\n                    // finishing scheduled meeting. \\n                    while(!freeAt.empty() \\n                    && meetings[i][0] >= freeAt.top()[0])\\n                    {\\n                        // let the meetings finish to make sure \\n                        // we get the room with the smallest number\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        freeAt.pop();\\n                    }\\n                    vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                    freeAt.push(newFreeAt);\\n                    bookingCount[emptyRooms.top()]++;\\n                    mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                    emptyRooms.pop();\\n                }\\n            }\\n        }\\n        return mostBooked;\\n    }\\n    static bool comparator(vector<int> a, vector<int> b)\\n    {\\n        if(a[0] <= b[0])\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int updateMostBooked(int mostBooked, int newlyBooked, int bookingCount[])\\n    {\\n        int newMostBooked;\\n        if(bookingCount[newlyBooked] > bookingCount[mostBooked])\\n        {\\n            newMostBooked = newlyBooked;\\n        }\\n        else if (bookingCount[newlyBooked] == bookingCount[mostBooked])\\n        {\\n            // if two rooms have the same amount of meetings,\\n            // we consider the room with the smallest ID as \\n            // the most booked\\n            newMostBooked = min(newlyBooked, mostBooked);\\n        }\\n        else\\n        {\\n            newMostBooked = mostBooked;\\n        }\\n        return newMostBooked;\\n    }\\n};\\n```\\n"
                    }
                ]
            },
            {
                "id": 1837807,
                "content": [
                    {
                        "username": "quanyincode",
                        "content": "If you are wondering why your solution past 80/82 test cases, it it due to the two test cases with long inputs, which will cause integer overflow on the meeting end time. Use Long instead of Integer to track a room\\'s end time should solve the problem."
                    },
                    {
                        "username": "jerome1210",
                        "content": "May someone explain why this meetings [[0,10],[1,9],[2,8],[3,7],[4,6]] will return 1?\nI thought it should be \n1. room: 0, time 10 (0+10)\n2. room: 1, time 10 (1+9)\n3. room: 2, time 10 (2+8)\n4. room: 0, time 17 (10+7)\n5. room: 1, time 16 (10 + 6)\n\nSo, the room 0, 1 will held 2 meetings, then it should return 0 ?\n"
                    },
                    {
                        "username": "user0081T",
                        "content": "The second meeting will end at time: 9 not 10, same thing for the third meeting, it will end at time 8, not 10.  Because the the second argument for each meeting is the end time of the meeting and not the duration of it. "
                    },
                    {
                        "username": "shru15",
                        "content": "After meeting 3, the earliest free room will be room 2\\nso [3,7] -> [3+8, 7+8] at room 2\\nand 4,6 -> [4+9, 6+9] at room 1\\nsince room 0 gets freed at last, only one meeting will take place there."
                    },
                    {
                        "username": "anshil1611",
                        "content": "For the people who are confused with WA at 80/82:\\n\\nI am seeing lot of comments where people are saying its because of integer overflow. Seemingly true, however if you are using a PriorityQueue of type Pair<Integer, Integer>, that is where all the problem is occurring. Just change the type of the priority queue from Pair<Integer, Integer> to int[] (yes, no Long required) and your solution would pass the remaining test cases.\\n\\nIt seems like Pair<Integer, Integer> is not able to handle large values, and the same code which fails with Pair<Integer, Integer>, passes all test cases with int[]."
                    },
                    {
                        "username": "spark6015",
                        "content": "are we even allow to use heapq.heapify() function in the interview?"
                    },
                    {
                        "username": "strangeranda",
                        "content": "Yes, you could ask the interviewer if you could use built-in functions, and 10/10 they\\u2019d say yes. I could be wrong in 10/10, but I never faced any instance where I couldn\\u2019t use. "
                    },
                    {
                        "username": "Tanayk",
                        "content": "Can someone please help me identify the error in this code? 80/82 test cases are passing. \\nThank you\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        rooms = collections.defaultdict(int)\\n        meetings.sort()\\n        booked, free = [], []\\n        max_meets = 0\\n        for i in range(n):\\n            heapq.heappush(booked, (0, i))\\n\\n        i, curr_time = 0, meetings[0][0]\\n        while i < len(meetings):\\n            while booked and booked[0][0] <= curr_time:\\n                free_time, index = heapq.heappop(booked)\\n                heapq.heappush(free, (index, free_time))\\n\\n            if not free:\\n                curr_time = booked[0][0]\\n                continue\\n\\n            room_id, _ = heapq.heappop(free)\\n            rooms[room_id] += 1\\n            max_meets = max(max_meets, rooms[room_id])\\n            heapq.heappush(booked, (curr_time + (meetings[i][1] - meetings[i][0]), room_id))\\n            curr_time = meetings[i+1][0] if i + 1 < len(meetings) else curr_time\\n            i += 1\\n\\n        for i in range(n):\\n            if rooms[i] == max_meets:\\n                return i\\n```"
                    },
                    {
                        "username": "frog445",
                        "content": "[@quanyincode](/quanyincode) It\\'s python lol why will it have integer overflow"
                    },
                    {
                        "username": "quanyincode",
                        "content": "See my comment about the two test cases that cause integer overflow."
                    },
                    {
                        "username": "jffiorillo",
                        "content": "Regarding this test: `[[1,27],[29,49],[47,49],[41,43],[15,36],[11,15]]` in theory the output is `1` but I did it manually and the output is `0`. Can you please explain me why the output is `1`?\\n\\nThe following is the explanation why I think the answer is `0`\\n\\n```\\n// Meetings ordered by start time : [Meeting(start=1, finish=27), Meeting(start=11, finish=15), Meeting(start=15, finish=36), Meeting(start=29, finish=49), Meeting(start=41, finish=43), Meeting(start=47, finish=49)]\\n\\nfirst meeting = Meeting(start=1, finish=27)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=0, numberOfMeetings=0), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nsecond meeting = Meeting(start=11, finish=15)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=15, numberOfMeetings=1), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nthird meeting = Meeting(start=15, finish=36)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nforth meeting  = Meeting(start=29, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nfifth meeting = Meeting(start=41, finish=43)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=43, numberOfMeetings=1)]\\n\\nlast meeting = Meeting(start=47, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=92, numberOfMeetings=2)]\\n\\nAll room has been booking twice, so the answer is 0.\\n```"
                    },
                    {
                        "username": "vandanakumari13998",
                        "content": "Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\\nI didn\\'t get this example. How is the output 0. Because at time 8, [4,9] meeting will end. Hence 2 meeting room will be empty and [6,8] one would be scheduled at that time. And how is the output given as 1."
                    },
                    {
                        "username": "superZero",
                        "content": "Is the solution flawed?  I see that the solution is to delay 1 meeting till 1 room becomes available.\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                current_end, room = heappop(running_meetings)\\n                new_end = current_end + meetings[i][1] - meetings[i][0]  # Update the room\\'s end time\\n                heappush(running_meetings, (new_end, room))\\n\\n            meetings_per_room[room] +=1\\n            i +=1\\n\\nBut reality should be that all the remaining meetings whose start time is < end_time of the 1st available room should be delayed.\\n\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                for j in range (i, size):\\n                    if meetings[j][0] < running_meetings[0][0]:\\n                        meetings[j][0] += delta \\n                        meetings[j][1] +=delta\\n                    else:\\n                        break\\n\\n"
                    },
                    {
                        "username": "jj3100",
                        "content": "I used Integer types and finally managed to pass all tests. The main issue that caused me to fail on the 80/82 and 81/82 test cases is that when the end times are equal, the PriorityQueue should also compare the room numbers."
                    },
                    {
                        "username": "magomez4",
                        "content": "Passing 82 test cases but TLE? My code is the same idea as others I\\'m seeing in the submissions, and it passes all test cases, but I get a TLE and it says \"82/82\" test cases passed. It also says that the last executed input is \"n=\" yes.. a blank \\'n\\'. Can anyone tell me if this is a leetcode problem or what am I doing wrong? Any help is greatly appreciated!! \\n\\nHere is my approach:\\n ```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // keep an array for the number of bookings of\\n        // each room.\\n        // also keep a mostBooked variable that gets\\n        // updated every time a room is used.\\n        // To assign a meeting to a room, check if\\n        // the meeting starts before the earliest-finishing\\n        // scheduled meeting. If so, assign a new room. If\\n        // there are no more rooms, wait until the earliest\\n        // finishing room, and use that one. If the meeting\\n        // starts after the earliest-finishing room becomes \\n        // free, then continue to \"free-up\" rooms until\\n        // there are no rooms booked or the earliest finishing\\n        // is later than the current start time. After this,\\n        // use the same logic as above to assign the next\\n        // available room.\\n\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        // ensure meetings are sorted by start time\\n        sort(meetings.begin(),meetings.end(), comparator);\\n\\n        int bookingCount[n];\\n        fill_n(bookingCount, n, 0);\\n        int mostBooked = -1;\\n        // We declare a min-heap that holds <endTime, roomNumber> \\n        // to keep the min end time at the front.\\n        priority_queue<vector<long>, vector<vector<long>>, greater<vector<long>>> freeAt; \\n        priority_queue<int,vector<int>,greater<int>> emptyRooms;\\n        for(int i = 0; i < n; i++)\\n        {\\n            emptyRooms.push(i);\\n        }\\n\\n        for(int i = 0; i < meetings.size(); i++)\\n        {\\n            if(mostBooked == -1)\\n            {\\n                mostBooked = 0;\\n                bookingCount[mostBooked]++;\\n                vector<long> newFreeAt = {meetings[i][1], mostBooked}; \\n                freeAt.push(newFreeAt);\\n                emptyRooms.pop();\\n            }\\n            else\\n            {\\n                // if(meetings[i][0] < freeAt.top().first )\\n                if(meetings[i][0] < freeAt.top()[0] )\\n                {\\n                    // current meeting start time is earlier\\n                    // than the earliest-finishing scheduled meeting\\n                    if(freeAt.size() < n)\\n                    {\\n                        // there are available rooms, so book the next available\\n                        vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                    else\\n                    {\\n                        // there are no more available rooms, so this will haven\\n                        // to wait for the earliest finishing scheduled meeting\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        int meetingDuration = meetings[i][1] - meetings[i][0];//end time - start time\\n                        long newEndTime = freeAt.top()[0] + meetingDuration;\\n                        freeAt.pop();\\n                        vector<long> newFreeAt = {newEndTime, emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                }\\n                else\\n                {\\n                    // current meeting start time is later than the earliest\\n                    // finishing scheduled meeting. \\n                    while(!freeAt.empty() \\n                    && meetings[i][0] >= freeAt.top()[0])\\n                    {\\n                        // let the meetings finish to make sure \\n                        // we get the room with the smallest number\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        freeAt.pop();\\n                    }\\n                    vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                    freeAt.push(newFreeAt);\\n                    bookingCount[emptyRooms.top()]++;\\n                    mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                    emptyRooms.pop();\\n                }\\n            }\\n        }\\n        return mostBooked;\\n    }\\n    static bool comparator(vector<int> a, vector<int> b)\\n    {\\n        if(a[0] <= b[0])\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int updateMostBooked(int mostBooked, int newlyBooked, int bookingCount[])\\n    {\\n        int newMostBooked;\\n        if(bookingCount[newlyBooked] > bookingCount[mostBooked])\\n        {\\n            newMostBooked = newlyBooked;\\n        }\\n        else if (bookingCount[newlyBooked] == bookingCount[mostBooked])\\n        {\\n            // if two rooms have the same amount of meetings,\\n            // we consider the room with the smallest ID as \\n            // the most booked\\n            newMostBooked = min(newlyBooked, mostBooked);\\n        }\\n        else\\n        {\\n            newMostBooked = mostBooked;\\n        }\\n        return newMostBooked;\\n    }\\n};\\n```\\n"
                    }
                ]
            },
            {
                "id": 1940407,
                "content": [
                    {
                        "username": "quanyincode",
                        "content": "If you are wondering why your solution past 80/82 test cases, it it due to the two test cases with long inputs, which will cause integer overflow on the meeting end time. Use Long instead of Integer to track a room\\'s end time should solve the problem."
                    },
                    {
                        "username": "jerome1210",
                        "content": "May someone explain why this meetings [[0,10],[1,9],[2,8],[3,7],[4,6]] will return 1?\nI thought it should be \n1. room: 0, time 10 (0+10)\n2. room: 1, time 10 (1+9)\n3. room: 2, time 10 (2+8)\n4. room: 0, time 17 (10+7)\n5. room: 1, time 16 (10 + 6)\n\nSo, the room 0, 1 will held 2 meetings, then it should return 0 ?\n"
                    },
                    {
                        "username": "user0081T",
                        "content": "The second meeting will end at time: 9 not 10, same thing for the third meeting, it will end at time 8, not 10.  Because the the second argument for each meeting is the end time of the meeting and not the duration of it. "
                    },
                    {
                        "username": "shru15",
                        "content": "After meeting 3, the earliest free room will be room 2\\nso [3,7] -> [3+8, 7+8] at room 2\\nand 4,6 -> [4+9, 6+9] at room 1\\nsince room 0 gets freed at last, only one meeting will take place there."
                    },
                    {
                        "username": "anshil1611",
                        "content": "For the people who are confused with WA at 80/82:\\n\\nI am seeing lot of comments where people are saying its because of integer overflow. Seemingly true, however if you are using a PriorityQueue of type Pair<Integer, Integer>, that is where all the problem is occurring. Just change the type of the priority queue from Pair<Integer, Integer> to int[] (yes, no Long required) and your solution would pass the remaining test cases.\\n\\nIt seems like Pair<Integer, Integer> is not able to handle large values, and the same code which fails with Pair<Integer, Integer>, passes all test cases with int[]."
                    },
                    {
                        "username": "spark6015",
                        "content": "are we even allow to use heapq.heapify() function in the interview?"
                    },
                    {
                        "username": "strangeranda",
                        "content": "Yes, you could ask the interviewer if you could use built-in functions, and 10/10 they\\u2019d say yes. I could be wrong in 10/10, but I never faced any instance where I couldn\\u2019t use. "
                    },
                    {
                        "username": "Tanayk",
                        "content": "Can someone please help me identify the error in this code? 80/82 test cases are passing. \\nThank you\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        rooms = collections.defaultdict(int)\\n        meetings.sort()\\n        booked, free = [], []\\n        max_meets = 0\\n        for i in range(n):\\n            heapq.heappush(booked, (0, i))\\n\\n        i, curr_time = 0, meetings[0][0]\\n        while i < len(meetings):\\n            while booked and booked[0][0] <= curr_time:\\n                free_time, index = heapq.heappop(booked)\\n                heapq.heappush(free, (index, free_time))\\n\\n            if not free:\\n                curr_time = booked[0][0]\\n                continue\\n\\n            room_id, _ = heapq.heappop(free)\\n            rooms[room_id] += 1\\n            max_meets = max(max_meets, rooms[room_id])\\n            heapq.heappush(booked, (curr_time + (meetings[i][1] - meetings[i][0]), room_id))\\n            curr_time = meetings[i+1][0] if i + 1 < len(meetings) else curr_time\\n            i += 1\\n\\n        for i in range(n):\\n            if rooms[i] == max_meets:\\n                return i\\n```"
                    },
                    {
                        "username": "frog445",
                        "content": "[@quanyincode](/quanyincode) It\\'s python lol why will it have integer overflow"
                    },
                    {
                        "username": "quanyincode",
                        "content": "See my comment about the two test cases that cause integer overflow."
                    },
                    {
                        "username": "jffiorillo",
                        "content": "Regarding this test: `[[1,27],[29,49],[47,49],[41,43],[15,36],[11,15]]` in theory the output is `1` but I did it manually and the output is `0`. Can you please explain me why the output is `1`?\\n\\nThe following is the explanation why I think the answer is `0`\\n\\n```\\n// Meetings ordered by start time : [Meeting(start=1, finish=27), Meeting(start=11, finish=15), Meeting(start=15, finish=36), Meeting(start=29, finish=49), Meeting(start=41, finish=43), Meeting(start=47, finish=49)]\\n\\nfirst meeting = Meeting(start=1, finish=27)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=0, numberOfMeetings=0), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nsecond meeting = Meeting(start=11, finish=15)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=15, numberOfMeetings=1), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nthird meeting = Meeting(start=15, finish=36)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nforth meeting  = Meeting(start=29, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nfifth meeting = Meeting(start=41, finish=43)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=43, numberOfMeetings=1)]\\n\\nlast meeting = Meeting(start=47, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=92, numberOfMeetings=2)]\\n\\nAll room has been booking twice, so the answer is 0.\\n```"
                    },
                    {
                        "username": "vandanakumari13998",
                        "content": "Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\\nI didn\\'t get this example. How is the output 0. Because at time 8, [4,9] meeting will end. Hence 2 meeting room will be empty and [6,8] one would be scheduled at that time. And how is the output given as 1."
                    },
                    {
                        "username": "superZero",
                        "content": "Is the solution flawed?  I see that the solution is to delay 1 meeting till 1 room becomes available.\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                current_end, room = heappop(running_meetings)\\n                new_end = current_end + meetings[i][1] - meetings[i][0]  # Update the room\\'s end time\\n                heappush(running_meetings, (new_end, room))\\n\\n            meetings_per_room[room] +=1\\n            i +=1\\n\\nBut reality should be that all the remaining meetings whose start time is < end_time of the 1st available room should be delayed.\\n\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                for j in range (i, size):\\n                    if meetings[j][0] < running_meetings[0][0]:\\n                        meetings[j][0] += delta \\n                        meetings[j][1] +=delta\\n                    else:\\n                        break\\n\\n"
                    },
                    {
                        "username": "jj3100",
                        "content": "I used Integer types and finally managed to pass all tests. The main issue that caused me to fail on the 80/82 and 81/82 test cases is that when the end times are equal, the PriorityQueue should also compare the room numbers."
                    },
                    {
                        "username": "magomez4",
                        "content": "Passing 82 test cases but TLE? My code is the same idea as others I\\'m seeing in the submissions, and it passes all test cases, but I get a TLE and it says \"82/82\" test cases passed. It also says that the last executed input is \"n=\" yes.. a blank \\'n\\'. Can anyone tell me if this is a leetcode problem or what am I doing wrong? Any help is greatly appreciated!! \\n\\nHere is my approach:\\n ```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // keep an array for the number of bookings of\\n        // each room.\\n        // also keep a mostBooked variable that gets\\n        // updated every time a room is used.\\n        // To assign a meeting to a room, check if\\n        // the meeting starts before the earliest-finishing\\n        // scheduled meeting. If so, assign a new room. If\\n        // there are no more rooms, wait until the earliest\\n        // finishing room, and use that one. If the meeting\\n        // starts after the earliest-finishing room becomes \\n        // free, then continue to \"free-up\" rooms until\\n        // there are no rooms booked or the earliest finishing\\n        // is later than the current start time. After this,\\n        // use the same logic as above to assign the next\\n        // available room.\\n\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        // ensure meetings are sorted by start time\\n        sort(meetings.begin(),meetings.end(), comparator);\\n\\n        int bookingCount[n];\\n        fill_n(bookingCount, n, 0);\\n        int mostBooked = -1;\\n        // We declare a min-heap that holds <endTime, roomNumber> \\n        // to keep the min end time at the front.\\n        priority_queue<vector<long>, vector<vector<long>>, greater<vector<long>>> freeAt; \\n        priority_queue<int,vector<int>,greater<int>> emptyRooms;\\n        for(int i = 0; i < n; i++)\\n        {\\n            emptyRooms.push(i);\\n        }\\n\\n        for(int i = 0; i < meetings.size(); i++)\\n        {\\n            if(mostBooked == -1)\\n            {\\n                mostBooked = 0;\\n                bookingCount[mostBooked]++;\\n                vector<long> newFreeAt = {meetings[i][1], mostBooked}; \\n                freeAt.push(newFreeAt);\\n                emptyRooms.pop();\\n            }\\n            else\\n            {\\n                // if(meetings[i][0] < freeAt.top().first )\\n                if(meetings[i][0] < freeAt.top()[0] )\\n                {\\n                    // current meeting start time is earlier\\n                    // than the earliest-finishing scheduled meeting\\n                    if(freeAt.size() < n)\\n                    {\\n                        // there are available rooms, so book the next available\\n                        vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                    else\\n                    {\\n                        // there are no more available rooms, so this will haven\\n                        // to wait for the earliest finishing scheduled meeting\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        int meetingDuration = meetings[i][1] - meetings[i][0];//end time - start time\\n                        long newEndTime = freeAt.top()[0] + meetingDuration;\\n                        freeAt.pop();\\n                        vector<long> newFreeAt = {newEndTime, emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                }\\n                else\\n                {\\n                    // current meeting start time is later than the earliest\\n                    // finishing scheduled meeting. \\n                    while(!freeAt.empty() \\n                    && meetings[i][0] >= freeAt.top()[0])\\n                    {\\n                        // let the meetings finish to make sure \\n                        // we get the room with the smallest number\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        freeAt.pop();\\n                    }\\n                    vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                    freeAt.push(newFreeAt);\\n                    bookingCount[emptyRooms.top()]++;\\n                    mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                    emptyRooms.pop();\\n                }\\n            }\\n        }\\n        return mostBooked;\\n    }\\n    static bool comparator(vector<int> a, vector<int> b)\\n    {\\n        if(a[0] <= b[0])\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int updateMostBooked(int mostBooked, int newlyBooked, int bookingCount[])\\n    {\\n        int newMostBooked;\\n        if(bookingCount[newlyBooked] > bookingCount[mostBooked])\\n        {\\n            newMostBooked = newlyBooked;\\n        }\\n        else if (bookingCount[newlyBooked] == bookingCount[mostBooked])\\n        {\\n            // if two rooms have the same amount of meetings,\\n            // we consider the room with the smallest ID as \\n            // the most booked\\n            newMostBooked = min(newlyBooked, mostBooked);\\n        }\\n        else\\n        {\\n            newMostBooked = mostBooked;\\n        }\\n        return newMostBooked;\\n    }\\n};\\n```\\n"
                    }
                ]
            },
            {
                "id": 1941456,
                "content": [
                    {
                        "username": "quanyincode",
                        "content": "If you are wondering why your solution past 80/82 test cases, it it due to the two test cases with long inputs, which will cause integer overflow on the meeting end time. Use Long instead of Integer to track a room\\'s end time should solve the problem."
                    },
                    {
                        "username": "jerome1210",
                        "content": "May someone explain why this meetings [[0,10],[1,9],[2,8],[3,7],[4,6]] will return 1?\nI thought it should be \n1. room: 0, time 10 (0+10)\n2. room: 1, time 10 (1+9)\n3. room: 2, time 10 (2+8)\n4. room: 0, time 17 (10+7)\n5. room: 1, time 16 (10 + 6)\n\nSo, the room 0, 1 will held 2 meetings, then it should return 0 ?\n"
                    },
                    {
                        "username": "user0081T",
                        "content": "The second meeting will end at time: 9 not 10, same thing for the third meeting, it will end at time 8, not 10.  Because the the second argument for each meeting is the end time of the meeting and not the duration of it. "
                    },
                    {
                        "username": "shru15",
                        "content": "After meeting 3, the earliest free room will be room 2\\nso [3,7] -> [3+8, 7+8] at room 2\\nand 4,6 -> [4+9, 6+9] at room 1\\nsince room 0 gets freed at last, only one meeting will take place there."
                    },
                    {
                        "username": "anshil1611",
                        "content": "For the people who are confused with WA at 80/82:\\n\\nI am seeing lot of comments where people are saying its because of integer overflow. Seemingly true, however if you are using a PriorityQueue of type Pair<Integer, Integer>, that is where all the problem is occurring. Just change the type of the priority queue from Pair<Integer, Integer> to int[] (yes, no Long required) and your solution would pass the remaining test cases.\\n\\nIt seems like Pair<Integer, Integer> is not able to handle large values, and the same code which fails with Pair<Integer, Integer>, passes all test cases with int[]."
                    },
                    {
                        "username": "spark6015",
                        "content": "are we even allow to use heapq.heapify() function in the interview?"
                    },
                    {
                        "username": "strangeranda",
                        "content": "Yes, you could ask the interviewer if you could use built-in functions, and 10/10 they\\u2019d say yes. I could be wrong in 10/10, but I never faced any instance where I couldn\\u2019t use. "
                    },
                    {
                        "username": "Tanayk",
                        "content": "Can someone please help me identify the error in this code? 80/82 test cases are passing. \\nThank you\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        rooms = collections.defaultdict(int)\\n        meetings.sort()\\n        booked, free = [], []\\n        max_meets = 0\\n        for i in range(n):\\n            heapq.heappush(booked, (0, i))\\n\\n        i, curr_time = 0, meetings[0][0]\\n        while i < len(meetings):\\n            while booked and booked[0][0] <= curr_time:\\n                free_time, index = heapq.heappop(booked)\\n                heapq.heappush(free, (index, free_time))\\n\\n            if not free:\\n                curr_time = booked[0][0]\\n                continue\\n\\n            room_id, _ = heapq.heappop(free)\\n            rooms[room_id] += 1\\n            max_meets = max(max_meets, rooms[room_id])\\n            heapq.heappush(booked, (curr_time + (meetings[i][1] - meetings[i][0]), room_id))\\n            curr_time = meetings[i+1][0] if i + 1 < len(meetings) else curr_time\\n            i += 1\\n\\n        for i in range(n):\\n            if rooms[i] == max_meets:\\n                return i\\n```"
                    },
                    {
                        "username": "frog445",
                        "content": "[@quanyincode](/quanyincode) It\\'s python lol why will it have integer overflow"
                    },
                    {
                        "username": "quanyincode",
                        "content": "See my comment about the two test cases that cause integer overflow."
                    },
                    {
                        "username": "jffiorillo",
                        "content": "Regarding this test: `[[1,27],[29,49],[47,49],[41,43],[15,36],[11,15]]` in theory the output is `1` but I did it manually and the output is `0`. Can you please explain me why the output is `1`?\\n\\nThe following is the explanation why I think the answer is `0`\\n\\n```\\n// Meetings ordered by start time : [Meeting(start=1, finish=27), Meeting(start=11, finish=15), Meeting(start=15, finish=36), Meeting(start=29, finish=49), Meeting(start=41, finish=43), Meeting(start=47, finish=49)]\\n\\nfirst meeting = Meeting(start=1, finish=27)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=0, numberOfMeetings=0), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nsecond meeting = Meeting(start=11, finish=15)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=15, numberOfMeetings=1), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nthird meeting = Meeting(start=15, finish=36)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nforth meeting  = Meeting(start=29, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nfifth meeting = Meeting(start=41, finish=43)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=43, numberOfMeetings=1)]\\n\\nlast meeting = Meeting(start=47, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=92, numberOfMeetings=2)]\\n\\nAll room has been booking twice, so the answer is 0.\\n```"
                    },
                    {
                        "username": "vandanakumari13998",
                        "content": "Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\\nI didn\\'t get this example. How is the output 0. Because at time 8, [4,9] meeting will end. Hence 2 meeting room will be empty and [6,8] one would be scheduled at that time. And how is the output given as 1."
                    },
                    {
                        "username": "superZero",
                        "content": "Is the solution flawed?  I see that the solution is to delay 1 meeting till 1 room becomes available.\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                current_end, room = heappop(running_meetings)\\n                new_end = current_end + meetings[i][1] - meetings[i][0]  # Update the room\\'s end time\\n                heappush(running_meetings, (new_end, room))\\n\\n            meetings_per_room[room] +=1\\n            i +=1\\n\\nBut reality should be that all the remaining meetings whose start time is < end_time of the 1st available room should be delayed.\\n\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                for j in range (i, size):\\n                    if meetings[j][0] < running_meetings[0][0]:\\n                        meetings[j][0] += delta \\n                        meetings[j][1] +=delta\\n                    else:\\n                        break\\n\\n"
                    },
                    {
                        "username": "jj3100",
                        "content": "I used Integer types and finally managed to pass all tests. The main issue that caused me to fail on the 80/82 and 81/82 test cases is that when the end times are equal, the PriorityQueue should also compare the room numbers."
                    },
                    {
                        "username": "magomez4",
                        "content": "Passing 82 test cases but TLE? My code is the same idea as others I\\'m seeing in the submissions, and it passes all test cases, but I get a TLE and it says \"82/82\" test cases passed. It also says that the last executed input is \"n=\" yes.. a blank \\'n\\'. Can anyone tell me if this is a leetcode problem or what am I doing wrong? Any help is greatly appreciated!! \\n\\nHere is my approach:\\n ```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // keep an array for the number of bookings of\\n        // each room.\\n        // also keep a mostBooked variable that gets\\n        // updated every time a room is used.\\n        // To assign a meeting to a room, check if\\n        // the meeting starts before the earliest-finishing\\n        // scheduled meeting. If so, assign a new room. If\\n        // there are no more rooms, wait until the earliest\\n        // finishing room, and use that one. If the meeting\\n        // starts after the earliest-finishing room becomes \\n        // free, then continue to \"free-up\" rooms until\\n        // there are no rooms booked or the earliest finishing\\n        // is later than the current start time. After this,\\n        // use the same logic as above to assign the next\\n        // available room.\\n\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        // ensure meetings are sorted by start time\\n        sort(meetings.begin(),meetings.end(), comparator);\\n\\n        int bookingCount[n];\\n        fill_n(bookingCount, n, 0);\\n        int mostBooked = -1;\\n        // We declare a min-heap that holds <endTime, roomNumber> \\n        // to keep the min end time at the front.\\n        priority_queue<vector<long>, vector<vector<long>>, greater<vector<long>>> freeAt; \\n        priority_queue<int,vector<int>,greater<int>> emptyRooms;\\n        for(int i = 0; i < n; i++)\\n        {\\n            emptyRooms.push(i);\\n        }\\n\\n        for(int i = 0; i < meetings.size(); i++)\\n        {\\n            if(mostBooked == -1)\\n            {\\n                mostBooked = 0;\\n                bookingCount[mostBooked]++;\\n                vector<long> newFreeAt = {meetings[i][1], mostBooked}; \\n                freeAt.push(newFreeAt);\\n                emptyRooms.pop();\\n            }\\n            else\\n            {\\n                // if(meetings[i][0] < freeAt.top().first )\\n                if(meetings[i][0] < freeAt.top()[0] )\\n                {\\n                    // current meeting start time is earlier\\n                    // than the earliest-finishing scheduled meeting\\n                    if(freeAt.size() < n)\\n                    {\\n                        // there are available rooms, so book the next available\\n                        vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                    else\\n                    {\\n                        // there are no more available rooms, so this will haven\\n                        // to wait for the earliest finishing scheduled meeting\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        int meetingDuration = meetings[i][1] - meetings[i][0];//end time - start time\\n                        long newEndTime = freeAt.top()[0] + meetingDuration;\\n                        freeAt.pop();\\n                        vector<long> newFreeAt = {newEndTime, emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                }\\n                else\\n                {\\n                    // current meeting start time is later than the earliest\\n                    // finishing scheduled meeting. \\n                    while(!freeAt.empty() \\n                    && meetings[i][0] >= freeAt.top()[0])\\n                    {\\n                        // let the meetings finish to make sure \\n                        // we get the room with the smallest number\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        freeAt.pop();\\n                    }\\n                    vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                    freeAt.push(newFreeAt);\\n                    bookingCount[emptyRooms.top()]++;\\n                    mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                    emptyRooms.pop();\\n                }\\n            }\\n        }\\n        return mostBooked;\\n    }\\n    static bool comparator(vector<int> a, vector<int> b)\\n    {\\n        if(a[0] <= b[0])\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int updateMostBooked(int mostBooked, int newlyBooked, int bookingCount[])\\n    {\\n        int newMostBooked;\\n        if(bookingCount[newlyBooked] > bookingCount[mostBooked])\\n        {\\n            newMostBooked = newlyBooked;\\n        }\\n        else if (bookingCount[newlyBooked] == bookingCount[mostBooked])\\n        {\\n            // if two rooms have the same amount of meetings,\\n            // we consider the room with the smallest ID as \\n            // the most booked\\n            newMostBooked = min(newlyBooked, mostBooked);\\n        }\\n        else\\n        {\\n            newMostBooked = mostBooked;\\n        }\\n        return newMostBooked;\\n    }\\n};\\n```\\n"
                    }
                ]
            },
            {
                "id": 2070608,
                "content": [
                    {
                        "username": "quanyincode",
                        "content": "If you are wondering why your solution past 80/82 test cases, it it due to the two test cases with long inputs, which will cause integer overflow on the meeting end time. Use Long instead of Integer to track a room\\'s end time should solve the problem."
                    },
                    {
                        "username": "jerome1210",
                        "content": "May someone explain why this meetings [[0,10],[1,9],[2,8],[3,7],[4,6]] will return 1?\nI thought it should be \n1. room: 0, time 10 (0+10)\n2. room: 1, time 10 (1+9)\n3. room: 2, time 10 (2+8)\n4. room: 0, time 17 (10+7)\n5. room: 1, time 16 (10 + 6)\n\nSo, the room 0, 1 will held 2 meetings, then it should return 0 ?\n"
                    },
                    {
                        "username": "user0081T",
                        "content": "The second meeting will end at time: 9 not 10, same thing for the third meeting, it will end at time 8, not 10.  Because the the second argument for each meeting is the end time of the meeting and not the duration of it. "
                    },
                    {
                        "username": "shru15",
                        "content": "After meeting 3, the earliest free room will be room 2\\nso [3,7] -> [3+8, 7+8] at room 2\\nand 4,6 -> [4+9, 6+9] at room 1\\nsince room 0 gets freed at last, only one meeting will take place there."
                    },
                    {
                        "username": "anshil1611",
                        "content": "For the people who are confused with WA at 80/82:\\n\\nI am seeing lot of comments where people are saying its because of integer overflow. Seemingly true, however if you are using a PriorityQueue of type Pair<Integer, Integer>, that is where all the problem is occurring. Just change the type of the priority queue from Pair<Integer, Integer> to int[] (yes, no Long required) and your solution would pass the remaining test cases.\\n\\nIt seems like Pair<Integer, Integer> is not able to handle large values, and the same code which fails with Pair<Integer, Integer>, passes all test cases with int[]."
                    },
                    {
                        "username": "spark6015",
                        "content": "are we even allow to use heapq.heapify() function in the interview?"
                    },
                    {
                        "username": "strangeranda",
                        "content": "Yes, you could ask the interviewer if you could use built-in functions, and 10/10 they\\u2019d say yes. I could be wrong in 10/10, but I never faced any instance where I couldn\\u2019t use. "
                    },
                    {
                        "username": "Tanayk",
                        "content": "Can someone please help me identify the error in this code? 80/82 test cases are passing. \\nThank you\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        rooms = collections.defaultdict(int)\\n        meetings.sort()\\n        booked, free = [], []\\n        max_meets = 0\\n        for i in range(n):\\n            heapq.heappush(booked, (0, i))\\n\\n        i, curr_time = 0, meetings[0][0]\\n        while i < len(meetings):\\n            while booked and booked[0][0] <= curr_time:\\n                free_time, index = heapq.heappop(booked)\\n                heapq.heappush(free, (index, free_time))\\n\\n            if not free:\\n                curr_time = booked[0][0]\\n                continue\\n\\n            room_id, _ = heapq.heappop(free)\\n            rooms[room_id] += 1\\n            max_meets = max(max_meets, rooms[room_id])\\n            heapq.heappush(booked, (curr_time + (meetings[i][1] - meetings[i][0]), room_id))\\n            curr_time = meetings[i+1][0] if i + 1 < len(meetings) else curr_time\\n            i += 1\\n\\n        for i in range(n):\\n            if rooms[i] == max_meets:\\n                return i\\n```"
                    },
                    {
                        "username": "frog445",
                        "content": "[@quanyincode](/quanyincode) It\\'s python lol why will it have integer overflow"
                    },
                    {
                        "username": "quanyincode",
                        "content": "See my comment about the two test cases that cause integer overflow."
                    },
                    {
                        "username": "jffiorillo",
                        "content": "Regarding this test: `[[1,27],[29,49],[47,49],[41,43],[15,36],[11,15]]` in theory the output is `1` but I did it manually and the output is `0`. Can you please explain me why the output is `1`?\\n\\nThe following is the explanation why I think the answer is `0`\\n\\n```\\n// Meetings ordered by start time : [Meeting(start=1, finish=27), Meeting(start=11, finish=15), Meeting(start=15, finish=36), Meeting(start=29, finish=49), Meeting(start=41, finish=43), Meeting(start=47, finish=49)]\\n\\nfirst meeting = Meeting(start=1, finish=27)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=0, numberOfMeetings=0), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nsecond meeting = Meeting(start=11, finish=15)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=15, numberOfMeetings=1), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nthird meeting = Meeting(start=15, finish=36)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nforth meeting  = Meeting(start=29, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nfifth meeting = Meeting(start=41, finish=43)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=43, numberOfMeetings=1)]\\n\\nlast meeting = Meeting(start=47, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=92, numberOfMeetings=2)]\\n\\nAll room has been booking twice, so the answer is 0.\\n```"
                    },
                    {
                        "username": "vandanakumari13998",
                        "content": "Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\\nI didn\\'t get this example. How is the output 0. Because at time 8, [4,9] meeting will end. Hence 2 meeting room will be empty and [6,8] one would be scheduled at that time. And how is the output given as 1."
                    },
                    {
                        "username": "superZero",
                        "content": "Is the solution flawed?  I see that the solution is to delay 1 meeting till 1 room becomes available.\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                current_end, room = heappop(running_meetings)\\n                new_end = current_end + meetings[i][1] - meetings[i][0]  # Update the room\\'s end time\\n                heappush(running_meetings, (new_end, room))\\n\\n            meetings_per_room[room] +=1\\n            i +=1\\n\\nBut reality should be that all the remaining meetings whose start time is < end_time of the 1st available room should be delayed.\\n\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                for j in range (i, size):\\n                    if meetings[j][0] < running_meetings[0][0]:\\n                        meetings[j][0] += delta \\n                        meetings[j][1] +=delta\\n                    else:\\n                        break\\n\\n"
                    },
                    {
                        "username": "jj3100",
                        "content": "I used Integer types and finally managed to pass all tests. The main issue that caused me to fail on the 80/82 and 81/82 test cases is that when the end times are equal, the PriorityQueue should also compare the room numbers."
                    },
                    {
                        "username": "magomez4",
                        "content": "Passing 82 test cases but TLE? My code is the same idea as others I\\'m seeing in the submissions, and it passes all test cases, but I get a TLE and it says \"82/82\" test cases passed. It also says that the last executed input is \"n=\" yes.. a blank \\'n\\'. Can anyone tell me if this is a leetcode problem or what am I doing wrong? Any help is greatly appreciated!! \\n\\nHere is my approach:\\n ```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // keep an array for the number of bookings of\\n        // each room.\\n        // also keep a mostBooked variable that gets\\n        // updated every time a room is used.\\n        // To assign a meeting to a room, check if\\n        // the meeting starts before the earliest-finishing\\n        // scheduled meeting. If so, assign a new room. If\\n        // there are no more rooms, wait until the earliest\\n        // finishing room, and use that one. If the meeting\\n        // starts after the earliest-finishing room becomes \\n        // free, then continue to \"free-up\" rooms until\\n        // there are no rooms booked or the earliest finishing\\n        // is later than the current start time. After this,\\n        // use the same logic as above to assign the next\\n        // available room.\\n\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        // ensure meetings are sorted by start time\\n        sort(meetings.begin(),meetings.end(), comparator);\\n\\n        int bookingCount[n];\\n        fill_n(bookingCount, n, 0);\\n        int mostBooked = -1;\\n        // We declare a min-heap that holds <endTime, roomNumber> \\n        // to keep the min end time at the front.\\n        priority_queue<vector<long>, vector<vector<long>>, greater<vector<long>>> freeAt; \\n        priority_queue<int,vector<int>,greater<int>> emptyRooms;\\n        for(int i = 0; i < n; i++)\\n        {\\n            emptyRooms.push(i);\\n        }\\n\\n        for(int i = 0; i < meetings.size(); i++)\\n        {\\n            if(mostBooked == -1)\\n            {\\n                mostBooked = 0;\\n                bookingCount[mostBooked]++;\\n                vector<long> newFreeAt = {meetings[i][1], mostBooked}; \\n                freeAt.push(newFreeAt);\\n                emptyRooms.pop();\\n            }\\n            else\\n            {\\n                // if(meetings[i][0] < freeAt.top().first )\\n                if(meetings[i][0] < freeAt.top()[0] )\\n                {\\n                    // current meeting start time is earlier\\n                    // than the earliest-finishing scheduled meeting\\n                    if(freeAt.size() < n)\\n                    {\\n                        // there are available rooms, so book the next available\\n                        vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                    else\\n                    {\\n                        // there are no more available rooms, so this will haven\\n                        // to wait for the earliest finishing scheduled meeting\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        int meetingDuration = meetings[i][1] - meetings[i][0];//end time - start time\\n                        long newEndTime = freeAt.top()[0] + meetingDuration;\\n                        freeAt.pop();\\n                        vector<long> newFreeAt = {newEndTime, emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                }\\n                else\\n                {\\n                    // current meeting start time is later than the earliest\\n                    // finishing scheduled meeting. \\n                    while(!freeAt.empty() \\n                    && meetings[i][0] >= freeAt.top()[0])\\n                    {\\n                        // let the meetings finish to make sure \\n                        // we get the room with the smallest number\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        freeAt.pop();\\n                    }\\n                    vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                    freeAt.push(newFreeAt);\\n                    bookingCount[emptyRooms.top()]++;\\n                    mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                    emptyRooms.pop();\\n                }\\n            }\\n        }\\n        return mostBooked;\\n    }\\n    static bool comparator(vector<int> a, vector<int> b)\\n    {\\n        if(a[0] <= b[0])\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int updateMostBooked(int mostBooked, int newlyBooked, int bookingCount[])\\n    {\\n        int newMostBooked;\\n        if(bookingCount[newlyBooked] > bookingCount[mostBooked])\\n        {\\n            newMostBooked = newlyBooked;\\n        }\\n        else if (bookingCount[newlyBooked] == bookingCount[mostBooked])\\n        {\\n            // if two rooms have the same amount of meetings,\\n            // we consider the room with the smallest ID as \\n            // the most booked\\n            newMostBooked = min(newlyBooked, mostBooked);\\n        }\\n        else\\n        {\\n            newMostBooked = mostBooked;\\n        }\\n        return newMostBooked;\\n    }\\n};\\n```\\n"
                    }
                ]
            },
            {
                "id": 1777141,
                "content": [
                    {
                        "username": "quanyincode",
                        "content": "If you are wondering why your solution past 80/82 test cases, it it due to the two test cases with long inputs, which will cause integer overflow on the meeting end time. Use Long instead of Integer to track a room\\'s end time should solve the problem."
                    },
                    {
                        "username": "jerome1210",
                        "content": "May someone explain why this meetings [[0,10],[1,9],[2,8],[3,7],[4,6]] will return 1?\nI thought it should be \n1. room: 0, time 10 (0+10)\n2. room: 1, time 10 (1+9)\n3. room: 2, time 10 (2+8)\n4. room: 0, time 17 (10+7)\n5. room: 1, time 16 (10 + 6)\n\nSo, the room 0, 1 will held 2 meetings, then it should return 0 ?\n"
                    },
                    {
                        "username": "user0081T",
                        "content": "The second meeting will end at time: 9 not 10, same thing for the third meeting, it will end at time 8, not 10.  Because the the second argument for each meeting is the end time of the meeting and not the duration of it. "
                    },
                    {
                        "username": "shru15",
                        "content": "After meeting 3, the earliest free room will be room 2\\nso [3,7] -> [3+8, 7+8] at room 2\\nand 4,6 -> [4+9, 6+9] at room 1\\nsince room 0 gets freed at last, only one meeting will take place there."
                    },
                    {
                        "username": "anshil1611",
                        "content": "For the people who are confused with WA at 80/82:\\n\\nI am seeing lot of comments where people are saying its because of integer overflow. Seemingly true, however if you are using a PriorityQueue of type Pair<Integer, Integer>, that is where all the problem is occurring. Just change the type of the priority queue from Pair<Integer, Integer> to int[] (yes, no Long required) and your solution would pass the remaining test cases.\\n\\nIt seems like Pair<Integer, Integer> is not able to handle large values, and the same code which fails with Pair<Integer, Integer>, passes all test cases with int[]."
                    },
                    {
                        "username": "spark6015",
                        "content": "are we even allow to use heapq.heapify() function in the interview?"
                    },
                    {
                        "username": "strangeranda",
                        "content": "Yes, you could ask the interviewer if you could use built-in functions, and 10/10 they\\u2019d say yes. I could be wrong in 10/10, but I never faced any instance where I couldn\\u2019t use. "
                    },
                    {
                        "username": "Tanayk",
                        "content": "Can someone please help me identify the error in this code? 80/82 test cases are passing. \\nThank you\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        rooms = collections.defaultdict(int)\\n        meetings.sort()\\n        booked, free = [], []\\n        max_meets = 0\\n        for i in range(n):\\n            heapq.heappush(booked, (0, i))\\n\\n        i, curr_time = 0, meetings[0][0]\\n        while i < len(meetings):\\n            while booked and booked[0][0] <= curr_time:\\n                free_time, index = heapq.heappop(booked)\\n                heapq.heappush(free, (index, free_time))\\n\\n            if not free:\\n                curr_time = booked[0][0]\\n                continue\\n\\n            room_id, _ = heapq.heappop(free)\\n            rooms[room_id] += 1\\n            max_meets = max(max_meets, rooms[room_id])\\n            heapq.heappush(booked, (curr_time + (meetings[i][1] - meetings[i][0]), room_id))\\n            curr_time = meetings[i+1][0] if i + 1 < len(meetings) else curr_time\\n            i += 1\\n\\n        for i in range(n):\\n            if rooms[i] == max_meets:\\n                return i\\n```"
                    },
                    {
                        "username": "frog445",
                        "content": "[@quanyincode](/quanyincode) It\\'s python lol why will it have integer overflow"
                    },
                    {
                        "username": "quanyincode",
                        "content": "See my comment about the two test cases that cause integer overflow."
                    },
                    {
                        "username": "jffiorillo",
                        "content": "Regarding this test: `[[1,27],[29,49],[47,49],[41,43],[15,36],[11,15]]` in theory the output is `1` but I did it manually and the output is `0`. Can you please explain me why the output is `1`?\\n\\nThe following is the explanation why I think the answer is `0`\\n\\n```\\n// Meetings ordered by start time : [Meeting(start=1, finish=27), Meeting(start=11, finish=15), Meeting(start=15, finish=36), Meeting(start=29, finish=49), Meeting(start=41, finish=43), Meeting(start=47, finish=49)]\\n\\nfirst meeting = Meeting(start=1, finish=27)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=0, numberOfMeetings=0), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nsecond meeting = Meeting(start=11, finish=15)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=15, numberOfMeetings=1), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nthird meeting = Meeting(start=15, finish=36)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nforth meeting  = Meeting(start=29, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nfifth meeting = Meeting(start=41, finish=43)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=43, numberOfMeetings=1)]\\n\\nlast meeting = Meeting(start=47, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=92, numberOfMeetings=2)]\\n\\nAll room has been booking twice, so the answer is 0.\\n```"
                    },
                    {
                        "username": "vandanakumari13998",
                        "content": "Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\\nI didn\\'t get this example. How is the output 0. Because at time 8, [4,9] meeting will end. Hence 2 meeting room will be empty and [6,8] one would be scheduled at that time. And how is the output given as 1."
                    },
                    {
                        "username": "superZero",
                        "content": "Is the solution flawed?  I see that the solution is to delay 1 meeting till 1 room becomes available.\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                current_end, room = heappop(running_meetings)\\n                new_end = current_end + meetings[i][1] - meetings[i][0]  # Update the room\\'s end time\\n                heappush(running_meetings, (new_end, room))\\n\\n            meetings_per_room[room] +=1\\n            i +=1\\n\\nBut reality should be that all the remaining meetings whose start time is < end_time of the 1st available room should be delayed.\\n\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                for j in range (i, size):\\n                    if meetings[j][0] < running_meetings[0][0]:\\n                        meetings[j][0] += delta \\n                        meetings[j][1] +=delta\\n                    else:\\n                        break\\n\\n"
                    },
                    {
                        "username": "jj3100",
                        "content": "I used Integer types and finally managed to pass all tests. The main issue that caused me to fail on the 80/82 and 81/82 test cases is that when the end times are equal, the PriorityQueue should also compare the room numbers."
                    },
                    {
                        "username": "magomez4",
                        "content": "Passing 82 test cases but TLE? My code is the same idea as others I\\'m seeing in the submissions, and it passes all test cases, but I get a TLE and it says \"82/82\" test cases passed. It also says that the last executed input is \"n=\" yes.. a blank \\'n\\'. Can anyone tell me if this is a leetcode problem or what am I doing wrong? Any help is greatly appreciated!! \\n\\nHere is my approach:\\n ```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // keep an array for the number of bookings of\\n        // each room.\\n        // also keep a mostBooked variable that gets\\n        // updated every time a room is used.\\n        // To assign a meeting to a room, check if\\n        // the meeting starts before the earliest-finishing\\n        // scheduled meeting. If so, assign a new room. If\\n        // there are no more rooms, wait until the earliest\\n        // finishing room, and use that one. If the meeting\\n        // starts after the earliest-finishing room becomes \\n        // free, then continue to \"free-up\" rooms until\\n        // there are no rooms booked or the earliest finishing\\n        // is later than the current start time. After this,\\n        // use the same logic as above to assign the next\\n        // available room.\\n\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        // ensure meetings are sorted by start time\\n        sort(meetings.begin(),meetings.end(), comparator);\\n\\n        int bookingCount[n];\\n        fill_n(bookingCount, n, 0);\\n        int mostBooked = -1;\\n        // We declare a min-heap that holds <endTime, roomNumber> \\n        // to keep the min end time at the front.\\n        priority_queue<vector<long>, vector<vector<long>>, greater<vector<long>>> freeAt; \\n        priority_queue<int,vector<int>,greater<int>> emptyRooms;\\n        for(int i = 0; i < n; i++)\\n        {\\n            emptyRooms.push(i);\\n        }\\n\\n        for(int i = 0; i < meetings.size(); i++)\\n        {\\n            if(mostBooked == -1)\\n            {\\n                mostBooked = 0;\\n                bookingCount[mostBooked]++;\\n                vector<long> newFreeAt = {meetings[i][1], mostBooked}; \\n                freeAt.push(newFreeAt);\\n                emptyRooms.pop();\\n            }\\n            else\\n            {\\n                // if(meetings[i][0] < freeAt.top().first )\\n                if(meetings[i][0] < freeAt.top()[0] )\\n                {\\n                    // current meeting start time is earlier\\n                    // than the earliest-finishing scheduled meeting\\n                    if(freeAt.size() < n)\\n                    {\\n                        // there are available rooms, so book the next available\\n                        vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                    else\\n                    {\\n                        // there are no more available rooms, so this will haven\\n                        // to wait for the earliest finishing scheduled meeting\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        int meetingDuration = meetings[i][1] - meetings[i][0];//end time - start time\\n                        long newEndTime = freeAt.top()[0] + meetingDuration;\\n                        freeAt.pop();\\n                        vector<long> newFreeAt = {newEndTime, emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                }\\n                else\\n                {\\n                    // current meeting start time is later than the earliest\\n                    // finishing scheduled meeting. \\n                    while(!freeAt.empty() \\n                    && meetings[i][0] >= freeAt.top()[0])\\n                    {\\n                        // let the meetings finish to make sure \\n                        // we get the room with the smallest number\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        freeAt.pop();\\n                    }\\n                    vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                    freeAt.push(newFreeAt);\\n                    bookingCount[emptyRooms.top()]++;\\n                    mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                    emptyRooms.pop();\\n                }\\n            }\\n        }\\n        return mostBooked;\\n    }\\n    static bool comparator(vector<int> a, vector<int> b)\\n    {\\n        if(a[0] <= b[0])\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int updateMostBooked(int mostBooked, int newlyBooked, int bookingCount[])\\n    {\\n        int newMostBooked;\\n        if(bookingCount[newlyBooked] > bookingCount[mostBooked])\\n        {\\n            newMostBooked = newlyBooked;\\n        }\\n        else if (bookingCount[newlyBooked] == bookingCount[mostBooked])\\n        {\\n            // if two rooms have the same amount of meetings,\\n            // we consider the room with the smallest ID as \\n            // the most booked\\n            newMostBooked = min(newlyBooked, mostBooked);\\n        }\\n        else\\n        {\\n            newMostBooked = mostBooked;\\n        }\\n        return newMostBooked;\\n    }\\n};\\n```\\n"
                    }
                ]
            },
            {
                "id": 1705712,
                "content": [
                    {
                        "username": "quanyincode",
                        "content": "If you are wondering why your solution past 80/82 test cases, it it due to the two test cases with long inputs, which will cause integer overflow on the meeting end time. Use Long instead of Integer to track a room\\'s end time should solve the problem."
                    },
                    {
                        "username": "jerome1210",
                        "content": "May someone explain why this meetings [[0,10],[1,9],[2,8],[3,7],[4,6]] will return 1?\nI thought it should be \n1. room: 0, time 10 (0+10)\n2. room: 1, time 10 (1+9)\n3. room: 2, time 10 (2+8)\n4. room: 0, time 17 (10+7)\n5. room: 1, time 16 (10 + 6)\n\nSo, the room 0, 1 will held 2 meetings, then it should return 0 ?\n"
                    },
                    {
                        "username": "user0081T",
                        "content": "The second meeting will end at time: 9 not 10, same thing for the third meeting, it will end at time 8, not 10.  Because the the second argument for each meeting is the end time of the meeting and not the duration of it. "
                    },
                    {
                        "username": "shru15",
                        "content": "After meeting 3, the earliest free room will be room 2\\nso [3,7] -> [3+8, 7+8] at room 2\\nand 4,6 -> [4+9, 6+9] at room 1\\nsince room 0 gets freed at last, only one meeting will take place there."
                    },
                    {
                        "username": "anshil1611",
                        "content": "For the people who are confused with WA at 80/82:\\n\\nI am seeing lot of comments where people are saying its because of integer overflow. Seemingly true, however if you are using a PriorityQueue of type Pair<Integer, Integer>, that is where all the problem is occurring. Just change the type of the priority queue from Pair<Integer, Integer> to int[] (yes, no Long required) and your solution would pass the remaining test cases.\\n\\nIt seems like Pair<Integer, Integer> is not able to handle large values, and the same code which fails with Pair<Integer, Integer>, passes all test cases with int[]."
                    },
                    {
                        "username": "spark6015",
                        "content": "are we even allow to use heapq.heapify() function in the interview?"
                    },
                    {
                        "username": "strangeranda",
                        "content": "Yes, you could ask the interviewer if you could use built-in functions, and 10/10 they\\u2019d say yes. I could be wrong in 10/10, but I never faced any instance where I couldn\\u2019t use. "
                    },
                    {
                        "username": "Tanayk",
                        "content": "Can someone please help me identify the error in this code? 80/82 test cases are passing. \\nThank you\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        rooms = collections.defaultdict(int)\\n        meetings.sort()\\n        booked, free = [], []\\n        max_meets = 0\\n        for i in range(n):\\n            heapq.heappush(booked, (0, i))\\n\\n        i, curr_time = 0, meetings[0][0]\\n        while i < len(meetings):\\n            while booked and booked[0][0] <= curr_time:\\n                free_time, index = heapq.heappop(booked)\\n                heapq.heappush(free, (index, free_time))\\n\\n            if not free:\\n                curr_time = booked[0][0]\\n                continue\\n\\n            room_id, _ = heapq.heappop(free)\\n            rooms[room_id] += 1\\n            max_meets = max(max_meets, rooms[room_id])\\n            heapq.heappush(booked, (curr_time + (meetings[i][1] - meetings[i][0]), room_id))\\n            curr_time = meetings[i+1][0] if i + 1 < len(meetings) else curr_time\\n            i += 1\\n\\n        for i in range(n):\\n            if rooms[i] == max_meets:\\n                return i\\n```"
                    },
                    {
                        "username": "frog445",
                        "content": "[@quanyincode](/quanyincode) It\\'s python lol why will it have integer overflow"
                    },
                    {
                        "username": "quanyincode",
                        "content": "See my comment about the two test cases that cause integer overflow."
                    },
                    {
                        "username": "jffiorillo",
                        "content": "Regarding this test: `[[1,27],[29,49],[47,49],[41,43],[15,36],[11,15]]` in theory the output is `1` but I did it manually and the output is `0`. Can you please explain me why the output is `1`?\\n\\nThe following is the explanation why I think the answer is `0`\\n\\n```\\n// Meetings ordered by start time : [Meeting(start=1, finish=27), Meeting(start=11, finish=15), Meeting(start=15, finish=36), Meeting(start=29, finish=49), Meeting(start=41, finish=43), Meeting(start=47, finish=49)]\\n\\nfirst meeting = Meeting(start=1, finish=27)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=0, numberOfMeetings=0), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nsecond meeting = Meeting(start=11, finish=15)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=15, numberOfMeetings=1), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nthird meeting = Meeting(start=15, finish=36)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nforth meeting  = Meeting(start=29, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nfifth meeting = Meeting(start=41, finish=43)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=43, numberOfMeetings=1)]\\n\\nlast meeting = Meeting(start=47, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=92, numberOfMeetings=2)]\\n\\nAll room has been booking twice, so the answer is 0.\\n```"
                    },
                    {
                        "username": "vandanakumari13998",
                        "content": "Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\\nI didn\\'t get this example. How is the output 0. Because at time 8, [4,9] meeting will end. Hence 2 meeting room will be empty and [6,8] one would be scheduled at that time. And how is the output given as 1."
                    },
                    {
                        "username": "superZero",
                        "content": "Is the solution flawed?  I see that the solution is to delay 1 meeting till 1 room becomes available.\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                current_end, room = heappop(running_meetings)\\n                new_end = current_end + meetings[i][1] - meetings[i][0]  # Update the room\\'s end time\\n                heappush(running_meetings, (new_end, room))\\n\\n            meetings_per_room[room] +=1\\n            i +=1\\n\\nBut reality should be that all the remaining meetings whose start time is < end_time of the 1st available room should be delayed.\\n\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                for j in range (i, size):\\n                    if meetings[j][0] < running_meetings[0][0]:\\n                        meetings[j][0] += delta \\n                        meetings[j][1] +=delta\\n                    else:\\n                        break\\n\\n"
                    },
                    {
                        "username": "jj3100",
                        "content": "I used Integer types and finally managed to pass all tests. The main issue that caused me to fail on the 80/82 and 81/82 test cases is that when the end times are equal, the PriorityQueue should also compare the room numbers."
                    },
                    {
                        "username": "magomez4",
                        "content": "Passing 82 test cases but TLE? My code is the same idea as others I\\'m seeing in the submissions, and it passes all test cases, but I get a TLE and it says \"82/82\" test cases passed. It also says that the last executed input is \"n=\" yes.. a blank \\'n\\'. Can anyone tell me if this is a leetcode problem or what am I doing wrong? Any help is greatly appreciated!! \\n\\nHere is my approach:\\n ```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // keep an array for the number of bookings of\\n        // each room.\\n        // also keep a mostBooked variable that gets\\n        // updated every time a room is used.\\n        // To assign a meeting to a room, check if\\n        // the meeting starts before the earliest-finishing\\n        // scheduled meeting. If so, assign a new room. If\\n        // there are no more rooms, wait until the earliest\\n        // finishing room, and use that one. If the meeting\\n        // starts after the earliest-finishing room becomes \\n        // free, then continue to \"free-up\" rooms until\\n        // there are no rooms booked or the earliest finishing\\n        // is later than the current start time. After this,\\n        // use the same logic as above to assign the next\\n        // available room.\\n\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        // ensure meetings are sorted by start time\\n        sort(meetings.begin(),meetings.end(), comparator);\\n\\n        int bookingCount[n];\\n        fill_n(bookingCount, n, 0);\\n        int mostBooked = -1;\\n        // We declare a min-heap that holds <endTime, roomNumber> \\n        // to keep the min end time at the front.\\n        priority_queue<vector<long>, vector<vector<long>>, greater<vector<long>>> freeAt; \\n        priority_queue<int,vector<int>,greater<int>> emptyRooms;\\n        for(int i = 0; i < n; i++)\\n        {\\n            emptyRooms.push(i);\\n        }\\n\\n        for(int i = 0; i < meetings.size(); i++)\\n        {\\n            if(mostBooked == -1)\\n            {\\n                mostBooked = 0;\\n                bookingCount[mostBooked]++;\\n                vector<long> newFreeAt = {meetings[i][1], mostBooked}; \\n                freeAt.push(newFreeAt);\\n                emptyRooms.pop();\\n            }\\n            else\\n            {\\n                // if(meetings[i][0] < freeAt.top().first )\\n                if(meetings[i][0] < freeAt.top()[0] )\\n                {\\n                    // current meeting start time is earlier\\n                    // than the earliest-finishing scheduled meeting\\n                    if(freeAt.size() < n)\\n                    {\\n                        // there are available rooms, so book the next available\\n                        vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                    else\\n                    {\\n                        // there are no more available rooms, so this will haven\\n                        // to wait for the earliest finishing scheduled meeting\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        int meetingDuration = meetings[i][1] - meetings[i][0];//end time - start time\\n                        long newEndTime = freeAt.top()[0] + meetingDuration;\\n                        freeAt.pop();\\n                        vector<long> newFreeAt = {newEndTime, emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                }\\n                else\\n                {\\n                    // current meeting start time is later than the earliest\\n                    // finishing scheduled meeting. \\n                    while(!freeAt.empty() \\n                    && meetings[i][0] >= freeAt.top()[0])\\n                    {\\n                        // let the meetings finish to make sure \\n                        // we get the room with the smallest number\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        freeAt.pop();\\n                    }\\n                    vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                    freeAt.push(newFreeAt);\\n                    bookingCount[emptyRooms.top()]++;\\n                    mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                    emptyRooms.pop();\\n                }\\n            }\\n        }\\n        return mostBooked;\\n    }\\n    static bool comparator(vector<int> a, vector<int> b)\\n    {\\n        if(a[0] <= b[0])\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int updateMostBooked(int mostBooked, int newlyBooked, int bookingCount[])\\n    {\\n        int newMostBooked;\\n        if(bookingCount[newlyBooked] > bookingCount[mostBooked])\\n        {\\n            newMostBooked = newlyBooked;\\n        }\\n        else if (bookingCount[newlyBooked] == bookingCount[mostBooked])\\n        {\\n            // if two rooms have the same amount of meetings,\\n            // we consider the room with the smallest ID as \\n            // the most booked\\n            newMostBooked = min(newlyBooked, mostBooked);\\n        }\\n        else\\n        {\\n            newMostBooked = mostBooked;\\n        }\\n        return newMostBooked;\\n    }\\n};\\n```\\n"
                    }
                ]
            },
            {
                "id": 2066259,
                "content": [
                    {
                        "username": "quanyincode",
                        "content": "If you are wondering why your solution past 80/82 test cases, it it due to the two test cases with long inputs, which will cause integer overflow on the meeting end time. Use Long instead of Integer to track a room\\'s end time should solve the problem."
                    },
                    {
                        "username": "jerome1210",
                        "content": "May someone explain why this meetings [[0,10],[1,9],[2,8],[3,7],[4,6]] will return 1?\nI thought it should be \n1. room: 0, time 10 (0+10)\n2. room: 1, time 10 (1+9)\n3. room: 2, time 10 (2+8)\n4. room: 0, time 17 (10+7)\n5. room: 1, time 16 (10 + 6)\n\nSo, the room 0, 1 will held 2 meetings, then it should return 0 ?\n"
                    },
                    {
                        "username": "user0081T",
                        "content": "The second meeting will end at time: 9 not 10, same thing for the third meeting, it will end at time 8, not 10.  Because the the second argument for each meeting is the end time of the meeting and not the duration of it. "
                    },
                    {
                        "username": "shru15",
                        "content": "After meeting 3, the earliest free room will be room 2\\nso [3,7] -> [3+8, 7+8] at room 2\\nand 4,6 -> [4+9, 6+9] at room 1\\nsince room 0 gets freed at last, only one meeting will take place there."
                    },
                    {
                        "username": "anshil1611",
                        "content": "For the people who are confused with WA at 80/82:\\n\\nI am seeing lot of comments where people are saying its because of integer overflow. Seemingly true, however if you are using a PriorityQueue of type Pair<Integer, Integer>, that is where all the problem is occurring. Just change the type of the priority queue from Pair<Integer, Integer> to int[] (yes, no Long required) and your solution would pass the remaining test cases.\\n\\nIt seems like Pair<Integer, Integer> is not able to handle large values, and the same code which fails with Pair<Integer, Integer>, passes all test cases with int[]."
                    },
                    {
                        "username": "spark6015",
                        "content": "are we even allow to use heapq.heapify() function in the interview?"
                    },
                    {
                        "username": "strangeranda",
                        "content": "Yes, you could ask the interviewer if you could use built-in functions, and 10/10 they\\u2019d say yes. I could be wrong in 10/10, but I never faced any instance where I couldn\\u2019t use. "
                    },
                    {
                        "username": "Tanayk",
                        "content": "Can someone please help me identify the error in this code? 80/82 test cases are passing. \\nThank you\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        rooms = collections.defaultdict(int)\\n        meetings.sort()\\n        booked, free = [], []\\n        max_meets = 0\\n        for i in range(n):\\n            heapq.heappush(booked, (0, i))\\n\\n        i, curr_time = 0, meetings[0][0]\\n        while i < len(meetings):\\n            while booked and booked[0][0] <= curr_time:\\n                free_time, index = heapq.heappop(booked)\\n                heapq.heappush(free, (index, free_time))\\n\\n            if not free:\\n                curr_time = booked[0][0]\\n                continue\\n\\n            room_id, _ = heapq.heappop(free)\\n            rooms[room_id] += 1\\n            max_meets = max(max_meets, rooms[room_id])\\n            heapq.heappush(booked, (curr_time + (meetings[i][1] - meetings[i][0]), room_id))\\n            curr_time = meetings[i+1][0] if i + 1 < len(meetings) else curr_time\\n            i += 1\\n\\n        for i in range(n):\\n            if rooms[i] == max_meets:\\n                return i\\n```"
                    },
                    {
                        "username": "frog445",
                        "content": "[@quanyincode](/quanyincode) It\\'s python lol why will it have integer overflow"
                    },
                    {
                        "username": "quanyincode",
                        "content": "See my comment about the two test cases that cause integer overflow."
                    },
                    {
                        "username": "jffiorillo",
                        "content": "Regarding this test: `[[1,27],[29,49],[47,49],[41,43],[15,36],[11,15]]` in theory the output is `1` but I did it manually and the output is `0`. Can you please explain me why the output is `1`?\\n\\nThe following is the explanation why I think the answer is `0`\\n\\n```\\n// Meetings ordered by start time : [Meeting(start=1, finish=27), Meeting(start=11, finish=15), Meeting(start=15, finish=36), Meeting(start=29, finish=49), Meeting(start=41, finish=43), Meeting(start=47, finish=49)]\\n\\nfirst meeting = Meeting(start=1, finish=27)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=0, numberOfMeetings=0), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nsecond meeting = Meeting(start=11, finish=15)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=15, numberOfMeetings=1), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nthird meeting = Meeting(start=15, finish=36)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nforth meeting  = Meeting(start=29, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nfifth meeting = Meeting(start=41, finish=43)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=43, numberOfMeetings=1)]\\n\\nlast meeting = Meeting(start=47, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=92, numberOfMeetings=2)]\\n\\nAll room has been booking twice, so the answer is 0.\\n```"
                    },
                    {
                        "username": "vandanakumari13998",
                        "content": "Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\\nI didn\\'t get this example. How is the output 0. Because at time 8, [4,9] meeting will end. Hence 2 meeting room will be empty and [6,8] one would be scheduled at that time. And how is the output given as 1."
                    },
                    {
                        "username": "superZero",
                        "content": "Is the solution flawed?  I see that the solution is to delay 1 meeting till 1 room becomes available.\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                current_end, room = heappop(running_meetings)\\n                new_end = current_end + meetings[i][1] - meetings[i][0]  # Update the room\\'s end time\\n                heappush(running_meetings, (new_end, room))\\n\\n            meetings_per_room[room] +=1\\n            i +=1\\n\\nBut reality should be that all the remaining meetings whose start time is < end_time of the 1st available room should be delayed.\\n\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                for j in range (i, size):\\n                    if meetings[j][0] < running_meetings[0][0]:\\n                        meetings[j][0] += delta \\n                        meetings[j][1] +=delta\\n                    else:\\n                        break\\n\\n"
                    },
                    {
                        "username": "jj3100",
                        "content": "I used Integer types and finally managed to pass all tests. The main issue that caused me to fail on the 80/82 and 81/82 test cases is that when the end times are equal, the PriorityQueue should also compare the room numbers."
                    },
                    {
                        "username": "magomez4",
                        "content": "Passing 82 test cases but TLE? My code is the same idea as others I\\'m seeing in the submissions, and it passes all test cases, but I get a TLE and it says \"82/82\" test cases passed. It also says that the last executed input is \"n=\" yes.. a blank \\'n\\'. Can anyone tell me if this is a leetcode problem or what am I doing wrong? Any help is greatly appreciated!! \\n\\nHere is my approach:\\n ```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // keep an array for the number of bookings of\\n        // each room.\\n        // also keep a mostBooked variable that gets\\n        // updated every time a room is used.\\n        // To assign a meeting to a room, check if\\n        // the meeting starts before the earliest-finishing\\n        // scheduled meeting. If so, assign a new room. If\\n        // there are no more rooms, wait until the earliest\\n        // finishing room, and use that one. If the meeting\\n        // starts after the earliest-finishing room becomes \\n        // free, then continue to \"free-up\" rooms until\\n        // there are no rooms booked or the earliest finishing\\n        // is later than the current start time. After this,\\n        // use the same logic as above to assign the next\\n        // available room.\\n\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        // ensure meetings are sorted by start time\\n        sort(meetings.begin(),meetings.end(), comparator);\\n\\n        int bookingCount[n];\\n        fill_n(bookingCount, n, 0);\\n        int mostBooked = -1;\\n        // We declare a min-heap that holds <endTime, roomNumber> \\n        // to keep the min end time at the front.\\n        priority_queue<vector<long>, vector<vector<long>>, greater<vector<long>>> freeAt; \\n        priority_queue<int,vector<int>,greater<int>> emptyRooms;\\n        for(int i = 0; i < n; i++)\\n        {\\n            emptyRooms.push(i);\\n        }\\n\\n        for(int i = 0; i < meetings.size(); i++)\\n        {\\n            if(mostBooked == -1)\\n            {\\n                mostBooked = 0;\\n                bookingCount[mostBooked]++;\\n                vector<long> newFreeAt = {meetings[i][1], mostBooked}; \\n                freeAt.push(newFreeAt);\\n                emptyRooms.pop();\\n            }\\n            else\\n            {\\n                // if(meetings[i][0] < freeAt.top().first )\\n                if(meetings[i][0] < freeAt.top()[0] )\\n                {\\n                    // current meeting start time is earlier\\n                    // than the earliest-finishing scheduled meeting\\n                    if(freeAt.size() < n)\\n                    {\\n                        // there are available rooms, so book the next available\\n                        vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                    else\\n                    {\\n                        // there are no more available rooms, so this will haven\\n                        // to wait for the earliest finishing scheduled meeting\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        int meetingDuration = meetings[i][1] - meetings[i][0];//end time - start time\\n                        long newEndTime = freeAt.top()[0] + meetingDuration;\\n                        freeAt.pop();\\n                        vector<long> newFreeAt = {newEndTime, emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                }\\n                else\\n                {\\n                    // current meeting start time is later than the earliest\\n                    // finishing scheduled meeting. \\n                    while(!freeAt.empty() \\n                    && meetings[i][0] >= freeAt.top()[0])\\n                    {\\n                        // let the meetings finish to make sure \\n                        // we get the room with the smallest number\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        freeAt.pop();\\n                    }\\n                    vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                    freeAt.push(newFreeAt);\\n                    bookingCount[emptyRooms.top()]++;\\n                    mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                    emptyRooms.pop();\\n                }\\n            }\\n        }\\n        return mostBooked;\\n    }\\n    static bool comparator(vector<int> a, vector<int> b)\\n    {\\n        if(a[0] <= b[0])\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int updateMostBooked(int mostBooked, int newlyBooked, int bookingCount[])\\n    {\\n        int newMostBooked;\\n        if(bookingCount[newlyBooked] > bookingCount[mostBooked])\\n        {\\n            newMostBooked = newlyBooked;\\n        }\\n        else if (bookingCount[newlyBooked] == bookingCount[mostBooked])\\n        {\\n            // if two rooms have the same amount of meetings,\\n            // we consider the room with the smallest ID as \\n            // the most booked\\n            newMostBooked = min(newlyBooked, mostBooked);\\n        }\\n        else\\n        {\\n            newMostBooked = mostBooked;\\n        }\\n        return newMostBooked;\\n    }\\n};\\n```\\n"
                    }
                ]
            },
            {
                "id": 2045529,
                "content": [
                    {
                        "username": "quanyincode",
                        "content": "If you are wondering why your solution past 80/82 test cases, it it due to the two test cases with long inputs, which will cause integer overflow on the meeting end time. Use Long instead of Integer to track a room\\'s end time should solve the problem."
                    },
                    {
                        "username": "jerome1210",
                        "content": "May someone explain why this meetings [[0,10],[1,9],[2,8],[3,7],[4,6]] will return 1?\nI thought it should be \n1. room: 0, time 10 (0+10)\n2. room: 1, time 10 (1+9)\n3. room: 2, time 10 (2+8)\n4. room: 0, time 17 (10+7)\n5. room: 1, time 16 (10 + 6)\n\nSo, the room 0, 1 will held 2 meetings, then it should return 0 ?\n"
                    },
                    {
                        "username": "user0081T",
                        "content": "The second meeting will end at time: 9 not 10, same thing for the third meeting, it will end at time 8, not 10.  Because the the second argument for each meeting is the end time of the meeting and not the duration of it. "
                    },
                    {
                        "username": "shru15",
                        "content": "After meeting 3, the earliest free room will be room 2\\nso [3,7] -> [3+8, 7+8] at room 2\\nand 4,6 -> [4+9, 6+9] at room 1\\nsince room 0 gets freed at last, only one meeting will take place there."
                    },
                    {
                        "username": "anshil1611",
                        "content": "For the people who are confused with WA at 80/82:\\n\\nI am seeing lot of comments where people are saying its because of integer overflow. Seemingly true, however if you are using a PriorityQueue of type Pair<Integer, Integer>, that is where all the problem is occurring. Just change the type of the priority queue from Pair<Integer, Integer> to int[] (yes, no Long required) and your solution would pass the remaining test cases.\\n\\nIt seems like Pair<Integer, Integer> is not able to handle large values, and the same code which fails with Pair<Integer, Integer>, passes all test cases with int[]."
                    },
                    {
                        "username": "spark6015",
                        "content": "are we even allow to use heapq.heapify() function in the interview?"
                    },
                    {
                        "username": "strangeranda",
                        "content": "Yes, you could ask the interviewer if you could use built-in functions, and 10/10 they\\u2019d say yes. I could be wrong in 10/10, but I never faced any instance where I couldn\\u2019t use. "
                    },
                    {
                        "username": "Tanayk",
                        "content": "Can someone please help me identify the error in this code? 80/82 test cases are passing. \\nThank you\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        rooms = collections.defaultdict(int)\\n        meetings.sort()\\n        booked, free = [], []\\n        max_meets = 0\\n        for i in range(n):\\n            heapq.heappush(booked, (0, i))\\n\\n        i, curr_time = 0, meetings[0][0]\\n        while i < len(meetings):\\n            while booked and booked[0][0] <= curr_time:\\n                free_time, index = heapq.heappop(booked)\\n                heapq.heappush(free, (index, free_time))\\n\\n            if not free:\\n                curr_time = booked[0][0]\\n                continue\\n\\n            room_id, _ = heapq.heappop(free)\\n            rooms[room_id] += 1\\n            max_meets = max(max_meets, rooms[room_id])\\n            heapq.heappush(booked, (curr_time + (meetings[i][1] - meetings[i][0]), room_id))\\n            curr_time = meetings[i+1][0] if i + 1 < len(meetings) else curr_time\\n            i += 1\\n\\n        for i in range(n):\\n            if rooms[i] == max_meets:\\n                return i\\n```"
                    },
                    {
                        "username": "frog445",
                        "content": "[@quanyincode](/quanyincode) It\\'s python lol why will it have integer overflow"
                    },
                    {
                        "username": "quanyincode",
                        "content": "See my comment about the two test cases that cause integer overflow."
                    },
                    {
                        "username": "jffiorillo",
                        "content": "Regarding this test: `[[1,27],[29,49],[47,49],[41,43],[15,36],[11,15]]` in theory the output is `1` but I did it manually and the output is `0`. Can you please explain me why the output is `1`?\\n\\nThe following is the explanation why I think the answer is `0`\\n\\n```\\n// Meetings ordered by start time : [Meeting(start=1, finish=27), Meeting(start=11, finish=15), Meeting(start=15, finish=36), Meeting(start=29, finish=49), Meeting(start=41, finish=43), Meeting(start=47, finish=49)]\\n\\nfirst meeting = Meeting(start=1, finish=27)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=0, numberOfMeetings=0), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nsecond meeting = Meeting(start=11, finish=15)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=15, numberOfMeetings=1), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nthird meeting = Meeting(start=15, finish=36)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nforth meeting  = Meeting(start=29, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nfifth meeting = Meeting(start=41, finish=43)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=43, numberOfMeetings=1)]\\n\\nlast meeting = Meeting(start=47, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=92, numberOfMeetings=2)]\\n\\nAll room has been booking twice, so the answer is 0.\\n```"
                    },
                    {
                        "username": "vandanakumari13998",
                        "content": "Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\\nI didn\\'t get this example. How is the output 0. Because at time 8, [4,9] meeting will end. Hence 2 meeting room will be empty and [6,8] one would be scheduled at that time. And how is the output given as 1."
                    },
                    {
                        "username": "superZero",
                        "content": "Is the solution flawed?  I see that the solution is to delay 1 meeting till 1 room becomes available.\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                current_end, room = heappop(running_meetings)\\n                new_end = current_end + meetings[i][1] - meetings[i][0]  # Update the room\\'s end time\\n                heappush(running_meetings, (new_end, room))\\n\\n            meetings_per_room[room] +=1\\n            i +=1\\n\\nBut reality should be that all the remaining meetings whose start time is < end_time of the 1st available room should be delayed.\\n\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                for j in range (i, size):\\n                    if meetings[j][0] < running_meetings[0][0]:\\n                        meetings[j][0] += delta \\n                        meetings[j][1] +=delta\\n                    else:\\n                        break\\n\\n"
                    },
                    {
                        "username": "jj3100",
                        "content": "I used Integer types and finally managed to pass all tests. The main issue that caused me to fail on the 80/82 and 81/82 test cases is that when the end times are equal, the PriorityQueue should also compare the room numbers."
                    },
                    {
                        "username": "magomez4",
                        "content": "Passing 82 test cases but TLE? My code is the same idea as others I\\'m seeing in the submissions, and it passes all test cases, but I get a TLE and it says \"82/82\" test cases passed. It also says that the last executed input is \"n=\" yes.. a blank \\'n\\'. Can anyone tell me if this is a leetcode problem or what am I doing wrong? Any help is greatly appreciated!! \\n\\nHere is my approach:\\n ```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // keep an array for the number of bookings of\\n        // each room.\\n        // also keep a mostBooked variable that gets\\n        // updated every time a room is used.\\n        // To assign a meeting to a room, check if\\n        // the meeting starts before the earliest-finishing\\n        // scheduled meeting. If so, assign a new room. If\\n        // there are no more rooms, wait until the earliest\\n        // finishing room, and use that one. If the meeting\\n        // starts after the earliest-finishing room becomes \\n        // free, then continue to \"free-up\" rooms until\\n        // there are no rooms booked or the earliest finishing\\n        // is later than the current start time. After this,\\n        // use the same logic as above to assign the next\\n        // available room.\\n\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        // ensure meetings are sorted by start time\\n        sort(meetings.begin(),meetings.end(), comparator);\\n\\n        int bookingCount[n];\\n        fill_n(bookingCount, n, 0);\\n        int mostBooked = -1;\\n        // We declare a min-heap that holds <endTime, roomNumber> \\n        // to keep the min end time at the front.\\n        priority_queue<vector<long>, vector<vector<long>>, greater<vector<long>>> freeAt; \\n        priority_queue<int,vector<int>,greater<int>> emptyRooms;\\n        for(int i = 0; i < n; i++)\\n        {\\n            emptyRooms.push(i);\\n        }\\n\\n        for(int i = 0; i < meetings.size(); i++)\\n        {\\n            if(mostBooked == -1)\\n            {\\n                mostBooked = 0;\\n                bookingCount[mostBooked]++;\\n                vector<long> newFreeAt = {meetings[i][1], mostBooked}; \\n                freeAt.push(newFreeAt);\\n                emptyRooms.pop();\\n            }\\n            else\\n            {\\n                // if(meetings[i][0] < freeAt.top().first )\\n                if(meetings[i][0] < freeAt.top()[0] )\\n                {\\n                    // current meeting start time is earlier\\n                    // than the earliest-finishing scheduled meeting\\n                    if(freeAt.size() < n)\\n                    {\\n                        // there are available rooms, so book the next available\\n                        vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                    else\\n                    {\\n                        // there are no more available rooms, so this will haven\\n                        // to wait for the earliest finishing scheduled meeting\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        int meetingDuration = meetings[i][1] - meetings[i][0];//end time - start time\\n                        long newEndTime = freeAt.top()[0] + meetingDuration;\\n                        freeAt.pop();\\n                        vector<long> newFreeAt = {newEndTime, emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                }\\n                else\\n                {\\n                    // current meeting start time is later than the earliest\\n                    // finishing scheduled meeting. \\n                    while(!freeAt.empty() \\n                    && meetings[i][0] >= freeAt.top()[0])\\n                    {\\n                        // let the meetings finish to make sure \\n                        // we get the room with the smallest number\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        freeAt.pop();\\n                    }\\n                    vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                    freeAt.push(newFreeAt);\\n                    bookingCount[emptyRooms.top()]++;\\n                    mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                    emptyRooms.pop();\\n                }\\n            }\\n        }\\n        return mostBooked;\\n    }\\n    static bool comparator(vector<int> a, vector<int> b)\\n    {\\n        if(a[0] <= b[0])\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int updateMostBooked(int mostBooked, int newlyBooked, int bookingCount[])\\n    {\\n        int newMostBooked;\\n        if(bookingCount[newlyBooked] > bookingCount[mostBooked])\\n        {\\n            newMostBooked = newlyBooked;\\n        }\\n        else if (bookingCount[newlyBooked] == bookingCount[mostBooked])\\n        {\\n            // if two rooms have the same amount of meetings,\\n            // we consider the room with the smallest ID as \\n            // the most booked\\n            newMostBooked = min(newlyBooked, mostBooked);\\n        }\\n        else\\n        {\\n            newMostBooked = mostBooked;\\n        }\\n        return newMostBooked;\\n    }\\n};\\n```\\n"
                    }
                ]
            },
            {
                "id": 2036225,
                "content": [
                    {
                        "username": "quanyincode",
                        "content": "If you are wondering why your solution past 80/82 test cases, it it due to the two test cases with long inputs, which will cause integer overflow on the meeting end time. Use Long instead of Integer to track a room\\'s end time should solve the problem."
                    },
                    {
                        "username": "jerome1210",
                        "content": "May someone explain why this meetings [[0,10],[1,9],[2,8],[3,7],[4,6]] will return 1?\nI thought it should be \n1. room: 0, time 10 (0+10)\n2. room: 1, time 10 (1+9)\n3. room: 2, time 10 (2+8)\n4. room: 0, time 17 (10+7)\n5. room: 1, time 16 (10 + 6)\n\nSo, the room 0, 1 will held 2 meetings, then it should return 0 ?\n"
                    },
                    {
                        "username": "user0081T",
                        "content": "The second meeting will end at time: 9 not 10, same thing for the third meeting, it will end at time 8, not 10.  Because the the second argument for each meeting is the end time of the meeting and not the duration of it. "
                    },
                    {
                        "username": "shru15",
                        "content": "After meeting 3, the earliest free room will be room 2\\nso [3,7] -> [3+8, 7+8] at room 2\\nand 4,6 -> [4+9, 6+9] at room 1\\nsince room 0 gets freed at last, only one meeting will take place there."
                    },
                    {
                        "username": "anshil1611",
                        "content": "For the people who are confused with WA at 80/82:\\n\\nI am seeing lot of comments where people are saying its because of integer overflow. Seemingly true, however if you are using a PriorityQueue of type Pair<Integer, Integer>, that is where all the problem is occurring. Just change the type of the priority queue from Pair<Integer, Integer> to int[] (yes, no Long required) and your solution would pass the remaining test cases.\\n\\nIt seems like Pair<Integer, Integer> is not able to handle large values, and the same code which fails with Pair<Integer, Integer>, passes all test cases with int[]."
                    },
                    {
                        "username": "spark6015",
                        "content": "are we even allow to use heapq.heapify() function in the interview?"
                    },
                    {
                        "username": "strangeranda",
                        "content": "Yes, you could ask the interviewer if you could use built-in functions, and 10/10 they\\u2019d say yes. I could be wrong in 10/10, but I never faced any instance where I couldn\\u2019t use. "
                    },
                    {
                        "username": "Tanayk",
                        "content": "Can someone please help me identify the error in this code? 80/82 test cases are passing. \\nThank you\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        rooms = collections.defaultdict(int)\\n        meetings.sort()\\n        booked, free = [], []\\n        max_meets = 0\\n        for i in range(n):\\n            heapq.heappush(booked, (0, i))\\n\\n        i, curr_time = 0, meetings[0][0]\\n        while i < len(meetings):\\n            while booked and booked[0][0] <= curr_time:\\n                free_time, index = heapq.heappop(booked)\\n                heapq.heappush(free, (index, free_time))\\n\\n            if not free:\\n                curr_time = booked[0][0]\\n                continue\\n\\n            room_id, _ = heapq.heappop(free)\\n            rooms[room_id] += 1\\n            max_meets = max(max_meets, rooms[room_id])\\n            heapq.heappush(booked, (curr_time + (meetings[i][1] - meetings[i][0]), room_id))\\n            curr_time = meetings[i+1][0] if i + 1 < len(meetings) else curr_time\\n            i += 1\\n\\n        for i in range(n):\\n            if rooms[i] == max_meets:\\n                return i\\n```"
                    },
                    {
                        "username": "frog445",
                        "content": "[@quanyincode](/quanyincode) It\\'s python lol why will it have integer overflow"
                    },
                    {
                        "username": "quanyincode",
                        "content": "See my comment about the two test cases that cause integer overflow."
                    },
                    {
                        "username": "jffiorillo",
                        "content": "Regarding this test: `[[1,27],[29,49],[47,49],[41,43],[15,36],[11,15]]` in theory the output is `1` but I did it manually and the output is `0`. Can you please explain me why the output is `1`?\\n\\nThe following is the explanation why I think the answer is `0`\\n\\n```\\n// Meetings ordered by start time : [Meeting(start=1, finish=27), Meeting(start=11, finish=15), Meeting(start=15, finish=36), Meeting(start=29, finish=49), Meeting(start=41, finish=43), Meeting(start=47, finish=49)]\\n\\nfirst meeting = Meeting(start=1, finish=27)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=0, numberOfMeetings=0), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nsecond meeting = Meeting(start=11, finish=15)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=15, numberOfMeetings=1), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nthird meeting = Meeting(start=15, finish=36)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nforth meeting  = Meeting(start=29, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nfifth meeting = Meeting(start=41, finish=43)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=43, numberOfMeetings=1)]\\n\\nlast meeting = Meeting(start=47, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=92, numberOfMeetings=2)]\\n\\nAll room has been booking twice, so the answer is 0.\\n```"
                    },
                    {
                        "username": "vandanakumari13998",
                        "content": "Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\\nI didn\\'t get this example. How is the output 0. Because at time 8, [4,9] meeting will end. Hence 2 meeting room will be empty and [6,8] one would be scheduled at that time. And how is the output given as 1."
                    },
                    {
                        "username": "superZero",
                        "content": "Is the solution flawed?  I see that the solution is to delay 1 meeting till 1 room becomes available.\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                current_end, room = heappop(running_meetings)\\n                new_end = current_end + meetings[i][1] - meetings[i][0]  # Update the room\\'s end time\\n                heappush(running_meetings, (new_end, room))\\n\\n            meetings_per_room[room] +=1\\n            i +=1\\n\\nBut reality should be that all the remaining meetings whose start time is < end_time of the 1st available room should be delayed.\\n\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                for j in range (i, size):\\n                    if meetings[j][0] < running_meetings[0][0]:\\n                        meetings[j][0] += delta \\n                        meetings[j][1] +=delta\\n                    else:\\n                        break\\n\\n"
                    },
                    {
                        "username": "jj3100",
                        "content": "I used Integer types and finally managed to pass all tests. The main issue that caused me to fail on the 80/82 and 81/82 test cases is that when the end times are equal, the PriorityQueue should also compare the room numbers."
                    },
                    {
                        "username": "magomez4",
                        "content": "Passing 82 test cases but TLE? My code is the same idea as others I\\'m seeing in the submissions, and it passes all test cases, but I get a TLE and it says \"82/82\" test cases passed. It also says that the last executed input is \"n=\" yes.. a blank \\'n\\'. Can anyone tell me if this is a leetcode problem or what am I doing wrong? Any help is greatly appreciated!! \\n\\nHere is my approach:\\n ```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // keep an array for the number of bookings of\\n        // each room.\\n        // also keep a mostBooked variable that gets\\n        // updated every time a room is used.\\n        // To assign a meeting to a room, check if\\n        // the meeting starts before the earliest-finishing\\n        // scheduled meeting. If so, assign a new room. If\\n        // there are no more rooms, wait until the earliest\\n        // finishing room, and use that one. If the meeting\\n        // starts after the earliest-finishing room becomes \\n        // free, then continue to \"free-up\" rooms until\\n        // there are no rooms booked or the earliest finishing\\n        // is later than the current start time. After this,\\n        // use the same logic as above to assign the next\\n        // available room.\\n\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        // ensure meetings are sorted by start time\\n        sort(meetings.begin(),meetings.end(), comparator);\\n\\n        int bookingCount[n];\\n        fill_n(bookingCount, n, 0);\\n        int mostBooked = -1;\\n        // We declare a min-heap that holds <endTime, roomNumber> \\n        // to keep the min end time at the front.\\n        priority_queue<vector<long>, vector<vector<long>>, greater<vector<long>>> freeAt; \\n        priority_queue<int,vector<int>,greater<int>> emptyRooms;\\n        for(int i = 0; i < n; i++)\\n        {\\n            emptyRooms.push(i);\\n        }\\n\\n        for(int i = 0; i < meetings.size(); i++)\\n        {\\n            if(mostBooked == -1)\\n            {\\n                mostBooked = 0;\\n                bookingCount[mostBooked]++;\\n                vector<long> newFreeAt = {meetings[i][1], mostBooked}; \\n                freeAt.push(newFreeAt);\\n                emptyRooms.pop();\\n            }\\n            else\\n            {\\n                // if(meetings[i][0] < freeAt.top().first )\\n                if(meetings[i][0] < freeAt.top()[0] )\\n                {\\n                    // current meeting start time is earlier\\n                    // than the earliest-finishing scheduled meeting\\n                    if(freeAt.size() < n)\\n                    {\\n                        // there are available rooms, so book the next available\\n                        vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                    else\\n                    {\\n                        // there are no more available rooms, so this will haven\\n                        // to wait for the earliest finishing scheduled meeting\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        int meetingDuration = meetings[i][1] - meetings[i][0];//end time - start time\\n                        long newEndTime = freeAt.top()[0] + meetingDuration;\\n                        freeAt.pop();\\n                        vector<long> newFreeAt = {newEndTime, emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                }\\n                else\\n                {\\n                    // current meeting start time is later than the earliest\\n                    // finishing scheduled meeting. \\n                    while(!freeAt.empty() \\n                    && meetings[i][0] >= freeAt.top()[0])\\n                    {\\n                        // let the meetings finish to make sure \\n                        // we get the room with the smallest number\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        freeAt.pop();\\n                    }\\n                    vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                    freeAt.push(newFreeAt);\\n                    bookingCount[emptyRooms.top()]++;\\n                    mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                    emptyRooms.pop();\\n                }\\n            }\\n        }\\n        return mostBooked;\\n    }\\n    static bool comparator(vector<int> a, vector<int> b)\\n    {\\n        if(a[0] <= b[0])\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int updateMostBooked(int mostBooked, int newlyBooked, int bookingCount[])\\n    {\\n        int newMostBooked;\\n        if(bookingCount[newlyBooked] > bookingCount[mostBooked])\\n        {\\n            newMostBooked = newlyBooked;\\n        }\\n        else if (bookingCount[newlyBooked] == bookingCount[mostBooked])\\n        {\\n            // if two rooms have the same amount of meetings,\\n            // we consider the room with the smallest ID as \\n            // the most booked\\n            newMostBooked = min(newlyBooked, mostBooked);\\n        }\\n        else\\n        {\\n            newMostBooked = mostBooked;\\n        }\\n        return newMostBooked;\\n    }\\n};\\n```\\n"
                    }
                ]
            },
            {
                "id": 2027700,
                "content": [
                    {
                        "username": "quanyincode",
                        "content": "If you are wondering why your solution past 80/82 test cases, it it due to the two test cases with long inputs, which will cause integer overflow on the meeting end time. Use Long instead of Integer to track a room\\'s end time should solve the problem."
                    },
                    {
                        "username": "jerome1210",
                        "content": "May someone explain why this meetings [[0,10],[1,9],[2,8],[3,7],[4,6]] will return 1?\nI thought it should be \n1. room: 0, time 10 (0+10)\n2. room: 1, time 10 (1+9)\n3. room: 2, time 10 (2+8)\n4. room: 0, time 17 (10+7)\n5. room: 1, time 16 (10 + 6)\n\nSo, the room 0, 1 will held 2 meetings, then it should return 0 ?\n"
                    },
                    {
                        "username": "user0081T",
                        "content": "The second meeting will end at time: 9 not 10, same thing for the third meeting, it will end at time 8, not 10.  Because the the second argument for each meeting is the end time of the meeting and not the duration of it. "
                    },
                    {
                        "username": "shru15",
                        "content": "After meeting 3, the earliest free room will be room 2\\nso [3,7] -> [3+8, 7+8] at room 2\\nand 4,6 -> [4+9, 6+9] at room 1\\nsince room 0 gets freed at last, only one meeting will take place there."
                    },
                    {
                        "username": "anshil1611",
                        "content": "For the people who are confused with WA at 80/82:\\n\\nI am seeing lot of comments where people are saying its because of integer overflow. Seemingly true, however if you are using a PriorityQueue of type Pair<Integer, Integer>, that is where all the problem is occurring. Just change the type of the priority queue from Pair<Integer, Integer> to int[] (yes, no Long required) and your solution would pass the remaining test cases.\\n\\nIt seems like Pair<Integer, Integer> is not able to handle large values, and the same code which fails with Pair<Integer, Integer>, passes all test cases with int[]."
                    },
                    {
                        "username": "spark6015",
                        "content": "are we even allow to use heapq.heapify() function in the interview?"
                    },
                    {
                        "username": "strangeranda",
                        "content": "Yes, you could ask the interviewer if you could use built-in functions, and 10/10 they\\u2019d say yes. I could be wrong in 10/10, but I never faced any instance where I couldn\\u2019t use. "
                    },
                    {
                        "username": "Tanayk",
                        "content": "Can someone please help me identify the error in this code? 80/82 test cases are passing. \\nThank you\\n```\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        rooms = collections.defaultdict(int)\\n        meetings.sort()\\n        booked, free = [], []\\n        max_meets = 0\\n        for i in range(n):\\n            heapq.heappush(booked, (0, i))\\n\\n        i, curr_time = 0, meetings[0][0]\\n        while i < len(meetings):\\n            while booked and booked[0][0] <= curr_time:\\n                free_time, index = heapq.heappop(booked)\\n                heapq.heappush(free, (index, free_time))\\n\\n            if not free:\\n                curr_time = booked[0][0]\\n                continue\\n\\n            room_id, _ = heapq.heappop(free)\\n            rooms[room_id] += 1\\n            max_meets = max(max_meets, rooms[room_id])\\n            heapq.heappush(booked, (curr_time + (meetings[i][1] - meetings[i][0]), room_id))\\n            curr_time = meetings[i+1][0] if i + 1 < len(meetings) else curr_time\\n            i += 1\\n\\n        for i in range(n):\\n            if rooms[i] == max_meets:\\n                return i\\n```"
                    },
                    {
                        "username": "frog445",
                        "content": "[@quanyincode](/quanyincode) It\\'s python lol why will it have integer overflow"
                    },
                    {
                        "username": "quanyincode",
                        "content": "See my comment about the two test cases that cause integer overflow."
                    },
                    {
                        "username": "jffiorillo",
                        "content": "Regarding this test: `[[1,27],[29,49],[47,49],[41,43],[15,36],[11,15]]` in theory the output is `1` but I did it manually and the output is `0`. Can you please explain me why the output is `1`?\\n\\nThe following is the explanation why I think the answer is `0`\\n\\n```\\n// Meetings ordered by start time : [Meeting(start=1, finish=27), Meeting(start=11, finish=15), Meeting(start=15, finish=36), Meeting(start=29, finish=49), Meeting(start=41, finish=43), Meeting(start=47, finish=49)]\\n\\nfirst meeting = Meeting(start=1, finish=27)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=0, numberOfMeetings=0), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nsecond meeting = Meeting(start=11, finish=15)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=15, numberOfMeetings=1), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nthird meeting = Meeting(start=15, finish=36)\\n[Room(index=0, finishes=27, numberOfMeetings=1), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nforth meeting  = Meeting(start=29, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=0, numberOfMeetings=0)]\\n\\nfifth meeting = Meeting(start=41, finish=43)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=43, numberOfMeetings=1)]\\n\\nlast meeting = Meeting(start=47, finish=49)\\n[Room(index=0, finishes=76, numberOfMeetings=2), Room(index=1, finishes=51, numberOfMeetings=2), Room(index=2, finishes=92, numberOfMeetings=2)]\\n\\nAll room has been booking twice, so the answer is 0.\\n```"
                    },
                    {
                        "username": "vandanakumari13998",
                        "content": "Input: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\\nI didn\\'t get this example. How is the output 0. Because at time 8, [4,9] meeting will end. Hence 2 meeting room will be empty and [6,8] one would be scheduled at that time. And how is the output given as 1."
                    },
                    {
                        "username": "superZero",
                        "content": "Is the solution flawed?  I see that the solution is to delay 1 meeting till 1 room becomes available.\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                current_end, room = heappop(running_meetings)\\n                new_end = current_end + meetings[i][1] - meetings[i][0]  # Update the room\\'s end time\\n                heappush(running_meetings, (new_end, room))\\n\\n            meetings_per_room[room] +=1\\n            i +=1\\n\\nBut reality should be that all the remaining meetings whose start time is < end_time of the 1st available room should be delayed.\\n\\n       while i < size:\\n            # refresh the availabe meeting list for all finished meetings\\n            while running_meetings and running_meetings[0][0] <= meetings[i][0]:\\n                finished_meeting = heappop(running_meetings)\\n                heappush(available_rooms_heap,finished_meeting[1])\\n\\n            if available_rooms_heap:\\n                room = heappop(available_rooms_heap)\\n                heappush(running_meetings, (meetings[i][1], room))\\n            else:\\n                for j in range (i, size):\\n                    if meetings[j][0] < running_meetings[0][0]:\\n                        meetings[j][0] += delta \\n                        meetings[j][1] +=delta\\n                    else:\\n                        break\\n\\n"
                    },
                    {
                        "username": "jj3100",
                        "content": "I used Integer types and finally managed to pass all tests. The main issue that caused me to fail on the 80/82 and 81/82 test cases is that when the end times are equal, the PriorityQueue should also compare the room numbers."
                    },
                    {
                        "username": "magomez4",
                        "content": "Passing 82 test cases but TLE? My code is the same idea as others I\\'m seeing in the submissions, and it passes all test cases, but I get a TLE and it says \"82/82\" test cases passed. It also says that the last executed input is \"n=\" yes.. a blank \\'n\\'. Can anyone tell me if this is a leetcode problem or what am I doing wrong? Any help is greatly appreciated!! \\n\\nHere is my approach:\\n ```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        // keep an array for the number of bookings of\\n        // each room.\\n        // also keep a mostBooked variable that gets\\n        // updated every time a room is used.\\n        // To assign a meeting to a room, check if\\n        // the meeting starts before the earliest-finishing\\n        // scheduled meeting. If so, assign a new room. If\\n        // there are no more rooms, wait until the earliest\\n        // finishing room, and use that one. If the meeting\\n        // starts after the earliest-finishing room becomes \\n        // free, then continue to \"free-up\" rooms until\\n        // there are no rooms booked or the earliest finishing\\n        // is later than the current start time. After this,\\n        // use the same logic as above to assign the next\\n        // available room.\\n\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        // ensure meetings are sorted by start time\\n        sort(meetings.begin(),meetings.end(), comparator);\\n\\n        int bookingCount[n];\\n        fill_n(bookingCount, n, 0);\\n        int mostBooked = -1;\\n        // We declare a min-heap that holds <endTime, roomNumber> \\n        // to keep the min end time at the front.\\n        priority_queue<vector<long>, vector<vector<long>>, greater<vector<long>>> freeAt; \\n        priority_queue<int,vector<int>,greater<int>> emptyRooms;\\n        for(int i = 0; i < n; i++)\\n        {\\n            emptyRooms.push(i);\\n        }\\n\\n        for(int i = 0; i < meetings.size(); i++)\\n        {\\n            if(mostBooked == -1)\\n            {\\n                mostBooked = 0;\\n                bookingCount[mostBooked]++;\\n                vector<long> newFreeAt = {meetings[i][1], mostBooked}; \\n                freeAt.push(newFreeAt);\\n                emptyRooms.pop();\\n            }\\n            else\\n            {\\n                // if(meetings[i][0] < freeAt.top().first )\\n                if(meetings[i][0] < freeAt.top()[0] )\\n                {\\n                    // current meeting start time is earlier\\n                    // than the earliest-finishing scheduled meeting\\n                    if(freeAt.size() < n)\\n                    {\\n                        // there are available rooms, so book the next available\\n                        vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                    else\\n                    {\\n                        // there are no more available rooms, so this will haven\\n                        // to wait for the earliest finishing scheduled meeting\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        int meetingDuration = meetings[i][1] - meetings[i][0];//end time - start time\\n                        long newEndTime = freeAt.top()[0] + meetingDuration;\\n                        freeAt.pop();\\n                        vector<long> newFreeAt = {newEndTime, emptyRooms.top()}; \\n                        freeAt.push(newFreeAt);\\n                        bookingCount[emptyRooms.top()]++;\\n                        mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                        emptyRooms.pop();\\n                    }\\n                }\\n                else\\n                {\\n                    // current meeting start time is later than the earliest\\n                    // finishing scheduled meeting. \\n                    while(!freeAt.empty() \\n                    && meetings[i][0] >= freeAt.top()[0])\\n                    {\\n                        // let the meetings finish to make sure \\n                        // we get the room with the smallest number\\n                        emptyRooms.push(freeAt.top()[1]);\\n                        freeAt.pop();\\n                    }\\n                    vector<long> newFreeAt = {meetings[i][1], emptyRooms.top()}; \\n                    freeAt.push(newFreeAt);\\n                    bookingCount[emptyRooms.top()]++;\\n                    mostBooked = updateMostBooked(mostBooked, emptyRooms.top(), bookingCount);\\n                    emptyRooms.pop();\\n                }\\n            }\\n        }\\n        return mostBooked;\\n    }\\n    static bool comparator(vector<int> a, vector<int> b)\\n    {\\n        if(a[0] <= b[0])\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int updateMostBooked(int mostBooked, int newlyBooked, int bookingCount[])\\n    {\\n        int newMostBooked;\\n        if(bookingCount[newlyBooked] > bookingCount[mostBooked])\\n        {\\n            newMostBooked = newlyBooked;\\n        }\\n        else if (bookingCount[newlyBooked] == bookingCount[mostBooked])\\n        {\\n            // if two rooms have the same amount of meetings,\\n            // we consider the room with the smallest ID as \\n            // the most booked\\n            newMostBooked = min(newlyBooked, mostBooked);\\n        }\\n        else\\n        {\\n            newMostBooked = mostBooked;\\n        }\\n        return newMostBooked;\\n    }\\n};\\n```\\n"
                    }
                ]
            },
            {
                "id": 2008755,
                "content": [
                    {
                        "username": "strangeranda",
                        "content": "Calculate Delay for only `current` meeting, not everything, "
                    },
                    {
                        "username": "superZero",
                        "content": "But why? All meetings that have start time less than the end time of the busy room should be delayed isn\\'t it? In reality, all such meetings run late until there are rooms available. "
                    },
                    {
                        "username": "strangeranda",
                        "content": "EDIT: This is solved. the idea here is calculate the delay just for one meeting, not anything else. \n\nCan someone help me here? [[39,49],[28,39],[9,29],[10,36],[22,47],[2,3],[4,49],[46,50],[45,50],[17,33]]\nThe expected is 0, but Im getting 1. \n\nIm storing a list of (end Time, room), and the last iteration is [(62,2), (66,0)], and the last meeting is [62,66] (taking the delay into consideration). \n\nIm under the impression that we free the room 2 and assign the meeting to room1 since it is lower index of two rooms available. which makes the count as {0:3, 1:4, 2:2}\n\nand it returns 1 as the most frequently used room. but the answer expected is 0."
                    },
                    {
                        "username": "naveenky",
                        "content": "Failing for this case: n = 4, meeting = [[12,44],[27,37],[48,49],[46,49],[24,44],[32,38],[21,49],[13,30]]\\nsolution should be:\\n3, 3, 1 ,1. \\n0: (12, 44) (46, 49) (48, 49)\\n1: (13, 30) (27, 37) (32, 38)\\n2: (21, 49)\\n3: (24, 44)\\n\\nbut reported output is 2, 4, 1, 1.\\nCan someone please explain how this output is coming?\\n"
                    },
                    {
                        "username": "Priyansh1210",
                        "content": "Passing 79/82 test cases. Can someone help me? Explained my reasoning with code comments.\\n\\nFails on the following test case: n=2; meetings=[[43,44],[34,36],[11,47],[1,8],[30,33],[45,48],[23,41],[29,30]])\\nO/P: 0; Expected O/P=1\\n\\n```\\nfrom heapq import heappush, heappop, heapify\\n\\nclass Solution:\\n    def mostBooked(self, N: int, meetings: List[List[int]]) -> int:\\n        meetings = sorted(meetings, key=lambda x: (x[0], x[1]))\\n        M = len(meetings)\\n        \\n        # end_time, room_index\\n        heap = []\\n\\n        counts = {i: 0 for i in range(N)}\\n        maxroom = (None, float(\\'-inf\\'))\\n        minPoppedRI = float(\\'inf\\')\\n        for i in range(M):\\n            start, end = meetings[i]\\n\\n            # et = End time of the next meeting which will be assigned to a room at the\\n            # end of this iteration.\\n            # ri = Index of the room which the current meeting will be assigned to. We\\'ll\\n            # make sure that this is the mimimum indexed room which is available at the \\n            # start of this meeting.\\n            et, ri = None, float(\\'inf\\')\\n\\n            # Free up all rooms which are holding meetings with end time less than the\\n            # start of the current meeting and keep track of the minimum indexed room.\\n            while heap and start > heap[0][0]:\\n                popped_et, popped_ri = heappop(heap)\\n                if popped_ri < ri:\\n                    et, ri = popped_et, popped_ri\\n                minPoppedRI = min(popped_ri, minPoppedRI)\\n\\n            if ri != float(\\'inf\\'):\\n                # If we did manage to free up some rooms, assign the current meeting to \\n                # the room with the minimum index. The current meeting will start and end\\n                # at its original time.\\n                et = end\\n                ri = len(heap) if ri > len(heap) else ri\\n            else:\\n                # If no meeting ends before the start of this one...\\n                if len(heap) < N:\\n                    # If there are some empty rooms, assign this meeting to the lowest\\n                    # indexed empty room. The current meeting will start and end at its\\n                    # original time.\\n                    et, ri = end, min(len(heap), minPoppedRI)\\n                else:\\n                    # If there are no empty rooms at the moment, delay the current meeting\\n                    # till the end of the meeting which is ending the earliest (\"et\") and then\\n                    # schedule the current meeting to that room. Now the current meeting\\n                    # will start at \"et\" and end at \"et + (end - start)\"\\n                    et, ri = heappop(heap)\\n                    et += (end-start)\\n                    minPoppedRI = min(ri, minPoppedRI)\\n                \\n            heappush(heap, (et, ri))\\n            # print(start, end, et, ri, heap)\\n            counts[ri] += 1\\n\\n            if counts[ri] > maxroom[1] or (counts[ri] == maxroom[1] and maxroom[0] is not None and maxroom[0] > ri):\\n                maxroom = (ri, counts[ri])\\n\\n        # print(counts)\\n        return maxroom[0]\\n```"
                    },
                    {
                        "username": "btulsi",
                        "content": "81/82 test cases , anyone know what\\'s wrong?\\n\\n `var mostBooked = function(n, meetings) {\\n\\n    // Sort meetings by start time\\n    meetings.sort((a, b) => a[0] - b[0]);\\n\\n    let busy = [];\\n    let avail = Array.from({length: n}, (_, i) => i);\\n    const count = Array(n).fill(0);\\n\\n    for(let meeting of meetings) {\\n        const [start,end] = meeting;\\n\\n        // Shift all the rooms that are past the current start time\\n        while(busy.length && busy[0][0] <= start){\\n            const [oldEnd, room] = busy.shift();\\n            avail.push(room);\\n            avail.sort((a, b) => a - b); // Ensure available rooms are sorted\\n        }\\n\\n        let room;\\n\\n        if(avail.length) {\\n            room = avail.shift();\\n            busy.push([end,room]);\\n        } else {\\n            // Calculate the new end time\\n            const [time, roomBusy] = busy.shift();\\n            room = roomBusy;\\n            const newEnd = time < start ? end : time + (end - start);\\n            busy.push([newEnd,room]);\\n        }\\n\\n        // Sort busy rooms by their end time\\n        busy.sort((a, b) => a[0] - b[0]);\\n\\n        // Increment the count of meetings held in the room\\n        count[room] += 1;\\n    }\\n\\n    // Determine the room that held the most meetings\\n    let maxCount = 0;\\n    let maxRoom = 0;\\n    for(let i = 0; i < n; i++){\\n        if(count[i] > maxCount){\\n            maxCount = count[i];\\n            maxRoom = i;\\n        }\\n    }\\n\\n    return maxRoom;\\n};\\n`"
                    },
                    {
                        "username": "leogean3",
                        "content": "I really need help for this code. Almost all the test case I\\'ve tried gives the correct answer. But it gets wrong answer when submitting with an long input which it cannot show the complete input. In this case, I am not able to know the exact input array, which gets the wrong output with this code. Could anyone give me a hand? Thanks in advance:) \\nclass Solution {\\npublic int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a, b) -> (Integer.compare(a[0], b[0])));\\n        int[] rooms_count = new int[n];\\n        int[] rooms_end = new int[n];\\n        int max_count = 0;\\n        int max_number = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            rooms_count[i] = 0;\\n            rooms_end[i] = 0;\\n        }\\n        for(int i=0; i<meetings.length; i++)\\n        {\\n            int flag = 0;\\n            int min_finish = Integer.MAX_VALUE;\\n            int pre_min = Integer.MAX_VALUE;\\n            int finish_room = 0;\\n            for(int j=0; j<n; j++)\\n            {\\n                if (rooms_end[j] <= meetings[i][0])\\n                {\\n                    rooms_count[j] ++;\\n                    rooms_end[j] = meetings[i][1];\\n                    flag= 1;\\n                    break;\\n                }\\n                pre_min = min_finish;\\n                min_finish = Math.min(min_finish, rooms_end[j]);\\n                if (pre_min != min_finish)\\n                    finish_room = j;\\n            }\\n            if (flag == 0)\\n            {\\n                rooms_count[finish_room] ++;\\n                rooms_end[finish_room] += meetings[i][1] - meetings[i][0];\\n            }\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            int pre_max = max_count;\\n            max_count = Math.max(max_count, rooms_count[i]);\\n            if (pre_max != max_count)\\n                max_number = i;\\n        }\\n        return max_number;\\n    }\\n}"
                    },
                    {
                        "username": "josec1003",
                        "content": "Not sure what is wrong with my answer if someone can help:\\n `n=2`\\n`meetings=[[10,11],[2,10],[1,17],[9,13],[18,20]]`\\n`leet code answer=1`\\nMy answer is room zero though:\\n1. Meeting [10,11] goes in unoccupied room 0\\n2. Meeting [2,10] goes into room 0 since it will finish before [10,11]\\n3. Meeting [1,17] goes into room 1 since it is unoccupied\\n4. Meeting [9,13] goes into room 0 as [11, 15]\\n5. Meeting [18,20] goes into room 0\\n`rooms=[[[2, 10], [10, 11], [11, 15], [18, 20]], [[1, 17]]]`\\nWhere the answer is `0` not `1`"
                    },
                    {
                        "username": "roger-song",
                        "content": "you need to read the condition carefully. \\n\\nthe description says \\ncond1, Each meeting will take place in the unused room with the lowest number.\\ncond2. When a room becomes unused, meetings that have an earlier original start time should be given the room.\\n\\nSo your thought is totally wrong. I think it is better to think in sorted array by start-i(start-i is unique) .\\n[[10,11],[2,10],[1,17],[9,13],[18,20]] => [[1,17],[2,10],[9,13],[10,11],[18,20]]\\n\\n[1,17] -> room 0 (cond1. lowest number)\\n[2,10] -> room 1 \\n[9,13] -> room 1 [10,14] (cause room 0 is not finish) (cond2 earlier original start time)\\n[10,11] -> room 1 [14,15] (cause room 0 is not finish)\\n[18,20] -> room 0 (cond1. lowest number)\\n\\nso answer is 1"
                    },
                    {
                        "username": "josec1003",
                        "content": "Actually even if we do that you will get the following still making room 0 have the most meetings:\n`rooms=[[[10, 11], [11, 15], [18, 20]], [[2, 10], [10, 26]]]`\n1. Meeting [10,11] goes in unoccupied room 0\n2. Meeting [2,10] goes in unoccupied room 1\n3. Meeting [1,17]  goes into room 1 as [10, 26] since it frees up first\n4. Meeting [9,13] goes into room 0 as [11, 15] since it frees up next\n5. Meeting [18,20] goes into room 0"
                    },
                    {
                        "username": "josec1003",
                        "content": "I guess it wants all rooms to be filled before you evaluate if a lower room has availability in the time slot?"
                    },
                    {
                        "username": "navneetjain",
                        "content": "2 of the test cases are failing. can someone point me if they see any mistake. Any help is appreciated :)\\n\\n```\\nfrom queue import PriorityQueue\\n\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        vacantRoomPQ = PriorityQueue()\\n        occupiedRoomPQ = PriorityQueue()\\n\\n        for roomNo in range(n):\\n            vacantRoomPQ.put((roomNo,0))\\n        \\n        currentTime = 0\\n        currentMax = 0\\n        currentMaxRoom = -1\\n        meetingRoomId = -1\\n        meetings.sort()\\n\\n        for meeting in meetings:\\n            currentTime = meeting[0]\\n\\n            #if there are no vacant rooms, then fast forward to the end time of meeting with \\n            #least end time (if it\\'s greater than current meeting\\'s start time)\\n            if vacantRoomPQ.empty() and currentTime < occupiedRoomPQ.queue[0][0]:\\n                currentTime = occupiedRoomPQ.queue[0][0]\\n                \\n            #pop from used meeting rooms till current time is greater than equal to meeting\\'s time\\n            while not occupiedRoomPQ.empty() and occupiedRoomPQ.queue[0][0] <= currentTime:\\n                (endTime, meetingRoomId, meetingCount) = occupiedRoomPQ.get()\\n                vacantRoomPQ.put((meetingRoomId, meetingCount))\\n            \\n            (meetingRoomId, meetingCount) = vacantRoomPQ.get()\\n\\n            #Condition to update currentmax and current room with max meetings\\n            if currentMax < meetingCount+1 or (currentMax == meetingCount+1 and currentMaxRoom > meetingRoomId):\\n                currentMax = meetingCount+1\\n                currentMaxRoom = meetingRoomId\\n                \\n            #increment duration, meeting count and put in occupied rooms\\n            occupiedRoomPQ.put((currentTime+meeting[1]-meeting[0], meetingRoomId, meetingCount+1))\\n        \\n        return currentMaxRoom\\n\\n\\n```\\n"
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "[@Heman962](/Heman962) Thanks man. This was very insightful"
                    },
                    {
                        "username": "Heman962",
                        "content": "[@navneetjain](/navneetjain) can you share full code? i want to see how you are taking values if there are free items."
                    },
                    {
                        "username": "navneetjain",
                        "content": "Hey [@Heman962](/Heman962),\\n\\nThanks for the reply\\n\\nI actually did take that into consideration\\n\\n```\\n\\n            #if there are no vacant rooms, then fast forward to the end time of meeting with \\n            #least end time (if it\\'s greater than current meeting\\'s start time)\\n            if vacantRoomPQ.empty() and currentTime < occupiedRoomPQ.queue[0][0]:\\n                currentTime = occupiedRoomPQ.queue[0][0]\\n                \\n            #pop from used meeting rooms till current time is greater than equal to meeting\\'s time\\n            while not occupiedRoomPQ.empty() and occupiedRoomPQ.queue[0][0] <= currentTime:\\n                (endTime, meetingRoomId, meetingCount) = occupiedRoomPQ.get()\\n                vacantRoomPQ.put((meetingRoomId, meetingCount))\\n            \\n```\\n"
                    },
                    {
                        "username": "Heman962",
                        "content": "hey [@navneetjain](/navneetjain),\\n\\nFaced the same issue,\\n\\nyou might have missed the case where there are no free rooms, and there are mutliple busy rooms with same avaialble time. now how do we know which one to take ? the one with min room no right ? so we need to move all the busy rooms with samve ending time back to freerooms priority queue. and then pop the top one.\\n\\nnow it gets tricky here  to choose the ending time for new meeting\\ncase1:\\nTop Free room with next avaialbiity time <= new meetingtime( good use case)\\ncase2\\nTop Free room with next avaialbiity time > new meetingtime( good use case) // this room came as result of moving from busy rooms when ending times match and there were no free rooms.\\n\\nso choosing the eindig time for new meeting would be\\n Math.max(nextAvaialbleTime, newMtngStrtTime) +duration\\n\\nhere: \\nhttps://leetcode.com/problems/meeting-rooms-iii/submissions/\\n"
                    },
                    {
                        "username": "roger-song",
                        "content": "I don\\'t know why my logic is wrong. Anybody can help me?\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        unordered_map<int, vector<vector<int>>> rooms(n + 1);\\n        sort(meetings.begin(), meetings.end());\\n\\n        for (auto meeting : meetings) {\\n            bool meeting_allocated = false;\\n            int min_finish_time = 500005;\\n            int min_finish_time_idx = -1;\\n\\n            for (int idx = 0; idx < n; idx++) {\\n                if (rooms[idx].size() == 0 || rooms[idx].back()[1] <= meeting[0]) {\\n                    rooms[idx].push_back(meeting);\\n                    meeting_allocated = true;\\n                    break;\\n                }\\n                else {\\n                    if (rooms[idx].back()[1] < min_finish_time) { // update which rooms last meeting end time is most ealry. \\n                        min_finish_time = rooms[idx].back()[1];\\n                        min_finish_time_idx = idx;\\n                    }\\n                }\\n            }\\n\\n            if (meeting_allocated == false) {\\n                vector<int> tmp = { min_finish_time, meeting[1] + (min_finish_time - meeting[0]) };\\n                rooms[min_finish_time_idx].push_back(tmp);\\n            }\\n        }\\n\\n        int max_meeting_room = 0;\\n        int max_meeting_cnt = -1;\\n        for (int idx = 0; idx < n; idx++) {\\n            if ((int)rooms[idx].size() > max_meeting_cnt) {\\n                max_meeting_cnt = rooms[idx].size();\\n                max_meeting_room = idx;\\n            }\\n        }\\n\\n        return max_meeting_room;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "roger-song",
                        "content": "I found it myself. \\n\\nI missed data type of the data structure. The number can be maxed to 5e9, so the data type could be long. thx"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This question really grinds my gears , I know it has something to do with heap but maintaining the heap of current meeting is something i was not able to figure out at all"
                    }
                ]
            },
            {
                "id": 2008743,
                "content": [
                    {
                        "username": "strangeranda",
                        "content": "Calculate Delay for only `current` meeting, not everything, "
                    },
                    {
                        "username": "superZero",
                        "content": "But why? All meetings that have start time less than the end time of the busy room should be delayed isn\\'t it? In reality, all such meetings run late until there are rooms available. "
                    },
                    {
                        "username": "strangeranda",
                        "content": "EDIT: This is solved. the idea here is calculate the delay just for one meeting, not anything else. \n\nCan someone help me here? [[39,49],[28,39],[9,29],[10,36],[22,47],[2,3],[4,49],[46,50],[45,50],[17,33]]\nThe expected is 0, but Im getting 1. \n\nIm storing a list of (end Time, room), and the last iteration is [(62,2), (66,0)], and the last meeting is [62,66] (taking the delay into consideration). \n\nIm under the impression that we free the room 2 and assign the meeting to room1 since it is lower index of two rooms available. which makes the count as {0:3, 1:4, 2:2}\n\nand it returns 1 as the most frequently used room. but the answer expected is 0."
                    },
                    {
                        "username": "naveenky",
                        "content": "Failing for this case: n = 4, meeting = [[12,44],[27,37],[48,49],[46,49],[24,44],[32,38],[21,49],[13,30]]\\nsolution should be:\\n3, 3, 1 ,1. \\n0: (12, 44) (46, 49) (48, 49)\\n1: (13, 30) (27, 37) (32, 38)\\n2: (21, 49)\\n3: (24, 44)\\n\\nbut reported output is 2, 4, 1, 1.\\nCan someone please explain how this output is coming?\\n"
                    },
                    {
                        "username": "Priyansh1210",
                        "content": "Passing 79/82 test cases. Can someone help me? Explained my reasoning with code comments.\\n\\nFails on the following test case: n=2; meetings=[[43,44],[34,36],[11,47],[1,8],[30,33],[45,48],[23,41],[29,30]])\\nO/P: 0; Expected O/P=1\\n\\n```\\nfrom heapq import heappush, heappop, heapify\\n\\nclass Solution:\\n    def mostBooked(self, N: int, meetings: List[List[int]]) -> int:\\n        meetings = sorted(meetings, key=lambda x: (x[0], x[1]))\\n        M = len(meetings)\\n        \\n        # end_time, room_index\\n        heap = []\\n\\n        counts = {i: 0 for i in range(N)}\\n        maxroom = (None, float(\\'-inf\\'))\\n        minPoppedRI = float(\\'inf\\')\\n        for i in range(M):\\n            start, end = meetings[i]\\n\\n            # et = End time of the next meeting which will be assigned to a room at the\\n            # end of this iteration.\\n            # ri = Index of the room which the current meeting will be assigned to. We\\'ll\\n            # make sure that this is the mimimum indexed room which is available at the \\n            # start of this meeting.\\n            et, ri = None, float(\\'inf\\')\\n\\n            # Free up all rooms which are holding meetings with end time less than the\\n            # start of the current meeting and keep track of the minimum indexed room.\\n            while heap and start > heap[0][0]:\\n                popped_et, popped_ri = heappop(heap)\\n                if popped_ri < ri:\\n                    et, ri = popped_et, popped_ri\\n                minPoppedRI = min(popped_ri, minPoppedRI)\\n\\n            if ri != float(\\'inf\\'):\\n                # If we did manage to free up some rooms, assign the current meeting to \\n                # the room with the minimum index. The current meeting will start and end\\n                # at its original time.\\n                et = end\\n                ri = len(heap) if ri > len(heap) else ri\\n            else:\\n                # If no meeting ends before the start of this one...\\n                if len(heap) < N:\\n                    # If there are some empty rooms, assign this meeting to the lowest\\n                    # indexed empty room. The current meeting will start and end at its\\n                    # original time.\\n                    et, ri = end, min(len(heap), minPoppedRI)\\n                else:\\n                    # If there are no empty rooms at the moment, delay the current meeting\\n                    # till the end of the meeting which is ending the earliest (\"et\") and then\\n                    # schedule the current meeting to that room. Now the current meeting\\n                    # will start at \"et\" and end at \"et + (end - start)\"\\n                    et, ri = heappop(heap)\\n                    et += (end-start)\\n                    minPoppedRI = min(ri, minPoppedRI)\\n                \\n            heappush(heap, (et, ri))\\n            # print(start, end, et, ri, heap)\\n            counts[ri] += 1\\n\\n            if counts[ri] > maxroom[1] or (counts[ri] == maxroom[1] and maxroom[0] is not None and maxroom[0] > ri):\\n                maxroom = (ri, counts[ri])\\n\\n        # print(counts)\\n        return maxroom[0]\\n```"
                    },
                    {
                        "username": "btulsi",
                        "content": "81/82 test cases , anyone know what\\'s wrong?\\n\\n `var mostBooked = function(n, meetings) {\\n\\n    // Sort meetings by start time\\n    meetings.sort((a, b) => a[0] - b[0]);\\n\\n    let busy = [];\\n    let avail = Array.from({length: n}, (_, i) => i);\\n    const count = Array(n).fill(0);\\n\\n    for(let meeting of meetings) {\\n        const [start,end] = meeting;\\n\\n        // Shift all the rooms that are past the current start time\\n        while(busy.length && busy[0][0] <= start){\\n            const [oldEnd, room] = busy.shift();\\n            avail.push(room);\\n            avail.sort((a, b) => a - b); // Ensure available rooms are sorted\\n        }\\n\\n        let room;\\n\\n        if(avail.length) {\\n            room = avail.shift();\\n            busy.push([end,room]);\\n        } else {\\n            // Calculate the new end time\\n            const [time, roomBusy] = busy.shift();\\n            room = roomBusy;\\n            const newEnd = time < start ? end : time + (end - start);\\n            busy.push([newEnd,room]);\\n        }\\n\\n        // Sort busy rooms by their end time\\n        busy.sort((a, b) => a[0] - b[0]);\\n\\n        // Increment the count of meetings held in the room\\n        count[room] += 1;\\n    }\\n\\n    // Determine the room that held the most meetings\\n    let maxCount = 0;\\n    let maxRoom = 0;\\n    for(let i = 0; i < n; i++){\\n        if(count[i] > maxCount){\\n            maxCount = count[i];\\n            maxRoom = i;\\n        }\\n    }\\n\\n    return maxRoom;\\n};\\n`"
                    },
                    {
                        "username": "leogean3",
                        "content": "I really need help for this code. Almost all the test case I\\'ve tried gives the correct answer. But it gets wrong answer when submitting with an long input which it cannot show the complete input. In this case, I am not able to know the exact input array, which gets the wrong output with this code. Could anyone give me a hand? Thanks in advance:) \\nclass Solution {\\npublic int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a, b) -> (Integer.compare(a[0], b[0])));\\n        int[] rooms_count = new int[n];\\n        int[] rooms_end = new int[n];\\n        int max_count = 0;\\n        int max_number = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            rooms_count[i] = 0;\\n            rooms_end[i] = 0;\\n        }\\n        for(int i=0; i<meetings.length; i++)\\n        {\\n            int flag = 0;\\n            int min_finish = Integer.MAX_VALUE;\\n            int pre_min = Integer.MAX_VALUE;\\n            int finish_room = 0;\\n            for(int j=0; j<n; j++)\\n            {\\n                if (rooms_end[j] <= meetings[i][0])\\n                {\\n                    rooms_count[j] ++;\\n                    rooms_end[j] = meetings[i][1];\\n                    flag= 1;\\n                    break;\\n                }\\n                pre_min = min_finish;\\n                min_finish = Math.min(min_finish, rooms_end[j]);\\n                if (pre_min != min_finish)\\n                    finish_room = j;\\n            }\\n            if (flag == 0)\\n            {\\n                rooms_count[finish_room] ++;\\n                rooms_end[finish_room] += meetings[i][1] - meetings[i][0];\\n            }\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            int pre_max = max_count;\\n            max_count = Math.max(max_count, rooms_count[i]);\\n            if (pre_max != max_count)\\n                max_number = i;\\n        }\\n        return max_number;\\n    }\\n}"
                    },
                    {
                        "username": "josec1003",
                        "content": "Not sure what is wrong with my answer if someone can help:\\n `n=2`\\n`meetings=[[10,11],[2,10],[1,17],[9,13],[18,20]]`\\n`leet code answer=1`\\nMy answer is room zero though:\\n1. Meeting [10,11] goes in unoccupied room 0\\n2. Meeting [2,10] goes into room 0 since it will finish before [10,11]\\n3. Meeting [1,17] goes into room 1 since it is unoccupied\\n4. Meeting [9,13] goes into room 0 as [11, 15]\\n5. Meeting [18,20] goes into room 0\\n`rooms=[[[2, 10], [10, 11], [11, 15], [18, 20]], [[1, 17]]]`\\nWhere the answer is `0` not `1`"
                    },
                    {
                        "username": "roger-song",
                        "content": "you need to read the condition carefully. \\n\\nthe description says \\ncond1, Each meeting will take place in the unused room with the lowest number.\\ncond2. When a room becomes unused, meetings that have an earlier original start time should be given the room.\\n\\nSo your thought is totally wrong. I think it is better to think in sorted array by start-i(start-i is unique) .\\n[[10,11],[2,10],[1,17],[9,13],[18,20]] => [[1,17],[2,10],[9,13],[10,11],[18,20]]\\n\\n[1,17] -> room 0 (cond1. lowest number)\\n[2,10] -> room 1 \\n[9,13] -> room 1 [10,14] (cause room 0 is not finish) (cond2 earlier original start time)\\n[10,11] -> room 1 [14,15] (cause room 0 is not finish)\\n[18,20] -> room 0 (cond1. lowest number)\\n\\nso answer is 1"
                    },
                    {
                        "username": "josec1003",
                        "content": "Actually even if we do that you will get the following still making room 0 have the most meetings:\n`rooms=[[[10, 11], [11, 15], [18, 20]], [[2, 10], [10, 26]]]`\n1. Meeting [10,11] goes in unoccupied room 0\n2. Meeting [2,10] goes in unoccupied room 1\n3. Meeting [1,17]  goes into room 1 as [10, 26] since it frees up first\n4. Meeting [9,13] goes into room 0 as [11, 15] since it frees up next\n5. Meeting [18,20] goes into room 0"
                    },
                    {
                        "username": "josec1003",
                        "content": "I guess it wants all rooms to be filled before you evaluate if a lower room has availability in the time slot?"
                    },
                    {
                        "username": "navneetjain",
                        "content": "2 of the test cases are failing. can someone point me if they see any mistake. Any help is appreciated :)\\n\\n```\\nfrom queue import PriorityQueue\\n\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        vacantRoomPQ = PriorityQueue()\\n        occupiedRoomPQ = PriorityQueue()\\n\\n        for roomNo in range(n):\\n            vacantRoomPQ.put((roomNo,0))\\n        \\n        currentTime = 0\\n        currentMax = 0\\n        currentMaxRoom = -1\\n        meetingRoomId = -1\\n        meetings.sort()\\n\\n        for meeting in meetings:\\n            currentTime = meeting[0]\\n\\n            #if there are no vacant rooms, then fast forward to the end time of meeting with \\n            #least end time (if it\\'s greater than current meeting\\'s start time)\\n            if vacantRoomPQ.empty() and currentTime < occupiedRoomPQ.queue[0][0]:\\n                currentTime = occupiedRoomPQ.queue[0][0]\\n                \\n            #pop from used meeting rooms till current time is greater than equal to meeting\\'s time\\n            while not occupiedRoomPQ.empty() and occupiedRoomPQ.queue[0][0] <= currentTime:\\n                (endTime, meetingRoomId, meetingCount) = occupiedRoomPQ.get()\\n                vacantRoomPQ.put((meetingRoomId, meetingCount))\\n            \\n            (meetingRoomId, meetingCount) = vacantRoomPQ.get()\\n\\n            #Condition to update currentmax and current room with max meetings\\n            if currentMax < meetingCount+1 or (currentMax == meetingCount+1 and currentMaxRoom > meetingRoomId):\\n                currentMax = meetingCount+1\\n                currentMaxRoom = meetingRoomId\\n                \\n            #increment duration, meeting count and put in occupied rooms\\n            occupiedRoomPQ.put((currentTime+meeting[1]-meeting[0], meetingRoomId, meetingCount+1))\\n        \\n        return currentMaxRoom\\n\\n\\n```\\n"
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "[@Heman962](/Heman962) Thanks man. This was very insightful"
                    },
                    {
                        "username": "Heman962",
                        "content": "[@navneetjain](/navneetjain) can you share full code? i want to see how you are taking values if there are free items."
                    },
                    {
                        "username": "navneetjain",
                        "content": "Hey [@Heman962](/Heman962),\\n\\nThanks for the reply\\n\\nI actually did take that into consideration\\n\\n```\\n\\n            #if there are no vacant rooms, then fast forward to the end time of meeting with \\n            #least end time (if it\\'s greater than current meeting\\'s start time)\\n            if vacantRoomPQ.empty() and currentTime < occupiedRoomPQ.queue[0][0]:\\n                currentTime = occupiedRoomPQ.queue[0][0]\\n                \\n            #pop from used meeting rooms till current time is greater than equal to meeting\\'s time\\n            while not occupiedRoomPQ.empty() and occupiedRoomPQ.queue[0][0] <= currentTime:\\n                (endTime, meetingRoomId, meetingCount) = occupiedRoomPQ.get()\\n                vacantRoomPQ.put((meetingRoomId, meetingCount))\\n            \\n```\\n"
                    },
                    {
                        "username": "Heman962",
                        "content": "hey [@navneetjain](/navneetjain),\\n\\nFaced the same issue,\\n\\nyou might have missed the case where there are no free rooms, and there are mutliple busy rooms with same avaialble time. now how do we know which one to take ? the one with min room no right ? so we need to move all the busy rooms with samve ending time back to freerooms priority queue. and then pop the top one.\\n\\nnow it gets tricky here  to choose the ending time for new meeting\\ncase1:\\nTop Free room with next avaialbiity time <= new meetingtime( good use case)\\ncase2\\nTop Free room with next avaialbiity time > new meetingtime( good use case) // this room came as result of moving from busy rooms when ending times match and there were no free rooms.\\n\\nso choosing the eindig time for new meeting would be\\n Math.max(nextAvaialbleTime, newMtngStrtTime) +duration\\n\\nhere: \\nhttps://leetcode.com/problems/meeting-rooms-iii/submissions/\\n"
                    },
                    {
                        "username": "roger-song",
                        "content": "I don\\'t know why my logic is wrong. Anybody can help me?\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        unordered_map<int, vector<vector<int>>> rooms(n + 1);\\n        sort(meetings.begin(), meetings.end());\\n\\n        for (auto meeting : meetings) {\\n            bool meeting_allocated = false;\\n            int min_finish_time = 500005;\\n            int min_finish_time_idx = -1;\\n\\n            for (int idx = 0; idx < n; idx++) {\\n                if (rooms[idx].size() == 0 || rooms[idx].back()[1] <= meeting[0]) {\\n                    rooms[idx].push_back(meeting);\\n                    meeting_allocated = true;\\n                    break;\\n                }\\n                else {\\n                    if (rooms[idx].back()[1] < min_finish_time) { // update which rooms last meeting end time is most ealry. \\n                        min_finish_time = rooms[idx].back()[1];\\n                        min_finish_time_idx = idx;\\n                    }\\n                }\\n            }\\n\\n            if (meeting_allocated == false) {\\n                vector<int> tmp = { min_finish_time, meeting[1] + (min_finish_time - meeting[0]) };\\n                rooms[min_finish_time_idx].push_back(tmp);\\n            }\\n        }\\n\\n        int max_meeting_room = 0;\\n        int max_meeting_cnt = -1;\\n        for (int idx = 0; idx < n; idx++) {\\n            if ((int)rooms[idx].size() > max_meeting_cnt) {\\n                max_meeting_cnt = rooms[idx].size();\\n                max_meeting_room = idx;\\n            }\\n        }\\n\\n        return max_meeting_room;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "roger-song",
                        "content": "I found it myself. \\n\\nI missed data type of the data structure. The number can be maxed to 5e9, so the data type could be long. thx"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This question really grinds my gears , I know it has something to do with heap but maintaining the heap of current meeting is something i was not able to figure out at all"
                    }
                ]
            },
            {
                "id": 2000795,
                "content": [
                    {
                        "username": "strangeranda",
                        "content": "Calculate Delay for only `current` meeting, not everything, "
                    },
                    {
                        "username": "superZero",
                        "content": "But why? All meetings that have start time less than the end time of the busy room should be delayed isn\\'t it? In reality, all such meetings run late until there are rooms available. "
                    },
                    {
                        "username": "strangeranda",
                        "content": "EDIT: This is solved. the idea here is calculate the delay just for one meeting, not anything else. \n\nCan someone help me here? [[39,49],[28,39],[9,29],[10,36],[22,47],[2,3],[4,49],[46,50],[45,50],[17,33]]\nThe expected is 0, but Im getting 1. \n\nIm storing a list of (end Time, room), and the last iteration is [(62,2), (66,0)], and the last meeting is [62,66] (taking the delay into consideration). \n\nIm under the impression that we free the room 2 and assign the meeting to room1 since it is lower index of two rooms available. which makes the count as {0:3, 1:4, 2:2}\n\nand it returns 1 as the most frequently used room. but the answer expected is 0."
                    },
                    {
                        "username": "naveenky",
                        "content": "Failing for this case: n = 4, meeting = [[12,44],[27,37],[48,49],[46,49],[24,44],[32,38],[21,49],[13,30]]\\nsolution should be:\\n3, 3, 1 ,1. \\n0: (12, 44) (46, 49) (48, 49)\\n1: (13, 30) (27, 37) (32, 38)\\n2: (21, 49)\\n3: (24, 44)\\n\\nbut reported output is 2, 4, 1, 1.\\nCan someone please explain how this output is coming?\\n"
                    },
                    {
                        "username": "Priyansh1210",
                        "content": "Passing 79/82 test cases. Can someone help me? Explained my reasoning with code comments.\\n\\nFails on the following test case: n=2; meetings=[[43,44],[34,36],[11,47],[1,8],[30,33],[45,48],[23,41],[29,30]])\\nO/P: 0; Expected O/P=1\\n\\n```\\nfrom heapq import heappush, heappop, heapify\\n\\nclass Solution:\\n    def mostBooked(self, N: int, meetings: List[List[int]]) -> int:\\n        meetings = sorted(meetings, key=lambda x: (x[0], x[1]))\\n        M = len(meetings)\\n        \\n        # end_time, room_index\\n        heap = []\\n\\n        counts = {i: 0 for i in range(N)}\\n        maxroom = (None, float(\\'-inf\\'))\\n        minPoppedRI = float(\\'inf\\')\\n        for i in range(M):\\n            start, end = meetings[i]\\n\\n            # et = End time of the next meeting which will be assigned to a room at the\\n            # end of this iteration.\\n            # ri = Index of the room which the current meeting will be assigned to. We\\'ll\\n            # make sure that this is the mimimum indexed room which is available at the \\n            # start of this meeting.\\n            et, ri = None, float(\\'inf\\')\\n\\n            # Free up all rooms which are holding meetings with end time less than the\\n            # start of the current meeting and keep track of the minimum indexed room.\\n            while heap and start > heap[0][0]:\\n                popped_et, popped_ri = heappop(heap)\\n                if popped_ri < ri:\\n                    et, ri = popped_et, popped_ri\\n                minPoppedRI = min(popped_ri, minPoppedRI)\\n\\n            if ri != float(\\'inf\\'):\\n                # If we did manage to free up some rooms, assign the current meeting to \\n                # the room with the minimum index. The current meeting will start and end\\n                # at its original time.\\n                et = end\\n                ri = len(heap) if ri > len(heap) else ri\\n            else:\\n                # If no meeting ends before the start of this one...\\n                if len(heap) < N:\\n                    # If there are some empty rooms, assign this meeting to the lowest\\n                    # indexed empty room. The current meeting will start and end at its\\n                    # original time.\\n                    et, ri = end, min(len(heap), minPoppedRI)\\n                else:\\n                    # If there are no empty rooms at the moment, delay the current meeting\\n                    # till the end of the meeting which is ending the earliest (\"et\") and then\\n                    # schedule the current meeting to that room. Now the current meeting\\n                    # will start at \"et\" and end at \"et + (end - start)\"\\n                    et, ri = heappop(heap)\\n                    et += (end-start)\\n                    minPoppedRI = min(ri, minPoppedRI)\\n                \\n            heappush(heap, (et, ri))\\n            # print(start, end, et, ri, heap)\\n            counts[ri] += 1\\n\\n            if counts[ri] > maxroom[1] or (counts[ri] == maxroom[1] and maxroom[0] is not None and maxroom[0] > ri):\\n                maxroom = (ri, counts[ri])\\n\\n        # print(counts)\\n        return maxroom[0]\\n```"
                    },
                    {
                        "username": "btulsi",
                        "content": "81/82 test cases , anyone know what\\'s wrong?\\n\\n `var mostBooked = function(n, meetings) {\\n\\n    // Sort meetings by start time\\n    meetings.sort((a, b) => a[0] - b[0]);\\n\\n    let busy = [];\\n    let avail = Array.from({length: n}, (_, i) => i);\\n    const count = Array(n).fill(0);\\n\\n    for(let meeting of meetings) {\\n        const [start,end] = meeting;\\n\\n        // Shift all the rooms that are past the current start time\\n        while(busy.length && busy[0][0] <= start){\\n            const [oldEnd, room] = busy.shift();\\n            avail.push(room);\\n            avail.sort((a, b) => a - b); // Ensure available rooms are sorted\\n        }\\n\\n        let room;\\n\\n        if(avail.length) {\\n            room = avail.shift();\\n            busy.push([end,room]);\\n        } else {\\n            // Calculate the new end time\\n            const [time, roomBusy] = busy.shift();\\n            room = roomBusy;\\n            const newEnd = time < start ? end : time + (end - start);\\n            busy.push([newEnd,room]);\\n        }\\n\\n        // Sort busy rooms by their end time\\n        busy.sort((a, b) => a[0] - b[0]);\\n\\n        // Increment the count of meetings held in the room\\n        count[room] += 1;\\n    }\\n\\n    // Determine the room that held the most meetings\\n    let maxCount = 0;\\n    let maxRoom = 0;\\n    for(let i = 0; i < n; i++){\\n        if(count[i] > maxCount){\\n            maxCount = count[i];\\n            maxRoom = i;\\n        }\\n    }\\n\\n    return maxRoom;\\n};\\n`"
                    },
                    {
                        "username": "leogean3",
                        "content": "I really need help for this code. Almost all the test case I\\'ve tried gives the correct answer. But it gets wrong answer when submitting with an long input which it cannot show the complete input. In this case, I am not able to know the exact input array, which gets the wrong output with this code. Could anyone give me a hand? Thanks in advance:) \\nclass Solution {\\npublic int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a, b) -> (Integer.compare(a[0], b[0])));\\n        int[] rooms_count = new int[n];\\n        int[] rooms_end = new int[n];\\n        int max_count = 0;\\n        int max_number = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            rooms_count[i] = 0;\\n            rooms_end[i] = 0;\\n        }\\n        for(int i=0; i<meetings.length; i++)\\n        {\\n            int flag = 0;\\n            int min_finish = Integer.MAX_VALUE;\\n            int pre_min = Integer.MAX_VALUE;\\n            int finish_room = 0;\\n            for(int j=0; j<n; j++)\\n            {\\n                if (rooms_end[j] <= meetings[i][0])\\n                {\\n                    rooms_count[j] ++;\\n                    rooms_end[j] = meetings[i][1];\\n                    flag= 1;\\n                    break;\\n                }\\n                pre_min = min_finish;\\n                min_finish = Math.min(min_finish, rooms_end[j]);\\n                if (pre_min != min_finish)\\n                    finish_room = j;\\n            }\\n            if (flag == 0)\\n            {\\n                rooms_count[finish_room] ++;\\n                rooms_end[finish_room] += meetings[i][1] - meetings[i][0];\\n            }\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            int pre_max = max_count;\\n            max_count = Math.max(max_count, rooms_count[i]);\\n            if (pre_max != max_count)\\n                max_number = i;\\n        }\\n        return max_number;\\n    }\\n}"
                    },
                    {
                        "username": "josec1003",
                        "content": "Not sure what is wrong with my answer if someone can help:\\n `n=2`\\n`meetings=[[10,11],[2,10],[1,17],[9,13],[18,20]]`\\n`leet code answer=1`\\nMy answer is room zero though:\\n1. Meeting [10,11] goes in unoccupied room 0\\n2. Meeting [2,10] goes into room 0 since it will finish before [10,11]\\n3. Meeting [1,17] goes into room 1 since it is unoccupied\\n4. Meeting [9,13] goes into room 0 as [11, 15]\\n5. Meeting [18,20] goes into room 0\\n`rooms=[[[2, 10], [10, 11], [11, 15], [18, 20]], [[1, 17]]]`\\nWhere the answer is `0` not `1`"
                    },
                    {
                        "username": "roger-song",
                        "content": "you need to read the condition carefully. \\n\\nthe description says \\ncond1, Each meeting will take place in the unused room with the lowest number.\\ncond2. When a room becomes unused, meetings that have an earlier original start time should be given the room.\\n\\nSo your thought is totally wrong. I think it is better to think in sorted array by start-i(start-i is unique) .\\n[[10,11],[2,10],[1,17],[9,13],[18,20]] => [[1,17],[2,10],[9,13],[10,11],[18,20]]\\n\\n[1,17] -> room 0 (cond1. lowest number)\\n[2,10] -> room 1 \\n[9,13] -> room 1 [10,14] (cause room 0 is not finish) (cond2 earlier original start time)\\n[10,11] -> room 1 [14,15] (cause room 0 is not finish)\\n[18,20] -> room 0 (cond1. lowest number)\\n\\nso answer is 1"
                    },
                    {
                        "username": "josec1003",
                        "content": "Actually even if we do that you will get the following still making room 0 have the most meetings:\n`rooms=[[[10, 11], [11, 15], [18, 20]], [[2, 10], [10, 26]]]`\n1. Meeting [10,11] goes in unoccupied room 0\n2. Meeting [2,10] goes in unoccupied room 1\n3. Meeting [1,17]  goes into room 1 as [10, 26] since it frees up first\n4. Meeting [9,13] goes into room 0 as [11, 15] since it frees up next\n5. Meeting [18,20] goes into room 0"
                    },
                    {
                        "username": "josec1003",
                        "content": "I guess it wants all rooms to be filled before you evaluate if a lower room has availability in the time slot?"
                    },
                    {
                        "username": "navneetjain",
                        "content": "2 of the test cases are failing. can someone point me if they see any mistake. Any help is appreciated :)\\n\\n```\\nfrom queue import PriorityQueue\\n\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        vacantRoomPQ = PriorityQueue()\\n        occupiedRoomPQ = PriorityQueue()\\n\\n        for roomNo in range(n):\\n            vacantRoomPQ.put((roomNo,0))\\n        \\n        currentTime = 0\\n        currentMax = 0\\n        currentMaxRoom = -1\\n        meetingRoomId = -1\\n        meetings.sort()\\n\\n        for meeting in meetings:\\n            currentTime = meeting[0]\\n\\n            #if there are no vacant rooms, then fast forward to the end time of meeting with \\n            #least end time (if it\\'s greater than current meeting\\'s start time)\\n            if vacantRoomPQ.empty() and currentTime < occupiedRoomPQ.queue[0][0]:\\n                currentTime = occupiedRoomPQ.queue[0][0]\\n                \\n            #pop from used meeting rooms till current time is greater than equal to meeting\\'s time\\n            while not occupiedRoomPQ.empty() and occupiedRoomPQ.queue[0][0] <= currentTime:\\n                (endTime, meetingRoomId, meetingCount) = occupiedRoomPQ.get()\\n                vacantRoomPQ.put((meetingRoomId, meetingCount))\\n            \\n            (meetingRoomId, meetingCount) = vacantRoomPQ.get()\\n\\n            #Condition to update currentmax and current room with max meetings\\n            if currentMax < meetingCount+1 or (currentMax == meetingCount+1 and currentMaxRoom > meetingRoomId):\\n                currentMax = meetingCount+1\\n                currentMaxRoom = meetingRoomId\\n                \\n            #increment duration, meeting count and put in occupied rooms\\n            occupiedRoomPQ.put((currentTime+meeting[1]-meeting[0], meetingRoomId, meetingCount+1))\\n        \\n        return currentMaxRoom\\n\\n\\n```\\n"
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "[@Heman962](/Heman962) Thanks man. This was very insightful"
                    },
                    {
                        "username": "Heman962",
                        "content": "[@navneetjain](/navneetjain) can you share full code? i want to see how you are taking values if there are free items."
                    },
                    {
                        "username": "navneetjain",
                        "content": "Hey [@Heman962](/Heman962),\\n\\nThanks for the reply\\n\\nI actually did take that into consideration\\n\\n```\\n\\n            #if there are no vacant rooms, then fast forward to the end time of meeting with \\n            #least end time (if it\\'s greater than current meeting\\'s start time)\\n            if vacantRoomPQ.empty() and currentTime < occupiedRoomPQ.queue[0][0]:\\n                currentTime = occupiedRoomPQ.queue[0][0]\\n                \\n            #pop from used meeting rooms till current time is greater than equal to meeting\\'s time\\n            while not occupiedRoomPQ.empty() and occupiedRoomPQ.queue[0][0] <= currentTime:\\n                (endTime, meetingRoomId, meetingCount) = occupiedRoomPQ.get()\\n                vacantRoomPQ.put((meetingRoomId, meetingCount))\\n            \\n```\\n"
                    },
                    {
                        "username": "Heman962",
                        "content": "hey [@navneetjain](/navneetjain),\\n\\nFaced the same issue,\\n\\nyou might have missed the case where there are no free rooms, and there are mutliple busy rooms with same avaialble time. now how do we know which one to take ? the one with min room no right ? so we need to move all the busy rooms with samve ending time back to freerooms priority queue. and then pop the top one.\\n\\nnow it gets tricky here  to choose the ending time for new meeting\\ncase1:\\nTop Free room with next avaialbiity time <= new meetingtime( good use case)\\ncase2\\nTop Free room with next avaialbiity time > new meetingtime( good use case) // this room came as result of moving from busy rooms when ending times match and there were no free rooms.\\n\\nso choosing the eindig time for new meeting would be\\n Math.max(nextAvaialbleTime, newMtngStrtTime) +duration\\n\\nhere: \\nhttps://leetcode.com/problems/meeting-rooms-iii/submissions/\\n"
                    },
                    {
                        "username": "roger-song",
                        "content": "I don\\'t know why my logic is wrong. Anybody can help me?\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        unordered_map<int, vector<vector<int>>> rooms(n + 1);\\n        sort(meetings.begin(), meetings.end());\\n\\n        for (auto meeting : meetings) {\\n            bool meeting_allocated = false;\\n            int min_finish_time = 500005;\\n            int min_finish_time_idx = -1;\\n\\n            for (int idx = 0; idx < n; idx++) {\\n                if (rooms[idx].size() == 0 || rooms[idx].back()[1] <= meeting[0]) {\\n                    rooms[idx].push_back(meeting);\\n                    meeting_allocated = true;\\n                    break;\\n                }\\n                else {\\n                    if (rooms[idx].back()[1] < min_finish_time) { // update which rooms last meeting end time is most ealry. \\n                        min_finish_time = rooms[idx].back()[1];\\n                        min_finish_time_idx = idx;\\n                    }\\n                }\\n            }\\n\\n            if (meeting_allocated == false) {\\n                vector<int> tmp = { min_finish_time, meeting[1] + (min_finish_time - meeting[0]) };\\n                rooms[min_finish_time_idx].push_back(tmp);\\n            }\\n        }\\n\\n        int max_meeting_room = 0;\\n        int max_meeting_cnt = -1;\\n        for (int idx = 0; idx < n; idx++) {\\n            if ((int)rooms[idx].size() > max_meeting_cnt) {\\n                max_meeting_cnt = rooms[idx].size();\\n                max_meeting_room = idx;\\n            }\\n        }\\n\\n        return max_meeting_room;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "roger-song",
                        "content": "I found it myself. \\n\\nI missed data type of the data structure. The number can be maxed to 5e9, so the data type could be long. thx"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This question really grinds my gears , I know it has something to do with heap but maintaining the heap of current meeting is something i was not able to figure out at all"
                    }
                ]
            },
            {
                "id": 1971800,
                "content": [
                    {
                        "username": "strangeranda",
                        "content": "Calculate Delay for only `current` meeting, not everything, "
                    },
                    {
                        "username": "superZero",
                        "content": "But why? All meetings that have start time less than the end time of the busy room should be delayed isn\\'t it? In reality, all such meetings run late until there are rooms available. "
                    },
                    {
                        "username": "strangeranda",
                        "content": "EDIT: This is solved. the idea here is calculate the delay just for one meeting, not anything else. \n\nCan someone help me here? [[39,49],[28,39],[9,29],[10,36],[22,47],[2,3],[4,49],[46,50],[45,50],[17,33]]\nThe expected is 0, but Im getting 1. \n\nIm storing a list of (end Time, room), and the last iteration is [(62,2), (66,0)], and the last meeting is [62,66] (taking the delay into consideration). \n\nIm under the impression that we free the room 2 and assign the meeting to room1 since it is lower index of two rooms available. which makes the count as {0:3, 1:4, 2:2}\n\nand it returns 1 as the most frequently used room. but the answer expected is 0."
                    },
                    {
                        "username": "naveenky",
                        "content": "Failing for this case: n = 4, meeting = [[12,44],[27,37],[48,49],[46,49],[24,44],[32,38],[21,49],[13,30]]\\nsolution should be:\\n3, 3, 1 ,1. \\n0: (12, 44) (46, 49) (48, 49)\\n1: (13, 30) (27, 37) (32, 38)\\n2: (21, 49)\\n3: (24, 44)\\n\\nbut reported output is 2, 4, 1, 1.\\nCan someone please explain how this output is coming?\\n"
                    },
                    {
                        "username": "Priyansh1210",
                        "content": "Passing 79/82 test cases. Can someone help me? Explained my reasoning with code comments.\\n\\nFails on the following test case: n=2; meetings=[[43,44],[34,36],[11,47],[1,8],[30,33],[45,48],[23,41],[29,30]])\\nO/P: 0; Expected O/P=1\\n\\n```\\nfrom heapq import heappush, heappop, heapify\\n\\nclass Solution:\\n    def mostBooked(self, N: int, meetings: List[List[int]]) -> int:\\n        meetings = sorted(meetings, key=lambda x: (x[0], x[1]))\\n        M = len(meetings)\\n        \\n        # end_time, room_index\\n        heap = []\\n\\n        counts = {i: 0 for i in range(N)}\\n        maxroom = (None, float(\\'-inf\\'))\\n        minPoppedRI = float(\\'inf\\')\\n        for i in range(M):\\n            start, end = meetings[i]\\n\\n            # et = End time of the next meeting which will be assigned to a room at the\\n            # end of this iteration.\\n            # ri = Index of the room which the current meeting will be assigned to. We\\'ll\\n            # make sure that this is the mimimum indexed room which is available at the \\n            # start of this meeting.\\n            et, ri = None, float(\\'inf\\')\\n\\n            # Free up all rooms which are holding meetings with end time less than the\\n            # start of the current meeting and keep track of the minimum indexed room.\\n            while heap and start > heap[0][0]:\\n                popped_et, popped_ri = heappop(heap)\\n                if popped_ri < ri:\\n                    et, ri = popped_et, popped_ri\\n                minPoppedRI = min(popped_ri, minPoppedRI)\\n\\n            if ri != float(\\'inf\\'):\\n                # If we did manage to free up some rooms, assign the current meeting to \\n                # the room with the minimum index. The current meeting will start and end\\n                # at its original time.\\n                et = end\\n                ri = len(heap) if ri > len(heap) else ri\\n            else:\\n                # If no meeting ends before the start of this one...\\n                if len(heap) < N:\\n                    # If there are some empty rooms, assign this meeting to the lowest\\n                    # indexed empty room. The current meeting will start and end at its\\n                    # original time.\\n                    et, ri = end, min(len(heap), minPoppedRI)\\n                else:\\n                    # If there are no empty rooms at the moment, delay the current meeting\\n                    # till the end of the meeting which is ending the earliest (\"et\") and then\\n                    # schedule the current meeting to that room. Now the current meeting\\n                    # will start at \"et\" and end at \"et + (end - start)\"\\n                    et, ri = heappop(heap)\\n                    et += (end-start)\\n                    minPoppedRI = min(ri, minPoppedRI)\\n                \\n            heappush(heap, (et, ri))\\n            # print(start, end, et, ri, heap)\\n            counts[ri] += 1\\n\\n            if counts[ri] > maxroom[1] or (counts[ri] == maxroom[1] and maxroom[0] is not None and maxroom[0] > ri):\\n                maxroom = (ri, counts[ri])\\n\\n        # print(counts)\\n        return maxroom[0]\\n```"
                    },
                    {
                        "username": "btulsi",
                        "content": "81/82 test cases , anyone know what\\'s wrong?\\n\\n `var mostBooked = function(n, meetings) {\\n\\n    // Sort meetings by start time\\n    meetings.sort((a, b) => a[0] - b[0]);\\n\\n    let busy = [];\\n    let avail = Array.from({length: n}, (_, i) => i);\\n    const count = Array(n).fill(0);\\n\\n    for(let meeting of meetings) {\\n        const [start,end] = meeting;\\n\\n        // Shift all the rooms that are past the current start time\\n        while(busy.length && busy[0][0] <= start){\\n            const [oldEnd, room] = busy.shift();\\n            avail.push(room);\\n            avail.sort((a, b) => a - b); // Ensure available rooms are sorted\\n        }\\n\\n        let room;\\n\\n        if(avail.length) {\\n            room = avail.shift();\\n            busy.push([end,room]);\\n        } else {\\n            // Calculate the new end time\\n            const [time, roomBusy] = busy.shift();\\n            room = roomBusy;\\n            const newEnd = time < start ? end : time + (end - start);\\n            busy.push([newEnd,room]);\\n        }\\n\\n        // Sort busy rooms by their end time\\n        busy.sort((a, b) => a[0] - b[0]);\\n\\n        // Increment the count of meetings held in the room\\n        count[room] += 1;\\n    }\\n\\n    // Determine the room that held the most meetings\\n    let maxCount = 0;\\n    let maxRoom = 0;\\n    for(let i = 0; i < n; i++){\\n        if(count[i] > maxCount){\\n            maxCount = count[i];\\n            maxRoom = i;\\n        }\\n    }\\n\\n    return maxRoom;\\n};\\n`"
                    },
                    {
                        "username": "leogean3",
                        "content": "I really need help for this code. Almost all the test case I\\'ve tried gives the correct answer. But it gets wrong answer when submitting with an long input which it cannot show the complete input. In this case, I am not able to know the exact input array, which gets the wrong output with this code. Could anyone give me a hand? Thanks in advance:) \\nclass Solution {\\npublic int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a, b) -> (Integer.compare(a[0], b[0])));\\n        int[] rooms_count = new int[n];\\n        int[] rooms_end = new int[n];\\n        int max_count = 0;\\n        int max_number = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            rooms_count[i] = 0;\\n            rooms_end[i] = 0;\\n        }\\n        for(int i=0; i<meetings.length; i++)\\n        {\\n            int flag = 0;\\n            int min_finish = Integer.MAX_VALUE;\\n            int pre_min = Integer.MAX_VALUE;\\n            int finish_room = 0;\\n            for(int j=0; j<n; j++)\\n            {\\n                if (rooms_end[j] <= meetings[i][0])\\n                {\\n                    rooms_count[j] ++;\\n                    rooms_end[j] = meetings[i][1];\\n                    flag= 1;\\n                    break;\\n                }\\n                pre_min = min_finish;\\n                min_finish = Math.min(min_finish, rooms_end[j]);\\n                if (pre_min != min_finish)\\n                    finish_room = j;\\n            }\\n            if (flag == 0)\\n            {\\n                rooms_count[finish_room] ++;\\n                rooms_end[finish_room] += meetings[i][1] - meetings[i][0];\\n            }\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            int pre_max = max_count;\\n            max_count = Math.max(max_count, rooms_count[i]);\\n            if (pre_max != max_count)\\n                max_number = i;\\n        }\\n        return max_number;\\n    }\\n}"
                    },
                    {
                        "username": "josec1003",
                        "content": "Not sure what is wrong with my answer if someone can help:\\n `n=2`\\n`meetings=[[10,11],[2,10],[1,17],[9,13],[18,20]]`\\n`leet code answer=1`\\nMy answer is room zero though:\\n1. Meeting [10,11] goes in unoccupied room 0\\n2. Meeting [2,10] goes into room 0 since it will finish before [10,11]\\n3. Meeting [1,17] goes into room 1 since it is unoccupied\\n4. Meeting [9,13] goes into room 0 as [11, 15]\\n5. Meeting [18,20] goes into room 0\\n`rooms=[[[2, 10], [10, 11], [11, 15], [18, 20]], [[1, 17]]]`\\nWhere the answer is `0` not `1`"
                    },
                    {
                        "username": "roger-song",
                        "content": "you need to read the condition carefully. \\n\\nthe description says \\ncond1, Each meeting will take place in the unused room with the lowest number.\\ncond2. When a room becomes unused, meetings that have an earlier original start time should be given the room.\\n\\nSo your thought is totally wrong. I think it is better to think in sorted array by start-i(start-i is unique) .\\n[[10,11],[2,10],[1,17],[9,13],[18,20]] => [[1,17],[2,10],[9,13],[10,11],[18,20]]\\n\\n[1,17] -> room 0 (cond1. lowest number)\\n[2,10] -> room 1 \\n[9,13] -> room 1 [10,14] (cause room 0 is not finish) (cond2 earlier original start time)\\n[10,11] -> room 1 [14,15] (cause room 0 is not finish)\\n[18,20] -> room 0 (cond1. lowest number)\\n\\nso answer is 1"
                    },
                    {
                        "username": "josec1003",
                        "content": "Actually even if we do that you will get the following still making room 0 have the most meetings:\n`rooms=[[[10, 11], [11, 15], [18, 20]], [[2, 10], [10, 26]]]`\n1. Meeting [10,11] goes in unoccupied room 0\n2. Meeting [2,10] goes in unoccupied room 1\n3. Meeting [1,17]  goes into room 1 as [10, 26] since it frees up first\n4. Meeting [9,13] goes into room 0 as [11, 15] since it frees up next\n5. Meeting [18,20] goes into room 0"
                    },
                    {
                        "username": "josec1003",
                        "content": "I guess it wants all rooms to be filled before you evaluate if a lower room has availability in the time slot?"
                    },
                    {
                        "username": "navneetjain",
                        "content": "2 of the test cases are failing. can someone point me if they see any mistake. Any help is appreciated :)\\n\\n```\\nfrom queue import PriorityQueue\\n\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        vacantRoomPQ = PriorityQueue()\\n        occupiedRoomPQ = PriorityQueue()\\n\\n        for roomNo in range(n):\\n            vacantRoomPQ.put((roomNo,0))\\n        \\n        currentTime = 0\\n        currentMax = 0\\n        currentMaxRoom = -1\\n        meetingRoomId = -1\\n        meetings.sort()\\n\\n        for meeting in meetings:\\n            currentTime = meeting[0]\\n\\n            #if there are no vacant rooms, then fast forward to the end time of meeting with \\n            #least end time (if it\\'s greater than current meeting\\'s start time)\\n            if vacantRoomPQ.empty() and currentTime < occupiedRoomPQ.queue[0][0]:\\n                currentTime = occupiedRoomPQ.queue[0][0]\\n                \\n            #pop from used meeting rooms till current time is greater than equal to meeting\\'s time\\n            while not occupiedRoomPQ.empty() and occupiedRoomPQ.queue[0][0] <= currentTime:\\n                (endTime, meetingRoomId, meetingCount) = occupiedRoomPQ.get()\\n                vacantRoomPQ.put((meetingRoomId, meetingCount))\\n            \\n            (meetingRoomId, meetingCount) = vacantRoomPQ.get()\\n\\n            #Condition to update currentmax and current room with max meetings\\n            if currentMax < meetingCount+1 or (currentMax == meetingCount+1 and currentMaxRoom > meetingRoomId):\\n                currentMax = meetingCount+1\\n                currentMaxRoom = meetingRoomId\\n                \\n            #increment duration, meeting count and put in occupied rooms\\n            occupiedRoomPQ.put((currentTime+meeting[1]-meeting[0], meetingRoomId, meetingCount+1))\\n        \\n        return currentMaxRoom\\n\\n\\n```\\n"
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "[@Heman962](/Heman962) Thanks man. This was very insightful"
                    },
                    {
                        "username": "Heman962",
                        "content": "[@navneetjain](/navneetjain) can you share full code? i want to see how you are taking values if there are free items."
                    },
                    {
                        "username": "navneetjain",
                        "content": "Hey [@Heman962](/Heman962),\\n\\nThanks for the reply\\n\\nI actually did take that into consideration\\n\\n```\\n\\n            #if there are no vacant rooms, then fast forward to the end time of meeting with \\n            #least end time (if it\\'s greater than current meeting\\'s start time)\\n            if vacantRoomPQ.empty() and currentTime < occupiedRoomPQ.queue[0][0]:\\n                currentTime = occupiedRoomPQ.queue[0][0]\\n                \\n            #pop from used meeting rooms till current time is greater than equal to meeting\\'s time\\n            while not occupiedRoomPQ.empty() and occupiedRoomPQ.queue[0][0] <= currentTime:\\n                (endTime, meetingRoomId, meetingCount) = occupiedRoomPQ.get()\\n                vacantRoomPQ.put((meetingRoomId, meetingCount))\\n            \\n```\\n"
                    },
                    {
                        "username": "Heman962",
                        "content": "hey [@navneetjain](/navneetjain),\\n\\nFaced the same issue,\\n\\nyou might have missed the case where there are no free rooms, and there are mutliple busy rooms with same avaialble time. now how do we know which one to take ? the one with min room no right ? so we need to move all the busy rooms with samve ending time back to freerooms priority queue. and then pop the top one.\\n\\nnow it gets tricky here  to choose the ending time for new meeting\\ncase1:\\nTop Free room with next avaialbiity time <= new meetingtime( good use case)\\ncase2\\nTop Free room with next avaialbiity time > new meetingtime( good use case) // this room came as result of moving from busy rooms when ending times match and there were no free rooms.\\n\\nso choosing the eindig time for new meeting would be\\n Math.max(nextAvaialbleTime, newMtngStrtTime) +duration\\n\\nhere: \\nhttps://leetcode.com/problems/meeting-rooms-iii/submissions/\\n"
                    },
                    {
                        "username": "roger-song",
                        "content": "I don\\'t know why my logic is wrong. Anybody can help me?\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        unordered_map<int, vector<vector<int>>> rooms(n + 1);\\n        sort(meetings.begin(), meetings.end());\\n\\n        for (auto meeting : meetings) {\\n            bool meeting_allocated = false;\\n            int min_finish_time = 500005;\\n            int min_finish_time_idx = -1;\\n\\n            for (int idx = 0; idx < n; idx++) {\\n                if (rooms[idx].size() == 0 || rooms[idx].back()[1] <= meeting[0]) {\\n                    rooms[idx].push_back(meeting);\\n                    meeting_allocated = true;\\n                    break;\\n                }\\n                else {\\n                    if (rooms[idx].back()[1] < min_finish_time) { // update which rooms last meeting end time is most ealry. \\n                        min_finish_time = rooms[idx].back()[1];\\n                        min_finish_time_idx = idx;\\n                    }\\n                }\\n            }\\n\\n            if (meeting_allocated == false) {\\n                vector<int> tmp = { min_finish_time, meeting[1] + (min_finish_time - meeting[0]) };\\n                rooms[min_finish_time_idx].push_back(tmp);\\n            }\\n        }\\n\\n        int max_meeting_room = 0;\\n        int max_meeting_cnt = -1;\\n        for (int idx = 0; idx < n; idx++) {\\n            if ((int)rooms[idx].size() > max_meeting_cnt) {\\n                max_meeting_cnt = rooms[idx].size();\\n                max_meeting_room = idx;\\n            }\\n        }\\n\\n        return max_meeting_room;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "roger-song",
                        "content": "I found it myself. \\n\\nI missed data type of the data structure. The number can be maxed to 5e9, so the data type could be long. thx"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This question really grinds my gears , I know it has something to do with heap but maintaining the heap of current meeting is something i was not able to figure out at all"
                    }
                ]
            },
            {
                "id": 1969234,
                "content": [
                    {
                        "username": "strangeranda",
                        "content": "Calculate Delay for only `current` meeting, not everything, "
                    },
                    {
                        "username": "superZero",
                        "content": "But why? All meetings that have start time less than the end time of the busy room should be delayed isn\\'t it? In reality, all such meetings run late until there are rooms available. "
                    },
                    {
                        "username": "strangeranda",
                        "content": "EDIT: This is solved. the idea here is calculate the delay just for one meeting, not anything else. \n\nCan someone help me here? [[39,49],[28,39],[9,29],[10,36],[22,47],[2,3],[4,49],[46,50],[45,50],[17,33]]\nThe expected is 0, but Im getting 1. \n\nIm storing a list of (end Time, room), and the last iteration is [(62,2), (66,0)], and the last meeting is [62,66] (taking the delay into consideration). \n\nIm under the impression that we free the room 2 and assign the meeting to room1 since it is lower index of two rooms available. which makes the count as {0:3, 1:4, 2:2}\n\nand it returns 1 as the most frequently used room. but the answer expected is 0."
                    },
                    {
                        "username": "naveenky",
                        "content": "Failing for this case: n = 4, meeting = [[12,44],[27,37],[48,49],[46,49],[24,44],[32,38],[21,49],[13,30]]\\nsolution should be:\\n3, 3, 1 ,1. \\n0: (12, 44) (46, 49) (48, 49)\\n1: (13, 30) (27, 37) (32, 38)\\n2: (21, 49)\\n3: (24, 44)\\n\\nbut reported output is 2, 4, 1, 1.\\nCan someone please explain how this output is coming?\\n"
                    },
                    {
                        "username": "Priyansh1210",
                        "content": "Passing 79/82 test cases. Can someone help me? Explained my reasoning with code comments.\\n\\nFails on the following test case: n=2; meetings=[[43,44],[34,36],[11,47],[1,8],[30,33],[45,48],[23,41],[29,30]])\\nO/P: 0; Expected O/P=1\\n\\n```\\nfrom heapq import heappush, heappop, heapify\\n\\nclass Solution:\\n    def mostBooked(self, N: int, meetings: List[List[int]]) -> int:\\n        meetings = sorted(meetings, key=lambda x: (x[0], x[1]))\\n        M = len(meetings)\\n        \\n        # end_time, room_index\\n        heap = []\\n\\n        counts = {i: 0 for i in range(N)}\\n        maxroom = (None, float(\\'-inf\\'))\\n        minPoppedRI = float(\\'inf\\')\\n        for i in range(M):\\n            start, end = meetings[i]\\n\\n            # et = End time of the next meeting which will be assigned to a room at the\\n            # end of this iteration.\\n            # ri = Index of the room which the current meeting will be assigned to. We\\'ll\\n            # make sure that this is the mimimum indexed room which is available at the \\n            # start of this meeting.\\n            et, ri = None, float(\\'inf\\')\\n\\n            # Free up all rooms which are holding meetings with end time less than the\\n            # start of the current meeting and keep track of the minimum indexed room.\\n            while heap and start > heap[0][0]:\\n                popped_et, popped_ri = heappop(heap)\\n                if popped_ri < ri:\\n                    et, ri = popped_et, popped_ri\\n                minPoppedRI = min(popped_ri, minPoppedRI)\\n\\n            if ri != float(\\'inf\\'):\\n                # If we did manage to free up some rooms, assign the current meeting to \\n                # the room with the minimum index. The current meeting will start and end\\n                # at its original time.\\n                et = end\\n                ri = len(heap) if ri > len(heap) else ri\\n            else:\\n                # If no meeting ends before the start of this one...\\n                if len(heap) < N:\\n                    # If there are some empty rooms, assign this meeting to the lowest\\n                    # indexed empty room. The current meeting will start and end at its\\n                    # original time.\\n                    et, ri = end, min(len(heap), minPoppedRI)\\n                else:\\n                    # If there are no empty rooms at the moment, delay the current meeting\\n                    # till the end of the meeting which is ending the earliest (\"et\") and then\\n                    # schedule the current meeting to that room. Now the current meeting\\n                    # will start at \"et\" and end at \"et + (end - start)\"\\n                    et, ri = heappop(heap)\\n                    et += (end-start)\\n                    minPoppedRI = min(ri, minPoppedRI)\\n                \\n            heappush(heap, (et, ri))\\n            # print(start, end, et, ri, heap)\\n            counts[ri] += 1\\n\\n            if counts[ri] > maxroom[1] or (counts[ri] == maxroom[1] and maxroom[0] is not None and maxroom[0] > ri):\\n                maxroom = (ri, counts[ri])\\n\\n        # print(counts)\\n        return maxroom[0]\\n```"
                    },
                    {
                        "username": "btulsi",
                        "content": "81/82 test cases , anyone know what\\'s wrong?\\n\\n `var mostBooked = function(n, meetings) {\\n\\n    // Sort meetings by start time\\n    meetings.sort((a, b) => a[0] - b[0]);\\n\\n    let busy = [];\\n    let avail = Array.from({length: n}, (_, i) => i);\\n    const count = Array(n).fill(0);\\n\\n    for(let meeting of meetings) {\\n        const [start,end] = meeting;\\n\\n        // Shift all the rooms that are past the current start time\\n        while(busy.length && busy[0][0] <= start){\\n            const [oldEnd, room] = busy.shift();\\n            avail.push(room);\\n            avail.sort((a, b) => a - b); // Ensure available rooms are sorted\\n        }\\n\\n        let room;\\n\\n        if(avail.length) {\\n            room = avail.shift();\\n            busy.push([end,room]);\\n        } else {\\n            // Calculate the new end time\\n            const [time, roomBusy] = busy.shift();\\n            room = roomBusy;\\n            const newEnd = time < start ? end : time + (end - start);\\n            busy.push([newEnd,room]);\\n        }\\n\\n        // Sort busy rooms by their end time\\n        busy.sort((a, b) => a[0] - b[0]);\\n\\n        // Increment the count of meetings held in the room\\n        count[room] += 1;\\n    }\\n\\n    // Determine the room that held the most meetings\\n    let maxCount = 0;\\n    let maxRoom = 0;\\n    for(let i = 0; i < n; i++){\\n        if(count[i] > maxCount){\\n            maxCount = count[i];\\n            maxRoom = i;\\n        }\\n    }\\n\\n    return maxRoom;\\n};\\n`"
                    },
                    {
                        "username": "leogean3",
                        "content": "I really need help for this code. Almost all the test case I\\'ve tried gives the correct answer. But it gets wrong answer when submitting with an long input which it cannot show the complete input. In this case, I am not able to know the exact input array, which gets the wrong output with this code. Could anyone give me a hand? Thanks in advance:) \\nclass Solution {\\npublic int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a, b) -> (Integer.compare(a[0], b[0])));\\n        int[] rooms_count = new int[n];\\n        int[] rooms_end = new int[n];\\n        int max_count = 0;\\n        int max_number = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            rooms_count[i] = 0;\\n            rooms_end[i] = 0;\\n        }\\n        for(int i=0; i<meetings.length; i++)\\n        {\\n            int flag = 0;\\n            int min_finish = Integer.MAX_VALUE;\\n            int pre_min = Integer.MAX_VALUE;\\n            int finish_room = 0;\\n            for(int j=0; j<n; j++)\\n            {\\n                if (rooms_end[j] <= meetings[i][0])\\n                {\\n                    rooms_count[j] ++;\\n                    rooms_end[j] = meetings[i][1];\\n                    flag= 1;\\n                    break;\\n                }\\n                pre_min = min_finish;\\n                min_finish = Math.min(min_finish, rooms_end[j]);\\n                if (pre_min != min_finish)\\n                    finish_room = j;\\n            }\\n            if (flag == 0)\\n            {\\n                rooms_count[finish_room] ++;\\n                rooms_end[finish_room] += meetings[i][1] - meetings[i][0];\\n            }\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            int pre_max = max_count;\\n            max_count = Math.max(max_count, rooms_count[i]);\\n            if (pre_max != max_count)\\n                max_number = i;\\n        }\\n        return max_number;\\n    }\\n}"
                    },
                    {
                        "username": "josec1003",
                        "content": "Not sure what is wrong with my answer if someone can help:\\n `n=2`\\n`meetings=[[10,11],[2,10],[1,17],[9,13],[18,20]]`\\n`leet code answer=1`\\nMy answer is room zero though:\\n1. Meeting [10,11] goes in unoccupied room 0\\n2. Meeting [2,10] goes into room 0 since it will finish before [10,11]\\n3. Meeting [1,17] goes into room 1 since it is unoccupied\\n4. Meeting [9,13] goes into room 0 as [11, 15]\\n5. Meeting [18,20] goes into room 0\\n`rooms=[[[2, 10], [10, 11], [11, 15], [18, 20]], [[1, 17]]]`\\nWhere the answer is `0` not `1`"
                    },
                    {
                        "username": "roger-song",
                        "content": "you need to read the condition carefully. \\n\\nthe description says \\ncond1, Each meeting will take place in the unused room with the lowest number.\\ncond2. When a room becomes unused, meetings that have an earlier original start time should be given the room.\\n\\nSo your thought is totally wrong. I think it is better to think in sorted array by start-i(start-i is unique) .\\n[[10,11],[2,10],[1,17],[9,13],[18,20]] => [[1,17],[2,10],[9,13],[10,11],[18,20]]\\n\\n[1,17] -> room 0 (cond1. lowest number)\\n[2,10] -> room 1 \\n[9,13] -> room 1 [10,14] (cause room 0 is not finish) (cond2 earlier original start time)\\n[10,11] -> room 1 [14,15] (cause room 0 is not finish)\\n[18,20] -> room 0 (cond1. lowest number)\\n\\nso answer is 1"
                    },
                    {
                        "username": "josec1003",
                        "content": "Actually even if we do that you will get the following still making room 0 have the most meetings:\n`rooms=[[[10, 11], [11, 15], [18, 20]], [[2, 10], [10, 26]]]`\n1. Meeting [10,11] goes in unoccupied room 0\n2. Meeting [2,10] goes in unoccupied room 1\n3. Meeting [1,17]  goes into room 1 as [10, 26] since it frees up first\n4. Meeting [9,13] goes into room 0 as [11, 15] since it frees up next\n5. Meeting [18,20] goes into room 0"
                    },
                    {
                        "username": "josec1003",
                        "content": "I guess it wants all rooms to be filled before you evaluate if a lower room has availability in the time slot?"
                    },
                    {
                        "username": "navneetjain",
                        "content": "2 of the test cases are failing. can someone point me if they see any mistake. Any help is appreciated :)\\n\\n```\\nfrom queue import PriorityQueue\\n\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        vacantRoomPQ = PriorityQueue()\\n        occupiedRoomPQ = PriorityQueue()\\n\\n        for roomNo in range(n):\\n            vacantRoomPQ.put((roomNo,0))\\n        \\n        currentTime = 0\\n        currentMax = 0\\n        currentMaxRoom = -1\\n        meetingRoomId = -1\\n        meetings.sort()\\n\\n        for meeting in meetings:\\n            currentTime = meeting[0]\\n\\n            #if there are no vacant rooms, then fast forward to the end time of meeting with \\n            #least end time (if it\\'s greater than current meeting\\'s start time)\\n            if vacantRoomPQ.empty() and currentTime < occupiedRoomPQ.queue[0][0]:\\n                currentTime = occupiedRoomPQ.queue[0][0]\\n                \\n            #pop from used meeting rooms till current time is greater than equal to meeting\\'s time\\n            while not occupiedRoomPQ.empty() and occupiedRoomPQ.queue[0][0] <= currentTime:\\n                (endTime, meetingRoomId, meetingCount) = occupiedRoomPQ.get()\\n                vacantRoomPQ.put((meetingRoomId, meetingCount))\\n            \\n            (meetingRoomId, meetingCount) = vacantRoomPQ.get()\\n\\n            #Condition to update currentmax and current room with max meetings\\n            if currentMax < meetingCount+1 or (currentMax == meetingCount+1 and currentMaxRoom > meetingRoomId):\\n                currentMax = meetingCount+1\\n                currentMaxRoom = meetingRoomId\\n                \\n            #increment duration, meeting count and put in occupied rooms\\n            occupiedRoomPQ.put((currentTime+meeting[1]-meeting[0], meetingRoomId, meetingCount+1))\\n        \\n        return currentMaxRoom\\n\\n\\n```\\n"
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "[@Heman962](/Heman962) Thanks man. This was very insightful"
                    },
                    {
                        "username": "Heman962",
                        "content": "[@navneetjain](/navneetjain) can you share full code? i want to see how you are taking values if there are free items."
                    },
                    {
                        "username": "navneetjain",
                        "content": "Hey [@Heman962](/Heman962),\\n\\nThanks for the reply\\n\\nI actually did take that into consideration\\n\\n```\\n\\n            #if there are no vacant rooms, then fast forward to the end time of meeting with \\n            #least end time (if it\\'s greater than current meeting\\'s start time)\\n            if vacantRoomPQ.empty() and currentTime < occupiedRoomPQ.queue[0][0]:\\n                currentTime = occupiedRoomPQ.queue[0][0]\\n                \\n            #pop from used meeting rooms till current time is greater than equal to meeting\\'s time\\n            while not occupiedRoomPQ.empty() and occupiedRoomPQ.queue[0][0] <= currentTime:\\n                (endTime, meetingRoomId, meetingCount) = occupiedRoomPQ.get()\\n                vacantRoomPQ.put((meetingRoomId, meetingCount))\\n            \\n```\\n"
                    },
                    {
                        "username": "Heman962",
                        "content": "hey [@navneetjain](/navneetjain),\\n\\nFaced the same issue,\\n\\nyou might have missed the case where there are no free rooms, and there are mutliple busy rooms with same avaialble time. now how do we know which one to take ? the one with min room no right ? so we need to move all the busy rooms with samve ending time back to freerooms priority queue. and then pop the top one.\\n\\nnow it gets tricky here  to choose the ending time for new meeting\\ncase1:\\nTop Free room with next avaialbiity time <= new meetingtime( good use case)\\ncase2\\nTop Free room with next avaialbiity time > new meetingtime( good use case) // this room came as result of moving from busy rooms when ending times match and there were no free rooms.\\n\\nso choosing the eindig time for new meeting would be\\n Math.max(nextAvaialbleTime, newMtngStrtTime) +duration\\n\\nhere: \\nhttps://leetcode.com/problems/meeting-rooms-iii/submissions/\\n"
                    },
                    {
                        "username": "roger-song",
                        "content": "I don\\'t know why my logic is wrong. Anybody can help me?\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        unordered_map<int, vector<vector<int>>> rooms(n + 1);\\n        sort(meetings.begin(), meetings.end());\\n\\n        for (auto meeting : meetings) {\\n            bool meeting_allocated = false;\\n            int min_finish_time = 500005;\\n            int min_finish_time_idx = -1;\\n\\n            for (int idx = 0; idx < n; idx++) {\\n                if (rooms[idx].size() == 0 || rooms[idx].back()[1] <= meeting[0]) {\\n                    rooms[idx].push_back(meeting);\\n                    meeting_allocated = true;\\n                    break;\\n                }\\n                else {\\n                    if (rooms[idx].back()[1] < min_finish_time) { // update which rooms last meeting end time is most ealry. \\n                        min_finish_time = rooms[idx].back()[1];\\n                        min_finish_time_idx = idx;\\n                    }\\n                }\\n            }\\n\\n            if (meeting_allocated == false) {\\n                vector<int> tmp = { min_finish_time, meeting[1] + (min_finish_time - meeting[0]) };\\n                rooms[min_finish_time_idx].push_back(tmp);\\n            }\\n        }\\n\\n        int max_meeting_room = 0;\\n        int max_meeting_cnt = -1;\\n        for (int idx = 0; idx < n; idx++) {\\n            if ((int)rooms[idx].size() > max_meeting_cnt) {\\n                max_meeting_cnt = rooms[idx].size();\\n                max_meeting_room = idx;\\n            }\\n        }\\n\\n        return max_meeting_room;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "roger-song",
                        "content": "I found it myself. \\n\\nI missed data type of the data structure. The number can be maxed to 5e9, so the data type could be long. thx"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This question really grinds my gears , I know it has something to do with heap but maintaining the heap of current meeting is something i was not able to figure out at all"
                    }
                ]
            },
            {
                "id": 1747709,
                "content": [
                    {
                        "username": "strangeranda",
                        "content": "Calculate Delay for only `current` meeting, not everything, "
                    },
                    {
                        "username": "superZero",
                        "content": "But why? All meetings that have start time less than the end time of the busy room should be delayed isn\\'t it? In reality, all such meetings run late until there are rooms available. "
                    },
                    {
                        "username": "strangeranda",
                        "content": "EDIT: This is solved. the idea here is calculate the delay just for one meeting, not anything else. \n\nCan someone help me here? [[39,49],[28,39],[9,29],[10,36],[22,47],[2,3],[4,49],[46,50],[45,50],[17,33]]\nThe expected is 0, but Im getting 1. \n\nIm storing a list of (end Time, room), and the last iteration is [(62,2), (66,0)], and the last meeting is [62,66] (taking the delay into consideration). \n\nIm under the impression that we free the room 2 and assign the meeting to room1 since it is lower index of two rooms available. which makes the count as {0:3, 1:4, 2:2}\n\nand it returns 1 as the most frequently used room. but the answer expected is 0."
                    },
                    {
                        "username": "naveenky",
                        "content": "Failing for this case: n = 4, meeting = [[12,44],[27,37],[48,49],[46,49],[24,44],[32,38],[21,49],[13,30]]\\nsolution should be:\\n3, 3, 1 ,1. \\n0: (12, 44) (46, 49) (48, 49)\\n1: (13, 30) (27, 37) (32, 38)\\n2: (21, 49)\\n3: (24, 44)\\n\\nbut reported output is 2, 4, 1, 1.\\nCan someone please explain how this output is coming?\\n"
                    },
                    {
                        "username": "Priyansh1210",
                        "content": "Passing 79/82 test cases. Can someone help me? Explained my reasoning with code comments.\\n\\nFails on the following test case: n=2; meetings=[[43,44],[34,36],[11,47],[1,8],[30,33],[45,48],[23,41],[29,30]])\\nO/P: 0; Expected O/P=1\\n\\n```\\nfrom heapq import heappush, heappop, heapify\\n\\nclass Solution:\\n    def mostBooked(self, N: int, meetings: List[List[int]]) -> int:\\n        meetings = sorted(meetings, key=lambda x: (x[0], x[1]))\\n        M = len(meetings)\\n        \\n        # end_time, room_index\\n        heap = []\\n\\n        counts = {i: 0 for i in range(N)}\\n        maxroom = (None, float(\\'-inf\\'))\\n        minPoppedRI = float(\\'inf\\')\\n        for i in range(M):\\n            start, end = meetings[i]\\n\\n            # et = End time of the next meeting which will be assigned to a room at the\\n            # end of this iteration.\\n            # ri = Index of the room which the current meeting will be assigned to. We\\'ll\\n            # make sure that this is the mimimum indexed room which is available at the \\n            # start of this meeting.\\n            et, ri = None, float(\\'inf\\')\\n\\n            # Free up all rooms which are holding meetings with end time less than the\\n            # start of the current meeting and keep track of the minimum indexed room.\\n            while heap and start > heap[0][0]:\\n                popped_et, popped_ri = heappop(heap)\\n                if popped_ri < ri:\\n                    et, ri = popped_et, popped_ri\\n                minPoppedRI = min(popped_ri, minPoppedRI)\\n\\n            if ri != float(\\'inf\\'):\\n                # If we did manage to free up some rooms, assign the current meeting to \\n                # the room with the minimum index. The current meeting will start and end\\n                # at its original time.\\n                et = end\\n                ri = len(heap) if ri > len(heap) else ri\\n            else:\\n                # If no meeting ends before the start of this one...\\n                if len(heap) < N:\\n                    # If there are some empty rooms, assign this meeting to the lowest\\n                    # indexed empty room. The current meeting will start and end at its\\n                    # original time.\\n                    et, ri = end, min(len(heap), minPoppedRI)\\n                else:\\n                    # If there are no empty rooms at the moment, delay the current meeting\\n                    # till the end of the meeting which is ending the earliest (\"et\") and then\\n                    # schedule the current meeting to that room. Now the current meeting\\n                    # will start at \"et\" and end at \"et + (end - start)\"\\n                    et, ri = heappop(heap)\\n                    et += (end-start)\\n                    minPoppedRI = min(ri, minPoppedRI)\\n                \\n            heappush(heap, (et, ri))\\n            # print(start, end, et, ri, heap)\\n            counts[ri] += 1\\n\\n            if counts[ri] > maxroom[1] or (counts[ri] == maxroom[1] and maxroom[0] is not None and maxroom[0] > ri):\\n                maxroom = (ri, counts[ri])\\n\\n        # print(counts)\\n        return maxroom[0]\\n```"
                    },
                    {
                        "username": "btulsi",
                        "content": "81/82 test cases , anyone know what\\'s wrong?\\n\\n `var mostBooked = function(n, meetings) {\\n\\n    // Sort meetings by start time\\n    meetings.sort((a, b) => a[0] - b[0]);\\n\\n    let busy = [];\\n    let avail = Array.from({length: n}, (_, i) => i);\\n    const count = Array(n).fill(0);\\n\\n    for(let meeting of meetings) {\\n        const [start,end] = meeting;\\n\\n        // Shift all the rooms that are past the current start time\\n        while(busy.length && busy[0][0] <= start){\\n            const [oldEnd, room] = busy.shift();\\n            avail.push(room);\\n            avail.sort((a, b) => a - b); // Ensure available rooms are sorted\\n        }\\n\\n        let room;\\n\\n        if(avail.length) {\\n            room = avail.shift();\\n            busy.push([end,room]);\\n        } else {\\n            // Calculate the new end time\\n            const [time, roomBusy] = busy.shift();\\n            room = roomBusy;\\n            const newEnd = time < start ? end : time + (end - start);\\n            busy.push([newEnd,room]);\\n        }\\n\\n        // Sort busy rooms by their end time\\n        busy.sort((a, b) => a[0] - b[0]);\\n\\n        // Increment the count of meetings held in the room\\n        count[room] += 1;\\n    }\\n\\n    // Determine the room that held the most meetings\\n    let maxCount = 0;\\n    let maxRoom = 0;\\n    for(let i = 0; i < n; i++){\\n        if(count[i] > maxCount){\\n            maxCount = count[i];\\n            maxRoom = i;\\n        }\\n    }\\n\\n    return maxRoom;\\n};\\n`"
                    },
                    {
                        "username": "leogean3",
                        "content": "I really need help for this code. Almost all the test case I\\'ve tried gives the correct answer. But it gets wrong answer when submitting with an long input which it cannot show the complete input. In this case, I am not able to know the exact input array, which gets the wrong output with this code. Could anyone give me a hand? Thanks in advance:) \\nclass Solution {\\npublic int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a, b) -> (Integer.compare(a[0], b[0])));\\n        int[] rooms_count = new int[n];\\n        int[] rooms_end = new int[n];\\n        int max_count = 0;\\n        int max_number = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            rooms_count[i] = 0;\\n            rooms_end[i] = 0;\\n        }\\n        for(int i=0; i<meetings.length; i++)\\n        {\\n            int flag = 0;\\n            int min_finish = Integer.MAX_VALUE;\\n            int pre_min = Integer.MAX_VALUE;\\n            int finish_room = 0;\\n            for(int j=0; j<n; j++)\\n            {\\n                if (rooms_end[j] <= meetings[i][0])\\n                {\\n                    rooms_count[j] ++;\\n                    rooms_end[j] = meetings[i][1];\\n                    flag= 1;\\n                    break;\\n                }\\n                pre_min = min_finish;\\n                min_finish = Math.min(min_finish, rooms_end[j]);\\n                if (pre_min != min_finish)\\n                    finish_room = j;\\n            }\\n            if (flag == 0)\\n            {\\n                rooms_count[finish_room] ++;\\n                rooms_end[finish_room] += meetings[i][1] - meetings[i][0];\\n            }\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            int pre_max = max_count;\\n            max_count = Math.max(max_count, rooms_count[i]);\\n            if (pre_max != max_count)\\n                max_number = i;\\n        }\\n        return max_number;\\n    }\\n}"
                    },
                    {
                        "username": "josec1003",
                        "content": "Not sure what is wrong with my answer if someone can help:\\n `n=2`\\n`meetings=[[10,11],[2,10],[1,17],[9,13],[18,20]]`\\n`leet code answer=1`\\nMy answer is room zero though:\\n1. Meeting [10,11] goes in unoccupied room 0\\n2. Meeting [2,10] goes into room 0 since it will finish before [10,11]\\n3. Meeting [1,17] goes into room 1 since it is unoccupied\\n4. Meeting [9,13] goes into room 0 as [11, 15]\\n5. Meeting [18,20] goes into room 0\\n`rooms=[[[2, 10], [10, 11], [11, 15], [18, 20]], [[1, 17]]]`\\nWhere the answer is `0` not `1`"
                    },
                    {
                        "username": "roger-song",
                        "content": "you need to read the condition carefully. \\n\\nthe description says \\ncond1, Each meeting will take place in the unused room with the lowest number.\\ncond2. When a room becomes unused, meetings that have an earlier original start time should be given the room.\\n\\nSo your thought is totally wrong. I think it is better to think in sorted array by start-i(start-i is unique) .\\n[[10,11],[2,10],[1,17],[9,13],[18,20]] => [[1,17],[2,10],[9,13],[10,11],[18,20]]\\n\\n[1,17] -> room 0 (cond1. lowest number)\\n[2,10] -> room 1 \\n[9,13] -> room 1 [10,14] (cause room 0 is not finish) (cond2 earlier original start time)\\n[10,11] -> room 1 [14,15] (cause room 0 is not finish)\\n[18,20] -> room 0 (cond1. lowest number)\\n\\nso answer is 1"
                    },
                    {
                        "username": "josec1003",
                        "content": "Actually even if we do that you will get the following still making room 0 have the most meetings:\n`rooms=[[[10, 11], [11, 15], [18, 20]], [[2, 10], [10, 26]]]`\n1. Meeting [10,11] goes in unoccupied room 0\n2. Meeting [2,10] goes in unoccupied room 1\n3. Meeting [1,17]  goes into room 1 as [10, 26] since it frees up first\n4. Meeting [9,13] goes into room 0 as [11, 15] since it frees up next\n5. Meeting [18,20] goes into room 0"
                    },
                    {
                        "username": "josec1003",
                        "content": "I guess it wants all rooms to be filled before you evaluate if a lower room has availability in the time slot?"
                    },
                    {
                        "username": "navneetjain",
                        "content": "2 of the test cases are failing. can someone point me if they see any mistake. Any help is appreciated :)\\n\\n```\\nfrom queue import PriorityQueue\\n\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        vacantRoomPQ = PriorityQueue()\\n        occupiedRoomPQ = PriorityQueue()\\n\\n        for roomNo in range(n):\\n            vacantRoomPQ.put((roomNo,0))\\n        \\n        currentTime = 0\\n        currentMax = 0\\n        currentMaxRoom = -1\\n        meetingRoomId = -1\\n        meetings.sort()\\n\\n        for meeting in meetings:\\n            currentTime = meeting[0]\\n\\n            #if there are no vacant rooms, then fast forward to the end time of meeting with \\n            #least end time (if it\\'s greater than current meeting\\'s start time)\\n            if vacantRoomPQ.empty() and currentTime < occupiedRoomPQ.queue[0][0]:\\n                currentTime = occupiedRoomPQ.queue[0][0]\\n                \\n            #pop from used meeting rooms till current time is greater than equal to meeting\\'s time\\n            while not occupiedRoomPQ.empty() and occupiedRoomPQ.queue[0][0] <= currentTime:\\n                (endTime, meetingRoomId, meetingCount) = occupiedRoomPQ.get()\\n                vacantRoomPQ.put((meetingRoomId, meetingCount))\\n            \\n            (meetingRoomId, meetingCount) = vacantRoomPQ.get()\\n\\n            #Condition to update currentmax and current room with max meetings\\n            if currentMax < meetingCount+1 or (currentMax == meetingCount+1 and currentMaxRoom > meetingRoomId):\\n                currentMax = meetingCount+1\\n                currentMaxRoom = meetingRoomId\\n                \\n            #increment duration, meeting count and put in occupied rooms\\n            occupiedRoomPQ.put((currentTime+meeting[1]-meeting[0], meetingRoomId, meetingCount+1))\\n        \\n        return currentMaxRoom\\n\\n\\n```\\n"
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "[@Heman962](/Heman962) Thanks man. This was very insightful"
                    },
                    {
                        "username": "Heman962",
                        "content": "[@navneetjain](/navneetjain) can you share full code? i want to see how you are taking values if there are free items."
                    },
                    {
                        "username": "navneetjain",
                        "content": "Hey [@Heman962](/Heman962),\\n\\nThanks for the reply\\n\\nI actually did take that into consideration\\n\\n```\\n\\n            #if there are no vacant rooms, then fast forward to the end time of meeting with \\n            #least end time (if it\\'s greater than current meeting\\'s start time)\\n            if vacantRoomPQ.empty() and currentTime < occupiedRoomPQ.queue[0][0]:\\n                currentTime = occupiedRoomPQ.queue[0][0]\\n                \\n            #pop from used meeting rooms till current time is greater than equal to meeting\\'s time\\n            while not occupiedRoomPQ.empty() and occupiedRoomPQ.queue[0][0] <= currentTime:\\n                (endTime, meetingRoomId, meetingCount) = occupiedRoomPQ.get()\\n                vacantRoomPQ.put((meetingRoomId, meetingCount))\\n            \\n```\\n"
                    },
                    {
                        "username": "Heman962",
                        "content": "hey [@navneetjain](/navneetjain),\\n\\nFaced the same issue,\\n\\nyou might have missed the case where there are no free rooms, and there are mutliple busy rooms with same avaialble time. now how do we know which one to take ? the one with min room no right ? so we need to move all the busy rooms with samve ending time back to freerooms priority queue. and then pop the top one.\\n\\nnow it gets tricky here  to choose the ending time for new meeting\\ncase1:\\nTop Free room with next avaialbiity time <= new meetingtime( good use case)\\ncase2\\nTop Free room with next avaialbiity time > new meetingtime( good use case) // this room came as result of moving from busy rooms when ending times match and there were no free rooms.\\n\\nso choosing the eindig time for new meeting would be\\n Math.max(nextAvaialbleTime, newMtngStrtTime) +duration\\n\\nhere: \\nhttps://leetcode.com/problems/meeting-rooms-iii/submissions/\\n"
                    },
                    {
                        "username": "roger-song",
                        "content": "I don\\'t know why my logic is wrong. Anybody can help me?\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        unordered_map<int, vector<vector<int>>> rooms(n + 1);\\n        sort(meetings.begin(), meetings.end());\\n\\n        for (auto meeting : meetings) {\\n            bool meeting_allocated = false;\\n            int min_finish_time = 500005;\\n            int min_finish_time_idx = -1;\\n\\n            for (int idx = 0; idx < n; idx++) {\\n                if (rooms[idx].size() == 0 || rooms[idx].back()[1] <= meeting[0]) {\\n                    rooms[idx].push_back(meeting);\\n                    meeting_allocated = true;\\n                    break;\\n                }\\n                else {\\n                    if (rooms[idx].back()[1] < min_finish_time) { // update which rooms last meeting end time is most ealry. \\n                        min_finish_time = rooms[idx].back()[1];\\n                        min_finish_time_idx = idx;\\n                    }\\n                }\\n            }\\n\\n            if (meeting_allocated == false) {\\n                vector<int> tmp = { min_finish_time, meeting[1] + (min_finish_time - meeting[0]) };\\n                rooms[min_finish_time_idx].push_back(tmp);\\n            }\\n        }\\n\\n        int max_meeting_room = 0;\\n        int max_meeting_cnt = -1;\\n        for (int idx = 0; idx < n; idx++) {\\n            if ((int)rooms[idx].size() > max_meeting_cnt) {\\n                max_meeting_cnt = rooms[idx].size();\\n                max_meeting_room = idx;\\n            }\\n        }\\n\\n        return max_meeting_room;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "roger-song",
                        "content": "I found it myself. \\n\\nI missed data type of the data structure. The number can be maxed to 5e9, so the data type could be long. thx"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This question really grinds my gears , I know it has something to do with heap but maintaining the heap of current meeting is something i was not able to figure out at all"
                    }
                ]
            },
            {
                "id": 1730492,
                "content": [
                    {
                        "username": "strangeranda",
                        "content": "Calculate Delay for only `current` meeting, not everything, "
                    },
                    {
                        "username": "superZero",
                        "content": "But why? All meetings that have start time less than the end time of the busy room should be delayed isn\\'t it? In reality, all such meetings run late until there are rooms available. "
                    },
                    {
                        "username": "strangeranda",
                        "content": "EDIT: This is solved. the idea here is calculate the delay just for one meeting, not anything else. \n\nCan someone help me here? [[39,49],[28,39],[9,29],[10,36],[22,47],[2,3],[4,49],[46,50],[45,50],[17,33]]\nThe expected is 0, but Im getting 1. \n\nIm storing a list of (end Time, room), and the last iteration is [(62,2), (66,0)], and the last meeting is [62,66] (taking the delay into consideration). \n\nIm under the impression that we free the room 2 and assign the meeting to room1 since it is lower index of two rooms available. which makes the count as {0:3, 1:4, 2:2}\n\nand it returns 1 as the most frequently used room. but the answer expected is 0."
                    },
                    {
                        "username": "naveenky",
                        "content": "Failing for this case: n = 4, meeting = [[12,44],[27,37],[48,49],[46,49],[24,44],[32,38],[21,49],[13,30]]\\nsolution should be:\\n3, 3, 1 ,1. \\n0: (12, 44) (46, 49) (48, 49)\\n1: (13, 30) (27, 37) (32, 38)\\n2: (21, 49)\\n3: (24, 44)\\n\\nbut reported output is 2, 4, 1, 1.\\nCan someone please explain how this output is coming?\\n"
                    },
                    {
                        "username": "Priyansh1210",
                        "content": "Passing 79/82 test cases. Can someone help me? Explained my reasoning with code comments.\\n\\nFails on the following test case: n=2; meetings=[[43,44],[34,36],[11,47],[1,8],[30,33],[45,48],[23,41],[29,30]])\\nO/P: 0; Expected O/P=1\\n\\n```\\nfrom heapq import heappush, heappop, heapify\\n\\nclass Solution:\\n    def mostBooked(self, N: int, meetings: List[List[int]]) -> int:\\n        meetings = sorted(meetings, key=lambda x: (x[0], x[1]))\\n        M = len(meetings)\\n        \\n        # end_time, room_index\\n        heap = []\\n\\n        counts = {i: 0 for i in range(N)}\\n        maxroom = (None, float(\\'-inf\\'))\\n        minPoppedRI = float(\\'inf\\')\\n        for i in range(M):\\n            start, end = meetings[i]\\n\\n            # et = End time of the next meeting which will be assigned to a room at the\\n            # end of this iteration.\\n            # ri = Index of the room which the current meeting will be assigned to. We\\'ll\\n            # make sure that this is the mimimum indexed room which is available at the \\n            # start of this meeting.\\n            et, ri = None, float(\\'inf\\')\\n\\n            # Free up all rooms which are holding meetings with end time less than the\\n            # start of the current meeting and keep track of the minimum indexed room.\\n            while heap and start > heap[0][0]:\\n                popped_et, popped_ri = heappop(heap)\\n                if popped_ri < ri:\\n                    et, ri = popped_et, popped_ri\\n                minPoppedRI = min(popped_ri, minPoppedRI)\\n\\n            if ri != float(\\'inf\\'):\\n                # If we did manage to free up some rooms, assign the current meeting to \\n                # the room with the minimum index. The current meeting will start and end\\n                # at its original time.\\n                et = end\\n                ri = len(heap) if ri > len(heap) else ri\\n            else:\\n                # If no meeting ends before the start of this one...\\n                if len(heap) < N:\\n                    # If there are some empty rooms, assign this meeting to the lowest\\n                    # indexed empty room. The current meeting will start and end at its\\n                    # original time.\\n                    et, ri = end, min(len(heap), minPoppedRI)\\n                else:\\n                    # If there are no empty rooms at the moment, delay the current meeting\\n                    # till the end of the meeting which is ending the earliest (\"et\") and then\\n                    # schedule the current meeting to that room. Now the current meeting\\n                    # will start at \"et\" and end at \"et + (end - start)\"\\n                    et, ri = heappop(heap)\\n                    et += (end-start)\\n                    minPoppedRI = min(ri, minPoppedRI)\\n                \\n            heappush(heap, (et, ri))\\n            # print(start, end, et, ri, heap)\\n            counts[ri] += 1\\n\\n            if counts[ri] > maxroom[1] or (counts[ri] == maxroom[1] and maxroom[0] is not None and maxroom[0] > ri):\\n                maxroom = (ri, counts[ri])\\n\\n        # print(counts)\\n        return maxroom[0]\\n```"
                    },
                    {
                        "username": "btulsi",
                        "content": "81/82 test cases , anyone know what\\'s wrong?\\n\\n `var mostBooked = function(n, meetings) {\\n\\n    // Sort meetings by start time\\n    meetings.sort((a, b) => a[0] - b[0]);\\n\\n    let busy = [];\\n    let avail = Array.from({length: n}, (_, i) => i);\\n    const count = Array(n).fill(0);\\n\\n    for(let meeting of meetings) {\\n        const [start,end] = meeting;\\n\\n        // Shift all the rooms that are past the current start time\\n        while(busy.length && busy[0][0] <= start){\\n            const [oldEnd, room] = busy.shift();\\n            avail.push(room);\\n            avail.sort((a, b) => a - b); // Ensure available rooms are sorted\\n        }\\n\\n        let room;\\n\\n        if(avail.length) {\\n            room = avail.shift();\\n            busy.push([end,room]);\\n        } else {\\n            // Calculate the new end time\\n            const [time, roomBusy] = busy.shift();\\n            room = roomBusy;\\n            const newEnd = time < start ? end : time + (end - start);\\n            busy.push([newEnd,room]);\\n        }\\n\\n        // Sort busy rooms by their end time\\n        busy.sort((a, b) => a[0] - b[0]);\\n\\n        // Increment the count of meetings held in the room\\n        count[room] += 1;\\n    }\\n\\n    // Determine the room that held the most meetings\\n    let maxCount = 0;\\n    let maxRoom = 0;\\n    for(let i = 0; i < n; i++){\\n        if(count[i] > maxCount){\\n            maxCount = count[i];\\n            maxRoom = i;\\n        }\\n    }\\n\\n    return maxRoom;\\n};\\n`"
                    },
                    {
                        "username": "leogean3",
                        "content": "I really need help for this code. Almost all the test case I\\'ve tried gives the correct answer. But it gets wrong answer when submitting with an long input which it cannot show the complete input. In this case, I am not able to know the exact input array, which gets the wrong output with this code. Could anyone give me a hand? Thanks in advance:) \\nclass Solution {\\npublic int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a, b) -> (Integer.compare(a[0], b[0])));\\n        int[] rooms_count = new int[n];\\n        int[] rooms_end = new int[n];\\n        int max_count = 0;\\n        int max_number = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            rooms_count[i] = 0;\\n            rooms_end[i] = 0;\\n        }\\n        for(int i=0; i<meetings.length; i++)\\n        {\\n            int flag = 0;\\n            int min_finish = Integer.MAX_VALUE;\\n            int pre_min = Integer.MAX_VALUE;\\n            int finish_room = 0;\\n            for(int j=0; j<n; j++)\\n            {\\n                if (rooms_end[j] <= meetings[i][0])\\n                {\\n                    rooms_count[j] ++;\\n                    rooms_end[j] = meetings[i][1];\\n                    flag= 1;\\n                    break;\\n                }\\n                pre_min = min_finish;\\n                min_finish = Math.min(min_finish, rooms_end[j]);\\n                if (pre_min != min_finish)\\n                    finish_room = j;\\n            }\\n            if (flag == 0)\\n            {\\n                rooms_count[finish_room] ++;\\n                rooms_end[finish_room] += meetings[i][1] - meetings[i][0];\\n            }\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            int pre_max = max_count;\\n            max_count = Math.max(max_count, rooms_count[i]);\\n            if (pre_max != max_count)\\n                max_number = i;\\n        }\\n        return max_number;\\n    }\\n}"
                    },
                    {
                        "username": "josec1003",
                        "content": "Not sure what is wrong with my answer if someone can help:\\n `n=2`\\n`meetings=[[10,11],[2,10],[1,17],[9,13],[18,20]]`\\n`leet code answer=1`\\nMy answer is room zero though:\\n1. Meeting [10,11] goes in unoccupied room 0\\n2. Meeting [2,10] goes into room 0 since it will finish before [10,11]\\n3. Meeting [1,17] goes into room 1 since it is unoccupied\\n4. Meeting [9,13] goes into room 0 as [11, 15]\\n5. Meeting [18,20] goes into room 0\\n`rooms=[[[2, 10], [10, 11], [11, 15], [18, 20]], [[1, 17]]]`\\nWhere the answer is `0` not `1`"
                    },
                    {
                        "username": "roger-song",
                        "content": "you need to read the condition carefully. \\n\\nthe description says \\ncond1, Each meeting will take place in the unused room with the lowest number.\\ncond2. When a room becomes unused, meetings that have an earlier original start time should be given the room.\\n\\nSo your thought is totally wrong. I think it is better to think in sorted array by start-i(start-i is unique) .\\n[[10,11],[2,10],[1,17],[9,13],[18,20]] => [[1,17],[2,10],[9,13],[10,11],[18,20]]\\n\\n[1,17] -> room 0 (cond1. lowest number)\\n[2,10] -> room 1 \\n[9,13] -> room 1 [10,14] (cause room 0 is not finish) (cond2 earlier original start time)\\n[10,11] -> room 1 [14,15] (cause room 0 is not finish)\\n[18,20] -> room 0 (cond1. lowest number)\\n\\nso answer is 1"
                    },
                    {
                        "username": "josec1003",
                        "content": "Actually even if we do that you will get the following still making room 0 have the most meetings:\n`rooms=[[[10, 11], [11, 15], [18, 20]], [[2, 10], [10, 26]]]`\n1. Meeting [10,11] goes in unoccupied room 0\n2. Meeting [2,10] goes in unoccupied room 1\n3. Meeting [1,17]  goes into room 1 as [10, 26] since it frees up first\n4. Meeting [9,13] goes into room 0 as [11, 15] since it frees up next\n5. Meeting [18,20] goes into room 0"
                    },
                    {
                        "username": "josec1003",
                        "content": "I guess it wants all rooms to be filled before you evaluate if a lower room has availability in the time slot?"
                    },
                    {
                        "username": "navneetjain",
                        "content": "2 of the test cases are failing. can someone point me if they see any mistake. Any help is appreciated :)\\n\\n```\\nfrom queue import PriorityQueue\\n\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        vacantRoomPQ = PriorityQueue()\\n        occupiedRoomPQ = PriorityQueue()\\n\\n        for roomNo in range(n):\\n            vacantRoomPQ.put((roomNo,0))\\n        \\n        currentTime = 0\\n        currentMax = 0\\n        currentMaxRoom = -1\\n        meetingRoomId = -1\\n        meetings.sort()\\n\\n        for meeting in meetings:\\n            currentTime = meeting[0]\\n\\n            #if there are no vacant rooms, then fast forward to the end time of meeting with \\n            #least end time (if it\\'s greater than current meeting\\'s start time)\\n            if vacantRoomPQ.empty() and currentTime < occupiedRoomPQ.queue[0][0]:\\n                currentTime = occupiedRoomPQ.queue[0][0]\\n                \\n            #pop from used meeting rooms till current time is greater than equal to meeting\\'s time\\n            while not occupiedRoomPQ.empty() and occupiedRoomPQ.queue[0][0] <= currentTime:\\n                (endTime, meetingRoomId, meetingCount) = occupiedRoomPQ.get()\\n                vacantRoomPQ.put((meetingRoomId, meetingCount))\\n            \\n            (meetingRoomId, meetingCount) = vacantRoomPQ.get()\\n\\n            #Condition to update currentmax and current room with max meetings\\n            if currentMax < meetingCount+1 or (currentMax == meetingCount+1 and currentMaxRoom > meetingRoomId):\\n                currentMax = meetingCount+1\\n                currentMaxRoom = meetingRoomId\\n                \\n            #increment duration, meeting count and put in occupied rooms\\n            occupiedRoomPQ.put((currentTime+meeting[1]-meeting[0], meetingRoomId, meetingCount+1))\\n        \\n        return currentMaxRoom\\n\\n\\n```\\n"
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "[@Heman962](/Heman962) Thanks man. This was very insightful"
                    },
                    {
                        "username": "Heman962",
                        "content": "[@navneetjain](/navneetjain) can you share full code? i want to see how you are taking values if there are free items."
                    },
                    {
                        "username": "navneetjain",
                        "content": "Hey [@Heman962](/Heman962),\\n\\nThanks for the reply\\n\\nI actually did take that into consideration\\n\\n```\\n\\n            #if there are no vacant rooms, then fast forward to the end time of meeting with \\n            #least end time (if it\\'s greater than current meeting\\'s start time)\\n            if vacantRoomPQ.empty() and currentTime < occupiedRoomPQ.queue[0][0]:\\n                currentTime = occupiedRoomPQ.queue[0][0]\\n                \\n            #pop from used meeting rooms till current time is greater than equal to meeting\\'s time\\n            while not occupiedRoomPQ.empty() and occupiedRoomPQ.queue[0][0] <= currentTime:\\n                (endTime, meetingRoomId, meetingCount) = occupiedRoomPQ.get()\\n                vacantRoomPQ.put((meetingRoomId, meetingCount))\\n            \\n```\\n"
                    },
                    {
                        "username": "Heman962",
                        "content": "hey [@navneetjain](/navneetjain),\\n\\nFaced the same issue,\\n\\nyou might have missed the case where there are no free rooms, and there are mutliple busy rooms with same avaialble time. now how do we know which one to take ? the one with min room no right ? so we need to move all the busy rooms with samve ending time back to freerooms priority queue. and then pop the top one.\\n\\nnow it gets tricky here  to choose the ending time for new meeting\\ncase1:\\nTop Free room with next avaialbiity time <= new meetingtime( good use case)\\ncase2\\nTop Free room with next avaialbiity time > new meetingtime( good use case) // this room came as result of moving from busy rooms when ending times match and there were no free rooms.\\n\\nso choosing the eindig time for new meeting would be\\n Math.max(nextAvaialbleTime, newMtngStrtTime) +duration\\n\\nhere: \\nhttps://leetcode.com/problems/meeting-rooms-iii/submissions/\\n"
                    },
                    {
                        "username": "roger-song",
                        "content": "I don\\'t know why my logic is wrong. Anybody can help me?\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        unordered_map<int, vector<vector<int>>> rooms(n + 1);\\n        sort(meetings.begin(), meetings.end());\\n\\n        for (auto meeting : meetings) {\\n            bool meeting_allocated = false;\\n            int min_finish_time = 500005;\\n            int min_finish_time_idx = -1;\\n\\n            for (int idx = 0; idx < n; idx++) {\\n                if (rooms[idx].size() == 0 || rooms[idx].back()[1] <= meeting[0]) {\\n                    rooms[idx].push_back(meeting);\\n                    meeting_allocated = true;\\n                    break;\\n                }\\n                else {\\n                    if (rooms[idx].back()[1] < min_finish_time) { // update which rooms last meeting end time is most ealry. \\n                        min_finish_time = rooms[idx].back()[1];\\n                        min_finish_time_idx = idx;\\n                    }\\n                }\\n            }\\n\\n            if (meeting_allocated == false) {\\n                vector<int> tmp = { min_finish_time, meeting[1] + (min_finish_time - meeting[0]) };\\n                rooms[min_finish_time_idx].push_back(tmp);\\n            }\\n        }\\n\\n        int max_meeting_room = 0;\\n        int max_meeting_cnt = -1;\\n        for (int idx = 0; idx < n; idx++) {\\n            if ((int)rooms[idx].size() > max_meeting_cnt) {\\n                max_meeting_cnt = rooms[idx].size();\\n                max_meeting_room = idx;\\n            }\\n        }\\n\\n        return max_meeting_room;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "roger-song",
                        "content": "I found it myself. \\n\\nI missed data type of the data structure. The number can be maxed to 5e9, so the data type could be long. thx"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This question really grinds my gears , I know it has something to do with heap but maintaining the heap of current meeting is something i was not able to figure out at all"
                    }
                ]
            },
            {
                "id": 1726600,
                "content": [
                    {
                        "username": "strangeranda",
                        "content": "Calculate Delay for only `current` meeting, not everything, "
                    },
                    {
                        "username": "superZero",
                        "content": "But why? All meetings that have start time less than the end time of the busy room should be delayed isn\\'t it? In reality, all such meetings run late until there are rooms available. "
                    },
                    {
                        "username": "strangeranda",
                        "content": "EDIT: This is solved. the idea here is calculate the delay just for one meeting, not anything else. \n\nCan someone help me here? [[39,49],[28,39],[9,29],[10,36],[22,47],[2,3],[4,49],[46,50],[45,50],[17,33]]\nThe expected is 0, but Im getting 1. \n\nIm storing a list of (end Time, room), and the last iteration is [(62,2), (66,0)], and the last meeting is [62,66] (taking the delay into consideration). \n\nIm under the impression that we free the room 2 and assign the meeting to room1 since it is lower index of two rooms available. which makes the count as {0:3, 1:4, 2:2}\n\nand it returns 1 as the most frequently used room. but the answer expected is 0."
                    },
                    {
                        "username": "naveenky",
                        "content": "Failing for this case: n = 4, meeting = [[12,44],[27,37],[48,49],[46,49],[24,44],[32,38],[21,49],[13,30]]\\nsolution should be:\\n3, 3, 1 ,1. \\n0: (12, 44) (46, 49) (48, 49)\\n1: (13, 30) (27, 37) (32, 38)\\n2: (21, 49)\\n3: (24, 44)\\n\\nbut reported output is 2, 4, 1, 1.\\nCan someone please explain how this output is coming?\\n"
                    },
                    {
                        "username": "Priyansh1210",
                        "content": "Passing 79/82 test cases. Can someone help me? Explained my reasoning with code comments.\\n\\nFails on the following test case: n=2; meetings=[[43,44],[34,36],[11,47],[1,8],[30,33],[45,48],[23,41],[29,30]])\\nO/P: 0; Expected O/P=1\\n\\n```\\nfrom heapq import heappush, heappop, heapify\\n\\nclass Solution:\\n    def mostBooked(self, N: int, meetings: List[List[int]]) -> int:\\n        meetings = sorted(meetings, key=lambda x: (x[0], x[1]))\\n        M = len(meetings)\\n        \\n        # end_time, room_index\\n        heap = []\\n\\n        counts = {i: 0 for i in range(N)}\\n        maxroom = (None, float(\\'-inf\\'))\\n        minPoppedRI = float(\\'inf\\')\\n        for i in range(M):\\n            start, end = meetings[i]\\n\\n            # et = End time of the next meeting which will be assigned to a room at the\\n            # end of this iteration.\\n            # ri = Index of the room which the current meeting will be assigned to. We\\'ll\\n            # make sure that this is the mimimum indexed room which is available at the \\n            # start of this meeting.\\n            et, ri = None, float(\\'inf\\')\\n\\n            # Free up all rooms which are holding meetings with end time less than the\\n            # start of the current meeting and keep track of the minimum indexed room.\\n            while heap and start > heap[0][0]:\\n                popped_et, popped_ri = heappop(heap)\\n                if popped_ri < ri:\\n                    et, ri = popped_et, popped_ri\\n                minPoppedRI = min(popped_ri, minPoppedRI)\\n\\n            if ri != float(\\'inf\\'):\\n                # If we did manage to free up some rooms, assign the current meeting to \\n                # the room with the minimum index. The current meeting will start and end\\n                # at its original time.\\n                et = end\\n                ri = len(heap) if ri > len(heap) else ri\\n            else:\\n                # If no meeting ends before the start of this one...\\n                if len(heap) < N:\\n                    # If there are some empty rooms, assign this meeting to the lowest\\n                    # indexed empty room. The current meeting will start and end at its\\n                    # original time.\\n                    et, ri = end, min(len(heap), minPoppedRI)\\n                else:\\n                    # If there are no empty rooms at the moment, delay the current meeting\\n                    # till the end of the meeting which is ending the earliest (\"et\") and then\\n                    # schedule the current meeting to that room. Now the current meeting\\n                    # will start at \"et\" and end at \"et + (end - start)\"\\n                    et, ri = heappop(heap)\\n                    et += (end-start)\\n                    minPoppedRI = min(ri, minPoppedRI)\\n                \\n            heappush(heap, (et, ri))\\n            # print(start, end, et, ri, heap)\\n            counts[ri] += 1\\n\\n            if counts[ri] > maxroom[1] or (counts[ri] == maxroom[1] and maxroom[0] is not None and maxroom[0] > ri):\\n                maxroom = (ri, counts[ri])\\n\\n        # print(counts)\\n        return maxroom[0]\\n```"
                    },
                    {
                        "username": "btulsi",
                        "content": "81/82 test cases , anyone know what\\'s wrong?\\n\\n `var mostBooked = function(n, meetings) {\\n\\n    // Sort meetings by start time\\n    meetings.sort((a, b) => a[0] - b[0]);\\n\\n    let busy = [];\\n    let avail = Array.from({length: n}, (_, i) => i);\\n    const count = Array(n).fill(0);\\n\\n    for(let meeting of meetings) {\\n        const [start,end] = meeting;\\n\\n        // Shift all the rooms that are past the current start time\\n        while(busy.length && busy[0][0] <= start){\\n            const [oldEnd, room] = busy.shift();\\n            avail.push(room);\\n            avail.sort((a, b) => a - b); // Ensure available rooms are sorted\\n        }\\n\\n        let room;\\n\\n        if(avail.length) {\\n            room = avail.shift();\\n            busy.push([end,room]);\\n        } else {\\n            // Calculate the new end time\\n            const [time, roomBusy] = busy.shift();\\n            room = roomBusy;\\n            const newEnd = time < start ? end : time + (end - start);\\n            busy.push([newEnd,room]);\\n        }\\n\\n        // Sort busy rooms by their end time\\n        busy.sort((a, b) => a[0] - b[0]);\\n\\n        // Increment the count of meetings held in the room\\n        count[room] += 1;\\n    }\\n\\n    // Determine the room that held the most meetings\\n    let maxCount = 0;\\n    let maxRoom = 0;\\n    for(let i = 0; i < n; i++){\\n        if(count[i] > maxCount){\\n            maxCount = count[i];\\n            maxRoom = i;\\n        }\\n    }\\n\\n    return maxRoom;\\n};\\n`"
                    },
                    {
                        "username": "leogean3",
                        "content": "I really need help for this code. Almost all the test case I\\'ve tried gives the correct answer. But it gets wrong answer when submitting with an long input which it cannot show the complete input. In this case, I am not able to know the exact input array, which gets the wrong output with this code. Could anyone give me a hand? Thanks in advance:) \\nclass Solution {\\npublic int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a, b) -> (Integer.compare(a[0], b[0])));\\n        int[] rooms_count = new int[n];\\n        int[] rooms_end = new int[n];\\n        int max_count = 0;\\n        int max_number = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            rooms_count[i] = 0;\\n            rooms_end[i] = 0;\\n        }\\n        for(int i=0; i<meetings.length; i++)\\n        {\\n            int flag = 0;\\n            int min_finish = Integer.MAX_VALUE;\\n            int pre_min = Integer.MAX_VALUE;\\n            int finish_room = 0;\\n            for(int j=0; j<n; j++)\\n            {\\n                if (rooms_end[j] <= meetings[i][0])\\n                {\\n                    rooms_count[j] ++;\\n                    rooms_end[j] = meetings[i][1];\\n                    flag= 1;\\n                    break;\\n                }\\n                pre_min = min_finish;\\n                min_finish = Math.min(min_finish, rooms_end[j]);\\n                if (pre_min != min_finish)\\n                    finish_room = j;\\n            }\\n            if (flag == 0)\\n            {\\n                rooms_count[finish_room] ++;\\n                rooms_end[finish_room] += meetings[i][1] - meetings[i][0];\\n            }\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            int pre_max = max_count;\\n            max_count = Math.max(max_count, rooms_count[i]);\\n            if (pre_max != max_count)\\n                max_number = i;\\n        }\\n        return max_number;\\n    }\\n}"
                    },
                    {
                        "username": "josec1003",
                        "content": "Not sure what is wrong with my answer if someone can help:\\n `n=2`\\n`meetings=[[10,11],[2,10],[1,17],[9,13],[18,20]]`\\n`leet code answer=1`\\nMy answer is room zero though:\\n1. Meeting [10,11] goes in unoccupied room 0\\n2. Meeting [2,10] goes into room 0 since it will finish before [10,11]\\n3. Meeting [1,17] goes into room 1 since it is unoccupied\\n4. Meeting [9,13] goes into room 0 as [11, 15]\\n5. Meeting [18,20] goes into room 0\\n`rooms=[[[2, 10], [10, 11], [11, 15], [18, 20]], [[1, 17]]]`\\nWhere the answer is `0` not `1`"
                    },
                    {
                        "username": "roger-song",
                        "content": "you need to read the condition carefully. \\n\\nthe description says \\ncond1, Each meeting will take place in the unused room with the lowest number.\\ncond2. When a room becomes unused, meetings that have an earlier original start time should be given the room.\\n\\nSo your thought is totally wrong. I think it is better to think in sorted array by start-i(start-i is unique) .\\n[[10,11],[2,10],[1,17],[9,13],[18,20]] => [[1,17],[2,10],[9,13],[10,11],[18,20]]\\n\\n[1,17] -> room 0 (cond1. lowest number)\\n[2,10] -> room 1 \\n[9,13] -> room 1 [10,14] (cause room 0 is not finish) (cond2 earlier original start time)\\n[10,11] -> room 1 [14,15] (cause room 0 is not finish)\\n[18,20] -> room 0 (cond1. lowest number)\\n\\nso answer is 1"
                    },
                    {
                        "username": "josec1003",
                        "content": "Actually even if we do that you will get the following still making room 0 have the most meetings:\n`rooms=[[[10, 11], [11, 15], [18, 20]], [[2, 10], [10, 26]]]`\n1. Meeting [10,11] goes in unoccupied room 0\n2. Meeting [2,10] goes in unoccupied room 1\n3. Meeting [1,17]  goes into room 1 as [10, 26] since it frees up first\n4. Meeting [9,13] goes into room 0 as [11, 15] since it frees up next\n5. Meeting [18,20] goes into room 0"
                    },
                    {
                        "username": "josec1003",
                        "content": "I guess it wants all rooms to be filled before you evaluate if a lower room has availability in the time slot?"
                    },
                    {
                        "username": "navneetjain",
                        "content": "2 of the test cases are failing. can someone point me if they see any mistake. Any help is appreciated :)\\n\\n```\\nfrom queue import PriorityQueue\\n\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        vacantRoomPQ = PriorityQueue()\\n        occupiedRoomPQ = PriorityQueue()\\n\\n        for roomNo in range(n):\\n            vacantRoomPQ.put((roomNo,0))\\n        \\n        currentTime = 0\\n        currentMax = 0\\n        currentMaxRoom = -1\\n        meetingRoomId = -1\\n        meetings.sort()\\n\\n        for meeting in meetings:\\n            currentTime = meeting[0]\\n\\n            #if there are no vacant rooms, then fast forward to the end time of meeting with \\n            #least end time (if it\\'s greater than current meeting\\'s start time)\\n            if vacantRoomPQ.empty() and currentTime < occupiedRoomPQ.queue[0][0]:\\n                currentTime = occupiedRoomPQ.queue[0][0]\\n                \\n            #pop from used meeting rooms till current time is greater than equal to meeting\\'s time\\n            while not occupiedRoomPQ.empty() and occupiedRoomPQ.queue[0][0] <= currentTime:\\n                (endTime, meetingRoomId, meetingCount) = occupiedRoomPQ.get()\\n                vacantRoomPQ.put((meetingRoomId, meetingCount))\\n            \\n            (meetingRoomId, meetingCount) = vacantRoomPQ.get()\\n\\n            #Condition to update currentmax and current room with max meetings\\n            if currentMax < meetingCount+1 or (currentMax == meetingCount+1 and currentMaxRoom > meetingRoomId):\\n                currentMax = meetingCount+1\\n                currentMaxRoom = meetingRoomId\\n                \\n            #increment duration, meeting count and put in occupied rooms\\n            occupiedRoomPQ.put((currentTime+meeting[1]-meeting[0], meetingRoomId, meetingCount+1))\\n        \\n        return currentMaxRoom\\n\\n\\n```\\n"
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "[@Heman962](/Heman962) Thanks man. This was very insightful"
                    },
                    {
                        "username": "Heman962",
                        "content": "[@navneetjain](/navneetjain) can you share full code? i want to see how you are taking values if there are free items."
                    },
                    {
                        "username": "navneetjain",
                        "content": "Hey [@Heman962](/Heman962),\\n\\nThanks for the reply\\n\\nI actually did take that into consideration\\n\\n```\\n\\n            #if there are no vacant rooms, then fast forward to the end time of meeting with \\n            #least end time (if it\\'s greater than current meeting\\'s start time)\\n            if vacantRoomPQ.empty() and currentTime < occupiedRoomPQ.queue[0][0]:\\n                currentTime = occupiedRoomPQ.queue[0][0]\\n                \\n            #pop from used meeting rooms till current time is greater than equal to meeting\\'s time\\n            while not occupiedRoomPQ.empty() and occupiedRoomPQ.queue[0][0] <= currentTime:\\n                (endTime, meetingRoomId, meetingCount) = occupiedRoomPQ.get()\\n                vacantRoomPQ.put((meetingRoomId, meetingCount))\\n            \\n```\\n"
                    },
                    {
                        "username": "Heman962",
                        "content": "hey [@navneetjain](/navneetjain),\\n\\nFaced the same issue,\\n\\nyou might have missed the case where there are no free rooms, and there are mutliple busy rooms with same avaialble time. now how do we know which one to take ? the one with min room no right ? so we need to move all the busy rooms with samve ending time back to freerooms priority queue. and then pop the top one.\\n\\nnow it gets tricky here  to choose the ending time for new meeting\\ncase1:\\nTop Free room with next avaialbiity time <= new meetingtime( good use case)\\ncase2\\nTop Free room with next avaialbiity time > new meetingtime( good use case) // this room came as result of moving from busy rooms when ending times match and there were no free rooms.\\n\\nso choosing the eindig time for new meeting would be\\n Math.max(nextAvaialbleTime, newMtngStrtTime) +duration\\n\\nhere: \\nhttps://leetcode.com/problems/meeting-rooms-iii/submissions/\\n"
                    },
                    {
                        "username": "roger-song",
                        "content": "I don\\'t know why my logic is wrong. Anybody can help me?\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        unordered_map<int, vector<vector<int>>> rooms(n + 1);\\n        sort(meetings.begin(), meetings.end());\\n\\n        for (auto meeting : meetings) {\\n            bool meeting_allocated = false;\\n            int min_finish_time = 500005;\\n            int min_finish_time_idx = -1;\\n\\n            for (int idx = 0; idx < n; idx++) {\\n                if (rooms[idx].size() == 0 || rooms[idx].back()[1] <= meeting[0]) {\\n                    rooms[idx].push_back(meeting);\\n                    meeting_allocated = true;\\n                    break;\\n                }\\n                else {\\n                    if (rooms[idx].back()[1] < min_finish_time) { // update which rooms last meeting end time is most ealry. \\n                        min_finish_time = rooms[idx].back()[1];\\n                        min_finish_time_idx = idx;\\n                    }\\n                }\\n            }\\n\\n            if (meeting_allocated == false) {\\n                vector<int> tmp = { min_finish_time, meeting[1] + (min_finish_time - meeting[0]) };\\n                rooms[min_finish_time_idx].push_back(tmp);\\n            }\\n        }\\n\\n        int max_meeting_room = 0;\\n        int max_meeting_cnt = -1;\\n        for (int idx = 0; idx < n; idx++) {\\n            if ((int)rooms[idx].size() > max_meeting_cnt) {\\n                max_meeting_cnt = rooms[idx].size();\\n                max_meeting_room = idx;\\n            }\\n        }\\n\\n        return max_meeting_room;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "roger-song",
                        "content": "I found it myself. \\n\\nI missed data type of the data structure. The number can be maxed to 5e9, so the data type could be long. thx"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This question really grinds my gears , I know it has something to do with heap but maintaining the heap of current meeting is something i was not able to figure out at all"
                    }
                ]
            },
            {
                "id": 1706847,
                "content": [
                    {
                        "username": "strangeranda",
                        "content": "Calculate Delay for only `current` meeting, not everything, "
                    },
                    {
                        "username": "superZero",
                        "content": "But why? All meetings that have start time less than the end time of the busy room should be delayed isn\\'t it? In reality, all such meetings run late until there are rooms available. "
                    },
                    {
                        "username": "strangeranda",
                        "content": "EDIT: This is solved. the idea here is calculate the delay just for one meeting, not anything else. \n\nCan someone help me here? [[39,49],[28,39],[9,29],[10,36],[22,47],[2,3],[4,49],[46,50],[45,50],[17,33]]\nThe expected is 0, but Im getting 1. \n\nIm storing a list of (end Time, room), and the last iteration is [(62,2), (66,0)], and the last meeting is [62,66] (taking the delay into consideration). \n\nIm under the impression that we free the room 2 and assign the meeting to room1 since it is lower index of two rooms available. which makes the count as {0:3, 1:4, 2:2}\n\nand it returns 1 as the most frequently used room. but the answer expected is 0."
                    },
                    {
                        "username": "naveenky",
                        "content": "Failing for this case: n = 4, meeting = [[12,44],[27,37],[48,49],[46,49],[24,44],[32,38],[21,49],[13,30]]\\nsolution should be:\\n3, 3, 1 ,1. \\n0: (12, 44) (46, 49) (48, 49)\\n1: (13, 30) (27, 37) (32, 38)\\n2: (21, 49)\\n3: (24, 44)\\n\\nbut reported output is 2, 4, 1, 1.\\nCan someone please explain how this output is coming?\\n"
                    },
                    {
                        "username": "Priyansh1210",
                        "content": "Passing 79/82 test cases. Can someone help me? Explained my reasoning with code comments.\\n\\nFails on the following test case: n=2; meetings=[[43,44],[34,36],[11,47],[1,8],[30,33],[45,48],[23,41],[29,30]])\\nO/P: 0; Expected O/P=1\\n\\n```\\nfrom heapq import heappush, heappop, heapify\\n\\nclass Solution:\\n    def mostBooked(self, N: int, meetings: List[List[int]]) -> int:\\n        meetings = sorted(meetings, key=lambda x: (x[0], x[1]))\\n        M = len(meetings)\\n        \\n        # end_time, room_index\\n        heap = []\\n\\n        counts = {i: 0 for i in range(N)}\\n        maxroom = (None, float(\\'-inf\\'))\\n        minPoppedRI = float(\\'inf\\')\\n        for i in range(M):\\n            start, end = meetings[i]\\n\\n            # et = End time of the next meeting which will be assigned to a room at the\\n            # end of this iteration.\\n            # ri = Index of the room which the current meeting will be assigned to. We\\'ll\\n            # make sure that this is the mimimum indexed room which is available at the \\n            # start of this meeting.\\n            et, ri = None, float(\\'inf\\')\\n\\n            # Free up all rooms which are holding meetings with end time less than the\\n            # start of the current meeting and keep track of the minimum indexed room.\\n            while heap and start > heap[0][0]:\\n                popped_et, popped_ri = heappop(heap)\\n                if popped_ri < ri:\\n                    et, ri = popped_et, popped_ri\\n                minPoppedRI = min(popped_ri, minPoppedRI)\\n\\n            if ri != float(\\'inf\\'):\\n                # If we did manage to free up some rooms, assign the current meeting to \\n                # the room with the minimum index. The current meeting will start and end\\n                # at its original time.\\n                et = end\\n                ri = len(heap) if ri > len(heap) else ri\\n            else:\\n                # If no meeting ends before the start of this one...\\n                if len(heap) < N:\\n                    # If there are some empty rooms, assign this meeting to the lowest\\n                    # indexed empty room. The current meeting will start and end at its\\n                    # original time.\\n                    et, ri = end, min(len(heap), minPoppedRI)\\n                else:\\n                    # If there are no empty rooms at the moment, delay the current meeting\\n                    # till the end of the meeting which is ending the earliest (\"et\") and then\\n                    # schedule the current meeting to that room. Now the current meeting\\n                    # will start at \"et\" and end at \"et + (end - start)\"\\n                    et, ri = heappop(heap)\\n                    et += (end-start)\\n                    minPoppedRI = min(ri, minPoppedRI)\\n                \\n            heappush(heap, (et, ri))\\n            # print(start, end, et, ri, heap)\\n            counts[ri] += 1\\n\\n            if counts[ri] > maxroom[1] or (counts[ri] == maxroom[1] and maxroom[0] is not None and maxroom[0] > ri):\\n                maxroom = (ri, counts[ri])\\n\\n        # print(counts)\\n        return maxroom[0]\\n```"
                    },
                    {
                        "username": "btulsi",
                        "content": "81/82 test cases , anyone know what\\'s wrong?\\n\\n `var mostBooked = function(n, meetings) {\\n\\n    // Sort meetings by start time\\n    meetings.sort((a, b) => a[0] - b[0]);\\n\\n    let busy = [];\\n    let avail = Array.from({length: n}, (_, i) => i);\\n    const count = Array(n).fill(0);\\n\\n    for(let meeting of meetings) {\\n        const [start,end] = meeting;\\n\\n        // Shift all the rooms that are past the current start time\\n        while(busy.length && busy[0][0] <= start){\\n            const [oldEnd, room] = busy.shift();\\n            avail.push(room);\\n            avail.sort((a, b) => a - b); // Ensure available rooms are sorted\\n        }\\n\\n        let room;\\n\\n        if(avail.length) {\\n            room = avail.shift();\\n            busy.push([end,room]);\\n        } else {\\n            // Calculate the new end time\\n            const [time, roomBusy] = busy.shift();\\n            room = roomBusy;\\n            const newEnd = time < start ? end : time + (end - start);\\n            busy.push([newEnd,room]);\\n        }\\n\\n        // Sort busy rooms by their end time\\n        busy.sort((a, b) => a[0] - b[0]);\\n\\n        // Increment the count of meetings held in the room\\n        count[room] += 1;\\n    }\\n\\n    // Determine the room that held the most meetings\\n    let maxCount = 0;\\n    let maxRoom = 0;\\n    for(let i = 0; i < n; i++){\\n        if(count[i] > maxCount){\\n            maxCount = count[i];\\n            maxRoom = i;\\n        }\\n    }\\n\\n    return maxRoom;\\n};\\n`"
                    },
                    {
                        "username": "leogean3",
                        "content": "I really need help for this code. Almost all the test case I\\'ve tried gives the correct answer. But it gets wrong answer when submitting with an long input which it cannot show the complete input. In this case, I am not able to know the exact input array, which gets the wrong output with this code. Could anyone give me a hand? Thanks in advance:) \\nclass Solution {\\npublic int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a, b) -> (Integer.compare(a[0], b[0])));\\n        int[] rooms_count = new int[n];\\n        int[] rooms_end = new int[n];\\n        int max_count = 0;\\n        int max_number = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            rooms_count[i] = 0;\\n            rooms_end[i] = 0;\\n        }\\n        for(int i=0; i<meetings.length; i++)\\n        {\\n            int flag = 0;\\n            int min_finish = Integer.MAX_VALUE;\\n            int pre_min = Integer.MAX_VALUE;\\n            int finish_room = 0;\\n            for(int j=0; j<n; j++)\\n            {\\n                if (rooms_end[j] <= meetings[i][0])\\n                {\\n                    rooms_count[j] ++;\\n                    rooms_end[j] = meetings[i][1];\\n                    flag= 1;\\n                    break;\\n                }\\n                pre_min = min_finish;\\n                min_finish = Math.min(min_finish, rooms_end[j]);\\n                if (pre_min != min_finish)\\n                    finish_room = j;\\n            }\\n            if (flag == 0)\\n            {\\n                rooms_count[finish_room] ++;\\n                rooms_end[finish_room] += meetings[i][1] - meetings[i][0];\\n            }\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            int pre_max = max_count;\\n            max_count = Math.max(max_count, rooms_count[i]);\\n            if (pre_max != max_count)\\n                max_number = i;\\n        }\\n        return max_number;\\n    }\\n}"
                    },
                    {
                        "username": "josec1003",
                        "content": "Not sure what is wrong with my answer if someone can help:\\n `n=2`\\n`meetings=[[10,11],[2,10],[1,17],[9,13],[18,20]]`\\n`leet code answer=1`\\nMy answer is room zero though:\\n1. Meeting [10,11] goes in unoccupied room 0\\n2. Meeting [2,10] goes into room 0 since it will finish before [10,11]\\n3. Meeting [1,17] goes into room 1 since it is unoccupied\\n4. Meeting [9,13] goes into room 0 as [11, 15]\\n5. Meeting [18,20] goes into room 0\\n`rooms=[[[2, 10], [10, 11], [11, 15], [18, 20]], [[1, 17]]]`\\nWhere the answer is `0` not `1`"
                    },
                    {
                        "username": "roger-song",
                        "content": "you need to read the condition carefully. \\n\\nthe description says \\ncond1, Each meeting will take place in the unused room with the lowest number.\\ncond2. When a room becomes unused, meetings that have an earlier original start time should be given the room.\\n\\nSo your thought is totally wrong. I think it is better to think in sorted array by start-i(start-i is unique) .\\n[[10,11],[2,10],[1,17],[9,13],[18,20]] => [[1,17],[2,10],[9,13],[10,11],[18,20]]\\n\\n[1,17] -> room 0 (cond1. lowest number)\\n[2,10] -> room 1 \\n[9,13] -> room 1 [10,14] (cause room 0 is not finish) (cond2 earlier original start time)\\n[10,11] -> room 1 [14,15] (cause room 0 is not finish)\\n[18,20] -> room 0 (cond1. lowest number)\\n\\nso answer is 1"
                    },
                    {
                        "username": "josec1003",
                        "content": "Actually even if we do that you will get the following still making room 0 have the most meetings:\n`rooms=[[[10, 11], [11, 15], [18, 20]], [[2, 10], [10, 26]]]`\n1. Meeting [10,11] goes in unoccupied room 0\n2. Meeting [2,10] goes in unoccupied room 1\n3. Meeting [1,17]  goes into room 1 as [10, 26] since it frees up first\n4. Meeting [9,13] goes into room 0 as [11, 15] since it frees up next\n5. Meeting [18,20] goes into room 0"
                    },
                    {
                        "username": "josec1003",
                        "content": "I guess it wants all rooms to be filled before you evaluate if a lower room has availability in the time slot?"
                    },
                    {
                        "username": "navneetjain",
                        "content": "2 of the test cases are failing. can someone point me if they see any mistake. Any help is appreciated :)\\n\\n```\\nfrom queue import PriorityQueue\\n\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        vacantRoomPQ = PriorityQueue()\\n        occupiedRoomPQ = PriorityQueue()\\n\\n        for roomNo in range(n):\\n            vacantRoomPQ.put((roomNo,0))\\n        \\n        currentTime = 0\\n        currentMax = 0\\n        currentMaxRoom = -1\\n        meetingRoomId = -1\\n        meetings.sort()\\n\\n        for meeting in meetings:\\n            currentTime = meeting[0]\\n\\n            #if there are no vacant rooms, then fast forward to the end time of meeting with \\n            #least end time (if it\\'s greater than current meeting\\'s start time)\\n            if vacantRoomPQ.empty() and currentTime < occupiedRoomPQ.queue[0][0]:\\n                currentTime = occupiedRoomPQ.queue[0][0]\\n                \\n            #pop from used meeting rooms till current time is greater than equal to meeting\\'s time\\n            while not occupiedRoomPQ.empty() and occupiedRoomPQ.queue[0][0] <= currentTime:\\n                (endTime, meetingRoomId, meetingCount) = occupiedRoomPQ.get()\\n                vacantRoomPQ.put((meetingRoomId, meetingCount))\\n            \\n            (meetingRoomId, meetingCount) = vacantRoomPQ.get()\\n\\n            #Condition to update currentmax and current room with max meetings\\n            if currentMax < meetingCount+1 or (currentMax == meetingCount+1 and currentMaxRoom > meetingRoomId):\\n                currentMax = meetingCount+1\\n                currentMaxRoom = meetingRoomId\\n                \\n            #increment duration, meeting count and put in occupied rooms\\n            occupiedRoomPQ.put((currentTime+meeting[1]-meeting[0], meetingRoomId, meetingCount+1))\\n        \\n        return currentMaxRoom\\n\\n\\n```\\n"
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "[@Heman962](/Heman962) Thanks man. This was very insightful"
                    },
                    {
                        "username": "Heman962",
                        "content": "[@navneetjain](/navneetjain) can you share full code? i want to see how you are taking values if there are free items."
                    },
                    {
                        "username": "navneetjain",
                        "content": "Hey [@Heman962](/Heman962),\\n\\nThanks for the reply\\n\\nI actually did take that into consideration\\n\\n```\\n\\n            #if there are no vacant rooms, then fast forward to the end time of meeting with \\n            #least end time (if it\\'s greater than current meeting\\'s start time)\\n            if vacantRoomPQ.empty() and currentTime < occupiedRoomPQ.queue[0][0]:\\n                currentTime = occupiedRoomPQ.queue[0][0]\\n                \\n            #pop from used meeting rooms till current time is greater than equal to meeting\\'s time\\n            while not occupiedRoomPQ.empty() and occupiedRoomPQ.queue[0][0] <= currentTime:\\n                (endTime, meetingRoomId, meetingCount) = occupiedRoomPQ.get()\\n                vacantRoomPQ.put((meetingRoomId, meetingCount))\\n            \\n```\\n"
                    },
                    {
                        "username": "Heman962",
                        "content": "hey [@navneetjain](/navneetjain),\\n\\nFaced the same issue,\\n\\nyou might have missed the case where there are no free rooms, and there are mutliple busy rooms with same avaialble time. now how do we know which one to take ? the one with min room no right ? so we need to move all the busy rooms with samve ending time back to freerooms priority queue. and then pop the top one.\\n\\nnow it gets tricky here  to choose the ending time for new meeting\\ncase1:\\nTop Free room with next avaialbiity time <= new meetingtime( good use case)\\ncase2\\nTop Free room with next avaialbiity time > new meetingtime( good use case) // this room came as result of moving from busy rooms when ending times match and there were no free rooms.\\n\\nso choosing the eindig time for new meeting would be\\n Math.max(nextAvaialbleTime, newMtngStrtTime) +duration\\n\\nhere: \\nhttps://leetcode.com/problems/meeting-rooms-iii/submissions/\\n"
                    },
                    {
                        "username": "roger-song",
                        "content": "I don\\'t know why my logic is wrong. Anybody can help me?\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        unordered_map<int, vector<vector<int>>> rooms(n + 1);\\n        sort(meetings.begin(), meetings.end());\\n\\n        for (auto meeting : meetings) {\\n            bool meeting_allocated = false;\\n            int min_finish_time = 500005;\\n            int min_finish_time_idx = -1;\\n\\n            for (int idx = 0; idx < n; idx++) {\\n                if (rooms[idx].size() == 0 || rooms[idx].back()[1] <= meeting[0]) {\\n                    rooms[idx].push_back(meeting);\\n                    meeting_allocated = true;\\n                    break;\\n                }\\n                else {\\n                    if (rooms[idx].back()[1] < min_finish_time) { // update which rooms last meeting end time is most ealry. \\n                        min_finish_time = rooms[idx].back()[1];\\n                        min_finish_time_idx = idx;\\n                    }\\n                }\\n            }\\n\\n            if (meeting_allocated == false) {\\n                vector<int> tmp = { min_finish_time, meeting[1] + (min_finish_time - meeting[0]) };\\n                rooms[min_finish_time_idx].push_back(tmp);\\n            }\\n        }\\n\\n        int max_meeting_room = 0;\\n        int max_meeting_cnt = -1;\\n        for (int idx = 0; idx < n; idx++) {\\n            if ((int)rooms[idx].size() > max_meeting_cnt) {\\n                max_meeting_cnt = rooms[idx].size();\\n                max_meeting_room = idx;\\n            }\\n        }\\n\\n        return max_meeting_room;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "roger-song",
                        "content": "I found it myself. \\n\\nI missed data type of the data structure. The number can be maxed to 5e9, so the data type could be long. thx"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This question really grinds my gears , I know it has something to do with heap but maintaining the heap of current meeting is something i was not able to figure out at all"
                    }
                ]
            },
            {
                "id": 1638562,
                "content": [
                    {
                        "username": "strangeranda",
                        "content": "Calculate Delay for only `current` meeting, not everything, "
                    },
                    {
                        "username": "superZero",
                        "content": "But why? All meetings that have start time less than the end time of the busy room should be delayed isn\\'t it? In reality, all such meetings run late until there are rooms available. "
                    },
                    {
                        "username": "strangeranda",
                        "content": "EDIT: This is solved. the idea here is calculate the delay just for one meeting, not anything else. \n\nCan someone help me here? [[39,49],[28,39],[9,29],[10,36],[22,47],[2,3],[4,49],[46,50],[45,50],[17,33]]\nThe expected is 0, but Im getting 1. \n\nIm storing a list of (end Time, room), and the last iteration is [(62,2), (66,0)], and the last meeting is [62,66] (taking the delay into consideration). \n\nIm under the impression that we free the room 2 and assign the meeting to room1 since it is lower index of two rooms available. which makes the count as {0:3, 1:4, 2:2}\n\nand it returns 1 as the most frequently used room. but the answer expected is 0."
                    },
                    {
                        "username": "naveenky",
                        "content": "Failing for this case: n = 4, meeting = [[12,44],[27,37],[48,49],[46,49],[24,44],[32,38],[21,49],[13,30]]\\nsolution should be:\\n3, 3, 1 ,1. \\n0: (12, 44) (46, 49) (48, 49)\\n1: (13, 30) (27, 37) (32, 38)\\n2: (21, 49)\\n3: (24, 44)\\n\\nbut reported output is 2, 4, 1, 1.\\nCan someone please explain how this output is coming?\\n"
                    },
                    {
                        "username": "Priyansh1210",
                        "content": "Passing 79/82 test cases. Can someone help me? Explained my reasoning with code comments.\\n\\nFails on the following test case: n=2; meetings=[[43,44],[34,36],[11,47],[1,8],[30,33],[45,48],[23,41],[29,30]])\\nO/P: 0; Expected O/P=1\\n\\n```\\nfrom heapq import heappush, heappop, heapify\\n\\nclass Solution:\\n    def mostBooked(self, N: int, meetings: List[List[int]]) -> int:\\n        meetings = sorted(meetings, key=lambda x: (x[0], x[1]))\\n        M = len(meetings)\\n        \\n        # end_time, room_index\\n        heap = []\\n\\n        counts = {i: 0 for i in range(N)}\\n        maxroom = (None, float(\\'-inf\\'))\\n        minPoppedRI = float(\\'inf\\')\\n        for i in range(M):\\n            start, end = meetings[i]\\n\\n            # et = End time of the next meeting which will be assigned to a room at the\\n            # end of this iteration.\\n            # ri = Index of the room which the current meeting will be assigned to. We\\'ll\\n            # make sure that this is the mimimum indexed room which is available at the \\n            # start of this meeting.\\n            et, ri = None, float(\\'inf\\')\\n\\n            # Free up all rooms which are holding meetings with end time less than the\\n            # start of the current meeting and keep track of the minimum indexed room.\\n            while heap and start > heap[0][0]:\\n                popped_et, popped_ri = heappop(heap)\\n                if popped_ri < ri:\\n                    et, ri = popped_et, popped_ri\\n                minPoppedRI = min(popped_ri, minPoppedRI)\\n\\n            if ri != float(\\'inf\\'):\\n                # If we did manage to free up some rooms, assign the current meeting to \\n                # the room with the minimum index. The current meeting will start and end\\n                # at its original time.\\n                et = end\\n                ri = len(heap) if ri > len(heap) else ri\\n            else:\\n                # If no meeting ends before the start of this one...\\n                if len(heap) < N:\\n                    # If there are some empty rooms, assign this meeting to the lowest\\n                    # indexed empty room. The current meeting will start and end at its\\n                    # original time.\\n                    et, ri = end, min(len(heap), minPoppedRI)\\n                else:\\n                    # If there are no empty rooms at the moment, delay the current meeting\\n                    # till the end of the meeting which is ending the earliest (\"et\") and then\\n                    # schedule the current meeting to that room. Now the current meeting\\n                    # will start at \"et\" and end at \"et + (end - start)\"\\n                    et, ri = heappop(heap)\\n                    et += (end-start)\\n                    minPoppedRI = min(ri, minPoppedRI)\\n                \\n            heappush(heap, (et, ri))\\n            # print(start, end, et, ri, heap)\\n            counts[ri] += 1\\n\\n            if counts[ri] > maxroom[1] or (counts[ri] == maxroom[1] and maxroom[0] is not None and maxroom[0] > ri):\\n                maxroom = (ri, counts[ri])\\n\\n        # print(counts)\\n        return maxroom[0]\\n```"
                    },
                    {
                        "username": "btulsi",
                        "content": "81/82 test cases , anyone know what\\'s wrong?\\n\\n `var mostBooked = function(n, meetings) {\\n\\n    // Sort meetings by start time\\n    meetings.sort((a, b) => a[0] - b[0]);\\n\\n    let busy = [];\\n    let avail = Array.from({length: n}, (_, i) => i);\\n    const count = Array(n).fill(0);\\n\\n    for(let meeting of meetings) {\\n        const [start,end] = meeting;\\n\\n        // Shift all the rooms that are past the current start time\\n        while(busy.length && busy[0][0] <= start){\\n            const [oldEnd, room] = busy.shift();\\n            avail.push(room);\\n            avail.sort((a, b) => a - b); // Ensure available rooms are sorted\\n        }\\n\\n        let room;\\n\\n        if(avail.length) {\\n            room = avail.shift();\\n            busy.push([end,room]);\\n        } else {\\n            // Calculate the new end time\\n            const [time, roomBusy] = busy.shift();\\n            room = roomBusy;\\n            const newEnd = time < start ? end : time + (end - start);\\n            busy.push([newEnd,room]);\\n        }\\n\\n        // Sort busy rooms by their end time\\n        busy.sort((a, b) => a[0] - b[0]);\\n\\n        // Increment the count of meetings held in the room\\n        count[room] += 1;\\n    }\\n\\n    // Determine the room that held the most meetings\\n    let maxCount = 0;\\n    let maxRoom = 0;\\n    for(let i = 0; i < n; i++){\\n        if(count[i] > maxCount){\\n            maxCount = count[i];\\n            maxRoom = i;\\n        }\\n    }\\n\\n    return maxRoom;\\n};\\n`"
                    },
                    {
                        "username": "leogean3",
                        "content": "I really need help for this code. Almost all the test case I\\'ve tried gives the correct answer. But it gets wrong answer when submitting with an long input which it cannot show the complete input. In this case, I am not able to know the exact input array, which gets the wrong output with this code. Could anyone give me a hand? Thanks in advance:) \\nclass Solution {\\npublic int mostBooked(int n, int[][] meetings) {\\n        Arrays.sort(meetings, (a, b) -> (Integer.compare(a[0], b[0])));\\n        int[] rooms_count = new int[n];\\n        int[] rooms_end = new int[n];\\n        int max_count = 0;\\n        int max_number = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            rooms_count[i] = 0;\\n            rooms_end[i] = 0;\\n        }\\n        for(int i=0; i<meetings.length; i++)\\n        {\\n            int flag = 0;\\n            int min_finish = Integer.MAX_VALUE;\\n            int pre_min = Integer.MAX_VALUE;\\n            int finish_room = 0;\\n            for(int j=0; j<n; j++)\\n            {\\n                if (rooms_end[j] <= meetings[i][0])\\n                {\\n                    rooms_count[j] ++;\\n                    rooms_end[j] = meetings[i][1];\\n                    flag= 1;\\n                    break;\\n                }\\n                pre_min = min_finish;\\n                min_finish = Math.min(min_finish, rooms_end[j]);\\n                if (pre_min != min_finish)\\n                    finish_room = j;\\n            }\\n            if (flag == 0)\\n            {\\n                rooms_count[finish_room] ++;\\n                rooms_end[finish_room] += meetings[i][1] - meetings[i][0];\\n            }\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            int pre_max = max_count;\\n            max_count = Math.max(max_count, rooms_count[i]);\\n            if (pre_max != max_count)\\n                max_number = i;\\n        }\\n        return max_number;\\n    }\\n}"
                    },
                    {
                        "username": "josec1003",
                        "content": "Not sure what is wrong with my answer if someone can help:\\n `n=2`\\n`meetings=[[10,11],[2,10],[1,17],[9,13],[18,20]]`\\n`leet code answer=1`\\nMy answer is room zero though:\\n1. Meeting [10,11] goes in unoccupied room 0\\n2. Meeting [2,10] goes into room 0 since it will finish before [10,11]\\n3. Meeting [1,17] goes into room 1 since it is unoccupied\\n4. Meeting [9,13] goes into room 0 as [11, 15]\\n5. Meeting [18,20] goes into room 0\\n`rooms=[[[2, 10], [10, 11], [11, 15], [18, 20]], [[1, 17]]]`\\nWhere the answer is `0` not `1`"
                    },
                    {
                        "username": "roger-song",
                        "content": "you need to read the condition carefully. \\n\\nthe description says \\ncond1, Each meeting will take place in the unused room with the lowest number.\\ncond2. When a room becomes unused, meetings that have an earlier original start time should be given the room.\\n\\nSo your thought is totally wrong. I think it is better to think in sorted array by start-i(start-i is unique) .\\n[[10,11],[2,10],[1,17],[9,13],[18,20]] => [[1,17],[2,10],[9,13],[10,11],[18,20]]\\n\\n[1,17] -> room 0 (cond1. lowest number)\\n[2,10] -> room 1 \\n[9,13] -> room 1 [10,14] (cause room 0 is not finish) (cond2 earlier original start time)\\n[10,11] -> room 1 [14,15] (cause room 0 is not finish)\\n[18,20] -> room 0 (cond1. lowest number)\\n\\nso answer is 1"
                    },
                    {
                        "username": "josec1003",
                        "content": "Actually even if we do that you will get the following still making room 0 have the most meetings:\n`rooms=[[[10, 11], [11, 15], [18, 20]], [[2, 10], [10, 26]]]`\n1. Meeting [10,11] goes in unoccupied room 0\n2. Meeting [2,10] goes in unoccupied room 1\n3. Meeting [1,17]  goes into room 1 as [10, 26] since it frees up first\n4. Meeting [9,13] goes into room 0 as [11, 15] since it frees up next\n5. Meeting [18,20] goes into room 0"
                    },
                    {
                        "username": "josec1003",
                        "content": "I guess it wants all rooms to be filled before you evaluate if a lower room has availability in the time slot?"
                    },
                    {
                        "username": "navneetjain",
                        "content": "2 of the test cases are failing. can someone point me if they see any mistake. Any help is appreciated :)\\n\\n```\\nfrom queue import PriorityQueue\\n\\nclass Solution:\\n    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\\n        vacantRoomPQ = PriorityQueue()\\n        occupiedRoomPQ = PriorityQueue()\\n\\n        for roomNo in range(n):\\n            vacantRoomPQ.put((roomNo,0))\\n        \\n        currentTime = 0\\n        currentMax = 0\\n        currentMaxRoom = -1\\n        meetingRoomId = -1\\n        meetings.sort()\\n\\n        for meeting in meetings:\\n            currentTime = meeting[0]\\n\\n            #if there are no vacant rooms, then fast forward to the end time of meeting with \\n            #least end time (if it\\'s greater than current meeting\\'s start time)\\n            if vacantRoomPQ.empty() and currentTime < occupiedRoomPQ.queue[0][0]:\\n                currentTime = occupiedRoomPQ.queue[0][0]\\n                \\n            #pop from used meeting rooms till current time is greater than equal to meeting\\'s time\\n            while not occupiedRoomPQ.empty() and occupiedRoomPQ.queue[0][0] <= currentTime:\\n                (endTime, meetingRoomId, meetingCount) = occupiedRoomPQ.get()\\n                vacantRoomPQ.put((meetingRoomId, meetingCount))\\n            \\n            (meetingRoomId, meetingCount) = vacantRoomPQ.get()\\n\\n            #Condition to update currentmax and current room with max meetings\\n            if currentMax < meetingCount+1 or (currentMax == meetingCount+1 and currentMaxRoom > meetingRoomId):\\n                currentMax = meetingCount+1\\n                currentMaxRoom = meetingRoomId\\n                \\n            #increment duration, meeting count and put in occupied rooms\\n            occupiedRoomPQ.put((currentTime+meeting[1]-meeting[0], meetingRoomId, meetingCount+1))\\n        \\n        return currentMaxRoom\\n\\n\\n```\\n"
                    },
                    {
                        "username": "raghavjanamanchi",
                        "content": "[@Heman962](/Heman962) Thanks man. This was very insightful"
                    },
                    {
                        "username": "Heman962",
                        "content": "[@navneetjain](/navneetjain) can you share full code? i want to see how you are taking values if there are free items."
                    },
                    {
                        "username": "navneetjain",
                        "content": "Hey [@Heman962](/Heman962),\\n\\nThanks for the reply\\n\\nI actually did take that into consideration\\n\\n```\\n\\n            #if there are no vacant rooms, then fast forward to the end time of meeting with \\n            #least end time (if it\\'s greater than current meeting\\'s start time)\\n            if vacantRoomPQ.empty() and currentTime < occupiedRoomPQ.queue[0][0]:\\n                currentTime = occupiedRoomPQ.queue[0][0]\\n                \\n            #pop from used meeting rooms till current time is greater than equal to meeting\\'s time\\n            while not occupiedRoomPQ.empty() and occupiedRoomPQ.queue[0][0] <= currentTime:\\n                (endTime, meetingRoomId, meetingCount) = occupiedRoomPQ.get()\\n                vacantRoomPQ.put((meetingRoomId, meetingCount))\\n            \\n```\\n"
                    },
                    {
                        "username": "Heman962",
                        "content": "hey [@navneetjain](/navneetjain),\\n\\nFaced the same issue,\\n\\nyou might have missed the case where there are no free rooms, and there are mutliple busy rooms with same avaialble time. now how do we know which one to take ? the one with min room no right ? so we need to move all the busy rooms with samve ending time back to freerooms priority queue. and then pop the top one.\\n\\nnow it gets tricky here  to choose the ending time for new meeting\\ncase1:\\nTop Free room with next avaialbiity time <= new meetingtime( good use case)\\ncase2\\nTop Free room with next avaialbiity time > new meetingtime( good use case) // this room came as result of moving from busy rooms when ending times match and there were no free rooms.\\n\\nso choosing the eindig time for new meeting would be\\n Math.max(nextAvaialbleTime, newMtngStrtTime) +duration\\n\\nhere: \\nhttps://leetcode.com/problems/meeting-rooms-iii/submissions/\\n"
                    },
                    {
                        "username": "roger-song",
                        "content": "I don\\'t know why my logic is wrong. Anybody can help me?\\n```\\nclass Solution {\\npublic:\\n    int mostBooked(int n, vector<vector<int>>& meetings) {\\n        unordered_map<int, vector<vector<int>>> rooms(n + 1);\\n        sort(meetings.begin(), meetings.end());\\n\\n        for (auto meeting : meetings) {\\n            bool meeting_allocated = false;\\n            int min_finish_time = 500005;\\n            int min_finish_time_idx = -1;\\n\\n            for (int idx = 0; idx < n; idx++) {\\n                if (rooms[idx].size() == 0 || rooms[idx].back()[1] <= meeting[0]) {\\n                    rooms[idx].push_back(meeting);\\n                    meeting_allocated = true;\\n                    break;\\n                }\\n                else {\\n                    if (rooms[idx].back()[1] < min_finish_time) { // update which rooms last meeting end time is most ealry. \\n                        min_finish_time = rooms[idx].back()[1];\\n                        min_finish_time_idx = idx;\\n                    }\\n                }\\n            }\\n\\n            if (meeting_allocated == false) {\\n                vector<int> tmp = { min_finish_time, meeting[1] + (min_finish_time - meeting[0]) };\\n                rooms[min_finish_time_idx].push_back(tmp);\\n            }\\n        }\\n\\n        int max_meeting_room = 0;\\n        int max_meeting_cnt = -1;\\n        for (int idx = 0; idx < n; idx++) {\\n            if ((int)rooms[idx].size() > max_meeting_cnt) {\\n                max_meeting_cnt = rooms[idx].size();\\n                max_meeting_room = idx;\\n            }\\n        }\\n\\n        return max_meeting_room;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "roger-song",
                        "content": "I found it myself. \\n\\nI missed data type of the data structure. The number can be maxed to 5e9, so the data type could be long. thx"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This question really grinds my gears , I know it has something to do with heap but maintaining the heap of current meeting is something i was not able to figure out at all"
                    }
                ]
            }
        ]
    }
]